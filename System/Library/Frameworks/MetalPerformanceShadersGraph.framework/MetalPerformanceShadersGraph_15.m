mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::A17,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t *a8, uint64_t a9, uint64_t a10)
{
  uint64_t *Context;
  uint64_t v19;
  char v20;
  int v21;
  mlir::GenericProgramPoint *v22;
  mlir::GenericProgramPoint *v23;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  uint64_t v28[4];
  __int16 v29;
  _QWORD v30[40];

  v30[38] = *MEMORY[0x1E0C80C00];
  v25 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.A17", (const unsigned __int8 *)8, Context);
  if (!v20)
  {
    v29 = 1283;
    v28[2] = (uint64_t)"anec.A17";
    v28[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v19);
  mlir::anec::A11Legacy::build((uint64_t)a1, (uint64_t)v30, *(void **)a3, *(_QWORD *)(a3 + 8), a4, *(void **)a5, *(_QWORD *)(a5 + 8), v21, *a6, a6[1], *(_QWORD **)a7, *(_QWORD *)(a7 + 8), *a8, a8[1], *(mlir::Operation ***)a9, *(_QWORD *)(a9 + 8), *(void **)a10, *(_QWORD *)(a10 + 8));
  v22 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((_QWORD *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A17,void>::id)
    v23 = v22;
  else
    v23 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::A11Legacy,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t *a8, uint64_t a9, uint64_t a10)
{
  uint64_t *Context;
  uint64_t v19;
  char v20;
  int v21;
  mlir::GenericProgramPoint *v22;
  mlir::GenericProgramPoint *v23;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  uint64_t v28[4];
  __int16 v29;
  _QWORD v30[40];

  v30[38] = *MEMORY[0x1E0C80C00];
  v25 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.A11Legacy", (const unsigned __int8 *)0xE, Context);
  if (!v20)
  {
    v29 = 1283;
    v28[2] = (uint64_t)"anec.A11Legacy";
    v28[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v19);
  mlir::anec::A11Legacy::build((uint64_t)a1, (uint64_t)v30, *(void **)a3, *(_QWORD *)(a3 + 8), a4, *(void **)a5, *(_QWORD *)(a5 + 8), v21, *a6, a6[1], *(_QWORD **)a7, *(_QWORD *)(a7 + 8), *a8, a8[1], *(mlir::Operation ***)a9, *(_QWORD *)(a9 + 8), *(void **)a10, *(_QWORD *)(a10 + 8));
  v22 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((_QWORD *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::A11Legacy,void>::id)
    v23 = v22;
  else
    v23 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

uint64_t mlir::`anonymous namespace'::GPUDeviceInterface::getConvertedTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  void *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  v14 = 0;
  if (a3)
  {
    v7 = 0;
    v8 = (void *)(a4 + 16);
    do
    {
      v9 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v13, v7) + 8);
      v10 = *(unsigned int *)(a4 + 8);
      if (v10 >= *(unsigned int *)(a4 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4, v8, v10 + 1, 8);
        v10 = *(unsigned int *)(a4 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a4 + 8 * v10) = v9 & 0xFFFFFFFFFFFFFFF8;
      ++*(_DWORD *)(a4 + 8);
      v7 = ++v14;
    }
    while (v13 != a2 || v7 != a3);
  }
  return 1;
}

uint64_t mlir::`anonymous namespace'::GPUDeviceInterface::getConvertedType(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  *a3 = *(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

mlir::GenericProgramPoint *mlir::`anonymous namespace'::GPUDeviceInterface::materializeRegion(uint64_t a1, mlir::OpBuilder *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  mlir::GenericProgramPoint *v18;
  mlir::GenericProgramPoint *v19;
  _QWORD v21[2];
  _QWORD v22[2];
  _QWORD v23[2];
  uint64_t v24[2];
  _QWORD v25[2];
  uint64_t v26[2];
  _QWORD v27[3];

  v27[2] = *MEMORY[0x1E0C80C00];
  v23[0] = a4;
  v23[1] = a5;
  v27[0] = a7;
  v27[1] = a8;
  v26[0] = a9;
  v26[1] = a10;
  v25[0] = a11;
  v25[1] = a12;
  v24[0] = a13;
  v24[1] = a14;
  v22[0] = a15;
  v22[1] = a16;
  v21[0] = a17;
  v21[1] = a18;
  v18 = mlir::OpBuilder::create<mlir::mpsx::GPUOp,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(a2, a3, (uint64_t)v23, a6, (uint64_t)v27, v26, (uint64_t)v25, v24, (uint64_t)v22, (uint64_t)v21);
  v19 = v18;
  if (v18)
    mlir::OpInterface<mlir::FormableRegionOpInterface,mlir::detail::FormableRegionOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)v18);
  return v19;
}

uint64_t mlir::`anonymous namespace'::GPUDeviceInterface::materializeHostTypeConversion(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  char v9;
  _QWORD *v10;
  unint64_t v12;
  _QWORD *v13;

  v12 = a4;
  v13 = 0;
  v9 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>(a7, &v12, &v13);
  v10 = v13;
  if ((v9 & 1) == 0)
  {
    v10 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)a7, (uint64_t)&v12, &v12, v13);
    *v10 = v12;
    v10[1] = 0;
  }
  v10[1] = a4;
  return 1;
}

mlir::GenericProgramPoint *mlir::`anonymous namespace'::GPUDeviceInterface::materializeCallOp(uint64_t a1, mlir::MLIRContext **a2, uint64_t a3, mlir::SymbolRefAttr *a4, uint64_t a5, uint64_t a6)
{
  int v7;
  mlir::SymbolRefAttr *v8;
  uint64_t v9[3];

  v9[2] = *MEMORY[0x1E0C80C00];
  v9[0] = a5;
  v9[1] = a6;
  v8 = a4;
  v7 = 0;
  return mlir::OpBuilder::create<mlir::placement::RegionCall,mlir::Operation *&,mlir::placement::RegionType,mlir::ValueRange &>(a2, a3, &v8, &v7, v9);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::GPUOp,llvm::StringRef &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t *a8, uint64_t a9, uint64_t a10)
{
  uint64_t *Context;
  uint64_t v19;
  char v20;
  int v21;
  mlir::GenericProgramPoint *v22;
  mlir::GenericProgramPoint *v23;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  uint64_t v28[4];
  __int16 v29;
  _QWORD v30[40];

  v30[38] = *MEMORY[0x1E0C80C00];
  v25 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.gpu", (const unsigned __int8 *)8, Context);
  if (!v20)
  {
    v29 = 1283;
    v28[2] = (uint64_t)"mpsx.gpu";
    v28[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v19);
  mlir::mpsx::ANEOp::build((uint64_t)a1, (uint64_t)v30, *(void **)a3, *(_QWORD *)(a3 + 8), a4, *(void **)a5, *(_QWORD *)(a5 + 8), v21, *a6, a6[1], *(_QWORD **)a7, *(_QWORD *)(a7 + 8), *a8, a8[1], *(mlir::Operation ***)a9, *(_QWORD *)(a9 + 8), *(void **)a10, *(_QWORD *)(a10 + 8));
  v22 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((_QWORD *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::GPUOp,void>::id)
    v23 = v22;
  else
    v23 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

BOOL mlir::verifyANECompatibleElementType(_QWORD *a1)
{
  uint64_t ElementTypeOrSelf;
  uint64_t v3;

  ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
  v3 = ElementTypeOrSelf;
  if (ElementTypeOrSelf
    && *(_UNKNOWN **)(*(_QWORD *)ElementTypeOrSelf + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
  {
    v3 = mlir::MPSToANECTypeConverter::canonicalizeIntegerType(ElementTypeOrSelf);
  }
  return mlir::Type::isF16((mlir::Type *)&v3)
      || mlir::Type::isSignedInteger((mlir::Type *)&v3, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&v3, 8);
}

uint64_t *mlir::verifyANECompatibleType(uint64_t *a1, int a2)
{
  uint64_t *result;
  uint64_t v5;
  uint64_t v6;
  uint64_t ElementTypeOrSelf;
  _QWORD v8[2];
  uint64_t v9;

  result = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible(a1);
  v8[0] = result;
  v8[1] = v5;
  if (result)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v8);
    if (a2 <= 1 && v6 == 5)
    {
      return 0;
    }
    else
    {
      ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
      v9 = ElementTypeOrSelf;
      if (ElementTypeOrSelf
        && *(_UNKNOWN **)(*(_QWORD *)ElementTypeOrSelf + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      {
        v9 = mlir::MPSToANECTypeConverter::canonicalizeIntegerType(ElementTypeOrSelf);
      }
      if (mlir::Type::isF16((mlir::Type *)&v9) || mlir::Type::isSignedInteger((mlir::Type *)&v9, 8))
        return (uint64_t *)1;
      else
        return (uint64_t *)mlir::Type::isUnsignedInteger((mlir::Type *)&v9, 8);
    }
  }
  return result;
}

BOOL mlir::verifyCompatibleTypesWithANE(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v8;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t DefiningOp;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t NextResultAtOffset;
  uint64_t v20;

  v8 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v8))
    return *(_QWORD *)(*(_QWORD *)mlir::getElementTypeOrSelf(a1 - 16) + 136) != (_QWORD)&mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id;
  if (a3 && (*(_BYTE *)(a1 + 46) & 0x80) != 0 && (v10 = *(unsigned int *)(a1 + 68), (_DWORD)v10))
  {
    v11 = (uint64_t *)(*(_QWORD *)(a1 + 72) + 24);
    while (1)
    {
      v12 = *v11;
      v20 = *v11;
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v20);
      if (!DefiningOp
        || (v14 = DefiningOp,
            v15 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
            !(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v14 + 48) + 32))(*(_QWORD *)(v14 + 48), v15))|| *(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf(v12) + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
      {
        if (!mlir::verifyANECompatibleType((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8), a2))break;
      }
      v11 += 4;
      if (!--v10)
        goto LABEL_13;
    }
  }
  else
  {
LABEL_13:
    if (!a4)
      return 1;
    v16 = *(unsigned int *)(a1 + 36);
    v17 = (_DWORD)v16 ? a1 - 16 : 0;
    if (!(_DWORD)v16)
      return 1;
    v18 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v17, v18);
      if (!mlir::verifyANECompatibleType((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), a2))break;
      if (v16 == ++v18)
        return 1;
    }
  }
  return 0;
}

uint64_t mlir::materializeMPSToANECHostTypeConversion(mlir::UnknownLoc **a1, uint64_t a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, uint64_t a6)
{
  _QWORD *v7;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t *v16;
  _QWORD *v17;
  unint64_t v18;
  _QWORD *v19;
  uint64_t ArgAttrsAttr;
  uint64_t v21;
  uint64_t v22;
  uint64_t OperandRange;
  uint64_t v24;
  _QWORD *v25;
  void *v26;
  void *Value;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t canMapOperands;
  uint64_t MemorySpace;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  char v47;
  _QWORD *v48;
  void *v49;
  uint64_t DefiningOp;
  void *v51;
  BOOL v52;
  char *v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  const void *v68;
  uint64_t v69;
  uint64_t v70;
  const void *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  char v85;
  _QWORD *v86;
  char v87;
  _QWORD *v88;
  _QWORD *Input;
  uint64_t ElementTypeOrSelf;
  char *v91;
  char v92;
  _QWORD *v93;
  uint64_t v94;
  _QWORD *v95;
  uint64_t v96;
  char v97;
  _QWORD *v98;
  char *v100;
  _QWORD *RawStringData;
  uint64_t v102;
  uint64_t v103;
  _QWORD *v104[2];
  _QWORD *v105[2];
  uint64_t v106;
  _QWORD *v107;

  v105[1] = a5;
  v106 = (uint64_t)a3;
  v105[0] = a4;
  v7 = (_QWORD *)(a3[1] & 0xFFFFFFFFFFFFFFF8);
  if (a4 == v7)
  {
    RawStringData = a3;
    v104[0] = 0;
    v47 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&RawStringData, v104);
    v48 = v104[0];
    if ((v47 & 1) == 0)
    {
      v48 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a6, (uint64_t)&RawStringData, (unint64_t *)&RawStringData, v104[0]);
      *v48 = RawStringData;
      v48[1] = 0;
    }
    v48[1] = a3;
  }
  else
  {
    if (!v7)
      goto LABEL_11;
    v10 = *v7;
    v11 = mlir::TypeID::get<mlir::ShapedType>();
    v12 = *(unsigned int *)(v10 + 16);
    if (!(_DWORD)v12)
      goto LABEL_11;
    v13 = *(_QWORD **)(v10 + 8);
    v14 = &v13[2 * v12];
    do
    {
      v15 = v12 >> 1;
      v16 = &v13[2 * (v12 >> 1)];
      v18 = *v16;
      v17 = v16 + 2;
      v12 += ~(v12 >> 1);
      if (v18 < v11)
        v13 = v17;
      else
        v12 = v15;
    }
    while (v12);
    if (v13 != v14 && *v13 == v11)
      v19 = (_QWORD *)v13[1];
    else
LABEL_11:
      v19 = 0;
    v104[0] = v7;
    v104[1] = v19;
    ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105);
    v22 = v21;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
    v24 = mlir::RankedTensorType::get(ArgAttrsAttr, v22, OperandRange, 0);
    v103 = 0;
    v25 = v105[0];
    v26 = *(void **)(*v105[0] + 136);
    if (v26 != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
      v25 = 0;
    v107 = v25;
    if (v26 == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
    {
      Value = (void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v107);
      v29 = v28;
      v30 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
      RawStringData = (_QWORD *)mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&v107);
      v102 = v31;
      canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&RawStringData);
      MemorySpace = mlir::MemRefType::getMemorySpace((mlir::MemRefType *)&v107);
      v103 = mlir::MemRefType::get(Value, v29, v30, canMapOperands, MemorySpace);
    }
    v34 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v104);
    v35 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
    v36 = *(void **)(*v105[0] + 136);
    if (v36 == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
    {
      v49 = *(void **)(*v104[0] + 136);
      if (v49 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      {
        v66 = (_QWORD *)v106;
        v67 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
        RawStringData = v66;
        v107 = (_QWORD *)v67;
        if (v34 != v35)
          v66 = (_QWORD *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16);
        v100 = (char *)v66;
        v68 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v104);
        v70 = v69;
        v71 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105);
        if (v70 != v72 || memcmp(v68, v71, 8 * v70))
        {
          v73 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
          RawStringData = v66;
          v107 = (_QWORD *)v73;
          if (v34 != v35)
            v66 = (_QWORD *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16);
          v107 = v66;
          RawStringData = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105);
          v102 = v74;
          v100 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::ArrayRef<long long>>((mlir::Builder *)a1, a2, (uint64_t *)&v107, (uint64_t)&RawStringData)- 16;
        }
        v45 = (char *)mlir::OpBuilder::create<mlir::placement::TensorToMemref,mlir::Value &>(a1, a2, &v100) - 16;
        v107 = (_QWORD *)v106;
LABEL_65:
        RawStringData = 0;
        v87 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&v107, &RawStringData);
        v88 = RawStringData;
        if ((v87 & 1) == 0)
        {
          v88 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a6, (uint64_t)&v107, (unint64_t *)&v107, RawStringData);
          *v88 = v107;
          v88[1] = 0;
        }
        v88[1] = v45;
        return 1;
      }
      if (v49 == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
      {
        DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v106);
        if (DefiningOp
          && ((v51 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16),
               v52 = v51 == &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id,
               v51 != &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id)
            ? (v53 = 0)
            : (v53 = (char *)DefiningOp),
              v100 = v53,
              v52))
        {
          Input = (_QWORD *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v100);
          ElementTypeOrSelf = mlir::getElementTypeOrSelf(v105[0]);
          RawStringData = Input;
          v107 = (_QWORD *)ElementTypeOrSelf;
          if (v34 != v35)
            Input = (_QWORD *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16);
          RawStringData = Input;
          v91 = (char *)mlir::OpBuilder::create<mlir::placement::TensorToMemref,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)a1, a2, (uint64_t)&v103, (uint64_t)&RawStringData)- 16;
          v107 = (_QWORD *)v106;
          RawStringData = 0;
          v92 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&v107, &RawStringData);
          v93 = RawStringData;
          if ((v92 & 1) == 0)
          {
            v93 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a6, (uint64_t)&v107, (unint64_t *)&v107, RawStringData);
            *v93 = v107;
            v93[1] = 0;
          }
          v93[1] = v91;
        }
        else
        {
          v54 = *(_QWORD **)v106;
          if (*(_QWORD *)v106)
          {
            if (!*v54)
            {
              v55 = v54[2];
              if (v55)
              {
                if (*(_UNKNOWN **)(*(_QWORD *)(v55 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::HostTypeCast,void>::id)
                {
                  v56 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v104);
                  v58 = v57;
                  v59 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
                  v60 = mlir::RankedTensorType::get(v56, v58, v59, 0);
                  v61 = (char *)mlir::OpBuilder::create<mlir::placement::MemrefToTensor,mlir::Value &>(a1, a2, &v106)
                      - 16;
                  if (v60 != v24)
                  {
                    v62 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
                    RawStringData = v61;
                    v107 = (_QWORD *)v62;
                    if (v34 != v35)
                      v61 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16;
                    v107 = v61;
                    RawStringData = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105);
                    v102 = v63;
                    v61 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::ArrayRef<long long>>((mlir::Builder *)a1, a2, (uint64_t *)&v107, (uint64_t)&RawStringData)- 16;
                  }
                  v64 = v106;
                  v65 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
                  RawStringData = v61;
                  v107 = (_QWORD *)v65;
                  if (v34 != v35)
                    v61 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16;
                  mlir::IRMapping::map((uint64_t *)a6, v64, (uint64_t)v61);
                }
              }
            }
          }
        }
        v94 = v106;
        v107 = (_QWORD *)v106;
        RawStringData = 0;
        v95 = (_QWORD *)v106;
        if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&v107, &RawStringData))
        {
          v95 = (_QWORD *)v94;
          if (RawStringData != (_QWORD *)(*(_QWORD *)a6 + 16 * *(unsigned int *)(a6 + 16)))
            v95 = (_QWORD *)RawStringData[1];
        }
        v96 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
        RawStringData = v95;
        v107 = (_QWORD *)v96;
        if (v34 != v35)
          v95 = (_QWORD *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16);
        v107 = (_QWORD *)v94;
        RawStringData = 0;
        v97 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&v107, &RawStringData);
        v98 = RawStringData;
        if ((v97 & 1) == 0)
        {
          v98 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a6, (uint64_t)&v107, (unint64_t *)&v107, RawStringData);
          *v98 = v107;
          v98[1] = 0;
        }
        v98[1] = v95;
      }
    }
    else
    {
      if (v36 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
        return 1;
      if (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v106 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
      {
        if (*(_UNKNOWN **)(*v104[0] + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
          return 1;
        v37 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v104);
        v39 = v38;
        v40 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
        v41 = mlir::RankedTensorType::get(v37, v39, v40, 0);
        v42 = (_QWORD *)v106;
        if (v41 == v24)
        {
          v45 = (char *)v106;
        }
        else
        {
          v43 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
          RawStringData = v42;
          v107 = (_QWORD *)v43;
          if (v34 != v35)
            v42 = (_QWORD *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16);
          v107 = v42;
          RawStringData = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105);
          v102 = v44;
          v45 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::ArrayRef<long long>>((mlir::Builder *)a1, a2, (uint64_t *)&v107, (uint64_t)&RawStringData)- 16;
          v42 = (_QWORD *)v106;
        }
        v107 = v42;
        goto LABEL_65;
      }
      v75 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v104);
      v77 = v76;
      v78 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
      v79 = mlir::RankedTensorType::get(v75, v77, v78, 0);
      v80 = (char *)mlir::OpBuilder::create<mlir::placement::MemrefToTensor,mlir::Value &>(a1, a2, &v106) - 16;
      if (v79 != v24)
      {
        v81 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
        RawStringData = v80;
        v107 = (_QWORD *)v81;
        if (v34 != v35)
          v80 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16;
        v107 = v80;
        RawStringData = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105);
        v102 = v82;
        v80 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::ArrayRef<long long>>((mlir::Builder *)a1, a2, (uint64_t *)&v107, (uint64_t)&RawStringData)- 16;
      }
      v83 = v106;
      v84 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v105);
      RawStringData = v80;
      v107 = (_QWORD *)v84;
      if (v34 != v35)
        v80 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a1, a2, (uint64_t *)&RawStringData, (uint64_t *)&v107)- 16;
      v107 = (_QWORD *)v83;
      RawStringData = 0;
      v85 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a6, (unint64_t *)&v107, &RawStringData);
      v86 = RawStringData;
      if ((v85 & 1) == 0)
      {
        v86 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a6, (uint64_t)&v107, (unint64_t *)&v107, RawStringData);
        *v86 = v107;
        v86[1] = 0;
      }
      v86[1] = v80;
    }
  }
  return 1;
}

uint64_t mlir::IRMapping::map(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t result;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;

  v7 = a2;
  v8 = 0;
  result = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>(a1, &v7, &v8);
  v6 = v8;
  if ((result & 1) == 0)
  {
    result = (uint64_t)llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)a1, (uint64_t)&v7, &v7, v8);
    v6 = (_QWORD *)result;
    *(_QWORD *)result = v7;
    *(_QWORD *)(result + 8) = 0;
  }
  v6[1] = a3;
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::placement::TensorToMemref,mlir::Value &>(mlir::UnknownLoc **a1, uint64_t a2, void *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"placement.tensor_to_memref", (const unsigned __int8 *)0x1A, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"placement.tensor_to_memref";
    v15[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::placement::TensorToMemref::build(a1, (uint64_t)v17, a3, 1, 0, 0);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::placement::TensorToMemref,mlir::MemRefType &,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"placement.tensor_to_memref", (const unsigned __int8 *)0x1A, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"placement.tensor_to_memref";
    v17[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, a3, 1uLL);
  mlir::anec::GOC::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], a4, 1, 0, 0);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::TensorToMemref,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

void mlir::populateMPSToANECConversionPatterns(uint64_t a1, char a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4;
  int v7;
  uint64_t v8;
  _QWORD *v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  _QWORD *v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  llvm::APFloatBase *v42;
  void *v43;
  llvm::APFloatBase *v44;
  uint64_t v45;
  char *v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  const char *v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  char *v55;
  _QWORD *v56;
  char *v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  _QWORD *v62;
  char *v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char *v67;
  _OWORD *v68;
  char *v69;
  uint64_t v70;
  __int128 v71;
  __int128 v72;
  uint64_t v73;
  char *v74;
  llvm::APFloatBase *v75;
  void *v76;
  void *v77;
  uint64_t v78;
  _QWORD *v79;
  char *v80;
  char *v81;
  char *v82;
  char *v83;
  uint64_t v84;
  char *v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  char *v89;
  _QWORD *v90;
  char *v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  char *v96;
  char *v97;
  char *v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  char *v102;
  char *v103;
  char *v104;
  uint64_t v105;
  __int128 v106;
  __int128 v107;
  uint64_t v108;
  char *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  _QWORD *v113;
  char *v114;
  char *v115;
  char *v116;
  char *v117;
  uint64_t v118;
  char *v119;
  unint64_t v120;
  unint64_t v121;
  unint64_t v122;
  char *v123;
  _QWORD *v124;
  char *v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  unint64_t v129;
  char *v130;
  char *v131;
  char *v132;
  unint64_t v133;
  uint64_t v134;
  uint64_t v135;
  char *v136;
  char *v137;
  char *v138;
  uint64_t v139;
  __int128 v140;
  __int128 v141;
  uint64_t v142;
  char *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  char *v147;
  unint64_t v148;
  unint64_t v149;
  const char *v150;
  unint64_t v151;
  uint64_t v152;
  const char *v153;
  unint64_t v154;
  unint64_t v155;
  unint64_t v156;
  char *v157;
  _QWORD *v158;
  char *v159;
  uint64_t v160;
  unint64_t v161;
  uint64_t v162;
  unint64_t v163;
  char *v164;
  char *v165;
  char *v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  char *v170;
  char *v171;
  char *v172;
  uint64_t v173;
  __int128 v174;
  __int128 v175;
  uint64_t v176;
  char *v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  char *v181;
  unint64_t v182;
  unint64_t v183;
  const char *v184;
  unint64_t v185;
  uint64_t v186;
  const char *v187;
  unint64_t v188;
  unint64_t v189;
  unint64_t v190;
  char *v191;
  _QWORD *v192;
  char *v193;
  uint64_t v194;
  unint64_t v195;
  uint64_t v196;
  unint64_t v197;
  char *v198;
  char *v199;
  char *v200;
  unint64_t v201;
  uint64_t v202;
  uint64_t v203;
  char *v204;
  char *v205;
  char *v206;
  uint64_t v207;
  __int128 v208;
  __int128 v209;
  uint64_t v210;
  char *v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  char *v215;
  unint64_t v216;
  unint64_t v217;
  const char *v218;
  unint64_t v219;
  uint64_t v220;
  const char *v221;
  unint64_t v222;
  unint64_t v223;
  unint64_t v224;
  char *v225;
  _QWORD *v226;
  char *v227;
  uint64_t v228;
  unint64_t v229;
  uint64_t v230;
  unint64_t v231;
  char *v232;
  char *v233;
  char *v234;
  unint64_t v235;
  uint64_t v236;
  uint64_t v237;
  char *v238;
  char *v239;
  char *v240;
  uint64_t v241;
  __int128 v242;
  __int128 v243;
  uint64_t v244;
  char *v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  char *v249;
  unint64_t v250;
  unint64_t v251;
  const char *v252;
  unint64_t v253;
  uint64_t v254;
  const char *v255;
  unint64_t v256;
  unint64_t v257;
  unint64_t v258;
  char *v259;
  _QWORD *v260;
  char *v261;
  uint64_t v262;
  unint64_t v263;
  uint64_t v264;
  unint64_t v265;
  char *v266;
  char *v267;
  char *v268;
  unint64_t v269;
  uint64_t v270;
  uint64_t v271;
  char *v272;
  char *v273;
  char *v274;
  uint64_t v275;
  __int128 v276;
  __int128 v277;
  uint64_t v278;
  char *v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  char *v283;
  unint64_t v284;
  unint64_t v285;
  const char *v286;
  unint64_t v287;
  uint64_t v288;
  const char *v289;
  unint64_t v290;
  unint64_t v291;
  unint64_t v292;
  char *v293;
  _QWORD *v294;
  char *v295;
  uint64_t v296;
  unint64_t v297;
  uint64_t v298;
  unint64_t v299;
  char *v300;
  char *v301;
  char *v302;
  unint64_t v303;
  uint64_t v304;
  uint64_t v305;
  char *v306;
  char *v307;
  char *v308;
  uint64_t v309;
  __int128 v310;
  __int128 v311;
  uint64_t v312;
  char *v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  _QWORD *v317;
  char *v318;
  char *v319;
  char *v320;
  char *v321;
  uint64_t v322;
  char *v323;
  unint64_t v324;
  unint64_t v325;
  unint64_t v326;
  char *v327;
  _QWORD *v328;
  char *v329;
  uint64_t v330;
  unint64_t v331;
  uint64_t v332;
  unint64_t v333;
  char *v334;
  char *v335;
  char *v336;
  unint64_t v337;
  uint64_t v338;
  uint64_t v339;
  char *v340;
  char *v341;
  char *v342;
  uint64_t v343;
  __int128 v344;
  __int128 v345;
  uint64_t v346;
  char *v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  _QWORD *v351;
  char *v352;
  char *v353;
  char *v354;
  char *v355;
  uint64_t v356;
  char *v357;
  unint64_t v358;
  unint64_t v359;
  unint64_t v360;
  char *v361;
  _QWORD *v362;
  char *v363;
  uint64_t v364;
  unint64_t v365;
  uint64_t v366;
  unint64_t v367;
  char *v368;
  char *v369;
  char *v370;
  unint64_t v371;
  uint64_t v372;
  uint64_t v373;
  char *v374;
  char *v375;
  char *v376;
  uint64_t v377;
  __int128 v378;
  __int128 v379;
  uint64_t v380;
  char *v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  _QWORD *v385;
  char *v386;
  char *v387;
  char *v388;
  char *v389;
  uint64_t v390;
  char *v391;
  unint64_t v392;
  unint64_t v393;
  unint64_t v394;
  char *v395;
  _QWORD *v396;
  char *v397;
  uint64_t v398;
  unint64_t v399;
  uint64_t v400;
  unint64_t v401;
  char *v402;
  char *v403;
  char *v404;
  unint64_t v405;
  uint64_t v406;
  uint64_t v407;
  char *v408;
  char *v409;
  char *v410;
  uint64_t v411;
  __int128 v412;
  __int128 v413;
  uint64_t v414;
  char *v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  _QWORD *v419;
  char *v420;
  char *v421;
  char *v422;
  char *v423;
  uint64_t v424;
  char *v425;
  unint64_t v426;
  unint64_t v427;
  unint64_t v428;
  char *v429;
  _QWORD *v430;
  char *v431;
  uint64_t v432;
  unint64_t v433;
  uint64_t v434;
  unint64_t v435;
  char *v436;
  char *v437;
  char *v438;
  unint64_t v439;
  uint64_t v440;
  uint64_t v441;
  char *v442;
  char *v443;
  char *v444;
  uint64_t v445;
  __int128 v446;
  __int128 v447;
  uint64_t v448;
  char *v449;
  uint64_t v450;
  uint64_t v451;
  uint64_t v452;
  _QWORD *v453;
  char *v454;
  char *v455;
  char *v456;
  char *v457;
  uint64_t v458;
  char *v459;
  unint64_t v460;
  unint64_t v461;
  unint64_t v462;
  char *v463;
  _QWORD *v464;
  char *v465;
  uint64_t v466;
  unint64_t v467;
  uint64_t v468;
  unint64_t v469;
  char *v470;
  char *v471;
  char *v472;
  unint64_t v473;
  uint64_t v474;
  uint64_t v475;
  char *v476;
  char *v477;
  char *v478;
  uint64_t v479;
  __int128 v480;
  __int128 v481;
  uint64_t v482;
  char *v483;
  uint64_t v484;
  uint64_t v485;
  uint64_t v486;
  _QWORD *v487;
  char *v488;
  char *v489;
  char *v490;
  char *v491;
  uint64_t v492;
  char *v493;
  unint64_t v494;
  unint64_t v495;
  unint64_t v496;
  char *v497;
  _QWORD *v498;
  char *v499;
  uint64_t v500;
  unint64_t v501;
  uint64_t v502;
  unint64_t v503;
  char *v504;
  char *v505;
  char *v506;
  unint64_t v507;
  uint64_t v508;
  uint64_t v509;
  char *v510;
  char *v511;
  char *v512;
  uint64_t v513;
  __int128 v514;
  __int128 v515;
  uint64_t v516;
  char *v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  _QWORD *v521;
  char *v522;
  char *v523;
  char *v524;
  char *v525;
  uint64_t v526;
  char *v527;
  unint64_t v528;
  unint64_t v529;
  unint64_t v530;
  char *v531;
  _QWORD *v532;
  char *v533;
  uint64_t v534;
  unint64_t v535;
  uint64_t v536;
  unint64_t v537;
  char *v538;
  char *v539;
  char *v540;
  unint64_t v541;
  uint64_t v542;
  uint64_t v543;
  char *v544;
  char *v545;
  char *v546;
  uint64_t v547;
  __int128 v548;
  __int128 v549;
  uint64_t v550;
  char *v551;
  uint64_t v552;
  uint64_t v553;
  uint64_t v554;
  _QWORD *v555;
  char *v556;
  char *v557;
  char *v558;
  char *v559;
  uint64_t v560;
  char *v561;
  unint64_t v562;
  unint64_t v563;
  unint64_t v564;
  char *v565;
  _QWORD *v566;
  char *v567;
  uint64_t v568;
  unint64_t v569;
  uint64_t v570;
  unint64_t v571;
  char *v572;
  char *v573;
  char *v574;
  unint64_t v575;
  uint64_t v576;
  uint64_t v577;
  char *v578;
  char *v579;
  char *v580;
  uint64_t v581;
  __int128 v582;
  __int128 v583;
  uint64_t v584;
  char *v585;
  uint64_t v586;
  uint64_t v587;
  void *v588;
  char v589;
  int v590;
  uint64_t v591;
  const char *v592;
  unint64_t v593;
  _QWORD *v594;
  const char *v595;
  void *v596[2];
  char v597;
  void *__p;
  void *v599[2];
  _BYTE v600[7];
  char v601;
  _QWORD v602[5];
  char v603;
  const char *p_p;
  _QWORD v605[3];
  const char *v606;
  void *v607[2];
  char v608;
  _QWORD v609[2];

  v4 = a4;
  v7 = a1;
  v609[0] = *MEMORY[0x1E0C80C00];
  _ZN4mlir12_GLOBAL__N_120addPatternsForTargetIJNS0_14ConvertBiasAddENS0_15ConvertConstantENS0_17ConvertCropResizeENS0_22ConvertDepthwiseConv3DENS0_31ConvertElementwiseBinaryA14PlusINS_3mps5AddOpENS_4anec14ElementwiseAddELNS9_6FamilyE2EEENS6_INS7_10MultiplyOpENS9_15ElementwiseMultELSB_2EEENS6_INS7_10SubtractOpENS9_14ElementwiseSubELSB_2EEENS6_INS7_9MaximumOpENS9_14ElementwiseMaxELSB_2EEENS6_INS7_9MinimumOpENS9_14ElementwiseMinELSB_2EEENS6_INS7_7PowerOpENS9_16ElementwisePowerELSB_2EEENS0_32ConvertElementwiseBinaryA14MinusIS8_SA_LSB_1EEENSS_ISD_SE_LSB_1EEENSS_ISG_SH_LSB_1EEENSS_ISJ_SK_LSB_1EEENSS_ISM_SN_LSB_1EEENSS_ISP_SQ_LSB_1EEENSS_IS8_SA_LSB_0EEENSS_ISD_SE_LSB_0EEENSS_ISG_SH_LSB_0EEENSS_ISJ_SK_LSB_0EEENSS_ISM_SN_LSB_0EEENSS_ISP_SQ_LSB_0EEENS0_23ConvertElementwiseUnaryINS7_10AbsoluteOpENS9_14ElementwiseAbsEEENS0_15ConvertExponentENS0_16ConvertLogarithmENS0_13ConvertSelectENS0_16ConvertFlatten2DENS0_13ConvertDivideILSB_0EEENS1D_ILSB_1EEENS1D_ILSB_2EEENS1D_ILSB_3EEENS1D_ILSB_4EEENS1D_ILSB_5EEENS1D_ILSB_6EEENS0_18ConvertFloorDivideILSB_0EEENS1L_ILSB_1EEENS1L_ILSB_2EEENS1L_ILSB_3EEENS1L_ILSB_4EEENS1L_ILSB_5EEENS1L_ILSB_6EEENS0_13ConvertMatMulILSB_0EEENS1T_ILSB_1EEENS1T_ILSB_2EEENS1T_ILSB_3EEENS1T_ILSB_4EEENS1T_ILSB_5EEENS1T_ILSB_6EEENS15_INS7_9DegammaOpENS9_7DegammaEEENS15_INS7_7DiracOpENS9_5DiracEEENS15_INS7_6GeluOpENS9_4GeluEEENS15_INS7_6ReluOpENS9_4ReluEEENS15_INS7_7RoundOpENS9_12RoundNearestEEENS15_INS7_9SigmoidOpENS9_20HighPrecisionSigmoidEEENS15_INS7_8SquareOpENS9_17ElementwiseSquareEEENS15_INS7_12SquareRootOpENS9_4SqrtEEENS15_INS7_7SwishOpENS9_5SwishEEENS15_INS7_6TanhOpENS9_4TanhEEENS0_20ConvertBinaryCompareINS7_9EqualToOpENS9_16ElementwiseEqualEEENS0_26ConvertBinaryCompareToZeroIS2W_NS9_20ElementwiseEqualZeroEEENS2V_INS7_12NotEqualToOpENS9_19ElementwiseNotEqualEEENS2Z_IS32_NS9_23ElementwiseNotEqualZeroEEENS2V_INS7_13GreaterThanOpENS9_22ElementwiseGreaterThanEEENS2Z_IS37_NS9_26ElementwiseGreaterThanZeroEEENS2V_INS7_22GreaterThanOrEqualToOpENS9_27ElementwiseGreaterThanEqualEEENS2Z_IS3C_NS9_31ElementwiseGreaterThanEqualZeroEEENS2V_INS7_10LessThanOpENS9_19ElementwiseLessThanEEENS2Z_IS3H_NS9_23ElementwiseLessThanZeroEEENS2V_INS7_19LessThanOrEqualToOpENS9_24ElementwiseLessThanEqualEEENS2Z_IS3M_NS9_28ElementwiseLessThanEqualZeroEEENS15_INS7_5NotOpES30_EENS0_11ConvertPoolINS7_9PoolAvgOpENS9_11AveragePoolEEENS3T_INS7_12PoolL2NormOpENS9_10L2NormPoolEEENS3T_INS7_9PoolMaxOpENS9_7MaxPoolEEENS0_14ConvertStencilENS15_INS7_6CeilOpENS9_4CeilEEENS15_INS7_5ErfOpENS9_3ErfEEENS15_INS7_15ExponentBase2OpENS9_4Exp2EEENS15_INS7_7FloorOpENS9_5FloorEEENS15_INS7_6SignOpENS9_4SignEEENS15_INS7_10TruncateOpENS9_5TruncEEENS0_23ConvertReductionA14PlusINS7_14ReductionMaxOpENS9_9ReduceMaxELSB_2EEENS4M_INS7_15ReductionMeanOpENS9_9ReduceAvgELSB_2EEENS4M_INS7_14ReductionMinOpENS9_9ReduceMinELSB_2EEENS4M_INS7_14ReductionSumOpENS9_9ReduceSumELSB_2EEENS0_24ConvertReductionA14MinusIS4N_S4O_LSB_1EEENS4Z_IS4Q_S4R_LSB_1EEENS4Z_IS4T_S4U_LSB_1EEENS4Z_IS4W_S4X_LSB_1EEENS4Z_IS4N_S4O_LSB_0EEENS4Z_IS4Q_S4R_LSB_0EEENS4Z_IS4T_S4U_LSB_0EEENS4Z_IS4W_S4X_LSB_0EEENS0_14ConvertReshapeILSB_0EEENS58_ILSB_1EEENS58_ILSB_2EEENS58_ILSB_3EEENS58_ILSB_4EEENS58_ILSB_5EEENS58_ILSB_6EEENS0_17ConvertExpandDimsILSB_0EEENS5G_ILSB_1EEENS5G_ILSB_2EEENS5G_ILSB_3EEENS5G_ILSB_4EEENS5G_ILSB_5EEENS5G_ILSB_6EEENS0_14ConvertSqueezeILSB_0EEENS5O_ILSB_1EEENS5O_ILSB_2EEENS5O_ILSB_3EEENS5O_ILSB_4EEENS5O_ILSB_5EEENS5O_ILSB_6EEENS0_11ConvertCastENS0_14ConvertSoftmaxENS0_13ConvertConcatENS0_12ConvertSplitENS0_13ConvertResizeILSB_0EEENS60_ILSB_1EEENS60_ILSB_2EEENS60_ILSB_3EEENS60_ILSB_4EEENS60_ILSB_5EEENS60_ILSB_6EEENS0_19ConvertInstanceNormENS0_14ConvertPermuteENS0_15ConvertGatherNDENS0_13ConvertGatherENS0_21ConvertDepthToSpace2DINS9_12PixelShuffleEEENS6C_INS9_14ChannelToSpaceEEENS0_21ConvertSpaceToDepth2DINS9_14PixelUnshuffleEEENS6H_INS9_14SpaceToChannelEEENS0_19ConvertBatchToSpaceINS7_14BatchToSpaceOpENS9_12BatchToSpaceEEENS6M_INS7_14SpaceToBatchOpENS9_12SpaceToBatchEEENS0_16ConvertTransposeILSB_0EEENS6T_ILSB_1EEENS6T_ILSB_2EEENS6T_ILSB_3EEENS6T_ILSB_4EEENS6T_ILSB_5EEENS6T_ILSB_6EEENS0_16ConvertBroadcastILSB_0EEENS71_ILSB_1EEENS71_ILSB_2EEENS71_ILSB_3EEENS71_ILSB_4EEENS71_ILSB_5EEENS71_ILSB_6EEENS0_14ConvertPaddingILSB_0EEENS79_ILSB_1EEENS79_ILSB_2EEENS79_ILSB_3EEENS79_ILSB_4EEENS79_ILSB_5EEENS79_ILSB_6EEENS0_12ConvertSliceILSB_0EEENS7H_ILSB_1EEENS7H_ILSB_2EEENS7H_ILSB_3EEENS7H_ILSB_4EEENS7H_ILSB_5EEENS7H_ILSB_6EEENS0_19ConvertStridedSliceILSB_0EEENS7P_ILSB_1EEENS7P_ILSB_2EEENS7P_ILSB_3EEENS7P_ILSB_4EEENS7P_ILSB_5EEENS7P_ILSB_6EEENS0_11ConvertCropILSB_0EEENS7X_ILSB_1EEENS7X_ILSB_2EEENS7X_ILSB_3EEENS7X_ILSB_4EEENS7X_ILSB_5EEENS7X_ILSB_6EEENS15_INS7_5CosOpENS9_3CosEEENS15_INS7_5SinOpENS9_3SinEEENS0_13FoldOperationINS7_10IdentityOpEEENS0_20ConvertNormalizationENS0_24ConvertReductionVarianceENS0_19ConvertReductionArgINS7_17ReductionArgMinOpELSB_0EEENS8G_IS8H_LSB_1EEENS8G_IS8H_LSB_2EEENS8G_IS8H_LSB_3EEENS8G_IS8H_LSB_4EEENS8G_IS8H_LSB_5EEENS8G_IS8H_LSB_6EEENS8G_INS7_17ReductionArgMaxOpELSB_0EEENS8G_IS8P_LSB_1EEENS8G_IS8P_LSB_2EEENS8G_IS8P_LSB_3EEENS8G_IS8P_LSB_4EEENS8G_IS8P_LSB_5EEENS8G_IS8P_LSB_6EEENS0_14ConvertSignBitENS0_11ConvertTileEEEEvSB_RNS_17RewritePatternSetERNS_13TypeConverterE(a1, a3, a4);
  mlir::populateFunctionOpInterfaceTypeConversionPattern((uint64_t)"anec.A12", 8, a3, v4);
  mlir::populateFunctionOpInterfaceTypeConversionPattern((uint64_t)"anec.A13", 8, a3, v4);
  mlir::populateFunctionOpInterfaceTypeConversionPattern((uint64_t)"anec.A14", 8, a3, v4);
  mlir::populateFunctionOpInterfaceTypeConversionPattern((uint64_t)"anec.A15", 8, a3, v4);
  mlir::populateFunctionOpInterfaceTypeConversionPattern((uint64_t)"anec.A16", 8, a3, v4);
  mlir::populateFunctionOpInterfaceTypeConversionPattern((uint64_t)"anec.A17", 8, a3, v4);
  mlir::populateFunctionOpInterfaceTypeConversionPattern((uint64_t)"anec.A11Legacy", 14, a3, v4);
  v8 = *a3;
  v9 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v595, 1);
  mlir::Pattern::Pattern((uint64_t)(v9 + 1), (uint64_t)"anec.region_return", 18, (__int16)v595, v8, 0, 0);
  v9[12] = v4;
  *v9 = off_1E0E2AB00;
  if (!v9[9])
  {
    v595 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::RegionReturnTypeConversion]";
    v596[0] = (void *)105;
    v10 = (char *)llvm::StringRef::find((uint64_t *)&v595, "DesiredTypeName = ", 0x12uLL, 0);
    if (v596[0] >= v10)
      v11 = v10;
    else
      v11 = (char *)v596[0];
    v12 = &v11[(_QWORD)v595];
    v13 = (char *)((char *)v596[0] - (char *)v11);
    if ((void *)((char *)v596[0] - (char *)v11) >= (void *)0x12)
      v14 = 18;
    else
      v14 = (char *)v596[0] - (char *)v11;
    v15 = &v12[v14];
    v16 = (unint64_t)&v13[-v14];
    if (v16 >= v16 - 1)
      --v16;
    v9[8] = v15;
    v9[9] = v16;
  }
  v17 = *((unsigned int *)v9 + 22);
  if (v17 > *((_DWORD *)v9 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v9 + 10), v9 + 12, v17, 16);
    LODWORD(v17) = *((_DWORD *)v9 + 22);
  }
  *((_DWORD *)v9 + 22) = v17;
  v19 = (char *)a3[2];
  v18 = a3[3];
  v591 = v4;
  v590 = v7;
  if ((unint64_t)v19 < v18)
  {
    *(_QWORD *)v19 = v9;
    v20 = v19 + 8;
    goto LABEL_41;
  }
  v21 = (char *)a3[1];
  v22 = (v19 - v21) >> 3;
  v23 = v22 + 1;
  if ((unint64_t)(v22 + 1) >> 61)
    goto LABEL_763;
  v24 = v18 - (_QWORD)v21;
  if (v24 >> 2 > v23)
    v23 = v24 >> 2;
  if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8)
    v25 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v25 = v23;
  if (v25)
  {
    if (v25 >> 61)
      goto LABEL_764;
    v26 = (char *)operator new(8 * v25);
  }
  else
  {
    v26 = 0;
  }
  v27 = &v26[8 * v22];
  v28 = &v26[8 * v25];
  *(_QWORD *)v27 = v9;
  v20 = v27 + 8;
  if (v19 == v21)
  {
    a3[1] = (uint64_t)v27;
    a3[2] = (uint64_t)v20;
    a3[3] = (uint64_t)v28;
    v4 = v591;
    v7 = v590;
    goto LABEL_39;
  }
  v29 = v19 - v21 - 8;
  v4 = v591;
  if (v29 < 0x78
    || &v19[-(v29 & 0xFFFFFFFFFFFFFFF8) - 8] < v27 && &v26[v19 - v21 - (v29 & 0xFFFFFFFFFFFFFFF8) - 8] < v19)
  {
    goto LABEL_767;
  }
  v30 = (v29 >> 3) + 1;
  v31 = 8 * (v30 & 0x3FFFFFFFFFFFFFFCLL);
  v32 = &v19[-v31];
  v27 -= v31;
  v33 = &v26[8 * v22 - 16];
  v34 = v19 - 16;
  v35 = v30 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v37 = *((_OWORD *)v34 - 1);
    v36 = *(_OWORD *)v34;
    *((_OWORD *)v34 - 1) = 0uLL;
    *(_OWORD *)v34 = 0uLL;
    *((_OWORD *)v33 - 1) = v37;
    *(_OWORD *)v33 = v36;
    v33 -= 32;
    v34 -= 32;
    v35 -= 4;
  }
  while (v35);
  v19 = v32;
  if (v30 != (v30 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_767:
    do
    {
      v38 = *((_QWORD *)v19 - 1);
      v19 -= 8;
      *(_QWORD *)v19 = 0;
      *((_QWORD *)v27 - 1) = v38;
      v27 -= 8;
    }
    while (v19 != v21);
  }
  v19 = (char *)a3[1];
  v39 = (char *)a3[2];
  a3[1] = (uint64_t)v27;
  a3[2] = (uint64_t)v20;
  a3[3] = (uint64_t)v28;
  if (v39 != v19)
  {
    v7 = v590;
    do
    {
      v41 = *((_QWORD *)v39 - 1);
      v39 -= 8;
      v40 = v41;
      *(_QWORD *)v39 = 0;
      if (v41)
        (*(void (**)(uint64_t))(*(_QWORD *)v40 + 8))(v40);
    }
    while (v39 != v19);
LABEL_39:
    if (!v19)
      goto LABEL_41;
    goto LABEL_40;
  }
  v7 = v590;
  if (v19)
LABEL_40:
    operator delete(v19);
LABEL_41:
  a3[2] = (uint64_t)v20;
  v608 = 5;
  LODWORD(v606) = 1;
  strcpy((char *)v607, "slope");
  v42 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v595, 0.0);
  v43 = llvm::APFloatBase::IEEEdouble(v42);
  llvm::APFloat::Storage::Storage(v605, &v595, v43);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v595);
  v44 = (llvm::APFloatBase *)std::pair<llvm::APFloat,std::string>::pair[abi:nn180100]<llvm::APFloat,char const(&)[7],0>((uint64_t)&v595, (uint64_t)&p_p, "offset");
  v588 = v43;
  if (v7 < 0)
    goto LABEL_86;
  v45 = *a3;
  v46 = (char *)operator new(0x170uLL);
  mlir::PatternBenefit::PatternBenefit(&v592, 1);
  mlir::Pattern::Pattern((uint64_t)(v46 + 8), (uint64_t)"mps.leaky_relu", 14, (__int16)v592, v45, 0, 0);
  *((_QWORD *)v46 + 12) = v4;
  *(_QWORD *)v46 = off_1E0E29750;
  v592 = (const char *)&v606;
  v594 = v609;
  llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v46 + 104), (uint64_t *)&v592, (uint64_t *)&v594);
  *((_QWORD *)v46 + 16) = v46 + 144;
  *((_QWORD *)v46 + 17) = 0x400000000;
  llvm::SmallVectorImpl<std::pair<llvm::APFloat,std::string>>::append<std::pair<llvm::APFloat,std::string> const*,void>((unsigned int *)v46 + 32, (uint64_t)&v595, (uint64_t)v600);
  if (!*((_QWORD *)v46 + 9))
  {
    v592 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::m"
           "ps::LeakyReluOp, mlir::anec::LeakyRelu>]";
    v593 = 149;
    v44 = (llvm::APFloatBase *)llvm::StringRef::find((uint64_t *)&v592, "DesiredTypeName = ", 0x12uLL, 0);
    if (v593 >= (unint64_t)v44)
      v47 = (unint64_t)v44;
    else
      v47 = v593;
    v48 = &v592[v47];
    v49 = v593 - v47;
    if (v593 - v47 >= 0x12)
      v50 = 18;
    else
      v50 = v593 - v47;
    v51 = &v48[v50];
    v52 = v49 - v50;
    if (v52 >= v52 - 1)
      --v52;
    *((_QWORD *)v46 + 8) = v51;
    *((_QWORD *)v46 + 9) = v52;
  }
  v53 = *((unsigned int *)v46 + 22);
  if (v53 > *((_DWORD *)v46 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v46 + 80), v46 + 96, v53, 16);
    LODWORD(v53) = *((_DWORD *)v46 + 22);
  }
  *((_DWORD *)v46 + 22) = v53;
  v55 = (char *)a3[2];
  v54 = a3[3];
  if ((unint64_t)v55 >= v54)
  {
    v57 = (char *)a3[1];
    v58 = (v55 - v57) >> 3;
    v59 = v58 + 1;
    if ((unint64_t)(v58 + 1) >> 61)
      goto LABEL_763;
    v60 = v54 - (_QWORD)v57;
    if (v60 >> 2 > v59)
      v59 = v60 >> 2;
    if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFF8)
      v61 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v61 = v59;
    if (v61)
    {
      if (v61 >> 61)
        goto LABEL_764;
      v44 = (llvm::APFloatBase *)operator new(8 * v61);
    }
    else
    {
      v44 = 0;
    }
    v62 = (_QWORD *)((char *)v44 + 8 * v58);
    v63 = (char *)v44 + 8 * v61;
    *v62 = v46;
    v56 = v62 + 1;
    if (v55 == v57)
    {
      a3[1] = (uint64_t)v62;
      a3[2] = (uint64_t)v56;
      a3[3] = (uint64_t)v63;
      v4 = v591;
    }
    else
    {
      v64 = v55 - v57 - 8;
      v4 = v591;
      if (v64 < 0x78
        || &v55[-(v64 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v62
        && (char *)v44 + v55 - v57 - (v64 & 0xFFFFFFFFFFFFFFF8) - 8 < v55)
      {
        goto LABEL_768;
      }
      v65 = (v64 >> 3) + 1;
      v66 = 8 * (v65 & 0x3FFFFFFFFFFFFFFCLL);
      v67 = &v55[-v66];
      v62 = (_QWORD *)((char *)v62 - v66);
      v68 = (_OWORD *)((char *)v44 + 8 * v58 - 16);
      v69 = v55 - 16;
      v70 = v65 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v72 = *((_OWORD *)v69 - 1);
        v71 = *(_OWORD *)v69;
        *((_OWORD *)v69 - 1) = 0uLL;
        *(_OWORD *)v69 = 0uLL;
        *(v68 - 1) = v72;
        *v68 = v71;
        v68 -= 2;
        v69 -= 32;
        v70 -= 4;
      }
      while (v70);
      v55 = v67;
      if (v65 != (v65 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_768:
        do
        {
          v73 = *((_QWORD *)v55 - 1);
          v55 -= 8;
          *(_QWORD *)v55 = 0;
          *--v62 = v73;
        }
        while (v55 != v57);
      }
      v55 = (char *)a3[1];
      v74 = (char *)a3[2];
      a3[1] = (uint64_t)v62;
      a3[2] = (uint64_t)v56;
      a3[3] = (uint64_t)v63;
      if (v74 != v55)
      {
        v7 = v590;
        do
        {
          v75 = (llvm::APFloatBase *)*((_QWORD *)v74 - 1);
          v74 -= 8;
          v44 = v75;
          *(_QWORD *)v74 = 0;
          if (v75)
            v44 = (llvm::APFloatBase *)(*(uint64_t (**)(llvm::APFloatBase *))(*(_QWORD *)v44 + 8))(v44);
        }
        while (v74 != v55);
        goto LABEL_83;
      }
    }
    v7 = v590;
LABEL_83:
    if (v55)
      operator delete(v55);
    goto LABEL_85;
  }
  *(_QWORD *)v55 = v46;
  v56 = v55 + 8;
LABEL_85:
  a3[2] = (uint64_t)v56;
LABEL_86:
  if (SHIBYTE(v599[1]) < 0)
    operator delete(__p);
  v76 = v596[0];
  v77 = llvm::APFloatBase::PPCDoubleDouble(v44);
  if (v77 == v76)
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v596);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v596);
  if (v77 != (void *)v605[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v605);
    if ((v608 & 0x80000000) == 0)
      goto LABEL_94;
    goto LABEL_93;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v605);
  if (v608 < 0)
LABEL_93:
    operator delete(v607[0]);
LABEL_94:
  LODWORD(v595) = 1;
  v597 = 9;
  strcpy((char *)v596, "min_value");
  LODWORD(__p) = 2;
  v601 = 9;
  strcpy((char *)v599, "max_value");
  v589 = a2;
  if (v7 < 0)
    goto LABEL_141;
  v78 = *a3;
  v79 = operator new(0x170uLL);
  mlir::PatternBenefit::PatternBenefit(&v606, 1);
  mlir::Pattern::Pattern((uint64_t)(v79 + 1), (uint64_t)"mps.clamp", 9, (__int16)v606, v78, 0, 0);
  v79[12] = v4;
  *v79 = off_1E0E29DE0;
  v606 = (const char *)&v595;
  p_p = (const char *)v602;
  llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v79 + 13), (uint64_t *)&v606, (uint64_t *)&p_p);
  v79[16] = v79 + 18;
  v79[17] = 0x400000000;
  if (!v79[9])
  {
    v606 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::m"
           "ps::ClampOp, mlir::anec::ClampedRelu>]";
    v607[0] = (void *)147;
    v80 = (char *)llvm::StringRef::find((uint64_t *)&v606, "DesiredTypeName = ", 0x12uLL, 0);
    if (v607[0] >= v80)
      v81 = v80;
    else
      v81 = (char *)v607[0];
    v82 = &v81[(_QWORD)v606];
    v83 = (char *)((char *)v607[0] - (char *)v81);
    if ((void *)((char *)v607[0] - (char *)v81) >= (void *)0x12)
      v84 = 18;
    else
      v84 = (char *)v607[0] - (char *)v81;
    v85 = &v82[v84];
    v86 = (unint64_t)&v83[-v84];
    if (v86 >= v86 - 1)
      --v86;
    v79[8] = v85;
    v79[9] = v86;
  }
  v87 = *((unsigned int *)v79 + 22);
  if (v87 > *((_DWORD *)v79 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v79 + 10), v79 + 12, v87, 16);
    LODWORD(v87) = *((_DWORD *)v79 + 22);
  }
  *((_DWORD *)v79 + 22) = v87;
  v89 = (char *)a3[2];
  v88 = a3[3];
  if ((unint64_t)v89 < v88)
  {
    *(_QWORD *)v89 = v79;
    v90 = v89 + 8;
    goto LABEL_140;
  }
  v91 = (char *)a3[1];
  v92 = (v89 - v91) >> 3;
  v93 = v92 + 1;
  if ((unint64_t)(v92 + 1) >> 61)
    goto LABEL_763;
  v94 = v88 - (_QWORD)v91;
  if (v94 >> 2 > v93)
    v93 = v94 >> 2;
  if ((unint64_t)v94 >= 0x7FFFFFFFFFFFFFF8)
    v95 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v95 = v93;
  if (v95)
  {
    if (v95 >> 61)
      goto LABEL_764;
    v96 = (char *)operator new(8 * v95);
  }
  else
  {
    v96 = 0;
  }
  v97 = &v96[8 * v92];
  v98 = &v96[8 * v95];
  *(_QWORD *)v97 = v79;
  v90 = v97 + 8;
  if (v89 == v91)
  {
    a3[1] = (uint64_t)v97;
    a3[2] = (uint64_t)v90;
    a3[3] = (uint64_t)v98;
    a2 = v589;
    goto LABEL_138;
  }
  v99 = v89 - v91 - 8;
  if (v99 < 0x78
    || &v89[-(v99 & 0xFFFFFFFFFFFFFFF8) - 8] < v97 && &v96[v89 - v91 - (v99 & 0xFFFFFFFFFFFFFFF8) - 8] < v89)
  {
    goto LABEL_769;
  }
  v100 = (v99 >> 3) + 1;
  v101 = 8 * (v100 & 0x3FFFFFFFFFFFFFFCLL);
  v102 = &v89[-v101];
  v97 -= v101;
  v103 = &v96[8 * v92 - 16];
  v104 = v89 - 16;
  v105 = v100 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v107 = *((_OWORD *)v104 - 1);
    v106 = *(_OWORD *)v104;
    *((_OWORD *)v104 - 1) = 0uLL;
    *(_OWORD *)v104 = 0uLL;
    *((_OWORD *)v103 - 1) = v107;
    *(_OWORD *)v103 = v106;
    v103 -= 32;
    v104 -= 32;
    v105 -= 4;
  }
  while (v105);
  v89 = v102;
  if (v100 != (v100 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_769:
    do
    {
      v108 = *((_QWORD *)v89 - 1);
      v89 -= 8;
      *(_QWORD *)v89 = 0;
      *((_QWORD *)v97 - 1) = v108;
      v97 -= 8;
    }
    while (v89 != v91);
  }
  v89 = (char *)a3[1];
  v109 = (char *)a3[2];
  a3[1] = (uint64_t)v97;
  a3[2] = (uint64_t)v90;
  a3[3] = (uint64_t)v98;
  if (v109 == v89)
  {
    a2 = v589;
    v4 = v591;
LABEL_138:
    v7 = v590;
    if (!v89)
      goto LABEL_140;
    goto LABEL_139;
  }
  a2 = v589;
  v7 = v590;
  do
  {
    v111 = *((_QWORD *)v109 - 1);
    v109 -= 8;
    v110 = v111;
    *(_QWORD *)v109 = 0;
    if (v111)
      (*(void (**)(uint64_t))(*(_QWORD *)v110 + 8))(v110);
  }
  while (v109 != v89);
  v4 = v591;
  if (v89)
LABEL_139:
    operator delete(v89);
LABEL_140:
  a3[2] = (uint64_t)v90;
  if ((v601 & 0x80000000) == 0)
  {
LABEL_141:
    if ((v597 & 0x80000000) == 0)
      goto LABEL_143;
    goto LABEL_142;
  }
  operator delete(v599[0]);
  if (v597 < 0)
LABEL_142:
    operator delete(v596[0]);
LABEL_143:
  LODWORD(v595) = 1;
  v597 = 9;
  strcpy((char *)v596, "max_value");
  v601 = 5;
  LODWORD(__p) = 2;
  strcpy((char *)v599, "slope");
  if (v7 < 0)
    goto LABEL_190;
  v112 = *a3;
  v113 = operator new(0x170uLL);
  mlir::PatternBenefit::PatternBenefit(&v606, 1);
  mlir::Pattern::Pattern((uint64_t)(v113 + 1), (uint64_t)"mps.n_relu", 10, (__int16)v606, v112, 0, 0);
  v113[12] = v4;
  *v113 = off_1E0E29F30;
  v606 = (const char *)&v595;
  p_p = (const char *)v602;
  llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v113 + 13), (uint64_t *)&v606, (uint64_t *)&p_p);
  v113[16] = v113 + 18;
  v113[17] = 0x400000000;
  if (!v113[9])
  {
    v606 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::m"
           "ps::NReluOp, mlir::anec::NRelu>]";
    v607[0] = (void *)141;
    v114 = (char *)llvm::StringRef::find((uint64_t *)&v606, "DesiredTypeName = ", 0x12uLL, 0);
    if (v607[0] >= v114)
      v115 = v114;
    else
      v115 = (char *)v607[0];
    v116 = &v115[(_QWORD)v606];
    v117 = (char *)((char *)v607[0] - (char *)v115);
    if ((void *)((char *)v607[0] - (char *)v115) >= (void *)0x12)
      v118 = 18;
    else
      v118 = (char *)v607[0] - (char *)v115;
    v119 = &v116[v118];
    v120 = (unint64_t)&v117[-v118];
    if (v120 >= v120 - 1)
      --v120;
    v113[8] = v119;
    v113[9] = v120;
  }
  v121 = *((unsigned int *)v113 + 22);
  if (v121 > *((_DWORD *)v113 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v113 + 10), v113 + 12, v121, 16);
    LODWORD(v121) = *((_DWORD *)v113 + 22);
  }
  *((_DWORD *)v113 + 22) = v121;
  v123 = (char *)a3[2];
  v122 = a3[3];
  if ((unint64_t)v123 < v122)
  {
    *(_QWORD *)v123 = v113;
    v124 = v123 + 8;
    goto LABEL_189;
  }
  v125 = (char *)a3[1];
  v126 = (v123 - v125) >> 3;
  v127 = v126 + 1;
  if ((unint64_t)(v126 + 1) >> 61)
    goto LABEL_763;
  v128 = v122 - (_QWORD)v125;
  if (v128 >> 2 > v127)
    v127 = v128 >> 2;
  if ((unint64_t)v128 >= 0x7FFFFFFFFFFFFFF8)
    v129 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v129 = v127;
  if (v129)
  {
    if (v129 >> 61)
      goto LABEL_764;
    v130 = (char *)operator new(8 * v129);
  }
  else
  {
    v130 = 0;
  }
  v131 = &v130[8 * v126];
  v132 = &v130[8 * v129];
  *(_QWORD *)v131 = v113;
  v124 = v131 + 8;
  if (v123 == v125)
  {
    a3[1] = (uint64_t)v131;
    a3[2] = (uint64_t)v124;
    a3[3] = (uint64_t)v132;
    goto LABEL_187;
  }
  v133 = v123 - v125 - 8;
  if (v133 < 0x78
    || &v123[-(v133 & 0xFFFFFFFFFFFFFFF8) - 8] < v131 && &v130[v123 - v125 - (v133 & 0xFFFFFFFFFFFFFFF8) - 8] < v123)
  {
    goto LABEL_770;
  }
  v134 = (v133 >> 3) + 1;
  v135 = 8 * (v134 & 0x3FFFFFFFFFFFFFFCLL);
  v136 = &v123[-v135];
  v131 -= v135;
  v137 = &v130[8 * v126 - 16];
  v138 = v123 - 16;
  v139 = v134 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v141 = *((_OWORD *)v138 - 1);
    v140 = *(_OWORD *)v138;
    *((_OWORD *)v138 - 1) = 0uLL;
    *(_OWORD *)v138 = 0uLL;
    *((_OWORD *)v137 - 1) = v141;
    *(_OWORD *)v137 = v140;
    v137 -= 32;
    v138 -= 32;
    v139 -= 4;
  }
  while (v139);
  v123 = v136;
  if (v134 != (v134 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_770:
    do
    {
      v142 = *((_QWORD *)v123 - 1);
      v123 -= 8;
      *(_QWORD *)v123 = 0;
      *((_QWORD *)v131 - 1) = v142;
      v131 -= 8;
    }
    while (v123 != v125);
  }
  v123 = (char *)a3[1];
  v143 = (char *)a3[2];
  a3[1] = (uint64_t)v131;
  a3[2] = (uint64_t)v124;
  a3[3] = (uint64_t)v132;
  if (v143 == v123)
  {
    v4 = v591;
LABEL_187:
    v7 = v590;
    if (!v123)
      goto LABEL_189;
    goto LABEL_188;
  }
  v7 = v590;
  do
  {
    v145 = *((_QWORD *)v143 - 1);
    v143 -= 8;
    v144 = v145;
    *(_QWORD *)v143 = 0;
    if (v145)
      (*(void (**)(uint64_t))(*(_QWORD *)v144 + 8))(v144);
  }
  while (v143 != v123);
  v4 = v591;
  if (v123)
LABEL_188:
    operator delete(v123);
LABEL_189:
  a3[2] = (uint64_t)v124;
  if ((v601 & 0x80000000) == 0)
  {
LABEL_190:
    if ((v597 & 0x80000000) == 0)
      goto LABEL_192;
    goto LABEL_191;
  }
  operator delete(v599[0]);
  if (v597 < 0)
LABEL_191:
    operator delete(v596[0]);
LABEL_192:
  v146 = *a3;
  v608 = 5;
  LODWORD(v606) = 1;
  strcpy((char *)v607, "slope");
  llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v595, 0.0);
  llvm::APFloat::Storage::Storage(v605, &v595, v43);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v595);
  std::pair<llvm::APFloat,std::string>::pair[abi:nn180100]<llvm::APFloat,char const(&)[7],0>((uint64_t)&v595, (uint64_t)&p_p, "offset");
  v147 = (char *)operator new(0x170uLL);
  mlir::PatternBenefit::PatternBenefit(&v592, 1);
  mlir::Pattern::Pattern((uint64_t)(v147 + 8), (uint64_t)"mps.prelu", 9, (__int16)v592, v146, 0, 0);
  *((_QWORD *)v147 + 12) = v4;
  *(_QWORD *)v147 = off_1E0E29FA0;
  v592 = (const char *)&v606;
  v594 = v609;
  llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v147 + 104), (uint64_t *)&v592, (uint64_t *)&v594);
  *((_QWORD *)v147 + 16) = v147 + 144;
  *((_QWORD *)v147 + 17) = 0x400000000;
  llvm::SmallVectorImpl<std::pair<llvm::APFloat,std::string>>::append<std::pair<llvm::APFloat,std::string> const*,void>((unsigned int *)v147 + 32, (uint64_t)&v595, (uint64_t)v600);
  if (!*((_QWORD *)v147 + 9))
  {
    v592 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::m"
           "ps::PReluOp, mlir::anec::LeakyRelu>]";
    v593 = 145;
    v148 = llvm::StringRef::find((uint64_t *)&v592, "DesiredTypeName = ", 0x12uLL, 0);
    if (v593 >= v148)
      v149 = v148;
    else
      v149 = v593;
    v150 = &v592[v149];
    v151 = v593 - v149;
    if (v593 - v149 >= 0x12)
      v152 = 18;
    else
      v152 = v593 - v149;
    v153 = &v150[v152];
    v154 = v151 - v152;
    if (v154 >= v154 - 1)
      --v154;
    *((_QWORD *)v147 + 8) = v153;
    *((_QWORD *)v147 + 9) = v154;
  }
  v155 = *((unsigned int *)v147 + 22);
  if (v155 > *((_DWORD *)v147 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v147 + 80), v147 + 96, v155, 16);
    LODWORD(v155) = *((_DWORD *)v147 + 22);
  }
  *((_DWORD *)v147 + 22) = v155;
  v157 = (char *)a3[2];
  v156 = a3[3];
  if ((unint64_t)v157 < v156)
  {
    *(_QWORD *)v157 = v147;
    v158 = v157 + 8;
    goto LABEL_237;
  }
  v159 = (char *)a3[1];
  v160 = (v157 - v159) >> 3;
  v161 = v160 + 1;
  if ((unint64_t)(v160 + 1) >> 61)
    goto LABEL_763;
  v162 = v156 - (_QWORD)v159;
  if (v162 >> 2 > v161)
    v161 = v162 >> 2;
  if ((unint64_t)v162 >= 0x7FFFFFFFFFFFFFF8)
    v163 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v163 = v161;
  if (v163)
  {
    if (v163 >> 61)
      goto LABEL_764;
    v164 = (char *)operator new(8 * v163);
  }
  else
  {
    v164 = 0;
  }
  v165 = &v164[8 * v160];
  v166 = &v164[8 * v163];
  *(_QWORD *)v165 = v147;
  v158 = v165 + 8;
  if (v157 == v159)
  {
    a3[1] = (uint64_t)v165;
    a3[2] = (uint64_t)v158;
    a3[3] = (uint64_t)v166;
    a2 = v589;
    goto LABEL_235;
  }
  v167 = v157 - v159 - 8;
  if (v167 < 0x78
    || &v157[-(v167 & 0xFFFFFFFFFFFFFFF8) - 8] < v165 && &v164[v157 - v159 - (v167 & 0xFFFFFFFFFFFFFFF8) - 8] < v157)
  {
    goto LABEL_771;
  }
  v168 = (v167 >> 3) + 1;
  v169 = 8 * (v168 & 0x3FFFFFFFFFFFFFFCLL);
  v170 = &v157[-v169];
  v165 -= v169;
  v171 = &v164[8 * v160 - 16];
  v172 = v157 - 16;
  v173 = v168 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v175 = *((_OWORD *)v172 - 1);
    v174 = *(_OWORD *)v172;
    *((_OWORD *)v172 - 1) = 0uLL;
    *(_OWORD *)v172 = 0uLL;
    *((_OWORD *)v171 - 1) = v175;
    *(_OWORD *)v171 = v174;
    v171 -= 32;
    v172 -= 32;
    v173 -= 4;
  }
  while (v173);
  v157 = v170;
  if (v168 != (v168 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_771:
    do
    {
      v176 = *((_QWORD *)v157 - 1);
      v157 -= 8;
      *(_QWORD *)v157 = 0;
      *((_QWORD *)v165 - 1) = v176;
      v165 -= 8;
    }
    while (v157 != v159);
  }
  v157 = (char *)a3[1];
  v177 = (char *)a3[2];
  a3[1] = (uint64_t)v165;
  a3[2] = (uint64_t)v158;
  a3[3] = (uint64_t)v166;
  if (v177 == v157)
  {
    a2 = v589;
    v4 = v591;
LABEL_235:
    v7 = v590;
    if (!v157)
      goto LABEL_237;
    goto LABEL_236;
  }
  a2 = v589;
  v7 = v590;
  do
  {
    v179 = *((_QWORD *)v177 - 1);
    v177 -= 8;
    v178 = v179;
    *(_QWORD *)v177 = 0;
    if (v179)
      (*(void (**)(uint64_t))(*(_QWORD *)v178 + 8))(v178);
  }
  while (v177 != v157);
  v4 = v591;
  if (v157)
LABEL_236:
    operator delete(v157);
LABEL_237:
  a3[2] = (uint64_t)v158;
  if (SHIBYTE(v599[1]) < 0)
    operator delete(__p);
  if (v77 == v596[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v596);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v596);
  if (v77 != (void *)v605[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v605);
    if ((v608 & 0x80000000) == 0)
      goto LABEL_245;
    goto LABEL_244;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v605);
  if (v608 < 0)
LABEL_244:
    operator delete(v607[0]);
LABEL_245:
  llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v595, 6.0);
  llvm::APFloat::Storage::Storage(v607, &v595, v43);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v595);
  std::pair<llvm::APFloat,std::string>::pair[abi:nn180100]<llvm::APFloat,char const(&)[7],0>((uint64_t)&v595, (uint64_t)&v606, "max_value");
  llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v592, 0.0);
  llvm::APFloat::Storage::Storage(v605, &v592, v43);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v592);
  std::pair<llvm::APFloat,std::string>::pair[abi:nn180100]<llvm::APFloat,char const(&)[7],0>((uint64_t)v600, (uint64_t)&p_p, "slope");
  if (v7 < 0)
    goto LABEL_290;
  v180 = *a3;
  v181 = (char *)operator new(0x170uLL);
  mlir::PatternBenefit::PatternBenefit(&v592, 1);
  mlir::Pattern::Pattern((uint64_t)(v181 + 8), (uint64_t)"mps.relu6", 9, (__int16)v592, v180, 0, 0);
  *((_QWORD *)v181 + 12) = v4;
  *(_QWORD *)v181 = off_1E0E2A010;
  v592 = 0;
  v594 = 0;
  llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v181 + 104), (uint64_t *)&v592, (uint64_t *)&v594);
  *((_QWORD *)v181 + 16) = v181 + 144;
  *((_QWORD *)v181 + 17) = 0x400000000;
  llvm::SmallVectorImpl<std::pair<llvm::APFloat,std::string>>::append<std::pair<llvm::APFloat,std::string> const*,void>((unsigned int *)v181 + 32, (uint64_t)&v595, (uint64_t)&p_p);
  if (!*((_QWORD *)v181 + 9))
  {
    v592 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::m"
           "ps::Relu6Op, mlir::anec::NRelu>]";
    v593 = 141;
    v182 = llvm::StringRef::find((uint64_t *)&v592, "DesiredTypeName = ", 0x12uLL, 0);
    if (v593 >= v182)
      v183 = v182;
    else
      v183 = v593;
    v184 = &v592[v183];
    v185 = v593 - v183;
    if (v593 - v183 >= 0x12)
      v186 = 18;
    else
      v186 = v593 - v183;
    v187 = &v184[v186];
    v188 = v185 - v186;
    if (v188 >= v188 - 1)
      --v188;
    *((_QWORD *)v181 + 8) = v187;
    *((_QWORD *)v181 + 9) = v188;
  }
  v189 = *((unsigned int *)v181 + 22);
  if (v189 > *((_DWORD *)v181 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v181 + 80), v181 + 96, v189, 16);
    LODWORD(v189) = *((_DWORD *)v181 + 22);
  }
  *((_DWORD *)v181 + 22) = v189;
  v191 = (char *)a3[2];
  v190 = a3[3];
  if ((unint64_t)v191 >= v190)
  {
    v193 = (char *)a3[1];
    v194 = (v191 - v193) >> 3;
    v195 = v194 + 1;
    if ((unint64_t)(v194 + 1) >> 61)
      goto LABEL_763;
    v196 = v190 - (_QWORD)v193;
    if (v196 >> 2 > v195)
      v195 = v196 >> 2;
    if ((unint64_t)v196 >= 0x7FFFFFFFFFFFFFF8)
      v197 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v197 = v195;
    if (v197)
    {
      if (v197 >> 61)
        goto LABEL_764;
      v198 = (char *)operator new(8 * v197);
    }
    else
    {
      v198 = 0;
    }
    v199 = &v198[8 * v194];
    v200 = &v198[8 * v197];
    *(_QWORD *)v199 = v181;
    v192 = v199 + 8;
    if (v191 == v193)
    {
      a3[1] = (uint64_t)v199;
      a3[2] = (uint64_t)v192;
      a3[3] = (uint64_t)v200;
      a2 = v589;
    }
    else
    {
      v201 = v191 - v193 - 8;
      a2 = v589;
      if (v201 < 0x78
        || &v191[-(v201 & 0xFFFFFFFFFFFFFFF8) - 8] < v199
        && &v198[v191 - v193 - (v201 & 0xFFFFFFFFFFFFFFF8) - 8] < v191)
      {
        goto LABEL_772;
      }
      v202 = (v201 >> 3) + 1;
      v203 = 8 * (v202 & 0x3FFFFFFFFFFFFFFCLL);
      v204 = &v191[-v203];
      v199 -= v203;
      v205 = &v198[8 * v194 - 16];
      v206 = v191 - 16;
      v207 = v202 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v209 = *((_OWORD *)v206 - 1);
        v208 = *(_OWORD *)v206;
        *((_OWORD *)v206 - 1) = 0uLL;
        *(_OWORD *)v206 = 0uLL;
        *((_OWORD *)v205 - 1) = v209;
        *(_OWORD *)v205 = v208;
        v205 -= 32;
        v206 -= 32;
        v207 -= 4;
      }
      while (v207);
      v191 = v204;
      if (v202 != (v202 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_772:
        do
        {
          v210 = *((_QWORD *)v191 - 1);
          v191 -= 8;
          *(_QWORD *)v191 = 0;
          *((_QWORD *)v199 - 1) = v210;
          v199 -= 8;
        }
        while (v191 != v193);
      }
      v191 = (char *)a3[1];
      v211 = (char *)a3[2];
      a3[1] = (uint64_t)v199;
      a3[2] = (uint64_t)v192;
      a3[3] = (uint64_t)v200;
      if (v211 != v191)
      {
        v7 = v590;
        v43 = v588;
        do
        {
          v213 = *((_QWORD *)v211 - 1);
          v211 -= 8;
          v212 = v213;
          *(_QWORD *)v211 = 0;
          if (v213)
            (*(void (**)(uint64_t))(*(_QWORD *)v212 + 8))(v212);
        }
        while (v211 != v191);
        goto LABEL_287;
      }
    }
    v7 = v590;
    v43 = v588;
LABEL_287:
    v4 = v591;
    if (v191)
      operator delete(v191);
    goto LABEL_289;
  }
  *(_QWORD *)v191 = v181;
  v192 = v191 + 8;
  a2 = v589;
LABEL_289:
  a3[2] = (uint64_t)v192;
LABEL_290:
  if (v603 < 0)
    operator delete((void *)v602[3]);
  if (v77 != (void *)v602[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v602);
    if ((SHIBYTE(v599[1]) & 0x80000000) == 0)
      goto LABEL_295;
    goto LABEL_294;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v602);
  if (SHIBYTE(v599[1]) < 0)
LABEL_294:
    operator delete(__p);
LABEL_295:
  if (v77 == v596[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v596);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v596);
  if (v77 == (void *)v605[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v605);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v605);
  if (v77 == v607[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v607);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v607);
  llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v595, 0.0);
  llvm::APFloat::Storage::Storage(v607, &v595, v43);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v595);
  std::pair<llvm::APFloat,std::string>::pair[abi:nn180100]<llvm::APFloat,char const(&)[7],0>((uint64_t)&v595, (uint64_t)&v606, "epsilon");
  if ((v7 & 0x80000000) == 0)
  {
    v214 = *a3;
    v215 = (char *)operator new(0x170uLL);
    mlir::PatternBenefit::PatternBenefit(&p_p, 1);
    mlir::Pattern::Pattern((uint64_t)(v215 + 8), (uint64_t)"mps.reciprocal", 14, (__int16)p_p, v214, 0, 0);
    *((_QWORD *)v215 + 12) = v4;
    *(_QWORD *)v215 = off_1E0E297C0;
    p_p = 0;
    v592 = 0;
    llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v215 + 104), (uint64_t *)&p_p, (uint64_t *)&v592);
    *((_QWORD *)v215 + 16) = v215 + 144;
    *((_QWORD *)v215 + 17) = 0x400000000;
    llvm::SmallVectorImpl<std::pair<llvm::APFloat,std::string>>::append<std::pair<llvm::APFloat,std::string> const*,void>((unsigned int *)v215 + 32, (uint64_t)&v595, (uint64_t)v600);
    if (!*((_QWORD *)v215 + 9))
    {
      p_p = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::"
            "mps::ReciprocalOp, mlir::anec::Invert>]";
      v605[0] = 147;
      v216 = llvm::StringRef::find((uint64_t *)&p_p, "DesiredTypeName = ", 0x12uLL, 0);
      if (v605[0] >= v216)
        v217 = v216;
      else
        v217 = v605[0];
      v218 = &p_p[v217];
      v219 = v605[0] - v217;
      if (v605[0] - v217 >= 0x12)
        v220 = 18;
      else
        v220 = v605[0] - v217;
      v221 = &v218[v220];
      v222 = v219 - v220;
      if (v222 >= v222 - 1)
        --v222;
      *((_QWORD *)v215 + 8) = v221;
      *((_QWORD *)v215 + 9) = v222;
    }
    v223 = *((unsigned int *)v215 + 22);
    if (v223 > *((_DWORD *)v215 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v215 + 80), v215 + 96, v223, 16);
      LODWORD(v223) = *((_DWORD *)v215 + 22);
    }
    *((_DWORD *)v215 + 22) = v223;
    v225 = (char *)a3[2];
    v224 = a3[3];
    if ((unint64_t)v225 < v224)
    {
      *(_QWORD *)v225 = v215;
      v226 = v225 + 8;
      goto LABEL_348;
    }
    v227 = (char *)a3[1];
    v228 = (v225 - v227) >> 3;
    v229 = v228 + 1;
    if ((unint64_t)(v228 + 1) >> 61)
      goto LABEL_763;
    v230 = v224 - (_QWORD)v227;
    if (v230 >> 2 > v229)
      v229 = v230 >> 2;
    if ((unint64_t)v230 >= 0x7FFFFFFFFFFFFFF8)
      v231 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v231 = v229;
    if (v231)
    {
      if (v231 >> 61)
        goto LABEL_764;
      v232 = (char *)operator new(8 * v231);
    }
    else
    {
      v232 = 0;
    }
    v233 = &v232[8 * v228];
    v234 = &v232[8 * v231];
    *(_QWORD *)v233 = v215;
    v226 = v233 + 8;
    if (v225 == v227)
    {
      a3[1] = (uint64_t)v233;
      a3[2] = (uint64_t)v226;
      a3[3] = (uint64_t)v234;
    }
    else
    {
      v235 = v225 - v227 - 8;
      if (v235 < 0x78
        || &v225[-(v235 & 0xFFFFFFFFFFFFFFF8) - 8] < v233
        && &v232[v225 - v227 - (v235 & 0xFFFFFFFFFFFFFFF8) - 8] < v225)
      {
        goto LABEL_773;
      }
      v236 = (v235 >> 3) + 1;
      v237 = 8 * (v236 & 0x3FFFFFFFFFFFFFFCLL);
      v238 = &v225[-v237];
      v233 -= v237;
      v239 = &v232[8 * v228 - 16];
      v240 = v225 - 16;
      v241 = v236 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v243 = *((_OWORD *)v240 - 1);
        v242 = *(_OWORD *)v240;
        *((_OWORD *)v240 - 1) = 0uLL;
        *(_OWORD *)v240 = 0uLL;
        *((_OWORD *)v239 - 1) = v243;
        *(_OWORD *)v239 = v242;
        v239 -= 32;
        v240 -= 32;
        v241 -= 4;
      }
      while (v241);
      v225 = v238;
      if (v236 != (v236 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_773:
        do
        {
          v244 = *((_QWORD *)v225 - 1);
          v225 -= 8;
          *(_QWORD *)v225 = 0;
          *((_QWORD *)v233 - 1) = v244;
          v233 -= 8;
        }
        while (v225 != v227);
      }
      v225 = (char *)a3[1];
      v245 = (char *)a3[2];
      a3[1] = (uint64_t)v233;
      a3[2] = (uint64_t)v226;
      a3[3] = (uint64_t)v234;
      if (v245 != v225)
      {
        a2 = v589;
        v7 = v590;
        do
        {
          v247 = *((_QWORD *)v245 - 1);
          v245 -= 8;
          v246 = v247;
          *(_QWORD *)v245 = 0;
          if (v247)
            (*(void (**)(uint64_t))(*(_QWORD *)v246 + 8))(v246);
        }
        while (v245 != v225);
        goto LABEL_346;
      }
    }
    a2 = v589;
    v7 = v590;
LABEL_346:
    v4 = v591;
    if (v225)
      operator delete(v225);
LABEL_348:
    a3[2] = (uint64_t)v226;
    if (v7 < 2)
      goto LABEL_431;
    v248 = *a3;
    v249 = (char *)operator new(0x170uLL);
    mlir::PatternBenefit::PatternBenefit(&p_p, 1);
    mlir::Pattern::Pattern((uint64_t)(v249 + 8), (uint64_t)"mps.reciprocal_square_root", 26, (__int16)p_p, v248, 0, 0);
    *((_QWORD *)v249 + 12) = v4;
    *(_QWORD *)v249 = off_1E0DFAC78;
    p_p = 0;
    v592 = 0;
    llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v249 + 104), (uint64_t *)&p_p, (uint64_t *)&v592);
    *((_QWORD *)v249 + 16) = v249 + 144;
    *((_QWORD *)v249 + 17) = 0x400000000;
    llvm::SmallVectorImpl<std::pair<llvm::APFloat,std::string>>::append<std::pair<llvm::APFloat,std::string> const*,void>((unsigned int *)v249 + 32, (uint64_t)&v595, (uint64_t)v600);
    if (!*((_QWORD *)v249 + 9))
    {
      p_p = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::"
            "mps::ReciprocalSquareRootOp, mlir::anec::Rsqrt>]";
      v605[0] = 156;
      v250 = llvm::StringRef::find((uint64_t *)&p_p, "DesiredTypeName = ", 0x12uLL, 0);
      if (v605[0] >= v250)
        v251 = v250;
      else
        v251 = v605[0];
      v252 = &p_p[v251];
      v253 = v605[0] - v251;
      if (v605[0] - v251 >= 0x12)
        v254 = 18;
      else
        v254 = v605[0] - v251;
      v255 = &v252[v254];
      v256 = v253 - v254;
      if (v256 >= v256 - 1)
        --v256;
      *((_QWORD *)v249 + 8) = v255;
      *((_QWORD *)v249 + 9) = v256;
    }
    v257 = *((unsigned int *)v249 + 22);
    if (v257 > *((_DWORD *)v249 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v249 + 80), v249 + 96, v257, 16);
      LODWORD(v257) = *((_DWORD *)v249 + 22);
    }
    *((_DWORD *)v249 + 22) = v257;
    v259 = (char *)a3[2];
    v258 = a3[3];
    if ((unint64_t)v259 < v258)
    {
      *(_QWORD *)v259 = v249;
      v260 = v259 + 8;
      goto LABEL_390;
    }
    v261 = (char *)a3[1];
    v262 = (v259 - v261) >> 3;
    v263 = v262 + 1;
    if ((unint64_t)(v262 + 1) >> 61)
      goto LABEL_763;
    v264 = v258 - (_QWORD)v261;
    if (v264 >> 2 > v263)
      v263 = v264 >> 2;
    if ((unint64_t)v264 >= 0x7FFFFFFFFFFFFFF8)
      v265 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v265 = v263;
    if (v265)
    {
      if (v265 >> 61)
        goto LABEL_764;
      v266 = (char *)operator new(8 * v265);
    }
    else
    {
      v266 = 0;
    }
    v267 = &v266[8 * v262];
    v268 = &v266[8 * v265];
    *(_QWORD *)v267 = v249;
    v260 = v267 + 8;
    if (v259 == v261)
    {
      a3[1] = (uint64_t)v267;
      a3[2] = (uint64_t)v260;
      a3[3] = (uint64_t)v268;
    }
    else
    {
      v269 = v259 - v261 - 8;
      if (v269 < 0x78
        || &v259[-(v269 & 0xFFFFFFFFFFFFFFF8) - 8] < v267
        && &v266[v259 - v261 - (v269 & 0xFFFFFFFFFFFFFFF8) - 8] < v259)
      {
        goto LABEL_774;
      }
      v270 = (v269 >> 3) + 1;
      v271 = 8 * (v270 & 0x3FFFFFFFFFFFFFFCLL);
      v272 = &v259[-v271];
      v267 -= v271;
      v273 = &v266[8 * v262 - 16];
      v274 = v259 - 16;
      v275 = v270 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v277 = *((_OWORD *)v274 - 1);
        v276 = *(_OWORD *)v274;
        *((_OWORD *)v274 - 1) = 0uLL;
        *(_OWORD *)v274 = 0uLL;
        *((_OWORD *)v273 - 1) = v277;
        *(_OWORD *)v273 = v276;
        v273 -= 32;
        v274 -= 32;
        v275 -= 4;
      }
      while (v275);
      v259 = v272;
      if (v270 != (v270 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_774:
        do
        {
          v278 = *((_QWORD *)v259 - 1);
          v259 -= 8;
          *(_QWORD *)v259 = 0;
          *((_QWORD *)v267 - 1) = v278;
          v267 -= 8;
        }
        while (v259 != v261);
      }
      v259 = (char *)a3[1];
      v279 = (char *)a3[2];
      a3[1] = (uint64_t)v267;
      a3[2] = (uint64_t)v260;
      a3[3] = (uint64_t)v268;
      if (v279 != v259)
      {
        a2 = v589;
        v7 = v590;
        do
        {
          v281 = *((_QWORD *)v279 - 1);
          v279 -= 8;
          v280 = v281;
          *(_QWORD *)v279 = 0;
          if (v281)
            (*(void (**)(uint64_t))(*(_QWORD *)v280 + 8))(v280);
        }
        while (v279 != v259);
        goto LABEL_388;
      }
    }
    a2 = v589;
    v7 = v590;
LABEL_388:
    v4 = v591;
    if (v259)
      operator delete(v259);
LABEL_390:
    a3[2] = (uint64_t)v260;
    v282 = *a3;
    v283 = (char *)operator new(0x170uLL);
    mlir::PatternBenefit::PatternBenefit(&p_p, 1);
    mlir::Pattern::Pattern((uint64_t)(v283 + 8), (uint64_t)"mps.logarithm_base_2", 20, (__int16)p_p, v282, 0, 0);
    *((_QWORD *)v283 + 12) = v4;
    *(_QWORD *)v283 = off_1E0E29910;
    p_p = 0;
    v592 = 0;
    llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v283 + 104), (uint64_t *)&p_p, (uint64_t *)&v592);
    *((_QWORD *)v283 + 16) = v283 + 144;
    *((_QWORD *)v283 + 17) = 0x400000000;
    llvm::SmallVectorImpl<std::pair<llvm::APFloat,std::string>>::append<std::pair<llvm::APFloat,std::string> const*,void>((unsigned int *)v283 + 32, (uint64_t)&v595, (uint64_t)v600);
    if (!*((_QWORD *)v283 + 9))
    {
      p_p = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::"
            "mps::LogarithmBase2Op, mlir::anec::Log2>]";
      v605[0] = 149;
      v284 = llvm::StringRef::find((uint64_t *)&p_p, "DesiredTypeName = ", 0x12uLL, 0);
      if (v605[0] >= v284)
        v285 = v284;
      else
        v285 = v605[0];
      v286 = &p_p[v285];
      v287 = v605[0] - v285;
      if (v605[0] - v285 >= 0x12)
        v288 = 18;
      else
        v288 = v605[0] - v285;
      v289 = &v286[v288];
      v290 = v287 - v288;
      if (v290 >= v290 - 1)
        --v290;
      *((_QWORD *)v283 + 8) = v289;
      *((_QWORD *)v283 + 9) = v290;
    }
    v291 = *((unsigned int *)v283 + 22);
    if (v291 > *((_DWORD *)v283 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v283 + 80), v283 + 96, v291, 16);
      LODWORD(v291) = *((_DWORD *)v283 + 22);
    }
    *((_DWORD *)v283 + 22) = v291;
    v293 = (char *)a3[2];
    v292 = a3[3];
    if ((unint64_t)v293 < v292)
    {
      *(_QWORD *)v293 = v283;
      v294 = v293 + 8;
LABEL_430:
      a3[2] = (uint64_t)v294;
      goto LABEL_431;
    }
    v295 = (char *)a3[1];
    v296 = (v293 - v295) >> 3;
    v297 = v296 + 1;
    if ((unint64_t)(v296 + 1) >> 61)
      goto LABEL_763;
    v298 = v292 - (_QWORD)v295;
    if (v298 >> 2 > v297)
      v297 = v298 >> 2;
    if ((unint64_t)v298 >= 0x7FFFFFFFFFFFFFF8)
      v299 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v299 = v297;
    if (v299)
    {
      if (v299 >> 61)
        goto LABEL_764;
      v300 = (char *)operator new(8 * v299);
    }
    else
    {
      v300 = 0;
    }
    v301 = &v300[8 * v296];
    v302 = &v300[8 * v299];
    *(_QWORD *)v301 = v283;
    v294 = v301 + 8;
    if (v293 == v295)
    {
      a3[1] = (uint64_t)v301;
      a3[2] = (uint64_t)v294;
      a3[3] = (uint64_t)v302;
      v7 = v590;
    }
    else
    {
      v303 = v293 - v295 - 8;
      if (v303 < 0x78
        || &v293[-(v303 & 0xFFFFFFFFFFFFFFF8) - 8] < v301
        && &v300[v293 - v295 - (v303 & 0xFFFFFFFFFFFFFFF8) - 8] < v293)
      {
        goto LABEL_775;
      }
      v304 = (v303 >> 3) + 1;
      v305 = 8 * (v304 & 0x3FFFFFFFFFFFFFFCLL);
      v306 = &v293[-v305];
      v301 -= v305;
      v307 = &v300[8 * v296 - 16];
      v308 = v293 - 16;
      v309 = v304 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v311 = *((_OWORD *)v308 - 1);
        v310 = *(_OWORD *)v308;
        *((_OWORD *)v308 - 1) = 0uLL;
        *(_OWORD *)v308 = 0uLL;
        *((_OWORD *)v307 - 1) = v311;
        *(_OWORD *)v307 = v310;
        v307 -= 32;
        v308 -= 32;
        v309 -= 4;
      }
      while (v309);
      v293 = v306;
      if (v304 != (v304 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_775:
        do
        {
          v312 = *((_QWORD *)v293 - 1);
          v293 -= 8;
          *(_QWORD *)v293 = 0;
          *((_QWORD *)v301 - 1) = v312;
          v301 -= 8;
        }
        while (v293 != v295);
      }
      v293 = (char *)a3[1];
      v313 = (char *)a3[2];
      a3[1] = (uint64_t)v301;
      a3[2] = (uint64_t)v294;
      a3[3] = (uint64_t)v302;
      if (v313 == v293)
      {
        v7 = v590;
        v4 = v591;
        if (!v293)
          goto LABEL_430;
        goto LABEL_429;
      }
      v7 = v590;
      do
      {
        v315 = *((_QWORD *)v313 - 1);
        v313 -= 8;
        v314 = v315;
        *(_QWORD *)v313 = 0;
        if (v315)
          (*(void (**)(uint64_t))(*(_QWORD *)v314 + 8))(v314);
      }
      while (v313 != v293);
    }
    v4 = v591;
    if (!v293)
      goto LABEL_430;
LABEL_429:
    operator delete(v293);
    goto LABEL_430;
  }
LABEL_431:
  if (SHIBYTE(v599[1]) < 0)
    operator delete(__p);
  if (v77 == v596[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v596);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v596);
  if (v77 == v607[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v607);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v607);
  v597 = 5;
  LODWORD(v595) = 1;
  strcpy((char *)v596, "alpha");
  if (v7 < 2)
    goto LABEL_481;
  v316 = *a3;
  v317 = operator new(0x170uLL);
  mlir::PatternBenefit::PatternBenefit(&v606, 1);
  mlir::Pattern::Pattern((uint64_t)(v317 + 1), (uint64_t)"mps.elu", 7, (__int16)v606, v316, 0, 0);
  v317[12] = v4;
  *v317 = off_1E0E299F0;
  v606 = (const char *)&v595;
  p_p = (const char *)&__p;
  llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>((uint64_t)(v317 + 13), (uint64_t *)&v606, (uint64_t *)&p_p);
  v317[16] = v317 + 18;
  v317[17] = 0x400000000;
  if (!v317[9])
  {
    v606 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertElementwiseUnary<mlir::m"
           "ps::EluOp, mlir::anec::Elu>]";
    v607[0] = (void *)137;
    v318 = (char *)llvm::StringRef::find((uint64_t *)&v606, "DesiredTypeName = ", 0x12uLL, 0);
    if (v607[0] >= v318)
      v319 = v318;
    else
      v319 = (char *)v607[0];
    v320 = &v319[(_QWORD)v606];
    v321 = (char *)((char *)v607[0] - (char *)v319);
    if ((void *)((char *)v607[0] - (char *)v319) >= (void *)0x12)
      v322 = 18;
    else
      v322 = (char *)v607[0] - (char *)v319;
    v323 = &v320[v322];
    v324 = (unint64_t)&v321[-v322];
    if (v324 >= v324 - 1)
      --v324;
    v317[8] = v323;
    v317[9] = v324;
  }
  v325 = *((unsigned int *)v317 + 22);
  if (v325 > *((_DWORD *)v317 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v317 + 10), v317 + 12, v325, 16);
    LODWORD(v325) = *((_DWORD *)v317 + 22);
  }
  *((_DWORD *)v317 + 22) = v325;
  v327 = (char *)a3[2];
  v326 = a3[3];
  if ((unint64_t)v327 < v326)
  {
    *(_QWORD *)v327 = v317;
    v328 = v327 + 8;
    goto LABEL_480;
  }
  v329 = (char *)a3[1];
  v330 = (v327 - v329) >> 3;
  v331 = v330 + 1;
  if ((unint64_t)(v330 + 1) >> 61)
    goto LABEL_763;
  v332 = v326 - (_QWORD)v329;
  if (v332 >> 2 > v331)
    v331 = v332 >> 2;
  if ((unint64_t)v332 >= 0x7FFFFFFFFFFFFFF8)
    v333 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v333 = v331;
  if (v333)
  {
    if (v333 >> 61)
      goto LABEL_764;
    v334 = (char *)operator new(8 * v333);
  }
  else
  {
    v334 = 0;
  }
  v335 = &v334[8 * v330];
  v336 = &v334[8 * v333];
  *(_QWORD *)v335 = v317;
  v328 = v335 + 8;
  if (v327 == v329)
  {
    a3[1] = (uint64_t)v335;
    a3[2] = (uint64_t)v328;
    a3[3] = (uint64_t)v336;
    v7 = v590;
    goto LABEL_478;
  }
  v337 = v327 - v329 - 8;
  if (v337 < 0x78
    || &v327[-(v337 & 0xFFFFFFFFFFFFFFF8) - 8] < v335 && &v334[v327 - v329 - (v337 & 0xFFFFFFFFFFFFFFF8) - 8] < v327)
  {
    goto LABEL_776;
  }
  v338 = (v337 >> 3) + 1;
  v339 = 8 * (v338 & 0x3FFFFFFFFFFFFFFCLL);
  v340 = &v327[-v339];
  v335 -= v339;
  v341 = &v334[8 * v330 - 16];
  v342 = v327 - 16;
  v343 = v338 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v345 = *((_OWORD *)v342 - 1);
    v344 = *(_OWORD *)v342;
    *((_OWORD *)v342 - 1) = 0uLL;
    *(_OWORD *)v342 = 0uLL;
    *((_OWORD *)v341 - 1) = v345;
    *(_OWORD *)v341 = v344;
    v341 -= 32;
    v342 -= 32;
    v343 -= 4;
  }
  while (v343);
  v327 = v340;
  if (v338 != (v338 & 0x3FFFFFFFFFFFFFFCLL))
  {
LABEL_776:
    do
    {
      v346 = *((_QWORD *)v327 - 1);
      v327 -= 8;
      *(_QWORD *)v327 = 0;
      *((_QWORD *)v335 - 1) = v346;
      v335 -= 8;
    }
    while (v327 != v329);
  }
  v327 = (char *)a3[1];
  v347 = (char *)a3[2];
  a3[1] = (uint64_t)v335;
  a3[2] = (uint64_t)v328;
  a3[3] = (uint64_t)v336;
  if (v347 != v327)
  {
    v7 = v590;
    do
    {
      v349 = *((_QWORD *)v347 - 1);
      v347 -= 8;
      v348 = v349;
      *(_QWORD *)v347 = 0;
      if (v349)
        (*(void (**)(uint64_t))(*(_QWORD *)v348 + 8))(v348);
    }
    while (v347 != v327);
LABEL_478:
    v4 = v591;
    if (!v327)
      goto LABEL_480;
    goto LABEL_479;
  }
  v7 = v590;
  v4 = v591;
  if (v327)
LABEL_479:
    operator delete(v327);
LABEL_480:
  a3[2] = (uint64_t)v328;
  if (v597 < 0)
  {
    operator delete(v596[0]);
    if (v7 < 0)
      return;
    goto LABEL_482;
  }
LABEL_481:
  if (v7 < 0)
    return;
LABEL_482:
  v350 = *a3;
  v351 = operator new(0x70uLL);
  mlir::PatternBenefit::PatternBenefit(&v595, 1);
  mlir::Pattern::Pattern((uint64_t)(v351 + 1), (uint64_t)"mps.dequantize", 14, (__int16)v595, v350, 0, 0);
  v351[12] = v4;
  *v351 = &off_1E0E294B0;
  *((_BYTE *)v351 + 104) = a2;
  if (!v351[9])
  {
    v595 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertQuantizationOp<mlir::mps"
           "::DequantizeOp>]";
    v596[0] = (void *)125;
    v352 = (char *)llvm::StringRef::find((uint64_t *)&v595, "DesiredTypeName = ", 0x12uLL, 0);
    if (v596[0] >= v352)
      v353 = v352;
    else
      v353 = (char *)v596[0];
    v354 = &v353[(_QWORD)v595];
    v355 = (char *)((char *)v596[0] - (char *)v353);
    if ((void *)((char *)v596[0] - (char *)v353) >= (void *)0x12)
      v356 = 18;
    else
      v356 = (char *)v596[0] - (char *)v353;
    v357 = &v354[v356];
    v358 = (unint64_t)&v355[-v356];
    if (v358 >= v358 - 1)
      --v358;
    v351[8] = v357;
    v351[9] = v358;
  }
  v359 = *((unsigned int *)v351 + 22);
  if (v359 > *((_DWORD *)v351 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v351 + 10), v351 + 12, v359, 16);
    LODWORD(v359) = *((_DWORD *)v351 + 22);
  }
  *((_DWORD *)v351 + 22) = v359;
  v361 = (char *)a3[2];
  v360 = a3[3];
  if ((unint64_t)v361 >= v360)
  {
    v363 = (char *)a3[1];
    v364 = (v361 - v363) >> 3;
    v365 = v364 + 1;
    if ((unint64_t)(v364 + 1) >> 61)
      goto LABEL_763;
    v366 = v360 - (_QWORD)v363;
    if (v366 >> 2 > v365)
      v365 = v366 >> 2;
    if ((unint64_t)v366 >= 0x7FFFFFFFFFFFFFF8)
      v367 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v367 = v365;
    if (v367)
    {
      if (v367 >> 61)
        goto LABEL_764;
      v368 = (char *)operator new(8 * v367);
    }
    else
    {
      v368 = 0;
    }
    v369 = &v368[8 * v364];
    v370 = &v368[8 * v367];
    *(_QWORD *)v369 = v351;
    v362 = v369 + 8;
    if (v361 == v363)
    {
      a3[1] = (uint64_t)v369;
      a3[2] = (uint64_t)v362;
      a3[3] = (uint64_t)v370;
    }
    else
    {
      v371 = v361 - v363 - 8;
      if (v371 < 0x78
        || &v361[-(v371 & 0xFFFFFFFFFFFFFFF8) - 8] < v369
        && &v368[v361 - v363 - (v371 & 0xFFFFFFFFFFFFFFF8) - 8] < v361)
      {
        goto LABEL_777;
      }
      v372 = (v371 >> 3) + 1;
      v373 = 8 * (v372 & 0x3FFFFFFFFFFFFFFCLL);
      v374 = &v361[-v373];
      v369 -= v373;
      v375 = &v368[8 * v364 - 16];
      v376 = v361 - 16;
      v377 = v372 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v379 = *((_OWORD *)v376 - 1);
        v378 = *(_OWORD *)v376;
        *((_OWORD *)v376 - 1) = 0uLL;
        *(_OWORD *)v376 = 0uLL;
        *((_OWORD *)v375 - 1) = v379;
        *(_OWORD *)v375 = v378;
        v375 -= 32;
        v376 -= 32;
        v377 -= 4;
      }
      while (v377);
      v361 = v374;
      if (v372 != (v372 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_777:
        do
        {
          v380 = *((_QWORD *)v361 - 1);
          v361 -= 8;
          *(_QWORD *)v361 = 0;
          *((_QWORD *)v369 - 1) = v380;
          v369 -= 8;
        }
        while (v361 != v363);
      }
      v361 = (char *)a3[1];
      v381 = (char *)a3[2];
      a3[1] = (uint64_t)v369;
      a3[2] = (uint64_t)v362;
      a3[3] = (uint64_t)v370;
      while (v381 != v361)
      {
        v383 = *((_QWORD *)v381 - 1);
        v381 -= 8;
        v382 = v383;
        *(_QWORD *)v381 = 0;
        if (v383)
          (*(void (**)(uint64_t))(*(_QWORD *)v382 + 8))(v382);
      }
    }
    v4 = v591;
    if (v361)
      operator delete(v361);
  }
  else
  {
    *(_QWORD *)v361 = v351;
    v362 = v361 + 8;
  }
  a3[2] = (uint64_t)v362;
  v384 = *a3;
  v385 = operator new(0x70uLL);
  mlir::PatternBenefit::PatternBenefit(&v595, 1);
  mlir::Pattern::Pattern((uint64_t)(v385 + 1), (uint64_t)"mps.quantize", 12, (__int16)v595, v384, 0, 0);
  v385[12] = v4;
  *v385 = &off_1E0E29440;
  *((_BYTE *)v385 + 104) = a2;
  if (!v385[9])
  {
    v595 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertQuantizationOp<mlir::mps::QuantizeOp>]";
    v596[0] = (void *)123;
    v386 = (char *)llvm::StringRef::find((uint64_t *)&v595, "DesiredTypeName = ", 0x12uLL, 0);
    if (v596[0] >= v386)
      v387 = v386;
    else
      v387 = (char *)v596[0];
    v388 = &v387[(_QWORD)v595];
    v389 = (char *)((char *)v596[0] - (char *)v387);
    if ((void *)((char *)v596[0] - (char *)v387) >= (void *)0x12)
      v390 = 18;
    else
      v390 = (char *)v596[0] - (char *)v387;
    v391 = &v388[v390];
    v392 = (unint64_t)&v389[-v390];
    if (v392 >= v392 - 1)
      --v392;
    v385[8] = v391;
    v385[9] = v392;
  }
  v393 = *((unsigned int *)v385 + 22);
  if (v393 > *((_DWORD *)v385 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v385 + 10), v385 + 12, v393, 16);
    LODWORD(v393) = *((_DWORD *)v385 + 22);
  }
  *((_DWORD *)v385 + 22) = v393;
  v395 = (char *)a3[2];
  v394 = a3[3];
  if ((unint64_t)v395 >= v394)
  {
    v397 = (char *)a3[1];
    v398 = (v395 - v397) >> 3;
    v399 = v398 + 1;
    if ((unint64_t)(v398 + 1) >> 61)
      goto LABEL_763;
    v400 = v394 - (_QWORD)v397;
    if (v400 >> 2 > v399)
      v399 = v400 >> 2;
    if ((unint64_t)v400 >= 0x7FFFFFFFFFFFFFF8)
      v401 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v401 = v399;
    if (v401)
    {
      if (v401 >> 61)
        goto LABEL_764;
      v402 = (char *)operator new(8 * v401);
    }
    else
    {
      v402 = 0;
    }
    v403 = &v402[8 * v398];
    v404 = &v402[8 * v401];
    *(_QWORD *)v403 = v385;
    v396 = v403 + 8;
    if (v395 == v397)
    {
      a3[1] = (uint64_t)v403;
      a3[2] = (uint64_t)v396;
      a3[3] = (uint64_t)v404;
    }
    else
    {
      v405 = v395 - v397 - 8;
      if (v405 < 0x78
        || &v395[-(v405 & 0xFFFFFFFFFFFFFFF8) - 8] < v403
        && &v402[v395 - v397 - (v405 & 0xFFFFFFFFFFFFFFF8) - 8] < v395)
      {
        goto LABEL_778;
      }
      v406 = (v405 >> 3) + 1;
      v407 = 8 * (v406 & 0x3FFFFFFFFFFFFFFCLL);
      v408 = &v395[-v407];
      v403 -= v407;
      v409 = &v402[8 * v398 - 16];
      v410 = v395 - 16;
      v411 = v406 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v413 = *((_OWORD *)v410 - 1);
        v412 = *(_OWORD *)v410;
        *((_OWORD *)v410 - 1) = 0uLL;
        *(_OWORD *)v410 = 0uLL;
        *((_OWORD *)v409 - 1) = v413;
        *(_OWORD *)v409 = v412;
        v409 -= 32;
        v410 -= 32;
        v411 -= 4;
      }
      while (v411);
      v395 = v408;
      if (v406 != (v406 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_778:
        do
        {
          v414 = *((_QWORD *)v395 - 1);
          v395 -= 8;
          *(_QWORD *)v395 = 0;
          *((_QWORD *)v403 - 1) = v414;
          v403 -= 8;
        }
        while (v395 != v397);
      }
      v395 = (char *)a3[1];
      v415 = (char *)a3[2];
      a3[1] = (uint64_t)v403;
      a3[2] = (uint64_t)v396;
      a3[3] = (uint64_t)v404;
      while (v415 != v395)
      {
        v417 = *((_QWORD *)v415 - 1);
        v415 -= 8;
        v416 = v417;
        *(_QWORD *)v415 = 0;
        if (v417)
          (*(void (**)(uint64_t))(*(_QWORD *)v416 + 8))(v416);
      }
    }
    v4 = v591;
    if (v395)
      operator delete(v395);
  }
  else
  {
    *(_QWORD *)v395 = v385;
    v396 = v395 + 8;
  }
  a3[2] = (uint64_t)v396;
  v418 = *a3;
  v419 = operator new(0x70uLL);
  mlir::PatternBenefit::PatternBenefit(&v595, 1);
  mlir::Pattern::Pattern((uint64_t)(v419 + 1), (uint64_t)"mps.conv_2d_data_gradient", 25, (__int16)v595, v418, 0, 0);
  v419[12] = v4;
  *v419 = &off_1E0E25BD8;
  *((_BYTE *)v419 + 104) = a2;
  if (!v419[9])
  {
    v595 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertConv<mlir::mps::Conv2DDa"
           "taGradientOp, mlir::anec::Deconvolution>]";
    v596[0] = (void *)150;
    v420 = (char *)llvm::StringRef::find((uint64_t *)&v595, "DesiredTypeName = ", 0x12uLL, 0);
    if (v596[0] >= v420)
      v421 = v420;
    else
      v421 = (char *)v596[0];
    v422 = &v421[(_QWORD)v595];
    v423 = (char *)((char *)v596[0] - (char *)v421);
    if ((void *)((char *)v596[0] - (char *)v421) >= (void *)0x12)
      v424 = 18;
    else
      v424 = (char *)v596[0] - (char *)v421;
    v425 = &v422[v424];
    v426 = (unint64_t)&v423[-v424];
    if (v426 >= v426 - 1)
      --v426;
    v419[8] = v425;
    v419[9] = v426;
  }
  v427 = *((unsigned int *)v419 + 22);
  if (v427 > *((_DWORD *)v419 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v419 + 10), v419 + 12, v427, 16);
    LODWORD(v427) = *((_DWORD *)v419 + 22);
  }
  *((_DWORD *)v419 + 22) = v427;
  v429 = (char *)a3[2];
  v428 = a3[3];
  if ((unint64_t)v429 >= v428)
  {
    v431 = (char *)a3[1];
    v432 = (v429 - v431) >> 3;
    v433 = v432 + 1;
    if ((unint64_t)(v432 + 1) >> 61)
      goto LABEL_763;
    v434 = v428 - (_QWORD)v431;
    if (v434 >> 2 > v433)
      v433 = v434 >> 2;
    if ((unint64_t)v434 >= 0x7FFFFFFFFFFFFFF8)
      v435 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v435 = v433;
    if (v435)
    {
      if (v435 >> 61)
        goto LABEL_764;
      v436 = (char *)operator new(8 * v435);
    }
    else
    {
      v436 = 0;
    }
    v437 = &v436[8 * v432];
    v438 = &v436[8 * v435];
    *(_QWORD *)v437 = v419;
    v430 = v437 + 8;
    if (v429 == v431)
    {
      a3[1] = (uint64_t)v437;
      a3[2] = (uint64_t)v430;
      a3[3] = (uint64_t)v438;
    }
    else
    {
      v439 = v429 - v431 - 8;
      if (v439 < 0x78
        || &v429[-(v439 & 0xFFFFFFFFFFFFFFF8) - 8] < v437
        && &v436[v429 - v431 - (v439 & 0xFFFFFFFFFFFFFFF8) - 8] < v429)
      {
        goto LABEL_779;
      }
      v440 = (v439 >> 3) + 1;
      v441 = 8 * (v440 & 0x3FFFFFFFFFFFFFFCLL);
      v442 = &v429[-v441];
      v437 -= v441;
      v443 = &v436[8 * v432 - 16];
      v444 = v429 - 16;
      v445 = v440 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v447 = *((_OWORD *)v444 - 1);
        v446 = *(_OWORD *)v444;
        *((_OWORD *)v444 - 1) = 0uLL;
        *(_OWORD *)v444 = 0uLL;
        *((_OWORD *)v443 - 1) = v447;
        *(_OWORD *)v443 = v446;
        v443 -= 32;
        v444 -= 32;
        v445 -= 4;
      }
      while (v445);
      v429 = v442;
      if (v440 != (v440 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_779:
        do
        {
          v448 = *((_QWORD *)v429 - 1);
          v429 -= 8;
          *(_QWORD *)v429 = 0;
          *((_QWORD *)v437 - 1) = v448;
          v437 -= 8;
        }
        while (v429 != v431);
      }
      v429 = (char *)a3[1];
      v449 = (char *)a3[2];
      a3[1] = (uint64_t)v437;
      a3[2] = (uint64_t)v430;
      a3[3] = (uint64_t)v438;
      while (v449 != v429)
      {
        v451 = *((_QWORD *)v449 - 1);
        v449 -= 8;
        v450 = v451;
        *(_QWORD *)v449 = 0;
        if (v451)
          (*(void (**)(uint64_t))(*(_QWORD *)v450 + 8))(v450);
      }
    }
    v4 = v591;
    if (v429)
      operator delete(v429);
  }
  else
  {
    *(_QWORD *)v429 = v419;
    v430 = v429 + 8;
  }
  a3[2] = (uint64_t)v430;
  v452 = *a3;
  v453 = operator new(0x70uLL);
  mlir::PatternBenefit::PatternBenefit(&v595, 1);
  mlir::Pattern::Pattern((uint64_t)(v453 + 1), (uint64_t)"mps.conv_2d", 11, (__int16)v595, v452, 0, 0);
  v453[12] = v4;
  *v453 = &off_1E0E25CB8;
  *((_BYTE *)v453 + 104) = a2;
  if (!v453[9])
  {
    v595 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertConv<mlir::mps::Conv2DOp"
           ", mlir::anec::Convolution>]";
    v596[0] = (void *)136;
    v454 = (char *)llvm::StringRef::find((uint64_t *)&v595, "DesiredTypeName = ", 0x12uLL, 0);
    if (v596[0] >= v454)
      v455 = v454;
    else
      v455 = (char *)v596[0];
    v456 = &v455[(_QWORD)v595];
    v457 = (char *)((char *)v596[0] - (char *)v455);
    if ((void *)((char *)v596[0] - (char *)v455) >= (void *)0x12)
      v458 = 18;
    else
      v458 = (char *)v596[0] - (char *)v455;
    v459 = &v456[v458];
    v460 = (unint64_t)&v457[-v458];
    if (v460 >= v460 - 1)
      --v460;
    v453[8] = v459;
    v453[9] = v460;
  }
  v461 = *((unsigned int *)v453 + 22);
  if (v461 > *((_DWORD *)v453 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v453 + 10), v453 + 12, v461, 16);
    LODWORD(v461) = *((_DWORD *)v453 + 22);
  }
  *((_DWORD *)v453 + 22) = v461;
  v463 = (char *)a3[2];
  v462 = a3[3];
  if ((unint64_t)v463 >= v462)
  {
    v465 = (char *)a3[1];
    v466 = (v463 - v465) >> 3;
    v467 = v466 + 1;
    if ((unint64_t)(v466 + 1) >> 61)
      goto LABEL_763;
    v468 = v462 - (_QWORD)v465;
    if (v468 >> 2 > v467)
      v467 = v468 >> 2;
    if ((unint64_t)v468 >= 0x7FFFFFFFFFFFFFF8)
      v469 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v469 = v467;
    if (v469)
    {
      if (v469 >> 61)
        goto LABEL_764;
      v470 = (char *)operator new(8 * v469);
    }
    else
    {
      v470 = 0;
    }
    v471 = &v470[8 * v466];
    v472 = &v470[8 * v469];
    *(_QWORD *)v471 = v453;
    v464 = v471 + 8;
    if (v463 == v465)
    {
      a3[1] = (uint64_t)v471;
      a3[2] = (uint64_t)v464;
      a3[3] = (uint64_t)v472;
    }
    else
    {
      v473 = v463 - v465 - 8;
      if (v473 < 0x78
        || &v463[-(v473 & 0xFFFFFFFFFFFFFFF8) - 8] < v471
        && &v470[v463 - v465 - (v473 & 0xFFFFFFFFFFFFFFF8) - 8] < v463)
      {
        goto LABEL_780;
      }
      v474 = (v473 >> 3) + 1;
      v475 = 8 * (v474 & 0x3FFFFFFFFFFFFFFCLL);
      v476 = &v463[-v475];
      v471 -= v475;
      v477 = &v470[8 * v466 - 16];
      v478 = v463 - 16;
      v479 = v474 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v481 = *((_OWORD *)v478 - 1);
        v480 = *(_OWORD *)v478;
        *((_OWORD *)v478 - 1) = 0uLL;
        *(_OWORD *)v478 = 0uLL;
        *((_OWORD *)v477 - 1) = v481;
        *(_OWORD *)v477 = v480;
        v477 -= 32;
        v478 -= 32;
        v479 -= 4;
      }
      while (v479);
      v463 = v476;
      if (v474 != (v474 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_780:
        do
        {
          v482 = *((_QWORD *)v463 - 1);
          v463 -= 8;
          *(_QWORD *)v463 = 0;
          *((_QWORD *)v471 - 1) = v482;
          v471 -= 8;
        }
        while (v463 != v465);
      }
      v463 = (char *)a3[1];
      v483 = (char *)a3[2];
      a3[1] = (uint64_t)v471;
      a3[2] = (uint64_t)v464;
      a3[3] = (uint64_t)v472;
      while (v483 != v463)
      {
        v485 = *((_QWORD *)v483 - 1);
        v483 -= 8;
        v484 = v485;
        *(_QWORD *)v483 = 0;
        if (v485)
          (*(void (**)(uint64_t))(*(_QWORD *)v484 + 8))(v484);
      }
    }
    v4 = v591;
    if (v463)
      operator delete(v463);
  }
  else
  {
    *(_QWORD *)v463 = v453;
    v464 = v463 + 8;
  }
  a3[2] = (uint64_t)v464;
  v486 = *a3;
  v487 = operator new(0x70uLL);
  mlir::PatternBenefit::PatternBenefit(&v595, 1);
  mlir::Pattern::Pattern((uint64_t)(v487 + 1), (uint64_t)"mps.conv_3d_data_gradient", 25, (__int16)v595, v486, 0, 0);
  v487[12] = v4;
  *v487 = &off_1E0E25C48;
  *((_BYTE *)v487 + 104) = a2;
  if (!v487[9])
  {
    v595 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertConv<mlir::mps::Conv3DDa"
           "taGradientOp, mlir::anec::Deconvolution>]";
    v596[0] = (void *)150;
    v488 = (char *)llvm::StringRef::find((uint64_t *)&v595, "DesiredTypeName = ", 0x12uLL, 0);
    if (v596[0] >= v488)
      v489 = v488;
    else
      v489 = (char *)v596[0];
    v490 = &v489[(_QWORD)v595];
    v491 = (char *)((char *)v596[0] - (char *)v489);
    if ((void *)((char *)v596[0] - (char *)v489) >= (void *)0x12)
      v492 = 18;
    else
      v492 = (char *)v596[0] - (char *)v489;
    v493 = &v490[v492];
    v494 = (unint64_t)&v491[-v492];
    if (v494 >= v494 - 1)
      --v494;
    v487[8] = v493;
    v487[9] = v494;
  }
  v495 = *((unsigned int *)v487 + 22);
  if (v495 > *((_DWORD *)v487 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v487 + 10), v487 + 12, v495, 16);
    LODWORD(v495) = *((_DWORD *)v487 + 22);
  }
  *((_DWORD *)v487 + 22) = v495;
  v497 = (char *)a3[2];
  v496 = a3[3];
  if ((unint64_t)v497 >= v496)
  {
    v499 = (char *)a3[1];
    v500 = (v497 - v499) >> 3;
    v501 = v500 + 1;
    if ((unint64_t)(v500 + 1) >> 61)
      goto LABEL_763;
    v502 = v496 - (_QWORD)v499;
    if (v502 >> 2 > v501)
      v501 = v502 >> 2;
    if ((unint64_t)v502 >= 0x7FFFFFFFFFFFFFF8)
      v503 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v503 = v501;
    if (v503)
    {
      if (v503 >> 61)
        goto LABEL_764;
      v504 = (char *)operator new(8 * v503);
    }
    else
    {
      v504 = 0;
    }
    v505 = &v504[8 * v500];
    v506 = &v504[8 * v503];
    *(_QWORD *)v505 = v487;
    v498 = v505 + 8;
    if (v497 == v499)
    {
      a3[1] = (uint64_t)v505;
      a3[2] = (uint64_t)v498;
      a3[3] = (uint64_t)v506;
    }
    else
    {
      v507 = v497 - v499 - 8;
      if (v507 < 0x78
        || &v497[-(v507 & 0xFFFFFFFFFFFFFFF8) - 8] < v505
        && &v504[v497 - v499 - (v507 & 0xFFFFFFFFFFFFFFF8) - 8] < v497)
      {
        goto LABEL_781;
      }
      v508 = (v507 >> 3) + 1;
      v509 = 8 * (v508 & 0x3FFFFFFFFFFFFFFCLL);
      v510 = &v497[-v509];
      v505 -= v509;
      v511 = &v504[8 * v500 - 16];
      v512 = v497 - 16;
      v513 = v508 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v515 = *((_OWORD *)v512 - 1);
        v514 = *(_OWORD *)v512;
        *((_OWORD *)v512 - 1) = 0uLL;
        *(_OWORD *)v512 = 0uLL;
        *((_OWORD *)v511 - 1) = v515;
        *(_OWORD *)v511 = v514;
        v511 -= 32;
        v512 -= 32;
        v513 -= 4;
      }
      while (v513);
      v497 = v510;
      if (v508 != (v508 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_781:
        do
        {
          v516 = *((_QWORD *)v497 - 1);
          v497 -= 8;
          *(_QWORD *)v497 = 0;
          *((_QWORD *)v505 - 1) = v516;
          v505 -= 8;
        }
        while (v497 != v499);
      }
      v497 = (char *)a3[1];
      v517 = (char *)a3[2];
      a3[1] = (uint64_t)v505;
      a3[2] = (uint64_t)v498;
      a3[3] = (uint64_t)v506;
      while (v517 != v497)
      {
        v519 = *((_QWORD *)v517 - 1);
        v517 -= 8;
        v518 = v519;
        *(_QWORD *)v517 = 0;
        if (v519)
          (*(void (**)(uint64_t))(*(_QWORD *)v518 + 8))(v518);
      }
    }
    v4 = v591;
    if (v497)
      operator delete(v497);
  }
  else
  {
    *(_QWORD *)v497 = v487;
    v498 = v497 + 8;
  }
  a3[2] = (uint64_t)v498;
  v520 = *a3;
  v521 = operator new(0x70uLL);
  mlir::PatternBenefit::PatternBenefit(&v595, 1);
  mlir::Pattern::Pattern((uint64_t)(v521 + 1), (uint64_t)"mps.conv_3d", 11, (__int16)v595, v520, 0, 0);
  v521[12] = v4;
  *v521 = &off_1E0E25D28;
  *((_BYTE *)v521 + 104) = a2;
  if (!v521[9])
  {
    v595 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertConv<mlir::mps::Conv3DOp"
           ", mlir::anec::Convolution>]";
    v596[0] = (void *)136;
    v522 = (char *)llvm::StringRef::find((uint64_t *)&v595, "DesiredTypeName = ", 0x12uLL, 0);
    if (v596[0] >= v522)
      v523 = v522;
    else
      v523 = (char *)v596[0];
    v524 = &v523[(_QWORD)v595];
    v525 = (char *)((char *)v596[0] - (char *)v523);
    if ((void *)((char *)v596[0] - (char *)v523) >= (void *)0x12)
      v526 = 18;
    else
      v526 = (char *)v596[0] - (char *)v523;
    v527 = &v524[v526];
    v528 = (unint64_t)&v525[-v526];
    if (v528 >= v528 - 1)
      --v528;
    v521[8] = v527;
    v521[9] = v528;
  }
  v529 = *((unsigned int *)v521 + 22);
  if (v529 > *((_DWORD *)v521 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v521 + 10), v521 + 12, v529, 16);
    LODWORD(v529) = *((_DWORD *)v521 + 22);
  }
  *((_DWORD *)v521 + 22) = v529;
  v531 = (char *)a3[2];
  v530 = a3[3];
  if ((unint64_t)v531 >= v530)
  {
    v533 = (char *)a3[1];
    v534 = (v531 - v533) >> 3;
    v535 = v534 + 1;
    if ((unint64_t)(v534 + 1) >> 61)
      goto LABEL_763;
    v536 = v530 - (_QWORD)v533;
    if (v536 >> 2 > v535)
      v535 = v536 >> 2;
    if ((unint64_t)v536 >= 0x7FFFFFFFFFFFFFF8)
      v537 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v537 = v535;
    if (v537)
    {
      if (v537 >> 61)
        goto LABEL_764;
      v538 = (char *)operator new(8 * v537);
    }
    else
    {
      v538 = 0;
    }
    v539 = &v538[8 * v534];
    v540 = &v538[8 * v537];
    *(_QWORD *)v539 = v521;
    v532 = v539 + 8;
    if (v531 == v533)
    {
      a3[1] = (uint64_t)v539;
      a3[2] = (uint64_t)v532;
      a3[3] = (uint64_t)v540;
    }
    else
    {
      v541 = v531 - v533 - 8;
      if (v541 < 0x78
        || &v531[-(v541 & 0xFFFFFFFFFFFFFFF8) - 8] < v539
        && &v538[v531 - v533 - (v541 & 0xFFFFFFFFFFFFFFF8) - 8] < v531)
      {
        goto LABEL_782;
      }
      v542 = (v541 >> 3) + 1;
      v543 = 8 * (v542 & 0x3FFFFFFFFFFFFFFCLL);
      v544 = &v531[-v543];
      v539 -= v543;
      v545 = &v538[8 * v534 - 16];
      v546 = v531 - 16;
      v547 = v542 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v549 = *((_OWORD *)v546 - 1);
        v548 = *(_OWORD *)v546;
        *((_OWORD *)v546 - 1) = 0uLL;
        *(_OWORD *)v546 = 0uLL;
        *((_OWORD *)v545 - 1) = v549;
        *(_OWORD *)v545 = v548;
        v545 -= 32;
        v546 -= 32;
        v547 -= 4;
      }
      while (v547);
      v531 = v544;
      if (v542 != (v542 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_782:
        do
        {
          v550 = *((_QWORD *)v531 - 1);
          v531 -= 8;
          *(_QWORD *)v531 = 0;
          *((_QWORD *)v539 - 1) = v550;
          v539 -= 8;
        }
        while (v531 != v533);
      }
      v531 = (char *)a3[1];
      v551 = (char *)a3[2];
      a3[1] = (uint64_t)v539;
      a3[2] = (uint64_t)v532;
      a3[3] = (uint64_t)v540;
      while (v551 != v531)
      {
        v553 = *((_QWORD *)v551 - 1);
        v551 -= 8;
        v552 = v553;
        *(_QWORD *)v551 = 0;
        if (v553)
          (*(void (**)(uint64_t))(*(_QWORD *)v552 + 8))(v552);
      }
    }
    v4 = v591;
    if (v531)
      operator delete(v531);
  }
  else
  {
    *(_QWORD *)v531 = v521;
    v532 = v531 + 8;
  }
  a3[2] = (uint64_t)v532;
  v554 = *a3;
  v555 = operator new(0x70uLL);
  mlir::PatternBenefit::PatternBenefit(&v595, 1);
  mlir::Pattern::Pattern((uint64_t)(v555 + 1), (uint64_t)"mps.depthwise_conv_2d", 21, (__int16)v595, v554, 0, 0);
  v555[12] = v4;
  *v555 = &off_1E0E25B68;
  *((_BYTE *)v555 + 104) = a2;
  if (!v555[9])
  {
    v595 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::(anonymous namespace)::ConvertConv<mlir::mps::Depthwis"
           "eConv2DOp, mlir::anec::Convolution>]";
    v596[0] = (void *)145;
    v556 = (char *)llvm::StringRef::find((uint64_t *)&v595, "DesiredTypeName = ", 0x12uLL, 0);
    if (v596[0] >= v556)
      v557 = v556;
    else
      v557 = (char *)v596[0];
    v558 = &v557[(_QWORD)v595];
    v559 = (char *)((char *)v596[0] - (char *)v557);
    if ((void *)((char *)v596[0] - (char *)v557) >= (void *)0x12)
      v560 = 18;
    else
      v560 = (char *)v596[0] - (char *)v557;
    v561 = &v558[v560];
    v562 = (unint64_t)&v559[-v560];
    if (v562 >= v562 - 1)
      --v562;
    v555[8] = v561;
    v555[9] = v562;
  }
  v563 = *((unsigned int *)v555 + 22);
  if (v563 > *((_DWORD *)v555 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v555 + 10), v555 + 12, v563, 16);
    LODWORD(v563) = *((_DWORD *)v555 + 22);
  }
  *((_DWORD *)v555 + 22) = v563;
  v565 = (char *)a3[2];
  v564 = a3[3];
  if ((unint64_t)v565 >= v564)
  {
    v567 = (char *)a3[1];
    v568 = (v565 - v567) >> 3;
    v569 = v568 + 1;
    if (!((unint64_t)(v568 + 1) >> 61))
    {
      v570 = v564 - (_QWORD)v567;
      if (v570 >> 2 > v569)
        v569 = v570 >> 2;
      if ((unint64_t)v570 >= 0x7FFFFFFFFFFFFFF8)
        v571 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v571 = v569;
      if (!v571)
      {
        v572 = 0;
        goto LABEL_742;
      }
      if (!(v571 >> 61))
      {
        v572 = (char *)operator new(8 * v571);
LABEL_742:
        v573 = &v572[8 * v568];
        v574 = &v572[8 * v571];
        *(_QWORD *)v573 = v555;
        v566 = v573 + 8;
        if (v565 == v567)
        {
          a3[1] = (uint64_t)v573;
          a3[2] = (uint64_t)v566;
          a3[3] = (uint64_t)v574;
        }
        else
        {
          v575 = v565 - v567 - 8;
          if (v575 < 0x78
            || &v565[-(v575 & 0xFFFFFFFFFFFFFFF8) - 8] < v573
            && &v572[v565 - v567 - (v575 & 0xFFFFFFFFFFFFFFF8) - 8] < v565)
          {
            goto LABEL_783;
          }
          v576 = (v575 >> 3) + 1;
          v577 = 8 * (v576 & 0x3FFFFFFFFFFFFFFCLL);
          v578 = &v565[-v577];
          v573 -= v577;
          v579 = &v572[8 * v568 - 16];
          v580 = v565 - 16;
          v581 = v576 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v583 = *((_OWORD *)v580 - 1);
            v582 = *(_OWORD *)v580;
            *((_OWORD *)v580 - 1) = 0uLL;
            *(_OWORD *)v580 = 0uLL;
            *((_OWORD *)v579 - 1) = v583;
            *(_OWORD *)v579 = v582;
            v579 -= 32;
            v580 -= 32;
            v581 -= 4;
          }
          while (v581);
          v565 = v578;
          if (v576 != (v576 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_783:
            do
            {
              v584 = *((_QWORD *)v565 - 1);
              v565 -= 8;
              *(_QWORD *)v565 = 0;
              *((_QWORD *)v573 - 1) = v584;
              v573 -= 8;
            }
            while (v565 != v567);
          }
          v565 = (char *)a3[1];
          v585 = (char *)a3[2];
          a3[1] = (uint64_t)v573;
          a3[2] = (uint64_t)v566;
          a3[3] = (uint64_t)v574;
          while (v585 != v565)
          {
            v587 = *((_QWORD *)v585 - 1);
            v585 -= 8;
            v586 = v587;
            *(_QWORD *)v585 = 0;
            if (v587)
              (*(void (**)(uint64_t))(*(_QWORD *)v586 + 8))(v586);
          }
        }
        if (v565)
          operator delete(v565);
        goto LABEL_757;
      }
LABEL_764:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_763:
    abort();
  }
  *(_QWORD *)v565 = v555;
  v566 = v565 + 8;
LABEL_757:
  a3[2] = (uint64_t)v566;
}

#error "180737160: too big function (funcsize=0)"

uint64_t std::pair<llvm::APFloat,std::string>::pair[abi:nn180100]<llvm::APFloat,char const(&)[7],0>(uint64_t a1, uint64_t a2, const char *a3)
{
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  size_t v8;
  size_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;

  v5 = (_QWORD *)(a1 + 8);
  v6 = (_QWORD *)(a2 + 8);
  v7 = *(void **)(a2 + 8);
  if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) == v7)
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v5, v6);
  else
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v5, (uint64_t)v6);
  v8 = strlen(a3);
  if (v8 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v9 = v8;
  if (v8 >= 0x17)
  {
    v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17)
      v11 = v8 | 7;
    v12 = v11 + 1;
    v10 = operator new(v11 + 1);
    *(_QWORD *)(a1 + 40) = v9;
    *(_QWORD *)(a1 + 48) = v12 | 0x8000000000000000;
    *(_QWORD *)(a1 + 32) = v10;
  }
  else
  {
    v10 = (void *)(a1 + 32);
    *(_BYTE *)(a1 + 55) = v8;
    if (!v8)
      goto LABEL_12;
  }
  memmove(v10, a3, v9);
LABEL_12:
  *((_BYTE *)v10 + v9) = 0;
  return a1;
}

void mlir::`anonymous namespace'::ConvertBiasAdd::~ConvertBiasAdd(mlir::_anonymous_namespace_::ConvertBiasAdd *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::BiasAddOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 48);
  v9 = *(_QWORD *)(a3 + 56);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      v29 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BiasAddOp &>(mlir::mps::BiasAddOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BiasAddOp &>(mlir::mps::BiasAddOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertBiasAdd::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t *v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t IndexFromDim;
  char v23;
  unint64_t v24;
  int StorageType;
  uint64_t v26;
  uint64_t DefiningOp;
  uint64_t v28;
  uint64_t v29;
  unsigned int *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  _QWORD v38[2];
  uint64_t v39;
  uint64_t v40;
  uint64_t *GOC;
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v39 = a2;
  v42 = *(_OWORD *)(a3 + 48);
  v5 = mlir::ValueRange::dereference_iterator(&v42, 0);
  v6 = mlir::ValueRange::dereference_iterator(&v42, 1);
  v7 = (uint64_t *)(*(_QWORD *)(v5 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v7)
    goto LABEL_10;
  v8 = *v7;
  v9 = mlir::TypeID::get<mlir::ShapedType>();
  v10 = *(unsigned int *)(v8 + 16);
  if (!(_DWORD)v10)
    goto LABEL_10;
  v11 = *(_QWORD **)(v8 + 8);
  v12 = &v11[2 * v10];
  do
  {
    v13 = v10 >> 1;
    v14 = &v11[2 * (v10 >> 1)];
    v16 = *v14;
    v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9)
      v11 = v15;
    else
      v10 = v13;
  }
  while (v10);
  if (v11 != v12 && *v11 == v9)
    v17 = v11[1];
  else
LABEL_10:
    v17 = 0;
  v38[0] = mlir::getRankPromotionTypeForANE((uint64_t)v7, v17);
  v38[1] = v18;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v38);
  v20 = v19;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v38);
  IndexFromDim = mlir::anec::getIndexFromDim(1, v21);
  if (!v23)
    std::__throw_bad_optional_access[abi:nn180100]();
  v24 = IndexFromDim;
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v39);
  if (StorageType)
  {
    if (StorageType != 1)
    {
      v36 = v39;
      GOC = &v39;
      v32 = *(_QWORD *)(a4 + 16);
      if (!v32 || !mlir::RewriterBase::Listener::classof(v32))
        return 0;
      v34 = *(_QWORD *)(v36 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t **))(*(_QWORD *)v32 + 64))(v32, v34, v35, &GOC);
    }
    v26 = -1;
  }
  else
  {
    v26 = -3;
  }
  if (v20 + v26 != v24
    || (GOC = (uint64_t *)v6, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&GOC)) == 0)
    || (v28 = DefiningOp,
        v29 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        !(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v28 + 48) + 32))(*(_QWORD *)(v28 + 48), v29)))
  {
    v32 = *(_QWORD *)(a4 + 16);
    if (!v32)
      return 0;
    v33 = v39;
    if (!mlir::RewriterBase::Listener::classof(v32))
      return 0;
    v34 = *(_QWORD *)(v33 + 24);
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t **))(*(_QWORD *)v32 + 64))(v32, v34, v35, &GOC);
  }
  v30 = (unsigned int *)v39;
  if (!GOC)
    return 0;
  v40 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
  v31 = 1;
  mlir::ConversionPatternRewriter::replaceOp(a4, v30, (uint64_t)&v40, 1);
  return v31;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBiasAdd::matchAndRewriteWithStaticShapes(mlir::mps::BiasAddOp,mlir::mps::BiasAddOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::mps::MaterializeSparseTensorOp **a1, uint64_t a2)
{
  uint64_t v3;
  unsigned int StorageType;
  const void **v5;
  uint64_t v6;
  const void **v8[4];
  __int16 v9;

  v3 = mlir::Diagnostic::operator<<(a2, "BiasAdd unsupported data format ");
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType(*a1);
  v9 = 261;
  v8[0] = (const void **)mlir::mps::stringifyTensorDataLayout(StorageType);
  v8[1] = v5;
  v6 = mlir::Diagnostic::operator<<(v3, v8);
  return mlir::Diagnostic::operator<<(v6, "\n");
}

uint64_t mlir::`anonymous namespace'::`anonymous namespace'::makeGOC(uint64_t a1, mlir::MLIRContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t OperandRange, int a7, int a8)
{
  uint64_t *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t *v22;
  _QWORD *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  uint64_t v29;
  unint64_t v30;
  mlir::GenericProgramPoint *GOCConstant;
  char v32;
  uint64_t v33;
  unint64_t v34;
  mlir::GenericProgramPoint *v35;
  char v36;
  void *v37;
  uint64_t v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42[2];
  char *v43;
  char *v44;
  uint64_t v45;
  __int128 v46;
  char v47;
  void *v48;
  uint64_t v49;
  _DWORD v50[12];
  void *v51;
  uint64_t v52;
  _DWORD v53[12];
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v44 = (char *)a4;
  v45 = a3;
  v43 = (char *)a5;
  v15 = (uint64_t *)(*(_QWORD *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v15)
    goto LABEL_10;
  v16 = *v15;
  v17 = mlir::TypeID::get<mlir::ShapedType>();
  v18 = *(unsigned int *)(v16 + 16);
  if (!(_DWORD)v18)
    goto LABEL_10;
  v19 = *(_QWORD **)(v16 + 8);
  v20 = &v19[2 * v18];
  do
  {
    v21 = v18 >> 1;
    v22 = &v19[2 * (v18 >> 1)];
    v24 = *v22;
    v23 = v22 + 2;
    v18 += ~(v18 >> 1);
    if (v24 < v17)
      v19 = v23;
    else
      v18 = v21;
  }
  while (v18);
  if (v19 != v20 && *v19 == v17)
    v25 = v19[1];
  else
LABEL_10:
    v25 = 0;
  v42[0] = mlir::getRankPromotionTypeForANE((uint64_t)v15, v25);
  v42[1] = v26;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v42);
  mlir::anec::getIndexFromDim(1, v27);
  if (v28)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v42);
    v51 = v53;
    v52 = 0xC00000000;
    v41 = 0;
    if (a4)
    {
      v29 = v41;
    }
    else
    {
      v29 = 0;
      v53[0] = 1065353216;
      LODWORD(v52) = 1;
    }
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v42);
    if (v32)
    {
      v44 = (char *)GOCConstant - 16;
      v48 = v50;
      v49 = 0xC00000000;
      v40 = 0;
      if (a5)
      {
        {
LABEL_27:
          if (v48 != v50)
            free(v48);
          goto LABEL_29;
        }
        v33 = v40;
      }
      else
      {
        v33 = 0;
        v50[0] = 0;
        LODWORD(v49) = 1;
      }
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v42);
      if (v36)
      {
        v43 = (char *)v35 - 16;
        if (!OperandRange)
          OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v42);
        LOBYTE(v46) = 0;
        v47 = 0;
        v37 = (void *)mlir::ShapedType::cloneWith(v42, &v46, OperandRange);
      }
      goto LABEL_27;
    }
LABEL_29:
    if (v51 != v53)
      free(v51);
  }
  return 0;
}

uint64_t mlir::`anonymous namespace'::`anonymous namespace'::getGOCConstantValue(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t *a5)
{
  uint64_t DefiningOp;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  mlir::Float16Type *v17;
  mlir::MLIRContext *v18;
  uint64_t v19;
  uint64_t v20;
  mlir::Float32Type *Context;
  mlir::MLIRContext *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  float *v27;
  unint64_t v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unsigned int v38;
  float32x4_t v39;
  unsigned int v40;
  float v41;
  uint64_t OperandRange;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  void *ArgOperands;
  uint64_t v47;
  _QWORD v48[3];

  v48[2] = *MEMORY[0x1E0C80C00];
  v44 = 0;
  v45 = 0;
  OperandRange = a1;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&OperandRange);
  if (!DefiningOp)
    return 0;
  v11 = DefiningOp;
  v12 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v11 + 48) + 32))(*(_QWORD *)(v11 + 48), v12))
    return 0;
  ArgOperands = v48;
  v47 = 0x100000000;
  mlir::Operation::fold(v11, 0, 0, (uint64_t)&ArgOperands);
  v13 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)ArgOperands & 0xFFFFFFFFFFFFFFF8));
  v15 = v13;
  if (v13)
  {
    v44 = v13;
    v45 = v14;
  }
  if (ArgOperands != v48)
    free(ArgOperands);
  if (!v15)
    return 0;
  ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v44);
  v47 = v16;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands);
  if (mlir::Type::isF32((mlir::Type *)&OperandRange) || a3)
  {
    ArgOperands = (void *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFF8);
    Context = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)&ArgOperands);
    v19 = mlir::Float32Type::get(Context, v23);
  }
  else
  {
    ArgOperands = (void *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFF8);
    v17 = (mlir::Float16Type *)mlir::Attribute::getContext((mlir::Attribute *)&ArgOperands);
    v19 = mlir::Float16Type::get(v17, v18);
  }
  *a5 = v19;
  ArgOperands = v48;
  v47 = 0x400000000;
  OperandRange = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v44);
  v43 = v24;
  if (*(_UNKNOWN **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&OperandRange)
                    + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    || (OperandRange = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v44),
        v43 = v25,
        v26 = *(void **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&OperandRange)
                       + 136),
        v26 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id)
    || v26 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    || v26 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v26 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    || v26 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v26 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    || v26 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v26 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    || v26 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    || v26 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    || v26 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v26 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    mlir::getIntValues<float>((uint64_t)v44, v45, (uint64_t)&ArgOperands, 1);
    v28 = v47;
    v29 = *(_DWORD *)(a2 + 8);
    if (v29 != (_DWORD)v47)
    {
      if (v29 <= v47)
      {
        if (*(_DWORD *)(a2 + 12) < v47)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v47, 4);
          v29 = *(_DWORD *)(a2 + 8);
        }
        if (v29 != (_DWORD)v28)
          bzero((void *)(*(_QWORD *)a2 + 4 * v29), 4 * (v28 - v29));
      }
      *(_DWORD *)(a2 + 8) = v28;
      v28 = v47;
    }
    v27 = (float *)ArgOperands;
    if ((_DWORD)v28)
    {
      v30 = 0;
      v31 = *(_QWORD *)a2;
      if (v28 < 4 || (unint64_t)(v31 - (_QWORD)ArgOperands) < 0x10)
        goto LABEL_57;
      v32 = 0;
      v30 = v28 & 0xFFFFFFFC;
      __asm { FMOV            V0.4S, #1.0 }
      do
      {
        if (a3)
          v38 = -1;
        else
          v38 = 0;
        v39 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_n_s32(v38), (int8x16_t)vdivq_f32(_Q0, *(float32x4_t *)&v27[v32 / 4]), *(int8x16_t *)&v27[v32 / 4]);
        if (a4)
          v40 = -1;
        else
          v40 = 0;
        *(int8x16_t *)(v31 + v32) = vbslq_s8((int8x16_t)vdupq_n_s32(v40), (int8x16_t)vnegq_f32(v39), (int8x16_t)v39);
        v32 += 16;
      }
      while (((4 * v28) & 0x3FFFFFFF0) != v32);
      if (v28 != v30)
      {
LABEL_57:
        do
        {
          v41 = v27[v30];
          if (a3)
            v41 = 1.0 / v41;
          if (a4)
            v41 = -v41;
          *(float *)(v31 + 4 * v30++) = v41;
        }
        while (v28 != v30);
      }
    }
    v20 = 1;
  }
  else
  {
    v20 = 0;
    v27 = (float *)ArgOperands;
  }
  if (v27 != (float *)v48)
    free(v27);
  return v20;
}

mlir::GenericProgramPoint *mlir::`anonymous namespace'::`anonymous namespace'::makeGOCConstant(uint64_t a1, mlir::MLIRContext *a2, unint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, char a7, uint64_t a8)
{
  uint64_t F16Type;
  unint64_t IndexFromDim;
  char v17;
  _QWORD *v18;
  uint64_t *v19;
  void *v20;
  mlir::AffineMap *v21;
  mlir::Float16Type **v22;
  mlir::MLIRContext *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  unint64_t v30;
  unint64_t *v31;
  _QWORD *v32;
  unint64_t v33;
  uint64_t v34;
  _BOOL4 isF32;
  uint64_t v36;
  uint64_t v37;
  __int128 *v38;
  _OWORD *v39;
  unint64_t v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;
  _DWORD *v44;
  int *v45;
  int v46;
  uint64_t v47;
  mlir::GenericProgramPoint *v48;
  float32x4_t *v49;
  float16x8_t *v50;
  unint64_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  uint64_t v56;
  _WORD *v57;
  int *v58;
  int v59;
  _QWORD *v65;
  _QWORD *v67[2];
  void *v68[5];
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  void *__b;
  unsigned int v73;
  int v74;
  _QWORD v75[6];

  F16Type = a8;
  v75[5] = *MEMORY[0x1E0C80C00];
  v71 = a8;
  if (a8)
  {
    if (a7)
      goto LABEL_7;
  }
  else
  {
    F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a1 + 8), a2);
    v71 = F16Type;
    if (a7)
      goto LABEL_7;
  }
  IndexFromDim = mlir::anec::getIndexFromDim(1, a3);
  if (!v17)
    return 0;
  a6 = IndexFromDim;
LABEL_7:
  __b = v75;
  v74 = 5;
  if (a3 < 6)
  {
    if (a3)
      memset_pattern16(v75, &unk_181233190, 8 * a3);
    v18 = v75;
  }
  else
  {
    v73 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__b, v75, a3, 8);
    v18 = __b;
    memset_pattern16(__b, &unk_181233190, 8 * a3);
  }
  v73 = a3;
  v18[a6] = a5;
  v19 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v18, a3, F16Type, 0);
  v20 = __b;
  v21 = (mlir::AffineMap *)v73;
  v22 = (mlir::Float16Type **)(a1 + 8);
  v24 = mlir::Builder::getF16Type(v22, v23);
  v70 = mlir::MemRefType::get(v20, v21, v24, 0, 0, 0);
  if (!v19)
    goto LABEL_21;
  v25 = *v19;
  v26 = mlir::TypeID::get<mlir::ShapedType>();
  v27 = *(unsigned int *)(v25 + 16);
  if (!(_DWORD)v27)
    goto LABEL_21;
  v28 = *(_QWORD **)(v25 + 8);
  v29 = &v28[2 * v27];
  do
  {
    v30 = v27 >> 1;
    v31 = &v28[2 * (v27 >> 1)];
    v33 = *v31;
    v32 = v31 + 2;
    v27 += ~(v27 >> 1);
    if (v33 < v26)
      v28 = v32;
    else
      v27 = v30;
  }
  while (v27);
  if (v28 != v29 && *v28 == v26)
    v34 = v28[1];
  else
LABEL_21:
    v34 = 0;
  mlir::mps::CPUNDArray::CPUNDArray(v68, v19, v34, 0);
  isF32 = mlir::Type::isF32((mlir::Type *)&v71);
  v36 = v69;
  if (isF32)
  {
    if (a5 >= 1)
    {
      v37 = 0;
      if ((unint64_t)a5 < 8)
        goto LABEL_29;
      if ((unint64_t)(v69 - a4) < 0x20)
        goto LABEL_29;
      v37 = a5 & 0x7FFFFFFFFFFFFFF8;
      v38 = (__int128 *)(a4 + 16);
      v39 = (_OWORD *)(v69 + 16);
      v40 = a5 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        v41 = *v38;
        *(v39 - 1) = *(v38 - 1);
        *v39 = v41;
        v38 += 2;
        v39 += 2;
        v40 -= 8;
      }
      while (v40);
      if (a5 != v37)
      {
LABEL_29:
        v42 = a5 - v37;
        v43 = 4 * v37;
        v44 = (_DWORD *)(v36 + v43);
        v45 = (int *)(a4 + v43);
        do
        {
          v46 = *v45++;
          *v44++ = v46;
          --v42;
        }
        while (v42);
      }
    }
    goto LABEL_41;
  }
  if (a5 >= 1)
  {
    if ((unint64_t)a5 < 0x10)
    {
      v47 = 0;
LABEL_39:
      v56 = a5 - v47;
      v57 = (_WORD *)(v36 + 2 * v47);
      v58 = (int *)(a4 + 4 * v47);
      do
      {
        v59 = *v58++;
        _S0 = v59;
        __asm { FCVT            H0, S0 }
        *v57++ = _S0;
        --v56;
      }
      while (v56);
      goto LABEL_41;
    }
    v47 = a5 & 0x7FFFFFFFFFFFFFF0;
    v49 = (float32x4_t *)(a4 + 32);
    v50 = (float16x8_t *)(v69 + 16);
    v51 = a5 & 0xFFFFFFFFFFFFFFF0;
    do
    {
      v53 = v49[-2];
      v52 = v49[-1];
      v55 = *v49;
      v54 = v49[1];
      v49 += 4;
      v50[-1] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v53), v52);
      *v50 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v55), v54);
      v50 += 2;
      v51 -= 16;
    }
    while (v51);
    if (a5 != v47)
      goto LABEL_39;
  }
LABEL_41:
  v67[0] = mlir::mps::CPUNDArray::getElementsAttr((mlir::mps::CPUNDArray *)v68, 0, 1);
  v67[1] = v65;
  v48 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)v22, (uint64_t)a2, &v70, v67);
  mlir::mps::CPUNDArray::~CPUNDArray(v68);
  if (__b != v75)
    free(__b);
  return v48;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::GOC,mlir::MemRefType,mlir::Value &,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gain_offset_control", (const unsigned __int8 *)0x18, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.gain_offset_control";
    v21[3] = 24;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::GOC::build((uint64_t)a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::`anonymous namespace'::canonicalizeType(void *a1, uint64_t a2)
{
  uint64_t *ArgAttrsAttr;
  uint64_t v3;
  uint64_t v4;
  void *OperandRange;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  mlir::AffineMap *v21;
  mlir::AffineMap *v22;
  uint64_t v23;
  uint64_t MemorySpace;
  _QWORD *v25;
  void *v26;
  uint64_t v27;
  void *RankPromotionTypeForANE;
  uint64_t v29;
  uint64_t v30;
  pthread_rwlock_t *v31[68];

  v31[67] = *(pthread_rwlock_t **)MEMORY[0x1E0C80C00];
  v26 = a1;
  v27 = a2;
  mlir::MPSToANECTypeConverter::MPSToANECTypeConverter((mlir::MPSToANECTypeConverter *)v31);
  ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v26);
  if (mlir::ShapedType::getNumElements(ArgAttrsAttr, v3) == 1
    && (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v26), v4 <= 3))
  {
    OperandRange = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v26);
    v6 = mlir::TypeConverter::convertType((uint64_t)v31, OperandRange);
    if (!v6)
      v6 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v26);
    mlir::getRankPromotionShapeForANE((uint64_t)v26, v27, (uint64_t **)&RankPromotionTypeForANE);
    mlir::MemRefType::get(RankPromotionTypeForANE, (mlir::AffineMap *)v29, v6, 0, 0, 0);
    if (RankPromotionTypeForANE != &v30)
      free(RankPromotionTypeForANE);
  }
  else
  {
    v7 = (_QWORD *)mlir::TypeConverter::convertType((uint64_t)v31, v26);
    v8 = (uint64_t)v7;
    v25 = v7;
    if (!v7)
      goto LABEL_16;
    v9 = *v7;
    v10 = mlir::TypeID::get<mlir::ShapedType>();
    v11 = *(unsigned int *)(v9 + 16);
    if (!(_DWORD)v11)
      goto LABEL_16;
    v12 = *(_QWORD **)(v9 + 8);
    v13 = &v12[2 * v11];
    do
    {
      v14 = v11 >> 1;
      v15 = &v12[2 * (v11 >> 1)];
      v17 = *v15;
      v16 = v15 + 2;
      v11 += ~(v11 >> 1);
      if (v17 < v10)
        v12 = v16;
      else
        v11 = v14;
    }
    while (v11);
    if (v12 != v13 && *v12 == v10)
      v18 = v12[1];
    else
LABEL_16:
      v18 = 0;
    RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v8, v18);
    v29 = v19;
    v20 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
    v22 = v21;
    v23 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&RankPromotionTypeForANE);
    MemorySpace = mlir::MemRefType::getMemorySpace((mlir::MemRefType *)&v25);
    mlir::MemRefType::get(v20, v22, v23, 0, MemorySpace);
  }
  mlir::TypeConverter::~TypeConverter(v31);
}

BOOL mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(uint64_t ***a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  _BOOL8 v7;
  uint64_t **v8;
  void *v10[2];
  _QWORD v11[2];

  v11[1] = *MEMORY[0x1E0C80C00];
  v4 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 48) + 32))(*(_QWORD *)(a2 + 48), v4))
    return 0;
  v10[0] = v11;
  v10[1] = (void *)0x100000000;
  mlir::Operation::fold(a2, 0, 0, (uint64_t)v10);
  v5 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v10[0] & 0xFFFFFFFFFFFFFFF8));
  v7 = v5 != 0;
  if (v5)
  {
    v8 = *a1;
    if (*a1)
    {
      *v8 = v5;
      v8[1] = v6;
    }
  }
  if (v10[0] != v11)
    free(v10[0]);
  return v7;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBiasAdd::matchAndRewriteWithStaticShapes(mlir::mps::BiasAddOp,mlir::mps::BiasAddOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BiasAdd invalid channel or not a constant bias\n");
}

void mlir::`anonymous namespace'::ConvertConstant::~ConvertConstant(mlir::_anonymous_namespace_::ConvertConstant *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConstantOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConstantOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  uint64_t result;
  __n128 *v11;
  void *v12;
  mlir::mps::MPSResourceBlobManagerInterface *Context;
  mlir::MLIRContext *v14;
  pthread_rwlock_t **Manager;
  __n128 v16;
  __n128 *v17;
  unint64_t v18[2];
  _BYTE v19[24];
  __n128 *v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v18, a3, a4);
  v8 = v18[0];
  v9 = v18[1];
  mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase((mlir::Attribute *)v19, a2);
  v21 = v8;
  v22 = v9;
  result = (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v19, a5);
  v11 = v20;
  if (v20)
  {
    v12 = *(void **)(v20->n128_u64[0] + 136);
    if (v12 != &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
      v11 = 0;
    v17 = v11;
    if (v12 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
    {
      mlir::mps::MPSBufferTensorAttr::getHandle(&v17, &v16);
      Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
      Manager = (pthread_rwlock_t **)mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v14);
      return mlir::mps::MPSResourceBlobManagerInterface::decrementResourceRefcount(Manager, (MPSResourceBlobEntry *)v16.n128_u64[0]);
    }
  }
  return result;
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConstantOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  __n128 *v11;
  void *v12;
  mlir::mps::MPSResourceBlobManagerInterface *Context;
  mlir::MLIRContext *v14;
  pthread_rwlock_t **Manager;
  __n128 v17;
  __n128 *v18;
  unint64_t v19[2];
  _BYTE v20[24];
  __n128 *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v19, a3, a4);
  v8 = v19[0];
  v9 = v19[1];
  mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase((mlir::Attribute *)v20, a2);
  v22 = v8;
  v23 = v9;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v20, a5);
  v11 = v21;
  if (v21)
  {
    v12 = *(void **)(v21->n128_u64[0] + 136);
    if (v12 != &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
      v11 = 0;
    v18 = v11;
    if (v12 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
    {
      mlir::mps::MPSBufferTensorAttr::getHandle(&v18, &v17);
      Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
      Manager = (pthread_rwlock_t **)mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v14);
      mlir::mps::MPSResourceBlobManagerInterface::decrementResourceRefcount(Manager, (MPSResourceBlobEntry *)v17.n128_u64[0]);
    }
  }
  return v10;
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ConstantOp>::matchAndRewrite(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4)
{
  __n128 *v8;
  uint64_t v9;
  __int128 *v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  _QWORD *ArgAttrsAttr;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t NextResultAtOffset;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __n128 *v31;
  void *v32;
  mlir::mps::MPSResourceBlobManagerInterface *Context;
  mlir::MLIRContext *v34;
  pthread_rwlock_t **Manager;
  unint64_t v36;
  pthread_rwlock_t **v37;
  __int128 v38;
  __n128 *v39;
  void *v40;
  mlir::mps::MPSResourceBlobManagerInterface *v41;
  mlir::MLIRContext *v42;
  pthread_rwlock_t **v43;
  _QWORD v44[2];
  __n128 *v45;
  __n128 v46[2];
  __int16 v47;
  __int128 v48;
  char v49;
  __n128 *v50;
  __int128 v51;
  __int128 v52;
  __n128 *v53;
  uint64_t v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v8 = (__n128 *)*((_QWORD *)a3 + 6);
  v9 = *((_QWORD *)a3 + 7);
  v10 = a3 + 3;
  v53 = v8;
  v54 = 0;
  if (v9)
  {
    v11 = 0;
    while (1)
    {
      v13 = mlir::ValueRange::dereference_iterator(&v53, v11);
      v44[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v13 + 8) & 0xFFFFFFFFFFFFFFF8));
      v44[1] = v14;
      if (v44[0])
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v44)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v44))
        {
          goto LABEL_15;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v44);
        if (v16)
          break;
      }
LABEL_3:
      v11 = ++v54;
      if (v53 == v8 && v11 == v9)
        goto LABEL_18;
    }
    v17 = 8 * v16;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v17 -= 8;
      if (!v17)
        goto LABEL_3;
    }
LABEL_15:
    v47 = 259;
    v45 = v46;
    v46[0].n128_u64[0] = (unint64_t)"failed: unranked input types or dynamic shapes are not supported on ANEs.";
    v18 = *(_QWORD *)(a4 + 16);
    if (v18 && mlir::RewriterBase::Listener::classof(v18))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), __n128 **))(*(_QWORD *)v18 + 64))(v18, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConstantOp &>(mlir::mps::ConstantOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v45);
    return 0;
  }
LABEL_18:
  v20 = *(unsigned int *)(a2 + 36);
  if ((_DWORD)v20)
    v21 = a2 - 16;
  else
    v21 = 0;
  if ((_DWORD)v20)
  {
    v22 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v21, v22);
      v53 = (__n128 *)llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v54 = v24;
      if (v53)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
        {
          goto LABEL_32;
        }
        v25 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v53);
        if (v26)
          break;
      }
LABEL_23:
      if (++v22 == v20)
        goto LABEL_38;
    }
    v27 = 8 * v26;
    while (*v25 != 0x8000000000000000)
    {
      ++v25;
      v27 -= 8;
      if (!v27)
        goto LABEL_23;
    }
LABEL_32:
    v46[0].n128_u64[0] = (unint64_t)"failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v47 = 259;
    v44[0] = v46;
    v28 = *(_QWORD *)(a4 + 16);
    if (v28 && mlir::RewriterBase::Listener::classof(v28))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v28 + 64))(v28, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConstantOp &>(mlir::mps::ConstantOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v44);
    return 0;
  }
LABEL_38:
  v48 = *a3;
  v49 = *((_BYTE *)a3 + 16);
  v31 = (__n128 *)*((_QWORD *)a3 + 3);
  v50 = v31;
  if (v31)
  {
    v32 = *(void **)(v31->n128_u64[0] + 136);
    if (v32 != &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
      v31 = 0;
    v53 = v31;
    if (v32 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
    {
      mlir::mps::MPSBufferTensorAttr::getHandle(&v53, v46);
      Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v53);
      Manager = (pthread_rwlock_t **)mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v34);
      v36 = v46[0].n128_u64[0];
      v37 = Manager + 6;
      llvm::sys::RWMutexImpl::lock(Manager + 6);
      ++*(_QWORD *)(v36 + 88);
      llvm::sys::RWMutexImpl::unlock_shared(v37);
    }
  }
  v38 = *v10;
  v51 = a3[2];
  v52 = v38;
  v29 = (*(uint64_t (**)(uint64_t, uint64_t, __int128 *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, &v48, a4);
  v39 = v50;
  if (v50)
  {
    v40 = *(void **)(v50->n128_u64[0] + 136);
    if (v40 != &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
      v39 = 0;
    v53 = v39;
    if (v40 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
    {
      mlir::mps::MPSBufferTensorAttr::getHandle(&v53, v46);
      v41 = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v53);
      v43 = (pthread_rwlock_t **)mlir::mps::MPSResourceBlobManagerInterface::getManager(v41, v42);
      mlir::mps::MPSResourceBlobManagerInterface::decrementResourceRefcount(v43, (MPSResourceBlobEntry *)v46[0].n128_u64[0]);
    }
  }
  return v29;
}

void mlir::`anonymous namespace'::ConvertConstant::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *OperandRange;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  unint64_t v29;
  unint64_t *v30;
  _QWORD *v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  mlir::GenericProgramPoint *v36;
  _QWORD *Value;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  _QWORD *ArgOperands;
  uint64_t v42;
  char v43;
  pthread_rwlock_t *v44[68];

  v44[67] = *(pthread_rwlock_t **)MEMORY[0x1E0C80C00];
  v40 = a2;
  mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v44, *(const mlir::TypeConverter **)(a1 + 96));
  v5 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v40);
  v38 = v16;
  ArgOperands = (_QWORD *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&Value);
  v42 = v17;
  OperandRange = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&ArgOperands);
  v19 = mlir::TypeConverter::convertType((uint64_t)v44, OperandRange);
  v20 = (uint64_t)Value;
  v21 = v38;
  LOBYTE(ArgOperands) = 0;
  v43 = 0;
  v22 = (uint64_t *)mlir::BaseMemRefType::cloneWith(&v39, (uint64_t)&ArgOperands, v19);
  v23 = (uint64_t)v22;
  if (!v22)
    goto LABEL_20;
  v24 = *v22;
  v25 = mlir::TypeID::get<mlir::ShapedType>();
  v26 = *(unsigned int *)(v24 + 16);
  if (!(_DWORD)v26)
    goto LABEL_20;
  v27 = *(_QWORD **)(v24 + 8);
  v28 = &v27[2 * v26];
  do
  {
    v29 = v26 >> 1;
    v30 = &v27[2 * (v26 >> 1)];
    v32 = *v30;
    v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25)
      v27 = v31;
    else
      v26 = v29;
  }
  while (v26);
  if (v27 != v28 && *v27 == v25)
    v33 = v27[1];
  else
LABEL_20:
    v33 = 0;
  ArgOperands = mlir::rewriteElementsAttr(v20, v21, v23, v33, 0);
  v42 = v34;
  v35 = v40;
  v36 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v40 + 24), (uint64_t *)&v39, &ArgOperands);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v35, v36);
  mlir::TypeConverter::~TypeConverter(v44);
}

BOOL mlir::mps::MPSResourceBlobManagerInterface::decrementResourceRefcount(pthread_rwlock_t **this, MPSResourceBlobEntry *a2)
{
  pthread_rwlock_t **v3;
  unint64_t v4;
  char *v5;
  char *v6;
  unint64_t v7;

  v3 = this + 6;
  llvm::sys::RWMutexImpl::lock(this + 6);
  if (*((_QWORD *)a2 + 11) == 1)
  {
    *((_QWORD *)a2 + 11) = 0;
    if (*((_BYTE *)a2 + 80))
    {
      v4 = *((_QWORD *)a2 + 8);
      if (v4 >= 8)
      {
        v5 = (char *)a2 + 40;
        v6 = (char *)a2 + 40;
        if ((v4 & 2) == 0)
          v6 = *(char **)v5;
        (*(void (**)(char *, _QWORD, _QWORD, _QWORD))(v4 & 0xFFFFFFFFFFFFFFF8))(v6, *((_QWORD *)a2 + 2), *((_QWORD *)a2 + 3), *((_QWORD *)a2 + 4));
        v7 = *((_QWORD *)a2 + 8);
        if (v7 >= 8)
        {
          if ((v7 & 4) != 0)
          {
            if ((v7 & 2) == 0)
              v5 = *(char **)v5;
            (*(void (**)(char *))((v7 & 0xFFFFFFFFFFFFFFF8) + 16))(v5);
          }
          if ((v7 & 2) == 0)
            llvm::deallocate_buffer(*((llvm **)a2 + 5), *((void **)a2 + 6));
        }
      }
      *((_BYTE *)a2 + 80) = 0;
    }
  }
  else
  {
    --*((_QWORD *)a2 + 11);
  }
  return llvm::sys::RWMutexImpl::unlock_shared(v3);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConstantOp &>(mlir::mps::ConstantOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::`anonymous namespace'::`anonymous namespace'::canonicalizeType(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t *ArgAttrsAttr;
  uint64_t v5;
  uint64_t v6;
  void *OperandRange;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  unint64_t v17;
  unint64_t *v18;
  _QWORD *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  mlir::AffineMap *v24;
  mlir::AffineMap *v25;
  uint64_t v26;
  uint64_t MemorySpace;
  _QWORD *v29;
  void *v30;
  uint64_t v31;
  void *RankPromotionTypeForANE;
  uint64_t v33;
  _QWORD v34[6];

  v34[5] = *MEMORY[0x1E0C80C00];
  v30 = a2;
  v31 = a3;
  ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v30);
  if (mlir::ShapedType::getNumElements(ArgAttrsAttr, v5) == 1
    && (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v30), v6 <= 3))
  {
    OperandRange = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v30);
    v8 = mlir::TypeConverter::convertType(a1, OperandRange);
    if (!v8)
      v8 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v30);
    mlir::getRankPromotionShapeForANE((uint64_t)v30, v31, (uint64_t **)&RankPromotionTypeForANE);
    v9 = mlir::MemRefType::get(RankPromotionTypeForANE, (mlir::AffineMap *)v33, v8, 0, 0, 0);
    if (RankPromotionTypeForANE != v34)
      free(RankPromotionTypeForANE);
  }
  else
  {
    v10 = (_QWORD *)mlir::TypeConverter::convertType(a1, v30);
    v11 = (uint64_t)v10;
    v29 = v10;
    if (!v10)
      goto LABEL_16;
    v12 = *v10;
    v13 = mlir::TypeID::get<mlir::ShapedType>();
    v14 = *(unsigned int *)(v12 + 16);
    if (!(_DWORD)v14)
      goto LABEL_16;
    v15 = *(_QWORD **)(v12 + 8);
    v16 = &v15[2 * v14];
    do
    {
      v17 = v14 >> 1;
      v18 = &v15[2 * (v14 >> 1)];
      v20 = *v18;
      v19 = v18 + 2;
      v14 += ~(v14 >> 1);
      if (v20 < v13)
        v15 = v19;
      else
        v14 = v17;
    }
    while (v14);
    if (v15 != v16 && *v15 == v13)
      v21 = v15[1];
    else
LABEL_16:
      v21 = 0;
    RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE(v11, v21);
    v33 = v22;
    v23 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
    v25 = v24;
    v26 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&RankPromotionTypeForANE);
    MemorySpace = mlir::MemRefType::getMemorySpace((mlir::MemRefType *)&v29);
    return mlir::MemRefType::get(v23, v25, v26, 0, MemorySpace);
  }
  return v9;
}

mlir::TypeConverter *mlir::TypeConverter::TypeConverter(mlir::TypeConverter *this, const mlir::TypeConverter *a2)
{
  char *v4;

  *(_QWORD *)this = off_1E0E2B630;
  *((_QWORD *)this + 1) = (char *)this + 24;
  v4 = (char *)this + 8;
  *((_QWORD *)this + 2) = 0x400000000;
  if (*((_DWORD *)a2 + 4))
    llvm::SmallVectorImpl<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>::operator=((uint64_t)v4, (uint64_t)a2 + 8);
  *((_QWORD *)this + 19) = (char *)this + 168;
  *((_QWORD *)this + 20) = 0x200000000;
  if (*((_DWORD *)a2 + 40))
    llvm::SmallVectorImpl<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>::operator=((uint64_t)this + 152, (uint64_t)a2 + 152);
  *((_QWORD *)this + 29) = (char *)this + 248;
  *((_QWORD *)this + 30) = 0x200000000;
  if (*((_DWORD *)a2 + 60))
    llvm::SmallVectorImpl<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>::operator=((uint64_t)this + 232, (uint64_t)a2 + 232);
  *((_QWORD *)this + 39) = (char *)this + 328;
  *((_QWORD *)this + 40) = 0x200000000;
  if (*((_DWORD *)a2 + 80))
    llvm::SmallVectorImpl<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>::operator=((uint64_t)this + 312, (uint64_t)a2 + 312);
  *((_QWORD *)this + 49) = (char *)this + 408;
  *((_QWORD *)this + 50) = 0x200000000;
  if (*((_DWORD *)a2 + 100))
    llvm::SmallVectorImpl<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>::operator=((uint64_t)this + 392, (uint64_t)a2 + 392);
  *((_QWORD *)this + 59) = 0;
  *((_QWORD *)this + 60) = 0;
  *((_DWORD *)this + 122) = 0;
  *((_QWORD *)this + 62) = 0;
  *((_QWORD *)this + 63) = 0;
  *((_DWORD *)this + 128) = 0;
  llvm::sys::RWMutexImpl::RWMutexImpl((mlir::TypeConverter *)((char *)this + 520));
  *((_QWORD *)this + 66) = 0;
  return this;
}

uint64_t llvm::SmallVectorImpl<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>::operator=(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t i;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  _QWORD *v33;
  uint64_t v34;
  _QWORD *v35;
  _QWORD v36[3];
  _QWORD *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (a1 != a2)
  {
    v4 = *(unsigned int *)(a2 + 8);
    v5 = *(unsigned int *)(a1 + 8);
    if (v5 < v4)
    {
      if (*(_DWORD *)(a1 + 12) < v4)
      {
        if ((_DWORD)v5)
        {
          v6 = *(_QWORD **)a1;
          for (i = 4 * v5; i * 8; i -= 4)
          {
            v8 = (_QWORD *)v6[i - 1];
            if (&v6[i - 4] == v8)
            {
              v8 = &v6[i - 4];
              v9 = 4;
            }
            else
            {
              if (!v8)
                continue;
              v9 = 5;
            }
            (*(void (**)(void))(*v8 + 8 * v9))();
          }
        }
        *(_DWORD *)(a1 + 8) = 0;
        llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>,false>::grow(a1, v4);
        goto LABEL_40;
      }
      if (!(_DWORD)v5)
      {
LABEL_40:
        v5 = 0;
LABEL_41:
        v25 = *(unsigned int *)(a2 + 8);
        if (v5 != v25)
        {
          v26 = *(_QWORD **)a2;
          v27 = *(_QWORD *)a1 + 32 * v5;
          v28 = &v26[4 * v5];
          v29 = 32 * v25 - 32 * v5;
          do
          {
            v30 = (_QWORD *)v28[3];
            if (v30)
            {
              if (v28 == v30)
              {
                *(_QWORD *)(v27 + 24) = v27;
                (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)v28[3] + 24))(v28[3], v27);
              }
              else
              {
                *(_QWORD *)(v27 + 24) = (*(uint64_t (**)(_QWORD *))(*v30 + 16))(v30);
              }
            }
            else
            {
              *(_QWORD *)(v27 + 24) = 0;
            }
            v28 += 4;
            v27 += 32;
            v29 -= 32;
          }
          while (v29);
        }
LABEL_51:
        *(_DWORD *)(a1 + 8) = v4;
        return a1;
      }
      v19 = *(_QWORD **)a2;
      v20 = *(_QWORD **)a1;
      v21 = 32 * v5;
      while (1)
      {
        v24 = (_QWORD *)v19[3];
        if (v24)
        {
          if (v19 == v24)
          {
            v37 = v36;
            (*(void (**)(_QWORD *, _QWORD *))(*v19 + 24))(v19, v36);
          }
          else
          {
            v37 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v24 + 16))(v24);
          }
        }
        else
        {
          v37 = 0;
        }
        std::__function::__value_func<void ()(long long const&)>::swap[abi:nn180100](v36, v20);
        v22 = v37;
        if (v37 == v36)
        {
          v22 = v36;
          v23 = 4;
        }
        else
        {
          if (!v37)
            goto LABEL_30;
          v23 = 5;
        }
        (*(void (**)(void))(*v22 + 8 * v23))();
LABEL_30:
        v19 += 4;
        v20 += 4;
        v21 -= 32;
        if (!v21)
          goto LABEL_41;
      }
    }
    if ((_DWORD)v4)
    {
      v10 = 0;
      v11 = *(_QWORD **)a2;
      v12 = *(_QWORD **)a1;
      while (1)
      {
        v15 = &v11[v10];
        v16 = (_QWORD *)v11[v10 + 3];
        if (v16)
        {
          if (v15 == v16)
          {
            v37 = v36;
            (*(void (**)(_QWORD *, _QWORD *))(*v15 + 24))(v15, v36);
          }
          else
          {
            v37 = (_QWORD *)(*(uint64_t (**)(_QWORD))(*v16 + 16))(v11[v10 + 3]);
          }
        }
        else
        {
          v37 = 0;
        }
        std::__function::__value_func<void ()(long long const&)>::swap[abi:nn180100](v36, &v12[v10]);
        v13 = v37;
        if (v37 == v36)
        {
          v13 = v36;
          v14 = 4;
        }
        else
        {
          if (!v37)
            goto LABEL_16;
          v14 = 5;
        }
        (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_16:
        v10 += 4;
        if (4 * v4 == v10)
        {
          v17 = &v12[v10];
          v18 = *(_QWORD **)a1;
          v5 = *(unsigned int *)(a1 + 8);
          goto LABEL_50;
        }
      }
    }
    v18 = *(_QWORD **)a1;
    v17 = *(_QWORD **)a1;
LABEL_50:
    v31 = &v18[4 * v5];
    if (v31 == v17)
      goto LABEL_51;
    while (1)
    {
      v35 = v31 - 4;
      v33 = (_QWORD *)*(v31 - 1);
      if (v31 - 4 == v33)
      {
        v33 = v31 - 4;
        v34 = 4;
      }
      else
      {
        if (!v33)
          goto LABEL_55;
        v34 = 5;
      }
      (*(void (**)(void))(*v33 + 8 * v34))();
LABEL_55:
      v31 = v35;
      if (v35 == v17)
        goto LABEL_51;
    }
  }
  return a1;
}

void llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>,false>::grow(uint64_t a1, unint64_t a2)
{
  _QWORD *v3;
  void *v4;
  void *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  int v15;
  unint64_t v16;

  v16 = 0;
  v3 = (_QWORD *)(a1 + 16);
  v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 32, &v16);
  v5 = v4;
  v6 = *(_QWORD **)a1;
  v7 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v7)
  {
    v8 = 32 * v7;
    v9 = v4;
    do
    {
      v10 = (_QWORD *)v6[3];
      if (v10)
      {
        if (v6 == v10)
        {
          v9[3] = v9;
          (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)v6[3] + 24))(v6[3], v9);
        }
        else
        {
          v9[3] = v10;
          v6[3] = 0;
        }
      }
      else
      {
        v9[3] = 0;
      }
      v9 += 4;
      v6 += 4;
      v8 -= 32;
    }
    while (v8);
    v6 = *(_QWORD **)a1;
    v11 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v11)
    {
      v12 = 4 * v11;
      while (1)
      {
        v13 = (_QWORD *)v6[v12 - 1];
        if (&v6[v12 - 4] == v13)
        {
          v13 = &v6[v12 - 4];
          v14 = 4;
        }
        else
        {
          if (!v13)
            goto LABEL_13;
          v14 = 5;
        }
        (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_13:
        v12 -= 4;
        if (!(v12 * 8))
        {
          v6 = *(_QWORD **)a1;
          break;
        }
      }
    }
  }
  v15 = v16;
  if (v6 != v3)
    free(v6);
  *(_QWORD *)a1 = v5;
  *(_DWORD *)(a1 + 12) = v15;
}

void mlir::`anonymous namespace'::ConvertCropResize::~ConvertCropResize(mlir::_anonymous_namespace_::ConvertCropResize *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CropResizeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CropResizeOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[96];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::CropResizeOpGenericAdaptorBase::CropResizeOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CropResizeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[96];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::CropResizeOpGenericAdaptorBase::CropResizeOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::CropResizeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _QWORD v32[2];
  _QWORD *v33;
  _QWORD v34[4];
  __int16 v35;
  _OWORD v36[7];
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 96);
  v9 = *(_QWORD *)(a3 + 104);
  v37 = v8;
  v38 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 96);
      v29 = *(_OWORD *)(a3 + 64);
      v36[5] = *(_OWORD *)(a3 + 80);
      v36[6] = v28;
      v30 = *(_OWORD *)(a3 + 16);
      v36[0] = *(_OWORD *)a3;
      v36[1] = v30;
      v31 = *(_OWORD *)(a3 + 32);
      v36[3] = *(_OWORD *)(a3 + 48);
      v36[4] = v29;
      v36[2] = v31;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v36, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v37 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v38 = v23;
      if (v37)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v37);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v34[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v35 = 259;
    v32[0] = v34;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropResizeOp &>(mlir::mps::CropResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v32);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v37, v10);
    v32[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v32[1] = v13;
    if (v32[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v38;
    if (v37 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v35 = 259;
  v33 = v34;
  v34[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropResizeOp &>(mlir::mps::CropResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v33);
  return result;
}

void mlir::`anonymous namespace'::ConvertCropResize::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const void *ArgAttrsAttr;
  uint64_t v29;
  size_t v30;
  int v31;
  _BYTE *v32;
  unint64_t IndexFromDim;
  char v34;
  unint64_t v35;
  unint64_t v36;
  char v37;
  _QWORD *v38;
  uint64_t v39;
  mlir::AffineMap *v40;
  uint64_t OperandRange;
  mlir::Builder *v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  unint64_t v50;
  unint64_t *v51;
  _QWORD *v52;
  unint64_t v53;
  uint64_t v54;
  llvm::APFloatBase *v55;
  void *v56;
  void *v57;
  uint64_t v58;
  llvm::APFloatBase *v59;
  void *v60;
  char v61;
  char IsEqual;
  float v63;
  mlir::MLIRContext *v64;
  unint64_t v65;
  uint64_t v66;
  mlir::MLIRContext *v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  void *v71;
  char v72;
  uint64_t v73;
  uint64_t v74;
  char *v75;
  uint64_t v76;
  mlir::GenericProgramPoint *v77;
  uint64_t v78;
  uint64_t *v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  _QWORD *v83;
  _QWORD *v84;
  unint64_t v85;
  unint64_t *v86;
  _QWORD *v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  const void *v91;
  uint64_t v92;
  unsigned int v93;
  unint64_t v94;
  char v95;
  uint64_t v96;
  mlir::GenericProgramPoint *v97;
  mlir::AffineMap *v98;
  uint64_t v99;
  uint64_t v100;
  int v101;
  unsigned int v102;
  _QWORD *v103;
  _QWORD *v104;
  void *v105;
  mlir::AffineMap *v106;
  uint64_t v107;
  uint64_t ResizeHeight;
  unsigned int WindowHeight;
  uint64_t IntegerType;
  _QWORD *v111;
  _QWORD *v112;
  uint64_t v113;
  unint64_t v114;
  unint64_t v115;
  _QWORD *v116;
  _QWORD *v117;
  unint64_t v118;
  unint64_t *v119;
  _QWORD *v120;
  unint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  _QWORD *v126;
  _QWORD *v127;
  uint64_t v128;
  unint64_t v129;
  unint64_t v130;
  _QWORD *v131;
  _QWORD *v132;
  unint64_t v133;
  unint64_t *v134;
  _QWORD *v135;
  unint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  _QWORD *v140;
  _QWORD *v141;
  uint64_t v142;
  unint64_t v143;
  unint64_t v144;
  _QWORD *v145;
  _QWORD *v146;
  unint64_t v147;
  unint64_t *v148;
  _QWORD *v149;
  unint64_t v150;
  uint64_t v151;
  uint64_t v152;
  int GateLayout;
  uint64_t v154;
  _QWORD *v155;
  _QWORD *v156;
  uint64_t v157;
  unint64_t v158;
  unint64_t v159;
  _QWORD *v160;
  _QWORD *v161;
  unint64_t v162;
  unint64_t *v163;
  _QWORD *v164;
  unint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  _QWORD *v170;
  _QWORD *v171;
  uint64_t v172;
  unint64_t v173;
  unint64_t v174;
  _QWORD *v175;
  _QWORD *v176;
  unint64_t v177;
  unint64_t *v178;
  _QWORD *v179;
  unint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  _QWORD *v184;
  _QWORD *v185;
  uint64_t v186;
  unint64_t v187;
  unint64_t v188;
  _QWORD *v189;
  _QWORD *v190;
  unint64_t v191;
  unint64_t *v192;
  _QWORD *v193;
  unint64_t v194;
  uint64_t v195;
  uint64_t v196;
  mlir::MLIRContext *v197;
  llvm::APFloatBase *F16FloatAttr;
  uint64_t *v199;
  uint64_t v200;
  unint64_t v201;
  unint64_t v202;
  _QWORD *v203;
  _QWORD *v204;
  unint64_t v205;
  unint64_t *v206;
  _QWORD *v207;
  unint64_t v208;
  uint64_t v209;
  char *v210;
  uint64_t v211;
  uint64_t v212;
  _QWORD v213[2];
  _QWORD v214[2];
  uint64_t v215;
  uint64_t v216;
  _QWORD v217[2];
  uint64_t v218;
  _QWORD v219[2];
  void *v220;
  uint64_t v221;
  _BYTE v222[40];
  void *v223[2];
  _QWORD v224[5];
  void *v225;
  uint64_t v226;
  _QWORD v227[5];
  void *v228;
  uint64_t v229;
  _QWORD v230[5];
  void *v231;
  uint64_t v232;
  _BYTE v233[32];
  uint64_t v234;
  void *v235;
  uint64_t v236;
  _QWORD v237[2];
  void *GOCConstant;
  uint64_t v239;
  _QWORD v240[9];
  mlir::GenericProgramPoint *v241;
  uint64_t v242;
  _BYTE v243[40];
  _BYTE *v244;
  uint64_t v245;
  _BYTE v246[40];
  __int128 v247;
  uint64_t v248;

  v248 = *MEMORY[0x1E0C80C00];
  v218 = a2;
  v247 = *(_OWORD *)(a3 + 96);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v247, 1) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v217[0] = v5;
  v217[1] = v15;
  v16 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v218) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  GOCConstant = v16;
  v239 = v26;
  ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&GOCConstant);
  v29 = v27;
  v244 = v246;
  v245 = 0x500000000;
  v30 = 8 * v27;
  if ((unint64_t)(8 * v27) < 0x29)
  {
    v31 = 0;
    v32 = v246;
    if (!v29)
    {
LABEL_26:
      LODWORD(v245) = v31 + (v30 >> 3);
      llvm::SmallVectorImpl<long long>::insert((uint64_t)&v244, (uint64_t)v32, 3uLL, 1uLL);
      IndexFromDim = mlir::anec::getIndexFromDim(0, v245);
      if (!v34)
        goto LABEL_175;
      v35 = IndexFromDim;
      v36 = mlir::anec::getIndexFromDim(3, v245);
      if (!v37)
        goto LABEL_175;
      v38 = v244;
      v39 = *(_QWORD *)&v244[8 * v35];
      *(_QWORD *)&v244[8 * v35] = *(_QWORD *)&v244[8 * v36];
      v38[v36] = v39;
      v40 = (mlir::AffineMap *)v245;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v217);
      v216 = mlir::MemRefType::get(v38, v40, OperandRange, 0, 0, 0);
      v42 = (mlir::Builder *)(a4 + 8);
      v43 = *(_QWORD *)(v218 + 24);
      GOCConstant = (void *)mlir::ValueRange::dereference_iterator(&v247, 1);
      v215 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v43, &v216, (uint64_t *)&GOCConstant)- 16;
      v44 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v218) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v44)
        goto LABEL_37;
      v45 = *v44;
      v46 = mlir::TypeID::get<mlir::ShapedType>();
      v47 = *(unsigned int *)(v45 + 16);
      if (!(_DWORD)v47)
        goto LABEL_37;
      v48 = *(_QWORD **)(v45 + 8);
      v49 = &v48[2 * v47];
      do
      {
        v50 = v47 >> 1;
        v51 = &v48[2 * (v47 >> 1)];
        v53 = *v51;
        v52 = v51 + 2;
        v47 += ~(v47 >> 1);
        if (v53 < v46)
          v48 = v52;
        else
          v47 = v50;
      }
      while (v47);
      if (v48 != v49 && *v48 == v46)
        v54 = v48[1];
      else
LABEL_37:
        v54 = 0;
      v214[0] = v44;
      v214[1] = v54;
      mlir::mps::CropResizeOp::getSpatialScale((mlir::mps::CropResizeOp *)&v218, (uint64_t)&GOCConstant);
      v55 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v231, 1.0);
      v56 = llvm::APFloatBase::IEEEsingle(v55);
      llvm::APFloat::Storage::Storage(&v242, &v231, v56);
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v231);
      v57 = (void *)v239;
      v58 = v242;
      v60 = llvm::APFloatBase::PPCDoubleDouble(v59);
      if (v57 == (void *)v58)
      {
        if (v60 == v57)
          IsEqual = llvm::detail::DoubleAPFloat::bitwiseIsEqual((llvm::detail::DoubleAPFloat *)&v239, (const llvm::detail::DoubleAPFloat *)&v242);
        else
          IsEqual = llvm::detail::IEEEFloat::bitwiseIsEqual((llvm::detail::IEEEFloat *)&v239, (const llvm::detail::IEEEFloat *)&v242);
        v61 = IsEqual;
      }
      else
      {
        v61 = 0;
      }
      if (v60 == (void *)v242)
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v242);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v242);
      if (v60 == (void *)v239)
      {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v239);
        if ((v61 & 1) != 0)
          goto LABEL_62;
      }
      else
      {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v239);
        if ((v61 & 1) != 0)
          goto LABEL_62;
      }
      mlir::mps::CropResizeOp::getSpatialScale((mlir::mps::CropResizeOp *)&v218, (uint64_t)&GOCConstant);
      v63 = llvm::APFloat::convertToFloat(&GOCConstant);
      if (v60 == (void *)v239)
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v239);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v239);
      v64 = *(mlir::MLIRContext **)(v218 + 24);
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v216);
      *(float *)&v241 = v63;
      v239 = v66;
      v67 = *(mlir::MLIRContext **)(v218 + 24);
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v216);
      LODWORD(v231) = 0;
      v242 = v69;
      v225 = 0;
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v216);
      v71 = (void *)mlir::anec::getIndexFromDim(4, v70);
      if (!v72)
        goto LABEL_175;
      v225 = v71;
      v73 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v216) + 8 * v71);
      if (v73 == 5)
      {
        v74 = *(_QWORD *)(v218 + 24);
        LODWORD(v231) = 4;
        LODWORD(v228) = 1;
        v75 = (char *)mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long &,int,int>((mlir::Builder *)(a4 + 8), v74, &v215, (uint64_t *)&v225, (int *)&v231, (int *)&v228)- 16;
        v76 = *(_QWORD *)(v218 + 24);
        LODWORD(v231) = 0;
        LODWORD(v228) = 4;
        v215 = (uint64_t)mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long &,int,int>((mlir::Builder *)(a4 + 8), v76, &v215, (uint64_t *)&v225, (int *)&v231, (int *)&v228)- 16;
      }
      else
      {
        v75 = 0;
      }
      if (!(_BYTE)v239 || !(_BYTE)v242)
        goto LABEL_175;
      v77 = mlir::OpBuilder::create<mlir::anec::GOC,mlir::Value &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *(_QWORD *)(v218 + 24), &v215, &GOCConstant, &v241);
      v215 = (uint64_t)v77 - 16;
      if (v73 == 5)
      {
        v78 = *(_QWORD *)(v218 + 24);
        v228 = (char *)v77 - 16;
        v229 = (uint64_t)v75;
        mlir::ValueRange::ValueRange((unint64_t *)&v231, (uint64_t)&v228, 2uLL);
        LOBYTE(v223[0]) = 0;
        v215 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Concat,mlir::ValueRange,unsigned long long &,BOOL>((mlir::Builder *)(a4 + 8), v78, (uint64_t *)&v231, (uint64_t *)&v225, (unsigned __int8 *)v223)- 16;
      }
LABEL_62:
      v79 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v247, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v79)
        goto LABEL_71;
      v80 = *v79;
      v81 = mlir::TypeID::get<mlir::ShapedType>();
      v82 = *(unsigned int *)(v80 + 16);
      if (!(_DWORD)v82)
        goto LABEL_71;
      v83 = *(_QWORD **)(v80 + 8);
      v84 = &v83[2 * v82];
      do
      {
        v85 = v82 >> 1;
        v86 = &v83[2 * (v82 >> 1)];
        v88 = *v86;
        v87 = v86 + 2;
        v82 += ~(v82 >> 1);
        if (v88 < v81)
          v83 = v87;
        else
          v82 = v85;
      }
      while (v82);
      if (v83 != v84 && *v83 == v81)
        v89 = v83[1];
      else
LABEL_71:
        v89 = 0;
      v213[0] = v79;
      v213[1] = v89;
      v91 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v213);
      v92 = v90;
      v241 = (mlir::GenericProgramPoint *)v243;
      v242 = 0x500000000;
      if ((unint64_t)(8 * v90) < 0x29)
      {
        v93 = 0;
        if (!v90)
          goto LABEL_77;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v241, v243, (8 * v90) >> 3, 8);
        v93 = v242;
        if (!v92)
        {
LABEL_77:
          LODWORD(v242) = v93 + v92;
          v94 = mlir::anec::getIndexFromDim(4, v245);
          if (v95)
          {
            v96 = *(_QWORD *)&v244[8 * v94];
            GOCConstant = (void *)1;
            llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v241, (uint64_t)v241 + 8 * (v96 == 5), (uint64_t *)&GOCConstant);
            v97 = v241;
            v98 = (mlir::AffineMap *)v242;
            v99 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v213);
            v212 = mlir::MemRefType::get(v97, v98, v99, 0, 0, 0);
            v100 = *(_QWORD *)(v218 + 24);
            GOCConstant = (void *)mlir::ValueRange::dereference_iterator(&v247, 0);
            v211 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v100, &v212, (uint64_t *)&GOCConstant)- 16;
            if (v96 == 5)
              goto LABEL_88;
            GOCConstant = v240;
            v239 = 0x500000000;
            v101 = v242;
            if (!(_DWORD)v242)
            {
LABEL_86:
              v104 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v214);
              v105 = GOCConstant;
              *(_QWORD *)GOCConstant = *v104;
              v106 = (mlir::AffineMap *)v239;
              v107 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v213);
              v231 = (void *)mlir::MemRefType::get(v105, v106, v107, 0, 0, 0);
              v211 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v218 + 24), (uint64_t *)&v231, &v211)- 16;
              if (GOCConstant != v240)
                free(GOCConstant);
LABEL_88:
              GOCConstant = v240;
              v239 = 0x400000000;
              v240[8] = 4;
              ResizeHeight = mlir::mps::CropResizeOp::getResizeHeight((mlir::mps::CropResizeOp *)&v218);
              WindowHeight = mlir::mps::CostVolumeOp::getWindowHeight((mlir::mps::CostVolumeOp *)&v218);
              v235 = v237;
              v237[0] = ResizeHeight;
              v237[1] = WindowHeight;
              v236 = 0x200000002;
              v231 = (void *)2;
              IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
              v111 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v231, 1, IntegerType, 0);
              v112 = v111;
              if (!v111)
                goto LABEL_97;
              v113 = *v111;
              v114 = mlir::TypeID::get<mlir::ShapedType>();
              v115 = *(unsigned int *)(v113 + 16);
              if (!(_DWORD)v115)
                goto LABEL_97;
              v116 = *(_QWORD **)(v113 + 8);
              v117 = &v116[2 * v115];
              do
              {
                v118 = v115 >> 1;
                v119 = &v116[2 * (v115 >> 1)];
                v121 = *v119;
                v120 = v119 + 2;
                v115 += ~(v115 >> 1);
                if (v121 < v114)
                  v116 = v120;
                else
                  v115 = v118;
              }
              while (v115);
              if (v116 != v117 && *v116 == v114)
                v122 = v116[1];
              else
LABEL_97:
                v122 = 0;
              v123 = mlir::DenseElementsAttr::getFromRawBuffer(v112, v122, v235, 8 * v236, 8, 1, 0);
              mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"output_dims", 11, v123);
              v231 = v233;
              memset(v233, 0, sizeof(v233));
              v234 = 0;
              v232 = 0x500000005;
              v124 = 0;
              if (mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v218))
                v124 = 2
                     * (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v218) == 1);
              if (mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v218)
                && mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v218) == 2)
              {
                v124 = 1;
              }
              v228 = v230;
              v230[0] = v124;
              v230[1] = v124;
              v230[2] = v124;
              v230[3] = v124;
              v230[4] = v124;
              v229 = 0x500000005;
              v225 = (void *)5;
              v125 = mlir::Builder::getIntegerType(v42, 0x40u, 0);
              v126 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v225, 1, v125, 0);
              v127 = v126;
              if (!v126)
                goto LABEL_112;
              v128 = *v126;
              v129 = mlir::TypeID::get<mlir::ShapedType>();
              v130 = *(unsigned int *)(v128 + 16);
              if (!(_DWORD)v130)
                goto LABEL_112;
              v131 = *(_QWORD **)(v128 + 8);
              v132 = &v131[2 * v130];
              do
              {
                v133 = v130 >> 1;
                v134 = &v131[2 * (v130 >> 1)];
                v136 = *v134;
                v135 = v134 + 2;
                v130 += ~(v130 >> 1);
                if (v136 < v129)
                  v131 = v135;
                else
                  v130 = v133;
              }
              while (v130);
              if (v131 != v132 && *v131 == v129)
                v137 = v131[1];
              else
LABEL_112:
                v137 = 0;
              v138 = mlir::DenseElementsAttr::getFromRawBuffer(v127, v137, v231, 8 * v232, 8, 1, 0);
              v225 = (void *)5;
              v139 = mlir::Builder::getIntegerType(v42, 0x40u, 0);
              v140 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v225, 1, v139, 0);
              v141 = v140;
              if (!v140)
                goto LABEL_122;
              v142 = *v140;
              v143 = mlir::TypeID::get<mlir::ShapedType>();
              v144 = *(unsigned int *)(v142 + 16);
              if (!(_DWORD)v144)
                goto LABEL_122;
              v145 = *(_QWORD **)(v142 + 8);
              v146 = &v145[2 * v144];
              do
              {
                v147 = v144 >> 1;
                v148 = &v145[2 * (v144 >> 1)];
                v150 = *v148;
                v149 = v148 + 2;
                v144 += ~(v144 >> 1);
                if (v150 < v143)
                  v145 = v149;
                else
                  v144 = v147;
              }
              while (v144);
              if (v145 != v146 && *v145 == v143)
                v151 = v145[1];
              else
LABEL_122:
                v151 = 0;
              v152 = mlir::DenseElementsAttr::getFromRawBuffer(v141, v151, v228, 8 * v229, 8, 1, 0);
              mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"normalized_range", 16, v138);
              mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"coordinate_mode", 15, v152);
              GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v218);
              v225 = v227;
              v227[0] = GateLayout != 1;
              v227[1] = v227[0];
              v227[2] = v227[0];
              v227[3] = v227[0];
              v227[4] = v227[0];
              v226 = 0x500000005;
              v223[0] = (void *)5;
              v154 = mlir::Builder::getIntegerType(v42, 0x40u, 0);
              v155 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v223, 1, v154, 0);
              v156 = v155;
              if (!v155)
                goto LABEL_132;
              v157 = *v155;
              v158 = mlir::TypeID::get<mlir::ShapedType>();
              v159 = *(unsigned int *)(v157 + 16);
              if (!(_DWORD)v159)
                goto LABEL_132;
              v160 = *(_QWORD **)(v157 + 8);
              v161 = &v160[2 * v159];
              do
              {
                v162 = v159 >> 1;
                v163 = &v160[2 * (v159 >> 1)];
                v165 = *v163;
                v164 = v163 + 2;
                v159 += ~(v159 >> 1);
                if (v165 < v158)
                  v160 = v164;
                else
                  v159 = v162;
              }
              while (v159);
              if (v160 != v161 && *v160 == v158)
                v166 = v160[1];
              else
LABEL_132:
                v166 = 0;
              v167 = mlir::DenseElementsAttr::getFromRawBuffer(v156, v166, v225, 8 * v226, 8, 1, 0);
              mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"sampling_method", 15, v167);
              v168 = qword_181246650[(int)mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v218)];
              v223[0] = v224;
              v224[0] = v168;
              v224[1] = v168;
              v224[2] = v168;
              v224[3] = v168;
              v224[4] = v168;
              v223[1] = (void *)0x500000005;
              v220 = (void *)5;
              v169 = mlir::Builder::getIntegerType(v42, 0x40u, 0);
              v170 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v220, 1, v169, 0);
              v171 = v170;
              if (!v170)
                goto LABEL_142;
              v172 = *v170;
              v173 = mlir::TypeID::get<mlir::ShapedType>();
              v174 = *(unsigned int *)(v172 + 16);
              if (!(_DWORD)v174)
                goto LABEL_142;
              v175 = *(_QWORD **)(v172 + 8);
              v176 = &v175[2 * v174];
              do
              {
                v177 = v174 >> 1;
                v178 = &v175[2 * (v174 >> 1)];
                v180 = *v178;
                v179 = v178 + 2;
                v174 += ~(v174 >> 1);
                if (v180 < v173)
                  v175 = v179;
                else
                  v174 = v177;
              }
              while (v174);
              if (v175 != v176 && *v175 == v173)
                v181 = v175[1];
              else
LABEL_142:
                v181 = 0;
              v182 = mlir::DenseElementsAttr::getFromRawBuffer(v171, v181, v225, 8 * v226, 8, 1, 0);
              mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"sampling_mode", 13, v182);
              v220 = v222;
              memset_pattern16(v222, &unk_1812464F0, 0x28uLL);
              v221 = 0x500000005;
              v219[0] = 5;
              v183 = mlir::Builder::getIntegerType(v42, 0x40u, 0);
              v184 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v219, 1, v183, 0);
              v185 = v184;
              if (!v184)
                goto LABEL_152;
              v186 = *v184;
              v187 = mlir::TypeID::get<mlir::ShapedType>();
              v188 = *(unsigned int *)(v186 + 16);
              if (!(_DWORD)v188)
                goto LABEL_152;
              v189 = *(_QWORD **)(v186 + 8);
              v190 = &v189[2 * v188];
              do
              {
                v191 = v188 >> 1;
                v192 = &v189[2 * (v188 >> 1)];
                v194 = *v192;
                v193 = v192 + 2;
                v188 += ~(v188 >> 1);
                if (v194 < v187)
                  v189 = v193;
                else
                  v188 = v191;
              }
              while (v188);
              if (v189 != v190 && *v189 == v187)
                v195 = v189[1];
              else
LABEL_152:
                v195 = 0;
              v196 = mlir::DenseElementsAttr::getFromRawBuffer(v185, v195, v220, 8 * v221, 8, 1, 0);
              mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"padding_modes", 13, v196);
              F16FloatAttr = mlir::Builder::getF16FloatAttr((mlir::Float16Type **)v42, 0.0, v197);
              mlir::NamedAttrList::set((uint64_t)&GOCConstant, (uint64_t)"background_value", 16, (uint64_t)F16FloatAttr);
              v199 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v218 + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
              if (!v199)
                goto LABEL_162;
              v200 = *v199;
              v201 = mlir::TypeID::get<mlir::ShapedType>();
              v202 = *(unsigned int *)(v200 + 16);
              if (!(_DWORD)v202)
                goto LABEL_162;
              v203 = *(_QWORD **)(v200 + 8);
              v204 = &v203[2 * v202];
              do
              {
                v205 = v202 >> 1;
                v206 = &v203[2 * (v202 >> 1)];
                v208 = *v206;
                v207 = v206 + 2;
                v202 += ~(v202 >> 1);
                if (v208 < v201)
                  v203 = v207;
                else
                  v202 = v205;
              }
              while (v202);
              if (v203 != v204 && *v203 == v201)
                v209 = v203[1];
              else
LABEL_162:
                v209 = 0;
              v219[0] = v199;
              v219[1] = v209;
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v219);
              mlir::Attribute::getContext((mlir::Attribute *)(v218 + 24));
              v210 = (char *)&loc_180759DBC
                   + 4
                   * byte_181246520[mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v218)];
              __asm { BR              X10 }
            }
            if (v242 < 6)
            {
              v103 = v240;
              v102 = v242;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&GOCConstant, v240, v242, 8);
              v102 = v242;
              if (!(_DWORD)v242)
              {
LABEL_85:
                LODWORD(v239) = v101;
                goto LABEL_86;
              }
              v103 = GOCConstant;
            }
            memcpy(v103, v241, 8 * v102);
            goto LABEL_85;
          }
LABEL_175:
          std::__throw_bad_optional_access[abi:nn180100]();
        }
      }
      memcpy((char *)v241 + 8 * v93, v91, 8 * v92);
      v93 = v242;
      goto LABEL_77;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v244, v246, (8 * v27) >> 3, 8);
    v31 = v245;
    v32 = v244;
    if (!v29)
      goto LABEL_26;
  }
  memcpy(&v32[8 * v31], ArgAttrsAttr, v30);
  v31 = v245;
  v32 = v244;
  goto LABEL_26;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropResizeOp &>(mlir::mps::CropResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reshape", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.reshape";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Reshape,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long &,int,int>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, int *a5, int *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.input_view", (const unsigned __int8 *)0xF, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.input_view";
    v21[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::InputView::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::GOC,mlir::Value &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(uint64_t *a1, uint64_t a2, uint64_t *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gain_offset_control", (const unsigned __int8 *)0x18, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"anec.gain_offset_control";
    v19[3] = 24;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::GOC::build(a1, (uint64_t)v21, *a3, *a4 - 16, *a5 - 16);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Concat,mlir::ValueRange,unsigned long long &,BOOL>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.concat", (const unsigned __int8 *)0xB, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"anec.concat";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::Concat::build(a1, (uint64_t)v21, *a3, a3[1], *a4, *a5);
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Concat,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.broadcast", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.broadcast";
    v17[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Broadcast,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::CropResize,mlir::ValueRange,mlir::NamedAttrList &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.crop_resize", (const unsigned __int8 *)0x10, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.crop_resize";
    v21[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::CropResize::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::CropResize,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertDepthwiseConv3D::~ConvertDepthwiseConv3D(mlir::_anonymous_namespace_::ConvertDepthwiseConv3D *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthwiseConv3DOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthwiseConv3DOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[80];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::DepthwiseConv3DOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthwiseConv3DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[80];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::DepthwiseConv3DOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::DepthwiseConv3DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _QWORD v31[2];
  _QWORD *v32;
  _QWORD v33[4];
  __int16 v34;
  _OWORD v35[6];
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 80);
  v9 = *(_QWORD *)(a3 + 88);
  v36 = v8;
  v37 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 48);
      v35[2] = *(_OWORD *)(a3 + 32);
      v35[3] = v28;
      v29 = *(_OWORD *)(a3 + 80);
      v35[4] = *(_OWORD *)(a3 + 64);
      v35[5] = v29;
      v30 = *(_OWORD *)(a3 + 16);
      v35[0] = *(_OWORD *)a3;
      v35[1] = v30;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v35, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v33[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v34 = 259;
    v31[0] = v33;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthwiseConv3DOp &>(mlir::mps::DepthwiseConv3DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v31);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v31[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v31[1] = v13;
    if (v31[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v31);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v37;
    if (v36 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v34 = 259;
  v32 = v33;
  v33[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthwiseConv3DOp &>(mlir::mps::DepthwiseConv3DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v32);
  return result;
}

void mlir::`anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t Result;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t *v16;
  _QWORD *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t ChannelAxis;
  uint64_t *v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  _QWORD *v38;
  _QWORD *v39;
  unint64_t v40;
  unint64_t *v41;
  _QWORD *v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t DefiningOp;
  uint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t IntegerType;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t *v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t v63;
  uint64_t ArgAttrsAttr;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  int PaddingStyle;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  mlir::GenericProgramPoint *v75;
  uint64_t v76;
  mlir::Operation *v77;
  uint64_t v78;
  uint64_t (*v79)(int, uint64_t);
  mlir::Operation *v80;
  mlir::Operation *v81;
  uint64_t v82;
  void *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t *v89;
  uint64_t v90;
  uint64_t v91[2];
  uint64_t ArgOperands;
  uint64_t v93;
  uint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t *v101;
  uint64_t *v102;
  uint64_t *v103;
  uint64_t v104;
  _QWORD v105[2];
  _QWORD v106[2];
  _QWORD *v107;
  uint64_t v108;
  mlir::Operation *v109;
  void *Strides;
  uint64_t v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  unint64_t v115;
  void *v116;
  uint64_t v117;
  _BYTE v118[24];
  void *v119;
  uint64_t v120;
  _BYTE v121[24];
  pthread_rwlock_t *v122[67];
  __int128 v123;
  uint64_t v124;

  v124 = *MEMORY[0x1E0C80C00];
  v109 = a2;
  v123 = *(_OWORD *)(a3 + 80);
  v6 = *((_QWORD *)a2 + 3);
  v108 = mlir::ValueRange::dereference_iterator(&v123, 0);
  v7 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v123, 1);
  v107 = v7;
  Result = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v109);
  v9 = (uint64_t *)(*(_QWORD *)(v108 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v9)
    goto LABEL_10;
  v10 = *v9;
  v11 = mlir::TypeID::get<mlir::ShapedType>();
  v12 = *(unsigned int *)(v10 + 16);
  if (!(_DWORD)v12)
    goto LABEL_10;
  v13 = *(_QWORD **)(v10 + 8);
  v14 = &v13[2 * v12];
  do
  {
    v15 = v12 >> 1;
    v16 = &v13[2 * (v12 >> 1)];
    v18 = *v16;
    v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11)
      v13 = v17;
    else
      v12 = v15;
  }
  while (v12);
  if (v13 != v14 && *v13 == v11)
    v19 = v13[1];
  else
LABEL_10:
    v19 = 0;
  v106[0] = v9;
  v106[1] = v19;
  v20 = (uint64_t *)(v7[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v20)
    goto LABEL_20;
  v21 = *v20;
  v22 = mlir::TypeID::get<mlir::ShapedType>();
  v23 = *(unsigned int *)(v21 + 16);
  if (!(_DWORD)v23)
    goto LABEL_20;
  v24 = *(_QWORD **)(v21 + 8);
  v25 = &v24[2 * v23];
  do
  {
    v26 = v23 >> 1;
    v27 = &v24[2 * (v23 >> 1)];
    v29 = *v27;
    v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22)
      v24 = v28;
    else
      v23 = v26;
  }
  while (v23);
  if (v24 != v25 && *v24 == v22)
    v30 = v24[1];
  else
LABEL_20:
    v30 = 0;
  v105[0] = v20;
  v105[1] = v30;
  if (*(_QWORD *)(Result + 8) >= 8uLL)
    mlir::TypeID::get<mlir::ShapedType>();
  mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v122, *(const mlir::TypeConverter **)(a1 + 96));
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v106);
  if (v31 == 4 && (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105), v32 == 4))
  {
    ChannelAxis = (int)mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v109);
    v34 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v109) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v34)
      goto LABEL_34;
    v35 = *v34;
    v36 = mlir::TypeID::get<mlir::ShapedType>();
    v37 = *(unsigned int *)(v35 + 16);
    if (!(_DWORD)v37)
      goto LABEL_34;
    v38 = *(_QWORD **)(v35 + 8);
    v39 = &v38[2 * v37];
    do
    {
      v40 = v37 >> 1;
      v41 = &v38[2 * (v37 >> 1)];
      v43 = *v41;
      v42 = v41 + 2;
      v37 += ~(v37 >> 1);
      if (v43 < v36)
        v38 = v42;
      else
        v37 = v40;
    }
    while (v37);
    if (v38 != v39 && *v38 == v36)
      v44 = v38[1];
    else
LABEL_34:
      v44 = 0;
    Strides = v34;
    v111 = v44;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Strides);
    if (mlir::getPositiveAxis(ChannelAxis, v45) == 1)
    {
      if (*(_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105) == 1)
      {
        v46 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105) + 8);
        v47 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v106) + 8);
        v103 = 0;
        v104 = 0;
        v119 = v7;
        DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v119);
        if (!DefiningOp)
          goto LABEL_61;
        v49 = DefiningOp;
        v50 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
        if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v49 + 48) + 32))(*(_QWORD *)(v49 + 48), v50))goto LABEL_61;
        Strides = &v112;
        v111 = 0x100000000;
        mlir::Operation::fold(v49, 0, 0, (uint64_t)&Strides);
        v51 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)Strides & 0xFFFFFFFFFFFFFFF8));
        v53 = v51;
        if (v51)
        {
          v103 = v51;
          v104 = v52;
        }
        if (Strides != &v112)
          free(Strides);
        if (v53)
        {
          Strides = (void *)3;
          IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
          v102 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Strides, 1, IntegerType, 0);
          Strides = (void *)6;
          v55 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
          v101 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Strides, 1, v55, 0);
          v119 = v121;
          v120 = 0x300000000;
          Strides = (void *)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v109);
          v56 = mlir::Attribute::cast<mlir::ElementsAttr>((uint64_t **)&Strides);
          mlir::getIntValues<unsigned long long>((uint64_t)v56, v57, (uint64_t)&v119, 1);
          if (*(_QWORD *)v119 == 1)
          {
            v58 = mlir::Type::cast<mlir::ShapedType>(&v102);
            v100 = mlir::DenseElementsAttr::getFromRawBuffer(v58, v59, v119, 8 * v120, 8, 1, 0);
            v116 = v118;
            v117 = 0x300000000;
            Strides = (void *)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v109);
            v60 = mlir::Attribute::cast<mlir::ElementsAttr>((uint64_t **)&Strides);
            mlir::getIntValues<unsigned long long>((uint64_t)v60, v61, (uint64_t)&v116, 1);
            v62 = mlir::Type::cast<mlir::ShapedType>(&v102);
            v99 = mlir::DenseElementsAttr::getFromRawBuffer(v62, v63, v116, 8 * v117, 8, 1, 0);
            ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105);
            v65 = *((_QWORD *)v116 + 1) * (*(_QWORD *)(ArgAttrsAttr + 16) - 1) + 1;
            v66 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105);
            v67 = *((_QWORD *)v116 + 2) * (*(_QWORD *)(v66 + 24) - 1) + 1;
            v97 = 0;
            v98 = 0;
            v95 = 0;
            v96 = 0;
            Strides = (void *)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v109);
            v68 = mlir::Attribute::cast<mlir::ElementsAttr>((uint64_t **)&Strides);
            v70 = v69;
            PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v109);
            v72 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v106);
            {
              ArgOperands = (uint64_t)mlir::Type::cast<mlir::ShapedType>(&v101);
              v93 = v74;
              Strides = 0;
              v111 = 0;
              v112 = v98;
              v113 = v97;
              v114 = v96;
              v115 = v95;
              v91[0] = (uint64_t)&Strides;
              v91[1] = 6;
              v94 = mlir::DenseIntElementsAttr::get<unsigned long long>(&ArgOperands, v91);
              v91[0] = 0;
              if (v46 / v47 == 1)
              {
                LODWORD(v90) = 1;
                LOBYTE(v89) = 1;
                Strides = 0;
                ArgOperands = 0;
                v75 = mlir::OpBuilder::create<mlir::anec::Convolution,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingMode &,int,BOOL,decltype(nullptr),decltype(nullptr)>(a4 + 1, v6, &v108, (uint64_t *)&v107, &v100, &v99, &v94, v91, (int *)&v90, (char *)&v89);
              }
              else
              {
                v90 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v106) + 8);
                ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v103);
                v93 = v82;
                Strides = *(void **)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105) + 8);
                v111 = 1;
                v112 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105) + 16);
                v113 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v105) + 24);
                v83 = (void *)mlir::ShapedType::clone((mlir::MemoryMapperInterface *)&ArgOperands, (uint64_t)&Strides, 4);
                ArgOperands = mlir::TypeConverter::convertType((uint64_t)v122, v83);
                v84 = (uint64_t)v103;
                v85 = v104;
                v89 = (uint64_t *)v83;
                v86 = mlir::Type::cast<mlir::ShapedType>(&v89);
                Strides = mlir::reshapeElementsAttr(v84, v85, (uint64_t)v86, v87);
                v111 = v88;
                v107 = (_QWORD *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v6, &ArgOperands, (_QWORD **)&Strides)- 16);
                LOBYTE(v89) = 0;
                Strides = 0;
                ArgOperands = 0;
                v75 = mlir::OpBuilder::create<mlir::anec::Convolution,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingMode &,long long &,BOOL,decltype(nullptr),decltype(nullptr)>(a4 + 1, v6, &v108, (uint64_t *)&v107, &v100, &v99, &v94, v91, &v90, (char *)&v89);
              }
              mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, v109, v75);
            }
            else
            {
            }
            if (v116 != v118)
              free(v116);
          }
          else
          {
          }
          if (v119 != v121)
            free(v119);
        }
        else
        {
LABEL_61:
        }
LABEL_60:
        mlir::TypeConverter::~TypeConverter(v122);
      }
      v76 = a4[2];
      if (!v76)
        goto LABEL_60;
      v81 = v109;
      if (!mlir::RewriterBase::Listener::classof(v76))
        goto LABEL_60;
      v78 = *((_QWORD *)v81 + 3);
    }
    else
    {
      v76 = a4[2];
      if (!v76)
        goto LABEL_60;
      v80 = v109;
      if (!mlir::RewriterBase::Listener::classof(v76))
        goto LABEL_60;
      v78 = *((_QWORD *)v80 + 3);
    }
  }
  else
  {
    v76 = a4[2];
    if (!v76)
      goto LABEL_60;
    v77 = v109;
    if (!mlir::RewriterBase::Listener::classof(v76))
      goto LABEL_60;
    v78 = *((_QWORD *)v77 + 3);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v76 + 64))(v76, v78, v79, &Strides);
  goto LABEL_60;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::`anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::`anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::`anonymous namespace'::getExplicitConv2DPadding(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t *a10, unint64_t *a11, unint64_t *a12, unint64_t *a13)
{
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  char *v21;
  uint64_t v22;
  _QWORD *v23;
  void *v25;
  uint64_t v26;
  _QWORD v27[9];

  v27[8] = *MEMORY[0x1E0C80C00];
  v13 = 1;
  switch(a3)
  {
    case 0:
      v25 = v27;
      v26 = 0x800000000;
      mlir::getIntValues<unsigned long long>(a1, a2, (uint64_t)&v25, 1);
      v20 = v25;
      v21 = (char *)v25 + 8 * v26;
      if (v25 == v21 - 32)
      {
LABEL_12:
        *a10 = *((_QWORD *)v21 - 4);
        *a11 = *((_QWORD *)v21 - 3);
        *a12 = *((_QWORD *)v21 - 2);
        *a13 = *((_QWORD *)v21 - 1);
        v13 = 1;
        if (v20 == v27)
          return v13;
        goto LABEL_16;
      }
      v22 = 8 * v26 - 32;
      v23 = v25;
      while (!*v23)
      {
        ++v23;
        v22 -= 8;
        if (!v22)
          goto LABEL_12;
      }
      v13 = 0;
      if (v25 != v27)
LABEL_16:
        free(v20);
      return v13;
    case 1:
      *a10 = 0;
      *a11 = 0;
      *a12 = 0;
      *a13 = 0;
      return v13;
    case 2:
    case 4:
      v14 = *(_QWORD *)(a4 + 16) % *(_QWORD *)(a6 + 8);
      if (!v14)
        v14 = *(_QWORD *)(a6 + 8);
      v15 = (a8 - v14) & ~((a8 - v14) >> 63);
      v16 = *(_QWORD *)(a4 + 24) % *(_QWORD *)(a6 + 16);
      if (!v16)
        v16 = *(_QWORD *)(a6 + 16);
      v17 = (a9 - v16) & ~((a9 - v16) >> 63);
      *a10 = v15 >> 1;
      *a11 = v15 - (v15 >> 1);
      *a12 = v17 >> 1;
      *a13 = v17 - (v17 >> 1);
      if (a3 == 4)
      {
        v18 = *a10;
        *a10 = *a11;
        *a11 = v18;
        v19 = *a12;
        *a12 = *a13;
        *a13 = v19;
      }
      return v13;
    default:
      return v13;
  }
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::`anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::DenseIntElementsAttr::get<unsigned long long>(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a2[1];
  if (v2)
    v3 = *a2;
  else
    v3 = 0;
  return mlir::DenseElementsAttr::getFromRawBuffer(*a1, a1[1], v3, 8 * v2, 8, 1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Convolution,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingMode &,int,BOOL,decltype(nullptr),decltype(nullptr)>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, int *a9, char *a10)
{
  uint64_t *Context;
  uint64_t v19;
  char v20;
  mlir::GenericProgramPoint *v21;
  mlir::GenericProgramPoint *v22;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  uint64_t v27[4];
  __int16 v28;
  _QWORD v29[40];

  v29[38] = *MEMORY[0x1E0C80C00];
  v24 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.convolution", (const unsigned __int8 *)0x10, Context);
  if (!v20)
  {
    v28 = 1283;
    v27[2] = (uint64_t)"anec.convolution";
    v27[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v19);
  mlir::anec::Convolution::build(a1, (uint64_t)v29, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, 0, 0);
  v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((_QWORD *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    v22 = v21;
  else
    v22 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v22;
}

uint64_t mlir::ShapedType::clone(mlir::MemoryMapperInterface *a1, uint64_t a2, uint64_t a3)
{
  uint64_t OperandRange;
  __int128 v6;
  char v7;

  *(_QWORD *)&v6 = a2;
  *((_QWORD *)&v6 + 1) = a3;
  v7 = 1;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange(a1);
  return mlir::ShapedType::cloneWith((uint64_t *)a1, &v6, OperandRange);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Convolution,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::anec::PaddingMode &,long long &,BOOL,decltype(nullptr),decltype(nullptr)>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, char *a10)
{
  uint64_t *Context;
  uint64_t v19;
  char v20;
  mlir::GenericProgramPoint *v21;
  mlir::GenericProgramPoint *v22;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  uint64_t v27[4];
  __int16 v28;
  _QWORD v29[40];

  v29[38] = *MEMORY[0x1E0C80C00];
  v24 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.convolution", (const unsigned __int8 *)0x10, Context);
  if (!v20)
  {
    v28 = 1283;
    v27[2] = (uint64_t)"anec.convolution";
    v27[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v19);
  mlir::anec::Convolution::build(a1, (uint64_t)v29, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, 0, 0);
  v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((_QWORD *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    v22 = v21;
  else
    v22 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v22;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "CWConv3DOp must have 4D inputs\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "CWConv3DOp must use NCHW data format");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "CWConv3DOp must use (1, C*ChannelMult, H, W) weights format");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "CWConv3DOp must have constant weights");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Conv stride must be 1 for batch axis\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertDepthwiseConv3D::matchAndRewriteWithStaticShapes(mlir::mps::DepthwiseConv3DOp,mlir::mps::DepthwiseConv3DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported padding values for Conv2D\n");
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::AddOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::AddOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::AddOpGenericAdaptorBase::AddOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::AddOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::AddOpGenericAdaptorBase::AddOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::AddOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::AddOp &>(mlir::mps::AddOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::AddOp &>(mlir::mps::AddOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _QWORD *v14;
  _QWORD *v15;
  mlir::MLIRContext *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v22;
  uint64_t GOC;
  __int128 v24;
  void *v25;
  uint64_t v26;
  _BYTE v27[16];
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v27;
  v25 = v27;
  v26 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v28 = v7;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    v9 = v26;
    v8 = v25;
    v28 = v7;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    v10 = ++*((_QWORD *)&v28 + 1);
  }
  while ((_QWORD)v28 != v7 || v10 != v6);
  v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  v28 = v24;
  v14 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v28, 0);
  v15 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    v16 = *(mlir::MLIRContext **)(a2 + 24);
    v17 = (uint64_t)a4;
    v18 = (uint64_t)v14;
    v19 = (uint64_t)v15;
  }
  else
  {
      goto LABEL_17;
    v16 = *(mlir::MLIRContext **)(a2 + 24);
    v17 = (uint64_t)a4;
    v18 = (uint64_t)v15;
    v19 = (uint64_t)v14;
  }
  if (GOC)
  {
    v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27)
    free(v25);
  return 1;
}

void mlir::`anonymous namespace'::`anonymous namespace'::assembleBroadcastOperands(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t BroadcastOperands;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;

  v6 = *(_QWORD *)(a1 + 72);
  v7 = *(_QWORD *)(v6 + 24);
  v8 = *(_QWORD *)(v6 + 56);
  v9 = **(_QWORD **)a3;
  v10 = *(_QWORD *)(*(_QWORD *)a3 + 8);
  {
    v13 = v12;
  }
  else
  {
      return;
    BroadcastOperands = v14;
  }
  *(_DWORD *)(a3 + 8) = 0;
  if (*(_DWORD *)(a3 + 12) > 1u)
  {
    v15 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), 2uLL, 8);
    v15 = *(unsigned int *)(a3 + 8);
  }
  v16 = (uint64_t *)(*(_QWORD *)a3 + 8 * v15);
  *v16 = BroadcastOperands;
  v16[1] = v13;
  *(_DWORD *)(a3 + 8) += 2;
}

BOOL mlir::`anonymous namespace'::`anonymous namespace'::isBroadcastWithFullRank(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *ArgAttrsAttr;
  uint64_t v29;
  uint64_t v30;
  _QWORD v32[2];
  _QWORD v33[2];

  v3 = (uint64_t *)(*(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3)
    goto LABEL_10;
  v4 = *v3;
  v5 = mlir::TypeID::get<mlir::ShapedType>();
  v6 = *(unsigned int *)(v4 + 16);
  if (!(_DWORD)v6)
    goto LABEL_10;
  v7 = *(_QWORD **)(v4 + 8);
  v8 = &v7[2 * v6];
  do
  {
    v9 = v6 >> 1;
    v10 = &v7[2 * (v6 >> 1)];
    v12 = *v10;
    v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5)
      v7 = v11;
    else
      v6 = v9;
  }
  while (v6);
  if (v7 != v8 && *v7 == v5)
    v13 = v7[1];
  else
LABEL_10:
    v13 = 0;
  v33[0] = v3;
  v33[1] = v13;
  v14 = (uint64_t *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14)
    goto LABEL_20;
  v15 = *v14;
  v16 = mlir::TypeID::get<mlir::ShapedType>();
  v17 = *(unsigned int *)(v15 + 16);
  if (!(_DWORD)v17)
    goto LABEL_20;
  v18 = *(_QWORD **)(v15 + 8);
  v19 = &v18[2 * v17];
  do
  {
    v20 = v17 >> 1;
    v21 = &v18[2 * (v17 >> 1)];
    v23 = *v21;
    v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16)
      v18 = v22;
    else
      v17 = v20;
  }
  while (v17);
  if (v18 != v19 && *v18 == v16)
    v24 = v18[1];
  else
LABEL_20:
    v24 = 0;
  v32[0] = v14;
  v32[1] = v24;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v33);
  v26 = v25;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
  if (v26 >= v27)
    return 0;
  ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v33);
  if (mlir::ShapedType::getNumElements(ArgAttrsAttr, v29) < 2)
    return 0;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
  return v30 > 3;
}

uint64_t mlir::`anonymous namespace'::`anonymous namespace'::getBroadcastOperands(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  unint64_t v27;
  unint64_t *v28;
  _QWORD *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const void *ArgAttrsAttr;
  uint64_t v34;
  size_t v35;
  unsigned int v36;
  mlir::AffineMap *v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  void *v41;
  uint64_t ElementTypeOrSelf;
  uint64_t v43;
  uint64_t v45[2];
  _QWORD v46[2];
  uint64_t v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  _QWORD v51[5];

  v51[4] = *MEMORY[0x1E0C80C00];
  v47 = a4;
  v48 = a5;
  v10 = (uint64_t *)(*(_QWORD *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_10;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_10;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_10:
    v20 = 0;
  v46[0] = v10;
  v46[1] = v20;
  v21 = (uint64_t *)(*(_QWORD *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v21)
    goto LABEL_20;
  v22 = *v21;
  v23 = mlir::TypeID::get<mlir::ShapedType>();
  v24 = *(unsigned int *)(v22 + 16);
  if (!(_DWORD)v24)
    goto LABEL_20;
  v25 = *(_QWORD **)(v22 + 8);
  v26 = &v25[2 * v24];
  do
  {
    v27 = v24 >> 1;
    v28 = &v25[2 * (v24 >> 1)];
    v30 = *v28;
    v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23)
      v25 = v29;
    else
      v24 = v27;
  }
  while (v24);
  if (v25 != v26 && *v25 == v23)
    v31 = v25[1];
  else
LABEL_20:
    v31 = 0;
  v45[0] = (uint64_t)v21;
  v45[1] = v31;
  ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v45);
  v34 = v32;
  v49 = v51;
  v50 = 0x400000000;
  v35 = 8 * v32;
  if ((unint64_t)(8 * v32) < 0x21)
  {
    v36 = 0;
    if (!v32)
      goto LABEL_26;
    goto LABEL_25;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, (8 * v32) >> 3, 8);
  v36 = v50;
  if (v34)
  {
LABEL_25:
    memcpy((char *)v49 + 8 * v36, ArgAttrsAttr, v35);
    v36 = v50;
  }
LABEL_26:
  LODWORD(v50) = v36 + (v35 >> 3);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v46);
  v37 = (mlir::AffineMap *)v50;
  if (v38 != v50)
  {
    v39 = v49;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v46);
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v49, (uint64_t)v39, v40 - v50, 1uLL);
    v37 = (mlir::AffineMap *)v50;
  }
  v41 = v49;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(a5);
  v45[0] = mlir::MemRefType::get(v41, v37, ElementTypeOrSelf, 0, 0, 0);
  mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a6 + 8), a1, v45, &v48);
  v43 = v47;
  if (v49 != v51)
    free(v49);
  return v43;
}

uint64_t mlir::`anonymous namespace'::`anonymous namespace'::isCompatibleWithGOC(uint64_t a1, _QWORD *a2)
{
  uint64_t DefiningOp;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t *v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t *ArgAttrsAttr;
  uint64_t v19;
  _BOOL8 v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t *v23;
  unint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t *v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  void *v38;
  unint64_t v39;
  unint64_t v40;
  _QWORD *v41;
  _QWORD v43[2];
  void *__s2;
  uint64_t v45;
  _QWORD v46[5];

  v46[4] = *MEMORY[0x1E0C80C00];
  __s2 = a2;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&__s2);
  if (!DefiningOp)
    return 0;
  v5 = DefiningOp;
  v6 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v5 + 48) + 32))(*(_QWORD *)(v5 + 48), v6))
    return 0;
  v7 = (uint64_t *)(a2[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v7)
    goto LABEL_12;
  v8 = *v7;
  v9 = mlir::TypeID::get<mlir::ShapedType>();
  v10 = *(unsigned int *)(v8 + 16);
  if (!(_DWORD)v10)
    goto LABEL_12;
  v11 = *(_QWORD **)(v8 + 8);
  v12 = &v11[2 * v10];
  do
  {
    v13 = v10 >> 1;
    v14 = &v11[2 * (v10 >> 1)];
    v16 = *v14;
    v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9)
      v11 = v15;
    else
      v10 = v13;
  }
  while (v10);
  if (v11 != v12 && *v11 == v9)
    v17 = v11[1];
  else
LABEL_12:
    v17 = 0;
  v43[0] = v7;
  v43[1] = v17;
  ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v43);
  if (mlir::ShapedType::getNumElements(ArgAttrsAttr, v19) == 1)
    return 1;
  v21 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v43);
  if (v22 < 3)
    return 0;
  v23 = (uint64_t *)v21;
  v24 = v22;
  v25 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v43);
  if (mlir::ShapedType::getNumElements(v25, v26) != *(uint64_t *)((char *)v23
                                                                + ((uint64_t)((v24 << 32) - 0x300000000) >> 29)))
    return 0;
  v27 = (uint64_t *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27)
    goto LABEL_26;
  v28 = *v27;
  v29 = mlir::TypeID::get<mlir::ShapedType>();
  v30 = *(unsigned int *)(v28 + 16);
  if (!(_DWORD)v30)
    goto LABEL_26;
  v31 = *(_QWORD **)(v28 + 8);
  v32 = &v31[2 * v30];
  do
  {
    v33 = v30 >> 1;
    v34 = &v31[2 * (v30 >> 1)];
    v36 = *v34;
    v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29)
      v31 = v35;
    else
      v30 = v33;
  }
  while (v30);
  if (v31 != v32 && *v31 == v29)
    v37 = v31[1];
  else
LABEL_26:
    v37 = 0;
  __s2 = v27;
  v45 = v37;
  v38 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__s2);
  v40 = v39;
  __s2 = v46;
  v45 = 0x400000000;
  if ((mlir::OpTrait::util::getBroadcastedShape((uint64_t *)v38, v39, v23, v24, (uint64_t)&__s2) & 1) != 0)
  {
    v41 = __s2;
    v20 = v40 == v45 && memcmp(v38, __s2, 8 * v45) == 0;
  }
  else
  {
    v20 = 0;
    v41 = __s2;
  }
  if (v41 != v46)
    free(v41);
  return v20;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  unint64_t v17[2];
  _QWORD v18[39];

  v18[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.add", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.add";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MultiplyOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MultiplyOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::MultiplyOpGenericAdaptorBase::MultiplyOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MultiplyOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::MultiplyOpGenericAdaptorBase::MultiplyOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::MultiplyOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MultiplyOp &>(mlir::mps::MultiplyOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MultiplyOp &>(mlir::mps::MultiplyOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _QWORD *v14;
  _QWORD *v15;
  mlir::MLIRContext *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v22;
  uint64_t GOC;
  __int128 v24;
  void *v25;
  uint64_t v26;
  _BYTE v27[16];
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v27;
  v25 = v27;
  v26 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v28 = v7;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    v9 = v26;
    v8 = v25;
    v28 = v7;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    v10 = ++*((_QWORD *)&v28 + 1);
  }
  while ((_QWORD)v28 != v7 || v10 != v6);
  v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  v28 = v24;
  v14 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v28, 0);
  v15 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    v16 = *(mlir::MLIRContext **)(a2 + 24);
    v17 = (uint64_t)a4;
    v18 = (uint64_t)v14;
    v19 = (uint64_t)v15;
  }
  else
  {
      goto LABEL_17;
    v16 = *(mlir::MLIRContext **)(a2 + 24);
    v17 = (uint64_t)a4;
    v18 = (uint64_t)v15;
    v19 = (uint64_t)v14;
  }
  if (GOC)
  {
    v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27)
    free(v25);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MultiplyOp &>(mlir::mps::MultiplyOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseMult,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  unint64_t v17[2];
  _QWORD v18[39];

  v18[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.mult", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.mult";
    v15[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SubtractOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SubtractOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SubtractOpGenericAdaptorBase::SubtractOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SubtractOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SubtractOpGenericAdaptorBase::SubtractOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SubtractOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SubtractOp &>(mlir::mps::SubtractOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SubtractOp &>(mlir::mps::SubtractOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, mlir::Float16Type **a4)
{
  unint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  unsigned int *v17;
  uint64_t *v18;
  mlir::MLIRContext *v19;
  uint64_t F16Type;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  mlir::GenericProgramPoint *v25;
  mlir::GenericProgramPoint *v26;
  _QWORD *v28[2];
  uint64_t ElementTypeOrSelf;
  uint64_t v30;
  __int128 v31;
  void *v32;
  uint64_t v33;
  _BYTE v34[16];
  __int128 v35;
  uint64_t v36;
  uint64_t v37[2];

  v37[1] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v34;
  v32 = v34;
  v33 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v35 = v7;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v32, v34, v6, 8);
    v9 = v33;
    v8 = v32;
    v35 = v7;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v35, v10);
    v10 = ++*((_QWORD *)&v35 + 1);
  }
  while ((_QWORD)v35 != v7 || v10 != v6);
  v13 = v33;
LABEL_11:
  LODWORD(v33) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v31, (uint64_t)v32, v33);
  v30 = a2;
  v35 = v31;
  v14 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v35, 0);
  v15 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v35, 1);
  v16 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v30);
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(v16);
  {
    v17 = (unsigned int *)v30;
    if (v28[0])
    {
      v37[0] = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v28);
      v18 = v37;
LABEL_14:
      mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, v17, (uint64_t)v18, 1);
      goto LABEL_20;
    }
  }
  else if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    {
      v37[0] = 1;
      F16Type = mlir::Builder::getF16Type(a4 + 1, v19);
      v21 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v37, 1, F16Type, 0);
      v28[0] = mlir::createSplatF16ElementsAttr(v21, -1.0);
      v28[1] = v22;
      v23 = *(_QWORD *)(v30 + 24);
      v36 = 1;
      v24 = mlir::Builder::getF16Type(a4 + 1, (mlir::MLIRContext *)v22);
      v37[0] = mlir::MemRefType::get(&v36, (mlir::AffineMap *)1, v24, 0, 0, 0);
      v25 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v23, v37, v28);
      v17 = (unsigned int *)v30;
      if (v37[0])
      {
        v36 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v37);
        v18 = &v36;
        goto LABEL_14;
      }
    }
  }
  v26 = mlir::OpBuilder::create<mlir::anec::ElementwiseSub,llvm::SmallVector<mlir::Value,2u> &>((uint64_t *)a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v32);
  (*((void (**)(mlir::Float16Type **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, a2, v26);
LABEL_20:
  if (v32 != v34)
    free(v32);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SubtractOp &>(mlir::mps::SubtractOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseSub,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  unint64_t v17[2];
  _QWORD v18[39];

  v18[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.sub", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.sub";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseSub,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MaximumOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MaximumOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::MaximumOpGenericAdaptorBase::MaximumOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MaximumOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::MaximumOpGenericAdaptorBase::MaximumOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::MaximumOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MaximumOp &>(mlir::mps::MaximumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MaximumOp &>(mlir::mps::MaximumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  mlir::GenericProgramPoint *v14;
  unint64_t v16;
  void *v17;
  uint64_t v18;
  _BYTE v19[16];
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v19;
  v17 = v19;
  v18 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v20 = v7;
    v21 = 0;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    v9 = v18;
    v8 = v17;
    v20 = v7;
    v21 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMax,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19)
    free(v17);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MaximumOp &>(mlir::mps::MaximumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseMax,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  unint64_t v17[2];
  _QWORD v18[39];

  v18[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.max", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.max";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMax,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MinimumOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MinimumOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::MinimumOpGenericAdaptorBase::MinimumOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MinimumOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::MinimumOpGenericAdaptorBase::MinimumOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::MinimumOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MinimumOp &>(mlir::mps::MinimumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MinimumOp &>(mlir::mps::MinimumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  mlir::GenericProgramPoint *v14;
  unint64_t v16;
  void *v17;
  uint64_t v18;
  _BYTE v19[16];
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v19;
  v17 = v19;
  v18 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v20 = v7;
    v21 = 0;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    v9 = v18;
    v8 = v17;
    v20 = v7;
    v21 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMin,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19)
    free(v17);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MinimumOp &>(mlir::mps::MinimumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseMin,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  unint64_t v17[2];
  _QWORD v18[39];

  v18[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.min", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.min";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMin,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Plus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)2>::~ConvertElementwiseBinaryA14Plus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PowerOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PowerOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::PowerOpGenericAdaptorBase::PowerOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PowerOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::PowerOpGenericAdaptorBase::PowerOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PowerOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PowerOp &>(mlir::mps::PowerOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PowerOp &>(mlir::mps::PowerOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  mlir::GenericProgramPoint *v14;
  unint64_t v16;
  void *v17;
  uint64_t v18;
  _BYTE v19[16];
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v19;
  v17 = v19;
  v18 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v20 = v7;
    v21 = 0;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    v9 = v18;
    v8 = v17;
    v20 = v7;
    v21 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  v14 = mlir::OpBuilder::create<mlir::anec::ElementwisePower,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19)
    free(v17);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PowerOp &>(mlir::mps::PowerOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwisePower,llvm::SmallVector<mlir::Value,2u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  unint64_t v17[2];
  _QWORD v18[39];

  v18[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.power", (const unsigned __int8 *)0xA, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.power";
    v15[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::Ceil::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwisePower,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _QWORD *v14;
  _QWORD *v15;
  mlir::MLIRContext *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v22;
  uint64_t GOC;
  __int128 v24;
  void *v25;
  uint64_t v26;
  _BYTE v27[16];
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v27;
  v25 = v27;
  v26 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v28 = v7;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    v9 = v26;
    v8 = v25;
    v28 = v7;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    v10 = ++*((_QWORD *)&v28 + 1);
  }
  while ((_QWORD)v28 != v7 || v10 != v6);
  v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  v28 = v24;
  v14 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v28, 0);
  v15 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    v16 = *(mlir::MLIRContext **)(a2 + 24);
    v17 = (uint64_t)a4;
    v18 = (uint64_t)v14;
    v19 = (uint64_t)v15;
  }
  else
  {
      goto LABEL_17;
    v16 = *(mlir::MLIRContext **)(a2 + 24);
    v17 = (uint64_t)a4;
    v18 = (uint64_t)v15;
    v19 = (uint64_t)v14;
  }
  if (GOC)
  {
    v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27)
    free(v25);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _QWORD *v14;
  _QWORD *v15;
  mlir::MLIRContext *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v22;
  uint64_t GOC;
  __int128 v24;
  void *v25;
  uint64_t v26;
  _BYTE v27[16];
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v27;
  v25 = v27;
  v26 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v28 = v7;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    v9 = v26;
    v8 = v25;
    v28 = v7;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    v10 = ++*((_QWORD *)&v28 + 1);
  }
  while ((_QWORD)v28 != v7 || v10 != v6);
  v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  v28 = v24;
  v14 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v28, 0);
  v15 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    v16 = *(mlir::MLIRContext **)(a2 + 24);
    v17 = (uint64_t)a4;
    v18 = (uint64_t)v14;
    v19 = (uint64_t)v15;
  }
  else
  {
      goto LABEL_17;
    v16 = *(mlir::MLIRContext **)(a2 + 24);
    v17 = (uint64_t)a4;
    v18 = (uint64_t)v15;
    v19 = (uint64_t)v14;
  }
  if (GOC)
  {
    v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27)
    free(v25);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, mlir::Float16Type **a4)
{
  unint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  unsigned int *v17;
  uint64_t *v18;
  mlir::MLIRContext *v19;
  uint64_t F16Type;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  mlir::GenericProgramPoint *v25;
  mlir::GenericProgramPoint *v26;
  _QWORD *v28[2];
  uint64_t ElementTypeOrSelf;
  uint64_t v30;
  __int128 v31;
  void *v32;
  uint64_t v33;
  _BYTE v34[16];
  __int128 v35;
  uint64_t v36;
  uint64_t v37[2];

  v37[1] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v34;
  v32 = v34;
  v33 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v35 = v7;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v32, v34, v6, 8);
    v9 = v33;
    v8 = v32;
    v35 = v7;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v35, v10);
    v10 = ++*((_QWORD *)&v35 + 1);
  }
  while ((_QWORD)v35 != v7 || v10 != v6);
  v13 = v33;
LABEL_11:
  LODWORD(v33) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v31, (uint64_t)v32, v33);
  v30 = a2;
  v35 = v31;
  v14 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v35, 0);
  v15 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v35, 1);
  v16 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v30);
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(v16);
  {
    v17 = (unsigned int *)v30;
    if (v28[0])
    {
      v37[0] = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v28);
      v18 = v37;
LABEL_14:
      mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, v17, (uint64_t)v18, 1);
      goto LABEL_20;
    }
  }
  else if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    {
      v37[0] = 1;
      F16Type = mlir::Builder::getF16Type(a4 + 1, v19);
      v21 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v37, 1, F16Type, 0);
      v28[0] = mlir::createSplatF16ElementsAttr(v21, -1.0);
      v28[1] = v22;
      v23 = *(_QWORD *)(v30 + 24);
      v36 = 1;
      v24 = mlir::Builder::getF16Type(a4 + 1, (mlir::MLIRContext *)v22);
      v37[0] = mlir::MemRefType::get(&v36, (mlir::AffineMap *)1, v24, 0, 0, 0);
      v25 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v23, v37, v28);
      v17 = (unsigned int *)v30;
      if (v37[0])
      {
        v36 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v37);
        v18 = &v36;
        goto LABEL_14;
      }
    }
  }
  v26 = mlir::OpBuilder::create<mlir::anec::ElementwiseSub,llvm::SmallVector<mlir::Value,2u> &>((uint64_t *)a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v32);
  (*((void (**)(mlir::Float16Type **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, a2, v26);
LABEL_20:
  if (v32 != v34)
    free(v32);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  mlir::GenericProgramPoint *v14;
  unint64_t v16;
  void *v17;
  uint64_t v18;
  _BYTE v19[16];
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v19;
  v17 = v19;
  v18 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v20 = v7;
    v21 = 0;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    v9 = v18;
    v8 = v17;
    v20 = v7;
    v21 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMax,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19)
    free(v17);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  mlir::GenericProgramPoint *v14;
  unint64_t v16;
  void *v17;
  uint64_t v18;
  _BYTE v19[16];
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v19;
  v17 = v19;
  v18 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v20 = v7;
    v21 = 0;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    v9 = v18;
    v8 = v17;
    v20 = v7;
    v21 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMin,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19)
    free(v17);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)1>::~ConvertElementwiseBinaryA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  mlir::GenericProgramPoint *v14;
  unint64_t v16;
  void *v17;
  uint64_t v18;
  _BYTE v19[16];
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v19;
  v17 = v19;
  v18 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v20 = v7;
    v21 = 0;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    v9 = v18;
    v8 = v17;
    v20 = v7;
    v21 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  v14 = mlir::OpBuilder::create<mlir::anec::ElementwisePower,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19)
    free(v17);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::AddOp,mlir::anec::ElementwiseAdd,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _QWORD *v14;
  _QWORD *v15;
  mlir::MLIRContext *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v22;
  uint64_t GOC;
  __int128 v24;
  void *v25;
  uint64_t v26;
  _BYTE v27[16];
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v27;
  v25 = v27;
  v26 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v28 = v7;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    v9 = v26;
    v8 = v25;
    v28 = v7;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    v10 = ++*((_QWORD *)&v28 + 1);
  }
  while ((_QWORD)v28 != v7 || v10 != v6);
  v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  v28 = v24;
  v14 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v28, 0);
  v15 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    v16 = *(mlir::MLIRContext **)(a2 + 24);
    v17 = (uint64_t)a4;
    v18 = (uint64_t)v14;
    v19 = (uint64_t)v15;
  }
  else
  {
      goto LABEL_17;
    v16 = *(mlir::MLIRContext **)(a2 + 24);
    v17 = (uint64_t)a4;
    v18 = (uint64_t)v15;
    v19 = (uint64_t)v14;
  }
  if (GOC)
  {
    v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27)
    free(v25);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MultiplyOp,mlir::anec::ElementwiseMult,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _QWORD *v14;
  _QWORD *v15;
  mlir::MLIRContext *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v22;
  uint64_t GOC;
  __int128 v24;
  void *v25;
  uint64_t v26;
  _BYTE v27[16];
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v27;
  v25 = v27;
  v26 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v28 = v7;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v6, 8);
    v9 = v26;
    v8 = v25;
    v28 = v7;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v28, v10);
    v10 = ++*((_QWORD *)&v28 + 1);
  }
  while ((_QWORD)v28 != v7 || v10 != v6);
  v13 = v26;
LABEL_11:
  LODWORD(v26) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v24, (uint64_t)v25, v26);
  v28 = v24;
  v14 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v28, 0);
  v15 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v28, 1);
  {
    v16 = *(mlir::MLIRContext **)(a2 + 24);
    v17 = (uint64_t)a4;
    v18 = (uint64_t)v14;
    v19 = (uint64_t)v15;
  }
  else
  {
      goto LABEL_17;
    v16 = *(mlir::MLIRContext **)(a2 + 24);
    v17 = (uint64_t)a4;
    v18 = (uint64_t)v15;
    v19 = (uint64_t)v14;
  }
  if (GOC)
  {
    v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)a2, (uint64_t)&v22, 1);
    goto LABEL_18;
  }
LABEL_17:
  v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v25);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
LABEL_18:
  if (v25 != v27)
    free(v25);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::SubtractOp,mlir::anec::ElementwiseSub,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, mlir::Float16Type **a4)
{
  unint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  unsigned int *v17;
  uint64_t *v18;
  mlir::MLIRContext *v19;
  uint64_t F16Type;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  mlir::GenericProgramPoint *v25;
  mlir::GenericProgramPoint *v26;
  _QWORD *v28[2];
  uint64_t ElementTypeOrSelf;
  uint64_t v30;
  __int128 v31;
  void *v32;
  uint64_t v33;
  _BYTE v34[16];
  __int128 v35;
  uint64_t v36;
  uint64_t v37[2];

  v37[1] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v34;
  v32 = v34;
  v33 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v35 = v7;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v32, v34, v6, 8);
    v9 = v33;
    v8 = v32;
    v35 = v7;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v35, v10);
    v10 = ++*((_QWORD *)&v35 + 1);
  }
  while ((_QWORD)v35 != v7 || v10 != v6);
  v13 = v33;
LABEL_11:
  LODWORD(v33) = v13 + v6;
  mlir::ValueRange::ValueRange((unint64_t *)&v31, (uint64_t)v32, v33);
  v30 = a2;
  v35 = v31;
  v14 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v35, 0);
  v15 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v35, 1);
  v16 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v30);
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(v16);
  {
    v17 = (unsigned int *)v30;
    if (v28[0])
    {
      v37[0] = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v28);
      v18 = v37;
LABEL_14:
      mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, v17, (uint64_t)v18, 1);
      goto LABEL_20;
    }
  }
  else if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    {
      v37[0] = 1;
      F16Type = mlir::Builder::getF16Type(a4 + 1, v19);
      v21 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v37, 1, F16Type, 0);
      v28[0] = mlir::createSplatF16ElementsAttr(v21, -1.0);
      v28[1] = v22;
      v23 = *(_QWORD *)(v30 + 24);
      v36 = 1;
      v24 = mlir::Builder::getF16Type(a4 + 1, (mlir::MLIRContext *)v22);
      v37[0] = mlir::MemRefType::get(&v36, (mlir::AffineMap *)1, v24, 0, 0, 0);
      v25 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v23, v37, v28);
      v17 = (unsigned int *)v30;
      if (v37[0])
      {
        v36 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v37);
        v18 = &v36;
        goto LABEL_14;
      }
    }
  }
  v26 = mlir::OpBuilder::create<mlir::anec::ElementwiseSub,llvm::SmallVector<mlir::Value,2u> &>((uint64_t *)a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v32);
  (*((void (**)(mlir::Float16Type **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, a2, v26);
LABEL_20:
  if (v32 != v34)
    free(v32);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MaximumOp,mlir::anec::ElementwiseMax,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  mlir::GenericProgramPoint *v14;
  unint64_t v16;
  void *v17;
  uint64_t v18;
  _BYTE v19[16];
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v19;
  v17 = v19;
  v18 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v20 = v7;
    v21 = 0;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    v9 = v18;
    v8 = v17;
    v20 = v7;
    v21 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMax,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19)
    free(v17);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::MinimumOp,mlir::anec::ElementwiseMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  mlir::GenericProgramPoint *v14;
  unint64_t v16;
  void *v17;
  uint64_t v18;
  _BYTE v19[16];
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v19;
  v17 = v19;
  v18 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v20 = v7;
    v21 = 0;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    v9 = v18;
    v8 = v17;
    v20 = v7;
    v21 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  v14 = mlir::OpBuilder::create<mlir::anec::ElementwiseMin,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19)
    free(v17);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertElementwiseBinaryA14Minus<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)0>::~ConvertElementwiseBinaryA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseBinary<mlir::mps::PowerOp,mlir::anec::ElementwisePower,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  mlir::GenericProgramPoint *v14;
  unint64_t v16;
  void *v17;
  uint64_t v18;
  _BYTE v19[16];
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v8 = v19;
  v17 = v19;
  v18 = 0x200000000;
  if (v6 < 3)
  {
    v9 = 0;
    v20 = v7;
    v21 = 0;
    if (!v6)
    {
      v13 = 0;
      goto LABEL_11;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v6, 8);
    v9 = v18;
    v8 = v17;
    v20 = v7;
    v21 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v8[8 * v9];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v20, v10);
    v10 = ++v21;
  }
  while (v20 != v7 || v10 != v6);
  v13 = v18;
LABEL_11:
  LODWORD(v18) = v13 + v6;
  mlir::ValueRange::ValueRange(&v16, (uint64_t)v17, v18);
  v14 = mlir::OpBuilder::create<mlir::anec::ElementwisePower,llvm::SmallVector<mlir::Value,2u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v17);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v14);
  if (v17 != v19)
    free(v17);
  return 1;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::AbsoluteOp,mlir::anec::ElementwiseAbs>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E29670;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_180760CD0()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::AbsoluteOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::AbsoluteOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::AbsoluteOpGenericAdaptorBase::AbsoluteOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::AbsoluteOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::AbsoluteOpGenericAdaptorBase::AbsoluteOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::AbsoluteOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::AbsoluteOp &>(mlir::mps::AbsoluteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::AbsoluteOp &>(mlir::mps::AbsoluteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::AbsoluteOp,mlir::anec::ElementwiseAbs>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::ElementwiseAbs,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::DenseMap<std::pair<unsigned int,std::string> const*>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _DWORD *buffer;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  _DWORD *v15;
  uint64_t v16;
  _DWORD *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  _DWORD *v22;
  int v23;
  int v24;
  uint64_t v25;
  _DWORD *v26;
  int v27;
  BOOL v28;
  int v29;

  v6 = (unint64_t)(*a3 - *a2) >> 5;
  if (!(_DWORD)v6)
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    goto LABEL_12;
  }
  v7 = (4 * (int)v6 / 3u + 1) | ((unint64_t)(4 * (int)v6 / 3u + 1) >> 1);
  v8 = v7 | (v7 >> 2) | ((v7 | (v7 >> 2)) >> 4);
  LODWORD(v8) = (((v8 | (v8 >> 8)) >> 16) | v8 | (v8 >> 8)) + 1;
  *(_DWORD *)(a1 + 16) = v8;
  buffer = llvm::allocate_buffer(32 * v8, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = buffer;
  *(_QWORD *)(a1 + 8) = 0;
  v10 = *(unsigned int *)(a1 + 16);
  if (!(_DWORD)v10)
    goto LABEL_12;
  v11 = (v10 - 1) & 0x7FFFFFFFFFFFFFFLL;
  if (!v11)
  {
    v14 = buffer;
LABEL_10:
    v17 = &buffer[8 * v10];
    do
    {
      *v14 = -1;
      v14 += 8;
    }
    while (v14 != v17);
    goto LABEL_12;
  }
  v12 = v11 + 1;
  v13 = (v11 + 1) & 0xFFFFFFFFFFFFFFELL;
  v14 = &buffer[8 * v13];
  v15 = buffer + 8;
  v16 = v13;
  do
  {
    *(v15 - 8) = -1;
    *v15 = -1;
    v15 += 16;
    v16 -= 2;
  }
  while (v16);
  if (v12 != v13)
    goto LABEL_10;
LABEL_12:
  v18 = *a2;
  v19 = *a3;
  if (v18 != v19)
  {
    while (1)
    {
      v24 = *(_DWORD *)(a1 + 16);
      if (!v24)
        break;
      v20 = v24 - 1;
      v21 = (37 * *(_DWORD *)v18) & v20;
      v22 = (_DWORD *)(*(_QWORD *)a1 + 32 * v21);
      v23 = *v22;
      if (*(_DWORD *)v18 != *v22)
      {
        v26 = 0;
        v27 = 1;
        while (v23 != -1)
        {
          if (v26)
            v28 = 0;
          else
            v28 = v23 == -2;
          if (v28)
            v26 = v22;
          v29 = v21 + v27++;
          v21 = v29 & v20;
          v22 = (_DWORD *)(*(_QWORD *)a1 + 32 * v21);
          v23 = *v22;
          if (*(_DWORD *)v18 == *v22)
            goto LABEL_15;
        }
        if (v26)
          v25 = (uint64_t)v26;
        else
          v25 = (uint64_t)v22;
        goto LABEL_18;
      }
LABEL_15:
      v18 += 32;
      if (v18 == v19)
        return a1;
    }
    v25 = 0;
LABEL_18:
    llvm::DenseMapBase<llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>,unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::InsertIntoBucket<unsigned int const&,std::string const&>(a1, v25, (_DWORD *)v18, (__int128 *)(v18 + 8));
    goto LABEL_15;
  }
  return a1;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>,unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::InsertIntoBucket<unsigned int const&,std::string const&>(uint64_t a1, uint64_t a2, _DWORD *a3, __int128 *a4)
{
  int v8;
  unsigned int v9;
  std::string *v10;
  __int128 v11;
  int v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  BOOL v19;
  int v20;

  v8 = *(_DWORD *)(a1 + 8);
  v9 = *(_DWORD *)(a1 + 16);
  if (4 * v8 + 4 >= 3 * v9)
  {
    v9 *= 2;
  }
  else if (v9 + ~v8 - *(_DWORD *)(a1 + 12) > v9 >> 3)
  {
    goto LABEL_3;
  }
  llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::grow(a1, v9);
  v13 = *(_DWORD *)(a1 + 16);
  if (v13)
  {
    v14 = v13 - 1;
    v15 = (37 * *a3) & v14;
    a2 = *(_QWORD *)a1 + 32 * v15;
    v16 = *(_DWORD *)a2;
    if (*a3 != *(_DWORD *)a2)
    {
      v17 = 0;
      v18 = 1;
      while (v16 != -1)
      {
        if (v17)
          v19 = 0;
        else
          v19 = v16 == -2;
        if (v19)
          v17 = a2;
        v20 = v15 + v18++;
        v15 = v20 & v14;
        a2 = *(_QWORD *)a1 + 32 * v15;
        v16 = *(_DWORD *)a2;
        if (*a3 == *(_DWORD *)a2)
          goto LABEL_3;
      }
      if (v17)
        a2 = v17;
    }
  }
  else
  {
    a2 = 0;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*(_DWORD *)a2 != -1)
    --*(_DWORD *)(a1 + 12);
  *(_DWORD *)a2 = *a3;
  v10 = (std::string *)(a2 + 8);
  if (*((char *)a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)a4, *((_QWORD *)a4 + 1));
  }
  else
  {
    v11 = *a4;
    *(_QWORD *)(a2 + 24) = *((_QWORD *)a4 + 2);
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
  }
  return a2;
}

_DWORD *llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  int *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _DWORD *result;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  _DWORD *v16;
  uint64_t v17;
  _DWORD *v18;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(int **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = llvm::allocate_buffer(32 * v8, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = result;
  if (v4)
  {
    v10 = (char *)(32 * v3);
    llvm::DenseMapBase<llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>,unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::moveFromOldBuckets(a1, v4, (int *)&v10[(_QWORD)v4]);
    llvm::deallocate_buffer((llvm *)v4, v10);
  }
  *(_QWORD *)(a1 + 8) = 0;
  v11 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v11)
  {
    v12 = (v11 - 1) & 0x7FFFFFFFFFFFFFFLL;
    if (v12)
    {
      v13 = v12 + 1;
      v14 = (v12 + 1) & 0xFFFFFFFFFFFFFFELL;
      v15 = &result[8 * v14];
      v16 = result + 8;
      v17 = v14;
      do
      {
        *(v16 - 8) = -1;
        *v16 = -1;
        v16 += 16;
        v17 -= 2;
      }
      while (v17);
      if (v13 == v14)
        return result;
    }
    else
    {
      v15 = result;
    }
    v18 = &result[8 * v11];
    do
    {
      *v15 = -1;
      v15 += 8;
    }
    while (v15 != v18);
  }
  return result;
}

void llvm::DenseMapBase<llvm::DenseMap<unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>,unsigned int,std::string,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,std::string>>::moveFromOldBuckets(uint64_t a1, int *a2, int *a3)
{
  int *v4;
  uint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  _DWORD *v12;
  uint64_t v13;
  _DWORD *v14;
  int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  BOOL v23;
  int v24;
  __int128 v25;

  v4 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(_DWORD **)a1;
    v8 = (v6 - 1) & 0x7FFFFFFFFFFFFFFLL;
    if (v8)
    {
      v9 = v8 + 1;
      v10 = (v8 + 1) & 0xFFFFFFFFFFFFFFELL;
      v11 = &v7[8 * v10];
      v12 = v7 + 8;
      v13 = v10;
      do
      {
        *(v12 - 8) = -1;
        *v12 = -1;
        v12 += 16;
        v13 -= 2;
      }
      while (v13);
      if (v9 == v10)
        goto LABEL_10;
    }
    else
    {
      v11 = *(_DWORD **)a1;
    }
    v14 = &v7[8 * v6];
    do
    {
      *v11 = -1;
      v11 += 8;
    }
    while (v11 != v14);
  }
LABEL_10:
  if (a2 != a3)
  {
    do
    {
      v15 = *v4;
      if (*v4 <= 0xFFFFFFFD)
      {
        v16 = *(_DWORD *)(a1 + 16);
        if (v16)
        {
          v17 = v16 - 1;
          v18 = (v16 - 1) & (37 * v15);
          v19 = *(_QWORD *)a1 + 32 * v18;
          v20 = *(_DWORD *)v19;
          if (v15 != *(_DWORD *)v19)
          {
            v21 = 0;
            v22 = 1;
            while (v20 != -1)
            {
              if (v21)
                v23 = 0;
              else
                v23 = v20 == -2;
              if (v23)
                v21 = v19;
              v24 = v18 + v22++;
              v18 = v24 & v17;
              v19 = *(_QWORD *)a1 + 32 * v18;
              v20 = *(_DWORD *)v19;
              if (v15 == *(_DWORD *)v19)
                goto LABEL_26;
            }
            if (v21)
              v19 = v21;
          }
        }
        else
        {
          v19 = 0;
        }
LABEL_26:
        *(_DWORD *)v19 = v15;
        v25 = *(_OWORD *)(v4 + 2);
        *(_QWORD *)(v19 + 24) = *((_QWORD *)v4 + 3);
        *(_OWORD *)(v19 + 8) = v25;
        *((_QWORD *)v4 + 2) = 0;
        *((_QWORD *)v4 + 3) = 0;
        *((_QWORD *)v4 + 1) = 0;
        ++*(_DWORD *)(a1 + 8);
        if (*((char *)v4 + 31) < 0)
          operator delete(*((void **)v4 + 1));
      }
      v4 += 8;
    }
    while (v4 != a3);
  }
}

void llvm::SmallVectorImpl<std::pair<llvm::APFloat,std::string>>::append<std::pair<llvm::APFloat,std::string> const*,void>(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  void *v9;
  unsigned int v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  llvm::detail::DoubleAPFloat *v14;
  const llvm::detail::DoubleAPFloat *v15;
  std::string *v16;
  const std::string::value_type **v17;
  __int128 v18;
  unint64_t v19;

  v5 = a1;
  v6 = 0x6DB6DB6DB6DB6DB7 * ((a3 - a2) >> 3);
  v7 = a1[2];
  if (v6 + v7 > (unint64_t)a1[3])
  {
    v19 = 0;
    v8 = a1 + 4;
    v9 = llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)a1, a1 + 4, v6 + v7, 56, &v19);
    llvm::SmallVectorTemplateBase<std::pair<llvm::APFloat,std::string>,false>::moveElementsForGrow(v5, (uint64_t)v9);
    v10 = v19;
    a1 = *(unsigned int **)v5;
    if (*(unsigned int **)v5 != v8)
      free(a1);
    *(_QWORD *)v5 = v9;
    v5[3] = v10;
    LODWORD(v7) = v5[2];
  }
  if (a2 != a3)
  {
    v11 = *(_QWORD *)v5 + 56 * v7;
    v12 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
    v13 = 0;
    do
    {
      v14 = (llvm::detail::DoubleAPFloat *)(v11 + v13 + 8);
      v15 = (const llvm::detail::DoubleAPFloat *)(a2 + v13 + 8);
      if (v12 == *(void **)v15)
        llvm::detail::DoubleAPFloat::DoubleAPFloat(v14, v15);
      else
        llvm::detail::IEEEFloat::IEEEFloat(v14, v15);
      v16 = (std::string *)(v11 + v13 + 32);
      v17 = (const std::string::value_type **)(a2 + v13 + 32);
      if (*(char *)(a2 + v13 + 55) < 0)
      {
        std::string::__init_copy_ctor_external(v16, *v17, *(_QWORD *)(a2 + v13 + 40));
      }
      else
      {
        v18 = *(_OWORD *)v17;
        *(_QWORD *)(v11 + v13 + 48) = *(_QWORD *)(a2 + v13 + 48);
        *(_OWORD *)&v16->__r_.__value_.__l.__data_ = v18;
      }
      v13 += 56;
    }
    while (a2 + v13 != a3);
    LODWORD(v7) = v5[2];
  }
  v5[2] = v7 + v6;
}

void llvm::SmallVectorTemplateBase<std::pair<llvm::APFloat,std::string>,false>::moveElementsForGrow(unsigned int *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  __int128 *v9;
  __int128 v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  llvm::detail::DoubleAPFloat *v17;

  v2 = a1[2];
  if ((_DWORD)v2)
  {
    v5 = *(_QWORD *)a1;
    v6 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
    v7 = a2 + 32;
    v8 = 56 * v2;
    v9 = (__int128 *)(v5 + 32);
    do
    {
      v11 = (_QWORD *)(v7 - 24);
      v12 = (_QWORD *)v9 - 3;
      if (v6 == *((void **)v9 - 3))
        llvm::detail::DoubleAPFloat::DoubleAPFloat(v11, v12);
      else
        llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v11, (uint64_t)v12);
      v10 = *v9;
      *(_QWORD *)(v7 + 16) = *((_QWORD *)v9 + 2);
      *(_OWORD *)v7 = v10;
      v7 += 56;
      *((_QWORD *)v9 + 1) = 0;
      *((_QWORD *)v9 + 2) = 0;
      *(_QWORD *)v9 = 0;
      v9 = (__int128 *)((char *)v9 + 56);
      v8 -= 56;
    }
    while (v8);
    v13 = a1[2];
    if ((_DWORD)v13)
    {
      v14 = *(_QWORD *)a1;
      v15 = 56 * v13;
      do
      {
        while (1)
        {
          v16 = v14 + v15;
          if (*(char *)(v14 + v15 - 1) < 0)
            operator delete(*(void **)(v16 - 24));
          v17 = (llvm::detail::DoubleAPFloat *)(v16 - 48);
          if (v6 != *(void **)(v16 - 48))
            break;
          llvm::detail::DoubleAPFloat::~DoubleAPFloat(v17);
          v15 -= 56;
          if (!v15)
            return;
        }
        llvm::detail::IEEEFloat::~IEEEFloat(v17);
        v15 -= 56;
      }
      while (v15);
    }
  }
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::AbsoluteOp &>(mlir::mps::AbsoluteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::AbsoluteOp,mlir::anec::ElementwiseAbs>::matchAndRewriteWithStaticShapes(mlir::mps::AbsoluteOp,mlir::mps::AbsoluteOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseAbs,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.abs", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.abs";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAbs,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertExponent::~ConvertExponent(mlir::_anonymous_namespace_::ConvertExponent *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ExponentOpGenericAdaptorBase::ExponentOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ExponentOpGenericAdaptorBase::ExponentOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ExponentOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentOp &>(mlir::mps::ExponentOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentOp &>(mlir::mps::ExponentOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertExponent::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::Float16Type **a4)
{
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *ArgAttrsAttr;
  mlir::MLIRContext *v19;
  mlir::AffineMap *v20;
  uint64_t F16Type;
  uint64_t v22;
  mlir::MLIRContext *v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  mlir::GenericProgramPoint *v28;
  mlir::GenericProgramPoint *v30;
  mlir::GenericProgramPoint *v31;
  _QWORD *v32[2];
  uint64_t v33;
  _QWORD v34[2];
  uint64_t v35;
  __int128 v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v36 = *(_OWORD *)(a3 + 40);
  v35 = mlir::ValueRange::dereference_iterator(&v36, 0);
  v6 = (uint64_t *)(*(_QWORD *)(v35 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v34[0] = v6;
  v34[1] = v16;
  v17 = *((_QWORD *)a2 + 3);
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v34);
  v20 = v19;
  F16Type = mlir::Builder::getF16Type(a4 + 1, v19);
  v33 = mlir::MemRefType::get(ArgAttrsAttr, v20, F16Type, 0, 0, 0);
  v22 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v34);
  v24 = (uint64_t)v23;
  v25 = mlir::Builder::getF16Type(a4 + 1, v23);
  v26 = (_QWORD *)mlir::RankedTensorType::get(v22, v24, v25, 0);
  v32[0] = mlir::createSplatF16ElementsAttr(v26, 1.4427);
  v32[1] = v27;
  v31 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v17, &v33, v32);
  v30 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>((uint64_t *)a4 + 1, v17, &v35, &v31);
  v28 = mlir::OpBuilder::create<mlir::anec::Exp2,mlir::anec::ElementwiseMult &>((uint64_t *)a4 + 1, v17, &v30);
  mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, a2, v28);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentOp &>(mlir::mps::ExponentOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>(uint64_t *a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.mult", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.mult";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3, *a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Exp2,mlir::anec::ElementwiseMult &>(uint64_t *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.exp2", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.exp2";
    v15[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseEqualZero::build(a1, (uint64_t)v17, *a3 - 16);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Exp2,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void mlir::`anonymous namespace'::ConvertLogarithm::~ConvertLogarithm(mlir::_anonymous_namespace_::ConvertLogarithm *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LogarithmOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LogarithmOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::LogarithmOpGenericAdaptorBase::LogarithmOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LogarithmOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::LogarithmOpGenericAdaptorBase::LogarithmOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::LogarithmOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LogarithmOp &>(mlir::mps::LogarithmOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LogarithmOp &>(mlir::mps::LogarithmOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertLogarithm::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, unint64_t *a3, mlir::Float16Type **a4)
{
  uint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t *v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *ArgAttrsAttr;
  mlir::MLIRContext *v20;
  mlir::AffineMap *v21;
  uint64_t F16Type;
  uint64_t v23;
  mlir::MLIRContext *v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  unsigned int ODSOperandIndexAndLength;
  unint64_t v30;
  mlir::MLIRContext *v31;
  mlir::GenericProgramPoint *v32;
  llvm::APFloatBase *F16FloatAttr;
  uint64_t v35;
  mlir::GenericProgramPoint *v36;
  _QWORD *v37[2];
  uint64_t v38;
  _QWORD v39[2];
  __int128 v40;
  mlir::GenericProgramPoint *v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v40 = *(_OWORD *)(a3 + 5);
  v7 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v40, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v7)
    goto LABEL_10;
  v8 = *v7;
  v9 = mlir::TypeID::get<mlir::ShapedType>();
  v10 = *(unsigned int *)(v8 + 16);
  if (!(_DWORD)v10)
    goto LABEL_10;
  v11 = *(_QWORD **)(v8 + 8);
  v12 = &v11[2 * v10];
  do
  {
    v13 = v10 >> 1;
    v14 = &v11[2 * (v10 >> 1)];
    v16 = *v14;
    v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9)
      v11 = v15;
    else
      v10 = v13;
  }
  while (v10);
  if (v11 != v12 && *v11 == v9)
    v17 = v11[1];
  else
LABEL_10:
    v17 = 0;
  v39[0] = v7;
  v39[1] = v17;
  v18 = *(_QWORD *)(a2 + 24);
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v39);
  v21 = v20;
  F16Type = mlir::Builder::getF16Type(a4 + 1, v20);
  v38 = mlir::MemRefType::get(ArgAttrsAttr, v21, F16Type, 0, 0, 0);
  v23 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v39);
  v25 = (uint64_t)v24;
  v26 = mlir::Builder::getF16Type(a4 + 1, v24);
  v27 = (_QWORD *)mlir::RankedTensorType::get(v23, v25, v26, 0);
  v37[0] = mlir::createSplatF16ElementsAttr(v27, 0.69315);
  v37[1] = v28;
  v36 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v18, &v38, v37);
  ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 0);
  v30 = a3[5];
  v41 = (mlir::GenericProgramPoint *)v30;
  v42 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v30 = mlir::ValueRange::offset_base(&v41, ODSOperandIndexAndLength);
  v41 = (mlir::GenericProgramPoint *)v30;
  v42 = 0;
  v35 = mlir::ValueRange::dereference_iterator(&v41, 0);
  F16FloatAttr = mlir::Builder::getF16FloatAttr(a4 + 1, 0.0, v31);
  v41 = mlir::OpBuilder::create<mlir::anec::Log2,mlir::Value,mlir::FloatAttr>((uint64_t *)a4 + 1, v18, &v35, (uint64_t *)&F16FloatAttr);
  v32 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::anec::Log2 &,mlir::mps::ConstantOp &>((uint64_t *)a4 + 1, *(_QWORD *)(a2 + 24), &v41, &v36);
  (*((void (**)(mlir::Float16Type **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, a2, v32);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LogarithmOp &>(mlir::mps::LogarithmOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Log2,mlir::Value,mlir::FloatAttr>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.log2", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.log2";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Invert::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Log2,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::anec::Log2 &,mlir::mps::ConstantOp &>(uint64_t *a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.mult", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.mult";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::`anonymous namespace'::ConvertSelect::~ConvertSelect(mlir::_anonymous_namespace_::ConvertSelect *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SelectOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SelectOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SelectOpGenericAdaptorBase::SelectOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SelectOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SelectOpGenericAdaptorBase::SelectOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SelectOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SelectOp &>(mlir::mps::SelectOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SelectOp &>(mlir::mps::SelectOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertSelect::matchAndRewriteWithStaticShapes(int a1, uint64_t a2, mlir::scf::detail::IfOpGenericAdaptorBase *this, uint64_t *a4)
{
  uint64_t *v7;
  uint64_t v8;
  unsigned int ODSOperandIndexAndLength;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unint64_t v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v22;
  mlir::GenericProgramPoint *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v7 = a4 + 1;
  v8 = *(_QWORD *)(a2 + 24);
  ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0);
  v10 = *((_QWORD *)this + 5);
  v26 = v10;
  v27 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v10 = mlir::ValueRange::offset_base(&v26, ODSOperandIndexAndLength);
  v26 = v10;
  v27 = 0;
  v26 = mlir::ValueRange::dereference_iterator(&v26, 0);
  v25 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqualZero,mlir::Value>(v7, v8, (uint64_t *)&v26) - 16;
  v11 = *(_QWORD *)(a2 + 24);
  v12 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0);
  v13 = *((_QWORD *)this + 5);
  v26 = v13;
  v27 = v12;
  if (v12)
    v13 = mlir::ValueRange::offset_base(&v26, v12);
  v26 = v13;
  v27 = 0;
  v26 = mlir::ValueRange::dereference_iterator(&v26, 0);
  v24 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseEqualZero,mlir::Value>(v7, v11, (uint64_t *)&v26) - 16;
  v14 = *(_QWORD *)(a2 + 24);
  v15 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 1u);
  v16 = *((_QWORD *)this + 5);
  v26 = v16;
  v27 = v15;
  if (v15)
    v16 = mlir::ValueRange::offset_base(&v26, v15);
  v26 = v16;
  v27 = 0;
  v26 = mlir::ValueRange::dereference_iterator(&v26, 0);
  v23 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value,mlir::Value&>(v7, v14, (uint64_t *)&v26, &v25);
  v17 = *(_QWORD *)(a2 + 24);
  v18 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 2u);
  v19 = *((_QWORD *)this + 5);
  v26 = v19;
  v27 = v18;
  if (v18)
    v19 = mlir::ValueRange::offset_base(&v26, v18);
  v26 = v19;
  v27 = 0;
  v22 = mlir::ValueRange::dereference_iterator(&v26, 0);
  v26 = (unint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value,mlir::Value&>(v7, v17, &v22, &v24);
  v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::anec::ElementwiseMult &,mlir::anec::ElementwiseMult &>(v7, *(_QWORD *)(a2 + 24), &v23, &v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SelectOp &>(mlir::mps::SelectOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqualZero,mlir::Value>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.not_equal_zero", (const unsigned __int8 *)0x13, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.not_equal_zero";
    v15[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseGreaterThanEqualZero::build(a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseNotEqualZero,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseEqualZero,mlir::Value>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.equal_zero", (const unsigned __int8 *)0xF, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.equal_zero";
    v15[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseEqualZero::build(a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseEqualZero,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value,mlir::Value&>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.mult", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.mult";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::anec::ElementwiseMult &,mlir::anec::ElementwiseMult &>(uint64_t *a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.add", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.add";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::`anonymous namespace'::ConvertFlatten2D::~ConvertFlatten2D(mlir::_anonymous_namespace_::ConvertFlatten2D *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::Flatten2DOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::Flatten2DOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::Flatten2DOpGenericAdaptorBase::Flatten2DOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::Flatten2DOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::Flatten2DOpGenericAdaptorBase::Flatten2DOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::Flatten2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::Flatten2DOp &>(mlir::mps::Flatten2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::Flatten2DOp &>(mlir::mps::Flatten2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertFlatten2D::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  uint64_t *SortedUniquePromotedPositiveAxesAttr;
  char v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  unint64_t v27;
  unint64_t *v28;
  _QWORD *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  unint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  __int128 *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  __int128 v67;
  uint64_t OperandRange;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  _QWORD *v74;
  _QWORD *v75;
  unint64_t v76;
  unint64_t *v77;
  _QWORD *v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  mlir::GenericProgramPoint *v83;
  uint64_t v84;
  const void ****v86;
  uint64_t v87;
  uint64_t v88;
  _QWORD *v89;
  uint64_t v90;
  void *v91;
  uint64_t v92;
  __int128 v93;
  char v94;
  __int128 v95;
  __int128 *v96;
  uint64_t v97;
  __int128 v98;
  void *v99;
  uint64_t v100;
  _OWORD v101[2];
  _QWORD *RankPromotionTypeForANE;
  uint64_t v103;
  _QWORD v104[2];

  v104[1] = *MEMORY[0x1E0C80C00];
  v88 = a2;
  v95 = *(_OWORD *)(a3 + 40);
  v6 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v89 = v6;
  v90 = v16;
  v17 = *(_QWORD **)(*(_QWORD *)(a2 + 72) + 56);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v89);
  SortedUniquePromotedPositiveAxesAttr = (uint64_t *)mlir::getSortedUniquePromotedPositiveAxesAttr(v17, v18, 0, 0);
  if (!v20)
  {
    LOBYTE(v91) = 0;
    v94 = 0;
    goto LABEL_70;
  }
  v21 = (uint64_t)SortedUniquePromotedPositiveAxesAttr;
  RankPromotionTypeForANE = v104;
  v103 = 0x100000000;
  if (!SortedUniquePromotedPositiveAxesAttr)
    goto LABEL_21;
  v22 = *SortedUniquePromotedPositiveAxesAttr;
  v23 = mlir::TypeID::get<mlir::ElementsAttr>();
  v24 = *(unsigned int *)(v22 + 16);
  if (!(_DWORD)v24)
    goto LABEL_21;
  v25 = *(_QWORD **)(v22 + 8);
  v26 = &v25[2 * v24];
  do
  {
    v27 = v24 >> 1;
    v28 = &v25[2 * (v24 >> 1)];
    v30 = *v28;
    v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23)
      v25 = v29;
    else
      v24 = v27;
  }
  while (v24);
  if (v25 != v26 && *v25 == v23)
    v31 = v25[1];
  else
LABEL_21:
    v31 = 0;
  v32 = 1;
  mlir::getIntValues<long long>(v21, v31, (uint64_t)&RankPromotionTypeForANE, 1);
  mlir::getRankPromotionShapeForANE((uint64_t)v89, v90, (uint64_t **)&v99);
  v96 = &v98;
  HIDWORD(v97) = 2;
  v33 = RankPromotionTypeForANE;
  v34 = *RankPromotionTypeForANE;
  if (!*RankPromotionTypeForANE)
  {
    v43 = 1;
    goto LABEL_33;
  }
  v35 = (v34 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (!v35)
  {
    v43 = 1;
    v38 = (char *)v99;
LABEL_31:
    v44 = (char *)v99 + 8 * v34;
    do
    {
      v45 = *(_QWORD *)v38;
      v38 += 8;
      v43 *= v45;
    }
    while (v38 != v44);
    goto LABEL_33;
  }
  v36 = v35 + 1;
  v37 = (v35 + 1) & 0x3FFFFFFFFFFFFFFELL;
  v38 = (char *)v99 + 8 * v37;
  v39 = (char *)v99 + 8;
  v40 = 1;
  v41 = v37;
  v42 = 1;
  do
  {
    v40 *= *(v39 - 1);
    v42 *= *v39;
    v39 += 2;
    v41 -= 2;
  }
  while (v41);
  v43 = v42 * v40;
  if (v36 != v37)
    goto LABEL_31;
LABEL_33:
  *(_QWORD *)&v98 = v43;
  LODWORD(v97) = 1;
  v46 = *RankPromotionTypeForANE;
  if (*RankPromotionTypeForANE == v100)
    goto LABEL_40;
  v47 = 8 * v46;
  v48 = (uint64_t *)((char *)v99 + 8 * v46);
  v49 = 8 * v100 - 8 - v47;
  if (!v49)
  {
    v32 = 1;
    do
    {
LABEL_39:
      v55 = *v48++;
      v32 *= v55;
    }
    while (v48 != (uint64_t *)((char *)v99 + 8 * v100));
    goto LABEL_40;
  }
  v50 = (v49 >> 3) + 1;
  v48 += v50 & 0x3FFFFFFFFFFFFFFELL;
  v51 = (char *)v99 + v47 + 8;
  v52 = 1;
  v53 = v50 & 0x3FFFFFFFFFFFFFFELL;
  v54 = 1;
  do
  {
    v52 *= *(v51 - 1);
    v54 *= *v51;
    v51 += 2;
    v53 -= 2;
  }
  while (v53);
  v32 = v54 * v52;
  if (v50 != (v50 & 0x3FFFFFFFFFFFFFFELL))
    goto LABEL_39;
LABEL_40:
  *((_QWORD *)&v98 + 1) = v32;
  v91 = &v93;
  v93 = v98;
  v92 = 0x200000002;
  v94 = 1;
  if (v99 != v101)
  {
    free(v99);
    v33 = RankPromotionTypeForANE;
  }
  if (v33 != v104)
    free(v33);
  if (!v94)
  {
LABEL_70:
    v84 = a4[2];
    if (v84)
    {
      if (!mlir::RewriterBase::Listener::classof(v84))
      {
        v84 = 0;
        if (v94)
        {
LABEL_74:
          if (v91 != &v93)
            free(v91);
        }
        return v84;
      }
    }
    if (v94)
      goto LABEL_74;
    return v84;
  }
  v56 = (__int128 *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v88) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v56)
    goto LABEL_54;
  v57 = *(_QWORD *)v56;
  v58 = mlir::TypeID::get<mlir::ShapedType>();
  v59 = *(unsigned int *)(v57 + 16);
  if (!(_DWORD)v59)
    goto LABEL_54;
  v60 = *(_QWORD **)(v57 + 8);
  v61 = &v60[2 * v59];
  do
  {
    v62 = v59 >> 1;
    v63 = &v60[2 * (v59 >> 1)];
    v65 = *v63;
    v64 = v63 + 2;
    v59 += ~(v59 >> 1);
    if (v65 < v58)
      v60 = v64;
    else
      v59 = v62;
  }
  while (v59);
  if (v60 != v61 && *v60 == v58)
    v66 = v60[1];
  else
LABEL_54:
    v66 = 0;
  v96 = v56;
  v97 = v66;
  if (v94)
  {
    v67 = *(_OWORD *)v91;
    v99 = v101;
    v101[0] = v67;
    v100 = 0x500000002;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v96);
    v69 = (uint64_t *)mlir::MemRefType::get(v101, (mlir::AffineMap *)2, OperandRange, 0, 0, 0);
    v70 = (uint64_t)v69;
    if (!v69)
      goto LABEL_65;
    v71 = *v69;
    v72 = mlir::TypeID::get<mlir::ShapedType>();
    v73 = *(unsigned int *)(v71 + 16);
    if (!(_DWORD)v73)
      goto LABEL_65;
    v74 = *(_QWORD **)(v71 + 8);
    v75 = &v74[2 * v73];
    do
    {
      v76 = v73 >> 1;
      v77 = &v74[2 * (v73 >> 1)];
      v79 = *v77;
      v78 = v77 + 2;
      v73 += ~(v73 >> 1);
      if (v79 < v72)
        v74 = v78;
      else
        v73 = v76;
    }
    while (v73);
    if (v74 != v75 && *v74 == v72)
      v80 = v74[1];
    else
LABEL_65:
      v80 = 0;
    RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE(v70, v80);
    v103 = v81;
    v82 = v88;
    v89 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v95, 0);
    v83 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 1), *(_QWORD *)(v82 + 24), (uint64_t *)&RankPromotionTypeForANE, (uint64_t *)&v89);
    (*(void (**)(_QWORD *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v82, v83);
    if (v99 != v101)
      free(v99);
    v84 = 1;
    if (!v94)
      return v84;
    goto LABEL_74;
  }
  v86 = (const void ****)std::__throw_bad_optional_access[abi:nn180100]();
  return llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::Flatten2DOp &>(mlir::mps::Flatten2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(v86, v87);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::Flatten2DOp &>(mlir::mps::Flatten2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertFlatten2D::matchAndRewriteWithStaticShapes(mlir::mps::Flatten2DOp,mlir::mps::Flatten2DOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Flatten2DOp axis argument was not a constant. \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertDivide<(mlir::anec::Family)0>::~ConvertDivide(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertDivide<(mlir::anec::Family)0>::~ConvertDivide(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DivideOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DivideOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::DivideOpGenericAdaptorBase::DivideOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DivideOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::DivideOpGenericAdaptorBase::DivideOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::DivideOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DivideOp &>(mlir::mps::DivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DivideOp &>(mlir::mps::DivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)0,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t DefiningOp;
  uint64_t v9;
  uint64_t v10;
  mlir::MLIRContext *v11;
  uint64_t v12;
  uint64_t v13;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t F16FloatAttr;
  __int128 v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v19 = *(_OWORD *)(a3 + 40);
  v17 = mlir::ValueRange::dereference_iterator(&v19, 0);
  v6 = mlir::ValueRange::dereference_iterator(&v19, 1);
  v16 = v6;
  v7 = *(_QWORD *)(a2 + 24);
  F16FloatAttr = v6;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&F16FloatAttr);
  if (DefiningOp
    && (v9 = DefiningOp,
        v10 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        (*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v9 + 48) + 32))(*(_QWORD *)(v9 + 48), v10))
    && (F16FloatAttr = mlir::getElementTypeOrSelf(v6), mlir::Type::isF16((mlir::Type *)&F16FloatAttr)))
  {
    F16FloatAttr = (uint64_t)mlir::Builder::getF16FloatAttr((mlir::Float16Type **)(a4 + 8), 0.0, v11);
    v15 = mlir::OpBuilder::create<mlir::anec::Invert,mlir::Value &,mlir::FloatAttr &>((uint64_t *)(a4 + 8), v7, &v16, &F16FloatAttr);
    F16FloatAttr = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v17, &v15)- 16;
    v12 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&F16FloatAttr, 1);
  }
  else
  {
    v13 = *(_QWORD *)(a4 + 16);
    if (v13 && mlir::RewriterBase::Listener::classof(v13))
    else
      return 0;
  }
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Invert,mlir::Value &,mlir::FloatAttr &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.invert", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.invert";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Invert::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Invert,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)0,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(mlir::mps::DivideOp,mlir::mps::DivideOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: can only support divide by a constant on A11/A12 class ANEs \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertDivide<(mlir::anec::Family)1>::~ConvertDivide(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertDivide<(mlir::anec::Family)1>::~ConvertDivide(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)1,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t DefiningOp;
  uint64_t v9;
  uint64_t v10;
  mlir::MLIRContext *v11;
  uint64_t v12;
  uint64_t v13;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t F16FloatAttr;
  __int128 v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v19 = *(_OWORD *)(a3 + 40);
  v17 = mlir::ValueRange::dereference_iterator(&v19, 0);
  v6 = mlir::ValueRange::dereference_iterator(&v19, 1);
  v16 = v6;
  v7 = *(_QWORD *)(a2 + 24);
  F16FloatAttr = v6;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&F16FloatAttr);
  if (DefiningOp
    && (v9 = DefiningOp,
        v10 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        (*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v9 + 48) + 32))(*(_QWORD *)(v9 + 48), v10))
    && (F16FloatAttr = mlir::getElementTypeOrSelf(v6), mlir::Type::isF16((mlir::Type *)&F16FloatAttr)))
  {
    F16FloatAttr = (uint64_t)mlir::Builder::getF16FloatAttr((mlir::Float16Type **)(a4 + 8), 0.0, v11);
    v15 = mlir::OpBuilder::create<mlir::anec::Invert,mlir::Value &,mlir::FloatAttr &>((uint64_t *)(a4 + 8), v7, &v16, &F16FloatAttr);
    F16FloatAttr = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v17, &v15)- 16;
    v12 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&F16FloatAttr, 1);
  }
  else
  {
    v13 = *(_QWORD *)(a4 + 16);
    if (v13 && mlir::RewriterBase::Listener::classof(v13))
    else
      return 0;
  }
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)1,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(mlir::mps::DivideOp,mlir::mps::DivideOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: can only support divide by a constant on A11/A12 class ANEs \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertDivide<(mlir::anec::Family)2>::~ConvertDivide(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertDivide<(mlir::anec::Family)2>::~ConvertDivide(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)2,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v10 = *(_OWORD *)(a3 + 40);
  v9 = mlir::ValueRange::dereference_iterator(&v10, 0);
  v8 = mlir::ValueRange::dereference_iterator(&v10, 1);
  v7 = (char *)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v9, &v8)- 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.div", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.div";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseDiv,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

_QWORD *mlir::`anonymous namespace'::ConvertDivide<(mlir::anec::Family)3>::~ConvertDivide(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertDivide<(mlir::anec::Family)3>::~ConvertDivide(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)3,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v10 = *(_OWORD *)(a3 + 40);
  v9 = mlir::ValueRange::dereference_iterator(&v10, 0);
  v8 = mlir::ValueRange::dereference_iterator(&v10, 1);
  v7 = (char *)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v9, &v8)- 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertDivide<(mlir::anec::Family)4>::~ConvertDivide(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertDivide<(mlir::anec::Family)4>::~ConvertDivide(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)4,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v10 = *(_OWORD *)(a3 + 40);
  v9 = mlir::ValueRange::dereference_iterator(&v10, 0);
  v8 = mlir::ValueRange::dereference_iterator(&v10, 1);
  v7 = (char *)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v9, &v8)- 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertDivide<(mlir::anec::Family)5>::~ConvertDivide(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertDivide<(mlir::anec::Family)5>::~ConvertDivide(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)5,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v10 = *(_OWORD *)(a3 + 40);
  v9 = mlir::ValueRange::dereference_iterator(&v10, 0);
  v8 = mlir::ValueRange::dereference_iterator(&v10, 1);
  v7 = (char *)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v9, &v8)- 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertDivide<(mlir::anec::Family)6>::~ConvertDivide(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertDivide<(mlir::anec::Family)6>::~ConvertDivide(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)6,mlir::mps::DivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v10 = *(_OWORD *)(a3 + 40);
  v9 = mlir::ValueRange::dereference_iterator(&v10, 0);
  v8 = mlir::ValueRange::dereference_iterator(&v10, 1);
  v7 = (char *)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v9, &v8)- 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)0>::~ConvertFloorDivide(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)0>::~ConvertFloorDivide(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorDivideOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorDivideOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::FloorDivideOpGenericAdaptorBase::FloorDivideOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorDivideOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::FloorDivideOpGenericAdaptorBase::FloorDivideOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::FloorDivideOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorDivideOp &>(mlir::mps::FloorDivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorDivideOp &>(mlir::mps::FloorDivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)0,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t DefiningOp;
  uint64_t v9;
  uint64_t v10;
  mlir::MLIRContext *v11;
  uint64_t v12;
  uint64_t v13;
  mlir::GenericProgramPoint *v15;
  llvm::APFloatBase *F16FloatAttr;
  uint64_t v17;
  uint64_t v18;
  uint64_t ElementTypeOrSelf;
  __int128 v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v20 = *(_OWORD *)(a3 + 40);
  v18 = mlir::ValueRange::dereference_iterator(&v20, 0);
  v6 = mlir::ValueRange::dereference_iterator(&v20, 1);
  v17 = v6;
  v7 = *(_QWORD *)(a2 + 24);
  ElementTypeOrSelf = v6;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ElementTypeOrSelf);
  if (DefiningOp
    && (v9 = DefiningOp,
        v10 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        (*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v9 + 48) + 32))(*(_QWORD *)(v9 + 48), v10))
    && (ElementTypeOrSelf = mlir::getElementTypeOrSelf(v6), mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf)))
  {
    F16FloatAttr = mlir::Builder::getF16FloatAttr((mlir::Float16Type **)(a4 + 8), 0.0, v11);
    v15 = mlir::OpBuilder::create<mlir::anec::Invert,mlir::Value &,mlir::FloatAttr &>((uint64_t *)(a4 + 8), v7, &v17, (uint64_t *)&F16FloatAttr);
    ElementTypeOrSelf = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v18, &v15)- 16;
    F16FloatAttr = (mlir::GenericProgramPoint *)((char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &ElementTypeOrSelf)- 16);
    v12 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&F16FloatAttr, 1);
  }
  else
  {
    v13 = *(_QWORD *)(a4 + 16);
    if (v13 && mlir::RewriterBase::Listener::classof(v13))
    else
      return 0;
  }
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorDivideOp &>(mlir::mps::FloorDivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.floor", (const unsigned __int8 *)0xA, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.floor";
    v15[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseEqualZero::build(a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Floor,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)0,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(mlir::mps::FloorDivideOp,mlir::mps::FloorDivideOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: can only support divide by a constant on A11/A12 class ANEs \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)1>::~ConvertFloorDivide(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)1>::~ConvertFloorDivide(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)1,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t DefiningOp;
  uint64_t v9;
  uint64_t v10;
  mlir::MLIRContext *v11;
  uint64_t v12;
  uint64_t v13;
  mlir::GenericProgramPoint *v15;
  llvm::APFloatBase *F16FloatAttr;
  uint64_t v17;
  uint64_t v18;
  uint64_t ElementTypeOrSelf;
  __int128 v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v20 = *(_OWORD *)(a3 + 40);
  v18 = mlir::ValueRange::dereference_iterator(&v20, 0);
  v6 = mlir::ValueRange::dereference_iterator(&v20, 1);
  v17 = v6;
  v7 = *(_QWORD *)(a2 + 24);
  ElementTypeOrSelf = v6;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ElementTypeOrSelf);
  if (DefiningOp
    && (v9 = DefiningOp,
        v10 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        (*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v9 + 48) + 32))(*(_QWORD *)(v9 + 48), v10))
    && (ElementTypeOrSelf = mlir::getElementTypeOrSelf(v6), mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf)))
  {
    F16FloatAttr = mlir::Builder::getF16FloatAttr((mlir::Float16Type **)(a4 + 8), 0.0, v11);
    v15 = mlir::OpBuilder::create<mlir::anec::Invert,mlir::Value &,mlir::FloatAttr &>((uint64_t *)(a4 + 8), v7, &v17, (uint64_t *)&F16FloatAttr);
    ElementTypeOrSelf = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v18, &v15)- 16;
    F16FloatAttr = (mlir::GenericProgramPoint *)((char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &ElementTypeOrSelf)- 16);
    v12 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&F16FloatAttr, 1);
  }
  else
  {
    v13 = *(_QWORD *)(a4 + 16);
    if (v13 && mlir::RewriterBase::Listener::classof(v13))
    else
      return 0;
  }
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)1,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(mlir::mps::FloorDivideOp,mlir::mps::FloorDivideOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: can only support divide by a constant on A11/A12 class ANEs \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)2>::~ConvertFloorDivide(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)2>::~ConvertFloorDivide(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)2,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v11 = *(_OWORD *)(a3 + 40);
  v10 = mlir::ValueRange::dereference_iterator(&v11, 0);
  v9 = mlir::ValueRange::dereference_iterator(&v11, 1);
  v8 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v10, &v9)- 16;
  v7 = (char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v8)
     - 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)3>::~ConvertFloorDivide(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)3>::~ConvertFloorDivide(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)3,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v11 = *(_OWORD *)(a3 + 40);
  v10 = mlir::ValueRange::dereference_iterator(&v11, 0);
  v9 = mlir::ValueRange::dereference_iterator(&v11, 1);
  v8 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v10, &v9)- 16;
  v7 = (char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v8)
     - 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)4>::~ConvertFloorDivide(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)4>::~ConvertFloorDivide(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)4,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v11 = *(_OWORD *)(a3 + 40);
  v10 = mlir::ValueRange::dereference_iterator(&v11, 0);
  v9 = mlir::ValueRange::dereference_iterator(&v11, 1);
  v8 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v10, &v9)- 16;
  v7 = (char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v8)
     - 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)5>::~ConvertFloorDivide(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)5>::~ConvertFloorDivide(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)5,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v11 = *(_OWORD *)(a3 + 40);
  v10 = mlir::ValueRange::dereference_iterator(&v11, 0);
  v9 = mlir::ValueRange::dereference_iterator(&v11, 1);
  v8 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v10, &v9)- 16;
  v7 = (char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v8)
     - 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)6>::~ConvertFloorDivide(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertFloorDivide<(mlir::anec::Family)6>::~ConvertFloorDivide(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertDivideImpl<(mlir::anec::Family)6,mlir::mps::FloorDivideOp>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v11 = *(_OWORD *)(a3 + 40);
  v10 = mlir::ValueRange::dereference_iterator(&v11, 0);
  v9 = mlir::ValueRange::dereference_iterator(&v11, 1);
  v8 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseDiv,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v10, &v9)- 16;
  v7 = (char *)mlir::OpBuilder::create<mlir::anec::Floor,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v8)
     - 16;
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, (uint64_t)&v7, 1);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)0>::~ConvertMatMul(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)0>::~ConvertMatMul(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MatMulOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MatMulOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[56];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::MatMulOpGenericAdaptorBase::MatMulOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::MatMulOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[56];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::MatMulOpGenericAdaptorBase::MatMulOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::MatMulOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 56);
  v9 = *(_QWORD *)(a3 + 64);
  v36 = v8;
  v37 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v28;
      v35 = *(_QWORD *)(a3 + 64);
      v29 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v37;
    if (v36 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t *v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  char *Input;
  int matched;
  char *Filter;
  _BOOL4 TransposeRhs;
  unsigned __int8 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int *v79;
  unsigned int *v80;
  uint64_t v82;
  uint64_t v84;
  _OWORD v85[4];
  _OWORD v86[4];
  char *v87;
  char *v88;
  _QWORD *v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t IndexFromDim;
  uint64_t v99;
  char *v100;
  unint64_t v101[2];
  pthread_rwlock_t *v102[67];
  __int128 v103;
  uint64_t ArgOperands;
  uint64_t v105;
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  v95 = a2;
  v103 = *(_OWORD *)(a3 + 56);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v93 = v5;
  v94 = v15;
  v82 = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  v84 = (uint64_t)v5;
  v91 = v16;
  v92 = v26;
  v27 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27)
    goto LABEL_30;
  v28 = *v27;
  v29 = mlir::TypeID::get<mlir::ShapedType>();
  v30 = *(unsigned int *)(v28 + 16);
  if (!(_DWORD)v30)
    goto LABEL_30;
  v31 = *(_QWORD **)(v28 + 8);
  v32 = &v31[2 * v30];
  do
  {
    v33 = v30 >> 1;
    v34 = &v31[2 * (v30 >> 1)];
    v36 = *v34;
    v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29)
      v31 = v35;
    else
      v30 = v33;
  }
  while (v30);
  if (v31 != v32 && *v31 == v29)
    v37 = v31[1];
  else
LABEL_30:
    v37 = 0;
  v89 = v27;
  v90 = v37;
  v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  v88 = v38;
  v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  v87 = v39;
  v40 = *(_QWORD *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (char *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95);
  Filter = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched)
      goto LABEL_42;
    v45 = 0;
LABEL_37:
    ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    v105 = v46;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2)
        goto LABEL_42;
LABEL_53:
      v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    v99 = v48;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
    if (v49 != 2)
      goto LABEL_42;
    v45 = 1;
    goto LABEL_53;
  }
  TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  v45 = TransposeRhs;
  if ((matched & 1) != 0)
    goto LABEL_37;
  if (TransposeRhs)
    goto LABEL_39;
LABEL_42:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v93);
  if (v50 >= 4)
  {
    v100 = v38;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    v105 = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v53 = v52;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    v99 = v54;
    v96 = mlir::anec::getIndexFromDim(3, v53);
    v97 = v55;
    v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    v88 = v38;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v91);
  if (v56 >= 4)
  {
    v100 = v39;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    v105 = v57;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v59 = v58;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    v99 = v60;
    v96 = mlir::anec::getIndexFromDim(3, v59);
    v97 = v61;
    v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    v100 = v38;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    v105 = v62;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v64 = v63;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    v99 = v65;
    v96 = mlir::anec::getIndexFromDim(4, v64);
    v97 = v66;
    v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    v100 = v39;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    v105 = v67;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v69 = v68;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    v99 = v70;
    v96 = mlir::anec::getIndexFromDim(4, v69);
    v97 = v71;
    v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  ArgOperands = 0;
  v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v89);
  if (v73 >= 4)
  {
    v100 = v72;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    v105 = v74;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v76 = v75;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    v99 = v77;
    v96 = mlir::anec::getIndexFromDim(3, v76);
    v97 = v78;
    v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  v79 = (unsigned int *)v95;
  ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

uint64_t mlir::`anonymous namespace'::matchAsConst(char *a1, uint64_t *a2)
{
  uint64_t DefiningOp;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t *ArgAttrsAttr;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t Axis;
  uint64_t KernelDimFromIndex;
  uint64_t v27;
  _QWORD v28[2];
  char *v29;
  uint64_t v30;
  char *v31;
  _QWORD *v32;
  char v33;
  void *ArgOperands;
  uint64_t v35;
  _QWORD v36[3];

  v36[2] = *MEMORY[0x1E0C80C00];
  v29 = a1;
  v31 = a1;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v31);
  if (DefiningOp)
  {
    v5 = DefiningOp;
    v6 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v5 + 48) + 32))(*(_QWORD *)(v5 + 48), v6))
    {
      ArgOperands = v36;
      v35 = 0x100000000;
      mlir::Operation::fold(v5, 0, 0, (uint64_t)&ArgOperands);
      v7 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)ArgOperands & 0xFFFFFFFFFFFFFFF8));
      v9 = v7;
      if (v7)
      {
        *a2 = (uint64_t)v7;
        a2[1] = v8;
      }
      if (ArgOperands != v36)
        free(ArgOperands);
      if (v9)
        return 1;
    }
  }
  ArgOperands = a2;
  v35 = (uint64_t)(a2 + 2);
  v36[0] = a2 + 4;
  v36[1] = a2 + 6;
  v30 = (uint64_t)a1;
  v11 = mlir::Value::getDefiningOp((mlir::Value *)&v30);
  if (!v11)
    return 0;
  v28[0] = v11;
  if (*(_UNKNOWN **)(*(_QWORD *)(v11 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id)
    return 0;
  if ((*(_BYTE *)(v11 + 46) & 0x80) == 0)
    return 0;
  if (*(_DWORD *)(v11 + 68) != 4)
    return 0;
  v33 = 1;
  v31 = &v33;
  v32 = v28;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>> &,mlir::detail::RecursivePatternMatcher<mlir::mps::DequantizeOp,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>> & &)#1},0ul,1ul,2ul,3ul>((uint64_t ***)&ArgOperands, (uint64_t)&v31);
  if (!v33
    || mlir::ElementsAttr::getNumElements(a2[6], a2[7]) != 1
    || (mlir::getSingleFloatValue<float>(a2[6], a2[7]) & 0x7FFFFFFF) != 0)
  {
    return 0;
  }
  v30 = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  ArgOperands = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)(a2 + 2));
  v35 = v12;
  v31 = (char *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)(a2 + 4));
  v32 = v13;
  ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
  if (mlir::ShapedType::getNumElements(ArgAttrsAttr, v15) == 1)
  {
    v16 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v31);
    if (mlir::ShapedType::getNumElements(v16, v17) == 1
      && (mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v30) & 0xFF00000000) == 0)
    {
      return 1;
    }
  }
  if ((mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v30) & 0xFF00000000) == 0)
    return 0;
  v28[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)a2);
  v28[1] = v18;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v28);
  v20 = v19;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
  v22 = v21;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v31);
  result = 0;
  if (v22 <= 1 && v23 <= 1)
  {
    if (v22 == 1 || v23 == 1)
    {
      Axis = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v30);
      if ((Axis & 0xFF00000000) != 0)
      {
        KernelDimFromIndex = mlir::anec::getKernelDimFromIndex((int)Axis, v20);
        return (KernelDimFromIndex & 0xFF00000000) != 0 && (_DWORD)KernelDimFromIndex == 0;
      }
      else
      {
        v27 = std::__throw_bad_optional_access[abi:nn180100]();
      }
    }
    return 1;
  }
  return result;
}

uint64_t mlir::`anonymous namespace'::convertToLinear(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t *a8, unsigned __int8 a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  int v20;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  mlir::OpBuilder *v48;
  _BOOL4 isSignedInteger;
  uint64_t IntegerType;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *Type;
  _QWORD *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t OperandRange;
  _QWORD *v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  _QWORD *v73;
  _QWORD *v74;
  unint64_t v75;
  unint64_t *v76;
  _QWORD *v77;
  unint64_t v78;
  uint64_t v79;
  void *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char *v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unsigned int *v96;
  uint64_t v98;
  char *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  unsigned int *v106;
  unint64_t v107;
  uint64_t v108;
  _QWORD *IndexFromDim;
  uint64_t v110;
  char *v111;
  unint64_t v112[2];
  __int128 v113;
  char v114;
  uint64_t v115;

  v20 = a9;
  v115 = *MEMORY[0x1E0C80C00];
  v105 = a11;
  v106 = a1;
  v103 = a13;
  v104 = a10;
  v101 = a15;
  v102 = a12;
  v99 = 0;
  v100 = a14;
  v98 = 0;
  if (a9)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v104);
    v22 = (char *)a5;
    if (v23 >= 4)
    {
      v111 = (char *)a5;
      *(_QWORD *)&v113 = mlir::getRankPromotionTypeForANE(v104, v105);
      *((_QWORD *)&v113 + 1) = v24;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v113);
      v26 = v25;
      IndexFromDim = (_QWORD *)mlir::anec::getIndexFromDim(1, v25);
      v110 = v27;
      v107 = mlir::anec::getIndexFromDim(3, v26);
      v108 = v28;
      v22 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
    }
    if (!mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v106))
    {
      v111 = v22;
      *(_QWORD *)&v113 = mlir::getRankPromotionTypeForANE(v104, v105);
      *((_QWORD *)&v113 + 1) = v29;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v113);
      v31 = v30;
      IndexFromDim = (_QWORD *)mlir::anec::getIndexFromDim(1, v30);
      v110 = v32;
      v107 = mlir::anec::getIndexFromDim(4, v31);
      v108 = v33;
      v22 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
    }
    a5 = a6;
  }
  else
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v102);
    v22 = (char *)a6;
    if (v35 >= 4)
    {
      v111 = (char *)a6;
      *(_QWORD *)&v113 = mlir::getRankPromotionTypeForANE(v102, v103);
      *((_QWORD *)&v113 + 1) = v36;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v113);
      v38 = v37;
      IndexFromDim = (_QWORD *)mlir::anec::getIndexFromDim(1, v37);
      v110 = v39;
      v107 = mlir::anec::getIndexFromDim(3, v38);
      v108 = v40;
      v22 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
    }
    if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v106))
    {
      v111 = v22;
      *(_QWORD *)&v113 = mlir::getRankPromotionTypeForANE(v102, v103);
      *((_QWORD *)&v113 + 1) = v41;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v113);
      v43 = v42;
      IndexFromDim = (_QWORD *)mlir::anec::getIndexFromDim(1, v42);
      v110 = v44;
      v107 = mlir::anec::getIndexFromDim(4, v43);
      v108 = v45;
      v22 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
    }
    a8 = a7;
  }
  v98 = a5;
  v99 = v22;
  v46 = a8[2];
  if (v46)
  {
    v47 = mlir::convertElementsAttr(v46, a8[3], 1);
    v48 = (mlir::OpBuilder *)(a2 + 8);
    *(_QWORD *)&v113 = mlir::getElementTypeOrSelf((_QWORD *)a8[4]);
    isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)&v113);
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a2 + 8), 8u, isSignedInteger);
    IndexFromDim = (_QWORD *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)(a8 + 4));
    v110 = v51;
    LOBYTE(v113) = 0;
    v114 = 0;
    v52 = mlir::ShapedType::cloneWith((uint64_t *)&IndexFromDim, &v113, IntegerType);
    v54 = mlir::rewriteElementsAttr(a8[4], a8[5], v52, v53, 1);
    Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)a8);
    v56 = Type;
    if (!Type)
      goto LABEL_22;
    v57 = *Type;
    v58 = mlir::TypeID::get<mlir::ShapedType>();
    v59 = *(unsigned int *)(v57 + 16);
    if (!(_DWORD)v59)
      goto LABEL_22;
    v60 = *(_QWORD **)(v57 + 8);
    v61 = &v60[2 * v59];
    do
    {
      v62 = v59 >> 1;
      v63 = &v60[2 * (v59 >> 1)];
      v65 = *v63;
      v64 = v63 + 2;
      v59 += ~(v59 >> 1);
      if (v65 < v58)
        v60 = v64;
      else
        v59 = v62;
    }
    while (v59);
    if (v60 != v61 && *v60 == v58)
      v66 = v60[1];
    else
LABEL_22:
      v66 = 0;
    *(_QWORD *)&v113 = v56;
    *((_QWORD *)&v113 + 1) = v66;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v113);
    v68 = (_QWORD *)(*(_QWORD *)(v98 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v68)
    {
      v69 = a3;
      v70 = *v68;
      v71 = mlir::TypeID::get<mlir::ShapedType>();
      v72 = *(unsigned int *)(v70 + 16);
      if ((_DWORD)v72)
      {
        v73 = *(_QWORD **)(v70 + 8);
        v74 = &v73[2 * v72];
        do
        {
          v75 = v72 >> 1;
          v76 = &v73[2 * (v72 >> 1)];
          v78 = *v76;
          v77 = v76 + 2;
          v72 += ~(v72 >> 1);
          if (v78 < v71)
            v73 = v77;
          else
            v72 = v75;
        }
        while (v72);
        a3 = v69;
        if (v73 == v74)
        {
          v79 = 0;
          v20 = a9;
        }
        else
        {
          v20 = a9;
          if (*v73 == v71)
            v79 = v73[1];
          else
            v79 = 0;
        }
      }
      else
      {
        v79 = 0;
        a3 = v69;
        v20 = a9;
      }
      v48 = (mlir::OpBuilder *)(a2 + 8);
    }
    else
    {
      v79 = 0;
    }
    IndexFromDim = v68;
    v110 = v79;
    LOBYTE(v113) = 0;
    v114 = 0;
    v80 = (void *)mlir::ShapedType::cloneWith((uint64_t *)&IndexFromDim, &v113, OperandRange);
    v82 = v81;
    *(_QWORD *)&v113 = mlir::rewriteElementsAttr(*a8, a8[1], (uint64_t)v80, v82, 0);
    *((_QWORD *)&v113 + 1) = v83;
    v98 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>(v48, a4, (uint64_t *)&IndexFromDim, (_QWORD **)&v113)- 16;
    *(_QWORD *)&v113 = v47;
  }
  else
  {
    v54 = 0;
    *(_QWORD *)&v113 = 0;
  }
  IndexFromDim = v54;
  v84 = (char *)mlir::OpBuilder::create<mlir::anec::Linear,mlir::Value &,mlir::Value &,mlir::DenseFPElementsAttr,mlir::DenseIntElementsAttr>((mlir::UnknownLoc **)(a2 + 8), a4, (uint64_t *)&v99, &v98, (uint64_t *)&v113, (uint64_t *)&IndexFromDim)- 16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v100);
  if (v85 >= 4)
  {
    v111 = v84;
    *(_QWORD *)&v113 = mlir::getRankPromotionTypeForANE(v100, v101);
    *((_QWORD *)&v113 + 1) = v86;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v113);
    v88 = v87;
    IndexFromDim = (_QWORD *)mlir::anec::getIndexFromDim(1, v87);
    v110 = v89;
    v107 = mlir::anec::getIndexFromDim(3, v88);
    v108 = v90;
    v84 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
  }
  if (v20)
  {
    v111 = v84;
    *(_QWORD *)&v113 = mlir::getRankPromotionTypeForANE(v100, v101);
    *((_QWORD *)&v113 + 1) = v91;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v113);
    v93 = v92;
    IndexFromDim = (_QWORD *)mlir::anec::getIndexFromDim(1, v92);
    v110 = v94;
    v107 = mlir::anec::getIndexFromDim(4, v93);
    v108 = v95;
    v84 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a2 + 8), a4, (uint64_t *)&v111, (uint64_t *)&IndexFromDim, (uint64_t *)&v107)- 16;
  }
  v96 = v106;
  *(_QWORD *)&v113 = v84;
  mlir::ValueRange::ValueRange(v112, (uint64_t)&v113, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a2, v96, v112[0], v112[1]);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.matmul", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.matmul";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::MatMul::build(a1, (uint64_t)v19, *a3, *a4, 0);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::MatMul,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>> &,mlir::detail::RecursivePatternMatcher<mlir::mps::DequantizeOp,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>,mlir::detail::constant_op_binder<mlir::ElementsAttr>> & &)#1},0ul,1ul,2ul,3ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t DefiningOp;
  char v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  char v9;
  uint64_t result;
  char v11;
  uint64_t v12;

  v12 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v12);
  if (DefiningOp)
    LOBYTE(DefiningOp) = mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(a1, DefiningOp);
  if (**(_BYTE **)a2)
    v5 = DefiningOp;
  else
    v5 = 0;
  **(_BYTE **)a2 = v5;
  v12 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 56);
  v6 = mlir::Value::getDefiningOp((mlir::Value *)&v12);
  if (v6)
    LOBYTE(v6) = mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(a1 + 1, v6);
  if (**(_BYTE **)a2)
    v7 = v6;
  else
    v7 = 0;
  **(_BYTE **)a2 = v7;
  v12 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 88);
  v8 = mlir::Value::getDefiningOp((mlir::Value *)&v12);
  if (v8)
    LOBYTE(v8) = mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(a1 + 2, v8);
  if (**(_BYTE **)a2)
    v9 = v8;
  else
    v9 = 0;
  **(_BYTE **)a2 = v9;
  v12 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 120);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v12);
  if (result)
    result = mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(a1 + 3, result);
  if (**(_BYTE **)a2)
    v11 = result;
  else
    v11 = 0;
  **(_BYTE **)a2 = v11;
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Linear,mlir::Value &,mlir::Value &,mlir::DenseFPElementsAttr,mlir::DenseIntElementsAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.linear", (const unsigned __int8 *)0xB, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.linear";
    v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::Linear::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Linear,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.transpose", (const unsigned __int8 *)0xE, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"anec.transpose";
    v19[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::Transpose::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Transpose,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

_QWORD *mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)1>::~ConvertMatMul(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)1>::~ConvertMatMul(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t *v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  char *Input;
  int matched;
  char *Filter;
  _BOOL4 TransposeRhs;
  unsigned __int8 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int *v79;
  unsigned int *v80;
  uint64_t v82;
  uint64_t v84;
  _OWORD v85[4];
  _OWORD v86[4];
  char *v87;
  char *v88;
  _QWORD *v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t IndexFromDim;
  uint64_t v99;
  char *v100;
  unint64_t v101[2];
  pthread_rwlock_t *v102[67];
  __int128 v103;
  uint64_t ArgOperands;
  uint64_t v105;
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  v95 = a2;
  v103 = *(_OWORD *)(a3 + 56);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v93 = v5;
  v94 = v15;
  v82 = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  v84 = (uint64_t)v5;
  v91 = v16;
  v92 = v26;
  v27 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27)
    goto LABEL_30;
  v28 = *v27;
  v29 = mlir::TypeID::get<mlir::ShapedType>();
  v30 = *(unsigned int *)(v28 + 16);
  if (!(_DWORD)v30)
    goto LABEL_30;
  v31 = *(_QWORD **)(v28 + 8);
  v32 = &v31[2 * v30];
  do
  {
    v33 = v30 >> 1;
    v34 = &v31[2 * (v30 >> 1)];
    v36 = *v34;
    v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29)
      v31 = v35;
    else
      v30 = v33;
  }
  while (v30);
  if (v31 != v32 && *v31 == v29)
    v37 = v31[1];
  else
LABEL_30:
    v37 = 0;
  v89 = v27;
  v90 = v37;
  v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  v88 = v38;
  v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  v87 = v39;
  v40 = *(_QWORD *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (char *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95);
  Filter = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched)
      goto LABEL_42;
    v45 = 0;
LABEL_37:
    ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    v105 = v46;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2)
        goto LABEL_42;
LABEL_53:
      v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    v99 = v48;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
    if (v49 != 2)
      goto LABEL_42;
    v45 = 1;
    goto LABEL_53;
  }
  TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  v45 = TransposeRhs;
  if ((matched & 1) != 0)
    goto LABEL_37;
  if (TransposeRhs)
    goto LABEL_39;
LABEL_42:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v93);
  if (v50 >= 4)
  {
    v100 = v38;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    v105 = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v53 = v52;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    v99 = v54;
    v96 = mlir::anec::getIndexFromDim(3, v53);
    v97 = v55;
    v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    v88 = v38;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v91);
  if (v56 >= 4)
  {
    v100 = v39;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    v105 = v57;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v59 = v58;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    v99 = v60;
    v96 = mlir::anec::getIndexFromDim(3, v59);
    v97 = v61;
    v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    v100 = v38;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    v105 = v62;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v64 = v63;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    v99 = v65;
    v96 = mlir::anec::getIndexFromDim(4, v64);
    v97 = v66;
    v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    v100 = v39;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    v105 = v67;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v69 = v68;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    v99 = v70;
    v96 = mlir::anec::getIndexFromDim(4, v69);
    v97 = v71;
    v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  ArgOperands = 0;
  v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v89);
  if (v73 >= 4)
  {
    v100 = v72;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    v105 = v74;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v76 = v75;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    v99 = v77;
    v96 = mlir::anec::getIndexFromDim(3, v76);
    v97 = v78;
    v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  v79 = (unsigned int *)v95;
  ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)2>::~ConvertMatMul(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)2>::~ConvertMatMul(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t *v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  char *Input;
  int matched;
  char *Filter;
  _BOOL4 TransposeRhs;
  unsigned __int8 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int *v79;
  unsigned int *v80;
  uint64_t v82;
  uint64_t v84;
  _OWORD v85[4];
  _OWORD v86[4];
  char *v87;
  char *v88;
  _QWORD *v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t IndexFromDim;
  uint64_t v99;
  char *v100;
  unint64_t v101[2];
  pthread_rwlock_t *v102[67];
  __int128 v103;
  uint64_t ArgOperands;
  uint64_t v105;
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  v95 = a2;
  v103 = *(_OWORD *)(a3 + 56);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v93 = v5;
  v94 = v15;
  v82 = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  v84 = (uint64_t)v5;
  v91 = v16;
  v92 = v26;
  v27 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27)
    goto LABEL_30;
  v28 = *v27;
  v29 = mlir::TypeID::get<mlir::ShapedType>();
  v30 = *(unsigned int *)(v28 + 16);
  if (!(_DWORD)v30)
    goto LABEL_30;
  v31 = *(_QWORD **)(v28 + 8);
  v32 = &v31[2 * v30];
  do
  {
    v33 = v30 >> 1;
    v34 = &v31[2 * (v30 >> 1)];
    v36 = *v34;
    v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29)
      v31 = v35;
    else
      v30 = v33;
  }
  while (v30);
  if (v31 != v32 && *v31 == v29)
    v37 = v31[1];
  else
LABEL_30:
    v37 = 0;
  v89 = v27;
  v90 = v37;
  v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  v88 = v38;
  v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  v87 = v39;
  v40 = *(_QWORD *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (char *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95);
  Filter = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched)
      goto LABEL_42;
    v45 = 0;
LABEL_37:
    ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    v105 = v46;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2)
        goto LABEL_42;
LABEL_53:
      v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    v99 = v48;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
    if (v49 != 2)
      goto LABEL_42;
    v45 = 1;
    goto LABEL_53;
  }
  TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  v45 = TransposeRhs;
  if ((matched & 1) != 0)
    goto LABEL_37;
  if (TransposeRhs)
    goto LABEL_39;
LABEL_42:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v93);
  if (v50 >= 4)
  {
    v100 = v38;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    v105 = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v53 = v52;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    v99 = v54;
    v96 = mlir::anec::getIndexFromDim(3, v53);
    v97 = v55;
    v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    v88 = v38;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v91);
  if (v56 >= 4)
  {
    v100 = v39;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    v105 = v57;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v59 = v58;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    v99 = v60;
    v96 = mlir::anec::getIndexFromDim(3, v59);
    v97 = v61;
    v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    v100 = v38;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    v105 = v62;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v64 = v63;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    v99 = v65;
    v96 = mlir::anec::getIndexFromDim(4, v64);
    v97 = v66;
    v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    v100 = v39;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    v105 = v67;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v69 = v68;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    v99 = v70;
    v96 = mlir::anec::getIndexFromDim(4, v69);
    v97 = v71;
    v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  ArgOperands = 0;
  v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v89);
  if (v73 >= 4)
  {
    v100 = v72;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    v105 = v74;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v76 = v75;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    v99 = v77;
    v96 = mlir::anec::getIndexFromDim(3, v76);
    v97 = v78;
    v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  v79 = (unsigned int *)v95;
  ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)3>::~ConvertMatMul(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)3>::~ConvertMatMul(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t *v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  char *Input;
  int matched;
  char *Filter;
  _BOOL4 TransposeRhs;
  unsigned __int8 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int *v79;
  unsigned int *v80;
  uint64_t v82;
  uint64_t v84;
  _OWORD v85[4];
  _OWORD v86[4];
  char *v87;
  char *v88;
  _QWORD *v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t IndexFromDim;
  uint64_t v99;
  char *v100;
  unint64_t v101[2];
  pthread_rwlock_t *v102[67];
  __int128 v103;
  uint64_t ArgOperands;
  uint64_t v105;
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  v95 = a2;
  v103 = *(_OWORD *)(a3 + 56);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v93 = v5;
  v94 = v15;
  v82 = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  v84 = (uint64_t)v5;
  v91 = v16;
  v92 = v26;
  v27 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27)
    goto LABEL_30;
  v28 = *v27;
  v29 = mlir::TypeID::get<mlir::ShapedType>();
  v30 = *(unsigned int *)(v28 + 16);
  if (!(_DWORD)v30)
    goto LABEL_30;
  v31 = *(_QWORD **)(v28 + 8);
  v32 = &v31[2 * v30];
  do
  {
    v33 = v30 >> 1;
    v34 = &v31[2 * (v30 >> 1)];
    v36 = *v34;
    v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29)
      v31 = v35;
    else
      v30 = v33;
  }
  while (v30);
  if (v31 != v32 && *v31 == v29)
    v37 = v31[1];
  else
LABEL_30:
    v37 = 0;
  v89 = v27;
  v90 = v37;
  v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  v88 = v38;
  v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  v87 = v39;
  v40 = *(_QWORD *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (char *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95);
  Filter = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched)
      goto LABEL_42;
    v45 = 0;
LABEL_37:
    ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    v105 = v46;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2)
        goto LABEL_42;
LABEL_53:
      v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    v99 = v48;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
    if (v49 != 2)
      goto LABEL_42;
    v45 = 1;
    goto LABEL_53;
  }
  TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  v45 = TransposeRhs;
  if ((matched & 1) != 0)
    goto LABEL_37;
  if (TransposeRhs)
    goto LABEL_39;
LABEL_42:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v93);
  if (v50 >= 4)
  {
    v100 = v38;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    v105 = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v53 = v52;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    v99 = v54;
    v96 = mlir::anec::getIndexFromDim(3, v53);
    v97 = v55;
    v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    v88 = v38;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v91);
  if (v56 >= 4)
  {
    v100 = v39;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    v105 = v57;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v59 = v58;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    v99 = v60;
    v96 = mlir::anec::getIndexFromDim(3, v59);
    v97 = v61;
    v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    v100 = v38;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    v105 = v62;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v64 = v63;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    v99 = v65;
    v96 = mlir::anec::getIndexFromDim(4, v64);
    v97 = v66;
    v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    v100 = v39;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    v105 = v67;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v69 = v68;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    v99 = v70;
    v96 = mlir::anec::getIndexFromDim(4, v69);
    v97 = v71;
    v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  ArgOperands = 0;
  v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v89);
  if (v73 >= 4)
  {
    v100 = v72;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    v105 = v74;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v76 = v75;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    v99 = v77;
    v96 = mlir::anec::getIndexFromDim(3, v76);
    v97 = v78;
    v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  v79 = (unsigned int *)v95;
  ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)4>::~ConvertMatMul(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)4>::~ConvertMatMul(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t *v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  char *Input;
  int matched;
  char *Filter;
  _BOOL4 TransposeRhs;
  unsigned __int8 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int *v79;
  unsigned int *v80;
  uint64_t v82;
  uint64_t v84;
  _OWORD v85[4];
  _OWORD v86[4];
  char *v87;
  char *v88;
  _QWORD *v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t IndexFromDim;
  uint64_t v99;
  char *v100;
  unint64_t v101[2];
  pthread_rwlock_t *v102[67];
  __int128 v103;
  uint64_t ArgOperands;
  uint64_t v105;
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  v95 = a2;
  v103 = *(_OWORD *)(a3 + 56);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v93 = v5;
  v94 = v15;
  v82 = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  v84 = (uint64_t)v5;
  v91 = v16;
  v92 = v26;
  v27 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27)
    goto LABEL_30;
  v28 = *v27;
  v29 = mlir::TypeID::get<mlir::ShapedType>();
  v30 = *(unsigned int *)(v28 + 16);
  if (!(_DWORD)v30)
    goto LABEL_30;
  v31 = *(_QWORD **)(v28 + 8);
  v32 = &v31[2 * v30];
  do
  {
    v33 = v30 >> 1;
    v34 = &v31[2 * (v30 >> 1)];
    v36 = *v34;
    v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29)
      v31 = v35;
    else
      v30 = v33;
  }
  while (v30);
  if (v31 != v32 && *v31 == v29)
    v37 = v31[1];
  else
LABEL_30:
    v37 = 0;
  v89 = v27;
  v90 = v37;
  v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  v88 = v38;
  v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  v87 = v39;
  v40 = *(_QWORD *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (char *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95);
  Filter = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched)
      goto LABEL_42;
    v45 = 0;
LABEL_37:
    ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    v105 = v46;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2)
        goto LABEL_42;
LABEL_53:
      v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    v99 = v48;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
    if (v49 != 2)
      goto LABEL_42;
    v45 = 1;
    goto LABEL_53;
  }
  TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  v45 = TransposeRhs;
  if ((matched & 1) != 0)
    goto LABEL_37;
  if (TransposeRhs)
    goto LABEL_39;
LABEL_42:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v93);
  if (v50 >= 4)
  {
    v100 = v38;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    v105 = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v53 = v52;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    v99 = v54;
    v96 = mlir::anec::getIndexFromDim(3, v53);
    v97 = v55;
    v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    v88 = v38;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v91);
  if (v56 >= 4)
  {
    v100 = v39;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    v105 = v57;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v59 = v58;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    v99 = v60;
    v96 = mlir::anec::getIndexFromDim(3, v59);
    v97 = v61;
    v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    v100 = v38;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    v105 = v62;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v64 = v63;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    v99 = v65;
    v96 = mlir::anec::getIndexFromDim(4, v64);
    v97 = v66;
    v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    v100 = v39;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    v105 = v67;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v69 = v68;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    v99 = v70;
    v96 = mlir::anec::getIndexFromDim(4, v69);
    v97 = v71;
    v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  ArgOperands = 0;
  v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v89);
  if (v73 >= 4)
  {
    v100 = v72;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    v105 = v74;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v76 = v75;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    v99 = v77;
    v96 = mlir::anec::getIndexFromDim(3, v76);
    v97 = v78;
    v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  v79 = (unsigned int *)v95;
  ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)5>::~ConvertMatMul(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)5>::~ConvertMatMul(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t *v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  char *Input;
  int matched;
  char *Filter;
  _BOOL4 TransposeRhs;
  unsigned __int8 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int *v79;
  unsigned int *v80;
  uint64_t v82;
  uint64_t v84;
  _OWORD v85[4];
  _OWORD v86[4];
  char *v87;
  char *v88;
  _QWORD *v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t IndexFromDim;
  uint64_t v99;
  char *v100;
  unint64_t v101[2];
  pthread_rwlock_t *v102[67];
  __int128 v103;
  uint64_t ArgOperands;
  uint64_t v105;
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  v95 = a2;
  v103 = *(_OWORD *)(a3 + 56);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v93 = v5;
  v94 = v15;
  v82 = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  v84 = (uint64_t)v5;
  v91 = v16;
  v92 = v26;
  v27 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27)
    goto LABEL_30;
  v28 = *v27;
  v29 = mlir::TypeID::get<mlir::ShapedType>();
  v30 = *(unsigned int *)(v28 + 16);
  if (!(_DWORD)v30)
    goto LABEL_30;
  v31 = *(_QWORD **)(v28 + 8);
  v32 = &v31[2 * v30];
  do
  {
    v33 = v30 >> 1;
    v34 = &v31[2 * (v30 >> 1)];
    v36 = *v34;
    v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29)
      v31 = v35;
    else
      v30 = v33;
  }
  while (v30);
  if (v31 != v32 && *v31 == v29)
    v37 = v31[1];
  else
LABEL_30:
    v37 = 0;
  v89 = v27;
  v90 = v37;
  v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  v88 = v38;
  v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  v87 = v39;
  v40 = *(_QWORD *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (char *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95);
  Filter = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched)
      goto LABEL_42;
    v45 = 0;
LABEL_37:
    ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    v105 = v46;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2)
        goto LABEL_42;
LABEL_53:
      v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    v99 = v48;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
    if (v49 != 2)
      goto LABEL_42;
    v45 = 1;
    goto LABEL_53;
  }
  TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  v45 = TransposeRhs;
  if ((matched & 1) != 0)
    goto LABEL_37;
  if (TransposeRhs)
    goto LABEL_39;
LABEL_42:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v93);
  if (v50 >= 4)
  {
    v100 = v38;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    v105 = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v53 = v52;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    v99 = v54;
    v96 = mlir::anec::getIndexFromDim(3, v53);
    v97 = v55;
    v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    v88 = v38;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v91);
  if (v56 >= 4)
  {
    v100 = v39;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    v105 = v57;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v59 = v58;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    v99 = v60;
    v96 = mlir::anec::getIndexFromDim(3, v59);
    v97 = v61;
    v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    v100 = v38;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    v105 = v62;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v64 = v63;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    v99 = v65;
    v96 = mlir::anec::getIndexFromDim(4, v64);
    v97 = v66;
    v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    v100 = v39;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    v105 = v67;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v69 = v68;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    v99 = v70;
    v96 = mlir::anec::getIndexFromDim(4, v69);
    v97 = v71;
    v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  ArgOperands = 0;
  v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v89);
  if (v73 >= 4)
  {
    v100 = v72;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    v105 = v74;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v76 = v75;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    v99 = v77;
    v96 = mlir::anec::getIndexFromDim(3, v76);
    v97 = v78;
    v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  v79 = (unsigned int *)v95;
  ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)6>::~ConvertMatMul(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)6>::~ConvertMatMul(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertMatMul<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t *v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  char *Input;
  int matched;
  char *Filter;
  _BOOL4 TransposeRhs;
  unsigned __int8 v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int *v79;
  unsigned int *v80;
  uint64_t v82;
  uint64_t v84;
  _OWORD v85[4];
  _OWORD v86[4];
  char *v87;
  char *v88;
  _QWORD *v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t IndexFromDim;
  uint64_t v99;
  char *v100;
  unint64_t v101[2];
  pthread_rwlock_t *v102[67];
  __int128 v103;
  uint64_t ArgOperands;
  uint64_t v105;
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  v95 = a2;
  v103 = *(_OWORD *)(a3 + 56);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v93 = v5;
  v94 = v15;
  v82 = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  v84 = (uint64_t)v5;
  v91 = v16;
  v92 = v26;
  v27 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27)
    goto LABEL_30;
  v28 = *v27;
  v29 = mlir::TypeID::get<mlir::ShapedType>();
  v30 = *(unsigned int *)(v28 + 16);
  if (!(_DWORD)v30)
    goto LABEL_30;
  v31 = *(_QWORD **)(v28 + 8);
  v32 = &v31[2 * v30];
  do
  {
    v33 = v30 >> 1;
    v34 = &v31[2 * (v30 >> 1)];
    v36 = *v34;
    v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29)
      v31 = v35;
    else
      v30 = v33;
  }
  while (v30);
  if (v31 != v32 && *v31 == v29)
    v37 = v31[1];
  else
LABEL_30:
    v37 = 0;
  v89 = v27;
  v90 = v37;
  v38 = (char *)mlir::ValueRange::dereference_iterator(&v103, 0);
  v88 = v38;
  v39 = (char *)mlir::ValueRange::dereference_iterator(&v103, 1);
  v87 = v39;
  v40 = *(_QWORD *)(v95 + 24);
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  Input = (char *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95);
  Filter = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  {
    if (!matched)
      goto LABEL_42;
    v45 = 0;
LABEL_37:
    ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v86);
    v105 = v46;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    if (v47 == 2 || (v45 & 1) == 0)
    {
      if (v47 != 2)
        goto LABEL_42;
LABEL_53:
      v80 = (unsigned int *)v95;
      mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v102, *(const mlir::TypeConverter **)(a1 + 96));
      mlir::TypeConverter::~TypeConverter(v102);
    }
LABEL_39:
    IndexFromDim = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85);
    v99 = v48;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
    if (v49 != 2)
      goto LABEL_42;
    v45 = 1;
    goto LABEL_53;
  }
  TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95);
  v45 = TransposeRhs;
  if ((matched & 1) != 0)
    goto LABEL_37;
  if (TransposeRhs)
    goto LABEL_39;
LABEL_42:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v93);
  if (v50 >= 4)
  {
    v100 = v38;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    v105 = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v53 = v52;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v52);
    v99 = v54;
    v96 = mlir::anec::getIndexFromDim(3, v53);
    v97 = v55;
    v38 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    v88 = v38;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v91);
  if (v56 >= 4)
  {
    v100 = v39;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    v105 = v57;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v59 = v58;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
    v99 = v60;
    v96 = mlir::anec::getIndexFromDim(3, v59);
    v97 = v61;
    v39 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
    v87 = v39;
  }
  if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v95))
  {
    v100 = v38;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v93, v94);
    v105 = v62;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v64 = v63;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v63);
    v99 = v65;
    v96 = mlir::anec::getIndexFromDim(4, v64);
    v97 = v66;
    v88 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  if (mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v95))
  {
    v100 = v39;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v91, v92);
    v105 = v67;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v69 = v68;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v68);
    v99 = v70;
    v96 = mlir::anec::getIndexFromDim(4, v69);
    v97 = v71;
    v87 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  ArgOperands = 0;
  v72 = (char *)mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::Value &,decltype(nullptr)>((mlir::UnknownLoc **)(a4 + 8), v40, (uint64_t *)&v88, (uint64_t *)&v87)- 16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v89);
  if (v73 >= 4)
  {
    v100 = v72;
    ArgOperands = mlir::getRankPromotionTypeForANE((uint64_t)v89, v90);
    v105 = v74;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
    v76 = v75;
    IndexFromDim = mlir::anec::getIndexFromDim(1, v75);
    v99 = v77;
    v96 = mlir::anec::getIndexFromDim(3, v76);
    v97 = v78;
    v72 = (char *)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), v40, (uint64_t *)&v100, (uint64_t *)&IndexFromDim, (uint64_t *)&v96)- 16;
  }
  v79 = (unsigned int *)v95;
  ArgOperands = (uint64_t)v72;
  mlir::ValueRange::ValueRange(v101, (uint64_t)&ArgOperands, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v79, v101[0], v101[1]);
  return 1;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DegammaOp,mlir::anec::Degamma>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E2A1D0;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_18076A31C()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::DegammaOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DegammaOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::DegammaOpGenericAdaptorBase::DegammaOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DegammaOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::DegammaOpGenericAdaptorBase::DegammaOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::DegammaOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DegammaOp &>(mlir::mps::DegammaOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DegammaOp &>(mlir::mps::DegammaOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DegammaOp,mlir::anec::Degamma>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::Degamma,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DegammaOp &>(mlir::mps::DegammaOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DegammaOp,mlir::anec::Degamma>::matchAndRewriteWithStaticShapes(mlir::mps::DegammaOp,mlir::mps::DegammaOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Degamma,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.degamma", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.degamma";
    v21[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Degamma,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DiracOp,mlir::anec::Dirac>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E29E50;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_18076AF14()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::DiracOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DiracOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::DiracOpGenericAdaptorBase::DiracOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DiracOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::DiracOpGenericAdaptorBase::DiracOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::DiracOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DiracOp &>(mlir::mps::DiracOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DiracOp &>(mlir::mps::DiracOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DiracOp,mlir::anec::Dirac>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::Dirac,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DiracOp &>(mlir::mps::DiracOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::DiracOp,mlir::anec::Dirac>::matchAndRewriteWithStaticShapes(mlir::mps::DiracOp,mlir::mps::DiracOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Dirac,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.dirac", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.dirac";
    v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Dirac,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::GeluOp,mlir::anec::Gelu>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E29C20;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_18076BB0C()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::GeluOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GeluOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::GeluOpGenericAdaptorBase::GeluOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GeluOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::GeluOpGenericAdaptorBase::GeluOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::GeluOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GeluOp &>(mlir::mps::GeluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GeluOp &>(mlir::mps::GeluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::GeluOp,mlir::anec::Gelu>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::Gelu,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GeluOp &>(mlir::mps::GeluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::GeluOp,mlir::anec::Gelu>::matchAndRewriteWithStaticShapes(mlir::mps::GeluOp,mlir::mps::GeluOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Gelu,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gelu", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.gelu";
    v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Gelu,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ReluOp,mlir::anec::Relu>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E29C90;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_18076C704()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReluOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReluOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ReluOpGenericAdaptorBase::ReluOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReluOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ReluOpGenericAdaptorBase::ReluOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReluOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReluOp &>(mlir::mps::ReluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReluOp &>(mlir::mps::ReluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ReluOp,mlir::anec::Relu>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::Relu,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReluOp &>(mlir::mps::ReluOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ReluOp,mlir::anec::Relu>::matchAndRewriteWithStaticShapes(mlir::mps::ReluOp,mlir::mps::ReluOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Relu,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.relu", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.relu";
    v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Relu,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::RoundOp,mlir::anec::RoundNearest>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E2A080;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_18076D2FC()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::RoundOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::RoundOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::RoundOpGenericAdaptorBase::RoundOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::RoundOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::RoundOpGenericAdaptorBase::RoundOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::RoundOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::RoundOp &>(mlir::mps::RoundOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::RoundOp &>(mlir::mps::RoundOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::RoundOp,mlir::anec::RoundNearest>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::RoundNearest,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::RoundOp &>(mlir::mps::RoundOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::RoundOp,mlir::anec::RoundNearest>::matchAndRewriteWithStaticShapes(mlir::mps::RoundOp,mlir::mps::RoundOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::RoundNearest,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.round_nearest", (const unsigned __int8 *)0x12, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.round_nearest";
    v21[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::RoundNearest,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SigmoidOp,mlir::anec::HighPrecisionSigmoid>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E2A240;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_18076DEF4()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SigmoidOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SigmoidOp &>(mlir::mps::SigmoidOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SigmoidOp &>(mlir::mps::SigmoidOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SigmoidOp,mlir::anec::HighPrecisionSigmoid>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::HighPrecisionSigmoid,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SigmoidOp &>(mlir::mps::SigmoidOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SigmoidOp,mlir::anec::HighPrecisionSigmoid>::matchAndRewriteWithStaticShapes(mlir::mps::SigmoidOp,mlir::mps::SigmoidOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::HighPrecisionSigmoid,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.high_precision_sigmoid", (const unsigned __int8 *)0x1B, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.high_precision_sigmoid";
    v21[3] = 27;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::HighPrecisionSigmoid,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareOp,mlir::anec::ElementwiseSquare>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E2A160;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_18076E990()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SquareOpGenericAdaptorBase::SquareOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SquareOpGenericAdaptorBase::SquareOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SquareOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareOp &>(mlir::mps::SquareOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareOp &>(mlir::mps::SquareOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareOp,mlir::anec::ElementwiseSquare>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::ElementwiseSquare,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareOp &>(mlir::mps::SquareOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareOp,mlir::anec::ElementwiseSquare>::matchAndRewriteWithStaticShapes(mlir::mps::SquareOp,mlir::mps::SquareOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseSquare,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.square", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.square";
    v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseSquare,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareRootOp,mlir::anec::Sqrt>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E29830;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_18076F588()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareRootOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareRootOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SquareRootOpGenericAdaptorBase::SquareRootOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SquareRootOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SquareRootOpGenericAdaptorBase::SquareRootOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SquareRootOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareRootOp &>(mlir::mps::SquareRootOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareRootOp &>(mlir::mps::SquareRootOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareRootOp,mlir::anec::Sqrt>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::Sqrt,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SquareRootOp &>(mlir::mps::SquareRootOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SquareRootOp,mlir::anec::Sqrt>::matchAndRewriteWithStaticShapes(mlir::mps::SquareRootOp,mlir::mps::SquareRootOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Sqrt,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.sqrt", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.sqrt";
    v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Sqrt,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SwishOp,mlir::anec::Swish>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E2A0F0;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_180770180()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::SwishOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SwishOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SwishOpGenericAdaptorBase::SwishOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SwishOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SwishOpGenericAdaptorBase::SwishOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SwishOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SwishOp &>(mlir::mps::SwishOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SwishOp &>(mlir::mps::SwishOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SwishOp,mlir::anec::Swish>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::Swish,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SwishOp &>(mlir::mps::SwishOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SwishOp,mlir::anec::Swish>::matchAndRewriteWithStaticShapes(mlir::mps::SwishOp,mlir::mps::SwishOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Swish,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.swish", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.swish";
    v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Swish,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TanhOp,mlir::anec::Tanh>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E29D70;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_180770D78()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::TanhOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::TanhOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::TanhOpGenericAdaptorBase::TanhOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::TanhOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::TanhOpGenericAdaptorBase::TanhOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::TanhOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TanhOp &>(mlir::mps::TanhOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TanhOp &>(mlir::mps::TanhOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TanhOp,mlir::anec::Tanh>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::Tanh,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TanhOp &>(mlir::mps::TanhOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TanhOp,mlir::anec::Tanh>::matchAndRewriteWithStaticShapes(mlir::mps::TanhOp,mlir::mps::TanhOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Tanh,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.tanh", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.tanh";
    v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Tanh,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

_QWORD *mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqual>::~ConvertBinaryCompare(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqual>::~ConvertBinaryCompare(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::EqualToOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::EqualToOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::EqualToOpGenericAdaptorBase::EqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::EqualToOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::EqualToOpGenericAdaptorBase::EqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::EqualToOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::EqualToOp &>(mlir::mps::EqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::EqualToOp &>(mlir::mps::EqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqual>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  void *v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _BYTE *v14;
  mlir::Operation *DefiningOp;
  int v16;
  unsigned int v17;
  void **v18;
  _BOOL4 v19;
  uint64_t v20;
  uint64_t v21;
  mlir::GenericProgramPoint *v22;
  uint64_t v24;
  void **v25;
  void *v26;
  uint64_t v27;
  _BYTE v28[48];
  void *v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v7 = *(void **)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v26 = v28;
  v27 = 0x600000000;
  if (v6 < 7)
  {
    v29 = v7;
    v30 = 0;
    if (!v6)
    {
      v13 = 0;
      v14 = v28;
      goto LABEL_12;
    }
    v8 = 0;
    v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    v8 = v27;
    v9 = v26;
    v29 = v7;
    v30 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  v13 = v27;
  v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  v24 = *((_QWORD *)v14 + 1);
  DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
    goto LABEL_32;
  LODWORD(v30) = 1;
  v29 = 0;
  v25 = &v29;
  v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29)
          operator delete[](v29);
        goto LABEL_32;
      }
      v18 = (void **)v29;
    }
    else
    {
      v18 = &v29;
    }
    v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        operator delete[](v29);
        if (!v19)
          goto LABEL_32;
LABEL_26:
        v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20))
        else
          v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    v19 = 0;
    if (v30 >= 0x41)
      goto LABEL_22;
  }
  if (v19)
    goto LABEL_26;
LABEL_32:
  v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseEqual,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v22);
  v21 = 1;
LABEL_33:
  if (v26 != v28)
    free(v26);
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::EqualToOp &>(mlir::mps::EqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::detail::constant_int_op_binder_any_splat::match(mlir::detail::constant_int_op_binder_any_splat *this, mlir::Operation *a2)
{
  uint64_t v4;
  unint64_t v5;
  void *v6;
  uint64_t v8;
  void *v9;
  BOOL v10;
  _BOOL8 v11;
  unint64_t v12;
  mlir::detail::constant_int_op_binder_any_splat *v15;
  uint64_t v16;
  uint64_t NumElements;
  uint64_t v18;
  void *v19;
  BOOL v20;
  uint64_t v21;
  mlir::detail::constant_int_op_binder_any_splat *v22;
  _QWORD v23[2];
  void *v24[2];
  _QWORD v25[2];

  v25[1] = *MEMORY[0x1E0C80C00];
  v4 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 6) + 32))(*((_QWORD *)a2 + 6), v4))
    return 0;
  v24[0] = v25;
  v24[1] = (void *)0x100000000;
  mlir::Operation::fold((uint64_t)a2, 0, 0, (uint64_t)v24);
  v5 = *(_QWORD *)v24[0] & 0xFFFFFFFFFFFFFFF8;
  if (v24[0] != v25)
    free(v24[0]);
  if (!v5)
    return 0;
  v6 = *(void **)(*(_QWORD *)(*((_QWORD *)a2 - 1) & 0xFFFFFFFFFFFFFFF8) + 136);
  if (v6 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    || v6 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
  {
    v8 = *(_QWORD *)this;
    v9 = *(void **)(*(_QWORD *)v5 + 136);
    v10 = v9 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id;
    v11 = v9 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id;
    if (v9 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      v12 = v5;
    else
      v12 = 0;
    v23[0] = v12;
    if (v10)
    {
      mlir::IntegerAttr::getValue(v23, (llvm::APInt *)v24);
      if (*(_DWORD *)(v8 + 8) >= 0x41u && *(_QWORD *)v8)
        operator delete[](*(void **)v8);
      *(void **)v8 = v24[0];
      *(_DWORD *)(v8 + 8) = v24[1];
    }
  }
  else
  {
    if (mlir::DenseElementsAttr::classof(v5))
      v15 = (mlir::detail::constant_int_op_binder_any_splat *)v5;
    else
      v15 = 0;
    v24[0] = v15;
    if (v15)
    {
      v15 = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)v24)
          ? (mlir::detail::constant_int_op_binder_any_splat *)v5
          : 0;
      v22 = v15;
      if (v15)
      {
        v16 = *(_QWORD *)this;
        mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v22);
        mlir::NamedAttribute::NamedAttribute(v24, (uint64_t)v22, 0);
        this = v22;
        NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v22);
        mlir::NamedAttribute::NamedAttribute(v23, (uint64_t)this, NumElements);
        v18 = mlir::DenseElementsAttr::AttributeElementIterator::operator*(v24);
        v19 = *(void **)(*(_QWORD *)v18 + 136);
        v20 = v19 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id;
        LODWORD(this) = v19 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id;
        if (v19 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
          v21 = v18;
        else
          v21 = 0;
        v23[0] = v21;
        if (v20)
        {
          mlir::IntegerAttr::getValue(v23, (llvm::APInt *)v24);
          if (*(_DWORD *)(v16 + 8) >= 0x41u && *(_QWORD *)v16)
            operator delete[](*(void **)v16);
          *(void **)v16 = v24[0];
          *(_DWORD *)(v16 + 8) = v24[1];
        }
        LODWORD(v15) = 1;
      }
    }
    return v15 & this;
  }
  return v11;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqual>::matchAndRewriteWithStaticShapes(mlir::mps::EqualToOp,mlir::mps::EqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseEqual,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  unint64_t v17[2];
  _QWORD v18[39];

  v18[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.equal", (const unsigned __int8 *)0xA, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.equal";
    v15[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseEqual,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

_QWORD *mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqualZero>::~ConvertBinaryCompareToZero(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqualZero>::~ConvertBinaryCompareToZero(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqualZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  void *v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _BYTE *v14;
  mlir::Operation *DefiningOp;
  int v16;
  unsigned int v17;
  void **v18;
  BOOL v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  void **v25;
  void *v26;
  uint64_t v27;
  _BYTE v28[48];
  void *v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v7 = *(void **)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v26 = v28;
  v27 = 0x600000000;
  if (v6 < 7)
  {
    v29 = v7;
    v30 = 0;
    if (!v6)
    {
      v13 = 0;
      v14 = v28;
      goto LABEL_12;
    }
    v8 = 0;
    v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    v8 = v27;
    v9 = v26;
    v29 = v7;
    v30 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  v13 = v27;
  v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  v24 = *((_QWORD *)v14 + 1);
  DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22))
    else
      v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  v29 = 0;
  v25 = &v29;
  v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  v17 = v30;
  if (!v16)
  {
    v19 = 0;
    if (v30 < 0x41)
      goto LABEL_24;
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29)
        operator delete[](v29);
      goto LABEL_28;
    }
    v18 = (void **)v29;
  }
  else
  {
    v18 = &v29;
  }
  v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29)
      operator delete[](v29);
  }
LABEL_24:
  if (!v19)
    goto LABEL_28;
  v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseEqualZero,mlir::Value>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
  v21 = 1;
LABEL_32:
  if (v26 != v28)
    free(v26);
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::EqualToOp,mlir::anec::ElementwiseEqualZero>::matchAndRewriteWithStaticShapes(mlir::mps::EqualToOp,mlir::mps::EqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqual>::~ConvertBinaryCompare(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqual>::~ConvertBinaryCompare(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotEqualToOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotEqualToOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::NotEqualToOpGenericAdaptorBase::NotEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotEqualToOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::NotEqualToOpGenericAdaptorBase::NotEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::NotEqualToOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotEqualToOp &>(mlir::mps::NotEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotEqualToOp &>(mlir::mps::NotEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqual>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  void *v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _BYTE *v14;
  mlir::Operation *DefiningOp;
  int v16;
  unsigned int v17;
  void **v18;
  _BOOL4 v19;
  uint64_t v20;
  uint64_t v21;
  mlir::GenericProgramPoint *v22;
  uint64_t v24;
  void **v25;
  void *v26;
  uint64_t v27;
  _BYTE v28[48];
  void *v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v7 = *(void **)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v26 = v28;
  v27 = 0x600000000;
  if (v6 < 7)
  {
    v29 = v7;
    v30 = 0;
    if (!v6)
    {
      v13 = 0;
      v14 = v28;
      goto LABEL_12;
    }
    v8 = 0;
    v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    v8 = v27;
    v9 = v26;
    v29 = v7;
    v30 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  v13 = v27;
  v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  v24 = *((_QWORD *)v14 + 1);
  DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
    goto LABEL_32;
  LODWORD(v30) = 1;
  v29 = 0;
  v25 = &v29;
  v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29)
          operator delete[](v29);
        goto LABEL_32;
      }
      v18 = (void **)v29;
    }
    else
    {
      v18 = &v29;
    }
    v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        operator delete[](v29);
        if (!v19)
          goto LABEL_32;
LABEL_26:
        v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20))
        else
          v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    v19 = 0;
    if (v30 >= 0x41)
      goto LABEL_22;
  }
  if (v19)
    goto LABEL_26;
LABEL_32:
  v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqual,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v22);
  v21 = 1;
LABEL_33:
  if (v26 != v28)
    free(v26);
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotEqualToOp &>(mlir::mps::NotEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqual>::matchAndRewriteWithStaticShapes(mlir::mps::NotEqualToOp,mlir::mps::NotEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqual,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  unint64_t v17[2];
  _QWORD v18[39];

  v18[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.not_equal", (const unsigned __int8 *)0xE, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.not_equal";
    v15[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseNotEqual,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

_QWORD *mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqualZero>::~ConvertBinaryCompareToZero(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqualZero>::~ConvertBinaryCompareToZero(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqualZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  void *v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _BYTE *v14;
  mlir::Operation *DefiningOp;
  int v16;
  unsigned int v17;
  void **v18;
  BOOL v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  void **v25;
  void *v26;
  uint64_t v27;
  _BYTE v28[48];
  void *v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v7 = *(void **)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v26 = v28;
  v27 = 0x600000000;
  if (v6 < 7)
  {
    v29 = v7;
    v30 = 0;
    if (!v6)
    {
      v13 = 0;
      v14 = v28;
      goto LABEL_12;
    }
    v8 = 0;
    v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    v8 = v27;
    v9 = v26;
    v29 = v7;
    v30 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  v13 = v27;
  v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  v24 = *((_QWORD *)v14 + 1);
  DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22))
    else
      v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  v29 = 0;
  v25 = &v29;
  v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  v17 = v30;
  if (!v16)
  {
    v19 = 0;
    if (v30 < 0x41)
      goto LABEL_24;
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29)
        operator delete[](v29);
      goto LABEL_28;
    }
    v18 = (void **)v29;
  }
  else
  {
    v18 = &v29;
  }
  v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29)
      operator delete[](v29);
  }
LABEL_24:
  if (!v19)
    goto LABEL_28;
  v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqualZero,mlir::Value>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
  v21 = 1;
LABEL_32:
  if (v26 != v28)
    free(v26);
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::NotEqualToOp,mlir::anec::ElementwiseNotEqualZero>::matchAndRewriteWithStaticShapes(mlir::mps::NotEqualToOp,mlir::mps::NotEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThan>::~ConvertBinaryCompare(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThan>::~ConvertBinaryCompare(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::GreaterThanOpGenericAdaptorBase::GreaterThanOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::GreaterThanOpGenericAdaptorBase::GreaterThanOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::GreaterThanOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOp &>(mlir::mps::GreaterThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOp &>(mlir::mps::GreaterThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThan>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  void *v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _BYTE *v14;
  mlir::Operation *DefiningOp;
  int v16;
  unsigned int v17;
  void **v18;
  _BOOL4 v19;
  uint64_t v20;
  uint64_t v21;
  mlir::GenericProgramPoint *v22;
  uint64_t v24;
  void **v25;
  void *v26;
  uint64_t v27;
  _BYTE v28[48];
  void *v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v7 = *(void **)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v26 = v28;
  v27 = 0x600000000;
  if (v6 < 7)
  {
    v29 = v7;
    v30 = 0;
    if (!v6)
    {
      v13 = 0;
      v14 = v28;
      goto LABEL_12;
    }
    v8 = 0;
    v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    v8 = v27;
    v9 = v26;
    v29 = v7;
    v30 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  v13 = v27;
  v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  v24 = *((_QWORD *)v14 + 1);
  DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
    goto LABEL_32;
  LODWORD(v30) = 1;
  v29 = 0;
  v25 = &v29;
  v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29)
          operator delete[](v29);
        goto LABEL_32;
      }
      v18 = (void **)v29;
    }
    else
    {
      v18 = &v29;
    }
    v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        operator delete[](v29);
        if (!v19)
          goto LABEL_32;
LABEL_26:
        v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20))
        else
          v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    v19 = 0;
    if (v30 >= 0x41)
      goto LABEL_22;
  }
  if (v19)
    goto LABEL_26;
LABEL_32:
  v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThan,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v22);
  v21 = 1;
LABEL_33:
  if (v26 != v28)
    free(v26);
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOp &>(mlir::mps::GreaterThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThan>::matchAndRewriteWithStaticShapes(mlir::mps::GreaterThanOp,mlir::mps::GreaterThanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThan,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  unint64_t v17[2];
  _QWORD v18[39];

  v18[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.greater_than", (const unsigned __int8 *)0x11, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.greater_than";
    v15[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThan,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

_QWORD *mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThanZero>::~ConvertBinaryCompareToZero(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThanZero>::~ConvertBinaryCompareToZero(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThanZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  void *v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _BYTE *v14;
  mlir::Operation *DefiningOp;
  int v16;
  unsigned int v17;
  void **v18;
  BOOL v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  void **v25;
  void *v26;
  uint64_t v27;
  _BYTE v28[48];
  void *v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v7 = *(void **)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v26 = v28;
  v27 = 0x600000000;
  if (v6 < 7)
  {
    v29 = v7;
    v30 = 0;
    if (!v6)
    {
      v13 = 0;
      v14 = v28;
      goto LABEL_12;
    }
    v8 = 0;
    v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    v8 = v27;
    v9 = v26;
    v29 = v7;
    v30 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  v13 = v27;
  v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  v24 = *((_QWORD *)v14 + 1);
  DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22))
    else
      v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  v29 = 0;
  v25 = &v29;
  v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  v17 = v30;
  if (!v16)
  {
    v19 = 0;
    if (v30 < 0x41)
      goto LABEL_24;
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29)
        operator delete[](v29);
      goto LABEL_28;
    }
    v18 = (void **)v29;
  }
  else
  {
    v18 = &v29;
  }
  v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29)
      operator delete[](v29);
  }
LABEL_24:
  if (!v19)
    goto LABEL_28;
  v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanZero,mlir::Value &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
  v21 = 1;
LABEL_32:
  if (v26 != v28)
    free(v26);
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOp,mlir::anec::ElementwiseGreaterThanZero>::matchAndRewriteWithStaticShapes(mlir::mps::GreaterThanOp,mlir::mps::GreaterThanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanZero,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.greater_than_zero", (const unsigned __int8 *)0x16, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.greater_than_zero";
    v15[3] = 22;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseGreaterThanEqualZero::build(a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanZero,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

_QWORD *mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqual>::~ConvertBinaryCompare(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqual>::~ConvertBinaryCompare(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOrEqualToOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOrEqualToOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::GreaterThanOrEqualToOpGenericAdaptorBase::GreaterThanOrEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GreaterThanOrEqualToOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::GreaterThanOrEqualToOpGenericAdaptorBase::GreaterThanOrEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::GreaterThanOrEqualToOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOrEqualToOp &>(mlir::mps::GreaterThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOrEqualToOp &>(mlir::mps::GreaterThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqual>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  void *v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _BYTE *v14;
  mlir::Operation *DefiningOp;
  int v16;
  unsigned int v17;
  void **v18;
  _BOOL4 v19;
  uint64_t v20;
  uint64_t v21;
  mlir::GenericProgramPoint *v22;
  uint64_t v24;
  void **v25;
  void *v26;
  uint64_t v27;
  _BYTE v28[48];
  void *v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v7 = *(void **)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v26 = v28;
  v27 = 0x600000000;
  if (v6 < 7)
  {
    v29 = v7;
    v30 = 0;
    if (!v6)
    {
      v13 = 0;
      v14 = v28;
      goto LABEL_12;
    }
    v8 = 0;
    v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    v8 = v27;
    v9 = v26;
    v29 = v7;
    v30 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  v13 = v27;
  v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  v24 = *((_QWORD *)v14 + 1);
  DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
    goto LABEL_32;
  LODWORD(v30) = 1;
  v29 = 0;
  v25 = &v29;
  v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29)
          operator delete[](v29);
        goto LABEL_32;
      }
      v18 = (void **)v29;
    }
    else
    {
      v18 = &v29;
    }
    v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        operator delete[](v29);
        if (!v19)
          goto LABEL_32;
LABEL_26:
        v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20))
        else
          v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    v19 = 0;
    if (v30 >= 0x41)
      goto LABEL_22;
  }
  if (v19)
    goto LABEL_26;
LABEL_32:
  v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanEqual,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v22);
  v21 = 1;
LABEL_33:
  if (v26 != v28)
    free(v26);
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GreaterThanOrEqualToOp &>(mlir::mps::GreaterThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqual>::matchAndRewriteWithStaticShapes(mlir::mps::GreaterThanOrEqualToOp,mlir::mps::GreaterThanOrEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanEqual,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  unint64_t v17[2];
  _QWORD v18[39];

  v18[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.greater_than_equal", (const unsigned __int8 *)0x17, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.greater_than_equal";
    v15[3] = 23;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanEqual,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

_QWORD *mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqualZero>::~ConvertBinaryCompareToZero(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqualZero>::~ConvertBinaryCompareToZero(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqualZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  void *v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _BYTE *v14;
  mlir::Operation *DefiningOp;
  int v16;
  unsigned int v17;
  void **v18;
  BOOL v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  void **v25;
  void *v26;
  uint64_t v27;
  _BYTE v28[48];
  void *v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v7 = *(void **)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v26 = v28;
  v27 = 0x600000000;
  if (v6 < 7)
  {
    v29 = v7;
    v30 = 0;
    if (!v6)
    {
      v13 = 0;
      v14 = v28;
      goto LABEL_12;
    }
    v8 = 0;
    v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    v8 = v27;
    v9 = v26;
    v29 = v7;
    v30 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  v13 = v27;
  v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  v24 = *((_QWORD *)v14 + 1);
  DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22))
    else
      v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  v29 = 0;
  v25 = &v29;
  v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  v17 = v30;
  if (!v16)
  {
    v19 = 0;
    if (v30 < 0x41)
      goto LABEL_24;
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29)
        operator delete[](v29);
      goto LABEL_28;
    }
    v18 = (void **)v29;
  }
  else
  {
    v18 = &v29;
  }
  v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29)
      operator delete[](v29);
  }
LABEL_24:
  if (!v19)
    goto LABEL_28;
  v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanEqualZero,mlir::Value &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
  v21 = 1;
LABEL_32:
  if (v26 != v28)
    free(v26);
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::GreaterThanOrEqualToOp,mlir::anec::ElementwiseGreaterThanEqualZero>::matchAndRewriteWithStaticShapes(mlir::mps::GreaterThanOrEqualToOp,mlir::mps::GreaterThanOrEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseGreaterThanEqualZero,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.greater_than_equal_zero", (const unsigned __int8 *)0x1C, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.greater_than_equal_zero";
    v15[3] = 28;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseGreaterThanEqualZero::build(a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanEqualZero,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

_QWORD *mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThan>::~ConvertBinaryCompare(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThan>::~ConvertBinaryCompare(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::LessThanOpGenericAdaptorBase::LessThanOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::LessThanOpGenericAdaptorBase::LessThanOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::LessThanOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOp &>(mlir::mps::LessThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOp &>(mlir::mps::LessThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThan>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  void *v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _BYTE *v14;
  mlir::Operation *DefiningOp;
  int v16;
  unsigned int v17;
  void **v18;
  _BOOL4 v19;
  uint64_t v20;
  uint64_t v21;
  mlir::GenericProgramPoint *v22;
  uint64_t v24;
  void **v25;
  void *v26;
  uint64_t v27;
  _BYTE v28[48];
  void *v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v7 = *(void **)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v26 = v28;
  v27 = 0x600000000;
  if (v6 < 7)
  {
    v29 = v7;
    v30 = 0;
    if (!v6)
    {
      v13 = 0;
      v14 = v28;
      goto LABEL_12;
    }
    v8 = 0;
    v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    v8 = v27;
    v9 = v26;
    v29 = v7;
    v30 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  v13 = v27;
  v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  v24 = *((_QWORD *)v14 + 1);
  DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
    goto LABEL_32;
  LODWORD(v30) = 1;
  v29 = 0;
  v25 = &v29;
  v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29)
          operator delete[](v29);
        goto LABEL_32;
      }
      v18 = (void **)v29;
    }
    else
    {
      v18 = &v29;
    }
    v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        operator delete[](v29);
        if (!v19)
          goto LABEL_32;
LABEL_26:
        v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20))
        else
          v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    v19 = 0;
    if (v30 >= 0x41)
      goto LABEL_22;
  }
  if (v19)
    goto LABEL_26;
LABEL_32:
  v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseLessThan,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v22);
  v21 = 1;
LABEL_33:
  if (v26 != v28)
    free(v26);
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOp &>(mlir::mps::LessThanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThan>::matchAndRewriteWithStaticShapes(mlir::mps::LessThanOp,mlir::mps::LessThanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseLessThan,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  unint64_t v17[2];
  _QWORD v18[39];

  v18[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.less_than", (const unsigned __int8 *)0xE, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.less_than";
    v15[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThan,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

_QWORD *mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThanZero>::~ConvertBinaryCompareToZero(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThanZero>::~ConvertBinaryCompareToZero(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThanZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  void *v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _BYTE *v14;
  mlir::Operation *DefiningOp;
  int v16;
  unsigned int v17;
  void **v18;
  BOOL v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  void **v25;
  void *v26;
  uint64_t v27;
  _BYTE v28[48];
  void *v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v7 = *(void **)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v26 = v28;
  v27 = 0x600000000;
  if (v6 < 7)
  {
    v29 = v7;
    v30 = 0;
    if (!v6)
    {
      v13 = 0;
      v14 = v28;
      goto LABEL_12;
    }
    v8 = 0;
    v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    v8 = v27;
    v9 = v26;
    v29 = v7;
    v30 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  v13 = v27;
  v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  v24 = *((_QWORD *)v14 + 1);
  DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22))
    else
      v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  v29 = 0;
  v25 = &v29;
  v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  v17 = v30;
  if (!v16)
  {
    v19 = 0;
    if (v30 < 0x41)
      goto LABEL_24;
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29)
        operator delete[](v29);
      goto LABEL_28;
    }
    v18 = (void **)v29;
  }
  else
  {
    v18 = &v29;
  }
  v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29)
      operator delete[](v29);
  }
LABEL_24:
  if (!v19)
    goto LABEL_28;
  v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanZero,mlir::Value &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
  v21 = 1;
LABEL_32:
  if (v26 != v28)
    free(v26);
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOp,mlir::anec::ElementwiseLessThanZero>::matchAndRewriteWithStaticShapes(mlir::mps::LessThanOp,mlir::mps::LessThanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanZero,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.less_than_zero", (const unsigned __int8 *)0x13, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.less_than_zero";
    v15[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseGreaterThanEqualZero::build(a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanZero,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

_QWORD *mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqual>::~ConvertBinaryCompare(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqual>::~ConvertBinaryCompare(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOrEqualToOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOrEqualToOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::LessThanOrEqualToOpGenericAdaptorBase::LessThanOrEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::LessThanOrEqualToOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::LessThanOrEqualToOpGenericAdaptorBase::LessThanOrEqualToOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::LessThanOrEqualToOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOrEqualToOp &>(mlir::mps::LessThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOrEqualToOp &>(mlir::mps::LessThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqual>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  void *v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _BYTE *v14;
  mlir::Operation *DefiningOp;
  int v16;
  unsigned int v17;
  void **v18;
  _BOOL4 v19;
  uint64_t v20;
  uint64_t v21;
  mlir::GenericProgramPoint *v22;
  uint64_t v24;
  void **v25;
  void *v26;
  uint64_t v27;
  _BYTE v28[48];
  void *v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v7 = *(void **)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v26 = v28;
  v27 = 0x600000000;
  if (v6 < 7)
  {
    v29 = v7;
    v30 = 0;
    if (!v6)
    {
      v13 = 0;
      v14 = v28;
      goto LABEL_12;
    }
    v8 = 0;
    v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    v8 = v27;
    v9 = v26;
    v29 = v7;
    v30 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  v13 = v27;
  v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  v24 = *((_QWORD *)v14 + 1);
  DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
    goto LABEL_32;
  LODWORD(v30) = 1;
  v29 = 0;
  v25 = &v29;
  v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  v17 = v30;
  if (v16)
  {
    if (v30 >= 0x41)
    {
      if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
      {
        if (v29)
          operator delete[](v29);
        goto LABEL_32;
      }
      v18 = (void **)v29;
    }
    else
    {
      v18 = &v29;
    }
    v19 = *v18 == 0;
    if (v17 >= 0x41)
    {
LABEL_22:
      if (v29)
      {
        operator delete[](v29);
        if (!v19)
          goto LABEL_32;
LABEL_26:
        v20 = a4[2];
        if (v20 && mlir::RewriterBase::Listener::classof(v20))
        else
          v21 = 0;
        goto LABEL_33;
      }
    }
  }
  else
  {
    v19 = 0;
    if (v30 >= 0x41)
      goto LABEL_22;
  }
  if (v19)
    goto LABEL_26;
LABEL_32:
  v22 = mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanEqual,llvm::SmallVector<mlir::Value,6u> &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t)&v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v22);
  v21 = 1;
LABEL_33:
  if (v26 != v28)
    free(v26);
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::LessThanOrEqualToOp &>(mlir::mps::LessThanOrEqualToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBinaryCompare<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqual>::matchAndRewriteWithStaticShapes(mlir::mps::LessThanOrEqualToOp,mlir::mps::LessThanOrEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompare expects the second operand to be non-zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanEqual,llvm::SmallVector<mlir::Value,6u> &>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  unint64_t v17[2];
  _QWORD v18[39];

  v18[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.less_than_equal", (const unsigned __int8 *)0x14, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.less_than_equal";
    v15[3] = 20;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::anec::ElementwiseEqual::build(a1, (uint64_t)v18, v17[0], v17[1], 0, 0);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanEqual,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

_QWORD *mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqualZero>::~ConvertBinaryCompareToZero(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqualZero>::~ConvertBinaryCompareToZero(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqualZero>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v6;
  void *v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t *v11;
  int v13;
  _BYTE *v14;
  mlir::Operation *DefiningOp;
  int v16;
  unsigned int v17;
  void **v18;
  BOOL v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  void **v25;
  void *v26;
  uint64_t v27;
  _BYTE v28[48];
  void *v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v7 = *(void **)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v26 = v28;
  v27 = 0x600000000;
  if (v6 < 7)
  {
    v29 = v7;
    v30 = 0;
    if (!v6)
    {
      v13 = 0;
      v14 = v28;
      goto LABEL_12;
    }
    v8 = 0;
    v9 = v28;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v6, 8);
    v8 = v27;
    v9 = v26;
    v29 = v7;
    v30 = 0;
  }
  v10 = 0;
  v11 = (uint64_t *)&v9[8 * v8];
  do
  {
    *v11++ = mlir::ValueRange::dereference_iterator(&v29, v10);
    v10 = ++v30;
  }
  while (v29 != v7 || v10 != v6);
  v13 = v27;
  v14 = v26;
LABEL_12:
  LODWORD(v27) = v13 + v6;
  v24 = *((_QWORD *)v14 + 1);
  DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v24);
  if (!DefiningOp)
  {
LABEL_28:
    v22 = a4[2];
    if (v22 && mlir::RewriterBase::Listener::classof(v22))
    else
      v21 = 0;
    goto LABEL_32;
  }
  LODWORD(v30) = 1;
  v29 = 0;
  v25 = &v29;
  v16 = mlir::detail::constant_int_op_binder_any_splat::match((mlir::detail::constant_int_op_binder_any_splat *)&v25, DefiningOp);
  v17 = v30;
  if (!v16)
  {
    v19 = 0;
    if (v30 < 0x41)
      goto LABEL_24;
    goto LABEL_22;
  }
  if (v30 >= 0x41)
  {
    if (v17 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29) > 0x40)
    {
      if (v29)
        operator delete[](v29);
      goto LABEL_28;
    }
    v18 = (void **)v29;
  }
  else
  {
    v18 = &v29;
  }
  v19 = *v18 == 0;
  if (v17 >= 0x41)
  {
LABEL_22:
    if (v29)
      operator delete[](v29);
  }
LABEL_24:
  if (!v19)
    goto LABEL_28;
  v20 = mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanEqualZero,mlir::Value &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)v26);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v20);
  v21 = 1;
LABEL_32:
  if (v26 != v28)
    free(v26);
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBinaryCompareToZero<mlir::mps::LessThanOrEqualToOp,mlir::anec::ElementwiseLessThanEqualZero>::matchAndRewriteWithStaticShapes(mlir::mps::LessThanOrEqualToOp,mlir::mps::LessThanOrEqualToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: ConvertBinaryCompareToZero expects the second operand to be zero. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseLessThanEqualZero,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.less_than_equal_zero", (const unsigned __int8 *)0x19, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.less_than_equal_zero";
    v15[3] = 25;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::ElementwiseGreaterThanEqualZero::build(a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanEqualZero,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::NotOp,mlir::anec::ElementwiseEqualZero>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E29AD0;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_1807761A4()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::NotOpGenericAdaptorBase::NotOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NotOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::NotOpGenericAdaptorBase::NotOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::NotOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotOp &>(mlir::mps::NotOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotOp &>(mlir::mps::NotOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::NotOp,mlir::anec::ElementwiseEqualZero>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::ElementwiseEqualZero,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NotOp &>(mlir::mps::NotOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::NotOp,mlir::anec::ElementwiseEqualZero>::matchAndRewriteWithStaticShapes(mlir::mps::NotOp,mlir::mps::NotOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseEqualZero,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.equal_zero", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.equal_zero";
    v21[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseEqualZero,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

_QWORD *mlir::`anonymous namespace'::ConvertPool<mlir::mps::PoolAvgOp,mlir::anec::AveragePool>::~ConvertPool(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertPool<mlir::mps::PoolAvgOp,mlir::anec::AveragePool>::~ConvertPool(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolAvgOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolAvgOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[96];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::PoolAvgOpGenericAdaptorBase::PoolAvgOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolAvgOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[96];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::PoolAvgOpGenericAdaptorBase::PoolAvgOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PoolAvgOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _QWORD v32[2];
  _QWORD *v33;
  _QWORD v34[4];
  __int16 v35;
  _OWORD v36[7];
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 96);
  v9 = *(_QWORD *)(a3 + 104);
  v37 = v8;
  v38 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 96);
      v29 = *(_OWORD *)(a3 + 64);
      v36[5] = *(_OWORD *)(a3 + 80);
      v36[6] = v28;
      v30 = *(_OWORD *)(a3 + 16);
      v36[0] = *(_OWORD *)a3;
      v36[1] = v30;
      v31 = *(_OWORD *)(a3 + 32);
      v36[3] = *(_OWORD *)(a3 + 48);
      v36[4] = v29;
      v36[2] = v31;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v36, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v37 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v38 = v23;
      if (v37)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v37);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v34[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v35 = 259;
    v32[0] = v34;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v32);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v37, v10);
    v32[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v32[1] = v13;
    if (v32[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v38;
    if (v37 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v35 = 259;
  v33 = v34;
  v34[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v33);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertPool<mlir::mps::PoolAvgOp,mlir::anec::AveragePool>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t *Strides;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t *InputAttributeNames;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  unint64_t v28;
  unint64_t *v29;
  _QWORD *v30;
  unint64_t v31;
  uint64_t v32;
  int PaddingStyle;
  char v34;
  uint64_t *Offsets;
  char v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  _QWORD *v41;
  _QWORD *v42;
  unint64_t v43;
  unint64_t *v44;
  _QWORD *v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *WindowSizes;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  unint64_t v55;
  unint64_t *v56;
  _QWORD *v57;
  unint64_t v58;
  uint64_t v59;
  _BOOL4 ResetAfter;
  _BOOL4 InferredResultTypes;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  unsigned int v66;
  _BYTE *v67;
  unsigned int *v68;
  int v69;
  unsigned int v70;
  _BYTE *v71;
  int v72;
  unsigned int v73;
  _BYTE *v74;
  uint64_t *v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  _QWORD *v79;
  _QWORD *v80;
  unint64_t v81;
  unint64_t *v82;
  _QWORD *v83;
  unint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  int v90;
  BOOL v91;
  _QWORD *v92;
  unint64_t v93;
  unint64_t v94;
  int v95;
  const char *v97;
  BOOL v98;
  int v99;
  unint64_t v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  _OWORD *v104;
  __int128 v105;
  uint64_t v106;
  char *v107;
  unsigned int *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  int v114;
  unint64_t v115;
  unsigned int *v116;
  unint64_t v117;
  uint64_t *v119;
  char *v120;
  int v121;
  char *v122;
  unsigned int v123;
  uint64_t v124;
  size_t v125;
  uint64_t *v126;
  char *v127;
  int v128;
  char *v129;
  unsigned int v130;
  uint64_t v131;
  size_t v132;
  char *v133;
  char *v134;
  char *v135;
  uint64_t v136;
  unint64_t v137;
  uint64_t IntegerType;
  uint64_t v139;
  uint64_t StringAttr;
  uint64_t *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t *v149;
  uint64_t v150;
  uint64_t v151;
  mlir::MLIRContext *v152;
  uint64_t UnitAttr;
  mlir::GenericProgramPoint *v154;
  uint64_t v155;
  unint64_t v156;
  uint64_t *v157;
  uint64_t v158;
  char v159;
  unint64_t v160;
  uint64_t v161;
  _QWORD *v162;
  char *v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t ArgAttrsAttr;
  uint64_t v167;
  uint64_t v168;
  unint64_t v169;
  unint64_t v170;
  uint64_t v171;
  _BOOL4 v172;
  __int128 v173;
  int v174;
  unsigned int *v175;
  uint64_t v176[2];
  uint64_t v177;
  uint64_t *v178;
  uint64_t *v179;
  uint64_t *v180;
  uint64_t v181;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  unint64_t v186[2];
  void *v187;
  uint64_t v188;
  _BYTE v189[64];
  void *v190;
  uint64_t v191;
  _BYTE v192[32];
  void *__dst;
  uint64_t v194;
  _BYTE v195[32];
  void *v196;
  uint64_t v197;
  _BYTE v198[32];
  void *v199;
  uint64_t v200;
  _BYTE v201[64];
  void *v202;
  uint64_t v203;
  _BYTE v204[32];
  void *__src;
  uint64_t v206;
  _BYTE v207[32];
  __int128 v208;
  uint64_t IndexFromDim;
  uint64_t v210;
  __int16 v211;
  char *v212;
  uint64_t v213;
  _QWORD v214[2];
  __int16 v215;
  uint64_t v216;
  __int128 v217;
  uint64_t v218;

  v218 = *MEMORY[0x1E0C80C00];
  v175 = (unsigned int *)a2;
  v208 = *(_OWORD *)(a3 + 96);
  v6 = mlir::ValueRange::dereference_iterator(&v208, 0);
  if (*(_DWORD *)(a2 + 36) >= 2u && *(_QWORD *)(a2 - 32))
  {
    v212 = "failed: pooling with indices operation is not supported on ANEs.";
    v215 = 259;
    v199 = &v212;
    v7 = *(_QWORD *)(a4 + 16);
    if (v7)
    {
      if (mlir::RewriterBase::Listener::classof(v7))
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v7 + 64))(v7, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v199);
      else
        return 0;
    }
    return v7;
  }
  v8 = (_QWORD *)(*(_QWORD *)(v6 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v8)
    mlir::TypeID::get<mlir::ShapedType>();
  if (*(_QWORD *)(a2 - 8) >= 8uLL)
    mlir::TypeID::get<mlir::ShapedType>();
  mlir::getElementBitWidth(v8);
  __src = v207;
  v206 = 0x400000000;
  Strides = (uint64_t *)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v175);
  v10 = (uint64_t)Strides;
  if (!Strides)
    goto LABEL_19;
  v11 = *Strides;
  v12 = mlir::TypeID::get<mlir::ElementsAttr>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_19;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_19:
    v20 = 0;
  mlir::getIntValues<unsigned long long>(v10, v20, (uint64_t)&__src, 1);
  v202 = v204;
  v203 = 0x400000000;
  InputAttributeNames = (uint64_t *)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v175);
  v22 = (uint64_t)InputAttributeNames;
  if (!InputAttributeNames)
    goto LABEL_29;
  v23 = *InputAttributeNames;
  v24 = mlir::TypeID::get<mlir::ElementsAttr>();
  v25 = *(unsigned int *)(v23 + 16);
  if (!(_DWORD)v25)
    goto LABEL_29;
  v26 = *(_QWORD **)(v23 + 8);
  v27 = &v26[2 * v25];
  do
  {
    v28 = v25 >> 1;
    v29 = &v26[2 * (v25 >> 1)];
    v31 = *v29;
    v30 = v29 + 2;
    v25 += ~(v25 >> 1);
    if (v31 < v24)
      v26 = v30;
    else
      v25 = v28;
  }
  while (v25);
  if (v26 != v27 && *v26 == v24)
    v32 = v26[1];
  else
LABEL_29:
    v32 = 0;
  mlir::getIntValues<unsigned long long>(v22, v32, (uint64_t)&v202, 1);
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v175);
  v199 = v201;
  v200 = 0x800000000;
  if (PaddingStyle)
  {
LABEL_44:
    v196 = v198;
    v197 = 0x400000000;
    WindowSizes = (uint64_t *)mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v175);
    v49 = (uint64_t)WindowSizes;
    if (!WindowSizes)
      goto LABEL_53;
    v50 = *WindowSizes;
    v51 = mlir::TypeID::get<mlir::ElementsAttr>();
    v52 = *(unsigned int *)(v50 + 16);
    if (!(_DWORD)v52)
      goto LABEL_53;
    v53 = *(_QWORD **)(v50 + 8);
    v54 = &v53[2 * v52];
    do
    {
      v55 = v52 >> 1;
      v56 = &v53[2 * (v52 >> 1)];
      v58 = *v56;
      v57 = v56 + 2;
      v52 += ~(v52 >> 1);
      if (v58 < v51)
        v53 = v57;
      else
        v52 = v55;
    }
    while (v52);
    if (v53 != v54 && *v53 == v51)
      v59 = v53[1];
    else
LABEL_53:
      v59 = 0;
    mlir::getIntValues<unsigned long long>(v49, v59, (uint64_t)&v196, 1);
    ResetAfter = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v175);
    InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v175);
    if ((_DWORD)v203)
    {
      v62 = v202;
      v63 = 8 * v203;
      while (*v62 == 1)
      {
        ++v62;
        v63 -= 8;
        if (!v63)
          goto LABEL_58;
      }
      v212 = "Dilated Pooling not supported on ANE";
      v215 = 259;
      v68 = v175;
      IndexFromDim = (uint64_t)&v212;
      v7 = *(_QWORD *)(a4 + 16);
      if (v7)
      {
        if (mlir::RewriterBase::Listener::classof(v7))
          v7 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v7 + 64))(v7, *((_QWORD *)v68 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &IndexFromDim);
        else
          v7 = 0;
      }
      goto LABEL_165;
    }
LABEL_58:
    v64 = (uint64_t)v175;
    v173 = v208;
    __dst = v195;
    v194 = 0x400000000;
    v65 = v206;
    if (!(_DWORD)v206)
    {
LABEL_68:
      v190 = v192;
      v191 = 0x400000000;
      v69 = v197;
      if (!(_DWORD)v197)
        goto LABEL_75;
      if (v197 < 5)
      {
        v71 = v192;
        v70 = v197;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v190, v192, v197, 8);
        v70 = v197;
        if (!(_DWORD)v197)
        {
LABEL_74:
          LODWORD(v191) = v69;
LABEL_75:
          v172 = ResetAfter;
          v187 = v189;
          v188 = 0x800000000;
          v72 = v200;
          if (!(_DWORD)v200)
            goto LABEL_82;
          if (v200 < 9)
          {
            v74 = v189;
            v73 = v200;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v187, v189, v200, 8);
            v73 = v200;
            if (!(_DWORD)v200)
            {
LABEL_81:
              LODWORD(v188) = v72;
LABEL_82:
              v185 = v64;
              v217 = v173;
              v184 = mlir::ValueRange::dereference_iterator(&v217, 0);
              v75 = (uint64_t *)(*(_QWORD *)(v184 + 8) & 0xFFFFFFFFFFFFFFF8);
              if (!v75)
                goto LABEL_91;
              v76 = *v75;
              v77 = mlir::TypeID::get<mlir::ShapedType>();
              v78 = *(unsigned int *)(v76 + 16);
              if (!(_DWORD)v78)
                goto LABEL_91;
              v79 = *(_QWORD **)(v76 + 8);
              v80 = &v79[2 * v78];
              do
              {
                v81 = v78 >> 1;
                v82 = &v79[2 * (v78 >> 1)];
                v84 = *v82;
                v83 = v82 + 2;
                v78 += ~(v78 >> 1);
                if (v84 < v77)
                  v79 = v83;
                else
                  v78 = v81;
              }
              while (v78);
              if (v79 != v80 && *v79 == v77)
                v85 = v79[1];
              else
LABEL_91:
                v85 = 0;
              RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE((uint64_t)v75, v85);
              v183 = v86;
              mlir::getElementBitWidth(RankPromotionTypeForANE);
              v87 = *(_QWORD *)__dst;
              v88 = *((_QWORD *)__dst + 1);
              if (*(_QWORD *)__dst == 1)
              {
                v89 = *((_QWORD *)__dst + 1);
                if (v88 == 1)
                {
                  v90 = 0;
                  goto LABEL_100;
                }
              }
              else
              {
                if (v88 != 1)
                {
                  v97 = "Cannot infer 5D layout based on strides";
                  goto LABEL_147;
                }
                v89 = 1;
              }
              v91 = v87 >= v89;
              LODWORD(v89) = v87 >= v89;
              v90 = !v91;
LABEL_100:
              v92 = v190;
              v93 = *(_QWORD *)v190;
              v94 = *((_QWORD *)v190 + 1);
              if (*(_QWORD *)v190 == 1)
              {
                if (v94 == 1)
                {
                  v95 = 0;
LABEL_107:
                  if (v87 == 1 && v88 == 1)
                  {
                    LODWORD(v89) = v94;
                    v90 = v95;
                  }
                  else if ((_DWORD)v89 != (_DWORD)v94 || v90 != v95)
                  {
                    v97 = "Unable to infer layout";
LABEL_147:
                    v212 = (char *)v97;
                    v215 = 259;
                    v111 = v185;
                    IndexFromDim = (uint64_t)&v212;
                    v112 = *(_QWORD *)(a4 + 16);
                    if (v112 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a4 + 16)))
                      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v112 + 64))(v112, *(_QWORD *)(v111 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &IndexFromDim);
LABEL_150:
                    LOBYTE(v113) = 0;
                    v114 = 0;
                    v115 = 0;
LABEL_151:
                    if (v187 != v189)
                      free(v187);
                    if (v190 != v192)
                      free(v190);
                    if (__dst != v195)
                      free(__dst);
                    if (v114)
                    {
                      v212 = (char *)v214;
                      v214[0] = v115 & 0xFFFFFFFFFFFFFF00 | v113;
                      v213 = 0x200000001;
                      v116 = v175;
                      if (v175[9] < 2)
                      {
                        v117 = 1;
                      }
                      else
                      {
                        v214[1] = 0;
                        v117 = 2;
                        LODWORD(v213) = 2;
                      }
                      mlir::ValueRange::ValueRange(v186, (uint64_t)v214, v117);
                      mlir::ConversionPatternRewriter::replaceOp(a4, v116, v186[0], v186[1]);
                      if (v212 != (char *)v214)
                        free(v212);
                      v7 = 1;
                    }
                    else
                    {
                      v7 = 0;
                    }
LABEL_165:
                    if (v196 != v198)
                      free(v196);
LABEL_167:
                    if (v199 != v201)
                      free(v199);
                    if (v202 != v204)
                      free(v202);
                    if (__src != v207)
                      free(__src);
                    return v7;
                  }
                  if ((_DWORD)v89)
                    v98 = 1;
                  else
                    v98 = v90 == 0;
                  v99 = !v98;
                  if (!v98)
                  {
                    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
                    IndexFromDim = mlir::anec::getIndexFromDim(1, v100);
                    v210 = v101;
                    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
                    v180 = (uint64_t *)mlir::anec::getIndexFromDim(2, v102);
                    v181 = v103;
                    if (!(_BYTE)v210 || !(_BYTE)v103)
                    {
                      v212 = "Cannot infer channel and depth dimensions for pooling";
                      v215 = 259;
                      v109 = v185;
                      v176[0] = (uint64_t)&v212;
                      v110 = *(_QWORD *)(a4 + 16);
                      if (v110 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a4 + 16)))
                        (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v110 + 64))(v110, *(_QWORD *)(v109 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v176);
                      goto LABEL_150;
                    }
                    *(int8x16_t *)__dst = vextq_s8(*(int8x16_t *)__dst, *(int8x16_t *)__dst, 8uLL);
                    *(int8x16_t *)v190 = vextq_s8(*(int8x16_t *)v190, *(int8x16_t *)v190, 8uLL);
                    if (!PaddingStyle)
                    {
                      v104 = v187;
                      v105 = *(_OWORD *)v187;
                      *(_OWORD *)v187 = *((_OWORD *)v187 + 1);
                      v104[1] = v105;
                    }
                    v184 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), *(_QWORD *)(v185 + 24), &v184, (uint64_t *)&v180, &IndexFromDim)- 16;
                    LODWORD(v89) = 1;
                    v92 = v190;
                  }
                  if (v92[v89] != 1)
                  {
                    v97 = "ANEC does not kernel size != 1 in channel dimension";
                    goto LABEL_147;
                  }
                  v174 = v99;
                  v106 = v89;
                  v107 = (char *)__dst;
                  if (*((_QWORD *)__dst + v89) != 1)
                  {
                    v97 = "ANEC does not support striding in channel dimension";
                    goto LABEL_147;
                  }
                  switch(PaddingStyle)
                  {
                    case 0:
                      v162 = (char *)v187 + 8 * (2 * v89);
                      if (*v162 || v162[1])
                      {
                        v163 = "padding is only supported in t,b,l,r,f,b";
                        goto LABEL_198;
                      }
                      if (InferredResultTypes && (_DWORD)v194)
                      {
                        v164 = 0;
                        v165 = 0;
                        v171 = 16 * v194;
                        do
                        {
                          ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
                          v167 = *(_QWORD *)((char *)v187 + v165 + 8);
                          if ((unint64_t)(*(_QWORD *)((char *)v187 + v165)
                                                + *(_QWORD *)(ArgAttrsAttr + v164)
                                                + v167
                                                - *(_QWORD *)((char *)v190 + v164)
                                                + *(_QWORD *)&v107[v164])
                             % *(_QWORD *)&v107[v164])
                          {
                            *(_QWORD *)((char *)v187 + v165 + 8) = v167 + 1;
                          }
                          v165 += 16;
                          v164 += 8;
                        }
                        while (v171 != v165);
                      }
                      break;
                    case 1:
                      llvm::SmallVectorImpl<unsigned long long>::resize((uint64_t)&v187, 8uLL, 0);
                      break;
                    case 2:
                    case 4:
                      llvm::SmallVectorImpl<unsigned long long>::resize((uint64_t)&v187, 8uLL, 0);
                      break;
                    default:
                      v163 = "Unsupported paddingStyle";
LABEL_198:
                      mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(a4, &v185, v163);
                      goto LABEL_150;
                  }
                  v119 = (uint64_t *)__dst;
                  v120 = (char *)__dst + 8 * v106;
                  v121 = v194;
                  v122 = (char *)__dst + 8 * v194;
                  if (v122 != v120 + 8)
                  {
                    memmove(v120, v120 + 8, v122 - (v120 + 8));
                    v121 = v194;
                    v119 = (uint64_t *)__dst;
                  }
                  v123 = v121 - 1;
                  LODWORD(v194) = v123;
                  if (v123 != 1)
                  {
                    v124 = *v119;
                    v125 = 8 * v123 - 8;
                    memmove(v119, v119 + 1, v125);
                    *(uint64_t *)((char *)v119 + v125) = v124;
                  }
                  v126 = (uint64_t *)v190;
                  v127 = (char *)v190 + 8 * v106;
                  v128 = v191;
                  v129 = (char *)v190 + 8 * v191;
                  if (v129 != v127 + 8)
                  {
                    memmove(v127, v127 + 8, v129 - (v127 + 8));
                    v128 = v191;
                    v126 = (uint64_t *)v190;
                  }
                  v130 = v128 - 1;
                  LODWORD(v191) = v130;
                  if (v130 != 1)
                  {
                    v131 = *v126;
                    v132 = 8 * v130 - 8;
                    memmove(v126, v126 + 1, v132);
                    *(uint64_t *)((char *)v126 + v132) = v131;
                  }
                  v133 = (char *)v187;
                  v134 = (char *)v187 + 8 * (2 * v106);
                  v135 = (char *)v187 + 8 * v188;
                  v136 = v135 - (v134 + 16);
                  if (v135 != v134 + 16)
                  {
                    memmove((char *)v187 + 8 * (2 * v106), v134 + 16, v135 - (v134 + 16));
                    v133 = (char *)v187;
                  }
                  v137 = &v134[v136] - v133;
                  LODWORD(v188) = v137 >> 3;
                  std::__rotate[abi:nn180100]<std::_ClassicAlgPolicy,unsigned long long *,unsigned long long *>(v133, v133 + 16, &v133[v137 & 0x7FFFFFFF8]);
                  v212 = (char *)v214;
                  v213 = 0x400000000;
                  v216 = 4;
                  IndexFromDim = 3;
                  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
                  v179 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&IndexFromDim, 1, IntegerType, 0);
                  IndexFromDim = 6;
                  v139 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
                  v178 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&IndexFromDim, 1, v139, 0);
                  IndexFromDim = (uint64_t)"ksize";
                  v211 = 259;
                  StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)&IndexFromDim);
                  v141 = mlir::Type::cast<mlir::ShapedType>(&v179);
                  v143 = mlir::DenseElementsAttr::getFromRawBuffer(v141, v142, v190, 8 * v191, 8, 1, 0);
                  mlir::NamedAttrList::set((uint64_t)&v212, StringAttr, v143);
                  IndexFromDim = (uint64_t)"stride";
                  v211 = 259;
                  v144 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)&IndexFromDim);
                  v145 = mlir::Type::cast<mlir::ShapedType>(&v179);
                  v147 = mlir::DenseElementsAttr::getFromRawBuffer(v145, v146, __dst, 8 * v194, 8, 1, 0);
                  mlir::NamedAttrList::set((uint64_t)&v212, v144, v147);
                  IndexFromDim = (uint64_t)"padding";
                  v211 = 259;
                  v148 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)&IndexFromDim);
                  v149 = mlir::Type::cast<mlir::ShapedType>(&v178);
                  v151 = mlir::DenseElementsAttr::getFromRawBuffer(v149, v150, v187, 8 * v188, 8, 1, 0);
                  mlir::NamedAttrList::set((uint64_t)&v212, v148, v151);
                  if (v172)
                  {
                    UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)(a4 + 8), v152);
                    mlir::NamedAttrList::set((uint64_t)&v212, (uint64_t)"inc_pad", 7, UnitAttr);
                  }
                  v154 = mlir::OpBuilder::create<mlir::anec::AveragePool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *(_QWORD *)(v185 + 24), (uint64_t)&v184, (uint64_t)&v212);
                  v113 = (unint64_t)v154 - 16;
                  v177 = (uint64_t)v154 - 16;
                  if (v174)
                  {
                    v180 = (uint64_t *)(*((_QWORD *)v154 - 1) & 0xFFFFFFFFFFFFFFF8);
                    IndexFromDim = (uint64_t)mlir::Type::cast<mlir::ShapedType>(&v180);
                    v210 = v155;
                    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
                    v157 = (uint64_t *)mlir::anec::getIndexFromDim(1, v156);
                    v159 = v158;
                    v180 = v157;
                    v181 = v158;
                    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
                    v176[0] = mlir::anec::getIndexFromDim(2, v160);
                    v176[1] = v161;
                    if (!v159 || !(_BYTE)v161)
                    {
                      mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(a4, &v185, "Cannot infer channel and depth dimensions for 3D Pooling");
                      LOBYTE(v113) = 0;
                      v114 = 0;
                      v115 = 0;
LABEL_200:
                      if (v212 != (char *)v214)
                        free(v212);
                      goto LABEL_151;
                    }
                    v113 = (unint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), *(_QWORD *)(v185 + 24), &v177, v176, (uint64_t *)&v180)- 16;
                  }
                  v115 = v113 & 0xFFFFFFFFFFFFFF00;
                  v114 = 1;
                  goto LABEL_200;
                }
              }
              else if (v94 != 1)
              {
                v97 = "Cannot infer 5D layout based on kernel size";
                goto LABEL_147;
              }
              v91 = v93 >= v94;
              LODWORD(v94) = v93 >= v94;
              v95 = !v91;
              goto LABEL_107;
            }
            v74 = v187;
          }
          memcpy(v74, v199, 8 * v73);
          goto LABEL_81;
        }
        v71 = v190;
      }
      memcpy(v71, v196, 8 * v70);
      goto LABEL_74;
    }
    if (v206 < 5)
    {
      v67 = v195;
      v66 = v206;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v195, v206, 8);
      v66 = v206;
      if (!(_DWORD)v206)
      {
LABEL_67:
        LODWORD(v194) = v65;
        goto LABEL_68;
      }
      v67 = __dst;
    }
    memcpy(v67, __src, 8 * v66);
    goto LABEL_67;
  }
  mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v175);
  if (!v34)
  {
    v212 = "padding is null but paddingStyle is EXPLICT";
    v215 = 259;
    v108 = v175;
    v196 = &v212;
    v7 = *(_QWORD *)(a4 + 16);
    if (v7)
    {
      if (mlir::RewriterBase::Listener::classof(v7))
        v7 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v7 + 64))(v7, *((_QWORD *)v108 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolAvgOp &>(mlir::mps::PoolAvgOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v196);
      else
        v7 = 0;
    }
    goto LABEL_167;
  }
  Offsets = (uint64_t *)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v175);
  if (v36)
  {
    v37 = (uint64_t)Offsets;
    if (!Offsets)
      goto LABEL_42;
    v38 = *Offsets;
    v39 = mlir::TypeID::get<mlir::ElementsAttr>();
    v40 = *(unsigned int *)(v38 + 16);
    if (!(_DWORD)v40)
      goto LABEL_42;
    v41 = *(_QWORD **)(v38 + 8);
    v42 = &v41[2 * v40];
    do
    {
      v43 = v40 >> 1;
      v44 = &v41[2 * (v40 >> 1)];
      v46 = *v44;
      v45 = v44 + 2;
      v40 += ~(v40 >> 1);
      if (v46 < v39)
        v41 = v45;
      else
        v40 = v43;
    }
    while (v40);
    if (v41 != v42 && *v41 == v39)
      v47 = v41[1];
    else
LABEL_42:
      v47 = 0;
    mlir::getIntValues<unsigned long long>(v37, v47, (uint64_t)&v199, 1);
    goto LABEL_44;
  }
  v168 = std::__throw_bad_optional_access[abi:nn180100]();
  return llvm::SmallVectorImpl<unsigned long long>::resize(v168, v169, v170);
}

uint64_t llvm::SmallVectorImpl<unsigned long long>::resize(uint64_t result, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  int v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  int64x2_t v9;
  int64x2_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;

  v3 = *(unsigned int *)(result + 8);
  v4 = a2 - v3;
  if (a2 != v3)
  {
    v5 = a2;
    if (a2 < v3)
    {
LABEL_11:
      *(_DWORD *)(result + 8) = v5;
      return result;
    }
    if (*(unsigned int *)(result + 12) < a2)
    {
      v14 = result;
      v12 = a2 - v3;
      v13 = a3;
      llvm::SmallVectorBase<unsigned int>::grow_pod(result, (void *)(result + 16), a2, 8);
      v4 = v12;
      a3 = v13;
      result = v14;
      v3 = *(unsigned int *)(v14 + 8);
      if (v12)
        goto LABEL_5;
    }
    else if (v4)
    {
LABEL_5:
      v6 = *(_QWORD *)result + 8 * v3;
      v7 = (unint64_t *)v6;
      v8 = v4;
      if (v4 < 4)
        goto LABEL_17;
      v7 = (unint64_t *)(v6 + 8 * (v4 & 0xFFFFFFFFFFFFFFFCLL));
      v8 = v4 & 3;
      v9 = vdupq_n_s64(a3);
      v10 = (int64x2_t *)(v6 + 16);
      v11 = v4 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v10[-1] = v9;
        *v10 = v9;
        v10 += 2;
        v11 -= 4;
      }
      while (v11);
      if (v4 != (v4 & 0xFFFFFFFFFFFFFFFCLL))
      {
LABEL_17:
        do
        {
          *v7++ = a3;
          --v8;
        }
        while (v8);
      }
    }
    v5 = v3 + v4;
    goto LABEL_11;
  }
  return result;
}

uint64_t mlir::`anonymous namespace'::updatePoolPadding(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5, uint64_t a6, unint64_t **a7, int a8, char a9)
{
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  unsigned int v47;
  uint64_t result;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  _QWORD v55[2];

  v55[0] = a1;
  v55[1] = a2;
  v13 = *a3;
  v14 = *a5;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  v16 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55)
                  + 8 * (v15 - 4));
  v17 = v16 % v14;
  if (v16 % v14)
    v18 = v16 % v14;
  else
    v18 = v14;
  v19 = (v13 - v18) & ~((v13 - v18) >> 63);
  v20 = v19 >> 1;
  v21 = *a7;
  v22 = v19 - (v19 >> 1);
  *v21 = v20;
  v21[1] = v22;
  if (a9)
  {
    *v21 = v22;
    v21[1] = v20;
    v22 = v20;
  }
  if (v17)
    v23 = a8 == 0;
  else
    v23 = 1;
  if (!v23)
    v21[1] = v22 + 1;
  v24 = a3[1];
  v25 = a5[1];
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  v27 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55)
                  + 8 * (v26 - 3));
  v28 = v27 % v25;
  if (v27 % v25)
    v29 = v27 % v25;
  else
    v29 = v25;
  v30 = (v24 - v29) & ~((v24 - v29) >> 63);
  v31 = v30 >> 1;
  v32 = *a7;
  v33 = v30 - (v30 >> 1);
  v32[2] = v31;
  v32[3] = v33;
  if (a9)
  {
    v32[2] = v33;
    v32[3] = v31;
    v33 = v31;
  }
  if (v28)
    v34 = a8 == 0;
  else
    v34 = 1;
  if (!v34)
    v32[3] = v33 + 1;
  v35 = a3[2];
  v36 = a5[2];
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  v38 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55)
                  + 8 * (v37 - 2))
      % v36;
  if (v38)
    v39 = v38;
  else
    v39 = v36;
  v40 = (v35 - v39) & ~((v35 - v39) >> 63);
  v41 = v40 >> 1;
  v42 = *a7;
  v43 = v40 - (v40 >> 1);
  v42[4] = v41;
  v42[5] = v43;
  if (a9)
  {
    v42[4] = v43;
    v42[5] = v41;
    v43 = v41;
  }
  if (v38 && a8)
    v42[5] = v43 + 1;
  v44 = a3[3];
  v45 = a5[3];
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  v47 = v46 - 1;
  result = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  v49 = *(_QWORD *)(result + 8 * v47) % v45;
  if (v49)
    v50 = *(_QWORD *)(result + 8 * v47) % v45;
  else
    v50 = v45;
  v51 = (v44 - v50) & ~((v44 - v50) >> 63);
  v52 = v51 >> 1;
  v53 = *a7;
  v54 = v51 - (v51 >> 1);
  v53[6] = v52;
  v53[7] = v54;
  if (a9)
  {
    v53[6] = v54;
    v53[7] = v52;
    v54 = v52;
  }
  if (v49)
  {
    if (a8)
      v53[7] = v54 + 1;
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::AveragePool,mlir::Value &,mlir::NamedAttrList &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  const void *v11;
  uint64_t v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.average_pool", (const unsigned __int8 *)0x11, Context);
  if (!v10)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"anec.average_pool";
    v19[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  v11 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::AveragePool::build(a1, (uint64_t)v21, a3, 1, v11, v12);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::AveragePool,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

char *std::__rotate[abi:nn180100]<std::_ClassicAlgPolicy,unsigned long long *,unsigned long long *>(char *__src, char *a2, char *a3)
{
  char *v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v13;
  int64_t v14;
  uint64_t v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  BOOL v27;
  char v28;
  uint64_t v29;

  v4 = a3;
  if (__src != a2)
  {
    if (a2 == a3)
    {
      return __src;
    }
    else if (__src + 8 == a2)
    {
      v13 = *(_QWORD *)__src;
      v14 = a3 - a2;
      memmove(__src, a2, a3 - a2);
      v4 = &__src[v14];
      *(_QWORD *)v4 = v13;
    }
    else if (a2 + 8 == a3)
    {
      v15 = *((_QWORD *)a3 - 1);
      v4 = __src + 8;
      v16 = a3 - 8 - __src;
      if (a3 - 8 != __src)
        memmove(__src + 8, __src, v16);
      *(_QWORD *)__src = v15;
    }
    else
    {
      v6 = (a2 - __src) >> 3;
      v7 = (a3 - a2) >> 3;
      if (v6 == v7)
      {
        v8 = 0;
        do
        {
          v9 = *(_QWORD *)&__src[v8];
          *(_QWORD *)&__src[v8] = *(_QWORD *)&a2[v8];
          v10 = &__src[v8 + 8];
          *(_QWORD *)&a2[v8] = v9;
          v11 = (uint64_t)&a2[v8 + 8];
          v8 += 8;
        }
        while (v10 != a2 && v11 != (_QWORD)a3);
        return a2;
      }
      else
      {
        v17 = (a3 - a2) >> 3;
        v18 = (a2 - __src) >> 3;
        do
        {
          v19 = v18;
          v18 = v17;
          v17 = v19 % v17;
        }
        while (v17);
        if (v18)
        {
          v20 = &__src[8 * v18];
          do
          {
            v22 = *((_QWORD *)v20 - 1);
            v20 -= 8;
            v21 = v22;
            v23 = &v20[8 * v6];
            v24 = v20;
            do
            {
              v25 = v24;
              v24 = v23;
              *(_QWORD *)v25 = *(_QWORD *)v23;
              v26 = (a3 - v23) >> 3;
              v27 = __OFSUB__(v6, v26);
              v29 = v6 - v26;
              v28 = (v29 < 0) ^ v27;
              v23 = &__src[8 * v29];
              if (v28)
                v23 = &v24[8 * v6];
            }
            while (v23 != v20);
            *(_QWORD *)v24 = v21;
          }
          while (v20 != __src);
        }
        return &__src[8 * v7];
      }
    }
  }
  return v4;
}

_QWORD *mlir::`anonymous namespace'::ConvertPool<mlir::mps::PoolL2NormOp,mlir::anec::L2NormPool>::~ConvertPool(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertPool<mlir::mps::PoolL2NormOp,mlir::anec::L2NormPool>::~ConvertPool(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolL2NormOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolL2NormOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[96];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::PoolL2NormOpGenericAdaptorBase::PoolL2NormOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolL2NormOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[96];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::PoolL2NormOpGenericAdaptorBase::PoolL2NormOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PoolL2NormOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _QWORD v32[2];
  _QWORD *v33;
  _QWORD v34[4];
  __int16 v35;
  _OWORD v36[7];
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 96);
  v9 = *(_QWORD *)(a3 + 104);
  v37 = v8;
  v38 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 96);
      v29 = *(_OWORD *)(a3 + 64);
      v36[5] = *(_OWORD *)(a3 + 80);
      v36[6] = v28;
      v30 = *(_OWORD *)(a3 + 16);
      v36[0] = *(_OWORD *)a3;
      v36[1] = v30;
      v31 = *(_OWORD *)(a3 + 32);
      v36[3] = *(_OWORD *)(a3 + 48);
      v36[4] = v29;
      v36[2] = v31;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v36, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v37 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v38 = v23;
      if (v37)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v37);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v34[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v35 = 259;
    v32[0] = v34;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v32);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v37, v10);
    v32[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v32[1] = v13;
    if (v32[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v38;
    if (v37 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v35 = 259;
  v33 = v34;
  v34[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v33);
  return result;
}

mlir::GenericProgramPoint *mlir::`anonymous namespace'::ConvertPool<mlir::mps::PoolL2NormOp,mlir::anec::L2NormPool>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t *Strides;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t *InputAttributeNames;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  unint64_t v28;
  unint64_t *v29;
  _QWORD *v30;
  unint64_t v31;
  uint64_t v32;
  int PaddingStyle;
  char v34;
  uint64_t *Offsets;
  char v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  _QWORD *v41;
  _QWORD *v42;
  unint64_t v43;
  unint64_t *v44;
  _QWORD *v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *WindowSizes;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  unint64_t v55;
  unint64_t *v56;
  _QWORD *v57;
  unint64_t v58;
  uint64_t v59;
  _BOOL4 InferredResultTypes;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  unsigned int v65;
  _BYTE *v66;
  unsigned int *v67;
  int v68;
  unsigned int v69;
  _BYTE *v70;
  int v71;
  unsigned int v72;
  _BYTE *v73;
  uint64_t *v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  unint64_t v80;
  unint64_t *v81;
  _QWORD *v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  int v89;
  BOOL v90;
  _QWORD *v91;
  unint64_t v92;
  unint64_t v93;
  int v94;
  const char *v96;
  BOOL v97;
  int v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  _OWORD *v103;
  __int128 v104;
  uint64_t v105;
  char *v106;
  unsigned int *v107;
  uint64_t v108;
  unint64_t v109;
  int v110;
  unint64_t v111;
  unsigned int *v112;
  unint64_t v113;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t *v118;
  char *v119;
  int v120;
  char *v121;
  unsigned int v122;
  uint64_t v123;
  size_t v124;
  uint64_t *v125;
  char *v126;
  int v127;
  char *v128;
  unsigned int v129;
  uint64_t v130;
  size_t v131;
  char *v132;
  char *v133;
  char *v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t IntegerType;
  uint64_t v138;
  uint64_t StringAttr;
  uint64_t *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t *v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t *v148;
  uint64_t v149;
  uint64_t v150;
  mlir::GenericProgramPoint *v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t *v154;
  uint64_t v155;
  char v156;
  unint64_t v157;
  uint64_t v158;
  _QWORD *v159;
  char *v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t ArgAttrsAttr;
  uint64_t v164;
  mlir::UnknownLoc **v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  int v169;
  uint64_t v170;
  __int128 v171;
  int v172;
  unsigned int *v173;
  uint64_t v174[2];
  uint64_t v175;
  uint64_t *v176;
  uint64_t *v177;
  uint64_t *v178;
  uint64_t v179;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  unint64_t v184[2];
  void *v185;
  uint64_t v186;
  _BYTE v187[64];
  void *v188;
  uint64_t v189;
  _BYTE v190[32];
  void *__dst;
  uint64_t v192;
  _BYTE v193[32];
  void *v194;
  uint64_t v195;
  _BYTE v196[32];
  void *v197;
  uint64_t v198;
  _BYTE v199[64];
  void *v200;
  uint64_t v201;
  _BYTE v202[32];
  void *__src;
  uint64_t v204;
  _BYTE v205[32];
  __int128 v206;
  uint64_t IndexFromDim;
  uint64_t v208;
  __int16 v209;
  char *v210;
  uint64_t v211;
  _QWORD v212[2];
  __int16 v213;
  uint64_t v214;
  __int128 v215;
  uint64_t v216;

  v216 = *MEMORY[0x1E0C80C00];
  v173 = (unsigned int *)a2;
  v206 = *(_OWORD *)(a3 + 96);
  v6 = mlir::ValueRange::dereference_iterator(&v206, 0);
  if (*(_DWORD *)(a2 + 36) >= 2u && *(_QWORD *)(a2 - 32))
  {
    v210 = "failed: pooling with indices operation is not supported on ANEs.";
    v213 = 259;
    v197 = &v210;
    v7 = *(_QWORD *)(a4 + 16);
    if (v7)
    {
      if (mlir::RewriterBase::Listener::classof(v7))
        return (mlir::GenericProgramPoint *)(*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v7 + 64))(v7, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v197);
      else
        return 0;
    }
    return (mlir::GenericProgramPoint *)v7;
  }
  v8 = (_QWORD *)(*(_QWORD *)(v6 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v8)
    mlir::TypeID::get<mlir::ShapedType>();
  if (*(_QWORD *)(a2 - 8) >= 8uLL)
    mlir::TypeID::get<mlir::ShapedType>();
  mlir::getElementBitWidth(v8);
  __src = v205;
  v204 = 0x400000000;
  Strides = (uint64_t *)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v173);
  v10 = (uint64_t)Strides;
  if (!Strides)
    goto LABEL_19;
  v11 = *Strides;
  v12 = mlir::TypeID::get<mlir::ElementsAttr>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_19;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_19:
    v20 = 0;
  mlir::getIntValues<unsigned long long>(v10, v20, (uint64_t)&__src, 1);
  v200 = v202;
  v201 = 0x400000000;
  InputAttributeNames = (uint64_t *)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v173);
  v22 = (uint64_t)InputAttributeNames;
  if (!InputAttributeNames)
    goto LABEL_29;
  v23 = *InputAttributeNames;
  v24 = mlir::TypeID::get<mlir::ElementsAttr>();
  v25 = *(unsigned int *)(v23 + 16);
  if (!(_DWORD)v25)
    goto LABEL_29;
  v26 = *(_QWORD **)(v23 + 8);
  v27 = &v26[2 * v25];
  do
  {
    v28 = v25 >> 1;
    v29 = &v26[2 * (v25 >> 1)];
    v31 = *v29;
    v30 = v29 + 2;
    v25 += ~(v25 >> 1);
    if (v31 < v24)
      v26 = v30;
    else
      v25 = v28;
  }
  while (v25);
  if (v26 != v27 && *v26 == v24)
    v32 = v26[1];
  else
LABEL_29:
    v32 = 0;
  mlir::getIntValues<unsigned long long>(v22, v32, (uint64_t)&v200, 1);
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v173);
  v197 = v199;
  v198 = 0x800000000;
  if (PaddingStyle)
  {
LABEL_44:
    v194 = v196;
    v195 = 0x400000000;
    WindowSizes = (uint64_t *)mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v173);
    v49 = (uint64_t)WindowSizes;
    if (!WindowSizes)
      goto LABEL_53;
    v50 = *WindowSizes;
    v51 = mlir::TypeID::get<mlir::ElementsAttr>();
    v52 = *(unsigned int *)(v50 + 16);
    if (!(_DWORD)v52)
      goto LABEL_53;
    v53 = *(_QWORD **)(v50 + 8);
    v54 = &v53[2 * v52];
    do
    {
      v55 = v52 >> 1;
      v56 = &v53[2 * (v52 >> 1)];
      v58 = *v56;
      v57 = v56 + 2;
      v52 += ~(v52 >> 1);
      if (v58 < v51)
        v53 = v57;
      else
        v52 = v55;
    }
    while (v52);
    if (v53 != v54 && *v53 == v51)
      v59 = v53[1];
    else
LABEL_53:
      v59 = 0;
    mlir::getIntValues<unsigned long long>(v49, v59, (uint64_t)&v194, 1);
    mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v173);
    InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v173);
    if ((_DWORD)v201)
    {
      v61 = v200;
      v62 = 8 * v201;
      while (*v61 == 1)
      {
        ++v61;
        v62 -= 8;
        if (!v62)
          goto LABEL_58;
      }
      v210 = "Dilated Pooling not supported on ANE";
      v213 = 259;
      v67 = v173;
      IndexFromDim = (uint64_t)&v210;
      v7 = *(_QWORD *)(a4 + 16);
      if (v7)
      {
        if (mlir::RewriterBase::Listener::classof(v7))
          v7 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v7 + 64))(v7, *((_QWORD *)v67 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &IndexFromDim);
        else
          v7 = 0;
      }
      goto LABEL_156;
    }
LABEL_58:
    v169 = InferredResultTypes;
    v63 = (uint64_t)v173;
    v171 = v206;
    __dst = v193;
    v192 = 0x400000000;
    v64 = v204;
    if (!(_DWORD)v204)
    {
LABEL_68:
      v188 = v190;
      v189 = 0x400000000;
      v68 = v195;
      if (!(_DWORD)v195)
        goto LABEL_75;
      if (v195 < 5)
      {
        v70 = v190;
        v69 = v195;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v188, v190, v195, 8);
        v69 = v195;
        if (!(_DWORD)v195)
        {
LABEL_74:
          LODWORD(v189) = v68;
LABEL_75:
          v185 = v187;
          v186 = 0x800000000;
          v71 = v198;
          if (!(_DWORD)v198)
            goto LABEL_82;
          if (v198 < 9)
          {
            v73 = v187;
            v72 = v198;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v185, v187, v198, 8);
            v72 = v198;
            if (!(_DWORD)v198)
            {
LABEL_81:
              LODWORD(v186) = v71;
LABEL_82:
              v183 = v63;
              v215 = v171;
              v182 = mlir::ValueRange::dereference_iterator(&v215, 0);
              v74 = (uint64_t *)(*(_QWORD *)(v182 + 8) & 0xFFFFFFFFFFFFFFF8);
              if (!v74)
                goto LABEL_91;
              v75 = *v74;
              v76 = mlir::TypeID::get<mlir::ShapedType>();
              v77 = *(unsigned int *)(v75 + 16);
              if (!(_DWORD)v77)
                goto LABEL_91;
              v78 = *(_QWORD **)(v75 + 8);
              v79 = &v78[2 * v77];
              do
              {
                v80 = v77 >> 1;
                v81 = &v78[2 * (v77 >> 1)];
                v83 = *v81;
                v82 = v81 + 2;
                v77 += ~(v77 >> 1);
                if (v83 < v76)
                  v78 = v82;
                else
                  v77 = v80;
              }
              while (v77);
              if (v78 != v79 && *v78 == v76)
                v84 = v78[1];
              else
LABEL_91:
                v84 = 0;
              RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE((uint64_t)v74, v84);
              v181 = v85;
              mlir::getElementBitWidth(RankPromotionTypeForANE);
              v86 = *(_QWORD *)__dst;
              v87 = *((_QWORD *)__dst + 1);
              if (*(_QWORD *)__dst == 1)
              {
                v88 = *((_QWORD *)__dst + 1);
                if (v87 == 1)
                {
                  v89 = 0;
                  goto LABEL_100;
                }
              }
              else
              {
                if (v87 != 1)
                {
                  v96 = "Cannot infer 5D layout based on strides";
                  goto LABEL_138;
                }
                v88 = 1;
              }
              v90 = v86 >= v88;
              LODWORD(v88) = v86 >= v88;
              v89 = !v90;
LABEL_100:
              v91 = v188;
              v92 = *(_QWORD *)v188;
              v93 = *((_QWORD *)v188 + 1);
              if (*(_QWORD *)v188 == 1)
              {
                if (v93 == 1)
                {
                  v94 = 0;
LABEL_107:
                  if (v86 == 1 && v87 == 1)
                  {
                    LODWORD(v88) = v93;
                    v89 = v94;
                  }
                  else if ((_DWORD)v88 != (_DWORD)v93 || v89 != v94)
                  {
                    v96 = "Unable to infer layout";
LABEL_138:
                    v210 = (char *)v96;
                    v213 = 259;
                    IndexFromDim = (uint64_t)&v210;
                    v108 = *(_QWORD *)(a4 + 16);
                    if (v108 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a4 + 16)))
                      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v108 + 64))(v108, *(_QWORD *)(v63 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &IndexFromDim);
LABEL_141:
                    LOBYTE(v109) = 0;
                    v110 = 0;
                    v111 = 0;
LABEL_142:
                    if (v185 != v187)
                      free(v185);
                    if (v188 != v190)
                      free(v188);
                    if (__dst != v193)
                      free(__dst);
                    if (v110)
                    {
                      v210 = (char *)v212;
                      v212[0] = v111 & 0xFFFFFFFFFFFFFF00 | v109;
                      v211 = 0x200000001;
                      v112 = v173;
                      if (v173[9] < 2)
                      {
                        v113 = 1;
                      }
                      else
                      {
                        v212[1] = 0;
                        v113 = 2;
                        LODWORD(v211) = 2;
                      }
                      mlir::ValueRange::ValueRange(v184, (uint64_t)v212, v113);
                      mlir::ConversionPatternRewriter::replaceOp(a4, v112, v184[0], v184[1]);
                      if (v210 != (char *)v212)
                        free(v210);
                      v7 = 1;
                    }
                    else
                    {
                      v7 = 0;
                    }
LABEL_156:
                    if (v194 != v196)
                      free(v194);
LABEL_158:
                    if (v197 != v199)
                      free(v197);
                    if (v200 != v202)
                      free(v200);
                    if (__src != v205)
                      free(__src);
                    return (mlir::GenericProgramPoint *)v7;
                  }
                  if ((_DWORD)v88)
                    v97 = 1;
                  else
                    v97 = v89 == 0;
                  v98 = !v97;
                  if (!v97)
                  {
                    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
                    IndexFromDim = mlir::anec::getIndexFromDim(1, v99);
                    v208 = v100;
                    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
                    v178 = (uint64_t *)mlir::anec::getIndexFromDim(2, v101);
                    v179 = v102;
                    if (!(_BYTE)v208 || !(_BYTE)v102)
                    {
                      v210 = "Cannot infer channel and depth dimensions for pooling";
                      v213 = 259;
                      v174[0] = (uint64_t)&v210;
                      v115 = *(_QWORD *)(a4 + 16);
                      if (v115 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a4 + 16)))
                        (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v115 + 64))(v115, *(_QWORD *)(v63 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v174);
                      goto LABEL_141;
                    }
                    *(int8x16_t *)__dst = vextq_s8(*(int8x16_t *)__dst, *(int8x16_t *)__dst, 8uLL);
                    *(int8x16_t *)v188 = vextq_s8(*(int8x16_t *)v188, *(int8x16_t *)v188, 8uLL);
                    if (!PaddingStyle)
                    {
                      v103 = v185;
                      v104 = *(_OWORD *)v185;
                      *(_OWORD *)v185 = *((_OWORD *)v185 + 1);
                      v103[1] = v104;
                    }
                    v182 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), *(_QWORD *)(v63 + 24), &v182, (uint64_t *)&v178, &IndexFromDim)- 16;
                    LODWORD(v88) = 1;
                    v91 = v188;
                  }
                  if (v91[v88] != 1)
                  {
                    v96 = "ANEC does not kernel size != 1 in channel dimension";
                    goto LABEL_138;
                  }
                  v105 = v88;
                  v106 = (char *)__dst;
                  if (*((_QWORD *)__dst + v88) != 1)
                  {
                    v210 = "ANEC does not support striding in channel dimension";
                    v213 = 259;
                    v116 = v183;
                    IndexFromDim = (uint64_t)&v210;
                    v117 = *(_QWORD *)(a4 + 16);
                    if (v117 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a4 + 16)))
                      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v117 + 64))(v117, *(_QWORD *)(v116 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &IndexFromDim);
                    LOBYTE(v109) = 0;
                    v110 = 0;
                    v111 = 0;
                    goto LABEL_142;
                  }
                  switch(PaddingStyle)
                  {
                    case 0:
                      v159 = (char *)v185 + 8 * (2 * v88);
                      if (*v159 || v159[1])
                      {
                        v160 = "padding is only supported in t,b,l,r,f,b";
                        goto LABEL_199;
                      }
                      v172 = v98;
                      if ((v169 & 1) != 0 && (_DWORD)v192)
                      {
                        v161 = 0;
                        v162 = 0;
                        v170 = 16 * v192;
                        do
                        {
                          ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
                          v164 = *(_QWORD *)((char *)v185 + v162 + 8);
                          if ((unint64_t)(*(_QWORD *)((char *)v185 + v162)
                                                + *(_QWORD *)(ArgAttrsAttr + v161)
                                                + v164
                                                - *(_QWORD *)((char *)v188 + v161)
                                                + *(_QWORD *)&v106[v161])
                             % *(_QWORD *)&v106[v161])
                          {
                            *(_QWORD *)((char *)v185 + v162 + 8) = v164 + 1;
                          }
                          v162 += 16;
                          v161 += 8;
                        }
                        while (v170 != v162);
                      }
                      break;
                    case 1:
                      v172 = v98;
                      llvm::SmallVectorImpl<unsigned long long>::resize((uint64_t)&v185, 8uLL, 0);
                      break;
                    case 2:
                    case 4:
                      v172 = v98;
                      llvm::SmallVectorImpl<unsigned long long>::resize((uint64_t)&v185, 8uLL, 0);
                      break;
                    default:
                      v160 = "Unsupported paddingStyle";
LABEL_199:
                      mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(a4, &v183, v160);
                      goto LABEL_141;
                  }
                  v118 = (uint64_t *)__dst;
                  v119 = (char *)__dst + 8 * v105;
                  v120 = v192;
                  v121 = (char *)__dst + 8 * v192;
                  if (v121 != v119 + 8)
                  {
                    memmove(v119, v119 + 8, v121 - (v119 + 8));
                    v120 = v192;
                    v118 = (uint64_t *)__dst;
                  }
                  v122 = v120 - 1;
                  LODWORD(v192) = v122;
                  if (v122 != 1)
                  {
                    v123 = *v118;
                    v124 = 8 * v122 - 8;
                    memmove(v118, v118 + 1, v124);
                    *(uint64_t *)((char *)v118 + v124) = v123;
                  }
                  v125 = (uint64_t *)v188;
                  v126 = (char *)v188 + 8 * v105;
                  v127 = v189;
                  v128 = (char *)v188 + 8 * v189;
                  if (v128 != v126 + 8)
                  {
                    memmove(v126, v126 + 8, v128 - (v126 + 8));
                    v127 = v189;
                    v125 = (uint64_t *)v188;
                  }
                  v129 = v127 - 1;
                  LODWORD(v189) = v129;
                  if (v129 != 1)
                  {
                    v130 = *v125;
                    v131 = 8 * v129 - 8;
                    memmove(v125, v125 + 1, v131);
                    *(uint64_t *)((char *)v125 + v131) = v130;
                  }
                  v132 = (char *)v185;
                  v133 = (char *)v185 + 8 * (2 * v105);
                  v134 = (char *)v185 + 8 * v186;
                  v135 = v134 - (v133 + 16);
                  if (v134 != v133 + 16)
                  {
                    memmove((char *)v185 + 8 * (2 * v105), v133 + 16, v134 - (v133 + 16));
                    v132 = (char *)v185;
                  }
                  v136 = &v133[v135] - v132;
                  LODWORD(v186) = v136 >> 3;
                  std::__rotate[abi:nn180100]<std::_ClassicAlgPolicy,unsigned long long *,unsigned long long *>(v132, v132 + 16, &v132[v136 & 0x7FFFFFFF8]);
                  v210 = (char *)v212;
                  v211 = 0x400000000;
                  v214 = 4;
                  IndexFromDim = 3;
                  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
                  v177 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&IndexFromDim, 1, IntegerType, 0);
                  IndexFromDim = 6;
                  v138 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
                  v176 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&IndexFromDim, 1, v138, 0);
                  IndexFromDim = (uint64_t)"ksize";
                  v209 = 259;
                  StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)&IndexFromDim);
                  v140 = mlir::Type::cast<mlir::ShapedType>(&v177);
                  v142 = mlir::DenseElementsAttr::getFromRawBuffer(v140, v141, v188, 8 * v189, 8, 1, 0);
                  mlir::NamedAttrList::set((uint64_t)&v210, StringAttr, v142);
                  IndexFromDim = (uint64_t)"stride";
                  v209 = 259;
                  v143 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)&IndexFromDim);
                  v144 = mlir::Type::cast<mlir::ShapedType>(&v177);
                  v146 = mlir::DenseElementsAttr::getFromRawBuffer(v144, v145, __dst, 8 * v192, 8, 1, 0);
                  mlir::NamedAttrList::set((uint64_t)&v210, v143, v146);
                  IndexFromDim = (uint64_t)"padding";
                  v209 = 259;
                  v147 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)&IndexFromDim);
                  v148 = mlir::Type::cast<mlir::ShapedType>(&v176);
                  v150 = mlir::DenseElementsAttr::getFromRawBuffer(v148, v149, v185, 8 * v186, 8, 1, 0);
                  mlir::NamedAttrList::set((uint64_t)&v210, v147, v150);
                  v151 = mlir::OpBuilder::create<mlir::anec::L2NormPool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *(_QWORD *)(v183 + 24), (uint64_t)&v182, (uint64_t)&v210);
                  v109 = (unint64_t)v151 - 16;
                  v175 = (uint64_t)v151 - 16;
                  if (v172)
                  {
                    v178 = (uint64_t *)(*((_QWORD *)v151 - 1) & 0xFFFFFFFFFFFFFFF8);
                    IndexFromDim = (uint64_t)mlir::Type::cast<mlir::ShapedType>(&v178);
                    v208 = v152;
                    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
                    v154 = (uint64_t *)mlir::anec::getIndexFromDim(1, v153);
                    v156 = v155;
                    v178 = v154;
                    v179 = v155;
                    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
                    v174[0] = mlir::anec::getIndexFromDim(2, v157);
                    v174[1] = v158;
                    if (!v156 || !(_BYTE)v158)
                    {
                      mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(a4, &v183, "Cannot infer channel and depth dimensions for 3D Pooling");
                      LOBYTE(v109) = 0;
                      v110 = 0;
                      v111 = 0;
LABEL_201:
                      if (v210 != (char *)v212)
                        free(v210);
                      goto LABEL_142;
                    }
                    v109 = (unint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), *(_QWORD *)(v183 + 24), &v175, v174, (uint64_t *)&v178)- 16;
                  }
                  v111 = v109 & 0xFFFFFFFFFFFFFF00;
                  v110 = 1;
                  goto LABEL_201;
                }
              }
              else if (v93 != 1)
              {
                v96 = "Cannot infer 5D layout based on kernel size";
                goto LABEL_138;
              }
              v90 = v92 >= v93;
              LODWORD(v93) = v92 >= v93;
              v94 = !v90;
              goto LABEL_107;
            }
            v73 = v185;
          }
          memcpy(v73, v197, 8 * v72);
          goto LABEL_81;
        }
        v70 = v188;
      }
      memcpy(v70, v194, 8 * v69);
      goto LABEL_74;
    }
    if (v204 < 5)
    {
      v66 = v193;
      v65 = v204;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v193, v204, 8);
      v65 = v204;
      if (!(_DWORD)v204)
      {
LABEL_67:
        LODWORD(v192) = v64;
        goto LABEL_68;
      }
      v66 = __dst;
    }
    memcpy(v66, __src, 8 * v65);
    goto LABEL_67;
  }
  mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v173);
  if (!v34)
  {
    v210 = "padding is null but paddingStyle is EXPLICT";
    v213 = 259;
    v107 = v173;
    v194 = &v210;
    v7 = *(_QWORD *)(a4 + 16);
    if (v7)
    {
      if (mlir::RewriterBase::Listener::classof(v7))
        v7 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v7 + 64))(v7, *((_QWORD *)v107 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v194);
      else
        v7 = 0;
    }
    goto LABEL_158;
  }
  Offsets = (uint64_t *)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v173);
  if (v36)
  {
    v37 = (uint64_t)Offsets;
    if (!Offsets)
      goto LABEL_42;
    v38 = *Offsets;
    v39 = mlir::TypeID::get<mlir::ElementsAttr>();
    v40 = *(unsigned int *)(v38 + 16);
    if (!(_DWORD)v40)
      goto LABEL_42;
    v41 = *(_QWORD **)(v38 + 8);
    v42 = &v41[2 * v40];
    do
    {
      v43 = v40 >> 1;
      v44 = &v41[2 * (v40 >> 1)];
      v46 = *v44;
      v45 = v44 + 2;
      v40 += ~(v40 >> 1);
      if (v46 < v39)
        v41 = v45;
      else
        v40 = v43;
    }
    while (v40);
    if (v41 != v42 && *v41 == v39)
      v47 = v41[1];
    else
LABEL_42:
      v47 = 0;
    mlir::getIntValues<unsigned long long>(v37, v47, (uint64_t)&v197, 1);
    goto LABEL_44;
  }
  v165 = (mlir::UnknownLoc **)std::__throw_bad_optional_access[abi:nn180100]();
  return mlir::OpBuilder::create<mlir::anec::L2NormPool,mlir::Value &,mlir::NamedAttrList &>(v165, v166, v167, v168);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::L2NormPool,mlir::Value &,mlir::NamedAttrList &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  const void *v11;
  uint64_t v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.l2norm_pool", (const unsigned __int8 *)0x10, Context);
  if (!v10)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"anec.l2norm_pool";
    v19[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  v11 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::L2NormPool::build(a1, (uint64_t)v21, a3, 1, v11, v12);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::L2NormPool,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

_QWORD *mlir::`anonymous namespace'::ConvertPool<mlir::mps::PoolMaxOp,mlir::anec::MaxPool>::~ConvertPool(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertPool<mlir::mps::PoolMaxOp,mlir::anec::MaxPool>::~ConvertPool(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolMaxOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolMaxOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[112];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::PoolMaxOpGenericAdaptorBase::PoolMaxOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PoolMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[112];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::PoolMaxOpGenericAdaptorBase::PoolMaxOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PoolMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _QWORD v32[2];
  _QWORD *v33;
  _QWORD v34[4];
  __int16 v35;
  _OWORD v36[8];
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 112);
  v9 = *(_QWORD *)(a3 + 120);
  v37 = v8;
  v38 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 112);
      v36[6] = *(_OWORD *)(a3 + 96);
      v36[7] = v28;
      v29 = *(_OWORD *)(a3 + 80);
      v36[4] = *(_OWORD *)(a3 + 64);
      v36[5] = v29;
      v30 = *(_OWORD *)(a3 + 16);
      v36[0] = *(_OWORD *)a3;
      v36[1] = v30;
      v31 = *(_OWORD *)(a3 + 48);
      v36[2] = *(_OWORD *)(a3 + 32);
      v36[3] = v31;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v36, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v37 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v38 = v23;
      if (v37)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v37);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v34[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v35 = 259;
    v32[0] = v34;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v32);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v37, v10);
    v32[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v32[1] = v13;
    if (v32[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v38;
    if (v37 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v35 = 259;
  v33 = v34;
  v34[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v33);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertPool<mlir::mps::PoolMaxOp,mlir::anec::MaxPool>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t *Strides;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t *InputAttributeNames;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  unint64_t v28;
  unint64_t *v29;
  _QWORD *v30;
  unint64_t v31;
  uint64_t v32;
  int WeightsLayout;
  char v34;
  uint64_t *Offsets;
  char v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  _QWORD *v41;
  _QWORD *v42;
  unint64_t v43;
  unint64_t *v44;
  _QWORD *v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *WindowSizes;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  unint64_t v55;
  unint64_t *v56;
  _QWORD *v57;
  unint64_t v58;
  uint64_t v59;
  _BOOL4 InferredResultTypes;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  unsigned int v65;
  _BYTE *v66;
  unsigned int *v67;
  int v68;
  unsigned int v69;
  _BYTE *v70;
  int v71;
  unsigned int v72;
  _BYTE *v73;
  uint64_t *v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  unint64_t v80;
  unint64_t *v81;
  _QWORD *v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  int v89;
  BOOL v90;
  _QWORD *v91;
  unint64_t v92;
  unint64_t v93;
  int v94;
  const char *v96;
  BOOL v97;
  int v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  _OWORD *v103;
  __int128 v104;
  uint64_t v105;
  char *v106;
  unsigned int *v107;
  uint64_t v108;
  unint64_t v109;
  int v110;
  unint64_t v111;
  unsigned int *v112;
  unint64_t v113;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t *v118;
  char *v119;
  int v120;
  char *v121;
  unsigned int v122;
  uint64_t v123;
  size_t v124;
  uint64_t *v125;
  char *v126;
  int v127;
  char *v128;
  unsigned int v129;
  uint64_t v130;
  size_t v131;
  char *v132;
  char *v133;
  char *v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t IntegerType;
  uint64_t v138;
  uint64_t StringAttr;
  uint64_t *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t *v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t *v148;
  uint64_t v149;
  uint64_t v150;
  mlir::GenericProgramPoint *v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t *v154;
  uint64_t v155;
  char v156;
  unint64_t v157;
  uint64_t v158;
  _QWORD *v159;
  char *v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t ArgAttrsAttr;
  uint64_t v164;
  uint64_t v165;
  uint64_t *v166;
  _BYTE *v167;
  int v168;
  uint64_t v169;
  __int128 v170;
  int v171;
  unsigned int *v172;
  uint64_t v173[2];
  uint64_t v174;
  uint64_t *v175;
  uint64_t *v176;
  uint64_t *v177;
  uint64_t v178;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  unint64_t v183[2];
  void *v184;
  uint64_t v185;
  _BYTE v186[64];
  void *v187;
  uint64_t v188;
  _BYTE v189[32];
  void *__dst;
  uint64_t v191;
  _BYTE v192[32];
  void *v193;
  uint64_t v194;
  _BYTE v195[32];
  void *v196;
  uint64_t v197;
  _BYTE v198[64];
  void *v199;
  uint64_t v200;
  _BYTE v201[32];
  void *__src;
  uint64_t v203;
  _BYTE v204[32];
  __int128 v205;
  uint64_t IndexFromDim;
  uint64_t v207;
  __int16 v208;
  char *v209;
  uint64_t v210;
  _QWORD v211[2];
  __int16 v212;
  uint64_t v213;
  __int128 v214;
  uint64_t v215;

  v215 = *MEMORY[0x1E0C80C00];
  v172 = (unsigned int *)a2;
  v205 = *(_OWORD *)(a3 + 112);
  v6 = mlir::ValueRange::dereference_iterator(&v205, 0);
  if (*(_DWORD *)(a2 + 36) >= 2u && *(_QWORD *)(a2 - 32))
  {
    v209 = "failed: pooling with indices operation is not supported on ANEs.";
    v212 = 259;
    v196 = &v209;
    v7 = *(_QWORD *)(a4 + 16);
    if (v7)
    {
      if (mlir::RewriterBase::Listener::classof(v7))
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v7 + 64))(v7, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v196);
      else
        return 0;
    }
    return v7;
  }
  v8 = (_QWORD *)(*(_QWORD *)(v6 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v8)
    mlir::TypeID::get<mlir::ShapedType>();
  if (*(_QWORD *)(a2 - 8) >= 8uLL)
    mlir::TypeID::get<mlir::ShapedType>();
  mlir::getElementBitWidth(v8);
  __src = v204;
  v203 = 0x400000000;
  Strides = (uint64_t *)mlir::mps::PoolMaxGradientOp::getStrides((mlir::mps::PoolMaxGradientOp *)&v172);
  v10 = (uint64_t)Strides;
  if (!Strides)
    goto LABEL_19;
  v11 = *Strides;
  v12 = mlir::TypeID::get<mlir::ElementsAttr>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_19;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_19:
    v20 = 0;
  mlir::getIntValues<unsigned long long>(v10, v20, (uint64_t)&__src, 1);
  v199 = v201;
  v200 = 0x400000000;
  InputAttributeNames = (uint64_t *)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v172);
  v22 = (uint64_t)InputAttributeNames;
  if (!InputAttributeNames)
    goto LABEL_29;
  v23 = *InputAttributeNames;
  v24 = mlir::TypeID::get<mlir::ElementsAttr>();
  v25 = *(unsigned int *)(v23 + 16);
  if (!(_DWORD)v25)
    goto LABEL_29;
  v26 = *(_QWORD **)(v23 + 8);
  v27 = &v26[2 * v25];
  do
  {
    v28 = v25 >> 1;
    v29 = &v26[2 * (v25 >> 1)];
    v31 = *v29;
    v30 = v29 + 2;
    v25 += ~(v25 >> 1);
    if (v31 < v24)
      v26 = v30;
    else
      v25 = v28;
  }
  while (v25);
  if (v26 != v27 && *v26 == v24)
    v32 = v26[1];
  else
LABEL_29:
    v32 = 0;
  mlir::getIntValues<unsigned long long>(v22, v32, (uint64_t)&v199, 1);
  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v172);
  v196 = v198;
  v197 = 0x800000000;
  if (WeightsLayout)
  {
LABEL_44:
    v193 = v195;
    v194 = 0x400000000;
    WindowSizes = (uint64_t *)mlir::mps::PoolMaxGradientOp::getWindowSizes((mlir::mps::PoolMaxGradientOp *)&v172);
    v49 = (uint64_t)WindowSizes;
    if (!WindowSizes)
      goto LABEL_53;
    v50 = *WindowSizes;
    v51 = mlir::TypeID::get<mlir::ElementsAttr>();
    v52 = *(unsigned int *)(v50 + 16);
    if (!(_DWORD)v52)
      goto LABEL_53;
    v53 = *(_QWORD **)(v50 + 8);
    v54 = &v53[2 * v52];
    do
    {
      v55 = v52 >> 1;
      v56 = &v53[2 * (v52 >> 1)];
      v58 = *v56;
      v57 = v56 + 2;
      v52 += ~(v52 >> 1);
      if (v58 < v51)
        v53 = v57;
      else
        v52 = v55;
    }
    while (v52);
    if (v53 != v54 && *v53 == v51)
      v59 = v53[1];
    else
LABEL_53:
      v59 = 0;
    mlir::getIntValues<unsigned long long>(v49, v59, (uint64_t)&v193, 1);
    mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v172);
    InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v172);
    if ((_DWORD)v200)
    {
      v61 = v199;
      v62 = 8 * v200;
      while (*v61 == 1)
      {
        ++v61;
        v62 -= 8;
        if (!v62)
          goto LABEL_58;
      }
      v209 = "Dilated Pooling not supported on ANE";
      v212 = 259;
      v67 = v172;
      IndexFromDim = (uint64_t)&v209;
      v7 = *(_QWORD *)(a4 + 16);
      if (v7)
      {
        if (mlir::RewriterBase::Listener::classof(v7))
          v7 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v7 + 64))(v7, *((_QWORD *)v67 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &IndexFromDim);
        else
          v7 = 0;
      }
      goto LABEL_156;
    }
LABEL_58:
    v168 = InferredResultTypes;
    v63 = (uint64_t)v172;
    v170 = v205;
    __dst = v192;
    v191 = 0x400000000;
    v64 = v203;
    if (!(_DWORD)v203)
    {
LABEL_68:
      v187 = v189;
      v188 = 0x400000000;
      v68 = v194;
      if (!(_DWORD)v194)
        goto LABEL_75;
      if (v194 < 5)
      {
        v70 = v189;
        v69 = v194;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v187, v189, v194, 8);
        v69 = v194;
        if (!(_DWORD)v194)
        {
LABEL_74:
          LODWORD(v188) = v68;
LABEL_75:
          v184 = v186;
          v185 = 0x800000000;
          v71 = v197;
          if (!(_DWORD)v197)
            goto LABEL_82;
          if (v197 < 9)
          {
            v73 = v186;
            v72 = v197;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v184, v186, v197, 8);
            v72 = v197;
            if (!(_DWORD)v197)
            {
LABEL_81:
              LODWORD(v185) = v71;
LABEL_82:
              v182 = v63;
              v214 = v170;
              v181 = mlir::ValueRange::dereference_iterator(&v214, 0);
              v74 = (uint64_t *)(*(_QWORD *)(v181 + 8) & 0xFFFFFFFFFFFFFFF8);
              if (!v74)
                goto LABEL_91;
              v75 = *v74;
              v76 = mlir::TypeID::get<mlir::ShapedType>();
              v77 = *(unsigned int *)(v75 + 16);
              if (!(_DWORD)v77)
                goto LABEL_91;
              v78 = *(_QWORD **)(v75 + 8);
              v79 = &v78[2 * v77];
              do
              {
                v80 = v77 >> 1;
                v81 = &v78[2 * (v77 >> 1)];
                v83 = *v81;
                v82 = v81 + 2;
                v77 += ~(v77 >> 1);
                if (v83 < v76)
                  v78 = v82;
                else
                  v77 = v80;
              }
              while (v77);
              if (v78 != v79 && *v78 == v76)
                v84 = v78[1];
              else
LABEL_91:
                v84 = 0;
              RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE((uint64_t)v74, v84);
              v180 = v85;
              mlir::getElementBitWidth(RankPromotionTypeForANE);
              v86 = *(_QWORD *)__dst;
              v87 = *((_QWORD *)__dst + 1);
              if (*(_QWORD *)__dst == 1)
              {
                v88 = *((_QWORD *)__dst + 1);
                if (v87 == 1)
                {
                  v89 = 0;
                  goto LABEL_100;
                }
              }
              else
              {
                if (v87 != 1)
                {
                  v96 = "Cannot infer 5D layout based on strides";
                  goto LABEL_138;
                }
                v88 = 1;
              }
              v90 = v86 >= v88;
              LODWORD(v88) = v86 >= v88;
              v89 = !v90;
LABEL_100:
              v91 = v187;
              v92 = *(_QWORD *)v187;
              v93 = *((_QWORD *)v187 + 1);
              if (*(_QWORD *)v187 == 1)
              {
                if (v93 == 1)
                {
                  v94 = 0;
LABEL_107:
                  if (v86 == 1 && v87 == 1)
                  {
                    LODWORD(v88) = v93;
                    v89 = v94;
                  }
                  else if ((_DWORD)v88 != (_DWORD)v93 || v89 != v94)
                  {
                    v96 = "Unable to infer layout";
LABEL_138:
                    v209 = (char *)v96;
                    v212 = 259;
                    IndexFromDim = (uint64_t)&v209;
                    v108 = *(_QWORD *)(a4 + 16);
                    if (v108 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a4 + 16)))
                      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v108 + 64))(v108, *(_QWORD *)(v63 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &IndexFromDim);
LABEL_141:
                    LOBYTE(v109) = 0;
                    v110 = 0;
                    v111 = 0;
LABEL_142:
                    if (v184 != v186)
                      free(v184);
                    if (v187 != v189)
                      free(v187);
                    if (__dst != v192)
                      free(__dst);
                    if (v110)
                    {
                      v209 = (char *)v211;
                      v211[0] = v111 & 0xFFFFFFFFFFFFFF00 | v109;
                      v210 = 0x200000001;
                      v112 = v172;
                      if (v172[9] < 2)
                      {
                        v113 = 1;
                      }
                      else
                      {
                        v211[1] = 0;
                        v113 = 2;
                        LODWORD(v210) = 2;
                      }
                      mlir::ValueRange::ValueRange(v183, (uint64_t)v211, v113);
                      mlir::ConversionPatternRewriter::replaceOp(a4, v112, v183[0], v183[1]);
                      if (v209 != (char *)v211)
                        free(v209);
                      v7 = 1;
                    }
                    else
                    {
                      v7 = 0;
                    }
LABEL_156:
                    if (v193 != v195)
                      free(v193);
LABEL_158:
                    if (v196 != v198)
                      free(v196);
                    if (v199 != v201)
                      free(v199);
                    if (__src != v204)
                      free(__src);
                    return v7;
                  }
                  if ((_DWORD)v88)
                    v97 = 1;
                  else
                    v97 = v89 == 0;
                  v98 = !v97;
                  if (!v97)
                  {
                    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
                    IndexFromDim = mlir::anec::getIndexFromDim(1, v99);
                    v207 = v100;
                    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
                    v177 = (uint64_t *)mlir::anec::getIndexFromDim(2, v101);
                    v178 = v102;
                    if (!(_BYTE)v207 || !(_BYTE)v102)
                    {
                      v209 = "Cannot infer channel and depth dimensions for pooling";
                      v212 = 259;
                      v173[0] = (uint64_t)&v209;
                      v115 = *(_QWORD *)(a4 + 16);
                      if (v115 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a4 + 16)))
                        (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v115 + 64))(v115, *(_QWORD *)(v63 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v173);
                      goto LABEL_141;
                    }
                    *(int8x16_t *)__dst = vextq_s8(*(int8x16_t *)__dst, *(int8x16_t *)__dst, 8uLL);
                    *(int8x16_t *)v187 = vextq_s8(*(int8x16_t *)v187, *(int8x16_t *)v187, 8uLL);
                    if (!WeightsLayout)
                    {
                      v103 = v184;
                      v104 = *(_OWORD *)v184;
                      *(_OWORD *)v184 = *((_OWORD *)v184 + 1);
                      v103[1] = v104;
                    }
                    v181 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), *(_QWORD *)(v63 + 24), &v181, (uint64_t *)&v177, &IndexFromDim)- 16;
                    LODWORD(v88) = 1;
                    v91 = v187;
                  }
                  if (v91[v88] != 1)
                  {
                    v96 = "ANEC does not kernel size != 1 in channel dimension";
                    goto LABEL_138;
                  }
                  v105 = v88;
                  v106 = (char *)__dst;
                  if (*((_QWORD *)__dst + v88) != 1)
                  {
                    v209 = "ANEC does not support striding in channel dimension";
                    v212 = 259;
                    v116 = v182;
                    IndexFromDim = (uint64_t)&v209;
                    v117 = *(_QWORD *)(a4 + 16);
                    if (v117 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a4 + 16)))
                      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v117 + 64))(v117, *(_QWORD *)(v116 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &IndexFromDim);
                    LOBYTE(v109) = 0;
                    v110 = 0;
                    v111 = 0;
                    goto LABEL_142;
                  }
                  switch(WeightsLayout)
                  {
                    case 0:
                      v159 = (char *)v184 + 8 * (2 * v88);
                      if (*v159 || v159[1])
                      {
                        v160 = "padding is only supported in t,b,l,r,f,b";
                        goto LABEL_199;
                      }
                      v171 = v98;
                      if ((v168 & 1) != 0 && (_DWORD)v191)
                      {
                        v161 = 0;
                        v162 = 0;
                        v169 = 16 * v191;
                        do
                        {
                          ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
                          v164 = *(_QWORD *)((char *)v184 + v162 + 8);
                          if ((unint64_t)(*(_QWORD *)((char *)v184 + v162)
                                                + *(_QWORD *)(ArgAttrsAttr + v161)
                                                + v164
                                                - *(_QWORD *)((char *)v187 + v161)
                                                + *(_QWORD *)&v106[v161])
                             % *(_QWORD *)&v106[v161])
                          {
                            *(_QWORD *)((char *)v184 + v162 + 8) = v164 + 1;
                          }
                          v162 += 16;
                          v161 += 8;
                        }
                        while (v169 != v162);
                      }
                      break;
                    case 1:
                      v171 = v98;
                      llvm::SmallVectorImpl<unsigned long long>::resize((uint64_t)&v184, 8uLL, 0);
                      break;
                    case 2:
                    case 4:
                      v171 = v98;
                      llvm::SmallVectorImpl<unsigned long long>::resize((uint64_t)&v184, 8uLL, 0);
                      break;
                    default:
                      v160 = "Unsupported paddingStyle";
LABEL_199:
                      mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(a4, &v182, v160);
                      goto LABEL_141;
                  }
                  v118 = (uint64_t *)__dst;
                  v119 = (char *)__dst + 8 * v105;
                  v120 = v191;
                  v121 = (char *)__dst + 8 * v191;
                  if (v121 != v119 + 8)
                  {
                    memmove(v119, v119 + 8, v121 - (v119 + 8));
                    v120 = v191;
                    v118 = (uint64_t *)__dst;
                  }
                  v122 = v120 - 1;
                  LODWORD(v191) = v122;
                  if (v122 != 1)
                  {
                    v123 = *v118;
                    v124 = 8 * v122 - 8;
                    memmove(v118, v118 + 1, v124);
                    *(uint64_t *)((char *)v118 + v124) = v123;
                  }
                  v125 = (uint64_t *)v187;
                  v126 = (char *)v187 + 8 * v105;
                  v127 = v188;
                  v128 = (char *)v187 + 8 * v188;
                  if (v128 != v126 + 8)
                  {
                    memmove(v126, v126 + 8, v128 - (v126 + 8));
                    v127 = v188;
                    v125 = (uint64_t *)v187;
                  }
                  v129 = v127 - 1;
                  LODWORD(v188) = v129;
                  if (v129 != 1)
                  {
                    v130 = *v125;
                    v131 = 8 * v129 - 8;
                    memmove(v125, v125 + 1, v131);
                    *(uint64_t *)((char *)v125 + v131) = v130;
                  }
                  v132 = (char *)v184;
                  v133 = (char *)v184 + 8 * (2 * v105);
                  v134 = (char *)v184 + 8 * v185;
                  v135 = v134 - (v133 + 16);
                  if (v134 != v133 + 16)
                  {
                    memmove((char *)v184 + 8 * (2 * v105), v133 + 16, v134 - (v133 + 16));
                    v132 = (char *)v184;
                  }
                  v136 = &v133[v135] - v132;
                  LODWORD(v185) = v136 >> 3;
                  std::__rotate[abi:nn180100]<std::_ClassicAlgPolicy,unsigned long long *,unsigned long long *>(v132, v132 + 16, &v132[v136 & 0x7FFFFFFF8]);
                  v209 = (char *)v211;
                  v210 = 0x400000000;
                  v213 = 4;
                  IndexFromDim = 3;
                  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
                  v176 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&IndexFromDim, 1, IntegerType, 0);
                  IndexFromDim = 6;
                  v138 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
                  v175 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&IndexFromDim, 1, v138, 0);
                  IndexFromDim = (uint64_t)"ksize";
                  v208 = 259;
                  StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)&IndexFromDim);
                  v140 = mlir::Type::cast<mlir::ShapedType>(&v176);
                  v142 = mlir::DenseElementsAttr::getFromRawBuffer(v140, v141, v187, 8 * v188, 8, 1, 0);
                  mlir::NamedAttrList::set((uint64_t)&v209, StringAttr, v142);
                  IndexFromDim = (uint64_t)"stride";
                  v208 = 259;
                  v143 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)&IndexFromDim);
                  v144 = mlir::Type::cast<mlir::ShapedType>(&v176);
                  v146 = mlir::DenseElementsAttr::getFromRawBuffer(v144, v145, __dst, 8 * v191, 8, 1, 0);
                  mlir::NamedAttrList::set((uint64_t)&v209, v143, v146);
                  IndexFromDim = (uint64_t)"padding";
                  v208 = 259;
                  v147 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)&IndexFromDim);
                  v148 = mlir::Type::cast<mlir::ShapedType>(&v175);
                  v150 = mlir::DenseElementsAttr::getFromRawBuffer(v148, v149, v184, 8 * v185, 8, 1, 0);
                  mlir::NamedAttrList::set((uint64_t)&v209, v147, v150);
                  v151 = mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *(_QWORD *)(v182 + 24), (uint64_t)&v181, (uint64_t)&v209);
                  v109 = (unint64_t)v151 - 16;
                  v174 = (uint64_t)v151 - 16;
                  if (v171)
                  {
                    v177 = (uint64_t *)(*((_QWORD *)v151 - 1) & 0xFFFFFFFFFFFFFFF8);
                    IndexFromDim = (uint64_t)mlir::Type::cast<mlir::ShapedType>(&v177);
                    v207 = v152;
                    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
                    v154 = (uint64_t *)mlir::anec::getIndexFromDim(1, v153);
                    v156 = v155;
                    v177 = v154;
                    v178 = v155;
                    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&IndexFromDim);
                    v173[0] = mlir::anec::getIndexFromDim(2, v157);
                    v173[1] = v158;
                    if (!v156 || !(_BYTE)v158)
                    {
                      mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(a4, &v182, "Cannot infer channel and depth dimensions for 3D Pooling");
                      LOBYTE(v109) = 0;
                      v110 = 0;
                      v111 = 0;
LABEL_201:
                      if (v209 != (char *)v211)
                        free(v209);
                      goto LABEL_142;
                    }
                    v109 = (unint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 8), *(_QWORD *)(v182 + 24), &v174, v173, (uint64_t *)&v177)- 16;
                  }
                  v111 = v109 & 0xFFFFFFFFFFFFFF00;
                  v110 = 1;
                  goto LABEL_201;
                }
              }
              else if (v93 != 1)
              {
                v96 = "Cannot infer 5D layout based on kernel size";
                goto LABEL_138;
              }
              v90 = v92 >= v93;
              LODWORD(v93) = v92 >= v93;
              v94 = !v90;
              goto LABEL_107;
            }
            v73 = v184;
          }
          memcpy(v73, v196, 8 * v72);
          goto LABEL_81;
        }
        v70 = v187;
      }
      memcpy(v70, v193, 8 * v69);
      goto LABEL_74;
    }
    if (v203 < 5)
    {
      v66 = v192;
      v65 = v203;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v192, v203, 8);
      v65 = v203;
      if (!(_DWORD)v203)
      {
LABEL_67:
        LODWORD(v191) = v64;
        goto LABEL_68;
      }
      v66 = __dst;
    }
    memcpy(v66, __src, 8 * v65);
    goto LABEL_67;
  }
  mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v172);
  if (!v34)
  {
    v209 = "padding is null but paddingStyle is EXPLICT";
    v212 = 259;
    v107 = v172;
    v193 = &v209;
    v7 = *(_QWORD *)(a4 + 16);
    if (v7)
    {
      if (mlir::RewriterBase::Listener::classof(v7))
        v7 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v7 + 64))(v7, *((_QWORD *)v107 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v193);
      else
        v7 = 0;
    }
    goto LABEL_158;
  }
  Offsets = (uint64_t *)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v172);
  if (v36)
  {
    v37 = (uint64_t)Offsets;
    if (!Offsets)
      goto LABEL_42;
    v38 = *Offsets;
    v39 = mlir::TypeID::get<mlir::ElementsAttr>();
    v40 = *(unsigned int *)(v38 + 16);
    if (!(_DWORD)v40)
      goto LABEL_42;
    v41 = *(_QWORD **)(v38 + 8);
    v42 = &v41[2 * v40];
    do
    {
      v43 = v40 >> 1;
      v44 = &v41[2 * (v40 >> 1)];
      v46 = *v44;
      v45 = v44 + 2;
      v40 += ~(v40 >> 1);
      if (v46 < v39)
        v41 = v45;
      else
        v40 = v43;
    }
    while (v40);
    if (v41 != v42 && *v41 == v39)
      v47 = v41[1];
    else
LABEL_42:
      v47 = 0;
    mlir::getIntValues<unsigned long long>(v37, v47, (uint64_t)&v196, 1);
    goto LABEL_44;
  }
  v165 = std::__throw_bad_optional_access[abi:nn180100]();
  return mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(v165, v166, v167);
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(uint64_t a1, uint64_t *a2, _BYTE *a3)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  _BYTE *v7;
  char v8;
  char v9;
  _QWORD *v10;

  v3 = 1;
  v9 = 1;
  if (*a3)
  {
    v7 = a3;
    v3 = 3;
  }
  v8 = v3;
  v4 = *a2;
  v10 = &v7;
  v5 = *(_QWORD *)(a1 + 16);
  if (!v5)
    return 0;
  result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v5 + 64))(v5, *(_QWORD *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolMaxOp &>(mlir::mps::PoolMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  const void *v11;
  uint64_t v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.max_pool", (const unsigned __int8 *)0xD, Context);
  if (!v10)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"anec.max_pool";
    v19[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  v11 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::MaxPool::build(a1, (uint64_t)v21, a3, 1, v11, v12);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::MaxPool,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::`anonymous namespace'::ConvertStencil::~ConvertStencil(mlir::_anonymous_namespace_::ConvertStencil *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::StencilOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::StencilOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[104];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::StencilOpGenericAdaptorBase::StencilOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::StencilOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[104];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::StencilOpGenericAdaptorBase::StencilOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::StencilOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  _QWORD v32[2];
  _QWORD *v33;
  _QWORD v34[4];
  __int16 v35;
  _OWORD v36[7];
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 104);
  v9 = *(_QWORD *)(a3 + 112);
  v38 = v8;
  v39 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 96);
      v37 = *(_QWORD *)(a3 + 112);
      v29 = *(_OWORD *)(a3 + 64);
      v36[5] = *(_OWORD *)(a3 + 80);
      v36[6] = v28;
      v30 = *(_OWORD *)(a3 + 16);
      v36[0] = *(_OWORD *)a3;
      v36[1] = v30;
      v31 = *(_OWORD *)(a3 + 48);
      v36[2] = *(_OWORD *)(a3 + 32);
      v36[3] = v31;
      v36[4] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v36, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v38 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v39 = v23;
      if (v38)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v38)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v38))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v38);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v34[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v35 = 259;
    v32[0] = v34;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(mlir::mps::StencilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v32);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v38, v10);
    v32[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v32[1] = v13;
    if (v32[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v39;
    if (v38 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v35 = 259;
  v33 = v34;
  v34[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(mlir::mps::StencilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v33);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertStencil::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  unint64_t v28;
  unint64_t *v29;
  _QWORD *v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  unint64_t v39;
  unint64_t *v40;
  _QWORD *v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t ArgAttrsAttr;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  const char *v56;
  uint64_t v57;
  char *v58;
  unint64_t v59;
  uint64_t *v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  __int128 *v64;
  _OWORD *v65;
  uint64_t v66;
  __int128 v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t IndexFromDim;
  char v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t *Strides;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  _QWORD *v80;
  _QWORD *v81;
  unint64_t v82;
  unint64_t *v83;
  _QWORD *v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t *FastmathAttr;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  _QWORD *v92;
  _QWORD *v93;
  unint64_t v94;
  unint64_t *v95;
  _QWORD *v96;
  unint64_t v97;
  uint64_t v98;
  int PaddingStyle;
  int v100;
  char v101;
  uint64_t v102;
  uint64_t *v103;
  uint64_t v104;
  _QWORD *v105;
  char *v106;
  _QWORD *v107;
  uint64_t v108;
  uint64_t v109;
  _QWORD *v110;
  uint64_t v111;
  __int128 v112;
  uint64_t IntegerType;
  uint64_t v114;
  const void *v115;
  uint64_t v116;
  void *v117;
  mlir::AffineMap *v118;
  uint64_t ElementTypeOrSelf;
  uint64_t v120;
  uint64_t *v121;
  uint64_t v122;
  uint64_t *v123;
  uint64_t v124;
  uint64_t *v125;
  uint64_t v126;
  mlir::MLIRContext *v127;
  unint64_t v128;
  mlir::MLIRContext *v129;
  unint64_t v130;
  mlir::GenericProgramPoint *GOCConstant;
  char v132;
  char *v133;
  uint64_t v134;
  void *v135;
  mlir::AffineMap *v136;
  mlir::AffineMap *v137;
  uint64_t v138;
  unsigned int *v139;
  uint64_t v141;
  uint64_t *v142;
  _BYTE *v143;
  uint64_t v144;
  uint64_t UnitAttr;
  uint64_t v146;
  char *v147;
  uint64_t *v148;
  uint64_t *v149;
  _QWORD v150[2];
  _QWORD v151[2];
  uint64_t RankPromotionTypeForANE;
  uint64_t v153;
  void *v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  unint64_t v160[2];
  __int128 v161;
  __int128 v162;
  uint64_t v163;
  uint64_t v164;
  __int128 v165;
  uint64_t v166;
  void *v167;
  unsigned int v168;
  uint64_t v169;
  void *v170;
  unsigned int v171;
  uint64_t v172;
  void *v173[2];
  _BYTE v174[16];
  __int16 v175;
  void *v176;
  uint64_t v177;
  _BYTE v178[32];
  char *v179;
  uint64_t v180;
  _BYTE v181[32];
  char *v182;
  uint64_t v183;
  _BYTE v184[32];
  __int128 v185;
  uint64_t v186;

  v186 = *MEMORY[0x1E0C80C00];
  v158 = a2;
  v185 = *(_OWORD *)(a3 + 104);
  v5 = mlir::ValueRange::dereference_iterator(&v185, 0);
  v157 = v5;
  v6 = mlir::ValueRange::dereference_iterator(&v185, 1);
  v7 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v158);
  if (mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v158) != 2)
  {
    v173[0] = "failed: stencil reduction_mode != sum is not supported on ANEs.";
    v175 = 259;
    v54 = v158;
    *(_QWORD *)&v165 = v173;
    v55 = *(_QWORD *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55))
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), __int128 *))(*(_QWORD *)v55 + 64))(v55, *(_QWORD *)(v54 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(mlir::mps::StencilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v165);
      else
        return 0;
    }
    return v55;
  }
  v154 = &v156;
  v155 = 0x100000000;
  if (!mlir::matchConstantWithFloatVector<float>(v6, (uint64_t)&v154))
  {
    v56 = "Failed to match kernel value";
    goto LABEL_47;
  }
  if ((_DWORD)v155)
  {
    v8 = (float *)v154;
    v9 = 4 * v155;
    while (*v8 == 1.0)
    {
      ++v8;
      v9 -= 4;
      if (!v9)
        goto LABEL_7;
    }
    v56 = "Can only convert to AvgPool if stencil kernel is all ones";
    goto LABEL_47;
  }
LABEL_7:
  v10 = (uint64_t *)(*(_QWORD *)(v5 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_16;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_16;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_16:
    v20 = 0;
  RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v153 = v21;
  v22 = (uint64_t *)(*(_QWORD *)(v6 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v22)
    goto LABEL_26;
  v23 = *v22;
  v24 = mlir::TypeID::get<mlir::ShapedType>();
  v25 = *(unsigned int *)(v23 + 16);
  if (!(_DWORD)v25)
    goto LABEL_26;
  v26 = *(_QWORD **)(v23 + 8);
  v27 = &v26[2 * v25];
  do
  {
    v28 = v25 >> 1;
    v29 = &v26[2 * (v25 >> 1)];
    v31 = *v29;
    v30 = v29 + 2;
    v25 += ~(v25 >> 1);
    if (v31 < v24)
      v26 = v30;
    else
      v25 = v28;
  }
  while (v25);
  if (v26 != v27 && *v26 == v24)
    v32 = v26[1];
  else
LABEL_26:
    v32 = 0;
  v151[0] = v22;
  v151[1] = v32;
  v33 = (uint64_t *)(*(_QWORD *)(v7 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v33)
    goto LABEL_36;
  v34 = *v33;
  v35 = mlir::TypeID::get<mlir::ShapedType>();
  v36 = *(unsigned int *)(v34 + 16);
  if (!(_DWORD)v36)
    goto LABEL_36;
  v37 = *(_QWORD **)(v34 + 8);
  v38 = &v37[2 * v36];
  do
  {
    v39 = v36 >> 1;
    v40 = &v37[2 * (v36 >> 1)];
    v42 = *v40;
    v41 = v40 + 2;
    v36 += ~(v36 >> 1);
    if (v42 < v35)
      v37 = v41;
    else
      v36 = v39;
  }
  while (v36);
  if (v37 != v38 && *v37 == v35)
    v43 = v37[1];
  else
LABEL_36:
    v43 = 0;
  v150[0] = mlir::getRankPromotionTypeForANE((uint64_t)v33, v43);
  v150[1] = v44;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v151);
  if (v45 != 4)
  {
    v56 = "failed: stencil kernel rank != 4 is not supported on ANEs.";
LABEL_47:
    v173[0] = (void *)v56;
    v175 = 259;
    v57 = v158;
    *(_QWORD *)&v165 = v173;
    v55 = *(_QWORD *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55))
        v55 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), __int128 *))(*(_QWORD *)v55 + 64))(v55, *(_QWORD *)(v57 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(mlir::mps::StencilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v165);
      else
        v55 = 0;
    }
    goto LABEL_135;
  }
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v151);
  v47 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v151);
  v49 = v48;
  v50 = (uint64_t *)(v47 + 8 * v48);
  v182 = v184;
  v183 = 0x400000000;
  v51 = (uint64_t)v50 - ArgAttrsAttr;
  if ((unint64_t)v50 - ArgAttrsAttr < 0x21)
  {
    v52 = 0;
    v53 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v182, v184, v51 >> 3, 8);
    v52 = v183;
    v53 = v183;
  }
  if (v50 != (uint64_t *)ArgAttrsAttr)
  {
    v58 = &v182[8 * v52];
    v59 = v47 + 8 * v49 - ArgAttrsAttr - 8;
    if (v59 < 0x38)
    {
      v60 = (uint64_t *)ArgAttrsAttr;
      do
      {
LABEL_59:
        v68 = *v60++;
        *(_QWORD *)v58 = v68;
        v58 += 8;
      }
      while (v60 != v50);
      goto LABEL_60;
    }
    v61 = &v182[8 * v52];
    v60 = (uint64_t *)ArgAttrsAttr;
    if ((unint64_t)&v61[-ArgAttrsAttr] < 0x20)
      goto LABEL_59;
    v62 = (v59 >> 3) + 1;
    v63 = 8 * (v62 & 0x3FFFFFFFFFFFFFFCLL);
    v58 += v63;
    v60 = (uint64_t *)(ArgAttrsAttr + v63);
    v64 = (__int128 *)(ArgAttrsAttr + 16);
    v65 = v61 + 16;
    v66 = v62 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v67 = *v64;
      *(v65 - 1) = *(v64 - 1);
      *v65 = v67;
      v64 += 2;
      v65 += 2;
      v66 -= 4;
    }
    while (v66);
    if (v62 != (v62 & 0x3FFFFFFFFFFFFFFCLL))
      goto LABEL_59;
  }
LABEL_60:
  LODWORD(v183) = v53 + ((unint64_t)v51 >> 3);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v151);
  IndexFromDim = mlir::anec::getIndexFromDim(1, v69);
  if (v71)
  {
    v72 = *(_QWORD *)&v182[8 * IndexFromDim];
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
    if (v73 == 5 && v72 >= 2)
    {
      v173[0] = "failed: stencil along channel with rank 5 input is not supported on ANEs.";
      v175 = 259;
      v74 = v158;
      *(_QWORD *)&v165 = v173;
      v55 = *(_QWORD *)(a4 + 16);
      if (v55)
      {
        if (mlir::RewriterBase::Listener::classof(v55))
          v55 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), __int128 *))(*(_QWORD *)v55 + 64))(v55, *(_QWORD *)(v74 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(mlir::mps::StencilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v165);
        else
          v55 = 0;
      }
LABEL_133:
      if (v182 != v184)
        free(v182);
LABEL_135:
      if (v154 != &v156)
        free(v154);
      return v55;
    }
    v179 = v181;
    v180 = 0x400000000;
    Strides = (uint64_t *)mlir::mps::PoolMaxGradientOp::getStrides((mlir::mps::PoolMaxGradientOp *)&v158);
    v76 = (uint64_t)Strides;
    if (!Strides)
      goto LABEL_75;
    v77 = *Strides;
    v78 = mlir::TypeID::get<mlir::ElementsAttr>();
    v79 = *(unsigned int *)(v77 + 16);
    if (!(_DWORD)v79)
      goto LABEL_75;
    v80 = *(_QWORD **)(v77 + 8);
    v81 = &v80[2 * v79];
    do
    {
      v82 = v79 >> 1;
      v83 = &v80[2 * (v79 >> 1)];
      v85 = *v83;
      v84 = v83 + 2;
      v79 += ~(v79 >> 1);
      if (v85 < v78)
        v80 = v84;
      else
        v79 = v82;
    }
    while (v79);
    if (v80 != v81 && *v80 == v78)
      v86 = v80[1];
    else
LABEL_75:
      v86 = 0;
    mlir::getIntValues<unsigned long long>(v76, v86, (uint64_t)&v179, 1);
    v176 = v178;
    v177 = 0x400000000;
    FastmathAttr = (uint64_t *)mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v158);
    v88 = (uint64_t)FastmathAttr;
    if (!FastmathAttr)
      goto LABEL_85;
    v89 = *FastmathAttr;
    v90 = mlir::TypeID::get<mlir::ElementsAttr>();
    v91 = *(unsigned int *)(v89 + 16);
    if (!(_DWORD)v91)
      goto LABEL_85;
    v92 = *(_QWORD **)(v89 + 8);
    v93 = &v92[2 * v91];
    do
    {
      v94 = v91 >> 1;
      v95 = &v92[2 * (v91 >> 1)];
      v97 = *v95;
      v96 = v95 + 2;
      v91 += ~(v91 >> 1);
      if (v97 < v90)
        v92 = v96;
      else
        v91 = v94;
    }
    while (v91);
    if (v92 != v93 && *v92 == v90)
      v98 = v92[1];
    else
LABEL_85:
      v98 = 0;
    mlir::getIntValues<unsigned long long>(v88, v98, (uint64_t)&v176, 1);
    PaddingStyle = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v158);
    v173[0] = v174;
    v173[1] = (void *)0x800000000;
    v100 = PaddingStyle;
    switch(PaddingStyle)
    {
      case 0:
        mlir::mps::StencilOp::getExplicitPadding((mlir::mps::StencilOp *)&v158);
        if (!v101)
        {
          v106 = "padding is null but paddingStyle is EXPLICT";
          goto LABEL_126;
        }
        *(_QWORD *)&v165 = mlir::mps::StencilOp::getExplicitPadding((mlir::mps::StencilOp *)&v158);
        *((_QWORD *)&v165 + 1) = v102;
        if (!(_BYTE)v102)
          break;
        v103 = mlir::Attribute::cast<mlir::ElementsAttr>((uint64_t **)&v165);
        mlir::getIntValues<unsigned long long>((uint64_t)v103, v104, (uint64_t)v173, 1);
        goto LABEL_96;
      case 1:
        llvm::SmallVectorImpl<unsigned long long>::resize((uint64_t)v173, 8uLL, 0);
        goto LABEL_96;
      case 2:
      case 4:
        llvm::SmallVectorImpl<unsigned long long>::resize((uint64_t)v173, 8uLL, 0);
LABEL_96:
        v105 = (char *)v173[0] + 16 * (v72 < 2);
        if (*v105 || v105[1])
        {
          v106 = "Channel padding is not supported on ANE";
LABEL_126:
          v55 = mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(a4, &v158, v106);
LABEL_127:
          if (v173[0] != v174)
            free(v173[0]);
          if (v176 != v178)
            free(v176);
          if (v179 != v181)
            free(v179);
          goto LABEL_133;
        }
        if ((_DWORD)v177)
        {
          v107 = v176;
          v108 = 8 * v177;
          while (*v107 == 1)
          {
            ++v107;
            v108 -= 8;
            if (!v108)
              goto LABEL_104;
          }
          v106 = "Dilated Stencil not supported on ANE";
          goto LABEL_126;
        }
LABEL_104:
        if ((_DWORD)v180)
        {
          v109 = 8 * v180;
          v110 = v179;
          while (*v110 == 1)
          {
            ++v110;
            v109 -= 8;
            if (!v109)
              goto LABEL_108;
          }
          v106 = "Strided Stencil not supported on ANE";
          goto LABEL_126;
        }
LABEL_108:
        v165 = *((_OWORD *)v179 + 1);
        v111 = 8 * (v72 > 1);
        v166 = *(_QWORD *)&v179[v111];
        llvm::SmallVector<unsigned long long,3u>::SmallVector(&v170, &v165, 3);
        v165 = *((_OWORD *)v182 + 1);
        v166 = *(_QWORD *)&v182[v111];
        llvm::SmallVector<unsigned long long,3u>::SmallVector(&v167, &v165, 3);
        v112 = *((_OWORD *)v173[0] + 3);
        v161 = *((_OWORD *)v173[0] + 2);
        v162 = v112;
        v163 = *((_QWORD *)v173[0] + 2 * (v72 > 1));
        v164 = *((_QWORD *)v173[0] + ((2 * (v72 > 1)) | 1u));
        llvm::SmallVector<long long,6u>::SmallVector(&v165, &v161, 6);
        *(_QWORD *)&v161 = 3;
        IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
        v149 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v161, 1, IntegerType, 0);
        *(_QWORD *)&v161 = 6;
        v114 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
        v147 = (char *)v5;
        v148 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v161, 1, v114, 0);
        if (v72 >= 2)
        {
          v115 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
          llvm::SmallVector<long long,5u>::SmallVector<long long,void>(&v161, v115, v116);
          v159 = 1;
          llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v161, v161 + 16, &v159);
          v144 = *(_QWORD *)(v158 + 24);
          v117 = (void *)v161;
          v118 = (mlir::AffineMap *)DWORD2(v161);
          ElementTypeOrSelf = mlir::getElementTypeOrSelf(v5);
          v159 = mlir::MemRefType::get(v117, v118, ElementTypeOrSelf, 0, 0, 0);
          v147 = (char *)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v144, &v159, &v157)- 16;
          if ((__int128 *)v161 != &v162)
            free((void *)v161);
        }
        v120 = *(_QWORD *)(v158 + 24);
        v121 = mlir::Type::cast<mlir::ShapedType>(&v149);
        *(_QWORD *)&v161 = mlir::DenseElementsAttr::getFromRawBuffer(v121, v122, v170, 8 * v171, 8, 1, 0);
        v123 = mlir::Type::cast<mlir::ShapedType>(&v148);
        v159 = mlir::DenseElementsAttr::getFromRawBuffer(v123, v124, v165, 8 * DWORD2(v165), 8, 1, 0);
        v125 = mlir::Type::cast<mlir::ShapedType>(&v149);
        v146 = mlir::DenseElementsAttr::getFromRawBuffer(v125, v126, v167, 8 * v168, 8, 1, 0);
        UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)(a4 + 8), v127);
        v147 = (char *)mlir::OpBuilder::create<mlir::anec::AveragePool,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::UnitAttr>((mlir::UnknownLoc **)(a4 + 8), v120, (uint64_t *)&v147, (uint64_t *)&v161, &v159, &v146, &UnitAttr)- 16;
        v128 = *((_QWORD *)v167 + 1) * *(_QWORD *)v167 * *((_QWORD *)v167 + 2);
        v129 = *(mlir::MLIRContext **)(v158 + 24);
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
        *(float *)&v161 = (float)v128;
        if (v132)
        {
          v147 = v133;
          if (v72 >= 2)
          {
            v134 = *(_QWORD *)(v158 + 24);
            v135 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v150);
            v137 = v136;
            v138 = mlir::getElementTypeOrSelf((uint64_t)v147);
            *(_QWORD *)&v161 = mlir::MemRefType::get(v135, v137, v138, 0, 0, 0);
            v133 = (char *)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v134, (uint64_t *)&v161, (uint64_t *)&v147)- 16;
            v147 = v133;
          }
          v139 = (unsigned int *)v158;
          *(_QWORD *)&v161 = v133;
          mlir::ValueRange::ValueRange(v160, (uint64_t)&v161, 1uLL);
          mlir::ConversionPatternRewriter::replaceOp(a4, v139, v160[0], v160[1]);
          if ((uint64_t *)v165 != &v166)
            free((void *)v165);
          if (v167 != &v169)
            free(v167);
          if (v170 != &v172)
            free(v170);
          v55 = 1;
          goto LABEL_127;
        }
        break;
      default:
        v106 = "Unsupported paddingStyle";
        goto LABEL_126;
    }
  }
  v141 = std::__throw_bad_optional_access[abi:nn180100]();
  return mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(v141, v142, v143);
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(uint64_t a1, uint64_t *a2, _BYTE *a3)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  _BYTE *v7;
  char v8;
  char v9;
  _QWORD *v10;

  v3 = 1;
  v9 = 1;
  if (*a3)
  {
    v7 = a3;
    v3 = 3;
  }
  v8 = v3;
  v4 = *a2;
  v10 = &v7;
  v5 = *(_QWORD *)(a1 + 16);
  if (!v5)
    return 0;
  result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v5 + 64))(v5, *(_QWORD *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(mlir::mps::StencilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StencilOp &>(mlir::mps::StencilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

_QWORD *llvm::SmallVector<unsigned long long,3u>::SmallVector(_QWORD *a1, const void *a2, uint64_t a3)
{
  size_t v6;
  unsigned int v7;

  *a1 = a1 + 2;
  a1[1] = 0x300000000;
  v6 = 8 * a3;
  if ((unint64_t)(8 * a3) >= 0x19)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, a1 + 2, (8 * a3) >> 3, 8);
    v7 = *((_DWORD *)a1 + 2);
    if (!a3)
      goto LABEL_6;
    goto LABEL_5;
  }
  v7 = 0;
  if (a3)
  {
LABEL_5:
    memcpy((void *)(*a1 + 8 * v7), a2, v6);
    v7 = *((_DWORD *)a1 + 2);
  }
LABEL_6:
  *((_DWORD *)a1 + 2) = v7 + (v6 >> 3);
  return a1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::AveragePool,mlir::Value &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::UnitAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t *Context;
  uint64_t v15;
  char v16;
  mlir::GenericProgramPoint *v17;
  mlir::GenericProgramPoint *v18;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.average_pool", (const unsigned __int8 *)0x11, Context);
  if (!v16)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"anec.average_pool";
    v23[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::anec::AveragePool::build(a1, (uint64_t)v25, *a3, *a4, *a5, *a6, *a7);
  v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((_QWORD *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::AveragePool,void>::id)
    v18 = v17;
  else
    v18 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::CeilOp,mlir::anec::Ceil>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E29BB0;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_18077C19C()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::CeilOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CeilOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::CeilOpGenericAdaptorBase::CeilOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CeilOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::CeilOpGenericAdaptorBase::CeilOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::CeilOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CeilOp &>(mlir::mps::CeilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CeilOp &>(mlir::mps::CeilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::CeilOp,mlir::anec::Ceil>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::Ceil,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CeilOp &>(mlir::mps::CeilOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::CeilOp,mlir::anec::Ceil>::matchAndRewriteWithStaticShapes(mlir::mps::CeilOp,mlir::mps::CeilOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Ceil,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.ceil", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.ceil";
    v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Ceil,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ErfOp,mlir::anec::Erf>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E29A60;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_18077CD94()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::ErfOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ErfOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ErfOpGenericAdaptorBase::ErfOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ErfOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ErfOpGenericAdaptorBase::ErfOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ErfOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ErfOp &>(mlir::mps::ErfOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ErfOp &>(mlir::mps::ErfOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ErfOp,mlir::anec::Erf>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::Erf,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ErfOp &>(mlir::mps::ErfOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ErfOp,mlir::anec::Erf>::matchAndRewriteWithStaticShapes(mlir::mps::ErfOp,mlir::mps::ErfOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Erf,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.erf", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.erf";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Erf,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ExponentBase2Op,mlir::anec::Exp2>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E298A0;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_18077D98C()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentBase2Op>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentBase2Op>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ExponentBase2OpGenericAdaptorBase::ExponentBase2OpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExponentBase2Op>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ExponentBase2OpGenericAdaptorBase::ExponentBase2OpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ExponentBase2Op>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentBase2Op &>(mlir::mps::ExponentBase2Op &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentBase2Op &>(mlir::mps::ExponentBase2Op &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ExponentBase2Op,mlir::anec::Exp2>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::Exp2,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExponentBase2Op &>(mlir::mps::ExponentBase2Op &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::ExponentBase2Op,mlir::anec::Exp2>::matchAndRewriteWithStaticShapes(mlir::mps::ExponentBase2Op,mlir::mps::ExponentBase2OpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Exp2,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.exp2", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.exp2";
    v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Exp2,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::FloorOp,mlir::anec::Floor>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E29EC0;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_18077E584()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::FloorOpGenericAdaptorBase::FloorOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::FloorOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::FloorOpGenericAdaptorBase::FloorOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::FloorOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorOp &>(mlir::mps::FloorOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorOp &>(mlir::mps::FloorOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::FloorOp,mlir::anec::Floor>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::Floor,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FloorOp &>(mlir::mps::FloorOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::FloorOp,mlir::anec::Floor>::matchAndRewriteWithStaticShapes(mlir::mps::FloorOp,mlir::mps::FloorOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Floor,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.floor", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.floor";
    v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Floor,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SignOp,mlir::anec::Sign>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E29D00;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_18077F17C()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::SignOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SignOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SignOpGenericAdaptorBase::SignOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SignOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SignOpGenericAdaptorBase::SignOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SignOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SignOp &>(mlir::mps::SignOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SignOp &>(mlir::mps::SignOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SignOp,mlir::anec::Sign>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::Sign,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SignOp &>(mlir::mps::SignOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SignOp,mlir::anec::Sign>::matchAndRewriteWithStaticShapes(mlir::mps::SignOp,mlir::mps::SignOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Sign,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.sign", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.sign";
    v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Sign,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TruncateOp,mlir::anec::Trunc>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E296E0;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_18077FD74()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::TruncateOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::TruncateOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::TruncateOpGenericAdaptorBase::TruncateOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::TruncateOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::TruncateOpGenericAdaptorBase::TruncateOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::TruncateOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TruncateOp &>(mlir::mps::TruncateOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TruncateOp &>(mlir::mps::TruncateOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TruncateOp,mlir::anec::Trunc>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::Trunc,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TruncateOp &>(mlir::mps::TruncateOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::TruncateOp,mlir::anec::Trunc>::matchAndRewriteWithStaticShapes(mlir::mps::TruncateOp,mlir::mps::TruncateOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Trunc,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.trunc", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.trunc";
    v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Trunc,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

_QWORD *mlir::`anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)2>::~ConvertReductionA14Plus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)2>::~ConvertReductionA14Plus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMaxOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMaxOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[56];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ReductionMaxOpGenericAdaptorBase::ReductionMaxOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[56];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ReductionMaxOpGenericAdaptorBase::ReductionMaxOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReductionMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 56);
  v9 = *(_QWORD *)(a3 + 64);
  v36 = v8;
  v37 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v28;
      v35 = *(_QWORD *)(a3 + 64);
      v29 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v37;
    if (v36 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  mlir::GenericProgramPoint *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24[2];
  unsigned int *v25;
  uint64_t v26[4];
  __int16 v27;
  uint64_t *v28;
  uint64_t v29[3];

  v29[2] = *MEMORY[0x1E0C80C00];
  v25 = (unsigned int *)a2;
  v6 = *(_QWORD *)(a3 + 64);
  v29[0] = *(_QWORD *)(a3 + 56);
  v29[1] = v6;
  v24[1] = v7;
  if ((_BYTE)v7)
  {
    v8 = *(_QWORD *)(a2 + 24);
    v26[0] = mlir::ValueRange::dereference_iterator(v29, 0);
    v9 = mlir::OpBuilder::create<mlir::anec::ReduceMax,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v8, v26, v24);
    if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v25))
    {
      v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v25) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v10)
        goto LABEL_12;
      v11 = *v10;
      v12 = mlir::TypeID::get<mlir::ShapedType>();
      v13 = *(unsigned int *)(v11 + 16);
      if (!(_DWORD)v13)
        goto LABEL_12;
      v14 = *(_QWORD **)(v11 + 8);
      v15 = &v14[2 * v13];
      do
      {
        v16 = v13 >> 1;
        v17 = &v14[2 * (v13 >> 1)];
        v19 = *v17;
        v18 = v17 + 2;
        v13 += ~(v13 >> 1);
        if (v19 < v12)
          v14 = v18;
        else
          v13 = v16;
      }
      while (v13);
      if (v14 != v15 && *v14 == v12)
        v20 = v14[1];
      else
LABEL_12:
        v20 = 0;
      v26[0] = (uint64_t)v10;
      v26[1] = v20;
    }
    v26[0] = (uint64_t)v9 - 16;
    v21 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, v25, (uint64_t)v26, 1);
  }
  else
  {
    v26[0] = (uint64_t)"failed to convert operand axes";
    v27 = 259;
    v28 = v26;
    v22 = *(_QWORD *)(a4 + 16);
    if (v22 && mlir::RewriterBase::Listener::classof(v22))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(_QWORD *)v22 + 64))(v22, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v28);
    else
      return 0;
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

unint64_t mlir::`anonymous namespace'::convertAxes(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int64x2_t *v19;
  unint64_t v20;
  _QWORD *v21;
  unint64_t SortedUniquePromotedPositiveAxesAttr;
  char v23;
  unsigned __int8 v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  unint64_t v29;
  int64x2_t v30;
  int64x2_t *v31;
  int64x2_t v32;
  int64x2_t v33;
  uint64_t v34;
  uint64_t Context;
  uint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  unint64_t v44;
  unint64_t *v45;
  _QWORD *v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v51;
  void *v52;
  uint64_t v53;
  _BYTE v54[48];
  _QWORD v55[3];

  v55[2] = *MEMORY[0x1E0C80C00];
  v55[0] = a1;
  v55[1] = a2;
  v51 = 0;
  v5 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v52 = v5;
  v53 = v15;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v52);
  v17 = v16;
  v51 = v16;
  if (a2 > 1)
  {
    v21 = (_QWORD *)mlir::ValueRange::dereference_iterator(v55, 1);
    SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(v21, v17, 0, 0);
    if (v23)
      v24 = SortedUniquePromotedPositiveAxesAttr;
    else
      v24 = 0;
    if (v23)
      v25 = SortedUniquePromotedPositiveAxesAttr & 0xFFFFFFFFFFFFFF00;
    else
      v25 = 0;
    return v25 | v24;
  }
  v52 = v54;
  v53 = 0x600000000;
  if (!v16)
    goto LABEL_31;
  if (v16 < 7)
  {
    v18 = 0;
    v19 = (int64x2_t *)v54;
    v20 = v16;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v54, v16, 8);
    v18 = v53;
    v19 = (int64x2_t *)v52;
    v20 = v17 - v53;
    if (v17 == v53)
      goto LABEL_24;
  }
  bzero((char *)v19 + 8 * v18, 8 * v20);
LABEL_24:
  LODWORD(v53) = v17;
  if (!(_DWORD)v17)
    goto LABEL_31;
  v26 = (v17 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v26 < 3)
  {
    v27 = 0;
    v28 = (uint64_t *)v19;
    do
LABEL_30:
      *v28++ = v27++;
    while (v28 != (uint64_t *)((char *)v19 + 8 * v17));
    goto LABEL_31;
  }
  v29 = v26 + 1;
  v27 = (v26 + 1) & 0x3FFFFFFFFFFFFFFCLL;
  v28 = &v19->i64[v27];
  v30 = (int64x2_t)xmmword_181233120;
  v31 = v19 + 1;
  v32 = vdupq_n_s64(2uLL);
  v33 = vdupq_n_s64(4uLL);
  v34 = v27;
  do
  {
    v31[-1] = v30;
    *v31 = vaddq_s64(v30, v32);
    v30 = vaddq_s64(v30, v33);
    v31 += 2;
    v34 -= 4;
  }
  while (v34);
  if (v29 != v27)
    goto LABEL_30;
LABEL_31:
  Context = mlir::Attribute::getContext((mlir::Attribute *)(a3 + 24));
  v36 = mlir::IntegerType::get(Context, 0x40u, 2u);
  v37 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v51, 1, v36, 0);
  v38 = v37;
  if (!v37)
    goto LABEL_40;
  v39 = *v37;
  v40 = mlir::TypeID::get<mlir::ShapedType>();
  v41 = *(unsigned int *)(v39 + 16);
  if (!(_DWORD)v41)
    goto LABEL_40;
  v42 = *(_QWORD **)(v39 + 8);
  v43 = &v42[2 * v41];
  do
  {
    v44 = v41 >> 1;
    v45 = &v42[2 * (v41 >> 1)];
    v47 = *v45;
    v46 = v45 + 2;
    v41 += ~(v41 >> 1);
    if (v47 < v40)
      v42 = v46;
    else
      v41 = v44;
  }
  while (v41);
  if (v42 != v43 && *v42 == v40)
    v48 = v42[1];
  else
LABEL_40:
    v48 = 0;
  v49 = mlir::DenseElementsAttr::getFromRawBuffer(v38, v48, v52, 8 * v53, 8, 1, 0);
  v24 = v49;
  v25 = v49 & 0xFFFFFFFFFFFFFF00;
  if (v52 != v54)
    free(v52);
  return v25 | v24;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ReduceMax,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reduce_max", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.reduce_max";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ReduceMax::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ReduceMax,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

_QWORD *mlir::`anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)2>::~ConvertReductionA14Plus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)2>::~ConvertReductionA14Plus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReductionMeanOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 48);
  v9 = *(_QWORD *)(a3 + 56);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      v29 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  mlir::GenericProgramPoint *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24[2];
  unsigned int *v25;
  uint64_t v26[4];
  __int16 v27;
  uint64_t *v28;
  uint64_t v29[3];

  v29[2] = *MEMORY[0x1E0C80C00];
  v25 = (unsigned int *)a2;
  v6 = *(_QWORD *)(a3 + 56);
  v29[0] = *(_QWORD *)(a3 + 48);
  v29[1] = v6;
  v24[1] = v7;
  if ((_BYTE)v7)
  {
    v8 = *(_QWORD *)(a2 + 24);
    v26[0] = mlir::ValueRange::dereference_iterator(v29, 0);
    v9 = mlir::OpBuilder::create<mlir::anec::ReduceAvg,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v8, v26, v24);
    if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v25))
    {
      v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v25) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v10)
        goto LABEL_12;
      v11 = *v10;
      v12 = mlir::TypeID::get<mlir::ShapedType>();
      v13 = *(unsigned int *)(v11 + 16);
      if (!(_DWORD)v13)
        goto LABEL_12;
      v14 = *(_QWORD **)(v11 + 8);
      v15 = &v14[2 * v13];
      do
      {
        v16 = v13 >> 1;
        v17 = &v14[2 * (v13 >> 1)];
        v19 = *v17;
        v18 = v17 + 2;
        v13 += ~(v13 >> 1);
        if (v19 < v12)
          v14 = v18;
        else
          v13 = v16;
      }
      while (v13);
      if (v14 != v15 && *v14 == v12)
        v20 = v14[1];
      else
LABEL_12:
        v20 = 0;
      v26[0] = (uint64_t)v10;
      v26[1] = v20;
    }
    v26[0] = (uint64_t)v9 - 16;
    v21 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, v25, (uint64_t)v26, 1);
  }
  else
  {
    v26[0] = (uint64_t)"failed to convert operand axes";
    v27 = 259;
    v28 = v26;
    v22 = *(_QWORD *)(a4 + 16);
    if (v22 && mlir::RewriterBase::Listener::classof(v22))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(_QWORD *)v22 + 64))(v22, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v28);
    else
      return 0;
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ReduceAvg,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reduce_avg", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.reduce_avg";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ReduceAvg::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ReduceAvg,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

_QWORD *mlir::`anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)2>::~ConvertReductionA14Plus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)2>::~ConvertReductionA14Plus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMinOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMinOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[56];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ReductionMinOpGenericAdaptorBase::ReductionMinOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMinOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[56];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ReductionMinOpGenericAdaptorBase::ReductionMinOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReductionMinOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 56);
  v9 = *(_QWORD *)(a3 + 64);
  v36 = v8;
  v37 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v28;
      v35 = *(_QWORD *)(a3 + 64);
      v29 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v37;
    if (v36 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  mlir::GenericProgramPoint *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24[2];
  unsigned int *v25;
  uint64_t v26[4];
  __int16 v27;
  uint64_t *v28;
  uint64_t v29[3];

  v29[2] = *MEMORY[0x1E0C80C00];
  v25 = (unsigned int *)a2;
  v6 = *(_QWORD *)(a3 + 64);
  v29[0] = *(_QWORD *)(a3 + 56);
  v29[1] = v6;
  v24[1] = v7;
  if ((_BYTE)v7)
  {
    v8 = *(_QWORD *)(a2 + 24);
    v26[0] = mlir::ValueRange::dereference_iterator(v29, 0);
    v9 = mlir::OpBuilder::create<mlir::anec::ReduceMin,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v8, v26, v24);
    if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v25))
    {
      v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v25) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v10)
        goto LABEL_12;
      v11 = *v10;
      v12 = mlir::TypeID::get<mlir::ShapedType>();
      v13 = *(unsigned int *)(v11 + 16);
      if (!(_DWORD)v13)
        goto LABEL_12;
      v14 = *(_QWORD **)(v11 + 8);
      v15 = &v14[2 * v13];
      do
      {
        v16 = v13 >> 1;
        v17 = &v14[2 * (v13 >> 1)];
        v19 = *v17;
        v18 = v17 + 2;
        v13 += ~(v13 >> 1);
        if (v19 < v12)
          v14 = v18;
        else
          v13 = v16;
      }
      while (v13);
      if (v14 != v15 && *v14 == v12)
        v20 = v14[1];
      else
LABEL_12:
        v20 = 0;
      v26[0] = (uint64_t)v10;
      v26[1] = v20;
    }
    v26[0] = (uint64_t)v9 - 16;
    v21 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, v25, (uint64_t)v26, 1);
  }
  else
  {
    v26[0] = (uint64_t)"failed to convert operand axes";
    v27 = 259;
    v28 = v26;
    v22 = *(_QWORD *)(a4 + 16);
    if (v22 && mlir::RewriterBase::Listener::classof(v22))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(_QWORD *)v22 + 64))(v22, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v28);
    else
      return 0;
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ReduceMin,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reduce_min", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.reduce_min";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ReduceMin::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ReduceMin,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

_QWORD *mlir::`anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)2>::~ConvertReductionA14Plus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReductionA14Plus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)2>::~ConvertReductionA14Plus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionSumOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionSumOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ReductionSumOpGenericAdaptorBase::ReductionSumOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionSumOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ReductionSumOpGenericAdaptorBase::ReductionSumOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReductionSumOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 48);
  v9 = *(_QWORD *)(a3 + 56);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      v29 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  mlir::GenericProgramPoint *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24[2];
  unsigned int *v25;
  uint64_t v26[4];
  __int16 v27;
  uint64_t *v28;
  uint64_t v29[3];

  v29[2] = *MEMORY[0x1E0C80C00];
  v25 = (unsigned int *)a2;
  v6 = *(_QWORD *)(a3 + 56);
  v29[0] = *(_QWORD *)(a3 + 48);
  v29[1] = v6;
  v24[1] = v7;
  if ((_BYTE)v7)
  {
    v8 = *(_QWORD *)(a2 + 24);
    v26[0] = mlir::ValueRange::dereference_iterator(v29, 0);
    v9 = mlir::OpBuilder::create<mlir::anec::ReduceSum,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v8, v26, v24);
    if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v25))
    {
      v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v25) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v10)
        goto LABEL_12;
      v11 = *v10;
      v12 = mlir::TypeID::get<mlir::ShapedType>();
      v13 = *(unsigned int *)(v11 + 16);
      if (!(_DWORD)v13)
        goto LABEL_12;
      v14 = *(_QWORD **)(v11 + 8);
      v15 = &v14[2 * v13];
      do
      {
        v16 = v13 >> 1;
        v17 = &v14[2 * (v13 >> 1)];
        v19 = *v17;
        v18 = v17 + 2;
        v13 += ~(v13 >> 1);
        if (v19 < v12)
          v14 = v18;
        else
          v13 = v16;
      }
      while (v13);
      if (v14 != v15 && *v14 == v12)
        v20 = v14[1];
      else
LABEL_12:
        v20 = 0;
      v26[0] = (uint64_t)v10;
      v26[1] = v20;
    }
    v26[0] = (uint64_t)v9 - 16;
    v21 = 1;
    mlir::ConversionPatternRewriter::replaceOp(a4, v25, (uint64_t)v26, 1);
  }
  else
  {
    v26[0] = (uint64_t)"failed to convert operand axes";
    v27 = 259;
    v28 = v26;
    v22 = *(_QWORD *)(a4 + 16);
    if (v22 && mlir::RewriterBase::Listener::classof(v22))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(_QWORD *)v22 + 64))(v22, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v28);
    else
      return 0;
  }
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ReduceSum,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reduce_sum", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.reduce_sum";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ReduceSum::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ReduceSum,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

_QWORD *mlir::`anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::~ConvertReductionA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::~ConvertReductionA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  char v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t IndexFromDim;
  char v34;
  unint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t ArgAttrsAttr;
  uint64_t IntegerType;
  uint64_t *v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t StringAttr;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  unint64_t v50;
  unint64_t *v51;
  _QWORD *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int *v57;
  unsigned int *v58;
  uint64_t v59;
  void *v60;
  unsigned int *v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  unint64_t v70;
  unint64_t *v71;
  _QWORD *v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  _QWORD *v80;
  _QWORD *v81;
  unint64_t v82;
  unint64_t *v83;
  _QWORD *v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  mlir::Operation ***v89;
  uint64_t v90;
  char *v91;
  _QWORD v92[2];
  unsigned int *v93;
  _QWORD v94[4];
  __int16 v95;
  void *v96;
  uint64_t v97;
  _WORD v98[32];
  uint64_t v99;
  void *v100;
  uint64_t v101;
  _BYTE v102[48];
  void *v103;
  uint64_t v104;
  _BYTE v105[48];
  _OWORD *v106;
  uint64_t v107;
  _OWORD v108[3];
  void **v109;
  uint64_t v110;
  _BYTE v111[48];
  uint64_t v112[4];

  v112[2] = *MEMORY[0x1E0C80C00];
  v93 = (unsigned int *)a2;
  v6 = *(_QWORD *)(a3 + 64);
  v112[0] = *(_QWORD *)(a3 + 56);
  v112[1] = v6;
  if (!v8)
  {
    v96 = "failed to convert operand axes";
    v98[8] = 259;
    v109 = &v96;
    v55 = *(_QWORD *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55))
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v55 + 64))(v55, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v109);
      return 0;
    }
    return v55;
  }
  v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v93))
  {
    v57 = v93;
    v96 = &v93;
    v55 = *(_QWORD *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55))
      return 0;
    }
    return v55;
  }
  v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v93) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_12;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_12;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_12:
    v20 = 0;
  v109 = (void **)v111;
  v110 = 0x600000000;
  if (!v9)
    goto LABEL_22;
  v21 = *v9;
  v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  v23 = *(unsigned int *)(v21 + 16);
  if (!(_DWORD)v23)
    goto LABEL_22;
  v24 = *(_QWORD **)(v21 + 8);
  v25 = &v24[2 * v23];
  do
  {
    v26 = v23 >> 1;
    v27 = &v24[2 * (v23 >> 1)];
    v29 = *v27;
    v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22)
      v24 = v28;
    else
      v23 = v26;
  }
  while (v23);
  if (v24 != v25 && *v24 == v22)
    v30 = v24[1];
  else
LABEL_22:
    v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v109, 1);
  v106 = v108;
  memset(v108, 0, sizeof(v108));
  v107 = 0x600000006;
  v103 = v105;
  memset_pattern16(v105, &unk_181233190, 0x18uLL);
  v104 = 0x600000003;
  v100 = v102;
  memset_pattern16(v102, &unk_181233190, 0x18uLL);
  v101 = 0x600000003;
  v92[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v92[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v92);
  IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if ((_DWORD)v110)
    {
      v35 = IndexFromDim;
      v36 = (uint64_t *)v109;
      v37 = 8 * v110;
      while (1)
      {
        v38 = *v36;
        v94[0] = v38;
        if (v38 == v35)
          break;
        if (v38 <= 1)
        {
          v61 = v93;
          v96 = &v93;
          v55 = *(_QWORD *)(a4 + 16);
          if (!v55)
            goto LABEL_89;
          if (mlir::RewriterBase::Listener::classof(v55))
          {
            v59 = *((_QWORD *)v61 + 3);
            goto LABEL_54;
          }
          goto LABEL_56;
        }
        ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v92);
        *((_QWORD *)v100 + v38 - 2) = *(_QWORD *)(ArgAttrsAttr + 8 * v38);
        ++v36;
        v37 -= 8;
        if (!v37)
          goto LABEL_29;
      }
      v58 = v93;
      v96 = v94;
      v97 = (uint64_t)&v93;
      v55 = *(_QWORD *)(a4 + 16);
      if (!v55)
        goto LABEL_89;
      if (mlir::RewriterBase::Listener::classof(v55))
      {
        v59 = *((_QWORD *)v58 + 3);
LABEL_54:
        v55 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(_QWORD *)v55 + 64))(v55, v59, v60, &v96);
        goto LABEL_89;
      }
LABEL_56:
      v55 = 0;
    }
    else
    {
LABEL_29:
      v96 = v98;
      v97 = 0x400000000;
      v99 = 4;
      v94[0] = 3;
      IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v94, 1, IntegerType, 0);
      v94[0] = 6;
      v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      v43 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v94, 1, v42, 0);
      v94[0] = "ksize";
      v95 = 259;
      StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
      if (v41)
      {
        v45 = *v41;
        v46 = mlir::TypeID::get<mlir::ShapedType>();
        v47 = *(unsigned int *)(v45 + 16);
        if ((_DWORD)v47)
        {
          v48 = *(_QWORD **)(v45 + 8);
          v49 = &v48[2 * v47];
          do
          {
            v50 = v47 >> 1;
            v51 = &v48[2 * (v47 >> 1)];
            v53 = *v51;
            v52 = v51 + 2;
            v47 += ~(v47 >> 1);
            if (v53 < v46)
              v48 = v52;
            else
              v47 = v50;
          }
          while (v47);
          if (v48 == v49)
          {
            v54 = 0;
          }
          else if (*v48 == v46)
          {
            v54 = v48[1];
          }
          else
          {
            v54 = 0;
          }
        }
        else
        {
          v54 = 0;
        }
      }
      else
      {
        v54 = 0;
      }
      v62 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v100, 8 * v101, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v96, StringAttr, v62);
      v94[0] = "stride";
      v95 = 259;
      v63 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
      if (v41)
      {
        v64 = v43;
        v65 = *v41;
        v66 = mlir::TypeID::get<mlir::ShapedType>();
        v67 = *(unsigned int *)(v65 + 16);
        if ((_DWORD)v67)
        {
          v68 = *(_QWORD **)(v65 + 8);
          v69 = &v68[2 * v67];
          do
          {
            v70 = v67 >> 1;
            v71 = &v68[2 * (v67 >> 1)];
            v73 = *v71;
            v72 = v71 + 2;
            v67 += ~(v67 >> 1);
            if (v73 < v66)
              v68 = v72;
            else
              v67 = v70;
          }
          while (v67);
          v43 = v64;
          if (v68 == v69)
          {
            v74 = 0;
          }
          else if (*v68 == v66)
          {
            v74 = v68[1];
          }
          else
          {
            v74 = 0;
          }
        }
        else
        {
          v74 = 0;
          v43 = v64;
        }
      }
      else
      {
        v74 = 0;
      }
      v75 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v74, v103, 8 * v104, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v96, v63, v75);
      v94[0] = "padding";
      v95 = 259;
      v76 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
      if (v43
        && (v77 = *v43, v78 = mlir::TypeID::get<mlir::ShapedType>(), v79 = *(unsigned int *)(v77 + 16), (_DWORD)v79))
      {
        v80 = *(_QWORD **)(v77 + 8);
        v81 = &v80[2 * v79];
        do
        {
          v82 = v79 >> 1;
          v83 = &v80[2 * (v79 >> 1)];
          v85 = *v83;
          v84 = v83 + 2;
          v79 += ~(v79 >> 1);
          if (v85 < v78)
            v80 = v84;
          else
            v79 = v82;
        }
        while (v79);
        if (v80 != v81 && *v80 == v78)
          v86 = v80[1];
        else
          v86 = 0;
      }
      else
      {
        v86 = 0;
      }
      v87 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v86, v106, 8 * v107, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v96, v76, v87);
      v94[0] = mlir::ValueRange::dereference_iterator(v112, 0);
      v91 = (char *)mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *((_QWORD *)v93 + 3), (uint64_t)v94, (uint64_t)&v96)- 16;
      mlir::ConversionPatternRewriter::replaceOp(a4, v93, (uint64_t)&v91, 1);
      if (v96 != v98)
        free(v96);
      v55 = 1;
    }
LABEL_89:
    if (v100 != v102)
      free(v100);
    if (v103 != v105)
      free(v103);
    if (v106 != v108)
      free(v106);
    if (v109 != (void **)v111)
      free(v109);
    return v55;
  }
  v89 = (mlir::Operation ***)std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, "to MaxPool, AveragePool or Conv for A13 and below on ane is not supported \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  mlir::Diagnostic *v11;
  mlir::Diagnostic *v12;
  unint64_t v14;
  BOOL v15;
  char *v16;
  int v17;
  uint64_t v18;

  v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = **a1;
  v17 = 2;
  v18 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v17;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v14 = v7 + 1;
    v15 = v5 + 24 * v7 > (unint64_t)&v17;
    if (v5 <= (unint64_t)&v17 && v15)
    {
      v16 = (char *)&v17 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v16[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v17;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  v12 = mlir::Diagnostic::operator<<(v11, (mlir::Operation *)*a1[1]);
  return mlir::Diagnostic::operator<<((uint64_t)v12, "is not supported for A13 and below\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, "\n");
}

_QWORD *mlir::`anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::~ConvertReductionA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::~ConvertReductionA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  char v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t IndexFromDim;
  char v34;
  unint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t ArgAttrsAttr;
  uint64_t IntegerType;
  uint64_t *v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t StringAttr;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  unint64_t v50;
  unint64_t *v51;
  _QWORD *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int *v57;
  unsigned int *v58;
  uint64_t v59;
  void *v60;
  unsigned int *v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  unint64_t v70;
  unint64_t *v71;
  _QWORD *v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  _QWORD *v80;
  _QWORD *v81;
  unint64_t v82;
  unint64_t *v83;
  _QWORD *v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  mlir::MLIRContext *v88;
  uint64_t UnitAttr;
  mlir::Operation ***v91;
  uint64_t v92;
  char *v93;
  _QWORD v94[2];
  unsigned int *v95;
  _QWORD v96[4];
  __int16 v97;
  void *v98;
  uint64_t v99;
  _WORD v100[32];
  uint64_t v101;
  void *v102;
  uint64_t v103;
  _BYTE v104[48];
  void *v105;
  uint64_t v106;
  _BYTE v107[48];
  _OWORD *v108;
  uint64_t v109;
  _OWORD v110[3];
  void **v111;
  uint64_t v112;
  _BYTE v113[48];
  uint64_t v114[4];

  v114[2] = *MEMORY[0x1E0C80C00];
  v95 = (unsigned int *)a2;
  v6 = *(_QWORD *)(a3 + 56);
  v114[0] = *(_QWORD *)(a3 + 48);
  v114[1] = v6;
  if (!v8)
  {
    v98 = "failed to convert operand axes";
    v100[8] = 259;
    v111 = &v98;
    v55 = *(_QWORD *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55))
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v55 + 64))(v55, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v111);
      return 0;
    }
    return v55;
  }
  v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v95))
  {
    v57 = v95;
    v98 = &v95;
    v55 = *(_QWORD *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55))
      return 0;
    }
    return v55;
  }
  v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_12;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_12;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_12:
    v20 = 0;
  v111 = (void **)v113;
  v112 = 0x600000000;
  if (!v9)
    goto LABEL_22;
  v21 = *v9;
  v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  v23 = *(unsigned int *)(v21 + 16);
  if (!(_DWORD)v23)
    goto LABEL_22;
  v24 = *(_QWORD **)(v21 + 8);
  v25 = &v24[2 * v23];
  do
  {
    v26 = v23 >> 1;
    v27 = &v24[2 * (v23 >> 1)];
    v29 = *v27;
    v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22)
      v24 = v28;
    else
      v23 = v26;
  }
  while (v23);
  if (v24 != v25 && *v24 == v22)
    v30 = v24[1];
  else
LABEL_22:
    v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v111, 1);
  v108 = v110;
  memset(v110, 0, sizeof(v110));
  v109 = 0x600000006;
  v105 = v107;
  memset_pattern16(v107, &unk_181233190, 0x18uLL);
  v106 = 0x600000003;
  v102 = v104;
  memset_pattern16(v104, &unk_181233190, 0x18uLL);
  v103 = 0x600000003;
  v94[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v94[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v94);
  IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if ((_DWORD)v112)
    {
      v35 = IndexFromDim;
      v36 = (uint64_t *)v111;
      v37 = 8 * v112;
      while (1)
      {
        v38 = *v36;
        v96[0] = v38;
        if (v38 == v35)
          break;
        if (v38 <= 1)
        {
          v61 = v95;
          v98 = &v95;
          v55 = *(_QWORD *)(a4 + 16);
          if (!v55)
            goto LABEL_89;
          if (mlir::RewriterBase::Listener::classof(v55))
          {
            v59 = *((_QWORD *)v61 + 3);
            goto LABEL_54;
          }
          goto LABEL_56;
        }
        ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v94);
        *((_QWORD *)v102 + v38 - 2) = *(_QWORD *)(ArgAttrsAttr + 8 * v38);
        ++v36;
        v37 -= 8;
        if (!v37)
          goto LABEL_29;
      }
      v58 = v95;
      v98 = v96;
      v99 = (uint64_t)&v95;
      v55 = *(_QWORD *)(a4 + 16);
      if (!v55)
        goto LABEL_89;
      if (mlir::RewriterBase::Listener::classof(v55))
      {
        v59 = *((_QWORD *)v58 + 3);
LABEL_54:
        v55 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(_QWORD *)v55 + 64))(v55, v59, v60, &v98);
        goto LABEL_89;
      }
LABEL_56:
      v55 = 0;
    }
    else
    {
LABEL_29:
      v98 = v100;
      v99 = 0x400000000;
      v101 = 4;
      v96[0] = 3;
      IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v96, 1, IntegerType, 0);
      v96[0] = 6;
      v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      v43 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v96, 1, v42, 0);
      v96[0] = "ksize";
      v97 = 259;
      StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
      if (v41)
      {
        v45 = *v41;
        v46 = mlir::TypeID::get<mlir::ShapedType>();
        v47 = *(unsigned int *)(v45 + 16);
        if ((_DWORD)v47)
        {
          v48 = *(_QWORD **)(v45 + 8);
          v49 = &v48[2 * v47];
          do
          {
            v50 = v47 >> 1;
            v51 = &v48[2 * (v47 >> 1)];
            v53 = *v51;
            v52 = v51 + 2;
            v47 += ~(v47 >> 1);
            if (v53 < v46)
              v48 = v52;
            else
              v47 = v50;
          }
          while (v47);
          if (v48 == v49)
          {
            v54 = 0;
          }
          else if (*v48 == v46)
          {
            v54 = v48[1];
          }
          else
          {
            v54 = 0;
          }
        }
        else
        {
          v54 = 0;
        }
      }
      else
      {
        v54 = 0;
      }
      v62 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v102, 8 * v103, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v98, StringAttr, v62);
      v96[0] = "stride";
      v97 = 259;
      v63 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
      if (v41)
      {
        v64 = v43;
        v65 = *v41;
        v66 = mlir::TypeID::get<mlir::ShapedType>();
        v67 = *(unsigned int *)(v65 + 16);
        if ((_DWORD)v67)
        {
          v68 = *(_QWORD **)(v65 + 8);
          v69 = &v68[2 * v67];
          do
          {
            v70 = v67 >> 1;
            v71 = &v68[2 * (v67 >> 1)];
            v73 = *v71;
            v72 = v71 + 2;
            v67 += ~(v67 >> 1);
            if (v73 < v66)
              v68 = v72;
            else
              v67 = v70;
          }
          while (v67);
          v43 = v64;
          if (v68 == v69)
          {
            v74 = 0;
          }
          else if (*v68 == v66)
          {
            v74 = v68[1];
          }
          else
          {
            v74 = 0;
          }
        }
        else
        {
          v74 = 0;
          v43 = v64;
        }
      }
      else
      {
        v74 = 0;
      }
      v75 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v74, v105, 8 * v106, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v98, v63, v75);
      v96[0] = "padding";
      v97 = 259;
      v76 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
      if (v43
        && (v77 = *v43, v78 = mlir::TypeID::get<mlir::ShapedType>(), v79 = *(unsigned int *)(v77 + 16), (_DWORD)v79))
      {
        v80 = *(_QWORD **)(v77 + 8);
        v81 = &v80[2 * v79];
        do
        {
          v82 = v79 >> 1;
          v83 = &v80[2 * (v79 >> 1)];
          v85 = *v83;
          v84 = v83 + 2;
          v79 += ~(v79 >> 1);
          if (v85 < v78)
            v80 = v84;
          else
            v79 = v82;
        }
        while (v79);
        if (v80 != v81 && *v80 == v78)
          v86 = v80[1];
        else
          v86 = 0;
      }
      else
      {
        v86 = 0;
      }
      v87 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v86, v108, 8 * v109, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v98, v76, v87);
      v96[0] = mlir::ValueRange::dereference_iterator(v114, 0);
      UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)(a4 + 8), v88);
      mlir::NamedAttrList::set((uint64_t)&v98, (uint64_t)"inc_pad", 7, UnitAttr);
      v93 = (char *)mlir::OpBuilder::create<mlir::anec::AveragePool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *((_QWORD *)v95 + 3), (uint64_t)v96, (uint64_t)&v98)- 16;
      mlir::ConversionPatternRewriter::replaceOp(a4, v95, (uint64_t)&v93, 1);
      if (v98 != v100)
        free(v98);
      v55 = 1;
    }
LABEL_89:
    if (v102 != v104)
      free(v102);
    if (v105 != v107)
      free(v105);
    if (v108 != v110)
      free(v108);
    if (v111 != (void **)v113)
      free(v111);
    return v55;
  }
  v91 = (mlir::Operation ***)std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, "to MaxPool, AveragePool or Conv for A13 and below on ane is not supported \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  mlir::Diagnostic *v11;
  mlir::Diagnostic *v12;
  unint64_t v14;
  BOOL v15;
  char *v16;
  int v17;
  uint64_t v18;

  v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = **a1;
  v17 = 2;
  v18 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v17;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v14 = v7 + 1;
    v15 = v5 + 24 * v7 > (unint64_t)&v17;
    if (v5 <= (unint64_t)&v17 && v15)
    {
      v16 = (char *)&v17 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v16[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v17;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  v12 = mlir::Diagnostic::operator<<(v11, (mlir::Operation *)*a1[1]);
  return mlir::Diagnostic::operator<<((uint64_t)v12, "is not supported for A13 and below\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, "\n");
}

_QWORD *mlir::`anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::~ConvertReductionA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::~ConvertReductionA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  char v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t IndexFromDim;
  char v34;
  uint64_t *v35;
  uint64_t **v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t ArgAttrsAttr;
  uint64_t IntegerType;
  uint64_t *v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t StringAttr;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  unint64_t v50;
  unint64_t *v51;
  _QWORD *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int *v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int *v60;
  uint64_t v61;
  uint64_t v62;
  void *v63;
  unsigned int *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  _QWORD *v70;
  _QWORD *v71;
  unint64_t v72;
  unint64_t *v73;
  _QWORD *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  unint64_t v81;
  _QWORD *v82;
  _QWORD *v83;
  unint64_t v84;
  unint64_t *v85;
  _QWORD *v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t OperandRange;
  uint64_t *v92;
  uint64_t v93;
  uint64_t v94;
  unint64_t v95;
  unint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  unint64_t v99;
  unint64_t *v100;
  _QWORD *v101;
  unint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  char *v107;
  uint64_t v108;
  mlir::MLIRContext *v109;
  uint64_t v110;
  unsigned int *v112;
  uint64_t v113;
  mlir::Operation ***v114;
  uint64_t v115;
  uint64_t v116;
  _QWORD v117[2];
  _QWORD v118[2];
  unsigned int *v119;
  uint64_t v120;
  uint64_t GOC;
  uint64_t *v122[4];
  __int16 v123;
  void *v124;
  uint64_t v125;
  _WORD v126[32];
  uint64_t v127;
  void *v128;
  uint64_t v129;
  _BYTE v130[48];
  void *v131;
  uint64_t v132;
  _BYTE v133[48];
  _OWORD *v134;
  uint64_t v135;
  _OWORD v136[3];
  void **v137;
  uint64_t v138;
  _BYTE v139[48];
  uint64_t v140[4];

  v140[2] = *MEMORY[0x1E0C80C00];
  v119 = (unsigned int *)a2;
  v6 = *(_QWORD *)(a3 + 64);
  v140[0] = *(_QWORD *)(a3 + 56);
  v140[1] = v6;
  if (!v8)
  {
    v124 = "failed to convert operand axes";
    v126[8] = 259;
    v137 = &v124;
    v55 = *(_QWORD *)(a4 + 16);
    if (v55 && mlir::RewriterBase::Listener::classof(v55))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v55 + 64))(v55, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v137);
    return 0;
  }
  v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v119))
  {
    v57 = v119;
    v124 = &v119;
    v58 = *(_QWORD *)(a4 + 16);
    if (v58 && mlir::RewriterBase::Listener::classof(v58))
    return 0;
  }
  v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v119) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_12;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_12;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_12:
    v20 = 0;
  v118[0] = v10;
  v118[1] = v20;
  v137 = (void **)v139;
  v138 = 0x600000000;
  if (!v9)
    goto LABEL_22;
  v21 = *v9;
  v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  v23 = *(unsigned int *)(v21 + 16);
  if (!(_DWORD)v23)
    goto LABEL_22;
  v24 = *(_QWORD **)(v21 + 8);
  v25 = &v24[2 * v23];
  do
  {
    v26 = v23 >> 1;
    v27 = &v24[2 * (v23 >> 1)];
    v29 = *v27;
    v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22)
      v24 = v28;
    else
      v23 = v26;
  }
  while (v23);
  if (v24 != v25 && *v24 == v22)
    v30 = v24[1];
  else
LABEL_22:
    v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v137, 1);
  v134 = v136;
  memset(v136, 0, sizeof(v136));
  v135 = 0x600000006;
  v131 = v133;
  memset_pattern16(v133, &unk_181233190, 0x18uLL);
  v132 = 0x600000003;
  v128 = v130;
  memset_pattern16(v130, &unk_181233190, 0x18uLL);
  v129 = 0x600000003;
  v117[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v117[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v117);
  IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if ((_DWORD)v138)
    {
      v35 = (uint64_t *)IndexFromDim;
      v36 = (uint64_t **)v137;
      v37 = 8 * v138;
      while (1)
      {
        v38 = *v36;
        v122[0] = v38;
        if (v38 == v35)
          break;
        if ((uint64_t)v38 <= 1)
        {
          v64 = v119;
          v124 = &v119;
          v61 = *(_QWORD *)(a4 + 16);
          if (v61 && mlir::RewriterBase::Listener::classof(v61))
          {
            v62 = *((_QWORD *)v64 + 3);
            goto LABEL_54;
          }
          goto LABEL_55;
        }
        ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v117);
        *((_QWORD *)v128 + (_QWORD)v38 - 2) = *(_QWORD *)(ArgAttrsAttr + 8 * v38);
        ++v36;
        v37 -= 8;
        if (!v37)
          goto LABEL_29;
      }
      v60 = v119;
      v124 = v122;
      v125 = (uint64_t)&v119;
      v61 = *(_QWORD *)(a4 + 16);
      if (v61 && mlir::RewriterBase::Listener::classof(v61))
      {
        v62 = *((_QWORD *)v60 + 3);
LABEL_54:
        v59 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(_QWORD *)v61 + 64))(v61, v62, v63, &v124);
        goto LABEL_96;
      }
LABEL_55:
      v59 = 0;
    }
    else
    {
LABEL_29:
      v124 = v126;
      v125 = 0x400000000;
      v127 = 4;
      v122[0] = (uint64_t *)3;
      IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v122, 1, IntegerType, 0);
      v122[0] = (uint64_t *)6;
      v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      v43 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v122, 1, v42, 0);
      v122[0] = (uint64_t *)"ksize";
      v123 = 259;
      StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
      if (v41)
      {
        v45 = *v41;
        v46 = mlir::TypeID::get<mlir::ShapedType>();
        v47 = *(unsigned int *)(v45 + 16);
        if ((_DWORD)v47)
        {
          v48 = *(_QWORD **)(v45 + 8);
          v49 = &v48[2 * v47];
          do
          {
            v50 = v47 >> 1;
            v51 = &v48[2 * (v47 >> 1)];
            v53 = *v51;
            v52 = v51 + 2;
            v47 += ~(v47 >> 1);
            if (v53 < v46)
              v48 = v52;
            else
              v47 = v50;
          }
          while (v47);
          if (v48 == v49)
          {
            v54 = 0;
          }
          else if (*v48 == v46)
          {
            v54 = v48[1];
          }
          else
          {
            v54 = 0;
          }
        }
        else
        {
          v54 = 0;
        }
      }
      else
      {
        v54 = 0;
      }
      v65 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v128, 8 * v129, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v124, StringAttr, v65);
      v122[0] = (uint64_t *)"stride";
      v123 = 259;
      v66 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
      if (!v41)
        goto LABEL_70;
      v67 = *v41;
      v68 = mlir::TypeID::get<mlir::ShapedType>();
      v69 = *(unsigned int *)(v67 + 16);
      if (!(_DWORD)v69)
        goto LABEL_70;
      v70 = *(_QWORD **)(v67 + 8);
      v71 = &v70[2 * v69];
      do
      {
        v72 = v69 >> 1;
        v73 = &v70[2 * (v69 >> 1)];
        v75 = *v73;
        v74 = v73 + 2;
        v69 += ~(v69 >> 1);
        if (v75 < v68)
          v70 = v74;
        else
          v69 = v72;
      }
      while (v69);
      if (v70 != v71 && *v70 == v68)
        v76 = v70[1];
      else
LABEL_70:
        v76 = 0;
      v77 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v76, v131, 8 * v132, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v124, v66, v77);
      v122[0] = (uint64_t *)"padding";
      v123 = 259;
      v78 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
      if (!v43)
        goto LABEL_80;
      v79 = *v43;
      v80 = mlir::TypeID::get<mlir::ShapedType>();
      v81 = *(unsigned int *)(v79 + 16);
      if (!(_DWORD)v81)
        goto LABEL_80;
      v82 = *(_QWORD **)(v79 + 8);
      v83 = &v82[2 * v81];
      do
      {
        v84 = v81 >> 1;
        v85 = &v82[2 * (v81 >> 1)];
        v87 = *v85;
        v86 = v85 + 2;
        v81 += ~(v81 >> 1);
        if (v87 < v80)
          v82 = v86;
        else
          v81 = v84;
      }
      while (v81);
      if (v82 != v83 && *v82 == v80)
        v88 = v82[1];
      else
LABEL_80:
        v88 = 0;
      v89 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v88, v134, 8 * v135, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v124, v78, v89);
      v90 = mlir::ValueRange::dereference_iterator(v140, 0);
      v122[0] = (uint64_t *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
      if (mlir::Type::isF16((mlir::Type *)v122)
        || (GOC = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118),
            mlir::Type::isF32((mlir::Type *)&GOC)))
      {
        GOC = 1;
        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
        v92 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&GOC, 1, OperandRange, 0);
        v93 = (uint64_t)v92;
        if (!v92)
          goto LABEL_92;
        v94 = *v92;
        v95 = mlir::TypeID::get<mlir::ShapedType>();
        v96 = *(unsigned int *)(v94 + 16);
        if (!(_DWORD)v96)
          goto LABEL_92;
        v97 = *(_QWORD **)(v94 + 8);
        v98 = &v97[2 * v96];
        do
        {
          v99 = v96 >> 1;
          v100 = &v97[2 * (v96 >> 1)];
          v102 = *v100;
          v101 = v100 + 2;
          v96 += ~(v96 >> 1);
          if (v102 < v95)
            v97 = v101;
          else
            v96 = v99;
        }
        while (v96);
        if (v97 != v98 && *v97 == v95)
          v103 = v97[1];
        else
LABEL_92:
          v103 = 0;
        v104 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
        v120 = (uint64_t)mlir::FloatAttr::get(v104, -1.0);
        v59 = 1;
        v122[0] = (uint64_t *)mlir::DenseElementsAttr::get(v93, v103, &v120, 1uLL);
        v105 = *((_QWORD *)v119 + 3);
        v120 = 1;
        v106 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
        GOC = mlir::MemRefType::get(&v120, (mlir::AffineMap *)1, v106, 0, 0, 0);
        v107 = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::MemRefType &,mlir::mps::MPSBufferTensorAttr &>((mlir::OpBuilder *)(a4 + 8), v105, &GOC, v122)- 16;
        v108 = *((_QWORD *)v119 + 3);
        v116 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
        v120 = (uint64_t)mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), v108, (uint64_t)&v116, (uint64_t)&v124);
        v109 = (mlir::MLIRContext *)*((_QWORD *)v119 + 3);
        v110 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v120);
        mlir::ConversionPatternRewriter::replaceOp(a4, v119, (uint64_t)v122, 1);
      }
      else
      {
        v112 = v119;
        v122[0] = v118;
        v113 = *(_QWORD *)(a4 + 16);
        if (v113)
        {
          if (mlir::RewriterBase::Listener::classof(v113))
          else
            v59 = 0;
        }
        else
        {
          v59 = 0;
        }
      }
      if (v124 != v126)
        free(v124);
    }
LABEL_96:
    if (v128 != v130)
      free(v128);
    if (v131 != v133)
      free(v131);
    if (v134 != v136)
      free(v134);
    if (v137 != (void **)v139)
      free(v137);
    return v59;
  }
  v114 = (mlir::Operation ***)std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, "to MaxPool, AveragePool or Conv for A13 and below on ane is not supported \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  mlir::Diagnostic *v11;
  mlir::Diagnostic *v12;
  unint64_t v14;
  BOOL v15;
  char *v16;
  int v17;
  uint64_t v18;

  v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = **a1;
  v17 = 2;
  v18 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v17;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v14 = v7 + 1;
    v15 = v5 + 24 * v7 > (unint64_t)&v17;
    if (v5 <= (unint64_t)&v17 && v15)
    {
      v16 = (char *)&v17 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v16[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v17;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  v12 = mlir::Diagnostic::operator<<(v11, (mlir::Operation *)*a1[1]);
  return mlir::Diagnostic::operator<<((uint64_t)v12, "is not supported for A13 and below\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, "\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(mlir::MemoryMapperInterface **a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t OperandRange;
  _BYTE *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  _BYTE *v14;
  _BYTE v15[24];

  v3 = mlir::Diagnostic::operator<<(a2, "ReduceMin for non fp type: ");
  OperandRange = mlir::MemoryMapperInterface::getOperandRange(*a1);
  v5 = v15;
  mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)v15, OperandRange);
  v6 = v3 + 16;
  v7 = *(_QWORD *)(v3 + 16);
  v8 = *(unsigned int *)(v3 + 24);
  if (v8 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v8 + 1;
    v13 = v7 + 24 * v8 > (unint64_t)v15;
    if (v7 <= (unint64_t)v15 && v13)
    {
      v14 = &v15[-v7];
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(v3 + 32), v12, 24);
      v7 = *(_QWORD *)(v3 + 16);
      v5 = &v14[v7];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(v3 + 32), v12, 24);
      v7 = *(_QWORD *)(v3 + 16);
      v5 = v15;
    }
  }
  v9 = v7 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v5;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v5 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " is not supported for A13 and below\n");
}

_QWORD *mlir::`anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)1>::~ConvertReductionA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)1>::~ConvertReductionA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

mlir::GenericProgramPoint *mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  char v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t IndexFromDim;
  char v34;
  uint64_t v35;
  uint64_t OperandRange;
  uint64_t *Value;
  uint64_t v38;
  llvm::APFloatBase *NumElements;
  llvm::APFloatBase *v40;
  llvm::APFloatBase *v41;
  uint64_t v42;
  mlir::Operation *v44;
  mlir::Operation *v45;
  mlir::MLIRContext *v46;
  void *v47;
  uint64_t v48;
  uint64_t F16Type;
  _QWORD *v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  _QWORD *v56;
  _QWORD *v57;
  unint64_t v58;
  unint64_t *v59;
  _QWORD *v60;
  unint64_t v61;
  uint64_t v62;
  mlir::Builder *v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t *v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD v71[2];
  mlir::Operation *v72;
  __n128 *ElementsAttr;
  _QWORD v74[3];
  void *v75;
  uint64_t v76;
  _WORD v77[256];
  void *v78;
  uint64_t v79;
  _QWORD v80[2];
  int64x2_t v81;
  void *v82;
  uint64_t v83;
  _BYTE v84[48];
  void *v85;
  uint64_t v86;
  _BYTE v87[48];
  _BYTE *v88;
  uint64_t v89;
  _BYTE v90[48];
  _QWORD *v91;
  uint64_t v92;
  _BYTE v93[48];
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;

  v96 = *MEMORY[0x1E0C80C00];
  v72 = a2;
  v6 = *(_QWORD *)(a3 + 56);
  v94 = *(_QWORD *)(a3 + 48);
  v95 = v6;
  if (!v8)
  {
    v75 = "failed to convert operand axes";
    v77[8] = 259;
    v78 = &v75;
    v42 = *(_QWORD *)(a4 + 16);
    if (v42)
    {
      if (mlir::RewriterBase::Listener::classof(v42))
        return (mlir::GenericProgramPoint *)(*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v42 + 64))(v42, *((_QWORD *)a2 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v78);
      return 0;
    }
    return (mlir::GenericProgramPoint *)v42;
  }
  v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v72))
  {
    v44 = v72;
    v75 = &v72;
    v42 = *(_QWORD *)(a4 + 16);
    if (v42)
    {
      if (mlir::RewriterBase::Listener::classof(v42))
      return 0;
    }
    return (mlir::GenericProgramPoint *)v42;
  }
  v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v72) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_12;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_12;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_12:
    v20 = 0;
  v91 = v93;
  v92 = 0x600000000;
  if (!v9)
    goto LABEL_22;
  v21 = *v9;
  v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  v23 = *(unsigned int *)(v21 + 16);
  if (!(_DWORD)v23)
    goto LABEL_22;
  v24 = *(_QWORD **)(v21 + 8);
  v25 = &v24[2 * v23];
  do
  {
    v26 = v23 >> 1;
    v27 = &v24[2 * (v23 >> 1)];
    v29 = *v27;
    v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22)
      v24 = v28;
    else
      v23 = v26;
  }
  while (v23);
  if (v24 != v25 && *v24 == v22)
    v30 = v24[1];
  else
LABEL_22:
    v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v91, 1);
  v88 = v90;
  memset(v90, 0, sizeof(v90));
  v89 = 0x600000006;
  v85 = v87;
  memset_pattern16(v87, &unk_181233190, 0x18uLL);
  v86 = 0x600000003;
  v82 = v84;
  memset_pattern16(v84, &unk_181233190, 0x18uLL);
  v83 = 0x600000003;
  v71[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v71[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v71);
  IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if ((_DWORD)v92 == 1 && *v91 == IndexFromDim)
    {
      v69 = *((_QWORD *)v72 + 3);
      v35 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v71)
                      + 8 * IndexFromDim);
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v71);
      v78 = v80;
      v80[0] = 1;
      v80[1] = v35;
      v81 = vdupq_n_s64(1uLL);
      v79 = 0x1000000004;
      v70 = mlir::MemRefType::get(v80, (mlir::AffineMap *)4, OperandRange, 0, 0, 0);
      Value = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v70);
      NumElements = (llvm::APFloatBase *)mlir::ShapedType::getNumElements(Value, v38);
      v40 = (llvm::APFloatBase *)llvm::APFloatBase::IEEEhalf(NumElements);
      v41 = (llvm::APFloatBase *)llvm::APFloatBase::PPCDoubleDouble(v40);
      if (v41 == v40)
        llvm::detail::DoubleAPFloat::DoubleAPFloat(v74, (uint64_t)v40, 1);
      else
        llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v74, (uint64_t)v40, (llvm::APInt *)1);
      v75 = v77;
      v76 = 0x1000000000;
      llvm::SmallVectorImpl<llvm::APFloat>::assign((unsigned int *)&v75, (unint64_t)NumElements, (uint64_t)&ElementsAttr);
      if (v41 == (llvm::APFloatBase *)v74[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v74);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v74);
      v47 = v78;
      v48 = v79;
      F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a4 + 8), v46);
      v50 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v47, v48, F16Type, 0);
      ElementsAttr = mlir::createElementsAttr(v50, (uint64_t)v75, v76);
      v74[0] = v51;
      mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 8), v69, &v70, (_QWORD **)&ElementsAttr);
      v52 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v72) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v52)
        goto LABEL_53;
      v53 = *v52;
      v54 = mlir::TypeID::get<mlir::ShapedType>();
      v55 = *(unsigned int *)(v53 + 16);
      if (!(_DWORD)v55)
        goto LABEL_53;
      v56 = *(_QWORD **)(v53 + 8);
      v57 = &v56[2 * v55];
      do
      {
        v58 = v55 >> 1;
        v59 = &v56[2 * (v55 >> 1)];
        v61 = *v59;
        v60 = v59 + 2;
        v55 += ~(v55 >> 1);
        if (v61 < v54)
          v56 = v60;
        else
          v55 = v58;
      }
      while (v55);
      if (v56 != v57 && *v56 == v54)
        v62 = v56[1];
      else
LABEL_53:
        v62 = 0;
    }
    v45 = v72;
    v75 = &v72;
    v42 = *(_QWORD *)(a4 + 16);
    if (v42)
    {
      if (mlir::RewriterBase::Listener::classof(v42))
      else
        v42 = 0;
    }
    if (v82 != v84)
      free(v82);
    if (v85 != v87)
      free(v85);
    if (v88 != v90)
      free(v88);
    if (v91 != (_QWORD *)v93)
      free(v91);
    return (mlir::GenericProgramPoint *)v42;
  }
  v64 = (mlir::Builder *)std::__throw_bad_optional_access[abi:nn180100]();
  return mlir::OpBuilder::create<mlir::anec::Convolution,mlir::MemRefType &,mlir::Value,mlir::Value&>(v64, v65, v66, v67, v68);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Convolution,mlir::MemRefType &,mlir::Value,mlir::Value&>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.convolution", (const unsigned __int8 *)0x10, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"anec.convolution";
    v19[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::Convolution::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionSumOp,mlir::mps::ReductionSumOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, "to MaxPool, AveragePool or Conv for A13 and below on ane is not supported \n");
}

void llvm::SmallVectorImpl<llvm::APFloat>::assign(unsigned int *a1, unint64_t a2, uint64_t a3)
{
  unsigned int *v5;
  unint64_t v6;
  unint64_t v7;
  llvm::APFloatBase *v8;
  unint64_t v9;
  uint64_t v10;
  const llvm::detail::DoubleAPFloat *v11;
  void *v12;
  llvm::detail::DoubleAPFloat *v13;
  llvm::detail::DoubleAPFloat *v14;
  uint64_t v16;
  void *v17;
  llvm::detail::DoubleAPFloat *v18;
  uint64_t v19;
  uint64_t v20;

  v5 = a1;
  if (a1[3] >= a2)
  {
    v6 = a1[2];
    if (v6 >= a2)
      v7 = a2;
    else
      v7 = a1[2];
    if (v7)
    {
      v8 = (llvm::APFloatBase *)(*(_QWORD *)a1 + 8);
      do
      {
        a1 = (unsigned int *)llvm::APFloat::Storage::operator=(v8, (uint64_t *)(a3 + 8));
        v8 = (llvm::APFloatBase *)((char *)v8 + 32);
        --v7;
      }
      while (v7);
      v6 = v5[2];
    }
    v9 = v6 - a2;
    if (v6 >= a2)
    {
      if (v6 > a2)
      {
        v16 = *(_QWORD *)v5;
        v17 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
        v18 = (llvm::detail::DoubleAPFloat *)(32 * v6 + v16 - 24);
        v19 = 32 * a2 - 32 * v6;
        do
        {
          if (v17 == *(void **)v18)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat(v18);
          else
            llvm::detail::IEEEFloat::~IEEEFloat(v18);
          v18 = (llvm::detail::DoubleAPFloat *)(v20 - 32);
          v19 += 32;
        }
        while (v19);
      }
    }
    else
    {
      v10 = *(_QWORD *)v5;
      v11 = (const llvm::detail::DoubleAPFloat *)(a3 + 8);
      v12 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
      v13 = (llvm::detail::DoubleAPFloat *)(v10 + 32 * v6 + 8);
      do
      {
        if (v12 == *(void **)v11)
          v14 = llvm::detail::DoubleAPFloat::DoubleAPFloat(v13, v11);
        else
          v14 = (llvm::detail::DoubleAPFloat *)llvm::detail::IEEEFloat::IEEEFloat(v13, v11);
        v13 = (llvm::detail::DoubleAPFloat *)((char *)v14 + 32);
      }
      while (!__CFADD__(v9++, 1));
    }
    v5[2] = a2;
  }
  else
  {
    llvm::SmallVectorTemplateBase<llvm::APFloat,false>::growAndAssign((uint64_t)a1, a2, a3);
  }
}

void llvm::SmallVectorTemplateBase<llvm::APFloat,false>::growAndAssign(uint64_t a1, unint64_t a2, uint64_t a3)
{
  char *v6;
  llvm::APFloatBase *v7;
  llvm::APFloatBase *v8;
  const llvm::detail::DoubleAPFloat *v9;
  void *v10;
  unint64_t v11;
  llvm::detail::DoubleAPFloat *v12;
  char *v13;
  uint64_t v14;
  void *v15;
  char *v16;
  uint64_t v17;
  llvm::detail::DoubleAPFloat *v18;
  int v19;
  unint64_t v20;

  v20 = 0;
  v6 = (char *)(a1 + 16);
  v7 = (llvm::APFloatBase *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 32, &v20);
  v8 = v7;
  if (a2)
  {
    v9 = (const llvm::detail::DoubleAPFloat *)(a3 + 8);
    v10 = llvm::APFloatBase::PPCDoubleDouble(v7);
    v7 = (llvm::APFloatBase *)((char *)v8 + 8);
    v11 = a2;
    do
    {
      if (v10 == *(void **)v9)
        v12 = llvm::detail::DoubleAPFloat::DoubleAPFloat(v7, v9);
      else
        v12 = (llvm::detail::DoubleAPFloat *)llvm::detail::IEEEFloat::IEEEFloat(v7, v9);
      v7 = (llvm::detail::DoubleAPFloat *)((char *)v12 + 32);
      --v11;
    }
    while (v11);
  }
  v13 = *(char **)a1;
  v14 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v14)
  {
    v15 = llvm::APFloatBase::PPCDoubleDouble(v7);
    v16 = v13 - 24;
    v17 = 32 * v14;
    do
    {
      while (1)
      {
        v18 = (llvm::detail::DoubleAPFloat *)&v16[v17];
        if (v15 != *(void **)&v16[v17])
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v18);
        v17 -= 32;
        if (!v17)
          goto LABEL_12;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v18);
      v17 -= 32;
    }
    while (v17);
LABEL_12:
    v13 = *(char **)a1;
  }
  v19 = v20;
  if (v13 != v6)
    free(v13);
  *(_QWORD *)a1 = v8;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = v19;
}

llvm::APFloatBase *llvm::APFloat::Storage::operator=(llvm::APFloatBase *a1, uint64_t *a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  void *v8;

  v4 = *(void **)a1;
  v5 = llvm::APFloatBase::PPCDoubleDouble(a1);
  v6 = *a2;
  if (v5 != v4 && v5 != (void *)v6)
  {
    llvm::detail::IEEEFloat::operator=((uint64_t *)a1, a2);
    return a1;
  }
  v8 = v5;
  if (v5 != v4)
  {
    if (a1 == (llvm::APFloatBase *)a2)
      return a1;
    llvm::detail::IEEEFloat::~IEEEFloat(a1);
    goto LABEL_12;
  }
  if (v4 == (void *)v6)
  {
    llvm::detail::DoubleAPFloat::operator=((uint64_t *)a1, a2);
    return a1;
  }
  if (a1 != (llvm::APFloatBase *)a2)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat(a1);
LABEL_12:
    if (v8 == (void *)*a2)
      llvm::detail::DoubleAPFloat::DoubleAPFloat(a1, (const llvm::detail::DoubleAPFloat *)a2);
    else
      llvm::detail::IEEEFloat::IEEEFloat(a1, (const llvm::detail::IEEEFloat *)a2);
  }
  return a1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionSumOp,mlir::mps::ReductionSumOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "ReduceSum for axes other than channel axis: ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " is not supported for A13 and below\n");
}

_QWORD *mlir::`anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::~ConvertReductionA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::~ConvertReductionA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  char v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t IndexFromDim;
  char v34;
  unint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t ArgAttrsAttr;
  uint64_t IntegerType;
  uint64_t *v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t StringAttr;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  unint64_t v50;
  unint64_t *v51;
  _QWORD *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int *v57;
  unsigned int *v58;
  uint64_t v59;
  void *v60;
  unsigned int *v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  unint64_t v70;
  unint64_t *v71;
  _QWORD *v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  _QWORD *v80;
  _QWORD *v81;
  unint64_t v82;
  unint64_t *v83;
  _QWORD *v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  mlir::Operation ***v89;
  uint64_t v90;
  char *v91;
  _QWORD v92[2];
  unsigned int *v93;
  _QWORD v94[4];
  __int16 v95;
  void *v96;
  uint64_t v97;
  _WORD v98[32];
  uint64_t v99;
  void *v100;
  uint64_t v101;
  _BYTE v102[48];
  void *v103;
  uint64_t v104;
  _BYTE v105[48];
  _OWORD *v106;
  uint64_t v107;
  _OWORD v108[3];
  void **v109;
  uint64_t v110;
  _BYTE v111[48];
  uint64_t v112[4];

  v112[2] = *MEMORY[0x1E0C80C00];
  v93 = (unsigned int *)a2;
  v6 = *(_QWORD *)(a3 + 64);
  v112[0] = *(_QWORD *)(a3 + 56);
  v112[1] = v6;
  if (!v8)
  {
    v96 = "failed to convert operand axes";
    v98[8] = 259;
    v109 = &v96;
    v55 = *(_QWORD *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55))
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v55 + 64))(v55, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMaxOp &>(mlir::mps::ReductionMaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v109);
      return 0;
    }
    return v55;
  }
  v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v93))
  {
    v57 = v93;
    v96 = &v93;
    v55 = *(_QWORD *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55))
      return 0;
    }
    return v55;
  }
  v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v93) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_12;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_12;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_12:
    v20 = 0;
  v109 = (void **)v111;
  v110 = 0x600000000;
  if (!v9)
    goto LABEL_22;
  v21 = *v9;
  v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  v23 = *(unsigned int *)(v21 + 16);
  if (!(_DWORD)v23)
    goto LABEL_22;
  v24 = *(_QWORD **)(v21 + 8);
  v25 = &v24[2 * v23];
  do
  {
    v26 = v23 >> 1;
    v27 = &v24[2 * (v23 >> 1)];
    v29 = *v27;
    v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22)
      v24 = v28;
    else
      v23 = v26;
  }
  while (v23);
  if (v24 != v25 && *v24 == v22)
    v30 = v24[1];
  else
LABEL_22:
    v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v109, 1);
  v106 = v108;
  memset(v108, 0, sizeof(v108));
  v107 = 0x600000006;
  v103 = v105;
  memset_pattern16(v105, &unk_181233190, 0x18uLL);
  v104 = 0x600000003;
  v100 = v102;
  memset_pattern16(v102, &unk_181233190, 0x18uLL);
  v101 = 0x600000003;
  v92[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v92[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v92);
  IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if ((_DWORD)v110)
    {
      v35 = IndexFromDim;
      v36 = (uint64_t *)v109;
      v37 = 8 * v110;
      while (1)
      {
        v38 = *v36;
        v94[0] = v38;
        if (v38 == v35)
          break;
        if (v38 <= 1)
        {
          v61 = v93;
          v96 = &v93;
          v55 = *(_QWORD *)(a4 + 16);
          if (!v55)
            goto LABEL_89;
          if (mlir::RewriterBase::Listener::classof(v55))
          {
            v59 = *((_QWORD *)v61 + 3);
            goto LABEL_54;
          }
          goto LABEL_56;
        }
        ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v92);
        *((_QWORD *)v100 + v38 - 2) = *(_QWORD *)(ArgAttrsAttr + 8 * v38);
        ++v36;
        v37 -= 8;
        if (!v37)
          goto LABEL_29;
      }
      v58 = v93;
      v96 = v94;
      v97 = (uint64_t)&v93;
      v55 = *(_QWORD *)(a4 + 16);
      if (!v55)
        goto LABEL_89;
      if (mlir::RewriterBase::Listener::classof(v55))
      {
        v59 = *((_QWORD *)v58 + 3);
LABEL_54:
        v55 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(_QWORD *)v55 + 64))(v55, v59, v60, &v96);
        goto LABEL_89;
      }
LABEL_56:
      v55 = 0;
    }
    else
    {
LABEL_29:
      v96 = v98;
      v97 = 0x400000000;
      v99 = 4;
      v94[0] = 3;
      IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v94, 1, IntegerType, 0);
      v94[0] = 6;
      v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      v43 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v94, 1, v42, 0);
      v94[0] = "ksize";
      v95 = 259;
      StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
      if (v41)
      {
        v45 = *v41;
        v46 = mlir::TypeID::get<mlir::ShapedType>();
        v47 = *(unsigned int *)(v45 + 16);
        if ((_DWORD)v47)
        {
          v48 = *(_QWORD **)(v45 + 8);
          v49 = &v48[2 * v47];
          do
          {
            v50 = v47 >> 1;
            v51 = &v48[2 * (v47 >> 1)];
            v53 = *v51;
            v52 = v51 + 2;
            v47 += ~(v47 >> 1);
            if (v53 < v46)
              v48 = v52;
            else
              v47 = v50;
          }
          while (v47);
          if (v48 == v49)
          {
            v54 = 0;
          }
          else if (*v48 == v46)
          {
            v54 = v48[1];
          }
          else
          {
            v54 = 0;
          }
        }
        else
        {
          v54 = 0;
        }
      }
      else
      {
        v54 = 0;
      }
      v62 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v100, 8 * v101, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v96, StringAttr, v62);
      v94[0] = "stride";
      v95 = 259;
      v63 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
      if (v41)
      {
        v64 = v43;
        v65 = *v41;
        v66 = mlir::TypeID::get<mlir::ShapedType>();
        v67 = *(unsigned int *)(v65 + 16);
        if ((_DWORD)v67)
        {
          v68 = *(_QWORD **)(v65 + 8);
          v69 = &v68[2 * v67];
          do
          {
            v70 = v67 >> 1;
            v71 = &v68[2 * (v67 >> 1)];
            v73 = *v71;
            v72 = v71 + 2;
            v67 += ~(v67 >> 1);
            if (v73 < v66)
              v68 = v72;
            else
              v67 = v70;
          }
          while (v67);
          v43 = v64;
          if (v68 == v69)
          {
            v74 = 0;
          }
          else if (*v68 == v66)
          {
            v74 = v68[1];
          }
          else
          {
            v74 = 0;
          }
        }
        else
        {
          v74 = 0;
          v43 = v64;
        }
      }
      else
      {
        v74 = 0;
      }
      v75 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v74, v103, 8 * v104, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v96, v63, v75);
      v94[0] = "padding";
      v95 = 259;
      v76 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v94);
      if (v43
        && (v77 = *v43, v78 = mlir::TypeID::get<mlir::ShapedType>(), v79 = *(unsigned int *)(v77 + 16), (_DWORD)v79))
      {
        v80 = *(_QWORD **)(v77 + 8);
        v81 = &v80[2 * v79];
        do
        {
          v82 = v79 >> 1;
          v83 = &v80[2 * (v79 >> 1)];
          v85 = *v83;
          v84 = v83 + 2;
          v79 += ~(v79 >> 1);
          if (v85 < v78)
            v80 = v84;
          else
            v79 = v82;
        }
        while (v79);
        if (v80 != v81 && *v80 == v78)
          v86 = v80[1];
        else
          v86 = 0;
      }
      else
      {
        v86 = 0;
      }
      v87 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v86, v106, 8 * v107, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v96, v76, v87);
      v94[0] = mlir::ValueRange::dereference_iterator(v112, 0);
      v91 = (char *)mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *((_QWORD *)v93 + 3), (uint64_t)v94, (uint64_t)&v96)- 16;
      mlir::ConversionPatternRewriter::replaceOp(a4, v93, (uint64_t)&v91, 1);
      if (v96 != v98)
        free(v96);
      v55 = 1;
    }
LABEL_89:
    if (v100 != v102)
      free(v100);
    if (v103 != v105)
      free(v103);
    if (v106 != v108)
      free(v106);
    if (v109 != (void **)v111)
      free(v109);
    return v55;
  }
  v89 = (mlir::Operation ***)std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, "to MaxPool, AveragePool or Conv for A13 and below on ane is not supported \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  mlir::Diagnostic *v11;
  mlir::Diagnostic *v12;
  unint64_t v14;
  BOOL v15;
  char *v16;
  int v17;
  uint64_t v18;

  v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = **a1;
  v17 = 2;
  v18 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v17;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v14 = v7 + 1;
    v15 = v5 + 24 * v7 > (unint64_t)&v17;
    if (v5 <= (unint64_t)&v17 && v15)
    {
      v16 = (char *)&v17 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v16[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v17;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  v12 = mlir::Diagnostic::operator<<(v11, (mlir::Operation *)*a1[1]);
  return mlir::Diagnostic::operator<<((uint64_t)v12, "is not supported for A13 and below\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMaxOp,mlir::anec::ReduceMax,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMaxOp,mlir::mps::ReductionMaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, "\n");
}

_QWORD *mlir::`anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::~ConvertReductionA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::~ConvertReductionA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  char v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t IndexFromDim;
  char v34;
  unint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t ArgAttrsAttr;
  uint64_t IntegerType;
  uint64_t *v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t StringAttr;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  unint64_t v50;
  unint64_t *v51;
  _QWORD *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int *v57;
  unsigned int *v58;
  uint64_t v59;
  void *v60;
  unsigned int *v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  unint64_t v70;
  unint64_t *v71;
  _QWORD *v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  _QWORD *v80;
  _QWORD *v81;
  unint64_t v82;
  unint64_t *v83;
  _QWORD *v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  mlir::MLIRContext *v88;
  uint64_t UnitAttr;
  mlir::Operation ***v91;
  uint64_t v92;
  char *v93;
  _QWORD v94[2];
  unsigned int *v95;
  _QWORD v96[4];
  __int16 v97;
  void *v98;
  uint64_t v99;
  _WORD v100[32];
  uint64_t v101;
  void *v102;
  uint64_t v103;
  _BYTE v104[48];
  void *v105;
  uint64_t v106;
  _BYTE v107[48];
  _OWORD *v108;
  uint64_t v109;
  _OWORD v110[3];
  void **v111;
  uint64_t v112;
  _BYTE v113[48];
  uint64_t v114[4];

  v114[2] = *MEMORY[0x1E0C80C00];
  v95 = (unsigned int *)a2;
  v6 = *(_QWORD *)(a3 + 56);
  v114[0] = *(_QWORD *)(a3 + 48);
  v114[1] = v6;
  if (!v8)
  {
    v98 = "failed to convert operand axes";
    v100[8] = 259;
    v111 = &v98;
    v55 = *(_QWORD *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55))
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v55 + 64))(v55, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMeanOp &>(mlir::mps::ReductionMeanOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v111);
      return 0;
    }
    return v55;
  }
  v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v95))
  {
    v57 = v95;
    v98 = &v95;
    v55 = *(_QWORD *)(a4 + 16);
    if (v55)
    {
      if (mlir::RewriterBase::Listener::classof(v55))
      return 0;
    }
    return v55;
  }
  v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_12;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_12;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_12:
    v20 = 0;
  v111 = (void **)v113;
  v112 = 0x600000000;
  if (!v9)
    goto LABEL_22;
  v21 = *v9;
  v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  v23 = *(unsigned int *)(v21 + 16);
  if (!(_DWORD)v23)
    goto LABEL_22;
  v24 = *(_QWORD **)(v21 + 8);
  v25 = &v24[2 * v23];
  do
  {
    v26 = v23 >> 1;
    v27 = &v24[2 * (v23 >> 1)];
    v29 = *v27;
    v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22)
      v24 = v28;
    else
      v23 = v26;
  }
  while (v23);
  if (v24 != v25 && *v24 == v22)
    v30 = v24[1];
  else
LABEL_22:
    v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v111, 1);
  v108 = v110;
  memset(v110, 0, sizeof(v110));
  v109 = 0x600000006;
  v105 = v107;
  memset_pattern16(v107, &unk_181233190, 0x18uLL);
  v106 = 0x600000003;
  v102 = v104;
  memset_pattern16(v104, &unk_181233190, 0x18uLL);
  v103 = 0x600000003;
  v94[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v94[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v94);
  IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if ((_DWORD)v112)
    {
      v35 = IndexFromDim;
      v36 = (uint64_t *)v111;
      v37 = 8 * v112;
      while (1)
      {
        v38 = *v36;
        v96[0] = v38;
        if (v38 == v35)
          break;
        if (v38 <= 1)
        {
          v61 = v95;
          v98 = &v95;
          v55 = *(_QWORD *)(a4 + 16);
          if (!v55)
            goto LABEL_89;
          if (mlir::RewriterBase::Listener::classof(v55))
          {
            v59 = *((_QWORD *)v61 + 3);
            goto LABEL_54;
          }
          goto LABEL_56;
        }
        ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v94);
        *((_QWORD *)v102 + v38 - 2) = *(_QWORD *)(ArgAttrsAttr + 8 * v38);
        ++v36;
        v37 -= 8;
        if (!v37)
          goto LABEL_29;
      }
      v58 = v95;
      v98 = v96;
      v99 = (uint64_t)&v95;
      v55 = *(_QWORD *)(a4 + 16);
      if (!v55)
        goto LABEL_89;
      if (mlir::RewriterBase::Listener::classof(v55))
      {
        v59 = *((_QWORD *)v58 + 3);
LABEL_54:
        v55 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(_QWORD *)v55 + 64))(v55, v59, v60, &v98);
        goto LABEL_89;
      }
LABEL_56:
      v55 = 0;
    }
    else
    {
LABEL_29:
      v98 = v100;
      v99 = 0x400000000;
      v101 = 4;
      v96[0] = 3;
      IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v96, 1, IntegerType, 0);
      v96[0] = 6;
      v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      v43 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v96, 1, v42, 0);
      v96[0] = "ksize";
      v97 = 259;
      StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
      if (v41)
      {
        v45 = *v41;
        v46 = mlir::TypeID::get<mlir::ShapedType>();
        v47 = *(unsigned int *)(v45 + 16);
        if ((_DWORD)v47)
        {
          v48 = *(_QWORD **)(v45 + 8);
          v49 = &v48[2 * v47];
          do
          {
            v50 = v47 >> 1;
            v51 = &v48[2 * (v47 >> 1)];
            v53 = *v51;
            v52 = v51 + 2;
            v47 += ~(v47 >> 1);
            if (v53 < v46)
              v48 = v52;
            else
              v47 = v50;
          }
          while (v47);
          if (v48 == v49)
          {
            v54 = 0;
          }
          else if (*v48 == v46)
          {
            v54 = v48[1];
          }
          else
          {
            v54 = 0;
          }
        }
        else
        {
          v54 = 0;
        }
      }
      else
      {
        v54 = 0;
      }
      v62 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v102, 8 * v103, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v98, StringAttr, v62);
      v96[0] = "stride";
      v97 = 259;
      v63 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
      if (v41)
      {
        v64 = v43;
        v65 = *v41;
        v66 = mlir::TypeID::get<mlir::ShapedType>();
        v67 = *(unsigned int *)(v65 + 16);
        if ((_DWORD)v67)
        {
          v68 = *(_QWORD **)(v65 + 8);
          v69 = &v68[2 * v67];
          do
          {
            v70 = v67 >> 1;
            v71 = &v68[2 * (v67 >> 1)];
            v73 = *v71;
            v72 = v71 + 2;
            v67 += ~(v67 >> 1);
            if (v73 < v66)
              v68 = v72;
            else
              v67 = v70;
          }
          while (v67);
          v43 = v64;
          if (v68 == v69)
          {
            v74 = 0;
          }
          else if (*v68 == v66)
          {
            v74 = v68[1];
          }
          else
          {
            v74 = 0;
          }
        }
        else
        {
          v74 = 0;
          v43 = v64;
        }
      }
      else
      {
        v74 = 0;
      }
      v75 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v74, v105, 8 * v106, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v98, v63, v75);
      v96[0] = "padding";
      v97 = 259;
      v76 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v96);
      if (v43
        && (v77 = *v43, v78 = mlir::TypeID::get<mlir::ShapedType>(), v79 = *(unsigned int *)(v77 + 16), (_DWORD)v79))
      {
        v80 = *(_QWORD **)(v77 + 8);
        v81 = &v80[2 * v79];
        do
        {
          v82 = v79 >> 1;
          v83 = &v80[2 * (v79 >> 1)];
          v85 = *v83;
          v84 = v83 + 2;
          v79 += ~(v79 >> 1);
          if (v85 < v78)
            v80 = v84;
          else
            v79 = v82;
        }
        while (v79);
        if (v80 != v81 && *v80 == v78)
          v86 = v80[1];
        else
          v86 = 0;
      }
      else
      {
        v86 = 0;
      }
      v87 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v86, v108, 8 * v109, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v98, v76, v87);
      v96[0] = mlir::ValueRange::dereference_iterator(v114, 0);
      UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)(a4 + 8), v88);
      mlir::NamedAttrList::set((uint64_t)&v98, (uint64_t)"inc_pad", 7, UnitAttr);
      v93 = (char *)mlir::OpBuilder::create<mlir::anec::AveragePool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), *((_QWORD *)v95 + 3), (uint64_t)v96, (uint64_t)&v98)- 16;
      mlir::ConversionPatternRewriter::replaceOp(a4, v95, (uint64_t)&v93, 1);
      if (v98 != v100)
        free(v98);
      v55 = 1;
    }
LABEL_89:
    if (v102 != v104)
      free(v102);
    if (v105 != v107)
      free(v105);
    if (v108 != v110)
      free(v108);
    if (v111 != (void **)v113)
      free(v111);
    return v55;
  }
  v91 = (mlir::Operation ***)std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, "to MaxPool, AveragePool or Conv for A13 and below on ane is not supported \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  mlir::Diagnostic *v11;
  mlir::Diagnostic *v12;
  unint64_t v14;
  BOOL v15;
  char *v16;
  int v17;
  uint64_t v18;

  v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = **a1;
  v17 = 2;
  v18 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v17;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v14 = v7 + 1;
    v15 = v5 + 24 * v7 > (unint64_t)&v17;
    if (v5 <= (unint64_t)&v17 && v15)
    {
      v16 = (char *)&v17 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v16[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v17;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  v12 = mlir::Diagnostic::operator<<(v11, (mlir::Operation *)*a1[1]);
  return mlir::Diagnostic::operator<<((uint64_t)v12, "is not supported for A13 and below\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMeanOp,mlir::anec::ReduceAvg,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMeanOp,mlir::mps::ReductionMeanOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, "\n");
}

_QWORD *mlir::`anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::~ConvertReductionA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::~ConvertReductionA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  char v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t IndexFromDim;
  char v34;
  uint64_t *v35;
  uint64_t **v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t ArgAttrsAttr;
  uint64_t IntegerType;
  uint64_t *v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t StringAttr;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  unint64_t v50;
  unint64_t *v51;
  _QWORD *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int *v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int *v60;
  uint64_t v61;
  uint64_t v62;
  void *v63;
  unsigned int *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  _QWORD *v70;
  _QWORD *v71;
  unint64_t v72;
  unint64_t *v73;
  _QWORD *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  unint64_t v81;
  _QWORD *v82;
  _QWORD *v83;
  unint64_t v84;
  unint64_t *v85;
  _QWORD *v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t OperandRange;
  uint64_t *v92;
  uint64_t v93;
  uint64_t v94;
  unint64_t v95;
  unint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  unint64_t v99;
  unint64_t *v100;
  _QWORD *v101;
  unint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  char *v107;
  uint64_t v108;
  mlir::MLIRContext *v109;
  uint64_t v110;
  unsigned int *v112;
  uint64_t v113;
  mlir::Operation ***v114;
  uint64_t v115;
  uint64_t v116;
  _QWORD v117[2];
  _QWORD v118[2];
  unsigned int *v119;
  uint64_t v120;
  uint64_t GOC;
  uint64_t *v122[4];
  __int16 v123;
  void *v124;
  uint64_t v125;
  _WORD v126[32];
  uint64_t v127;
  void *v128;
  uint64_t v129;
  _BYTE v130[48];
  void *v131;
  uint64_t v132;
  _BYTE v133[48];
  _OWORD *v134;
  uint64_t v135;
  _OWORD v136[3];
  void **v137;
  uint64_t v138;
  _BYTE v139[48];
  uint64_t v140[4];

  v140[2] = *MEMORY[0x1E0C80C00];
  v119 = (unsigned int *)a2;
  v6 = *(_QWORD *)(a3 + 64);
  v140[0] = *(_QWORD *)(a3 + 56);
  v140[1] = v6;
  if (!v8)
  {
    v124 = "failed to convert operand axes";
    v126[8] = 259;
    v137 = &v124;
    v55 = *(_QWORD *)(a4 + 16);
    if (v55 && mlir::RewriterBase::Listener::classof(v55))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v55 + 64))(v55, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionMinOp &>(mlir::mps::ReductionMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v137);
    return 0;
  }
  v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v119))
  {
    v57 = v119;
    v124 = &v119;
    v58 = *(_QWORD *)(a4 + 16);
    if (v58 && mlir::RewriterBase::Listener::classof(v58))
    return 0;
  }
  v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v119) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_12;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_12;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_12:
    v20 = 0;
  v118[0] = v10;
  v118[1] = v20;
  v137 = (void **)v139;
  v138 = 0x600000000;
  if (!v9)
    goto LABEL_22;
  v21 = *v9;
  v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  v23 = *(unsigned int *)(v21 + 16);
  if (!(_DWORD)v23)
    goto LABEL_22;
  v24 = *(_QWORD **)(v21 + 8);
  v25 = &v24[2 * v23];
  do
  {
    v26 = v23 >> 1;
    v27 = &v24[2 * (v23 >> 1)];
    v29 = *v27;
    v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22)
      v24 = v28;
    else
      v23 = v26;
  }
  while (v23);
  if (v24 != v25 && *v24 == v22)
    v30 = v24[1];
  else
LABEL_22:
    v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v137, 1);
  v134 = v136;
  memset(v136, 0, sizeof(v136));
  v135 = 0x600000006;
  v131 = v133;
  memset_pattern16(v133, &unk_181233190, 0x18uLL);
  v132 = 0x600000003;
  v128 = v130;
  memset_pattern16(v130, &unk_181233190, 0x18uLL);
  v129 = 0x600000003;
  v117[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v117[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v117);
  IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if ((_DWORD)v138)
    {
      v35 = (uint64_t *)IndexFromDim;
      v36 = (uint64_t **)v137;
      v37 = 8 * v138;
      while (1)
      {
        v38 = *v36;
        v122[0] = v38;
        if (v38 == v35)
          break;
        if ((uint64_t)v38 <= 1)
        {
          v64 = v119;
          v124 = &v119;
          v61 = *(_QWORD *)(a4 + 16);
          if (v61 && mlir::RewriterBase::Listener::classof(v61))
          {
            v62 = *((_QWORD *)v64 + 3);
            goto LABEL_54;
          }
          goto LABEL_55;
        }
        ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v117);
        *((_QWORD *)v128 + (_QWORD)v38 - 2) = *(_QWORD *)(ArgAttrsAttr + 8 * v38);
        ++v36;
        v37 -= 8;
        if (!v37)
          goto LABEL_29;
      }
      v60 = v119;
      v124 = v122;
      v125 = (uint64_t)&v119;
      v61 = *(_QWORD *)(a4 + 16);
      if (v61 && mlir::RewriterBase::Listener::classof(v61))
      {
        v62 = *((_QWORD *)v60 + 3);
LABEL_54:
        v59 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void **))(*(_QWORD *)v61 + 64))(v61, v62, v63, &v124);
        goto LABEL_96;
      }
LABEL_55:
      v59 = 0;
    }
    else
    {
LABEL_29:
      v124 = v126;
      v125 = 0x400000000;
      v127 = 4;
      v122[0] = (uint64_t *)3;
      IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      v41 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v122, 1, IntegerType, 0);
      v122[0] = (uint64_t *)6;
      v42 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
      v43 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v122, 1, v42, 0);
      v122[0] = (uint64_t *)"ksize";
      v123 = 259;
      StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
      if (v41)
      {
        v45 = *v41;
        v46 = mlir::TypeID::get<mlir::ShapedType>();
        v47 = *(unsigned int *)(v45 + 16);
        if ((_DWORD)v47)
        {
          v48 = *(_QWORD **)(v45 + 8);
          v49 = &v48[2 * v47];
          do
          {
            v50 = v47 >> 1;
            v51 = &v48[2 * (v47 >> 1)];
            v53 = *v51;
            v52 = v51 + 2;
            v47 += ~(v47 >> 1);
            if (v53 < v46)
              v48 = v52;
            else
              v47 = v50;
          }
          while (v47);
          if (v48 == v49)
          {
            v54 = 0;
          }
          else if (*v48 == v46)
          {
            v54 = v48[1];
          }
          else
          {
            v54 = 0;
          }
        }
        else
        {
          v54 = 0;
        }
      }
      else
      {
        v54 = 0;
      }
      v65 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v54, v128, 8 * v129, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v124, StringAttr, v65);
      v122[0] = (uint64_t *)"stride";
      v123 = 259;
      v66 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
      if (!v41)
        goto LABEL_70;
      v67 = *v41;
      v68 = mlir::TypeID::get<mlir::ShapedType>();
      v69 = *(unsigned int *)(v67 + 16);
      if (!(_DWORD)v69)
        goto LABEL_70;
      v70 = *(_QWORD **)(v67 + 8);
      v71 = &v70[2 * v69];
      do
      {
        v72 = v69 >> 1;
        v73 = &v70[2 * (v69 >> 1)];
        v75 = *v73;
        v74 = v73 + 2;
        v69 += ~(v69 >> 1);
        if (v75 < v68)
          v70 = v74;
        else
          v69 = v72;
      }
      while (v69);
      if (v70 != v71 && *v70 == v68)
        v76 = v70[1];
      else
LABEL_70:
        v76 = 0;
      v77 = mlir::DenseElementsAttr::getFromRawBuffer(v41, v76, v131, 8 * v132, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v124, v66, v77);
      v122[0] = (uint64_t *)"padding";
      v123 = 259;
      v78 = mlir::Builder::getStringAttr((mlir::StringAttr **)(a4 + 8), (mlir::MLIRContext *)v122);
      if (!v43)
        goto LABEL_80;
      v79 = *v43;
      v80 = mlir::TypeID::get<mlir::ShapedType>();
      v81 = *(unsigned int *)(v79 + 16);
      if (!(_DWORD)v81)
        goto LABEL_80;
      v82 = *(_QWORD **)(v79 + 8);
      v83 = &v82[2 * v81];
      do
      {
        v84 = v81 >> 1;
        v85 = &v82[2 * (v81 >> 1)];
        v87 = *v85;
        v86 = v85 + 2;
        v81 += ~(v81 >> 1);
        if (v87 < v80)
          v82 = v86;
        else
          v81 = v84;
      }
      while (v81);
      if (v82 != v83 && *v82 == v80)
        v88 = v82[1];
      else
LABEL_80:
        v88 = 0;
      v89 = mlir::DenseElementsAttr::getFromRawBuffer(v43, v88, v134, 8 * v135, 8, 1, 0);
      mlir::NamedAttrList::set((uint64_t)&v124, v78, v89);
      v90 = mlir::ValueRange::dereference_iterator(v140, 0);
      v122[0] = (uint64_t *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
      if (mlir::Type::isF16((mlir::Type *)v122)
        || (GOC = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118),
            mlir::Type::isF32((mlir::Type *)&GOC)))
      {
        GOC = 1;
        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
        v92 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&GOC, 1, OperandRange, 0);
        v93 = (uint64_t)v92;
        if (!v92)
          goto LABEL_92;
        v94 = *v92;
        v95 = mlir::TypeID::get<mlir::ShapedType>();
        v96 = *(unsigned int *)(v94 + 16);
        if (!(_DWORD)v96)
          goto LABEL_92;
        v97 = *(_QWORD **)(v94 + 8);
        v98 = &v97[2 * v96];
        do
        {
          v99 = v96 >> 1;
          v100 = &v97[2 * (v96 >> 1)];
          v102 = *v100;
          v101 = v100 + 2;
          v96 += ~(v96 >> 1);
          if (v102 < v95)
            v97 = v101;
          else
            v96 = v99;
        }
        while (v96);
        if (v97 != v98 && *v97 == v95)
          v103 = v97[1];
        else
LABEL_92:
          v103 = 0;
        v104 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
        v120 = (uint64_t)mlir::FloatAttr::get(v104, -1.0);
        v59 = 1;
        v122[0] = (uint64_t *)mlir::DenseElementsAttr::get(v93, v103, &v120, 1uLL);
        v105 = *((_QWORD *)v119 + 3);
        v120 = 1;
        v106 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
        GOC = mlir::MemRefType::get(&v120, (mlir::AffineMap *)1, v106, 0, 0, 0);
        v107 = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::MemRefType &,mlir::mps::MPSBufferTensorAttr &>((mlir::OpBuilder *)(a4 + 8), v105, &GOC, v122)- 16;
        v108 = *((_QWORD *)v119 + 3);
        v116 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&GOC);
        v120 = (uint64_t)mlir::OpBuilder::create<mlir::anec::MaxPool,mlir::Value &,mlir::NamedAttrList &>((mlir::UnknownLoc **)(a4 + 8), v108, (uint64_t)&v116, (uint64_t)&v124);
        v109 = (mlir::MLIRContext *)*((_QWORD *)v119 + 3);
        v110 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v120);
        mlir::ConversionPatternRewriter::replaceOp(a4, v119, (uint64_t)v122, 1);
      }
      else
      {
        v112 = v119;
        v122[0] = v118;
        v113 = *(_QWORD *)(a4 + 16);
        if (v113)
        {
          if (mlir::RewriterBase::Listener::classof(v113))
          else
            v59 = 0;
        }
        else
        {
          v59 = 0;
        }
      }
      if (v124 != v126)
        free(v124);
    }
LABEL_96:
    if (v128 != v130)
      free(v128);
    if (v131 != v133)
      free(v131);
    if (v134 != v136)
      free(v134);
    if (v137 != (void **)v139)
      free(v137);
    return v59;
  }
  v114 = (mlir::Operation ***)std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, "to MaxPool, AveragePool or Conv for A13 and below on ane is not supported \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  mlir::Diagnostic *v11;
  mlir::Diagnostic *v12;
  unint64_t v14;
  BOOL v15;
  char *v16;
  int v17;
  uint64_t v18;

  v3 = mlir::Diagnostic::operator<<(a2, "MaxPool/AveragePool for axes:");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = **a1;
  v17 = 2;
  v18 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v17;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v14 = v7 + 1;
    v15 = v5 + 24 * v7 > (unint64_t)&v17;
    if (v5 <= (unint64_t)&v17 && v15)
    {
      v16 = (char *)&v17 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v16[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v14, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v17;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  v11 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(v3, "reduced from Op ");
  v12 = mlir::Diagnostic::operator<<(v11, (mlir::Operation *)*a1[1]);
  return mlir::Diagnostic::operator<<((uint64_t)v12, "is not supported for A13 and below\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Axis value is incorrect for Op");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, "\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionMinOp,mlir::anec::ReduceMin,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionMinOp,mlir::mps::ReductionMinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(mlir::MemoryMapperInterface **a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t OperandRange;
  _BYTE *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  _BYTE *v14;
  _BYTE v15[24];

  v3 = mlir::Diagnostic::operator<<(a2, "ReduceMin for non fp type: ");
  OperandRange = mlir::MemoryMapperInterface::getOperandRange(*a1);
  v5 = v15;
  mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)v15, OperandRange);
  v6 = v3 + 16;
  v7 = *(_QWORD *)(v3 + 16);
  v8 = *(unsigned int *)(v3 + 24);
  if (v8 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v8 + 1;
    v13 = v7 + 24 * v8 > (unint64_t)v15;
    if (v7 <= (unint64_t)v15 && v13)
    {
      v14 = &v15[-v7];
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(v3 + 32), v12, 24);
      v7 = *(_QWORD *)(v3 + 16);
      v5 = &v14[v7];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(v3 + 32), v12, 24);
      v7 = *(_QWORD *)(v3 + 16);
      v5 = v15;
    }
  }
  v9 = v7 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v5;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v5 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " is not supported for A13 and below\n");
}

_QWORD *mlir::`anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)0>::~ConvertReductionA14Minus(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReductionA14Minus<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)0>::~ConvertReductionA14Minus(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6;
  unint64_t v7;
  char v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t IndexFromDim;
  char v34;
  uint64_t v35;
  uint64_t OperandRange;
  uint64_t *Value;
  uint64_t v38;
  llvm::APFloatBase *NumElements;
  llvm::APFloatBase *v40;
  llvm::APFloatBase *v41;
  uint64_t v42;
  mlir::Operation *v44;
  mlir::Operation *v45;
  mlir::MLIRContext *v46;
  void *v47;
  uint64_t v48;
  uint64_t F16Type;
  _QWORD *v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  _QWORD *v56;
  _QWORD *v57;
  unint64_t v58;
  unint64_t *v59;
  _QWORD *v60;
  unint64_t v61;
  uint64_t v62;
  mlir::Operation ***v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD v68[2];
  mlir::Operation *v69;
  __n128 *ElementsAttr;
  _QWORD v71[3];
  void *v72;
  uint64_t v73;
  _WORD v74[256];
  void *v75;
  uint64_t v76;
  _QWORD v77[2];
  int64x2_t v78;
  void *v79;
  uint64_t v80;
  _BYTE v81[48];
  void *v82;
  uint64_t v83;
  _BYTE v84[48];
  _BYTE *v85;
  uint64_t v86;
  _BYTE v87[48];
  _QWORD *v88;
  uint64_t v89;
  _BYTE v90[48];
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;

  v93 = *MEMORY[0x1E0C80C00];
  v69 = a2;
  v6 = *(_QWORD *)(a3 + 56);
  v91 = *(_QWORD *)(a3 + 48);
  v92 = v6;
  if (!v8)
  {
    v72 = "failed to convert operand axes";
    v74[8] = 259;
    v75 = &v72;
    v42 = *(_QWORD *)(a4 + 16);
    if (v42)
    {
      if (mlir::RewriterBase::Listener::classof(v42))
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v42 + 64))(v42, *((_QWORD *)a2 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionSumOp &>(mlir::mps::ReductionSumOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v75);
      return 0;
    }
    return v42;
  }
  v9 = (uint64_t *)v7;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v69))
  {
    v44 = v69;
    v72 = &v69;
    v42 = *(_QWORD *)(a4 + 16);
    if (v42)
    {
      if (mlir::RewriterBase::Listener::classof(v42))
      return 0;
    }
    return v42;
  }
  v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v69) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_12;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_12;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_12:
    v20 = 0;
  v88 = v90;
  v89 = 0x600000000;
  if (!v9)
    goto LABEL_22;
  v21 = *v9;
  v22 = mlir::TypeID::get<mlir::ElementsAttr>();
  v23 = *(unsigned int *)(v21 + 16);
  if (!(_DWORD)v23)
    goto LABEL_22;
  v24 = *(_QWORD **)(v21 + 8);
  v25 = &v24[2 * v23];
  do
  {
    v26 = v23 >> 1;
    v27 = &v24[2 * (v23 >> 1)];
    v29 = *v27;
    v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22)
      v24 = v28;
    else
      v23 = v26;
  }
  while (v23);
  if (v24 != v25 && *v24 == v22)
    v30 = v24[1];
  else
LABEL_22:
    v30 = 0;
  mlir::getIntValues<long long>((uint64_t)v9, v30, (uint64_t)&v88, 1);
  v85 = v87;
  memset(v87, 0, sizeof(v87));
  v86 = 0x600000006;
  v82 = v84;
  memset_pattern16(v84, &unk_181233190, 0x18uLL);
  v83 = 0x600000003;
  v79 = v81;
  memset_pattern16(v81, &unk_181233190, 0x18uLL);
  v80 = 0x600000003;
  v68[0] = mlir::getRankPromotionTypeForANE((uint64_t)v10, v20);
  v68[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v68);
  IndexFromDim = mlir::anec::getIndexFromDim(1, v32);
  if (v34)
  {
    if ((_DWORD)v89 == 1 && *v88 == IndexFromDim)
    {
      v66 = *((_QWORD *)v69 + 3);
      v35 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v68)
                      + 8 * IndexFromDim);
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v68);
      v75 = v77;
      v77[0] = 1;
      v77[1] = v35;
      v78 = vdupq_n_s64(1uLL);
      v76 = 0x1000000004;
      v67 = mlir::MemRefType::get(v77, (mlir::AffineMap *)4, OperandRange, 0, 0, 0);
      Value = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v67);
      NumElements = (llvm::APFloatBase *)mlir::ShapedType::getNumElements(Value, v38);
      v40 = (llvm::APFloatBase *)llvm::APFloatBase::IEEEhalf(NumElements);
      v41 = (llvm::APFloatBase *)llvm::APFloatBase::PPCDoubleDouble(v40);
      if (v41 == v40)
        llvm::detail::DoubleAPFloat::DoubleAPFloat(v71, (uint64_t)v40, 1);
      else
        llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v71, (uint64_t)v40, (llvm::APInt *)1);
      v72 = v74;
      v73 = 0x1000000000;
      llvm::SmallVectorImpl<llvm::APFloat>::assign((unsigned int *)&v72, (unint64_t)NumElements, (uint64_t)&ElementsAttr);
      if (v41 == (llvm::APFloatBase *)v71[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v71);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v71);
      v47 = v75;
      v48 = v76;
      F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a4 + 8), v46);
      v50 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v47, v48, F16Type, 0);
      ElementsAttr = mlir::createElementsAttr(v50, (uint64_t)v72, v73);
      v71[0] = v51;
      mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 8), v66, &v67, (_QWORD **)&ElementsAttr);
      v52 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v69) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v52)
        goto LABEL_53;
      v53 = *v52;
      v54 = mlir::TypeID::get<mlir::ShapedType>();
      v55 = *(unsigned int *)(v53 + 16);
      if (!(_DWORD)v55)
        goto LABEL_53;
      v56 = *(_QWORD **)(v53 + 8);
      v57 = &v56[2 * v55];
      do
      {
        v58 = v55 >> 1;
        v59 = &v56[2 * (v55 >> 1)];
        v61 = *v59;
        v60 = v59 + 2;
        v55 += ~(v55 >> 1);
        if (v61 < v54)
          v56 = v60;
        else
          v55 = v58;
      }
      while (v55);
      if (v56 != v57 && *v56 == v54)
        v62 = v56[1];
      else
LABEL_53:
        v62 = 0;
    }
    v45 = v69;
    v72 = &v69;
    v42 = *(_QWORD *)(a4 + 16);
    if (v42)
    {
      if (mlir::RewriterBase::Listener::classof(v42))
      else
        v42 = 0;
    }
    if (v79 != v81)
      free(v79);
    if (v82 != v84)
      free(v82);
    if (v85 != v87)
      free(v85);
    if (v88 != (_QWORD *)v90)
      free(v88);
    return v42;
  }
  v64 = (mlir::Operation ***)std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionSumOp,mlir::mps::ReductionSumOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Collapsing dimension for Op");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, "to MaxPool, AveragePool or Conv for A13 and below on ane is not supported \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertReduction<mlir::mps::ReductionSumOp,mlir::anec::ReduceSum,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReductionSumOp,mlir::mps::ReductionSumOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "ReduceSum for axes other than channel axis: ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " is not supported for A13 and below\n");
}

_QWORD *mlir::`anonymous namespace'::ConvertReshape<(mlir::anec::Family)0>::~ConvertReshape(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReshape<(mlir::anec::Family)0>::~ConvertReshape(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReshapeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReshapeOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ReshapeOpGenericAdaptorBase::ReshapeOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReshapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ReshapeOpGenericAdaptorBase::ReshapeOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReshapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 48);
  v9 = *(_QWORD *)(a3 + 56);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      v29 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const void *v45;
  uint64_t v46;
  uint64_t v47;
  const void *v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  unint64_t v56;
  unint64_t *v57;
  _QWORD *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t RankPromotionTypeForANE;
  uint64_t v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  unint64_t v70;
  unint64_t *v71;
  _QWORD *v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t Context;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t *v82;
  uint64_t v83;
  unint64_t v84;
  unint64_t v85;
  _QWORD *v86;
  _QWORD *v87;
  unint64_t v88;
  unint64_t *v89;
  _QWORD *v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t *v96;
  uint64_t v97;
  unint64_t v98;
  unint64_t v99;
  _QWORD *v100;
  _QWORD *v101;
  unint64_t v102;
  unint64_t *v103;
  _QWORD *v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t IntegerType;
  _QWORD *v114;
  _QWORD *v115;
  uint64_t v116;
  unint64_t v117;
  unint64_t v118;
  _QWORD *v119;
  _QWORD *v120;
  unint64_t v121;
  unint64_t *v122;
  _QWORD *v123;
  unint64_t v124;
  uint64_t v125;
  uint64_t v126;
  mlir::GenericProgramPoint *v127;
  unsigned int *v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  _QWORD v134[2];
  __int128 v135;
  _QWORD *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  __int128 v141;
  uint64_t v142;
  unint64_t v143[2];
  __int128 v144;
  uint64_t v145;
  __int128 v146;
  _QWORD v147[4];
  __int128 v148;
  uint64_t v149;

  v149 = *MEMORY[0x1E0C80C00];
  v138 = a2;
  v144 = *(_OWORD *)(a3 + 48);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v144, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v136 = v5;
  v137 = v15;
  v16 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v138) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  *(_QWORD *)&v146 = v16;
  *((_QWORD *)&v146 + 1) = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v146);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v136);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  *(_QWORD *)&v135 = mlir::getRankPromotionTypeForANE(v32, v42);
  *((_QWORD *)&v135 + 1) = v43;
  v134[0] = mlir::getRankPromotionTypeForANE((uint64_t)v136, v137);
  v134[1] = v44;
  v45 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v135);
  v47 = v46;
  v48 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v134);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    v128 = (unsigned int *)v138;
    *(_QWORD *)&v146 = mlir::ValueRange::dereference_iterator(&v144, 0);
    v79 = 1;
    mlir::ValueRange::ValueRange(v143, (uint64_t)&v146, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v128, v143[0], v143[1]);
    return v79;
  }
  *(_QWORD *)&v148 = v138;
  v146 = v144;
  v50 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v146, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v50)
    goto LABEL_42;
  v51 = *v50;
  v52 = mlir::TypeID::get<mlir::ShapedType>();
  v53 = *(unsigned int *)(v51 + 16);
  if (!(_DWORD)v53)
    goto LABEL_42;
  v54 = *(_QWORD **)(v51 + 8);
  v55 = &v54[2 * v53];
  do
  {
    v56 = v53 >> 1;
    v57 = &v54[2 * (v53 >> 1)];
    v59 = *v57;
    v58 = v57 + 2;
    v53 += ~(v53 >> 1);
    if (v59 < v52)
      v54 = v58;
    else
      v53 = v56;
  }
  while (v53);
  if (v54 != v55 && *v54 == v52)
    v60 = v54[1];
  else
LABEL_42:
    v60 = 0;
  RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v50, v60);
  v63 = v62;
  v64 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v148) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v64)
    goto LABEL_52;
  v65 = *v64;
  v66 = mlir::TypeID::get<mlir::ShapedType>();
  v67 = *(unsigned int *)(v65 + 16);
  if (!(_DWORD)v67)
    goto LABEL_52;
  v68 = *(_QWORD **)(v65 + 8);
  v69 = &v68[2 * v67];
  do
  {
    v70 = v67 >> 1;
    v71 = &v68[2 * (v67 >> 1)];
    v73 = *v71;
    v72 = v71 + 2;
    v67 += ~(v67 >> 1);
    if (v73 < v66)
      v68 = v72;
    else
      v67 = v70;
  }
  while (v67);
  if (v68 != v69 && *v68 == v66)
    v74 = v68[1];
  else
LABEL_52:
    v74 = 0;
  v75 = mlir::getRankPromotionTypeForANE((uint64_t)v64, v74);
  if (mlir::anec::verifyCompatibilityWithFlatten(RankPromotionTypeForANE, v63, v75, v76))
  {
    v77 = *(_QWORD *)(v148 + 24);
    v142 = mlir::ValueRange::dereference_iterator(&v146, 0);
    Context = mlir::Attribute::getContext((mlir::Attribute *)(v148 + 24));
    v140 = mlir::anec::BoxCoordinateModeAttr::get(Context, 1);
    *(_QWORD *)&v141 = (char *)mlir::OpBuilder::create<mlir::anec::Flatten,mlir::Value,mlir::anec::FlattenModeAttr>((mlir::UnknownLoc **)(a4 + 8), v77, &v142, &v140)- 16;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)v148, (uint64_t)&v141, 1);
    return 1;
  }
  v80 = *(_QWORD *)(a4 + 16);
  if (v80)
  {
    v81 = v148;
    if (mlir::RewriterBase::Listener::classof(*(_QWORD *)(a4 + 16)))
    {
      {
        return 1;
      }
    }
  }
  v142 = v138;
  v148 = v144;
  v141 = v135;
  v82 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v148, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v82)
    goto LABEL_67;
  v83 = *v82;
  v84 = mlir::TypeID::get<mlir::ShapedType>();
  v85 = *(unsigned int *)(v83 + 16);
  if (!(_DWORD)v85)
    goto LABEL_67;
  v86 = *(_QWORD **)(v83 + 8);
  v87 = &v86[2 * v85];
  do
  {
    v88 = v85 >> 1;
    v89 = &v86[2 * (v85 >> 1)];
    v91 = *v89;
    v90 = v89 + 2;
    v85 += ~(v85 >> 1);
    if (v91 < v84)
      v86 = v90;
    else
      v85 = v88;
  }
  while (v85);
  if (v86 != v87 && *v86 == v84)
    v92 = v86[1];
  else
LABEL_67:
    v92 = 0;
  v93 = mlir::getRankPromotionTypeForANE((uint64_t)v82, v92);
  v95 = v94;
  v96 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v142) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v96)
    goto LABEL_77;
  v97 = *v96;
  v98 = mlir::TypeID::get<mlir::ShapedType>();
  v99 = *(unsigned int *)(v97 + 16);
  if (!(_DWORD)v99)
    goto LABEL_77;
  v100 = *(_QWORD **)(v97 + 8);
  v101 = &v100[2 * v99];
  do
  {
    v102 = v99 >> 1;
    v103 = &v100[2 * (v99 >> 1)];
    v105 = *v103;
    v104 = v103 + 2;
    v99 += ~(v99 >> 1);
    if (v105 < v98)
      v100 = v104;
    else
      v99 = v102;
  }
  while (v99);
  if (v100 != v101 && *v100 == v98)
    v106 = v100[1];
  else
LABEL_77:
    v106 = 0;
  v107 = mlir::getRankPromotionTypeForANE((uint64_t)v96, v106);
  if (mlir::anec::verifyCompatibilityWithUnflatten(v93, v95, v107, v108))
  {
    v109 = mlir::Attribute::getContext((mlir::Attribute *)(v142 + 24));
    v140 = mlir::anec::BoxCoordinateModeAttr::get(v109, 1);
    v110 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v141);
    v112 = v110 + 8 * v111;
    *(_QWORD *)&v146 = v147;
    v147[0] = *(_QWORD *)(v112 - 24);
    v147[1] = *(_QWORD *)(v112 - 16);
    v147[2] = *(_QWORD *)(v112 - 8);
    *((_QWORD *)&v146 + 1) = 0x300000003;
    v145 = 3;
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    v114 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v145, 1, IntegerType, 0);
    v115 = v114;
    if (!v114)
      goto LABEL_88;
    v116 = *v114;
    v117 = mlir::TypeID::get<mlir::ShapedType>();
    v118 = *(unsigned int *)(v116 + 16);
    if (!(_DWORD)v118)
      goto LABEL_88;
    v119 = *(_QWORD **)(v116 + 8);
    v120 = &v119[2 * v118];
    do
    {
      v121 = v118 >> 1;
      v122 = &v119[2 * (v118 >> 1)];
      v124 = *v122;
      v123 = v122 + 2;
      v118 += ~(v118 >> 1);
      if (v124 < v117)
        v119 = v123;
      else
        v118 = v121;
    }
    while (v118);
    if (v119 != v120 && *v119 == v117)
      v125 = v119[1];
    else
LABEL_88:
      v125 = 0;
    v145 = mlir::DenseElementsAttr::getFromRawBuffer(v115, v125, v146, 8 * DWORD2(v146), 8, 1, 0);
    v126 = v142;
    v139 = mlir::ValueRange::dereference_iterator(&v148, 0);
    v127 = mlir::OpBuilder::create<mlir::anec::Unflatten,mlir::Value,mlir::anec::FlattenModeAttr &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(_QWORD *)(v126 + 24), &v139, &v140, &v145);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v126, v127);
    if ((_QWORD *)v146 != v147)
      free((void *)v146);
    return 1;
  }
  v129 = *(_QWORD *)(a4 + 16);
  if (v129)
  {
    v130 = v142;
    if (mlir::RewriterBase::Listener::classof(*(_QWORD *)(a4 + 16)))
    {
      {
        return 1;
      }
    }
  }
  v131 = *(_QWORD *)(a4 + 16);
  if (v131 && (v132 = v138, mlir::RewriterBase::Listener::classof(v131)))
  else
    return 0;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Flatten,mlir::Value,mlir::anec::FlattenModeAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.flatten", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.flatten";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Flatten::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Flatten,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)0>::tryConvertToFlatten(mlir::mps::ReshapeOp,mlir::ValueRange,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Reshape target shape must be NxCx1x1 to be lowered as Flatten on ANEs.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)0>::tryConvertToUnflatten(mlir::mps::ReshapeOp,mlir::ValueRange,mlir::ShapedType,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Reshape input shape must be NxCx1x1 to be lowered as Unflatten on ANEs.");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Unflatten,mlir::Value,mlir::anec::FlattenModeAttr &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.unflatten", (const unsigned __int8 *)0xE, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"anec.unflatten";
    v19[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::Unflatten::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Unflatten,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ReshapeOp,mlir::mps::ReshapeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

_QWORD *mlir::`anonymous namespace'::ConvertReshape<(mlir::anec::Family)1>::~ConvertReshape(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReshape<(mlir::anec::Family)1>::~ConvertReshape(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const void *v45;
  uint64_t v46;
  uint64_t v47;
  const void *v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  unint64_t v56;
  unint64_t *v57;
  _QWORD *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t RankPromotionTypeForANE;
  uint64_t v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  unint64_t v70;
  unint64_t *v71;
  _QWORD *v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t Context;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t *v82;
  uint64_t v83;
  unint64_t v84;
  unint64_t v85;
  _QWORD *v86;
  _QWORD *v87;
  unint64_t v88;
  unint64_t *v89;
  _QWORD *v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t *v96;
  uint64_t v97;
  unint64_t v98;
  unint64_t v99;
  _QWORD *v100;
  _QWORD *v101;
  unint64_t v102;
  unint64_t *v103;
  _QWORD *v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t IntegerType;
  _QWORD *v114;
  _QWORD *v115;
  uint64_t v116;
  unint64_t v117;
  unint64_t v118;
  _QWORD *v119;
  _QWORD *v120;
  unint64_t v121;
  unint64_t *v122;
  _QWORD *v123;
  unint64_t v124;
  uint64_t v125;
  uint64_t v126;
  mlir::GenericProgramPoint *v127;
  unsigned int *v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  _QWORD v134[2];
  __int128 v135;
  _QWORD *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  __int128 v141;
  uint64_t v142;
  unint64_t v143[2];
  __int128 v144;
  uint64_t v145;
  __int128 v146;
  _QWORD v147[4];
  __int128 v148;
  uint64_t v149;

  v149 = *MEMORY[0x1E0C80C00];
  v138 = a2;
  v144 = *(_OWORD *)(a3 + 48);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v144, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v136 = v5;
  v137 = v15;
  v16 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v138) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  *(_QWORD *)&v146 = v16;
  *((_QWORD *)&v146 + 1) = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v146);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v136);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  *(_QWORD *)&v135 = mlir::getRankPromotionTypeForANE(v32, v42);
  *((_QWORD *)&v135 + 1) = v43;
  v134[0] = mlir::getRankPromotionTypeForANE((uint64_t)v136, v137);
  v134[1] = v44;
  v45 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v135);
  v47 = v46;
  v48 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v134);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    v128 = (unsigned int *)v138;
    *(_QWORD *)&v146 = mlir::ValueRange::dereference_iterator(&v144, 0);
    v79 = 1;
    mlir::ValueRange::ValueRange(v143, (uint64_t)&v146, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v128, v143[0], v143[1]);
    return v79;
  }
  *(_QWORD *)&v148 = v138;
  v146 = v144;
  v50 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v146, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v50)
    goto LABEL_42;
  v51 = *v50;
  v52 = mlir::TypeID::get<mlir::ShapedType>();
  v53 = *(unsigned int *)(v51 + 16);
  if (!(_DWORD)v53)
    goto LABEL_42;
  v54 = *(_QWORD **)(v51 + 8);
  v55 = &v54[2 * v53];
  do
  {
    v56 = v53 >> 1;
    v57 = &v54[2 * (v53 >> 1)];
    v59 = *v57;
    v58 = v57 + 2;
    v53 += ~(v53 >> 1);
    if (v59 < v52)
      v54 = v58;
    else
      v53 = v56;
  }
  while (v53);
  if (v54 != v55 && *v54 == v52)
    v60 = v54[1];
  else
LABEL_42:
    v60 = 0;
  RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v50, v60);
  v63 = v62;
  v64 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v148) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v64)
    goto LABEL_52;
  v65 = *v64;
  v66 = mlir::TypeID::get<mlir::ShapedType>();
  v67 = *(unsigned int *)(v65 + 16);
  if (!(_DWORD)v67)
    goto LABEL_52;
  v68 = *(_QWORD **)(v65 + 8);
  v69 = &v68[2 * v67];
  do
  {
    v70 = v67 >> 1;
    v71 = &v68[2 * (v67 >> 1)];
    v73 = *v71;
    v72 = v71 + 2;
    v67 += ~(v67 >> 1);
    if (v73 < v66)
      v68 = v72;
    else
      v67 = v70;
  }
  while (v67);
  if (v68 != v69 && *v68 == v66)
    v74 = v68[1];
  else
LABEL_52:
    v74 = 0;
  v75 = mlir::getRankPromotionTypeForANE((uint64_t)v64, v74);
  if (mlir::anec::verifyCompatibilityWithFlatten(RankPromotionTypeForANE, v63, v75, v76))
  {
    v77 = *(_QWORD *)(v148 + 24);
    v142 = mlir::ValueRange::dereference_iterator(&v146, 0);
    Context = mlir::Attribute::getContext((mlir::Attribute *)(v148 + 24));
    v140 = mlir::anec::BoxCoordinateModeAttr::get(Context, 1);
    *(_QWORD *)&v141 = (char *)mlir::OpBuilder::create<mlir::anec::Flatten,mlir::Value,mlir::anec::FlattenModeAttr>((mlir::UnknownLoc **)(a4 + 8), v77, &v142, &v140)- 16;
    mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)v148, (uint64_t)&v141, 1);
    return 1;
  }
  v80 = *(_QWORD *)(a4 + 16);
  if (v80)
  {
    v81 = v148;
    if (mlir::RewriterBase::Listener::classof(*(_QWORD *)(a4 + 16)))
    {
      {
        return 1;
      }
    }
  }
  v142 = v138;
  v148 = v144;
  v141 = v135;
  v82 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v148, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v82)
    goto LABEL_67;
  v83 = *v82;
  v84 = mlir::TypeID::get<mlir::ShapedType>();
  v85 = *(unsigned int *)(v83 + 16);
  if (!(_DWORD)v85)
    goto LABEL_67;
  v86 = *(_QWORD **)(v83 + 8);
  v87 = &v86[2 * v85];
  do
  {
    v88 = v85 >> 1;
    v89 = &v86[2 * (v85 >> 1)];
    v91 = *v89;
    v90 = v89 + 2;
    v85 += ~(v85 >> 1);
    if (v91 < v84)
      v86 = v90;
    else
      v85 = v88;
  }
  while (v85);
  if (v86 != v87 && *v86 == v84)
    v92 = v86[1];
  else
LABEL_67:
    v92 = 0;
  v93 = mlir::getRankPromotionTypeForANE((uint64_t)v82, v92);
  v95 = v94;
  v96 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v142) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v96)
    goto LABEL_77;
  v97 = *v96;
  v98 = mlir::TypeID::get<mlir::ShapedType>();
  v99 = *(unsigned int *)(v97 + 16);
  if (!(_DWORD)v99)
    goto LABEL_77;
  v100 = *(_QWORD **)(v97 + 8);
  v101 = &v100[2 * v99];
  do
  {
    v102 = v99 >> 1;
    v103 = &v100[2 * (v99 >> 1)];
    v105 = *v103;
    v104 = v103 + 2;
    v99 += ~(v99 >> 1);
    if (v105 < v98)
      v100 = v104;
    else
      v99 = v102;
  }
  while (v99);
  if (v100 != v101 && *v100 == v98)
    v106 = v100[1];
  else
LABEL_77:
    v106 = 0;
  v107 = mlir::getRankPromotionTypeForANE((uint64_t)v96, v106);
  if (mlir::anec::verifyCompatibilityWithUnflatten(v93, v95, v107, v108))
  {
    v109 = mlir::Attribute::getContext((mlir::Attribute *)(v142 + 24));
    v140 = mlir::anec::BoxCoordinateModeAttr::get(v109, 1);
    v110 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v141);
    v112 = v110 + 8 * v111;
    *(_QWORD *)&v146 = v147;
    v147[0] = *(_QWORD *)(v112 - 24);
    v147[1] = *(_QWORD *)(v112 - 16);
    v147[2] = *(_QWORD *)(v112 - 8);
    *((_QWORD *)&v146 + 1) = 0x300000003;
    v145 = 3;
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    v114 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v145, 1, IntegerType, 0);
    v115 = v114;
    if (!v114)
      goto LABEL_88;
    v116 = *v114;
    v117 = mlir::TypeID::get<mlir::ShapedType>();
    v118 = *(unsigned int *)(v116 + 16);
    if (!(_DWORD)v118)
      goto LABEL_88;
    v119 = *(_QWORD **)(v116 + 8);
    v120 = &v119[2 * v118];
    do
    {
      v121 = v118 >> 1;
      v122 = &v119[2 * (v118 >> 1)];
      v124 = *v122;
      v123 = v122 + 2;
      v118 += ~(v118 >> 1);
      if (v124 < v117)
        v119 = v123;
      else
        v118 = v121;
    }
    while (v118);
    if (v119 != v120 && *v119 == v117)
      v125 = v119[1];
    else
LABEL_88:
      v125 = 0;
    v145 = mlir::DenseElementsAttr::getFromRawBuffer(v115, v125, v146, 8 * DWORD2(v146), 8, 1, 0);
    v126 = v142;
    v139 = mlir::ValueRange::dereference_iterator(&v148, 0);
    v127 = mlir::OpBuilder::create<mlir::anec::Unflatten,mlir::Value,mlir::anec::FlattenModeAttr &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(_QWORD *)(v126 + 24), &v139, &v140, &v145);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v126, v127);
    if ((_QWORD *)v146 != v147)
      free((void *)v146);
    return 1;
  }
  v129 = *(_QWORD *)(a4 + 16);
  if (v129)
  {
    v130 = v142;
    if (mlir::RewriterBase::Listener::classof(*(_QWORD *)(a4 + 16)))
    {
      {
        return 1;
      }
    }
  }
  v131 = *(_QWORD *)(a4 + 16);
  if (v131 && (v132 = v138, mlir::RewriterBase::Listener::classof(v131)))
  else
    return 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)1>::tryConvertToFlatten(mlir::mps::ReshapeOp,mlir::ValueRange,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Reshape target shape must be NxCx1x1 to be lowered as Flatten on ANEs.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)1>::tryConvertToUnflatten(mlir::mps::ReshapeOp,mlir::ValueRange,mlir::ShapedType,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Reshape input shape must be NxCx1x1 to be lowered as Unflatten on ANEs.");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ReshapeOp,mlir::mps::ReshapeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

_QWORD *mlir::`anonymous namespace'::ConvertReshape<(mlir::anec::Family)2>::~ConvertReshape(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReshape<(mlir::anec::Family)2>::~ConvertReshape(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  mlir::GenericProgramPoint *v45;
  uint64_t v47;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v49;
  _QWORD v50[2];
  uint64_t v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = a2;
  v52 = *(_OWORD *)(a3 + 48);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = v16;
  v49 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE(v32, v42);
  v49 = v43;
  v44 = v51;
  v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v44, v45);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertReshape<(mlir::anec::Family)3>::~ConvertReshape(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReshape<(mlir::anec::Family)3>::~ConvertReshape(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  mlir::GenericProgramPoint *v45;
  uint64_t v47;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v49;
  _QWORD v50[2];
  uint64_t v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = a2;
  v52 = *(_OWORD *)(a3 + 48);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = v16;
  v49 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE(v32, v42);
  v49 = v43;
  v44 = v51;
  v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v44, v45);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertReshape<(mlir::anec::Family)4>::~ConvertReshape(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReshape<(mlir::anec::Family)4>::~ConvertReshape(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  mlir::GenericProgramPoint *v45;
  uint64_t v47;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v49;
  _QWORD v50[2];
  uint64_t v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = a2;
  v52 = *(_OWORD *)(a3 + 48);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = v16;
  v49 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE(v32, v42);
  v49 = v43;
  v44 = v51;
  v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v44, v45);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertReshape<(mlir::anec::Family)5>::~ConvertReshape(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReshape<(mlir::anec::Family)5>::~ConvertReshape(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  mlir::GenericProgramPoint *v45;
  uint64_t v47;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v49;
  _QWORD v50[2];
  uint64_t v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = a2;
  v52 = *(_OWORD *)(a3 + 48);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = v16;
  v49 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE(v32, v42);
  v49 = v43;
  v44 = v51;
  v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v44, v45);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertReshape<(mlir::anec::Family)6>::~ConvertReshape(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReshape<(mlir::anec::Family)6>::~ConvertReshape(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ReshapeOp,(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  mlir::GenericProgramPoint *v45;
  uint64_t v47;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v49;
  _QWORD v50[2];
  uint64_t v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = a2;
  v52 = *(_OWORD *)(a3 + 48);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = v16;
  v49 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE(v32, v42);
  v49 = v43;
  v44 = v51;
  v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v44, v45);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)0>::~ConvertExpandDims(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)0>::~ConvertExpandDims(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExpandDimsOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExpandDimsOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ExpandDimsOpGenericAdaptorBase::ExpandDimsOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ExpandDimsOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ExpandDimsOpGenericAdaptorBase::ExpandDimsOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ExpandDimsOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExpandDimsOp &>(mlir::mps::ExpandDimsOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExpandDimsOp &>(mlir::mps::ExpandDimsOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const void *v45;
  uint64_t v46;
  uint64_t v47;
  const void *v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int *v51;
  uint64_t v52;
  unsigned int *v53;
  _QWORD v55[2];
  uint64_t RankPromotionTypeForANE;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  unsigned int *v60;
  uint64_t v61;
  unint64_t v62[2];
  __int128 v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v60 = a2;
  v63 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v63, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v58 = v5;
  v59 = v15;
  v16 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v60) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = (uint64_t)v16;
  v57 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v58);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v32, v42);
  v57 = v43;
  v55[0] = mlir::getRankPromotionTypeForANE((uint64_t)v58, v59);
  v55[1] = v44;
  v45 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v47 = v46;
  v48 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    v53 = v60;
    v61 = mlir::ValueRange::dereference_iterator(&v63, 0);
    v52 = 1;
    mlir::ValueRange::ValueRange(v62, (uint64_t)&v61, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v53, v62[0], v62[1]);
  }
  else
  {
    v50 = *(_QWORD *)(a4 + 16);
    if (v50 && (v51 = v60, mlir::RewriterBase::Listener::classof(v50)))
    else
      return 0;
  }
  return v52;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ExpandDimsOp &>(mlir::mps::ExpandDimsOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::ExpandDimsOp,mlir::mps::ExpandDimsOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

_QWORD *mlir::`anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)1>::~ConvertExpandDims(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)1>::~ConvertExpandDims(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const void *v45;
  uint64_t v46;
  uint64_t v47;
  const void *v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int *v51;
  uint64_t v52;
  unsigned int *v53;
  _QWORD v55[2];
  uint64_t RankPromotionTypeForANE;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  unsigned int *v60;
  uint64_t v61;
  unint64_t v62[2];
  __int128 v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v60 = a2;
  v63 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v63, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v58 = v5;
  v59 = v15;
  v16 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v60) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = (uint64_t)v16;
  v57 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v58);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v32, v42);
  v57 = v43;
  v55[0] = mlir::getRankPromotionTypeForANE((uint64_t)v58, v59);
  v55[1] = v44;
  v45 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v47 = v46;
  v48 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    v53 = v60;
    v61 = mlir::ValueRange::dereference_iterator(&v63, 0);
    v52 = 1;
    mlir::ValueRange::ValueRange(v62, (uint64_t)&v61, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v53, v62[0], v62[1]);
  }
  else
  {
    v50 = *(_QWORD *)(a4 + 16);
    if (v50 && (v51 = v60, mlir::RewriterBase::Listener::classof(v50)))
    else
      return 0;
  }
  return v52;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::ExpandDimsOp,mlir::mps::ExpandDimsOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

_QWORD *mlir::`anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)2>::~ConvertExpandDims(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)2>::~ConvertExpandDims(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  mlir::GenericProgramPoint *v45;
  uint64_t v47;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v49;
  _QWORD v50[2];
  uint64_t v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = v16;
  v49 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE(v32, v42);
  v49 = v43;
  v44 = v51;
  v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v44, v45);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)3>::~ConvertExpandDims(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)3>::~ConvertExpandDims(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  mlir::GenericProgramPoint *v45;
  uint64_t v47;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v49;
  _QWORD v50[2];
  uint64_t v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = v16;
  v49 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE(v32, v42);
  v49 = v43;
  v44 = v51;
  v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v44, v45);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)4>::~ConvertExpandDims(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)4>::~ConvertExpandDims(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  mlir::GenericProgramPoint *v45;
  uint64_t v47;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v49;
  _QWORD v50[2];
  uint64_t v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = v16;
  v49 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE(v32, v42);
  v49 = v43;
  v44 = v51;
  v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v44, v45);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)5>::~ConvertExpandDims(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)5>::~ConvertExpandDims(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  mlir::GenericProgramPoint *v45;
  uint64_t v47;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v49;
  _QWORD v50[2];
  uint64_t v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = v16;
  v49 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE(v32, v42);
  v49 = v43;
  v44 = v51;
  v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v44, v45);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)6>::~ConvertExpandDims(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertExpandDims<(mlir::anec::Family)6>::~ConvertExpandDims(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::ExpandDimsOp,(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  mlir::GenericProgramPoint *v45;
  uint64_t v47;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v49;
  _QWORD v50[2];
  uint64_t v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = v16;
  v49 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE(v32, v42);
  v49 = v43;
  v44 = v51;
  v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v44, v45);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)0>::~ConvertSqueeze(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)0>::~ConvertSqueeze(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SqueezeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SqueezeOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SqueezeOpGenericAdaptorBase::SqueezeOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SqueezeOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SqueezeOpGenericAdaptorBase::SqueezeOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SqueezeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SqueezeOp &>(mlir::mps::SqueezeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SqueezeOp &>(mlir::mps::SqueezeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const void *v45;
  uint64_t v46;
  uint64_t v47;
  const void *v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int *v51;
  uint64_t v52;
  unsigned int *v53;
  _QWORD v55[2];
  uint64_t RankPromotionTypeForANE;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  unsigned int *v60;
  uint64_t v61;
  unint64_t v62[2];
  __int128 v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v60 = a2;
  v63 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v63, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v58 = v5;
  v59 = v15;
  v16 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v60) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = (uint64_t)v16;
  v57 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v58);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v32, v42);
  v57 = v43;
  v55[0] = mlir::getRankPromotionTypeForANE((uint64_t)v58, v59);
  v55[1] = v44;
  v45 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v47 = v46;
  v48 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    v53 = v60;
    v61 = mlir::ValueRange::dereference_iterator(&v63, 0);
    v52 = 1;
    mlir::ValueRange::ValueRange(v62, (uint64_t)&v61, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v53, v62[0], v62[1]);
  }
  else
  {
    v50 = *(_QWORD *)(a4 + 16);
    if (v50 && (v51 = v60, mlir::RewriterBase::Listener::classof(v50)))
    else
      return 0;
  }
  return v52;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SqueezeOp &>(mlir::mps::SqueezeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::SqueezeOp,mlir::mps::SqueezeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

_QWORD *mlir::`anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)1>::~ConvertSqueeze(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)1>::~ConvertSqueeze(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const void *v45;
  uint64_t v46;
  uint64_t v47;
  const void *v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int *v51;
  uint64_t v52;
  unsigned int *v53;
  _QWORD v55[2];
  uint64_t RankPromotionTypeForANE;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  unsigned int *v60;
  uint64_t v61;
  unint64_t v62[2];
  __int128 v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v60 = a2;
  v63 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v63, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v58 = v5;
  v59 = v15;
  v16 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v60) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = (uint64_t)v16;
  v57 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v58);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v32, v42);
  v57 = v43;
  v55[0] = mlir::getRankPromotionTypeForANE((uint64_t)v58, v59);
  v55[1] = v44;
  v45 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v47 = v46;
  v48 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  if (v47 == v49 && !memcmp(v45, v48, 8 * v47))
  {
    v53 = v60;
    v61 = mlir::ValueRange::dereference_iterator(&v63, 0);
    v52 = 1;
    mlir::ValueRange::ValueRange(v62, (uint64_t)&v61, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v53, v62[0], v62[1]);
  }
  else
  {
    v50 = *(_QWORD *)(a4 + 16);
    if (v50 && (v51 = v60, mlir::RewriterBase::Listener::classof(v50)))
    else
      return 0;
  }
  return v52;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::SqueezeOp,mlir::mps::SqueezeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: op couldn't be folded or converted to flatten on A11/A12.");
}

_QWORD *mlir::`anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)2>::~ConvertSqueeze(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)2>::~ConvertSqueeze(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  mlir::GenericProgramPoint *v45;
  uint64_t v47;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v49;
  _QWORD v50[2];
  uint64_t v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = v16;
  v49 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE(v32, v42);
  v49 = v43;
  v44 = v51;
  v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v44, v45);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)3>::~ConvertSqueeze(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)3>::~ConvertSqueeze(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  mlir::GenericProgramPoint *v45;
  uint64_t v47;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v49;
  _QWORD v50[2];
  uint64_t v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = v16;
  v49 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE(v32, v42);
  v49 = v43;
  v44 = v51;
  v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v44, v45);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)4>::~ConvertSqueeze(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)4>::~ConvertSqueeze(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  mlir::GenericProgramPoint *v45;
  uint64_t v47;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v49;
  _QWORD v50[2];
  uint64_t v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = v16;
  v49 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE(v32, v42);
  v49 = v43;
  v44 = v51;
  v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v44, v45);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)5>::~ConvertSqueeze(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)5>::~ConvertSqueeze(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  mlir::GenericProgramPoint *v45;
  uint64_t v47;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v49;
  _QWORD v50[2];
  uint64_t v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = v16;
  v49 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE(v32, v42);
  v49 = v43;
  v44 = v51;
  v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v44, v45);
  return 1;
}

_QWORD *mlir::`anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)6>::~ConvertSqueeze(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertSqueeze<(mlir::anec::Family)6>::~ConvertSqueeze(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertToReshape<mlir::mps::SqueezeOp,(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  void *ArgAttrsAttr;
  mlir::AffineMap *v28;
  mlir::AffineMap *v29;
  uint64_t OperandRange;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  mlir::GenericProgramPoint *v45;
  uint64_t v47;
  _QWORD *RankPromotionTypeForANE;
  uint64_t v49;
  _QWORD v50[2];
  uint64_t v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v51 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v52, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v50[0] = v5;
  v50[1] = v15;
  v16 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  RankPromotionTypeForANE = v16;
  v49 = v26;
  ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v29 = v28;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
  v31 = (uint64_t *)mlir::MemRefType::get(ArgAttrsAttr, v29, OperandRange, 0, 0, 0);
  v32 = (uint64_t)v31;
  if (!v31)
    goto LABEL_30;
  v33 = *v31;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_30;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_30:
    v42 = 0;
  RankPromotionTypeForANE = (_QWORD *)mlir::getRankPromotionTypeForANE(v32, v42);
  v49 = v43;
  v44 = v51;
  v47 = mlir::ValueRange::dereference_iterator(&v52, 0);
  v45 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v44 + 24), (uint64_t *)&RankPromotionTypeForANE, &v47);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v44, v45);
  return 1;
}

void mlir::`anonymous namespace'::ConvertCast::~ConvertCast(mlir::_anonymous_namespace_::ConvertCast *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CastOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CastOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::CastOpGenericAdaptorBase::CastOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CastOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::CastOpGenericAdaptorBase::CastOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::CastOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 48);
  v9 = *(_QWORD *)(a3 + 56);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      v29 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CastOp &>(mlir::mps::CastOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CastOp &>(mlir::mps::CastOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertCast::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, mlir::scf::detail::IfOpGenericAdaptorBase *this, uint64_t *a4)
{
  unsigned int ODSOperandIndexAndLength;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  mlir::GenericProgramPoint *v26;
  uint64_t ResultElementType;
  uint64_t v28;
  unsigned int v29;
  unint64_t v30;
  mlir::GenericProgramPoint *v31;
  uint64_t v33;
  uint64_t v34[2];
  uint64_t v35;
  __int128 v36;
  char v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v35 = a2;
  ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0);
  v9 = *((_QWORD *)this + 6);
  *(_QWORD *)&v36 = v9;
  *((_QWORD *)&v36 + 1) = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v9 = mlir::ValueRange::offset_base(&v36, ODSOperandIndexAndLength);
  v36 = v9;
  v10 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v36, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_12;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_12;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_12:
    v20 = 0;
  v34[0] = (uint64_t)v10;
  v34[1] = v20;
  *(_QWORD *)&v36 = mlir::mps::detail::CastOpGenericAdaptorBase::getResultElementType(this);
  if (mlir::Type::isInteger((mlir::Type *)&v36, 1))
  {
    mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)&v36, *(const mlir::TypeConverter **)(a1 + 96));
    v21 = *(_QWORD *)(a2 + 24);
    v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0);
    v23 = *((_QWORD *)this + 6);
    v38 = v23;
    v39 = v22;
    if (v22)
      v23 = mlir::ValueRange::offset_base(&v38, v22);
    v38 = v23;
    v39 = 0;
    v33 = mlir::ValueRange::dereference_iterator(&v38, 0);
    v38 = (unint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseNotEqualZero,mlir::Value>(a4 + 1, v21, &v33);
    v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v35);
    v33 = mlir::TypeConverter::convertType((uint64_t)&v36, (void *)(*(_QWORD *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    v25 = v35;
    v26 = mlir::OpBuilder::create<mlir::anec::Cast,mlir::Type &,mlir::anec::ElementwiseNotEqualZero &>((mlir::OpBuilder *)(a4 + 1), *(_QWORD *)(v35 + 24), &v33, &v38);
    (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v25, v26);
    mlir::TypeConverter::~TypeConverter((pthread_rwlock_t **)&v36);
  }
  ResultElementType = mlir::mps::detail::CastOpGenericAdaptorBase::getResultElementType(this);
  LOBYTE(v36) = 0;
  v37 = 0;
  v38 = mlir::ShapedType::cloneWith(v34, &v36, ResultElementType);
  v39 = v28;
  v29 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0);
  v30 = *((_QWORD *)this + 6);
  *(_QWORD *)&v36 = v30;
  *((_QWORD *)&v36 + 1) = v29;
  if (v29)
    v30 = mlir::ValueRange::offset_base(&v36, v29);
  v36 = v30;
  *(_QWORD *)&v36 = mlir::ValueRange::dereference_iterator(&v36, 0);
  v31 = mlir::OpBuilder::create<mlir::anec::Cast,mlir::ShapedType &,mlir::Value>((mlir::OpBuilder *)(a4 + 1), *(_QWORD *)(a2 + 24), (uint64_t *)&v38, (uint64_t *)&v36);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v31);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Cast,mlir::Type &,mlir::anec::ElementwiseNotEqualZero &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.cast", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.cast";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4 - 16);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Cast,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Cast,mlir::ShapedType &,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.cast", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.cast";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Cast,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::`anonymous namespace'::ConvertSoftmax::~ConvertSoftmax(mlir::_anonymous_namespace_::ConvertSoftmax *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftmaxOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftmaxOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SoftmaxOpGenericAdaptorBase::SoftmaxOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftmaxOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SoftmaxOpGenericAdaptorBase::SoftmaxOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SoftmaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SoftmaxOp &>(mlir::mps::SoftmaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SoftmaxOp &>(mlir::mps::SoftmaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertSoftmax::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  mlir::GenericProgramPoint *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  unsigned __int8 v26;
  uint64_t v27[2];
  _QWORD v28[2];
  uint64_t v29;
  __int128 v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v29 = a2;
  v30 = *(_OWORD *)(a3 + 40);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v29) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v28[0] = v5;
  v28[1] = v15;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v28) & 1) == 0)
  {
    v22 = *(_QWORD *)(a4 + 16);
    if (v22)
    {
      v23 = v29;
      if (mlir::RewriterBase::Listener::classof(v22))
    }
    return 0;
  }
  v16 = 1;
  v17 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v30, 1);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v28);
  v27[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(v17, v18, 0, 0);
  v27[1] = v19;
  if (!(_BYTE)v19)
    return 0;
  v26 = 1;
  v20 = v29;
  v25 = mlir::ValueRange::dereference_iterator(&v30, 0);
  v21 = mlir::OpBuilder::create<mlir::anec::Softmax,mlir::Value,mlir::DenseIntElementsAttr &,BOOL &>((mlir::UnitAttr **)(a4 + 8), *(_QWORD *)(v20 + 24), &v25, v27, &v26);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v20, v21);
  return v16;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SoftmaxOp &>(mlir::mps::SoftmaxOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertSoftmax::matchAndRewriteWithStaticShapes(mlir::mps::SoftmaxOp,mlir::mps::SoftmaxOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Softmax,mlir::Value,mlir::DenseIntElementsAttr &,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.softmax", (const unsigned __int8 *)0xC, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"anec.softmax";
    v19[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::Softmax::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Softmax,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::`anonymous namespace'::ConvertConcat::~ConvertConcat(mlir::_anonymous_namespace_::ConvertConcat *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConcatOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConcatOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ConcatOpGenericAdaptorBase::ConcatOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ConcatOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ConcatOpGenericAdaptorBase::ConcatOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ConcatOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 48);
  v9 = *(_QWORD *)(a3 + 56);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      v29 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConcatOp &>(mlir::mps::ConcatOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConcatOp &>(mlir::mps::ConcatOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertConcat::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t *v16;
  _QWORD *v17;
  unint64_t v18;
  uint64_t v19;
  _QWORD *Axis;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int *v25;
  uint64_t v26;
  uint64_t (*v27)(int, uint64_t);
  unsigned int *v28;
  unsigned int *v29;
  mlir::GenericProgramPoint *v30;
  BOOL InferredResultTypes;
  uint64_t v33;
  void *__p;
  unsigned int v35;
  uint64_t v36[2];
  _QWORD v37[2];
  unsigned int *v38;
  uint64_t v39[4];
  _QWORD v40[3];

  v40[2] = *MEMORY[0x1E0C80C00];
  v38 = a2;
  v5 = *(_QWORD *)(a3 + 48);
  v6 = *(_QWORD *)(a3 + 56);
  v40[0] = v5;
  v40[1] = v6;
  if (v6 == 2)
  {
    v39[0] = mlir::ValueRange::dereference_iterator(v40, 0);
    v8 = 1;
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, a2, (uint64_t)v39, 1);
    return v8;
  }
  v9 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(mlir::mps::ConcatOp::getValues((mlir::mps::ConcatOp *)&v38) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v9)
    goto LABEL_12;
  v10 = *v9;
  v11 = mlir::TypeID::get<mlir::ShapedType>();
  v12 = *(unsigned int *)(v10 + 16);
  if (!(_DWORD)v12)
    goto LABEL_12;
  v13 = *(_QWORD **)(v10 + 8);
  v14 = &v13[2 * v12];
  do
  {
    v15 = v12 >> 1;
    v16 = &v13[2 * (v12 >> 1)];
    v18 = *v16;
    v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11)
      v13 = v17;
    else
      v12 = v15;
  }
  while (v12);
  if (v13 != v14 && *v13 == v11)
    v19 = v13[1];
  else
LABEL_12:
    v19 = 0;
  v37[0] = v9;
  v37[1] = v19;
  Axis = (_QWORD *)mlir::mps::ConcatOp::getAxis((mlir::mps::ConcatOp *)&v38);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v37);
  v36[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Axis, v21, 0, 0);
  v36[1] = v22;
  if (!(_BYTE)v22)
  {
    v24 = a4[2];
    if (v24)
    {
      v25 = v38;
      if (mlir::RewriterBase::Listener::classof(v24))
      {
        v26 = *((_QWORD *)v25 + 3);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(_QWORD *)v24 + 64))(v24, v26, v27, v39);
      }
    }
    return 0;
  }
  if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v36) != 1)
  {
    v24 = a4[2];
    if (v24)
    {
      v28 = v38;
      if (mlir::RewriterBase::Listener::classof(v24))
      {
        v26 = *((_QWORD *)v28 + 3);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(_QWORD *)v24 + 64))(v24, v26, v27, v39);
      }
    }
    return 0;
  }
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v39, v36[0], 0);
  mlir::DenseElementsAttr::IntElementIterator::operator*(v39, (llvm::APInt *)&__p);
  if (v35 > 0x40)
    v23 = *(_QWORD *)__p;
  else
    v23 = (uint64_t)((_QWORD)__p << -(uint64_t)v35) >> -(uint64_t)v35;
  v33 = v23;
  InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v38);
  v29 = v38;
  v39[0] = v5;
  v39[1] = v6 - 1;
  v30 = mlir::OpBuilder::create<mlir::anec::Concat,mlir::ValueRange,unsigned long long &,BOOL>((mlir::Builder *)(a4 + 1), *((_QWORD *)v38 + 3), v39, &v33, (unsigned __int8 *)&InferredResultTypes);
  (*(void (**)(_QWORD *, unsigned int *, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v29, v30);
  if (v35 >= 0x41 && __p)
    operator delete[](__p);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ConcatOp &>(mlir::mps::ConcatOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertConcat::matchAndRewriteWithStaticShapes(mlir::mps::ConcatOp,mlir::mps::ConcatOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "ANE Concat supports only supports const positive axis \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertConcat::matchAndRewriteWithStaticShapes(mlir::mps::ConcatOp,mlir::mps::ConcatOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Concat supports only 1 axis \n");
}

void mlir::`anonymous namespace'::ConvertSplit::~ConvertSplit(mlir::_anonymous_namespace_::ConvertSplit *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SplitOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SplitOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SplitOpGenericAdaptorBase::SplitOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SplitOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SplitOpGenericAdaptorBase::SplitOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SplitOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 48);
  v9 = *(_QWORD *)(a3 + 56);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      v29 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SplitOp &>(mlir::mps::SplitOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SplitOp &>(mlir::mps::SplitOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertSplit::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *Filter;
  unint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t (*v24)(int, uint64_t);
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  unint64_t v32;
  unint64_t *v33;
  _QWORD *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t SplitSizes;
  unint64_t v39;
  unint64_t UInt;
  uint64_t v41;
  uint64_t *v42;
  uint64_t *v43;
  uint64_t v44;
  int64x2_t v45;
  int64x2_t *v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t (*v50)(int, uint64_t);
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t *v54;
  unint64_t v55;
  int64x2_t v56;
  int64x2_t *v57;
  uint64_t v58;
  unint64_t v59;
  int64x2_t *v60;
  uint64_t *v61;
  unint64_t v62;
  int64x2_t v63;
  int64x2_t *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t v69;
  mlir::GenericProgramPoint *v70;
  uint64_t v71;
  unsigned int v72;
  unsigned int *v73;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD v78[2];
  uint64_t v79;
  void *__p;
  unsigned int v81;
  uint64_t v82[2];
  _QWORD v83[2];
  uint64_t v84;
  unint64_t v85[2];
  void *FastmathAttr;
  uint64_t v87;
  _BYTE v88[32];
  int64x2_t *v89;
  uint64_t v90;
  _BYTE v91[32];
  __int128 v92;
  uint64_t v93;

  v93 = *MEMORY[0x1E0C80C00];
  v84 = a2;
  v92 = *(_OWORD *)(a3 + 48);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v84) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v83[0] = v5;
  v83[1] = v15;
  Filter = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v84);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v83);
  v82[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Filter, v17, 0, 0);
  v82[1] = v18;
  if (!(_BYTE)v18)
  {
    v21 = *(_QWORD *)(a4 + 16);
    if (!v21)
      return v21;
    v22 = v84;
    if (mlir::RewriterBase::Listener::classof(v21))
    {
      v23 = *(_QWORD *)(v22 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), int64x2_t **))(*(_QWORD *)v21 + 64))(v21, v23, v24, &v89);
    }
    return 0;
  }
  if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v82) != 1)
  {
    v21 = *(_QWORD *)(a4 + 16);
    if (!v21)
      return v21;
    v25 = v84;
    if (mlir::RewriterBase::Listener::classof(v21))
    {
      v23 = *(_QWORD *)(v25 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), int64x2_t **))(*(_QWORD *)v21 + 64))(v21, v23, v24, &v89);
    }
    return 0;
  }
  v19 = mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v89, v82[0], 0);
  mlir::DenseElementsAttr::IntElementIterator::operator*(v19, (llvm::APInt *)&__p);
  if (v81 > 0x40)
    v20 = *(_QWORD *)__p;
  else
    v20 = (uint64_t)((_QWORD)__p << -(uint64_t)v81) >> -(uint64_t)v81;
  v79 = v20;
  v26 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v92, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v26)
    goto LABEL_33;
  v27 = *v26;
  v28 = mlir::TypeID::get<mlir::ShapedType>();
  v29 = *(unsigned int *)(v27 + 16);
  if (!(_DWORD)v29)
    goto LABEL_33;
  v30 = *(_QWORD **)(v27 + 8);
  v31 = &v30[2 * v29];
  do
  {
    v32 = v29 >> 1;
    v33 = &v30[2 * (v29 >> 1)];
    v35 = *v33;
    v34 = v33 + 2;
    v29 += ~(v29 >> 1);
    if (v35 < v28)
      v30 = v34;
    else
      v29 = v32;
  }
  while (v29);
  if (v30 != v31 && *v30 == v28)
    v36 = v30[1];
  else
LABEL_33:
    v36 = 0;
  v78[0] = v26;
  v78[1] = v36;
  v37 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v78)
                  + 8 * v20);
  v89 = (int64x2_t *)v91;
  v90 = 0x400000000;
  if (mlir::mps::SplitOp::getSplitSizes((mlir::mps::SplitOp *)&v84))
  {
    SplitSizes = mlir::mps::SplitOp::getSplitSizes((mlir::mps::SplitOp *)&v84);
    if (mlir::matchConstantWithIntVector<long long>(SplitSizes, (uint64_t)&v89))
    {
      LODWORD(v39) = v90;
LABEL_75:
      FastmathAttr = v88;
      v87 = 0x400000000;
      if (v39 >= 5)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&FastmathAttr, v88, v39, 8);
        LODWORD(v39) = v90;
      }
      v77 = 0;
      if ((_DWORD)v39)
      {
        v67 = (uint64_t *)v89;
        v68 = 8 * v39;
        do
        {
          v76 = *v67;
          v69 = *(_QWORD *)(v84 + 24);
          v75 = mlir::ValueRange::dereference_iterator(&v92, 0);
          v70 = mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,long long const&,unsigned long long &,long long &>((mlir::Builder *)(a4 + 8), v69, &v75, &v79, &v77, &v76);
          v71 = v87;
          if (v87 >= (unint64_t)HIDWORD(v87))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&FastmathAttr, v88, v87 + 1, 8);
            v71 = v87;
          }
          *((_QWORD *)FastmathAttr + v71) = (char *)v70 - 16;
          v72 = v87 + 1;
          LODWORD(v87) = v87 + 1;
          v77 += v76;
          ++v67;
          v68 -= 8;
        }
        while (v68);
      }
      else
      {
        v72 = v87;
      }
      v73 = (unsigned int *)v84;
      mlir::ValueRange::ValueRange(v85, (uint64_t)FastmathAttr, v72);
      mlir::ConversionPatternRewriter::replaceOp(a4, v73, v85[0], v85[1]);
      if (FastmathAttr != v88)
        free(FastmathAttr);
      v21 = 1;
      goto LABEL_87;
    }
    v21 = *(_QWORD *)(a4 + 16);
    if (v21)
    {
      v48 = v84;
      if (mlir::RewriterBase::Listener::classof(v21))
      {
        v49 = *(_QWORD *)(v48 + 24);
LABEL_52:
        v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v21 + 64))(v21, v49, v50, &FastmathAttr);
        goto LABEL_87;
      }
      goto LABEL_65;
    }
    goto LABEL_87;
  }
  if (mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v84))
  {
    FastmathAttr = (void *)mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v84);
    UInt = (unint64_t)mlir::IntegerAttr::getUInt((mlir::IntegerAttr *)&FastmathAttr);
    v41 = (v37 + UInt - 1) / UInt;
    v39 = v37 / v41;
    if (v37 / v41 > (unint64_t)HIDWORD(v90))
    {
      LODWORD(v90) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v91, v37 / v41, 8);
      v42 = (uint64_t *)v89;
      v43 = (uint64_t *)v89;
      v44 = v37 / v41;
      if (v39 < 4)
        goto LABEL_95;
      v43 = &v89->i64[v39 & 0xFFFFFFFFFFFFFFFCLL];
      v44 = (v37 / v41) & 3;
      v45 = vdupq_n_s64(v41);
      v46 = v89 + 1;
      v47 = v39 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v46[-1] = v45;
        *v46 = v45;
        v46 += 2;
        v47 -= 4;
      }
      while (v47);
      if (v39 != (v39 & 0xFFFFFFFFFFFFFFFCLL))
      {
LABEL_95:
        do
        {
          *v43++ = v41;
          --v44;
        }
        while (v44);
      }
      goto LABEL_71;
    }
    v42 = (uint64_t *)v89;
    v52 = v90;
    if (v90 >= v39)
      v53 = v37 / v41;
    else
      v53 = v90;
    if (v53)
    {
      v54 = (uint64_t *)v89;
      v55 = v53;
      if (v53 < 4)
        goto LABEL_96;
      v54 = &v89->i64[v53 & 0xFFFFFFFC];
      v55 = v53 & 3;
      v56 = vdupq_n_s64(v41);
      v57 = v89 + 1;
      v58 = v53 & 0xFFFFFFFC;
      do
      {
        v57[-1] = v56;
        *v57 = v56;
        v57 += 2;
        v58 -= 4;
      }
      while (v58);
      if (v53 != (v53 & 0xFFFFFFFC))
      {
LABEL_96:
        do
        {
          *v54++ = v41;
          --v55;
        }
        while (v55);
      }
    }
    v59 = v39 - v52;
    if (v39 <= v52)
      goto LABEL_71;
    v60 = (int64x2_t *)&v42[v52];
    if (v59 >= 4)
    {
      v61 = &v60->i64[v59 & 0xFFFFFFFFFFFFFFFCLL];
      v62 = v59 & 3;
      v63 = vdupq_n_s64(v41);
      v64 = v60 + 1;
      v65 = v59 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v64[-1] = v63;
        *v64 = v63;
        v64 += 2;
        v65 -= 4;
      }
      while (v65);
      if (v59 == (v59 & 0xFFFFFFFFFFFFFFFCLL))
      {
LABEL_71:
        LODWORD(v90) = v37 / v41;
        v66 = v37 % v41;
        if (v66)
        {
          if (HIDWORD(v90) <= v39)
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v91, v39 + 1, 8);
            LODWORD(v39) = v90;
            v42 = (uint64_t *)v89;
          }
          v42[v39] = v66;
          LODWORD(v39) = v90 + 1;
          LODWORD(v90) = v90 + 1;
        }
        goto LABEL_75;
      }
    }
    else
    {
      v61 = &v42[v52];
      v62 = v59;
    }
    do
    {
      *v61++ = v41;
      --v62;
    }
    while (v62);
    goto LABEL_71;
  }
  v21 = *(_QWORD *)(a4 + 16);
  if (v21)
  {
    v51 = v84;
    if (mlir::RewriterBase::Listener::classof(v21))
    {
      v49 = *(_QWORD *)(v51 + 24);
      goto LABEL_52;
    }
LABEL_65:
    v21 = 0;
  }
LABEL_87:
  if (v89 != (int64x2_t *)v91)
    free(v89);
  if (v81 >= 0x41 && __p)
    operator delete[](__p);
  return v21;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SplitOp &>(mlir::mps::SplitOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,long long const&,unsigned long long &,long long &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.input_view", (const unsigned __int8 *)0xF, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.input_view";
    v21[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::InputView::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertSplit::matchAndRewriteWithStaticShapes(mlir::mps::SplitOp,mlir::mps::SplitOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "ANE Split supports only supports const positive axis");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertSplit::matchAndRewriteWithStaticShapes(mlir::mps::SplitOp,mlir::mps::SplitOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Split supports only 1 axis");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertSplit::matchAndRewriteWithStaticShapes(mlir::mps::SplitOp,mlir::mps::SplitOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Cannot statically infer split sizes");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertSplit::matchAndRewriteWithStaticShapes(mlir::mps::SplitOp,mlir::mps::SplitOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Cannot infer split sizes");
}

_QWORD *mlir::`anonymous namespace'::ConvertResize<(mlir::anec::Family)0>::~ConvertResize(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertResize<(mlir::anec::Family)0>::~ConvertResize(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ResizeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ResizeOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[88];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ResizeOpGenericAdaptorBase::ResizeOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ResizeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[88];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ResizeOpGenericAdaptorBase::ResizeOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ResizeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _QWORD v31[2];
  _QWORD *v32;
  _QWORD v33[4];
  __int16 v34;
  _OWORD v35[6];
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 88);
  v9 = *(_QWORD *)(a3 + 96);
  v37 = v8;
  v38 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v36 = *(_QWORD *)(a3 + 96);
      v28 = *(_OWORD *)(a3 + 80);
      v35[4] = *(_OWORD *)(a3 + 64);
      v35[5] = v28;
      v29 = *(_OWORD *)(a3 + 16);
      v35[0] = *(_OWORD *)a3;
      v35[1] = v29;
      v30 = *(_OWORD *)(a3 + 48);
      v35[2] = *(_OWORD *)(a3 + 32);
      v35[3] = v30;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v35, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v37 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v38 = v23;
      if (v37)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v37))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v37);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v33[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v34 = 259;
    v31[0] = v33;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v31);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v37, v10);
    v31[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v31[1] = v13;
    if (v31[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v31);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v38;
    if (v37 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v34 = 259;
  v32 = v33;
  v33[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v32);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, __int128 *a3, uint64_t *a4)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int ODSOperandIndexAndLength;
  void *v22;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  unint64_t v29;
  unint64_t *v30;
  _QWORD *v31;
  unint64_t v32;
  void *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t IndexFromDim;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t IntegerType;
  _QWORD *v42;
  _QWORD *v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  _QWORD *v49;
  _QWORD *v50;
  unint64_t v51;
  unint64_t *v52;
  _QWORD *v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const void *ArgAttrsAttr;
  uint64_t v69;
  size_t v70;
  unsigned int v71;
  mlir::Operation *v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t ResizeLayout;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  _QWORD *v84;
  _QWORD *v85;
  unint64_t v86;
  unint64_t *v87;
  _QWORD *v88;
  unint64_t v89;
  uint64_t v90;
  mlir::mps *v91;
  uint64_t v92;
  mlir::GenericProgramPoint *v93;
  int v94;
  mlir::mps *v95;
  mlir::Operation *v96;
  uint64_t *v97;
  uint64_t DefiningOp;
  uint64_t v99;
  uint64_t v100;
  uint64_t *v101;
  int GateLayout;
  uint64_t v103;
  _QWORD *v104;
  _QWORD *v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  _QWORD *v109;
  _QWORD *v110;
  unint64_t v111;
  unint64_t *v112;
  _QWORD *v113;
  unint64_t v114;
  uint64_t v115;
  mlir::mps *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  void **v121;
  void *v122;
  uint64_t *v123;
  _BOOL4 InferredResultTypes;
  _BOOL4 IsSize;
  mlir::Operation *v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  void *v132;
  void *v133;
  unint64_t v134;
  void *v135;
  void *v136;
  float v137;
  float v138;
  unint64_t v139;
  void *v140;
  void *v141;
  unint64_t v142;
  void *v143;
  void *v144;
  float v145;
  float v146;
  unsigned int v147;
  void *v148;
  uint64_t *v149;
  uint64_t v150;
  unint64_t v151;
  unint64_t v152;
  _QWORD *v153;
  _QWORD *v154;
  unint64_t v155;
  unint64_t *v156;
  _QWORD *v157;
  unint64_t v158;
  void *v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t *v164;
  uint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t *v172;
  uint64_t v173;
  uint64_t v174;
  unint64_t v175;
  uint64_t v176;
  unint64_t v177;
  unint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t *v181;
  uint64_t *v182;
  uint64_t v183;
  unint64_t v184;
  unint64_t v185;
  _QWORD *v186;
  _QWORD *v187;
  unint64_t v188;
  unint64_t *v189;
  _QWORD *v190;
  unint64_t v191;
  void *v192;
  uint64_t v193;
  unint64_t v194;
  unint64_t v195;
  unint64_t v196;
  unint64_t v197;
  float v198;
  float v199;
  float v200;
  float v201;
  _BOOL4 v202;
  _BOOL4 v203;
  _BOOL4 v204;
  _BOOL4 v205;
  uint64_t v206;
  mlir::mps *v207;
  uint64_t v208;
  uint64_t (*v209)(int, uint64_t);
  const void *v210;
  uint64_t v211;
  mlir::mps *v212;
  uint64_t v213;
  _QWORD *v214;
  _QWORD *v215;
  uint64_t v216;
  unint64_t v217;
  unint64_t v218;
  _QWORD *v219;
  _QWORD *v220;
  unint64_t v221;
  unint64_t *v222;
  _QWORD *v223;
  unint64_t v224;
  uint64_t v225;
  uint64_t *v226;
  llvm::APFloatBase *v227;
  void *v228;
  void *v229;
  void *v230;
  unint64_t v231;
  char v232;
  uint64_t v233;
  _QWORD *v234;
  _QWORD *v235;
  uint64_t v236;
  unint64_t v237;
  unint64_t v238;
  _QWORD *v239;
  _QWORD *v240;
  unint64_t v241;
  unint64_t *v242;
  _QWORD *v243;
  unint64_t v244;
  uint64_t v245;
  mlir::mps *v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  _QWORD *v250;
  _QWORD *v251;
  uint64_t v252;
  unint64_t v253;
  unint64_t v254;
  _QWORD *v255;
  _QWORD *v256;
  unint64_t v257;
  unint64_t *v258;
  _QWORD *v259;
  unint64_t v260;
  uint64_t v261;
  uint64_t v262;
  unint64_t v263;
  mlir::Builder *v264;
  uint64_t v265;
  uint64_t *v267;
  unint64_t v268;
  mlir::mps *v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  _QWORD v273[2];
  _QWORD v274[2];
  uint64_t v275;
  mlir::mps *v276;
  mlir::Operation *v277[3];
  unint64_t v278[2];
  __int128 v279;
  __int128 v280;
  __int128 v281;
  __int128 v282;
  __int128 v283;
  _BYTE v284[24];
  uint64_t v285[4];
  void *v286[2];
  __int128 v287;
  unint64_t v288;
  unint64_t v289;
  unint64_t v290;
  unint64_t v291;
  void *v292[2];
  __int128 v293;
  __int128 v294;
  __int128 v295;
  __int128 v296;
  __int128 v297;
  unsigned int v298[2];
  void *__dst;
  uint64_t v300;
  _BYTE v301[16];
  void *v302;
  uint64_t v303;
  _BYTE v304[16];
  _QWORD *v305;
  uint64_t v306;
  _QWORD v307[2];
  uint64_t *v308;
  uint64_t v309;
  _QWORD v310[2];
  mlir::Operation *v311;
  uint64_t v312;
  _BYTE v313[32];
  __int128 v314;
  uint64_t v315;

  v315 = *MEMORY[0x1E0C80C00];
  v6 = a3[5];
  v283 = a3[4];
  *(_OWORD *)v284 = v6;
  *(_QWORD *)&v284[16] = *((_QWORD *)a3 + 12);
  v7 = a3[1];
  v279 = *a3;
  v280 = v7;
  v8 = a3[3];
  v281 = a3[2];
  v282 = v8;
  v276 = a2;
  v314 = *(_OWORD *)&v284[8];
  v9 = *((_QWORD *)a2 + 3);
  v275 = mlir::ValueRange::dereference_iterator(&v314, 0);
  v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v276) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_10;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_10;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_10:
    v20 = 0;
  v274[0] = v10;
  v274[1] = v20;
  ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v279, 0);
  v22 = *(void **)&v284[8];
  v292[0] = *(void **)&v284[8];
  v292[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v22 = (void *)mlir::ValueRange::offset_base(v292, ODSOperandIndexAndLength);
  v292[0] = v22;
  v292[1] = 0;
  v23 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v292, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v269 = a2;
  if (!v23)
    goto LABEL_22;
  v24 = *v23;
  v25 = mlir::TypeID::get<mlir::ShapedType>();
  v26 = *(unsigned int *)(v24 + 16);
  if (!(_DWORD)v26)
    goto LABEL_22;
  v27 = *(_QWORD **)(v24 + 8);
  v28 = &v27[2 * v26];
  do
  {
    v29 = v26 >> 1;
    v30 = &v27[2 * (v26 >> 1)];
    v32 = *v30;
    v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25)
      v27 = v31;
    else
      v26 = v29;
  }
  while (v26);
  if (v27 != v28 && *v27 == v25)
    v33 = (void *)v27[1];
  else
LABEL_22:
    v33 = 0;
  v292[0] = v23;
  v292[1] = v33;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v292);
  v35 = v34;
  IndexFromDim = mlir::anec::getIndexFromDim(0, v34);
  v37 = mlir::anec::getIndexFromDim(1, v35);
  v38 = mlir::anec::getIndexFromDim(3, v35);
  v39 = mlir::anec::getIndexFromDim(4, v35);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v274);
  if (v40 <= 3)
  {
    v292[0] = &v293;
    *(_QWORD *)&v293 = IndexFromDim;
    *((_QWORD *)&v293 + 1) = v37;
    *(_QWORD *)&v294 = v37;
    *((_QWORD *)&v294 + 1) = v38;
    *(_QWORD *)&v295 = v38;
    *((_QWORD *)&v295 + 1) = IndexFromDim;
    v292[1] = (void *)0x600000006;
    *(_OWORD *)v286 = xmmword_1812464A0;
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    v42 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 2, IntegerType, 0);
    v43 = v42;
    if (v42)
    {
      v44 = v39;
      v45 = v9;
      v46 = *v42;
      v47 = mlir::TypeID::get<mlir::ShapedType>();
      v48 = *(unsigned int *)(v46 + 16);
      if ((_DWORD)v48)
      {
        v49 = *(_QWORD **)(v46 + 8);
        v50 = &v49[2 * v48];
        do
        {
          v51 = v48 >> 1;
          v52 = &v49[2 * (v48 >> 1)];
          v54 = *v52;
          v53 = v52 + 2;
          v48 += ~(v48 >> 1);
          if (v54 < v47)
            v49 = v53;
          else
            v48 = v51;
        }
        while (v48);
        v9 = v45;
        if (v49 == v50)
        {
          v55 = 0;
          v39 = v44;
        }
        else
        {
          v39 = v44;
          if (*v49 != v47)
            goto LABEL_33;
          v55 = v49[1];
        }
      }
      else
      {
        v55 = 0;
        v9 = v45;
        v39 = v44;
      }
LABEL_39:
      v311 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v43, v55, v292[0], 8 * LODWORD(v292[1]), 8, 1, 0);
      v275 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v9, &v275, (uint64_t *)&v311)- 16;
      if (v292[0] != &v293)
        free(v292[0]);
      goto LABEL_41;
    }
LABEL_33:
    v55 = 0;
    goto LABEL_39;
  }
LABEL_41:
  v56 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v276) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v56)
    goto LABEL_50;
  v57 = *v56;
  v58 = mlir::TypeID::get<mlir::ShapedType>();
  v59 = *(unsigned int *)(v57 + 16);
  if (!(_DWORD)v59)
    goto LABEL_50;
  v60 = *(_QWORD **)(v57 + 8);
  v61 = &v60[2 * v59];
  do
  {
    v62 = v59 >> 1;
    v63 = &v60[2 * (v59 >> 1)];
    v65 = *v63;
    v64 = v63 + 2;
    v59 += ~(v59 >> 1);
    if (v65 < v58)
      v60 = v64;
    else
      v59 = v62;
  }
  while (v59);
  if (v60 != v61 && *v60 == v58)
    v66 = v60[1];
  else
LABEL_50:
    v66 = 0;
  v273[0] = v56;
  v273[1] = v66;
  ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v273);
  v69 = v67;
  v311 = (mlir::Operation *)v313;
  v312 = 0x400000000;
  v70 = 8 * v67;
  if ((unint64_t)(8 * v67) < 0x21)
  {
    v71 = 0;
    v72 = (mlir::Operation *)v313;
    if (!v69)
      goto LABEL_56;
    goto LABEL_55;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v311, v313, (8 * v67) >> 3, 8);
  v71 = v312;
  v72 = v311;
  if (v69)
  {
LABEL_55:
    memcpy((char *)v72 + 8 * v71, ArgAttrsAttr, v70);
    v71 = v312;
    v72 = v311;
  }
LABEL_56:
  v73 = v71 + (v70 >> 3);
  LODWORD(v312) = v73;
  if (v73 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v311, (uint64_t)v72, 4 - v73, 1uLL);
    v72 = v311;
  }
  v74 = *((_QWORD *)v72 + v38);
  v268 = v39;
  v75 = *((_QWORD *)v72 + v39);
  v308 = v310;
  v310[0] = v74;
  v310[1] = v75;
  v309 = 0x200000002;
  ResizeLayout = mlir::mps::getResizeLayout(v276, v72);
  if ((ResizeLayout & 0xFF00000000) != 0)
  {
    v265 = ResizeLayout;
    if (ResizeLayout == 1)
    {
      v292[0] = &v293;
      *(_QWORD *)&v293 = v37;
      *((_QWORD *)&v293 + 1) = v38;
      *(_QWORD *)&v294 = v38;
      *((_QWORD *)&v294 + 1) = v39;
      *(_QWORD *)&v295 = v39;
      *((_QWORD *)&v295 + 1) = v37;
      v292[1] = (void *)0x600000006;
      *(_OWORD *)v286 = xmmword_1812464A0;
      v77 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
      v78 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 2, v77, 0);
      v79 = v78;
      if (v78)
      {
        v80 = v9;
        v81 = *v78;
        v82 = mlir::TypeID::get<mlir::ShapedType>();
        v83 = *(unsigned int *)(v81 + 16);
        if ((_DWORD)v83)
        {
          v84 = *(_QWORD **)(v81 + 8);
          v85 = &v84[2 * v83];
          do
          {
            v86 = v83 >> 1;
            v87 = &v84[2 * (v83 >> 1)];
            v89 = *v87;
            v88 = v87 + 2;
            v83 += ~(v83 >> 1);
            if (v89 < v82)
              v84 = v88;
            else
              v83 = v86;
          }
          while (v83);
          v9 = v80;
          if (v84 == v85)
            v90 = 0;
          else
            v90 = *v84 == v82 ? v84[1] : 0;
        }
        else
        {
          v90 = 0;
          v9 = v80;
        }
      }
      else
      {
        v90 = 0;
      }
      v305 = (_QWORD *)mlir::DenseElementsAttr::getFromRawBuffer(v79, v90, v292[0], 8 * LODWORD(v292[1]), 8, 1, 0);
      v275 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v9, &v275, (uint64_t *)&v305)- 16;
      v96 = v311;
      v97 = v308;
      *v308 = *((_QWORD *)v311 + v37);
      v97[1] = *((_QWORD *)v96 + v38);
      if (v292[0] != &v293)
        free(v292[0]);
    }
    v286[0] = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v276);
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v286);
    if (DefiningOp
      && (v99 = DefiningOp,
          v100 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          (*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v99 + 48) + 32))(*(_QWORD *)(v99 + 48), v100)))
    {
      v263 = v38;
      v292[0] = &v293;
      v292[1] = (void *)0x100000000;
      mlir::Operation::fold(v99, 0, 0, (uint64_t)v292);
      v101 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v292[0] & 0xFFFFFFFFFFFFFFF8));
      if (v292[0] != &v293)
        free(v292[0]);
      v95 = v269;
      if (v101)
      {
        v262 = v9;
        v305 = v307;
        v307[0] = 0;
        v307[1] = 0;
        v306 = 0x200000002;
        v302 = v304;
        memset_pattern16(v304, &unk_181233190, 0x10uLL);
        v303 = 0x200000002;
        GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v276);
        v292[0] = (void *)2;
        v264 = (mlir::Builder *)(a4 + 1);
        v103 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
        v104 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v292, 1, v103, 0);
        v105 = v104;
        if (v104)
        {
          v106 = *v104;
          v107 = mlir::TypeID::get<mlir::ShapedType>();
          v108 = *(unsigned int *)(v106 + 16);
          if ((_DWORD)v108)
          {
            v109 = *(_QWORD **)(v106 + 8);
            v110 = &v109[2 * v108];
            do
            {
              v111 = v108 >> 1;
              v112 = &v109[2 * (v108 >> 1)];
              v114 = *v112;
              v113 = v112 + 2;
              v108 += ~(v108 >> 1);
              if (v114 < v107)
                v109 = v113;
              else
                v108 = v111;
            }
            while (v108);
            v95 = v269;
            if (v109 == v110 || *v109 != v107)
              goto LABEL_95;
            v115 = v109[1];
          }
          else
          {
            v115 = 0;
            v95 = v269;
          }
LABEL_114:
          if (GateLayout == 1)
            v121 = (void **)&v305;
          else
            v121 = &v302;
          v122 = *v121;
          v123 = &v306;
          if (GateLayout != 1)
            v123 = &v303;
          v272 = mlir::DenseElementsAttr::getFromRawBuffer(v105, v115, v122, 8 * *(unsigned int *)v123, 8, 1, 0);
          __dst = v301;
          v300 = 0x200000000;
          InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v276);
          IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v276);
          if (!mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v276)
            && !mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v276))
          {
            goto LABEL_222;
          }
          v296 = v283;
          v297 = *(_OWORD *)v284;
          *(_QWORD *)v298 = *(_QWORD *)&v284[16];
          *(_OWORD *)v292 = v279;
          v293 = v280;
          v294 = v281;
          v295 = v282;
          v277[0] = v276;
          v127 = mlir::mps::getResizeLayout(v276, v126);
          if ((v127 & 0xFF00000000) == 0)
            goto LABEL_208;
          v128 = 8 * (int)v127;
          v129 = *(_QWORD *)((char *)&unk_181246668 + v128);
          v130 = *(_QWORD *)((char *)&unk_1812466A0 + v128);
          v131 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 2u);
          v132 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v131;
          if ((_DWORD)v131)
          {
            v132 = (void *)mlir::ValueRange::offset_base(v286, v131);
            v133 = v286[1];
          }
          else
          {
            v133 = 0;
          }
          if ((void *)(HIDWORD(v131) + v131) == v133
            || (v286[0] = v132, v286[1] = 0, !mlir::ValueRange::dereference_iterator(v286, 0)))
          {
            v137 = 1.0;
            v138 = 1.0;
          }
          else
          {
            v134 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 2u);
            v135 = (void *)*((_QWORD *)&v297 + 1);
            v286[0] = *((void **)&v297 + 1);
            v286[1] = (void *)v134;
            if ((_DWORD)v134)
            {
              v135 = (void *)mlir::ValueRange::offset_base(v286, v134);
              v136 = v286[1];
            }
            else
            {
              v136 = 0;
            }
            if ((void *)(HIDWORD(v134) + v134) == v136)
            {
              v160 = 0;
            }
            else
            {
              v286[0] = v135;
              v286[1] = 0;
              v160 = mlir::ValueRange::dereference_iterator(v286, 0);
            }
            v285[0] = v160;
            v161 = mlir::Value::getDefiningOp((mlir::Value *)v285);
            if (!v161)
              goto LABEL_208;
            v162 = v161;
            v163 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v162 + 48) + 32))(*(_QWORD *)(v162 + 48), v163))goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x100000000;
            mlir::Operation::fold(v162, 0, 0, (uint64_t)v286);
            v164 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v286[0] & 0xFFFFFFFFFFFFFFF8));
            v166 = v165;
            if (v286[0] != &v287)
              free(v286[0]);
            v95 = v269;
            if (!v164)
              goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x400000000;
            mlir::getIntValues<float>((uint64_t)v164, v166, (uint64_t)v286, 1);
            v167 = LODWORD(v286[1]);
            v137 = 1.0;
            v138 = 1.0;
            if (v129 < LODWORD(v286[1]))
            {
              v138 = *((float *)v286[0] + v129);
              v137 = *((float *)v286[0] + v130);
            }
            if (v286[0] != &v287)
              free(v286[0]);
            if (v129 >= v167)
              goto LABEL_208;
          }
          v139 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 3u);
          v140 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v139;
          if ((_DWORD)v139)
          {
            v140 = (void *)mlir::ValueRange::offset_base(v286, v139);
            v141 = v286[1];
          }
          else
          {
            v141 = 0;
          }
          if ((void *)(HIDWORD(v139) + v139) == v141
            || (v286[0] = v140, v286[1] = 0, !mlir::ValueRange::dereference_iterator(v286, 0)))
          {
            v145 = 0.0;
            v146 = 0.0;
          }
          else
          {
            v142 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 3u);
            v143 = (void *)*((_QWORD *)&v297 + 1);
            v286[0] = *((void **)&v297 + 1);
            v286[1] = (void *)v142;
            if ((_DWORD)v142)
            {
              v143 = (void *)mlir::ValueRange::offset_base(v286, v142);
              v144 = v286[1];
            }
            else
            {
              v144 = 0;
            }
            if ((void *)(HIDWORD(v142) + v142) == v144)
            {
              v168 = 0;
            }
            else
            {
              v286[0] = v143;
              v286[1] = 0;
              v168 = mlir::ValueRange::dereference_iterator(v286, 0);
            }
            v285[0] = v168;
            v169 = mlir::Value::getDefiningOp((mlir::Value *)v285);
            if (!v169)
              goto LABEL_208;
            v170 = v169;
            v171 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v170 + 48) + 32))(*(_QWORD *)(v170 + 48), v171))goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x100000000;
            mlir::Operation::fold(v170, 0, 0, (uint64_t)v286);
            v172 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v286[0] & 0xFFFFFFFFFFFFFFF8));
            v174 = v173;
            if (v286[0] != &v287)
              free(v286[0]);
            v95 = v269;
            if (!v172)
              goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x400000000;
            mlir::getIntValues<float>((uint64_t)v172, v174, (uint64_t)v286, 1);
            v175 = LODWORD(v286[1]);
            v145 = 0.0;
            v146 = 0.0;
            if (v129 < LODWORD(v286[1]))
            {
              v146 = *((float *)v286[0] + v129);
              v145 = *((float *)v286[0] + v130);
            }
            if (v286[0] != &v287)
              free(v286[0]);
            if (v129 >= v175)
              goto LABEL_208;
          }
          v147 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 0);
          v148 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v147;
          if (v147)
            v148 = (void *)mlir::ValueRange::offset_base(v286, v147);
          v286[0] = v148;
          v286[1] = 0;
          v149 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v286, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v149)
            goto LABEL_149;
          v150 = *v149;
          v151 = mlir::TypeID::get<mlir::ShapedType>();
          v152 = *(unsigned int *)(v150 + 16);
          if ((_DWORD)v152)
          {
            v153 = *(_QWORD **)(v150 + 8);
            v154 = &v153[2 * v152];
            do
            {
              v155 = v152 >> 1;
              v156 = &v153[2 * (v152 >> 1)];
              v158 = *v156;
              v157 = v156 + 2;
              v152 += ~(v152 >> 1);
              if (v158 < v151)
                v153 = v157;
              else
                v152 = v155;
            }
            while (v152);
            v95 = v269;
            if (v153 == v154 || *v153 != v151)
            {
LABEL_149:
              v159 = 0;
              goto LABEL_182;
            }
            v159 = (void *)v153[1];
          }
          else
          {
            v159 = 0;
            v95 = v269;
          }
LABEL_182:
          v286[0] = v149;
          v286[1] = v159;
          v176 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v286);
          v178 = v177;
          v179 = *(_QWORD *)(a1 + 96);
          v180 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v277);
          v181 = (uint64_t *)mlir::TypeConverter::convertType(v179, (void *)(*(_QWORD *)(v180 + 8) & 0xFFFFFFFFFFFFFFF8));
          v182 = v181;
          if (v181)
          {
            v183 = *v181;
            v184 = mlir::TypeID::get<mlir::ShapedType>();
            v185 = *(unsigned int *)(v183 + 16);
            if ((_DWORD)v185)
            {
              v186 = *(_QWORD **)(v183 + 8);
              v187 = &v186[2 * v185];
              do
              {
                v188 = v185 >> 1;
                v189 = &v186[2 * (v185 >> 1)];
                v191 = *v189;
                v190 = v189 + 2;
                v185 += ~(v185 >> 1);
                if (v191 < v184)
                  v186 = v190;
                else
                  v185 = v188;
              }
              while (v185);
              v95 = v269;
              if (v186 == v187 || *v186 != v184)
                goto LABEL_191;
              v192 = (void *)v186[1];
            }
            else
            {
              v192 = 0;
              v95 = v269;
            }
LABEL_194:
            v286[0] = v182;
            v286[1] = v192;
            v193 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v286);
            v195 = v194;
            v196 = mlir::anec::getIndexFromDim(3, v178);
            v197 = mlir::anec::getIndexFromDim(4, v195);
            v198 = (float)*(uint64_t *)(v176 + 8 * v196);
            v199 = (float)*(uint64_t *)(v176 + 8 * v197);
            v200 = (float)*(uint64_t *)(v193 + 8 * v196);
            v201 = (float)*(uint64_t *)(v193 + 8 * v197);
            v202 = v146 != 0.0;
            if (v145 != 0.0)
              v202 = 1;
            v203 = (v138 + -1.0) * 0.5 != v146 || (v137 + -1.0) * 0.5 != v145;
            v204 = v138 != (float)(v200 / v198) || v137 != (float)(v201 / v199);
            v205 = v138 != (float)((float)(v200 + -1.0) / (float)(v198 + -1.0))
                || v137 != (float)((float)(v201 + -1.0) / (float)(v199 + -1.0));
            if (v202 || v204)
            {
              if (v202 || v205)
              {
                if (v203 || v204)
                {
LABEL_208:
                  v206 = a4[2];
                  if (!v206)
                    goto LABEL_212;
                  v207 = v276;
                  if (!mlir::RewriterBase::Listener::classof(a4[2]))
                    goto LABEL_212;
                  v208 = *((_QWORD *)v207 + 3);
LABEL_211:
                  (*(void (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v206 + 64))(v206, v208, v209, v286);
LABEL_212:
                  v93 = 0;
                  v94 = 0;
LABEL_213:
                  if (__dst != v301)
                    free(__dst);
                  if (v302 != v304)
                    free(v302);
                  if (v305 != v307)
                    free(v305);
                  goto LABEL_101;
                }
                InferredResultTypes = 0;
                IsSize = 1;
              }
              else
              {
                IsSize = 1;
                InferredResultTypes = 1;
              }
            }
            else
            {
              IsSize = 0;
              InferredResultTypes = 0;
            }
LABEL_222:
            if (InferredResultTypes && IsSize)
            {
              v286[0] = &v287;
              v287 = 0uLL;
            }
            else
            {
              if (InferredResultTypes || IsSize)
              {
                if (InferredResultTypes || !IsSize)
                {
                  v206 = a4[2];
                  if (!v206)
                    goto LABEL_212;
                  v212 = v276;
                  if (!mlir::RewriterBase::Listener::classof(a4[2]))
                    goto LABEL_212;
                  v208 = *((_QWORD *)v212 + 3);
                  goto LABEL_211;
                }
                v286[0] = &v287;
                v210 = &unk_181233190;
              }
              else
              {
                v286[0] = &v287;
                v210 = &unk_181246500;
              }
              memset_pattern16(&v287, v210, 0x10uLL);
            }
            v286[1] = (void *)0x600000002;
            v211 = v300;
            if (v300 >= 2)
            {
              *(_OWORD *)__dst = v287;
            }
            else
            {
              if (HIDWORD(v300) > 1)
              {
                if ((_DWORD)v300)
                  memmove(__dst, &v287, 8 * v300);
                else
                  v211 = 0;
              }
              else
              {
                LODWORD(v300) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v301, 2uLL, 8);
                v211 = 0;
              }
              if (v211 != LODWORD(v286[1]))
                memcpy((char *)__dst + 8 * v211, (char *)v286[0] + 8 * v211, 8 * LODWORD(v286[1]) - 8 * v211);
            }
            LODWORD(v300) = 2;
            LODWORD(v286[1]) = 0;
            if (v286[0] != &v287)
              free(v286[0]);
            v286[0] = (void *)2;
            v213 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
            v214 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 1, v213, 0);
            v215 = v214;
            if (!v214)
              goto LABEL_254;
            v216 = *v214;
            v217 = mlir::TypeID::get<mlir::ShapedType>();
            v218 = *(unsigned int *)(v216 + 16);
            if (!(_DWORD)v218)
              goto LABEL_254;
            v219 = *(_QWORD **)(v216 + 8);
            v220 = &v219[2 * v218];
            do
            {
              v221 = v218 >> 1;
              v222 = &v219[2 * (v218 >> 1)];
              v224 = *v222;
              v223 = v222 + 2;
              v218 += ~(v218 >> 1);
              if (v224 < v217)
                v219 = v223;
              else
                v218 = v221;
            }
            while (v218);
            if (v219 != v220 && *v219 == v217)
              v225 = v219[1];
            else
LABEL_254:
              v225 = 0;
            v271 = mlir::DenseElementsAttr::getFromRawBuffer(v215, v225, __dst, 8 * v300, 8, 1, 0);
            v226 = v308;
            v267 = v308 + 1;
            v227 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v285, -1.0);
            v228 = llvm::APFloatBase::IEEEsingle(v227);
            llvm::APFloat::Storage::Storage(&v286[1], v285, v228);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v285);
            llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v277, -1.0);
            llvm::APFloat::Storage::Storage(&v285[1], v277, v228);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v277);
            v277[0] = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v264, v262, &v275, v226, v267, (uint64_t)v286, (uint64_t)v285, &v272, &v271);
            v229 = (void *)v285[1];
            v230 = llvm::APFloatBase::PPCDoubleDouble(v277[0]);
            if (v230 == v229)
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v285[1]);
            else
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v285[1]);
            v231 = v263;
            if (v230 == v286[1])
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v286[1]);
            else
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v286[1]);
            v232 = mlir::anec::Resize::verifyAttributesWithFamily((uint64_t *)v277, 0);
            v93 = v277[0];
            if (!v232)
            {
              mlir::ConversionPatternRewriter::eraseOp((mlir::ConversionPatternRewriter *)a4, v277[0]);
              v286[0] = "requested attributes are not compatible with hardware requirements";
              LOWORD(v288) = 259;
              v246 = v276;
              v285[0] = (uint64_t)v286;
              v247 = a4[2];
              if (v247 && mlir::RewriterBase::Listener::classof(a4[2]))
                (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v247 + 64))(v247, *((_QWORD *)v246 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v285);
              v93 = 0;
              v94 = 0;
              v95 = v269;
              goto LABEL_213;
            }
            if (v265 != 1)
            {
LABEL_282:
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v274);
              if (v248 > 3)
              {
                v94 = 1;
                v95 = v269;
              }
              else
              {
                v286[0] = &v287;
                *(_QWORD *)&v287 = v37;
                *((_QWORD *)&v287 + 1) = IndexFromDim;
                v288 = v231;
                v289 = v37;
                v290 = IndexFromDim;
                v291 = v231;
                v286[1] = (void *)0x600000006;
                *(_OWORD *)v285 = xmmword_1812464A0;
                v249 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
                v250 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v285, 2, v249, 0);
                v251 = v250;
                if (v250
                  && (v252 = *v250,
                      v253 = mlir::TypeID::get<mlir::ShapedType>(),
                      v254 = *(unsigned int *)(v252 + 16),
                      (_DWORD)v254))
                {
                  v255 = *(_QWORD **)(v252 + 8);
                  v256 = &v255[2 * v254];
                  do
                  {
                    v257 = v254 >> 1;
                    v258 = &v255[2 * (v254 >> 1)];
                    v260 = *v258;
                    v259 = v258 + 2;
                    v254 += ~(v254 >> 1);
                    if (v260 < v253)
                      v255 = v259;
                    else
                      v254 = v257;
                  }
                  while (v254);
                  v95 = v269;
                  if (v255 != v256 && *v255 == v253)
                    v261 = v255[1];
                  else
                    v261 = 0;
                }
                else
                {
                  v261 = 0;
                  v95 = v269;
                }
                v270 = mlir::DenseElementsAttr::getFromRawBuffer(v251, v261, v286[0], 8 * LODWORD(v286[1]), 8, 1, 0);
                v285[0] = (uint64_t)v93 - 16;
                v93 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v264, v262, v285, &v270);
                if (v286[0] != &v287)
                  free(v286[0]);
                v94 = 1;
              }
              goto LABEL_213;
            }
            v286[0] = &v287;
            *(_QWORD *)&v287 = v37;
            *((_QWORD *)&v287 + 1) = v268;
            v288 = v263;
            v289 = v37;
            v290 = v268;
            v291 = v263;
            v286[1] = (void *)0x600000006;
            *(_OWORD *)v285 = xmmword_1812464A0;
            v233 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
            v234 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v285, 2, v233, 0);
            v235 = v234;
            if (!v234)
              goto LABEL_272;
            v236 = *v234;
            v237 = mlir::TypeID::get<mlir::ShapedType>();
            v238 = *(unsigned int *)(v236 + 16);
            if ((_DWORD)v238)
            {
              v239 = *(_QWORD **)(v236 + 8);
              v240 = &v239[2 * v238];
              do
              {
                v241 = v238 >> 1;
                v242 = &v239[2 * (v238 >> 1)];
                v244 = *v242;
                v243 = v242 + 2;
                v238 += ~(v238 >> 1);
                if (v244 < v237)
                  v239 = v243;
                else
                  v238 = v241;
              }
              while (v238);
              v231 = v263;
              if (v239 == v240 || *v239 != v237)
              {
LABEL_272:
                v245 = 0;
                goto LABEL_280;
              }
              v245 = v239[1];
            }
            else
            {
              v245 = 0;
              v231 = v263;
            }
LABEL_280:
            v270 = mlir::DenseElementsAttr::getFromRawBuffer(v235, v245, v286[0], 8 * LODWORD(v286[1]), 8, 1, 0);
            v93 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v264, v262, v277, &v270);
            if (v286[0] != &v287)
              free(v286[0]);
            goto LABEL_282;
          }
LABEL_191:
          v192 = 0;
          goto LABEL_194;
        }
LABEL_95:
        v115 = 0;
        goto LABEL_114;
      }
    }
    else
    {
      v95 = v269;
    }
    v292[0] = "Shape operand was not a constant";
    LOWORD(v294) = 259;
    v116 = v276;
    v286[0] = v292;
    v117 = a4[2];
    if (v117 && mlir::RewriterBase::Listener::classof(a4[2]))
      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v117 + 64))(v117, *((_QWORD *)v116 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    v93 = 0;
    v94 = 0;
  }
  else
  {
    v292[0] = "Resize layout not supported";
    LOWORD(v294) = 259;
    v91 = v276;
    v286[0] = v292;
    v92 = a4[2];
    if (v92 && mlir::RewriterBase::Listener::classof(a4[2]))
      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v92 + 64))(v92, *((_QWORD *)v91 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    v93 = 0;
    v94 = 0;
    v95 = v269;
  }
LABEL_101:
  if (v308 != v310)
    free(v308);
  if (v311 != (mlir::Operation *)v313)
    free(v311);
  if (v94)
  {
    v292[0] = (char *)v93 - 16;
    v118 = 1;
    mlir::ValueRange::ValueRange(v278, (uint64_t)v292, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)v95, v278[0], v278[1]);
  }
  else
  {
    v292[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v294) = 259;
    v286[0] = v292;
    v119 = a4[2];
    if (v119 && mlir::RewriterBase::Listener::classof(v119))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v119 + 64))(v119, *((_QWORD *)v95 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    else
      return 0;
  }
  return v118;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.transpose", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.transpose";
    v17[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Transpose::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Transpose,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t *a8, uint64_t *a9)
{
  uint64_t *Context;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  _QWORD *v27;
  mlir::GenericProgramPoint *v28;
  mlir::GenericProgramPoint *v29;
  uint64_t v31;
  const char *v32;
  __int16 v33;
  uint64_t v34[4];
  __int16 v35;
  char v36[8];
  _QWORD v37[3];
  char v38[8];
  _QWORD v39[3];
  _QWORD v40[40];

  v40[38] = *MEMORY[0x1E0C80C00];
  v31 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v31);
  v18 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.resize", (const unsigned __int8 *)0xB, Context);
  if (!v19)
  {
    v35 = 1283;
    v34[2] = (uint64_t)"anec.resize";
    v34[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v33 = 259;
    llvm::operator+(v34, (uint64_t *)&v32, (uint64_t)v40);
    llvm::report_fatal_error((llvm::Twine *)v40, 1);
  }
  mlir::OperationState::OperationState(v40, a2, v18);
  v20 = *a3;
  v21 = *a4;
  v22 = *a5;
  v24 = *(void **)(a6 + 8);
  v23 = (_QWORD *)(a6 + 8);
  v26 = llvm::APFloatBase::PPCDoubleDouble(v25);
  if (v26 == v24)
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v39, v23);
  else
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v39, (uint64_t)v23);
  v27 = (_QWORD *)(a7 + 8);
  if (v26 == *(void **)(a7 + 8))
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v37, v27);
  else
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v37, (uint64_t)v27);
  mlir::anec::Resize::build(a1, (uint64_t)v40, v20, v21, v22, (uint64_t)v38, (uint64_t)v36, *a8, *a9);
  if (v26 == (void *)v37[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v37);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v37);
  if (v26 == (void *)v39[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v39);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v39);
  v28 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v40);
  if (*(_UNKNOWN **)(*((_QWORD *)v28 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Resize,void>::id)
    v29 = v28;
  else
    v29 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v40);
  return v29;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.transpose", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.transpose";
    v17[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Transpose::build(a1, (uint64_t)v19, *a3 - 16, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Transpose,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)0>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)0>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

_QWORD *mlir::`anonymous namespace'::ConvertResize<(mlir::anec::Family)1>::~ConvertResize(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertResize<(mlir::anec::Family)1>::~ConvertResize(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, __int128 *a3, uint64_t *a4)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int ODSOperandIndexAndLength;
  void *v22;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  unint64_t v29;
  unint64_t *v30;
  _QWORD *v31;
  unint64_t v32;
  void *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t IndexFromDim;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t IntegerType;
  _QWORD *v42;
  _QWORD *v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  _QWORD *v49;
  _QWORD *v50;
  unint64_t v51;
  unint64_t *v52;
  _QWORD *v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const void *ArgAttrsAttr;
  uint64_t v69;
  size_t v70;
  unsigned int v71;
  mlir::Operation *v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t ResizeLayout;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  _QWORD *v84;
  _QWORD *v85;
  unint64_t v86;
  unint64_t *v87;
  _QWORD *v88;
  unint64_t v89;
  uint64_t v90;
  mlir::mps *v91;
  uint64_t v92;
  mlir::GenericProgramPoint *v93;
  int v94;
  mlir::mps *v95;
  mlir::Operation *v96;
  uint64_t *v97;
  uint64_t DefiningOp;
  uint64_t v99;
  uint64_t v100;
  uint64_t *v101;
  int GateLayout;
  uint64_t v103;
  _QWORD *v104;
  _QWORD *v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  _QWORD *v109;
  _QWORD *v110;
  unint64_t v111;
  unint64_t *v112;
  _QWORD *v113;
  unint64_t v114;
  uint64_t v115;
  mlir::mps *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  void **v121;
  void *v122;
  uint64_t *v123;
  _BOOL4 InferredResultTypes;
  _BOOL4 IsSize;
  mlir::Operation *v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  void *v132;
  void *v133;
  unint64_t v134;
  void *v135;
  void *v136;
  float v137;
  float v138;
  unint64_t v139;
  void *v140;
  void *v141;
  unint64_t v142;
  void *v143;
  void *v144;
  float v145;
  float v146;
  unsigned int v147;
  void *v148;
  uint64_t *v149;
  uint64_t v150;
  unint64_t v151;
  unint64_t v152;
  _QWORD *v153;
  _QWORD *v154;
  unint64_t v155;
  unint64_t *v156;
  _QWORD *v157;
  unint64_t v158;
  void *v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t *v164;
  uint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t *v172;
  uint64_t v173;
  uint64_t v174;
  unint64_t v175;
  uint64_t v176;
  unint64_t v177;
  unint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t *v181;
  uint64_t *v182;
  uint64_t v183;
  unint64_t v184;
  unint64_t v185;
  _QWORD *v186;
  _QWORD *v187;
  unint64_t v188;
  unint64_t *v189;
  _QWORD *v190;
  unint64_t v191;
  void *v192;
  uint64_t v193;
  unint64_t v194;
  unint64_t v195;
  unint64_t v196;
  unint64_t v197;
  float v198;
  float v199;
  float v200;
  float v201;
  _BOOL4 v202;
  _BOOL4 v203;
  _BOOL4 v204;
  _BOOL4 v205;
  uint64_t v206;
  mlir::mps *v207;
  uint64_t v208;
  uint64_t (*v209)(int, uint64_t);
  const void *v210;
  uint64_t v211;
  mlir::mps *v212;
  uint64_t v213;
  _QWORD *v214;
  _QWORD *v215;
  uint64_t v216;
  unint64_t v217;
  unint64_t v218;
  _QWORD *v219;
  _QWORD *v220;
  unint64_t v221;
  unint64_t *v222;
  _QWORD *v223;
  unint64_t v224;
  uint64_t v225;
  uint64_t *v226;
  llvm::APFloatBase *v227;
  void *v228;
  void *v229;
  void *v230;
  unint64_t v231;
  char v232;
  uint64_t v233;
  _QWORD *v234;
  _QWORD *v235;
  uint64_t v236;
  unint64_t v237;
  unint64_t v238;
  _QWORD *v239;
  _QWORD *v240;
  unint64_t v241;
  unint64_t *v242;
  _QWORD *v243;
  unint64_t v244;
  uint64_t v245;
  mlir::mps *v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  _QWORD *v250;
  _QWORD *v251;
  uint64_t v252;
  unint64_t v253;
  unint64_t v254;
  _QWORD *v255;
  _QWORD *v256;
  unint64_t v257;
  unint64_t *v258;
  _QWORD *v259;
  unint64_t v260;
  uint64_t v261;
  uint64_t v262;
  unint64_t v263;
  mlir::Builder *v264;
  uint64_t v265;
  uint64_t *v267;
  unint64_t v268;
  mlir::mps *v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  _QWORD v273[2];
  _QWORD v274[2];
  uint64_t v275;
  mlir::mps *v276;
  mlir::Operation *v277[3];
  unint64_t v278[2];
  __int128 v279;
  __int128 v280;
  __int128 v281;
  __int128 v282;
  __int128 v283;
  _BYTE v284[24];
  uint64_t v285[4];
  void *v286[2];
  __int128 v287;
  unint64_t v288;
  unint64_t v289;
  unint64_t v290;
  unint64_t v291;
  void *v292[2];
  __int128 v293;
  __int128 v294;
  __int128 v295;
  __int128 v296;
  __int128 v297;
  unsigned int v298[2];
  void *__dst;
  uint64_t v300;
  _BYTE v301[16];
  void *v302;
  uint64_t v303;
  _BYTE v304[16];
  _QWORD *v305;
  uint64_t v306;
  _QWORD v307[2];
  uint64_t *v308;
  uint64_t v309;
  _QWORD v310[2];
  mlir::Operation *v311;
  uint64_t v312;
  _BYTE v313[32];
  __int128 v314;
  uint64_t v315;

  v315 = *MEMORY[0x1E0C80C00];
  v6 = a3[5];
  v283 = a3[4];
  *(_OWORD *)v284 = v6;
  *(_QWORD *)&v284[16] = *((_QWORD *)a3 + 12);
  v7 = a3[1];
  v279 = *a3;
  v280 = v7;
  v8 = a3[3];
  v281 = a3[2];
  v282 = v8;
  v276 = a2;
  v314 = *(_OWORD *)&v284[8];
  v9 = *((_QWORD *)a2 + 3);
  v275 = mlir::ValueRange::dereference_iterator(&v314, 0);
  v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v276) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_10;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_10;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_10:
    v20 = 0;
  v274[0] = v10;
  v274[1] = v20;
  ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v279, 0);
  v22 = *(void **)&v284[8];
  v292[0] = *(void **)&v284[8];
  v292[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v22 = (void *)mlir::ValueRange::offset_base(v292, ODSOperandIndexAndLength);
  v292[0] = v22;
  v292[1] = 0;
  v23 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v292, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v269 = a2;
  if (!v23)
    goto LABEL_22;
  v24 = *v23;
  v25 = mlir::TypeID::get<mlir::ShapedType>();
  v26 = *(unsigned int *)(v24 + 16);
  if (!(_DWORD)v26)
    goto LABEL_22;
  v27 = *(_QWORD **)(v24 + 8);
  v28 = &v27[2 * v26];
  do
  {
    v29 = v26 >> 1;
    v30 = &v27[2 * (v26 >> 1)];
    v32 = *v30;
    v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25)
      v27 = v31;
    else
      v26 = v29;
  }
  while (v26);
  if (v27 != v28 && *v27 == v25)
    v33 = (void *)v27[1];
  else
LABEL_22:
    v33 = 0;
  v292[0] = v23;
  v292[1] = v33;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v292);
  v35 = v34;
  IndexFromDim = mlir::anec::getIndexFromDim(0, v34);
  v37 = mlir::anec::getIndexFromDim(1, v35);
  v38 = mlir::anec::getIndexFromDim(3, v35);
  v39 = mlir::anec::getIndexFromDim(4, v35);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v274);
  if (v40 <= 3)
  {
    v292[0] = &v293;
    *(_QWORD *)&v293 = IndexFromDim;
    *((_QWORD *)&v293 + 1) = v37;
    *(_QWORD *)&v294 = v37;
    *((_QWORD *)&v294 + 1) = v38;
    *(_QWORD *)&v295 = v38;
    *((_QWORD *)&v295 + 1) = IndexFromDim;
    v292[1] = (void *)0x600000006;
    *(_OWORD *)v286 = xmmword_1812464A0;
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    v42 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 2, IntegerType, 0);
    v43 = v42;
    if (v42)
    {
      v44 = v39;
      v45 = v9;
      v46 = *v42;
      v47 = mlir::TypeID::get<mlir::ShapedType>();
      v48 = *(unsigned int *)(v46 + 16);
      if ((_DWORD)v48)
      {
        v49 = *(_QWORD **)(v46 + 8);
        v50 = &v49[2 * v48];
        do
        {
          v51 = v48 >> 1;
          v52 = &v49[2 * (v48 >> 1)];
          v54 = *v52;
          v53 = v52 + 2;
          v48 += ~(v48 >> 1);
          if (v54 < v47)
            v49 = v53;
          else
            v48 = v51;
        }
        while (v48);
        v9 = v45;
        if (v49 == v50)
        {
          v55 = 0;
          v39 = v44;
        }
        else
        {
          v39 = v44;
          if (*v49 != v47)
            goto LABEL_33;
          v55 = v49[1];
        }
      }
      else
      {
        v55 = 0;
        v9 = v45;
        v39 = v44;
      }
LABEL_39:
      v311 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v43, v55, v292[0], 8 * LODWORD(v292[1]), 8, 1, 0);
      v275 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v9, &v275, (uint64_t *)&v311)- 16;
      if (v292[0] != &v293)
        free(v292[0]);
      goto LABEL_41;
    }
LABEL_33:
    v55 = 0;
    goto LABEL_39;
  }
LABEL_41:
  v56 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v276) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v56)
    goto LABEL_50;
  v57 = *v56;
  v58 = mlir::TypeID::get<mlir::ShapedType>();
  v59 = *(unsigned int *)(v57 + 16);
  if (!(_DWORD)v59)
    goto LABEL_50;
  v60 = *(_QWORD **)(v57 + 8);
  v61 = &v60[2 * v59];
  do
  {
    v62 = v59 >> 1;
    v63 = &v60[2 * (v59 >> 1)];
    v65 = *v63;
    v64 = v63 + 2;
    v59 += ~(v59 >> 1);
    if (v65 < v58)
      v60 = v64;
    else
      v59 = v62;
  }
  while (v59);
  if (v60 != v61 && *v60 == v58)
    v66 = v60[1];
  else
LABEL_50:
    v66 = 0;
  v273[0] = v56;
  v273[1] = v66;
  ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v273);
  v69 = v67;
  v311 = (mlir::Operation *)v313;
  v312 = 0x400000000;
  v70 = 8 * v67;
  if ((unint64_t)(8 * v67) < 0x21)
  {
    v71 = 0;
    v72 = (mlir::Operation *)v313;
    if (!v69)
      goto LABEL_56;
    goto LABEL_55;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v311, v313, (8 * v67) >> 3, 8);
  v71 = v312;
  v72 = v311;
  if (v69)
  {
LABEL_55:
    memcpy((char *)v72 + 8 * v71, ArgAttrsAttr, v70);
    v71 = v312;
    v72 = v311;
  }
LABEL_56:
  v73 = v71 + (v70 >> 3);
  LODWORD(v312) = v73;
  if (v73 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v311, (uint64_t)v72, 4 - v73, 1uLL);
    v72 = v311;
  }
  v74 = *((_QWORD *)v72 + v38);
  v268 = v39;
  v75 = *((_QWORD *)v72 + v39);
  v308 = v310;
  v310[0] = v74;
  v310[1] = v75;
  v309 = 0x200000002;
  ResizeLayout = mlir::mps::getResizeLayout(v276, v72);
  if ((ResizeLayout & 0xFF00000000) != 0)
  {
    v265 = ResizeLayout;
    if (ResizeLayout == 1)
    {
      v292[0] = &v293;
      *(_QWORD *)&v293 = v37;
      *((_QWORD *)&v293 + 1) = v38;
      *(_QWORD *)&v294 = v38;
      *((_QWORD *)&v294 + 1) = v39;
      *(_QWORD *)&v295 = v39;
      *((_QWORD *)&v295 + 1) = v37;
      v292[1] = (void *)0x600000006;
      *(_OWORD *)v286 = xmmword_1812464A0;
      v77 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
      v78 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 2, v77, 0);
      v79 = v78;
      if (v78)
      {
        v80 = v9;
        v81 = *v78;
        v82 = mlir::TypeID::get<mlir::ShapedType>();
        v83 = *(unsigned int *)(v81 + 16);
        if ((_DWORD)v83)
        {
          v84 = *(_QWORD **)(v81 + 8);
          v85 = &v84[2 * v83];
          do
          {
            v86 = v83 >> 1;
            v87 = &v84[2 * (v83 >> 1)];
            v89 = *v87;
            v88 = v87 + 2;
            v83 += ~(v83 >> 1);
            if (v89 < v82)
              v84 = v88;
            else
              v83 = v86;
          }
          while (v83);
          v9 = v80;
          if (v84 == v85)
            v90 = 0;
          else
            v90 = *v84 == v82 ? v84[1] : 0;
        }
        else
        {
          v90 = 0;
          v9 = v80;
        }
      }
      else
      {
        v90 = 0;
      }
      v305 = (_QWORD *)mlir::DenseElementsAttr::getFromRawBuffer(v79, v90, v292[0], 8 * LODWORD(v292[1]), 8, 1, 0);
      v275 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v9, &v275, (uint64_t *)&v305)- 16;
      v96 = v311;
      v97 = v308;
      *v308 = *((_QWORD *)v311 + v37);
      v97[1] = *((_QWORD *)v96 + v38);
      if (v292[0] != &v293)
        free(v292[0]);
    }
    v286[0] = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v276);
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v286);
    if (DefiningOp
      && (v99 = DefiningOp,
          v100 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          (*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v99 + 48) + 32))(*(_QWORD *)(v99 + 48), v100)))
    {
      v263 = v38;
      v292[0] = &v293;
      v292[1] = (void *)0x100000000;
      mlir::Operation::fold(v99, 0, 0, (uint64_t)v292);
      v101 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v292[0] & 0xFFFFFFFFFFFFFFF8));
      if (v292[0] != &v293)
        free(v292[0]);
      v95 = v269;
      if (v101)
      {
        v262 = v9;
        v305 = v307;
        v307[0] = 0;
        v307[1] = 0;
        v306 = 0x200000002;
        v302 = v304;
        memset_pattern16(v304, &unk_181233190, 0x10uLL);
        v303 = 0x200000002;
        GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v276);
        v292[0] = (void *)2;
        v264 = (mlir::Builder *)(a4 + 1);
        v103 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
        v104 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v292, 1, v103, 0);
        v105 = v104;
        if (v104)
        {
          v106 = *v104;
          v107 = mlir::TypeID::get<mlir::ShapedType>();
          v108 = *(unsigned int *)(v106 + 16);
          if ((_DWORD)v108)
          {
            v109 = *(_QWORD **)(v106 + 8);
            v110 = &v109[2 * v108];
            do
            {
              v111 = v108 >> 1;
              v112 = &v109[2 * (v108 >> 1)];
              v114 = *v112;
              v113 = v112 + 2;
              v108 += ~(v108 >> 1);
              if (v114 < v107)
                v109 = v113;
              else
                v108 = v111;
            }
            while (v108);
            v95 = v269;
            if (v109 == v110 || *v109 != v107)
              goto LABEL_95;
            v115 = v109[1];
          }
          else
          {
            v115 = 0;
            v95 = v269;
          }
LABEL_114:
          if (GateLayout == 1)
            v121 = (void **)&v305;
          else
            v121 = &v302;
          v122 = *v121;
          v123 = &v306;
          if (GateLayout != 1)
            v123 = &v303;
          v272 = mlir::DenseElementsAttr::getFromRawBuffer(v105, v115, v122, 8 * *(unsigned int *)v123, 8, 1, 0);
          __dst = v301;
          v300 = 0x200000000;
          InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v276);
          IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v276);
          if (!mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v276)
            && !mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v276))
          {
            goto LABEL_222;
          }
          v296 = v283;
          v297 = *(_OWORD *)v284;
          *(_QWORD *)v298 = *(_QWORD *)&v284[16];
          *(_OWORD *)v292 = v279;
          v293 = v280;
          v294 = v281;
          v295 = v282;
          v277[0] = v276;
          v127 = mlir::mps::getResizeLayout(v276, v126);
          if ((v127 & 0xFF00000000) == 0)
            goto LABEL_208;
          v128 = 8 * (int)v127;
          v129 = *(_QWORD *)((char *)&unk_181246668 + v128);
          v130 = *(_QWORD *)((char *)&unk_1812466A0 + v128);
          v131 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 2u);
          v132 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v131;
          if ((_DWORD)v131)
          {
            v132 = (void *)mlir::ValueRange::offset_base(v286, v131);
            v133 = v286[1];
          }
          else
          {
            v133 = 0;
          }
          if ((void *)(HIDWORD(v131) + v131) == v133
            || (v286[0] = v132, v286[1] = 0, !mlir::ValueRange::dereference_iterator(v286, 0)))
          {
            v137 = 1.0;
            v138 = 1.0;
          }
          else
          {
            v134 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 2u);
            v135 = (void *)*((_QWORD *)&v297 + 1);
            v286[0] = *((void **)&v297 + 1);
            v286[1] = (void *)v134;
            if ((_DWORD)v134)
            {
              v135 = (void *)mlir::ValueRange::offset_base(v286, v134);
              v136 = v286[1];
            }
            else
            {
              v136 = 0;
            }
            if ((void *)(HIDWORD(v134) + v134) == v136)
            {
              v160 = 0;
            }
            else
            {
              v286[0] = v135;
              v286[1] = 0;
              v160 = mlir::ValueRange::dereference_iterator(v286, 0);
            }
            v285[0] = v160;
            v161 = mlir::Value::getDefiningOp((mlir::Value *)v285);
            if (!v161)
              goto LABEL_208;
            v162 = v161;
            v163 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v162 + 48) + 32))(*(_QWORD *)(v162 + 48), v163))goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x100000000;
            mlir::Operation::fold(v162, 0, 0, (uint64_t)v286);
            v164 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v286[0] & 0xFFFFFFFFFFFFFFF8));
            v166 = v165;
            if (v286[0] != &v287)
              free(v286[0]);
            v95 = v269;
            if (!v164)
              goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x400000000;
            mlir::getIntValues<float>((uint64_t)v164, v166, (uint64_t)v286, 1);
            v167 = LODWORD(v286[1]);
            v137 = 1.0;
            v138 = 1.0;
            if (v129 < LODWORD(v286[1]))
            {
              v138 = *((float *)v286[0] + v129);
              v137 = *((float *)v286[0] + v130);
            }
            if (v286[0] != &v287)
              free(v286[0]);
            if (v129 >= v167)
              goto LABEL_208;
          }
          v139 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 3u);
          v140 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v139;
          if ((_DWORD)v139)
          {
            v140 = (void *)mlir::ValueRange::offset_base(v286, v139);
            v141 = v286[1];
          }
          else
          {
            v141 = 0;
          }
          if ((void *)(HIDWORD(v139) + v139) == v141
            || (v286[0] = v140, v286[1] = 0, !mlir::ValueRange::dereference_iterator(v286, 0)))
          {
            v145 = 0.0;
            v146 = 0.0;
          }
          else
          {
            v142 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 3u);
            v143 = (void *)*((_QWORD *)&v297 + 1);
            v286[0] = *((void **)&v297 + 1);
            v286[1] = (void *)v142;
            if ((_DWORD)v142)
            {
              v143 = (void *)mlir::ValueRange::offset_base(v286, v142);
              v144 = v286[1];
            }
            else
            {
              v144 = 0;
            }
            if ((void *)(HIDWORD(v142) + v142) == v144)
            {
              v168 = 0;
            }
            else
            {
              v286[0] = v143;
              v286[1] = 0;
              v168 = mlir::ValueRange::dereference_iterator(v286, 0);
            }
            v285[0] = v168;
            v169 = mlir::Value::getDefiningOp((mlir::Value *)v285);
            if (!v169)
              goto LABEL_208;
            v170 = v169;
            v171 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v170 + 48) + 32))(*(_QWORD *)(v170 + 48), v171))goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x100000000;
            mlir::Operation::fold(v170, 0, 0, (uint64_t)v286);
            v172 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v286[0] & 0xFFFFFFFFFFFFFFF8));
            v174 = v173;
            if (v286[0] != &v287)
              free(v286[0]);
            v95 = v269;
            if (!v172)
              goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x400000000;
            mlir::getIntValues<float>((uint64_t)v172, v174, (uint64_t)v286, 1);
            v175 = LODWORD(v286[1]);
            v145 = 0.0;
            v146 = 0.0;
            if (v129 < LODWORD(v286[1]))
            {
              v146 = *((float *)v286[0] + v129);
              v145 = *((float *)v286[0] + v130);
            }
            if (v286[0] != &v287)
              free(v286[0]);
            if (v129 >= v175)
              goto LABEL_208;
          }
          v147 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 0);
          v148 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v147;
          if (v147)
            v148 = (void *)mlir::ValueRange::offset_base(v286, v147);
          v286[0] = v148;
          v286[1] = 0;
          v149 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v286, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v149)
            goto LABEL_149;
          v150 = *v149;
          v151 = mlir::TypeID::get<mlir::ShapedType>();
          v152 = *(unsigned int *)(v150 + 16);
          if ((_DWORD)v152)
          {
            v153 = *(_QWORD **)(v150 + 8);
            v154 = &v153[2 * v152];
            do
            {
              v155 = v152 >> 1;
              v156 = &v153[2 * (v152 >> 1)];
              v158 = *v156;
              v157 = v156 + 2;
              v152 += ~(v152 >> 1);
              if (v158 < v151)
                v153 = v157;
              else
                v152 = v155;
            }
            while (v152);
            v95 = v269;
            if (v153 == v154 || *v153 != v151)
            {
LABEL_149:
              v159 = 0;
              goto LABEL_182;
            }
            v159 = (void *)v153[1];
          }
          else
          {
            v159 = 0;
            v95 = v269;
          }
LABEL_182:
          v286[0] = v149;
          v286[1] = v159;
          v176 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v286);
          v178 = v177;
          v179 = *(_QWORD *)(a1 + 96);
          v180 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v277);
          v181 = (uint64_t *)mlir::TypeConverter::convertType(v179, (void *)(*(_QWORD *)(v180 + 8) & 0xFFFFFFFFFFFFFFF8));
          v182 = v181;
          if (v181)
          {
            v183 = *v181;
            v184 = mlir::TypeID::get<mlir::ShapedType>();
            v185 = *(unsigned int *)(v183 + 16);
            if ((_DWORD)v185)
            {
              v186 = *(_QWORD **)(v183 + 8);
              v187 = &v186[2 * v185];
              do
              {
                v188 = v185 >> 1;
                v189 = &v186[2 * (v185 >> 1)];
                v191 = *v189;
                v190 = v189 + 2;
                v185 += ~(v185 >> 1);
                if (v191 < v184)
                  v186 = v190;
                else
                  v185 = v188;
              }
              while (v185);
              v95 = v269;
              if (v186 == v187 || *v186 != v184)
                goto LABEL_191;
              v192 = (void *)v186[1];
            }
            else
            {
              v192 = 0;
              v95 = v269;
            }
LABEL_194:
            v286[0] = v182;
            v286[1] = v192;
            v193 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v286);
            v195 = v194;
            v196 = mlir::anec::getIndexFromDim(3, v178);
            v197 = mlir::anec::getIndexFromDim(4, v195);
            v198 = (float)*(uint64_t *)(v176 + 8 * v196);
            v199 = (float)*(uint64_t *)(v176 + 8 * v197);
            v200 = (float)*(uint64_t *)(v193 + 8 * v196);
            v201 = (float)*(uint64_t *)(v193 + 8 * v197);
            v202 = v146 != 0.0;
            if (v145 != 0.0)
              v202 = 1;
            v203 = (v138 + -1.0) * 0.5 != v146 || (v137 + -1.0) * 0.5 != v145;
            v204 = v138 != (float)(v200 / v198) || v137 != (float)(v201 / v199);
            v205 = v138 != (float)((float)(v200 + -1.0) / (float)(v198 + -1.0))
                || v137 != (float)((float)(v201 + -1.0) / (float)(v199 + -1.0));
            if (v202 || v204)
            {
              if (v202 || v205)
              {
                if (v203 || v204)
                {
LABEL_208:
                  v206 = a4[2];
                  if (!v206)
                    goto LABEL_212;
                  v207 = v276;
                  if (!mlir::RewriterBase::Listener::classof(a4[2]))
                    goto LABEL_212;
                  v208 = *((_QWORD *)v207 + 3);
LABEL_211:
                  (*(void (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v206 + 64))(v206, v208, v209, v286);
LABEL_212:
                  v93 = 0;
                  v94 = 0;
LABEL_213:
                  if (__dst != v301)
                    free(__dst);
                  if (v302 != v304)
                    free(v302);
                  if (v305 != v307)
                    free(v305);
                  goto LABEL_101;
                }
                InferredResultTypes = 0;
                IsSize = 1;
              }
              else
              {
                IsSize = 1;
                InferredResultTypes = 1;
              }
            }
            else
            {
              IsSize = 0;
              InferredResultTypes = 0;
            }
LABEL_222:
            if (InferredResultTypes && IsSize)
            {
              v286[0] = &v287;
              v287 = 0uLL;
            }
            else
            {
              if (InferredResultTypes || IsSize)
              {
                if (InferredResultTypes || !IsSize)
                {
                  v206 = a4[2];
                  if (!v206)
                    goto LABEL_212;
                  v212 = v276;
                  if (!mlir::RewriterBase::Listener::classof(a4[2]))
                    goto LABEL_212;
                  v208 = *((_QWORD *)v212 + 3);
                  goto LABEL_211;
                }
                v286[0] = &v287;
                v210 = &unk_181233190;
              }
              else
              {
                v286[0] = &v287;
                v210 = &unk_181246500;
              }
              memset_pattern16(&v287, v210, 0x10uLL);
            }
            v286[1] = (void *)0x600000002;
            v211 = v300;
            if (v300 >= 2)
            {
              *(_OWORD *)__dst = v287;
            }
            else
            {
              if (HIDWORD(v300) > 1)
              {
                if ((_DWORD)v300)
                  memmove(__dst, &v287, 8 * v300);
                else
                  v211 = 0;
              }
              else
              {
                LODWORD(v300) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v301, 2uLL, 8);
                v211 = 0;
              }
              if (v211 != LODWORD(v286[1]))
                memcpy((char *)__dst + 8 * v211, (char *)v286[0] + 8 * v211, 8 * LODWORD(v286[1]) - 8 * v211);
            }
            LODWORD(v300) = 2;
            LODWORD(v286[1]) = 0;
            if (v286[0] != &v287)
              free(v286[0]);
            v286[0] = (void *)2;
            v213 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
            v214 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 1, v213, 0);
            v215 = v214;
            if (!v214)
              goto LABEL_254;
            v216 = *v214;
            v217 = mlir::TypeID::get<mlir::ShapedType>();
            v218 = *(unsigned int *)(v216 + 16);
            if (!(_DWORD)v218)
              goto LABEL_254;
            v219 = *(_QWORD **)(v216 + 8);
            v220 = &v219[2 * v218];
            do
            {
              v221 = v218 >> 1;
              v222 = &v219[2 * (v218 >> 1)];
              v224 = *v222;
              v223 = v222 + 2;
              v218 += ~(v218 >> 1);
              if (v224 < v217)
                v219 = v223;
              else
                v218 = v221;
            }
            while (v218);
            if (v219 != v220 && *v219 == v217)
              v225 = v219[1];
            else
LABEL_254:
              v225 = 0;
            v271 = mlir::DenseElementsAttr::getFromRawBuffer(v215, v225, __dst, 8 * v300, 8, 1, 0);
            v226 = v308;
            v267 = v308 + 1;
            v227 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v285, -1.0);
            v228 = llvm::APFloatBase::IEEEsingle(v227);
            llvm::APFloat::Storage::Storage(&v286[1], v285, v228);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v285);
            llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v277, -1.0);
            llvm::APFloat::Storage::Storage(&v285[1], v277, v228);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v277);
            v277[0] = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v264, v262, &v275, v226, v267, (uint64_t)v286, (uint64_t)v285, &v272, &v271);
            v229 = (void *)v285[1];
            v230 = llvm::APFloatBase::PPCDoubleDouble(v277[0]);
            if (v230 == v229)
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v285[1]);
            else
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v285[1]);
            v231 = v263;
            if (v230 == v286[1])
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v286[1]);
            else
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v286[1]);
            v232 = mlir::anec::Resize::verifyAttributesWithFamily((uint64_t *)v277, 1);
            v93 = v277[0];
            if (!v232)
            {
              mlir::ConversionPatternRewriter::eraseOp((mlir::ConversionPatternRewriter *)a4, v277[0]);
              v286[0] = "requested attributes are not compatible with hardware requirements";
              LOWORD(v288) = 259;
              v246 = v276;
              v285[0] = (uint64_t)v286;
              v247 = a4[2];
              if (v247 && mlir::RewriterBase::Listener::classof(a4[2]))
                (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v247 + 64))(v247, *((_QWORD *)v246 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v285);
              v93 = 0;
              v94 = 0;
              v95 = v269;
              goto LABEL_213;
            }
            if (v265 != 1)
            {
LABEL_282:
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v274);
              if (v248 > 3)
              {
                v94 = 1;
                v95 = v269;
              }
              else
              {
                v286[0] = &v287;
                *(_QWORD *)&v287 = v37;
                *((_QWORD *)&v287 + 1) = IndexFromDim;
                v288 = v231;
                v289 = v37;
                v290 = IndexFromDim;
                v291 = v231;
                v286[1] = (void *)0x600000006;
                *(_OWORD *)v285 = xmmword_1812464A0;
                v249 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
                v250 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v285, 2, v249, 0);
                v251 = v250;
                if (v250
                  && (v252 = *v250,
                      v253 = mlir::TypeID::get<mlir::ShapedType>(),
                      v254 = *(unsigned int *)(v252 + 16),
                      (_DWORD)v254))
                {
                  v255 = *(_QWORD **)(v252 + 8);
                  v256 = &v255[2 * v254];
                  do
                  {
                    v257 = v254 >> 1;
                    v258 = &v255[2 * (v254 >> 1)];
                    v260 = *v258;
                    v259 = v258 + 2;
                    v254 += ~(v254 >> 1);
                    if (v260 < v253)
                      v255 = v259;
                    else
                      v254 = v257;
                  }
                  while (v254);
                  v95 = v269;
                  if (v255 != v256 && *v255 == v253)
                    v261 = v255[1];
                  else
                    v261 = 0;
                }
                else
                {
                  v261 = 0;
                  v95 = v269;
                }
                v270 = mlir::DenseElementsAttr::getFromRawBuffer(v251, v261, v286[0], 8 * LODWORD(v286[1]), 8, 1, 0);
                v285[0] = (uint64_t)v93 - 16;
                v93 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v264, v262, v285, &v270);
                if (v286[0] != &v287)
                  free(v286[0]);
                v94 = 1;
              }
              goto LABEL_213;
            }
            v286[0] = &v287;
            *(_QWORD *)&v287 = v37;
            *((_QWORD *)&v287 + 1) = v268;
            v288 = v263;
            v289 = v37;
            v290 = v268;
            v291 = v263;
            v286[1] = (void *)0x600000006;
            *(_OWORD *)v285 = xmmword_1812464A0;
            v233 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
            v234 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v285, 2, v233, 0);
            v235 = v234;
            if (!v234)
              goto LABEL_272;
            v236 = *v234;
            v237 = mlir::TypeID::get<mlir::ShapedType>();
            v238 = *(unsigned int *)(v236 + 16);
            if ((_DWORD)v238)
            {
              v239 = *(_QWORD **)(v236 + 8);
              v240 = &v239[2 * v238];
              do
              {
                v241 = v238 >> 1;
                v242 = &v239[2 * (v238 >> 1)];
                v244 = *v242;
                v243 = v242 + 2;
                v238 += ~(v238 >> 1);
                if (v244 < v237)
                  v239 = v243;
                else
                  v238 = v241;
              }
              while (v238);
              v231 = v263;
              if (v239 == v240 || *v239 != v237)
              {
LABEL_272:
                v245 = 0;
                goto LABEL_280;
              }
              v245 = v239[1];
            }
            else
            {
              v245 = 0;
              v231 = v263;
            }
LABEL_280:
            v270 = mlir::DenseElementsAttr::getFromRawBuffer(v235, v245, v286[0], 8 * LODWORD(v286[1]), 8, 1, 0);
            v93 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v264, v262, v277, &v270);
            if (v286[0] != &v287)
              free(v286[0]);
            goto LABEL_282;
          }
LABEL_191:
          v192 = 0;
          goto LABEL_194;
        }
LABEL_95:
        v115 = 0;
        goto LABEL_114;
      }
    }
    else
    {
      v95 = v269;
    }
    v292[0] = "Shape operand was not a constant";
    LOWORD(v294) = 259;
    v116 = v276;
    v286[0] = v292;
    v117 = a4[2];
    if (v117 && mlir::RewriterBase::Listener::classof(a4[2]))
      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v117 + 64))(v117, *((_QWORD *)v116 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    v93 = 0;
    v94 = 0;
  }
  else
  {
    v292[0] = "Resize layout not supported";
    LOWORD(v294) = 259;
    v91 = v276;
    v286[0] = v292;
    v92 = a4[2];
    if (v92 && mlir::RewriterBase::Listener::classof(a4[2]))
      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v92 + 64))(v92, *((_QWORD *)v91 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    v93 = 0;
    v94 = 0;
    v95 = v269;
  }
LABEL_101:
  if (v308 != v310)
    free(v308);
  if (v311 != (mlir::Operation *)v313)
    free(v311);
  if (v94)
  {
    v292[0] = (char *)v93 - 16;
    v118 = 1;
    mlir::ValueRange::ValueRange(v278, (uint64_t)v292, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)v95, v278[0], v278[1]);
  }
  else
  {
    v292[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v294) = 259;
    v286[0] = v292;
    v119 = a4[2];
    if (v119 && mlir::RewriterBase::Listener::classof(v119))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v119 + 64))(v119, *((_QWORD *)v95 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    else
      return 0;
  }
  return v118;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)1>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)1>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

_QWORD *mlir::`anonymous namespace'::ConvertResize<(mlir::anec::Family)2>::~ConvertResize(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertResize<(mlir::anec::Family)2>::~ConvertResize(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, __int128 *a3, uint64_t *a4)
{
  unsigned int *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int ODSOperandIndexAndLength;
  void *v22;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  unint64_t v29;
  unint64_t *v30;
  _QWORD *v31;
  unint64_t v32;
  void *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t IndexFromDim;
  unint64_t v37;
  uint64_t v38;
  uint64_t IntegerType;
  _QWORD *v40;
  _QWORD *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  _QWORD *v45;
  _QWORD *v46;
  unint64_t v47;
  unint64_t *v48;
  _QWORD *v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  _QWORD *v56;
  _QWORD *v57;
  unint64_t v58;
  unint64_t *v59;
  _QWORD *v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  const void *ArgAttrsAttr;
  uint64_t v65;
  size_t v66;
  unsigned int v67;
  mlir::Operation *v68;
  unsigned int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t ResizeLayout;
  uint64_t v73;
  uint64_t v74;
  _QWORD *v75;
  _QWORD *v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  _QWORD *v80;
  _QWORD *v81;
  unint64_t v82;
  unint64_t *v83;
  _QWORD *v84;
  unint64_t v85;
  uint64_t v86;
  const char *v87;
  mlir::Operation *v88;
  uint64_t *v89;
  uint64_t DefiningOp;
  uint64_t v91;
  uint64_t v92;
  uint64_t *v93;
  int GateLayout;
  uint64_t v95;
  _QWORD *v96;
  _QWORD *v97;
  uint64_t v98;
  unsigned int *v99;
  uint64_t v100;
  unint64_t v101;
  unint64_t v102;
  _QWORD *v103;
  _QWORD *v104;
  unint64_t v105;
  unint64_t *v106;
  _QWORD *v107;
  unint64_t v108;
  uint64_t v109;
  mlir::mps *v110;
  uint64_t v111;
  mlir::GenericProgramPoint *v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  void **v117;
  void *v118;
  uint64_t *v119;
  _BOOL4 InferredResultTypes;
  _BOOL4 IsSize;
  mlir::Operation *v122;
  uint64_t v123;
  uint64_t v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  void *v128;
  void *v129;
  unint64_t v130;
  void *v131;
  void *v132;
  float v133;
  float v134;
  unint64_t v135;
  void *v136;
  void *v137;
  unint64_t v138;
  void *v139;
  void *v140;
  float v141;
  float v142;
  unsigned int v143;
  void *v144;
  uint64_t *v145;
  uint64_t v146;
  unint64_t v147;
  unint64_t v148;
  _QWORD *v149;
  _QWORD *v150;
  unint64_t v151;
  unint64_t *v152;
  _QWORD *v153;
  unint64_t v154;
  void *v155;
  uint64_t v156;
  unint64_t v157;
  unint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t *v161;
  uint64_t *v162;
  uint64_t v163;
  uint64_t v164;
  unint64_t v165;
  unint64_t v166;
  _QWORD *v167;
  _QWORD *v168;
  unint64_t v169;
  unint64_t *v170;
  _QWORD *v171;
  unint64_t v172;
  void *v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t *v178;
  uint64_t v179;
  uint64_t v180;
  unint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t *v186;
  uint64_t v187;
  uint64_t v188;
  unint64_t v189;
  uint64_t v190;
  unint64_t v191;
  unint64_t v192;
  unint64_t v193;
  unint64_t v194;
  float v195;
  float v196;
  float v197;
  float v198;
  _BOOL4 v199;
  _BOOL4 v200;
  _BOOL4 v201;
  _BOOL4 v202;
  uint64_t v203;
  mlir::mps *v204;
  uint64_t v205;
  uint64_t (*v206)(int, uint64_t);
  mlir::mps *v207;
  const void *v208;
  uint64_t v209;
  mlir::mps *v210;
  uint64_t v211;
  _QWORD *v212;
  _QWORD *v213;
  uint64_t v214;
  unint64_t v215;
  unint64_t v216;
  _QWORD *v217;
  _QWORD *v218;
  unint64_t v219;
  unint64_t *v220;
  _QWORD *v221;
  unint64_t v222;
  uint64_t v223;
  uint64_t *v224;
  llvm::APFloatBase *v225;
  void *v226;
  void *v227;
  void *v228;
  char v229;
  unsigned int *v230;
  uint64_t v231;
  _QWORD *v232;
  _QWORD *v233;
  uint64_t v234;
  unint64_t v235;
  unint64_t v236;
  _QWORD *v237;
  _QWORD *v238;
  unint64_t v239;
  unint64_t *v240;
  _QWORD *v241;
  unint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  _QWORD *v246;
  _QWORD *v247;
  uint64_t v248;
  unint64_t v249;
  unint64_t v250;
  _QWORD *v251;
  _QWORD *v252;
  unint64_t v253;
  unint64_t *v254;
  _QWORD *v255;
  unint64_t v256;
  uint64_t v257;
  mlir::mps *v258;
  uint64_t v259;
  uint64_t *v260;
  mlir::Builder *v261;
  uint64_t v262;
  unint64_t v263;
  __int128 v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  _QWORD v269[2];
  _QWORD v270[2];
  uint64_t v271;
  mlir::mps *v272;
  mlir::Operation *v273[3];
  unint64_t v274[2];
  __int128 v275;
  __int128 v276;
  __int128 v277;
  __int128 v278;
  __int128 v279;
  _BYTE v280[24];
  uint64_t v281[4];
  void *v282[2];
  __int128 v283;
  unint64_t v284;
  __int128 v285;
  unint64_t v286;
  void *v287[2];
  __int128 v288;
  __int128 v289;
  __int128 v290;
  __int128 v291;
  __int128 v292;
  unsigned int v293[2];
  void *__dst;
  uint64_t v295;
  _BYTE v296[16];
  void *v297;
  uint64_t v298;
  _BYTE v299[16];
  _QWORD *v300;
  uint64_t v301;
  _QWORD v302[2];
  uint64_t *v303;
  uint64_t v304;
  _QWORD v305[2];
  mlir::Operation *v306;
  uint64_t v307;
  _BYTE v308[32];
  __int128 v309;
  uint64_t v310;

  v5 = (unsigned int *)a2;
  v310 = *MEMORY[0x1E0C80C00];
  v6 = a3[5];
  v279 = a3[4];
  *(_OWORD *)v280 = v6;
  *(_QWORD *)&v280[16] = *((_QWORD *)a3 + 12);
  v7 = a3[1];
  v275 = *a3;
  v276 = v7;
  v8 = a3[3];
  v277 = a3[2];
  v278 = v8;
  v272 = a2;
  v309 = *(_OWORD *)&v280[8];
  v9 = *((_QWORD *)a2 + 3);
  v271 = mlir::ValueRange::dereference_iterator(&v309, 0);
  v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v272) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_10;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_10;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_10:
    v20 = 0;
  v270[0] = v10;
  v270[1] = v20;
  ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v275, 0);
  v22 = *(void **)&v280[8];
  v287[0] = *(void **)&v280[8];
  v287[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v22 = (void *)mlir::ValueRange::offset_base(v287, ODSOperandIndexAndLength);
  v287[0] = v22;
  v287[1] = 0;
  v23 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v287, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v23)
    goto LABEL_22;
  v24 = *v23;
  v25 = mlir::TypeID::get<mlir::ShapedType>();
  v26 = *(unsigned int *)(v24 + 16);
  if (!(_DWORD)v26)
    goto LABEL_22;
  v27 = *(_QWORD **)(v24 + 8);
  v28 = &v27[2 * v26];
  do
  {
    v29 = v26 >> 1;
    v30 = &v27[2 * (v26 >> 1)];
    v32 = *v30;
    v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25)
      v27 = v31;
    else
      v26 = v29;
  }
  while (v26);
  if (v27 != v28 && *v27 == v25)
    v33 = (void *)v27[1];
  else
LABEL_22:
    v33 = 0;
  v287[0] = v23;
  v287[1] = v33;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v287);
  v35 = v34;
  IndexFromDim = mlir::anec::getIndexFromDim(0, v34);
  *(_QWORD *)&v265 = mlir::anec::getIndexFromDim(1, v35);
  v37 = mlir::anec::getIndexFromDim(3, v35);
  *((_QWORD *)&v265 + 1) = mlir::anec::getIndexFromDim(4, v35);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v270);
  if (v38 <= 3)
  {
    v287[0] = &v288;
    *(_QWORD *)&v288 = IndexFromDim;
    *((_QWORD *)&v288 + 1) = v265;
    *(_QWORD *)&v289 = v265;
    *((_QWORD *)&v289 + 1) = v37;
    *(_QWORD *)&v290 = v37;
    *((_QWORD *)&v290 + 1) = IndexFromDim;
    v287[1] = (void *)0x600000006;
    *(_OWORD *)v282 = xmmword_1812464A0;
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    v40 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v282, 2, IntegerType, 0);
    v41 = v40;
    if (!v40)
      goto LABEL_33;
    v42 = *v40;
    v43 = mlir::TypeID::get<mlir::ShapedType>();
    v44 = *(unsigned int *)(v42 + 16);
    if (!(_DWORD)v44)
      goto LABEL_33;
    v45 = *(_QWORD **)(v42 + 8);
    v46 = &v45[2 * v44];
    do
    {
      v47 = v44 >> 1;
      v48 = &v45[2 * (v44 >> 1)];
      v50 = *v48;
      v49 = v48 + 2;
      v44 += ~(v44 >> 1);
      if (v50 < v43)
        v45 = v49;
      else
        v44 = v47;
    }
    while (v44);
    if (v45 != v46 && *v45 == v43)
      v51 = v45[1];
    else
LABEL_33:
      v51 = 0;
    v306 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v41, v51, v287[0], 8 * LODWORD(v287[1]), 8, 1, 0);
    v271 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v9, &v271, (uint64_t *)&v306)- 16;
    if (v287[0] != &v288)
      free(v287[0]);
  }
  v52 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v272) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v52)
    goto LABEL_45;
  v53 = *v52;
  v54 = mlir::TypeID::get<mlir::ShapedType>();
  v55 = *(unsigned int *)(v53 + 16);
  if (!(_DWORD)v55)
    goto LABEL_45;
  v56 = *(_QWORD **)(v53 + 8);
  v57 = &v56[2 * v55];
  do
  {
    v58 = v55 >> 1;
    v59 = &v56[2 * (v55 >> 1)];
    v61 = *v59;
    v60 = v59 + 2;
    v55 += ~(v55 >> 1);
    if (v61 < v54)
      v56 = v60;
    else
      v55 = v58;
  }
  while (v55);
  if (v56 != v57 && *v56 == v54)
    v62 = v56[1];
  else
LABEL_45:
    v62 = 0;
  v269[0] = v52;
  v269[1] = v62;
  ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v269);
  v65 = v63;
  v306 = (mlir::Operation *)v308;
  v307 = 0x400000000;
  v66 = 8 * v63;
  if ((unint64_t)(8 * v63) < 0x21)
  {
    v67 = 0;
    v68 = (mlir::Operation *)v308;
    if (!v65)
      goto LABEL_51;
    goto LABEL_50;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v306, v308, (8 * v63) >> 3, 8);
  v67 = v307;
  v68 = v306;
  if (v65)
  {
LABEL_50:
    memcpy((char *)v68 + 8 * v67, ArgAttrsAttr, v66);
    v67 = v307;
    v68 = v306;
  }
LABEL_51:
  v69 = v67 + (v66 >> 3);
  LODWORD(v307) = v69;
  v263 = IndexFromDim;
  if (v69 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v306, (uint64_t)v68, 4 - v69, 1uLL);
    v68 = v306;
  }
  v70 = *((_QWORD *)v68 + v37);
  v71 = *((_QWORD *)v68 + *((_QWORD *)&v265 + 1));
  v303 = v305;
  v305[0] = v70;
  v305[1] = v71;
  v304 = 0x200000002;
  ResizeLayout = mlir::mps::getResizeLayout(v272, v68);
  if ((ResizeLayout & 0xFF00000000) != 0)
  {
    v73 = ResizeLayout;
    if (ResizeLayout == 1)
    {
      v287[0] = &v288;
      *(_QWORD *)&v288 = v265;
      *((_QWORD *)&v288 + 1) = v37;
      *(_QWORD *)&v289 = v37;
      *((_QWORD *)&v289 + 1) = *((_QWORD *)&v265 + 1);
      *(_QWORD *)&v290 = *((_QWORD *)&v265 + 1);
      *((_QWORD *)&v290 + 1) = v265;
      v287[1] = (void *)0x600000006;
      *(_OWORD *)v282 = xmmword_1812464A0;
      v74 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
      v75 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v282, 2, v74, 0);
      v76 = v75;
      if (v75)
      {
        v77 = *v75;
        v78 = mlir::TypeID::get<mlir::ShapedType>();
        v79 = *(unsigned int *)(v77 + 16);
        if ((_DWORD)v79)
        {
          v80 = *(_QWORD **)(v77 + 8);
          v81 = &v80[2 * v79];
          do
          {
            v82 = v79 >> 1;
            v83 = &v80[2 * (v79 >> 1)];
            v85 = *v83;
            v84 = v83 + 2;
            v79 += ~(v79 >> 1);
            if (v85 < v78)
              v80 = v84;
            else
              v79 = v82;
          }
          while (v79);
          v73 = 1;
          if (v80 == v81)
            v86 = 0;
          else
            v86 = *v80 == v78 ? v80[1] : 0;
        }
        else
        {
          v86 = 0;
          v73 = 1;
        }
      }
      else
      {
        v86 = 0;
      }
      v300 = (_QWORD *)mlir::DenseElementsAttr::getFromRawBuffer(v76, v86, v287[0], 8 * LODWORD(v287[1]), 8, 1, 0);
      v271 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v9, &v271, (uint64_t *)&v300)- 16;
      v88 = v306;
      v89 = v303;
      *v303 = *((_QWORD *)v306 + v265);
      v89[1] = *((_QWORD *)v88 + v37);
      if (v287[0] != &v288)
        free(v287[0]);
    }
    v282[0] = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v272);
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v282);
    if (DefiningOp)
    {
      v91 = DefiningOp;
      v92 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v91 + 48) + 32))(*(_QWORD *)(v91 + 48), v92))
      {
        v262 = v73;
        v287[0] = &v288;
        v287[1] = (void *)0x100000000;
        mlir::Operation::fold(v91, 0, 0, (uint64_t)v287);
        v93 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v287[0] & 0xFFFFFFFFFFFFFFF8));
        if (v287[0] != &v288)
          free(v287[0]);
        if (v93)
        {
          v300 = v302;
          v302[0] = 0;
          v302[1] = 0;
          v301 = 0x200000002;
          v297 = v299;
          memset_pattern16(v299, &unk_181233190, 0x10uLL);
          v298 = 0x200000002;
          GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v272);
          v287[0] = (void *)2;
          v261 = (mlir::Builder *)(a4 + 1);
          v95 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
          v96 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v287, 1, v95, 0);
          v97 = v96;
          if (v96)
          {
            v98 = v9;
            v99 = v5;
            v100 = *v96;
            v101 = mlir::TypeID::get<mlir::ShapedType>();
            v102 = *(unsigned int *)(v100 + 16);
            if ((_DWORD)v102)
            {
              v103 = *(_QWORD **)(v100 + 8);
              v104 = &v103[2 * v102];
              do
              {
                v105 = v102 >> 1;
                v106 = &v103[2 * (v102 >> 1)];
                v108 = *v106;
                v107 = v106 + 2;
                v102 += ~(v102 >> 1);
                if (v108 < v101)
                  v103 = v107;
                else
                  v102 = v105;
              }
              while (v102);
              v5 = v99;
              if (v103 == v104)
              {
                v109 = 0;
                v9 = v98;
              }
              else
              {
                v9 = v98;
                if (*v103 == v101)
                  v109 = v103[1];
                else
                  v109 = 0;
              }
            }
            else
            {
              v109 = 0;
              v5 = v99;
              v9 = v98;
            }
          }
          else
          {
            v109 = 0;
          }
          if (GateLayout == 1)
            v117 = (void **)&v300;
          else
            v117 = &v297;
          v118 = *v117;
          v119 = &v301;
          if (GateLayout != 1)
            v119 = &v298;
          v268 = mlir::DenseElementsAttr::getFromRawBuffer(v97, v109, v118, 8 * *(unsigned int *)v119, 8, 1, 0);
          __dst = v296;
          v295 = 0x200000000;
          InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v272);
          IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v272);
          if (!mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v272)
            && !mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v272))
          {
            goto LABEL_210;
          }
          v291 = v279;
          v292 = *(_OWORD *)v280;
          *(_QWORD *)v293 = *(_QWORD *)&v280[16];
          *(_OWORD *)v287 = v275;
          v288 = v276;
          v289 = v277;
          v290 = v278;
          v273[0] = v272;
          v123 = mlir::mps::getResizeLayout(v272, v122);
          if ((v123 & 0xFF00000000) == 0)
            goto LABEL_204;
          v124 = 8 * (int)v123;
          v125 = *(_QWORD *)((char *)&unk_181246668 + v124);
          v126 = *(_QWORD *)((char *)&unk_1812466A0 + v124);
          v127 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v287, 2u);
          v128 = (void *)*((_QWORD *)&v292 + 1);
          v282[0] = *((void **)&v292 + 1);
          v282[1] = (void *)v127;
          if ((_DWORD)v127)
          {
            v128 = (void *)mlir::ValueRange::offset_base(v282, v127);
            v129 = v282[1];
          }
          else
          {
            v129 = 0;
          }
          if ((void *)(HIDWORD(v127) + v127) == v129
            || (v282[0] = v128, v282[1] = 0, !mlir::ValueRange::dereference_iterator(v282, 0)))
          {
            v133 = 1.0;
            v134 = 1.0;
          }
          else
          {
            v130 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v287, 2u);
            v131 = (void *)*((_QWORD *)&v292 + 1);
            v282[0] = *((void **)&v292 + 1);
            v282[1] = (void *)v130;
            if ((_DWORD)v130)
            {
              v131 = (void *)mlir::ValueRange::offset_base(v282, v130);
              v132 = v282[1];
            }
            else
            {
              v132 = 0;
            }
            if ((void *)(HIDWORD(v130) + v130) == v132)
            {
              v174 = 0;
            }
            else
            {
              v282[0] = v131;
              v282[1] = 0;
              v174 = mlir::ValueRange::dereference_iterator(v282, 0);
            }
            v281[0] = v174;
            v175 = mlir::Value::getDefiningOp((mlir::Value *)v281);
            if (!v175)
              goto LABEL_204;
            v176 = v175;
            v177 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v176 + 48) + 32))(*(_QWORD *)(v176 + 48), v177))goto LABEL_204;
            v282[0] = &v283;
            v282[1] = (void *)0x100000000;
            mlir::Operation::fold(v176, 0, 0, (uint64_t)v282);
            v178 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v282[0] & 0xFFFFFFFFFFFFFFF8));
            v180 = v179;
            if (v282[0] != &v283)
              free(v282[0]);
            if (!v178)
              goto LABEL_204;
            v282[0] = &v283;
            v282[1] = (void *)0x400000000;
            mlir::getIntValues<float>((uint64_t)v178, v180, (uint64_t)v282, 1);
            v181 = LODWORD(v282[1]);
            v133 = 1.0;
            v134 = 1.0;
            if (v125 < LODWORD(v282[1]))
            {
              v134 = *((float *)v282[0] + v125);
              v133 = *((float *)v282[0] + v126);
            }
            if (v282[0] != &v283)
              free(v282[0]);
            if (v125 >= v181)
              goto LABEL_204;
          }
          v135 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v287, 3u);
          v136 = (void *)*((_QWORD *)&v292 + 1);
          v282[0] = *((void **)&v292 + 1);
          v282[1] = (void *)v135;
          if ((_DWORD)v135)
          {
            v136 = (void *)mlir::ValueRange::offset_base(v282, v135);
            v137 = v282[1];
          }
          else
          {
            v137 = 0;
          }
          if ((void *)(HIDWORD(v135) + v135) == v137
            || (v282[0] = v136, v282[1] = 0, !mlir::ValueRange::dereference_iterator(v282, 0)))
          {
            v141 = 0.0;
            v142 = 0.0;
          }
          else
          {
            v138 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v287, 3u);
            v139 = (void *)*((_QWORD *)&v292 + 1);
            v282[0] = *((void **)&v292 + 1);
            v282[1] = (void *)v138;
            if ((_DWORD)v138)
            {
              v139 = (void *)mlir::ValueRange::offset_base(v282, v138);
              v140 = v282[1];
            }
            else
            {
              v140 = 0;
            }
            if ((void *)(HIDWORD(v138) + v138) == v140)
            {
              v182 = 0;
            }
            else
            {
              v282[0] = v139;
              v282[1] = 0;
              v182 = mlir::ValueRange::dereference_iterator(v282, 0);
            }
            v281[0] = v182;
            v183 = mlir::Value::getDefiningOp((mlir::Value *)v281);
            if (!v183)
              goto LABEL_204;
            v184 = v183;
            v185 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v184 + 48) + 32))(*(_QWORD *)(v184 + 48), v185))goto LABEL_204;
            v282[0] = &v283;
            v282[1] = (void *)0x100000000;
            mlir::Operation::fold(v184, 0, 0, (uint64_t)v282);
            v186 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v282[0] & 0xFFFFFFFFFFFFFFF8));
            v188 = v187;
            if (v282[0] != &v283)
              free(v282[0]);
            if (!v186)
              goto LABEL_204;
            v282[0] = &v283;
            v282[1] = (void *)0x400000000;
            mlir::getIntValues<float>((uint64_t)v186, v188, (uint64_t)v282, 1);
            v189 = LODWORD(v282[1]);
            v141 = 0.0;
            v142 = 0.0;
            if (v125 < LODWORD(v282[1]))
            {
              v142 = *((float *)v282[0] + v125);
              v141 = *((float *)v282[0] + v126);
            }
            if (v282[0] != &v283)
              free(v282[0]);
            if (v125 >= v189)
              goto LABEL_204;
          }
          v143 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v287, 0);
          v144 = (void *)*((_QWORD *)&v292 + 1);
          v282[0] = *((void **)&v292 + 1);
          v282[1] = (void *)v143;
          if (v143)
            v144 = (void *)mlir::ValueRange::offset_base(v282, v143);
          v282[0] = v144;
          v282[1] = 0;
          v145 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v282, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v145)
            goto LABEL_146;
          v146 = *v145;
          v147 = mlir::TypeID::get<mlir::ShapedType>();
          v148 = *(unsigned int *)(v146 + 16);
          if (!(_DWORD)v148)
            goto LABEL_146;
          v149 = *(_QWORD **)(v146 + 8);
          v150 = &v149[2 * v148];
          do
          {
            v151 = v148 >> 1;
            v152 = &v149[2 * (v148 >> 1)];
            v154 = *v152;
            v153 = v152 + 2;
            v148 += ~(v148 >> 1);
            if (v154 < v147)
              v149 = v153;
            else
              v148 = v151;
          }
          while (v148);
          if (v149 != v150 && *v149 == v147)
            v155 = (void *)v149[1];
          else
LABEL_146:
            v155 = 0;
          v282[0] = v145;
          v282[1] = v155;
          v156 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v282);
          v158 = v157;
          v159 = *(_QWORD *)(a1 + 96);
          v160 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v273);
          v161 = (uint64_t *)mlir::TypeConverter::convertType(v159, (void *)(*(_QWORD *)(v160 + 8) & 0xFFFFFFFFFFFFFFF8));
          v162 = v161;
          if (!v161)
            goto LABEL_156;
          v163 = v156;
          v164 = *v161;
          v165 = mlir::TypeID::get<mlir::ShapedType>();
          v166 = *(unsigned int *)(v164 + 16);
          if ((_DWORD)v166)
          {
            v167 = *(_QWORD **)(v164 + 8);
            v168 = &v167[2 * v166];
            do
            {
              v169 = v166 >> 1;
              v170 = &v167[2 * (v166 >> 1)];
              v172 = *v170;
              v171 = v170 + 2;
              v166 += ~(v166 >> 1);
              if (v172 < v165)
                v167 = v171;
              else
                v166 = v169;
            }
            while (v166);
            v156 = v163;
            if (v167 == v168 || *v167 != v165)
            {
LABEL_156:
              v173 = 0;
              goto LABEL_190;
            }
            v173 = (void *)v167[1];
          }
          else
          {
            v173 = 0;
            v156 = v163;
          }
LABEL_190:
          v282[0] = v162;
          v282[1] = v173;
          v190 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v282);
          v192 = v191;
          v193 = mlir::anec::getIndexFromDim(3, v158);
          v194 = mlir::anec::getIndexFromDim(4, v192);
          v195 = (float)*(uint64_t *)(v156 + 8 * v193);
          v196 = (float)*(uint64_t *)(v156 + 8 * v194);
          v197 = (float)*(uint64_t *)(v190 + 8 * v193);
          v198 = (float)*(uint64_t *)(v190 + 8 * v194);
          v199 = v142 != 0.0;
          if (v141 != 0.0)
            v199 = 1;
          v200 = (v134 + -1.0) * 0.5 != v142 || (v133 + -1.0) * 0.5 != v141;
          v201 = v134 != (float)(v197 / v195) || v133 != (float)(v198 / v196);
          v202 = v134 != (float)((float)(v197 + -1.0) / (float)(v195 + -1.0))
              || v133 != (float)((float)(v198 + -1.0) / (float)(v196 + -1.0));
          if (v199 || v201)
          {
            if (v199 || v202)
            {
              if (v200 || v201)
              {
LABEL_204:
                v203 = a4[2];
                if (!v203)
                  goto LABEL_216;
                v204 = v272;
                if (!mlir::RewriterBase::Listener::classof(a4[2]))
                  goto LABEL_216;
                v205 = *((_QWORD *)v204 + 3);
                goto LABEL_215;
              }
              InferredResultTypes = 0;
              IsSize = 1;
            }
            else
            {
              IsSize = 1;
              InferredResultTypes = 1;
            }
          }
          else
          {
            IsSize = 0;
            InferredResultTypes = 0;
          }
LABEL_210:
          if (InferredResultTypes && IsSize)
          {
            v203 = a4[2];
            if (!v203)
              goto LABEL_216;
            v207 = v272;
            if (!mlir::RewriterBase::Listener::classof(a4[2]))
              goto LABEL_216;
            v205 = *((_QWORD *)v207 + 3);
            goto LABEL_215;
          }
          if (InferredResultTypes || IsSize)
          {
            if (InferredResultTypes || !IsSize)
            {
              v203 = a4[2];
              if (!v203)
                goto LABEL_216;
              v210 = v272;
              if (!mlir::RewriterBase::Listener::classof(a4[2]))
                goto LABEL_216;
              v205 = *((_QWORD *)v210 + 3);
LABEL_215:
              (*(void (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v203 + 64))(v203, v205, v206, v282);
              goto LABEL_216;
            }
            v282[0] = &v283;
            v208 = &unk_181233190;
          }
          else
          {
            v282[0] = &v283;
            v208 = &unk_181246500;
          }
          memset_pattern16(&v283, v208, 0x10uLL);
          v282[1] = (void *)0x600000002;
          v209 = v295;
          if (v295 >= 2)
          {
            *(_OWORD *)__dst = v283;
          }
          else
          {
            if (HIDWORD(v295) > 1)
            {
              if ((_DWORD)v295)
                memmove(__dst, &v283, 8 * v295);
              else
                v209 = 0;
            }
            else
            {
              LODWORD(v295) = 0;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v296, 2uLL, 8);
              v209 = 0;
            }
            if (v209 != LODWORD(v282[1]))
              memcpy((char *)__dst + 8 * v209, (char *)v282[0] + 8 * v209, 8 * LODWORD(v282[1]) - 8 * v209);
          }
          LODWORD(v295) = 2;
          LODWORD(v282[1]) = 0;
          if (v282[0] != &v283)
            free(v282[0]);
          v282[0] = (void *)2;
          v211 = mlir::Builder::getIntegerType(v261, 0x40u, 0);
          v212 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v282, 1, v211, 0);
          v213 = v212;
          if (!v212)
            goto LABEL_251;
          v214 = *v212;
          v215 = mlir::TypeID::get<mlir::ShapedType>();
          v216 = *(unsigned int *)(v214 + 16);
          if (!(_DWORD)v216)
            goto LABEL_251;
          v217 = *(_QWORD **)(v214 + 8);
          v218 = &v217[2 * v216];
          do
          {
            v219 = v216 >> 1;
            v220 = &v217[2 * (v216 >> 1)];
            v222 = *v220;
            v221 = v220 + 2;
            v216 += ~(v216 >> 1);
            if (v222 < v215)
              v217 = v221;
            else
              v216 = v219;
          }
          while (v216);
          if (v217 != v218 && *v217 == v215)
            v223 = v217[1];
          else
LABEL_251:
            v223 = 0;
          v267 = mlir::DenseElementsAttr::getFromRawBuffer(v213, v223, __dst, 8 * v295, 8, 1, 0);
          v224 = v303;
          v260 = v303 + 1;
          v225 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v281, -1.0);
          v226 = llvm::APFloatBase::IEEEsingle(v225);
          llvm::APFloat::Storage::Storage(&v282[1], v281, v226);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v281);
          llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v273, -1.0);
          llvm::APFloat::Storage::Storage(&v281[1], v273, v226);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v273);
          v273[0] = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v261, v9, &v271, v224, v260, (uint64_t)v282, (uint64_t)v281, &v268, &v267);
          v227 = (void *)v281[1];
          v228 = llvm::APFloatBase::PPCDoubleDouble(v273[0]);
          if (v228 == v227)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v281[1]);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v281[1]);
          if (v228 == v282[1])
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v282[1]);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v282[1]);
          v229 = mlir::anec::Resize::verifyAttributesWithFamily((uint64_t *)v273, 2);
          v112 = v273[0];
          if (v229)
          {
            if (v262 == 1)
            {
              v230 = v5;
              v282[0] = &v283;
              v283 = v265;
              v284 = v37;
              v285 = v265;
              v286 = v37;
              v282[1] = (void *)0x600000006;
              *(_OWORD *)v281 = xmmword_1812464A0;
              v231 = mlir::Builder::getIntegerType(v261, 0x40u, 0);
              v232 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v281, 2, v231, 0);
              v233 = v232;
              if (!v232)
                goto LABEL_269;
              v234 = *v232;
              v235 = mlir::TypeID::get<mlir::ShapedType>();
              v236 = *(unsigned int *)(v234 + 16);
              if (!(_DWORD)v236)
                goto LABEL_269;
              v237 = *(_QWORD **)(v234 + 8);
              v238 = &v237[2 * v236];
              do
              {
                v239 = v236 >> 1;
                v240 = &v237[2 * (v236 >> 1)];
                v242 = *v240;
                v241 = v240 + 2;
                v236 += ~(v236 >> 1);
                if (v242 < v235)
                  v237 = v241;
                else
                  v236 = v239;
              }
              while (v236);
              if (v237 != v238 && *v237 == v235)
                v243 = v237[1];
              else
LABEL_269:
                v243 = 0;
              v266 = mlir::DenseElementsAttr::getFromRawBuffer(v233, v243, v282[0], 8 * LODWORD(v282[1]), 8, 1, 0);
              v112 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v261, v9, v273, &v266);
              if (v282[0] != &v283)
                free(v282[0]);
              v5 = v230;
            }
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v270);
            if (v244 > 3)
            {
              v113 = 1;
            }
            else
            {
              v282[0] = &v283;
              *(_QWORD *)&v283 = v265;
              *((_QWORD *)&v283 + 1) = v263;
              v284 = v37;
              *(_QWORD *)&v285 = v265;
              *((_QWORD *)&v285 + 1) = v263;
              v286 = v37;
              v282[1] = (void *)0x600000006;
              *(_OWORD *)v281 = xmmword_1812464A0;
              v245 = mlir::Builder::getIntegerType(v261, 0x40u, 0);
              v246 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v281, 2, v245, 0);
              v247 = v246;
              if (v246
                && (v248 = *v246,
                    v249 = mlir::TypeID::get<mlir::ShapedType>(),
                    v250 = *(unsigned int *)(v248 + 16),
                    (_DWORD)v250))
              {
                v251 = *(_QWORD **)(v248 + 8);
                v252 = &v251[2 * v250];
                do
                {
                  v253 = v250 >> 1;
                  v254 = &v251[2 * (v250 >> 1)];
                  v256 = *v254;
                  v255 = v254 + 2;
                  v250 += ~(v250 >> 1);
                  if (v256 < v249)
                    v251 = v255;
                  else
                    v250 = v253;
                }
                while (v250);
                if (v251 != v252 && *v251 == v249)
                  v257 = v251[1];
                else
                  v257 = 0;
              }
              else
              {
                v257 = 0;
              }
              v266 = mlir::DenseElementsAttr::getFromRawBuffer(v247, v257, v282[0], 8 * LODWORD(v282[1]), 8, 1, 0);
              v281[0] = (uint64_t)v112 - 16;
              v112 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v261, v9, v281, &v266);
              if (v282[0] != &v283)
                free(v282[0]);
              v113 = 1;
            }
            goto LABEL_217;
          }
          mlir::ConversionPatternRewriter::eraseOp((mlir::ConversionPatternRewriter *)a4, v273[0]);
          v282[0] = "requested attributes are not compatible with hardware requirements";
          LOWORD(v284) = 259;
          v258 = v272;
          v281[0] = (uint64_t)v282;
          v259 = a4[2];
          if (v259 && mlir::RewriterBase::Listener::classof(a4[2]))
            (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v259 + 64))(v259, *((_QWORD *)v258 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v281);
LABEL_216:
          v112 = 0;
          v113 = 0;
LABEL_217:
          if (__dst != v296)
            free(__dst);
          if (v297 != v299)
            free(v297);
          if (v300 != v302)
            free(v300);
          goto LABEL_96;
        }
      }
    }
    v87 = "Shape operand was not a constant";
  }
  else
  {
    v87 = "Resize layout not supported";
  }
  v287[0] = (void *)v87;
  LOWORD(v289) = 259;
  v110 = v272;
  v282[0] = v287;
  v111 = a4[2];
  if (v111 && mlir::RewriterBase::Listener::classof(a4[2]))
    (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v111 + 64))(v111, *((_QWORD *)v110 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v282);
  v112 = 0;
  v113 = 0;
LABEL_96:
  if (v303 != v305)
    free(v303);
  if (v306 != (mlir::Operation *)v308)
    free(v306);
  if (v113)
  {
    v287[0] = (char *)v112 - 16;
    v114 = 1;
    mlir::ValueRange::ValueRange(v274, (uint64_t)v287, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, v5, v274[0], v274[1]);
  }
  else
  {
    v287[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v289) = 259;
    v282[0] = v287;
    v115 = a4[2];
    if (v115 && mlir::RewriterBase::Listener::classof(v115))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v115 + 64))(v115, *((_QWORD *)v5 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v282);
    else
      return 0;
  }
  return v114;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)2>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)2>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize alignCorners == centerResult == true is not supported on A14-class ANEs. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)2>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

_QWORD *mlir::`anonymous namespace'::ConvertResize<(mlir::anec::Family)3>::~ConvertResize(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertResize<(mlir::anec::Family)3>::~ConvertResize(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, __int128 *a3, uint64_t *a4)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int ODSOperandIndexAndLength;
  void *v22;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  unint64_t v29;
  unint64_t *v30;
  _QWORD *v31;
  unint64_t v32;
  void *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t IndexFromDim;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t IntegerType;
  _QWORD *v42;
  _QWORD *v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  _QWORD *v49;
  _QWORD *v50;
  unint64_t v51;
  unint64_t *v52;
  _QWORD *v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const void *ArgAttrsAttr;
  uint64_t v69;
  size_t v70;
  unsigned int v71;
  mlir::Operation *v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t ResizeLayout;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  _QWORD *v84;
  _QWORD *v85;
  unint64_t v86;
  unint64_t *v87;
  _QWORD *v88;
  unint64_t v89;
  uint64_t v90;
  mlir::mps *v91;
  uint64_t v92;
  mlir::GenericProgramPoint *v93;
  int v94;
  mlir::mps *v95;
  mlir::Operation *v96;
  uint64_t *v97;
  uint64_t DefiningOp;
  uint64_t v99;
  uint64_t v100;
  uint64_t *v101;
  int GateLayout;
  uint64_t v103;
  _QWORD *v104;
  _QWORD *v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  _QWORD *v109;
  _QWORD *v110;
  unint64_t v111;
  unint64_t *v112;
  _QWORD *v113;
  unint64_t v114;
  uint64_t v115;
  mlir::mps *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  void **v121;
  void *v122;
  uint64_t *v123;
  _BOOL4 InferredResultTypes;
  _BOOL4 IsSize;
  mlir::Operation *v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  void *v132;
  void *v133;
  unint64_t v134;
  void *v135;
  void *v136;
  float v137;
  float v138;
  unint64_t v139;
  void *v140;
  void *v141;
  unint64_t v142;
  void *v143;
  void *v144;
  float v145;
  float v146;
  unsigned int v147;
  void *v148;
  uint64_t *v149;
  uint64_t v150;
  unint64_t v151;
  unint64_t v152;
  _QWORD *v153;
  _QWORD *v154;
  unint64_t v155;
  unint64_t *v156;
  _QWORD *v157;
  unint64_t v158;
  void *v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t *v164;
  uint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t *v172;
  uint64_t v173;
  uint64_t v174;
  unint64_t v175;
  uint64_t v176;
  unint64_t v177;
  unint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t *v181;
  uint64_t *v182;
  uint64_t v183;
  unint64_t v184;
  unint64_t v185;
  _QWORD *v186;
  _QWORD *v187;
  unint64_t v188;
  unint64_t *v189;
  _QWORD *v190;
  unint64_t v191;
  void *v192;
  uint64_t v193;
  unint64_t v194;
  unint64_t v195;
  unint64_t v196;
  unint64_t v197;
  float v198;
  float v199;
  float v200;
  float v201;
  _BOOL4 v202;
  _BOOL4 v203;
  _BOOL4 v204;
  _BOOL4 v205;
  uint64_t v206;
  mlir::mps *v207;
  uint64_t v208;
  uint64_t (*v209)(int, uint64_t);
  const void *v210;
  uint64_t v211;
  mlir::mps *v212;
  uint64_t v213;
  _QWORD *v214;
  _QWORD *v215;
  uint64_t v216;
  unint64_t v217;
  unint64_t v218;
  _QWORD *v219;
  _QWORD *v220;
  unint64_t v221;
  unint64_t *v222;
  _QWORD *v223;
  unint64_t v224;
  uint64_t v225;
  uint64_t *v226;
  llvm::APFloatBase *v227;
  void *v228;
  void *v229;
  void *v230;
  unint64_t v231;
  char v232;
  uint64_t v233;
  _QWORD *v234;
  _QWORD *v235;
  uint64_t v236;
  unint64_t v237;
  unint64_t v238;
  _QWORD *v239;
  _QWORD *v240;
  unint64_t v241;
  unint64_t *v242;
  _QWORD *v243;
  unint64_t v244;
  uint64_t v245;
  mlir::mps *v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  _QWORD *v250;
  _QWORD *v251;
  uint64_t v252;
  unint64_t v253;
  unint64_t v254;
  _QWORD *v255;
  _QWORD *v256;
  unint64_t v257;
  unint64_t *v258;
  _QWORD *v259;
  unint64_t v260;
  uint64_t v261;
  uint64_t v262;
  unint64_t v263;
  mlir::Builder *v264;
  uint64_t v265;
  uint64_t *v267;
  unint64_t v268;
  mlir::mps *v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  _QWORD v273[2];
  _QWORD v274[2];
  uint64_t v275;
  mlir::mps *v276;
  mlir::Operation *v277[3];
  unint64_t v278[2];
  __int128 v279;
  __int128 v280;
  __int128 v281;
  __int128 v282;
  __int128 v283;
  _BYTE v284[24];
  uint64_t v285[4];
  void *v286[2];
  __int128 v287;
  unint64_t v288;
  unint64_t v289;
  unint64_t v290;
  unint64_t v291;
  void *v292[2];
  __int128 v293;
  __int128 v294;
  __int128 v295;
  __int128 v296;
  __int128 v297;
  unsigned int v298[2];
  void *__dst;
  uint64_t v300;
  _BYTE v301[16];
  void *v302;
  uint64_t v303;
  _BYTE v304[16];
  _QWORD *v305;
  uint64_t v306;
  _QWORD v307[2];
  uint64_t *v308;
  uint64_t v309;
  _QWORD v310[2];
  mlir::Operation *v311;
  uint64_t v312;
  _BYTE v313[32];
  __int128 v314;
  uint64_t v315;

  v315 = *MEMORY[0x1E0C80C00];
  v6 = a3[5];
  v283 = a3[4];
  *(_OWORD *)v284 = v6;
  *(_QWORD *)&v284[16] = *((_QWORD *)a3 + 12);
  v7 = a3[1];
  v279 = *a3;
  v280 = v7;
  v8 = a3[3];
  v281 = a3[2];
  v282 = v8;
  v276 = a2;
  v314 = *(_OWORD *)&v284[8];
  v9 = *((_QWORD *)a2 + 3);
  v275 = mlir::ValueRange::dereference_iterator(&v314, 0);
  v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v276) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_10;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_10;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_10:
    v20 = 0;
  v274[0] = v10;
  v274[1] = v20;
  ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v279, 0);
  v22 = *(void **)&v284[8];
  v292[0] = *(void **)&v284[8];
  v292[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v22 = (void *)mlir::ValueRange::offset_base(v292, ODSOperandIndexAndLength);
  v292[0] = v22;
  v292[1] = 0;
  v23 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v292, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v269 = a2;
  if (!v23)
    goto LABEL_22;
  v24 = *v23;
  v25 = mlir::TypeID::get<mlir::ShapedType>();
  v26 = *(unsigned int *)(v24 + 16);
  if (!(_DWORD)v26)
    goto LABEL_22;
  v27 = *(_QWORD **)(v24 + 8);
  v28 = &v27[2 * v26];
  do
  {
    v29 = v26 >> 1;
    v30 = &v27[2 * (v26 >> 1)];
    v32 = *v30;
    v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25)
      v27 = v31;
    else
      v26 = v29;
  }
  while (v26);
  if (v27 != v28 && *v27 == v25)
    v33 = (void *)v27[1];
  else
LABEL_22:
    v33 = 0;
  v292[0] = v23;
  v292[1] = v33;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v292);
  v35 = v34;
  IndexFromDim = mlir::anec::getIndexFromDim(0, v34);
  v37 = mlir::anec::getIndexFromDim(1, v35);
  v38 = mlir::anec::getIndexFromDim(3, v35);
  v39 = mlir::anec::getIndexFromDim(4, v35);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v274);
  if (v40 <= 3)
  {
    v292[0] = &v293;
    *(_QWORD *)&v293 = IndexFromDim;
    *((_QWORD *)&v293 + 1) = v37;
    *(_QWORD *)&v294 = v37;
    *((_QWORD *)&v294 + 1) = v38;
    *(_QWORD *)&v295 = v38;
    *((_QWORD *)&v295 + 1) = IndexFromDim;
    v292[1] = (void *)0x600000006;
    *(_OWORD *)v286 = xmmword_1812464A0;
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    v42 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 2, IntegerType, 0);
    v43 = v42;
    if (v42)
    {
      v44 = v39;
      v45 = v9;
      v46 = *v42;
      v47 = mlir::TypeID::get<mlir::ShapedType>();
      v48 = *(unsigned int *)(v46 + 16);
      if ((_DWORD)v48)
      {
        v49 = *(_QWORD **)(v46 + 8);
        v50 = &v49[2 * v48];
        do
        {
          v51 = v48 >> 1;
          v52 = &v49[2 * (v48 >> 1)];
          v54 = *v52;
          v53 = v52 + 2;
          v48 += ~(v48 >> 1);
          if (v54 < v47)
            v49 = v53;
          else
            v48 = v51;
        }
        while (v48);
        v9 = v45;
        if (v49 == v50)
        {
          v55 = 0;
          v39 = v44;
        }
        else
        {
          v39 = v44;
          if (*v49 != v47)
            goto LABEL_33;
          v55 = v49[1];
        }
      }
      else
      {
        v55 = 0;
        v9 = v45;
        v39 = v44;
      }
LABEL_39:
      v311 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v43, v55, v292[0], 8 * LODWORD(v292[1]), 8, 1, 0);
      v275 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v9, &v275, (uint64_t *)&v311)- 16;
      if (v292[0] != &v293)
        free(v292[0]);
      goto LABEL_41;
    }
LABEL_33:
    v55 = 0;
    goto LABEL_39;
  }
LABEL_41:
  v56 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v276) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v56)
    goto LABEL_50;
  v57 = *v56;
  v58 = mlir::TypeID::get<mlir::ShapedType>();
  v59 = *(unsigned int *)(v57 + 16);
  if (!(_DWORD)v59)
    goto LABEL_50;
  v60 = *(_QWORD **)(v57 + 8);
  v61 = &v60[2 * v59];
  do
  {
    v62 = v59 >> 1;
    v63 = &v60[2 * (v59 >> 1)];
    v65 = *v63;
    v64 = v63 + 2;
    v59 += ~(v59 >> 1);
    if (v65 < v58)
      v60 = v64;
    else
      v59 = v62;
  }
  while (v59);
  if (v60 != v61 && *v60 == v58)
    v66 = v60[1];
  else
LABEL_50:
    v66 = 0;
  v273[0] = v56;
  v273[1] = v66;
  ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v273);
  v69 = v67;
  v311 = (mlir::Operation *)v313;
  v312 = 0x400000000;
  v70 = 8 * v67;
  if ((unint64_t)(8 * v67) < 0x21)
  {
    v71 = 0;
    v72 = (mlir::Operation *)v313;
    if (!v69)
      goto LABEL_56;
    goto LABEL_55;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v311, v313, (8 * v67) >> 3, 8);
  v71 = v312;
  v72 = v311;
  if (v69)
  {
LABEL_55:
    memcpy((char *)v72 + 8 * v71, ArgAttrsAttr, v70);
    v71 = v312;
    v72 = v311;
  }
LABEL_56:
  v73 = v71 + (v70 >> 3);
  LODWORD(v312) = v73;
  if (v73 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v311, (uint64_t)v72, 4 - v73, 1uLL);
    v72 = v311;
  }
  v74 = *((_QWORD *)v72 + v38);
  v268 = v39;
  v75 = *((_QWORD *)v72 + v39);
  v308 = v310;
  v310[0] = v74;
  v310[1] = v75;
  v309 = 0x200000002;
  ResizeLayout = mlir::mps::getResizeLayout(v276, v72);
  if ((ResizeLayout & 0xFF00000000) != 0)
  {
    v265 = ResizeLayout;
    if (ResizeLayout == 1)
    {
      v292[0] = &v293;
      *(_QWORD *)&v293 = v37;
      *((_QWORD *)&v293 + 1) = v38;
      *(_QWORD *)&v294 = v38;
      *((_QWORD *)&v294 + 1) = v39;
      *(_QWORD *)&v295 = v39;
      *((_QWORD *)&v295 + 1) = v37;
      v292[1] = (void *)0x600000006;
      *(_OWORD *)v286 = xmmword_1812464A0;
      v77 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
      v78 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 2, v77, 0);
      v79 = v78;
      if (v78)
      {
        v80 = v9;
        v81 = *v78;
        v82 = mlir::TypeID::get<mlir::ShapedType>();
        v83 = *(unsigned int *)(v81 + 16);
        if ((_DWORD)v83)
        {
          v84 = *(_QWORD **)(v81 + 8);
          v85 = &v84[2 * v83];
          do
          {
            v86 = v83 >> 1;
            v87 = &v84[2 * (v83 >> 1)];
            v89 = *v87;
            v88 = v87 + 2;
            v83 += ~(v83 >> 1);
            if (v89 < v82)
              v84 = v88;
            else
              v83 = v86;
          }
          while (v83);
          v9 = v80;
          if (v84 == v85)
            v90 = 0;
          else
            v90 = *v84 == v82 ? v84[1] : 0;
        }
        else
        {
          v90 = 0;
          v9 = v80;
        }
      }
      else
      {
        v90 = 0;
      }
      v305 = (_QWORD *)mlir::DenseElementsAttr::getFromRawBuffer(v79, v90, v292[0], 8 * LODWORD(v292[1]), 8, 1, 0);
      v275 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v9, &v275, (uint64_t *)&v305)- 16;
      v96 = v311;
      v97 = v308;
      *v308 = *((_QWORD *)v311 + v37);
      v97[1] = *((_QWORD *)v96 + v38);
      if (v292[0] != &v293)
        free(v292[0]);
    }
    v286[0] = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v276);
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v286);
    if (DefiningOp
      && (v99 = DefiningOp,
          v100 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          (*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v99 + 48) + 32))(*(_QWORD *)(v99 + 48), v100)))
    {
      v263 = v38;
      v292[0] = &v293;
      v292[1] = (void *)0x100000000;
      mlir::Operation::fold(v99, 0, 0, (uint64_t)v292);
      v101 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v292[0] & 0xFFFFFFFFFFFFFFF8));
      if (v292[0] != &v293)
        free(v292[0]);
      v95 = v269;
      if (v101)
      {
        v262 = v9;
        v305 = v307;
        v307[0] = 0;
        v307[1] = 0;
        v306 = 0x200000002;
        v302 = v304;
        memset_pattern16(v304, &unk_181233190, 0x10uLL);
        v303 = 0x200000002;
        GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v276);
        v292[0] = (void *)2;
        v264 = (mlir::Builder *)(a4 + 1);
        v103 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
        v104 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v292, 1, v103, 0);
        v105 = v104;
        if (v104)
        {
          v106 = *v104;
          v107 = mlir::TypeID::get<mlir::ShapedType>();
          v108 = *(unsigned int *)(v106 + 16);
          if ((_DWORD)v108)
          {
            v109 = *(_QWORD **)(v106 + 8);
            v110 = &v109[2 * v108];
            do
            {
              v111 = v108 >> 1;
              v112 = &v109[2 * (v108 >> 1)];
              v114 = *v112;
              v113 = v112 + 2;
              v108 += ~(v108 >> 1);
              if (v114 < v107)
                v109 = v113;
              else
                v108 = v111;
            }
            while (v108);
            v95 = v269;
            if (v109 == v110 || *v109 != v107)
              goto LABEL_95;
            v115 = v109[1];
          }
          else
          {
            v115 = 0;
            v95 = v269;
          }
LABEL_114:
          if (GateLayout == 1)
            v121 = (void **)&v305;
          else
            v121 = &v302;
          v122 = *v121;
          v123 = &v306;
          if (GateLayout != 1)
            v123 = &v303;
          v272 = mlir::DenseElementsAttr::getFromRawBuffer(v105, v115, v122, 8 * *(unsigned int *)v123, 8, 1, 0);
          __dst = v301;
          v300 = 0x200000000;
          InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v276);
          IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v276);
          if (!mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v276)
            && !mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v276))
          {
            goto LABEL_222;
          }
          v296 = v283;
          v297 = *(_OWORD *)v284;
          *(_QWORD *)v298 = *(_QWORD *)&v284[16];
          *(_OWORD *)v292 = v279;
          v293 = v280;
          v294 = v281;
          v295 = v282;
          v277[0] = v276;
          v127 = mlir::mps::getResizeLayout(v276, v126);
          if ((v127 & 0xFF00000000) == 0)
            goto LABEL_208;
          v128 = 8 * (int)v127;
          v129 = *(_QWORD *)((char *)&unk_181246668 + v128);
          v130 = *(_QWORD *)((char *)&unk_1812466A0 + v128);
          v131 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 2u);
          v132 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v131;
          if ((_DWORD)v131)
          {
            v132 = (void *)mlir::ValueRange::offset_base(v286, v131);
            v133 = v286[1];
          }
          else
          {
            v133 = 0;
          }
          if ((void *)(HIDWORD(v131) + v131) == v133
            || (v286[0] = v132, v286[1] = 0, !mlir::ValueRange::dereference_iterator(v286, 0)))
          {
            v137 = 1.0;
            v138 = 1.0;
          }
          else
          {
            v134 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 2u);
            v135 = (void *)*((_QWORD *)&v297 + 1);
            v286[0] = *((void **)&v297 + 1);
            v286[1] = (void *)v134;
            if ((_DWORD)v134)
            {
              v135 = (void *)mlir::ValueRange::offset_base(v286, v134);
              v136 = v286[1];
            }
            else
            {
              v136 = 0;
            }
            if ((void *)(HIDWORD(v134) + v134) == v136)
            {
              v160 = 0;
            }
            else
            {
              v286[0] = v135;
              v286[1] = 0;
              v160 = mlir::ValueRange::dereference_iterator(v286, 0);
            }
            v285[0] = v160;
            v161 = mlir::Value::getDefiningOp((mlir::Value *)v285);
            if (!v161)
              goto LABEL_208;
            v162 = v161;
            v163 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v162 + 48) + 32))(*(_QWORD *)(v162 + 48), v163))goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x100000000;
            mlir::Operation::fold(v162, 0, 0, (uint64_t)v286);
            v164 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v286[0] & 0xFFFFFFFFFFFFFFF8));
            v166 = v165;
            if (v286[0] != &v287)
              free(v286[0]);
            v95 = v269;
            if (!v164)
              goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x400000000;
            mlir::getIntValues<float>((uint64_t)v164, v166, (uint64_t)v286, 1);
            v167 = LODWORD(v286[1]);
            v137 = 1.0;
            v138 = 1.0;
            if (v129 < LODWORD(v286[1]))
            {
              v138 = *((float *)v286[0] + v129);
              v137 = *((float *)v286[0] + v130);
            }
            if (v286[0] != &v287)
              free(v286[0]);
            if (v129 >= v167)
              goto LABEL_208;
          }
          v139 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 3u);
          v140 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v139;
          if ((_DWORD)v139)
          {
            v140 = (void *)mlir::ValueRange::offset_base(v286, v139);
            v141 = v286[1];
          }
          else
          {
            v141 = 0;
          }
          if ((void *)(HIDWORD(v139) + v139) == v141
            || (v286[0] = v140, v286[1] = 0, !mlir::ValueRange::dereference_iterator(v286, 0)))
          {
            v145 = 0.0;
            v146 = 0.0;
          }
          else
          {
            v142 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 3u);
            v143 = (void *)*((_QWORD *)&v297 + 1);
            v286[0] = *((void **)&v297 + 1);
            v286[1] = (void *)v142;
            if ((_DWORD)v142)
            {
              v143 = (void *)mlir::ValueRange::offset_base(v286, v142);
              v144 = v286[1];
            }
            else
            {
              v144 = 0;
            }
            if ((void *)(HIDWORD(v142) + v142) == v144)
            {
              v168 = 0;
            }
            else
            {
              v286[0] = v143;
              v286[1] = 0;
              v168 = mlir::ValueRange::dereference_iterator(v286, 0);
            }
            v285[0] = v168;
            v169 = mlir::Value::getDefiningOp((mlir::Value *)v285);
            if (!v169)
              goto LABEL_208;
            v170 = v169;
            v171 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v170 + 48) + 32))(*(_QWORD *)(v170 + 48), v171))goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x100000000;
            mlir::Operation::fold(v170, 0, 0, (uint64_t)v286);
            v172 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v286[0] & 0xFFFFFFFFFFFFFFF8));
            v174 = v173;
            if (v286[0] != &v287)
              free(v286[0]);
            v95 = v269;
            if (!v172)
              goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x400000000;
            mlir::getIntValues<float>((uint64_t)v172, v174, (uint64_t)v286, 1);
            v175 = LODWORD(v286[1]);
            v145 = 0.0;
            v146 = 0.0;
            if (v129 < LODWORD(v286[1]))
            {
              v146 = *((float *)v286[0] + v129);
              v145 = *((float *)v286[0] + v130);
            }
            if (v286[0] != &v287)
              free(v286[0]);
            if (v129 >= v175)
              goto LABEL_208;
          }
          v147 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 0);
          v148 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v147;
          if (v147)
            v148 = (void *)mlir::ValueRange::offset_base(v286, v147);
          v286[0] = v148;
          v286[1] = 0;
          v149 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v286, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v149)
            goto LABEL_149;
          v150 = *v149;
          v151 = mlir::TypeID::get<mlir::ShapedType>();
          v152 = *(unsigned int *)(v150 + 16);
          if ((_DWORD)v152)
          {
            v153 = *(_QWORD **)(v150 + 8);
            v154 = &v153[2 * v152];
            do
            {
              v155 = v152 >> 1;
              v156 = &v153[2 * (v152 >> 1)];
              v158 = *v156;
              v157 = v156 + 2;
              v152 += ~(v152 >> 1);
              if (v158 < v151)
                v153 = v157;
              else
                v152 = v155;
            }
            while (v152);
            v95 = v269;
            if (v153 == v154 || *v153 != v151)
            {
LABEL_149:
              v159 = 0;
              goto LABEL_182;
            }
            v159 = (void *)v153[1];
          }
          else
          {
            v159 = 0;
            v95 = v269;
          }
LABEL_182:
          v286[0] = v149;
          v286[1] = v159;
          v176 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v286);
          v178 = v177;
          v179 = *(_QWORD *)(a1 + 96);
          v180 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v277);
          v181 = (uint64_t *)mlir::TypeConverter::convertType(v179, (void *)(*(_QWORD *)(v180 + 8) & 0xFFFFFFFFFFFFFFF8));
          v182 = v181;
          if (v181)
          {
            v183 = *v181;
            v184 = mlir::TypeID::get<mlir::ShapedType>();
            v185 = *(unsigned int *)(v183 + 16);
            if ((_DWORD)v185)
            {
              v186 = *(_QWORD **)(v183 + 8);
              v187 = &v186[2 * v185];
              do
              {
                v188 = v185 >> 1;
                v189 = &v186[2 * (v185 >> 1)];
                v191 = *v189;
                v190 = v189 + 2;
                v185 += ~(v185 >> 1);
                if (v191 < v184)
                  v186 = v190;
                else
                  v185 = v188;
              }
              while (v185);
              v95 = v269;
              if (v186 == v187 || *v186 != v184)
                goto LABEL_191;
              v192 = (void *)v186[1];
            }
            else
            {
              v192 = 0;
              v95 = v269;
            }
LABEL_194:
            v286[0] = v182;
            v286[1] = v192;
            v193 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v286);
            v195 = v194;
            v196 = mlir::anec::getIndexFromDim(3, v178);
            v197 = mlir::anec::getIndexFromDim(4, v195);
            v198 = (float)*(uint64_t *)(v176 + 8 * v196);
            v199 = (float)*(uint64_t *)(v176 + 8 * v197);
            v200 = (float)*(uint64_t *)(v193 + 8 * v196);
            v201 = (float)*(uint64_t *)(v193 + 8 * v197);
            v202 = v146 != 0.0;
            if (v145 != 0.0)
              v202 = 1;
            v203 = (v138 + -1.0) * 0.5 != v146 || (v137 + -1.0) * 0.5 != v145;
            v204 = v138 != (float)(v200 / v198) || v137 != (float)(v201 / v199);
            v205 = v138 != (float)((float)(v200 + -1.0) / (float)(v198 + -1.0))
                || v137 != (float)((float)(v201 + -1.0) / (float)(v199 + -1.0));
            if (v202 || v204)
            {
              if (v202 || v205)
              {
                if (v203 || v204)
                {
LABEL_208:
                  v206 = a4[2];
                  if (!v206)
                    goto LABEL_212;
                  v207 = v276;
                  if (!mlir::RewriterBase::Listener::classof(a4[2]))
                    goto LABEL_212;
                  v208 = *((_QWORD *)v207 + 3);
LABEL_211:
                  (*(void (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v206 + 64))(v206, v208, v209, v286);
LABEL_212:
                  v93 = 0;
                  v94 = 0;
LABEL_213:
                  if (__dst != v301)
                    free(__dst);
                  if (v302 != v304)
                    free(v302);
                  if (v305 != v307)
                    free(v305);
                  goto LABEL_101;
                }
                InferredResultTypes = 0;
                IsSize = 1;
              }
              else
              {
                IsSize = 1;
                InferredResultTypes = 1;
              }
            }
            else
            {
              IsSize = 0;
              InferredResultTypes = 0;
            }
LABEL_222:
            if (InferredResultTypes && IsSize)
            {
              v286[0] = &v287;
              v287 = 0uLL;
            }
            else
            {
              if (InferredResultTypes || IsSize)
              {
                if (InferredResultTypes || !IsSize)
                {
                  v206 = a4[2];
                  if (!v206)
                    goto LABEL_212;
                  v212 = v276;
                  if (!mlir::RewriterBase::Listener::classof(a4[2]))
                    goto LABEL_212;
                  v208 = *((_QWORD *)v212 + 3);
                  goto LABEL_211;
                }
                v286[0] = &v287;
                v210 = &unk_181233190;
              }
              else
              {
                v286[0] = &v287;
                v210 = &unk_181246500;
              }
              memset_pattern16(&v287, v210, 0x10uLL);
            }
            v286[1] = (void *)0x600000002;
            v211 = v300;
            if (v300 >= 2)
            {
              *(_OWORD *)__dst = v287;
            }
            else
            {
              if (HIDWORD(v300) > 1)
              {
                if ((_DWORD)v300)
                  memmove(__dst, &v287, 8 * v300);
                else
                  v211 = 0;
              }
              else
              {
                LODWORD(v300) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v301, 2uLL, 8);
                v211 = 0;
              }
              if (v211 != LODWORD(v286[1]))
                memcpy((char *)__dst + 8 * v211, (char *)v286[0] + 8 * v211, 8 * LODWORD(v286[1]) - 8 * v211);
            }
            LODWORD(v300) = 2;
            LODWORD(v286[1]) = 0;
            if (v286[0] != &v287)
              free(v286[0]);
            v286[0] = (void *)2;
            v213 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
            v214 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 1, v213, 0);
            v215 = v214;
            if (!v214)
              goto LABEL_254;
            v216 = *v214;
            v217 = mlir::TypeID::get<mlir::ShapedType>();
            v218 = *(unsigned int *)(v216 + 16);
            if (!(_DWORD)v218)
              goto LABEL_254;
            v219 = *(_QWORD **)(v216 + 8);
            v220 = &v219[2 * v218];
            do
            {
              v221 = v218 >> 1;
              v222 = &v219[2 * (v218 >> 1)];
              v224 = *v222;
              v223 = v222 + 2;
              v218 += ~(v218 >> 1);
              if (v224 < v217)
                v219 = v223;
              else
                v218 = v221;
            }
            while (v218);
            if (v219 != v220 && *v219 == v217)
              v225 = v219[1];
            else
LABEL_254:
              v225 = 0;
            v271 = mlir::DenseElementsAttr::getFromRawBuffer(v215, v225, __dst, 8 * v300, 8, 1, 0);
            v226 = v308;
            v267 = v308 + 1;
            v227 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v285, -1.0);
            v228 = llvm::APFloatBase::IEEEsingle(v227);
            llvm::APFloat::Storage::Storage(&v286[1], v285, v228);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v285);
            llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v277, -1.0);
            llvm::APFloat::Storage::Storage(&v285[1], v277, v228);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v277);
            v277[0] = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v264, v262, &v275, v226, v267, (uint64_t)v286, (uint64_t)v285, &v272, &v271);
            v229 = (void *)v285[1];
            v230 = llvm::APFloatBase::PPCDoubleDouble(v277[0]);
            if (v230 == v229)
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v285[1]);
            else
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v285[1]);
            v231 = v263;
            if (v230 == v286[1])
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v286[1]);
            else
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v286[1]);
            v232 = mlir::anec::Resize::verifyAttributesWithFamily((uint64_t *)v277, 3);
            v93 = v277[0];
            if (!v232)
            {
              mlir::ConversionPatternRewriter::eraseOp((mlir::ConversionPatternRewriter *)a4, v277[0]);
              v286[0] = "requested attributes are not compatible with hardware requirements";
              LOWORD(v288) = 259;
              v246 = v276;
              v285[0] = (uint64_t)v286;
              v247 = a4[2];
              if (v247 && mlir::RewriterBase::Listener::classof(a4[2]))
                (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v247 + 64))(v247, *((_QWORD *)v246 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v285);
              v93 = 0;
              v94 = 0;
              v95 = v269;
              goto LABEL_213;
            }
            if (v265 != 1)
            {
LABEL_282:
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v274);
              if (v248 > 3)
              {
                v94 = 1;
                v95 = v269;
              }
              else
              {
                v286[0] = &v287;
                *(_QWORD *)&v287 = v37;
                *((_QWORD *)&v287 + 1) = IndexFromDim;
                v288 = v231;
                v289 = v37;
                v290 = IndexFromDim;
                v291 = v231;
                v286[1] = (void *)0x600000006;
                *(_OWORD *)v285 = xmmword_1812464A0;
                v249 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
                v250 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v285, 2, v249, 0);
                v251 = v250;
                if (v250
                  && (v252 = *v250,
                      v253 = mlir::TypeID::get<mlir::ShapedType>(),
                      v254 = *(unsigned int *)(v252 + 16),
                      (_DWORD)v254))
                {
                  v255 = *(_QWORD **)(v252 + 8);
                  v256 = &v255[2 * v254];
                  do
                  {
                    v257 = v254 >> 1;
                    v258 = &v255[2 * (v254 >> 1)];
                    v260 = *v258;
                    v259 = v258 + 2;
                    v254 += ~(v254 >> 1);
                    if (v260 < v253)
                      v255 = v259;
                    else
                      v254 = v257;
                  }
                  while (v254);
                  v95 = v269;
                  if (v255 != v256 && *v255 == v253)
                    v261 = v255[1];
                  else
                    v261 = 0;
                }
                else
                {
                  v261 = 0;
                  v95 = v269;
                }
                v270 = mlir::DenseElementsAttr::getFromRawBuffer(v251, v261, v286[0], 8 * LODWORD(v286[1]), 8, 1, 0);
                v285[0] = (uint64_t)v93 - 16;
                v93 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v264, v262, v285, &v270);
                if (v286[0] != &v287)
                  free(v286[0]);
                v94 = 1;
              }
              goto LABEL_213;
            }
            v286[0] = &v287;
            *(_QWORD *)&v287 = v37;
            *((_QWORD *)&v287 + 1) = v268;
            v288 = v263;
            v289 = v37;
            v290 = v268;
            v291 = v263;
            v286[1] = (void *)0x600000006;
            *(_OWORD *)v285 = xmmword_1812464A0;
            v233 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
            v234 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v285, 2, v233, 0);
            v235 = v234;
            if (!v234)
              goto LABEL_272;
            v236 = *v234;
            v237 = mlir::TypeID::get<mlir::ShapedType>();
            v238 = *(unsigned int *)(v236 + 16);
            if ((_DWORD)v238)
            {
              v239 = *(_QWORD **)(v236 + 8);
              v240 = &v239[2 * v238];
              do
              {
                v241 = v238 >> 1;
                v242 = &v239[2 * (v238 >> 1)];
                v244 = *v242;
                v243 = v242 + 2;
                v238 += ~(v238 >> 1);
                if (v244 < v237)
                  v239 = v243;
                else
                  v238 = v241;
              }
              while (v238);
              v231 = v263;
              if (v239 == v240 || *v239 != v237)
              {
LABEL_272:
                v245 = 0;
                goto LABEL_280;
              }
              v245 = v239[1];
            }
            else
            {
              v245 = 0;
              v231 = v263;
            }
LABEL_280:
            v270 = mlir::DenseElementsAttr::getFromRawBuffer(v235, v245, v286[0], 8 * LODWORD(v286[1]), 8, 1, 0);
            v93 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v264, v262, v277, &v270);
            if (v286[0] != &v287)
              free(v286[0]);
            goto LABEL_282;
          }
LABEL_191:
          v192 = 0;
          goto LABEL_194;
        }
LABEL_95:
        v115 = 0;
        goto LABEL_114;
      }
    }
    else
    {
      v95 = v269;
    }
    v292[0] = "Shape operand was not a constant";
    LOWORD(v294) = 259;
    v116 = v276;
    v286[0] = v292;
    v117 = a4[2];
    if (v117 && mlir::RewriterBase::Listener::classof(a4[2]))
      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v117 + 64))(v117, *((_QWORD *)v116 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    v93 = 0;
    v94 = 0;
  }
  else
  {
    v292[0] = "Resize layout not supported";
    LOWORD(v294) = 259;
    v91 = v276;
    v286[0] = v292;
    v92 = a4[2];
    if (v92 && mlir::RewriterBase::Listener::classof(a4[2]))
      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v92 + 64))(v92, *((_QWORD *)v91 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    v93 = 0;
    v94 = 0;
    v95 = v269;
  }
LABEL_101:
  if (v308 != v310)
    free(v308);
  if (v311 != (mlir::Operation *)v313)
    free(v311);
  if (v94)
  {
    v292[0] = (char *)v93 - 16;
    v118 = 1;
    mlir::ValueRange::ValueRange(v278, (uint64_t)v292, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)v95, v278[0], v278[1]);
  }
  else
  {
    v292[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v294) = 259;
    v286[0] = v292;
    v119 = a4[2];
    if (v119 && mlir::RewriterBase::Listener::classof(v119))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v119 + 64))(v119, *((_QWORD *)v95 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    else
      return 0;
  }
  return v118;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)3>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)3>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

_QWORD *mlir::`anonymous namespace'::ConvertResize<(mlir::anec::Family)4>::~ConvertResize(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertResize<(mlir::anec::Family)4>::~ConvertResize(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, __int128 *a3, uint64_t *a4)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int ODSOperandIndexAndLength;
  void *v22;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  unint64_t v29;
  unint64_t *v30;
  _QWORD *v31;
  unint64_t v32;
  void *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t IndexFromDim;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t IntegerType;
  _QWORD *v42;
  _QWORD *v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  _QWORD *v49;
  _QWORD *v50;
  unint64_t v51;
  unint64_t *v52;
  _QWORD *v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const void *ArgAttrsAttr;
  uint64_t v69;
  size_t v70;
  unsigned int v71;
  mlir::Operation *v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t ResizeLayout;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  _QWORD *v84;
  _QWORD *v85;
  unint64_t v86;
  unint64_t *v87;
  _QWORD *v88;
  unint64_t v89;
  uint64_t v90;
  mlir::mps *v91;
  uint64_t v92;
  mlir::GenericProgramPoint *v93;
  int v94;
  mlir::mps *v95;
  mlir::Operation *v96;
  uint64_t *v97;
  uint64_t DefiningOp;
  uint64_t v99;
  uint64_t v100;
  uint64_t *v101;
  int GateLayout;
  uint64_t v103;
  _QWORD *v104;
  _QWORD *v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  _QWORD *v109;
  _QWORD *v110;
  unint64_t v111;
  unint64_t *v112;
  _QWORD *v113;
  unint64_t v114;
  uint64_t v115;
  mlir::mps *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  void **v121;
  void *v122;
  uint64_t *v123;
  _BOOL4 InferredResultTypes;
  _BOOL4 IsSize;
  mlir::Operation *v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  void *v132;
  void *v133;
  unint64_t v134;
  void *v135;
  void *v136;
  float v137;
  float v138;
  unint64_t v139;
  void *v140;
  void *v141;
  unint64_t v142;
  void *v143;
  void *v144;
  float v145;
  float v146;
  unsigned int v147;
  void *v148;
  uint64_t *v149;
  uint64_t v150;
  unint64_t v151;
  unint64_t v152;
  _QWORD *v153;
  _QWORD *v154;
  unint64_t v155;
  unint64_t *v156;
  _QWORD *v157;
  unint64_t v158;
  void *v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t *v164;
  uint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t *v172;
  uint64_t v173;
  uint64_t v174;
  unint64_t v175;
  uint64_t v176;
  unint64_t v177;
  unint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t *v181;
  uint64_t *v182;
  uint64_t v183;
  unint64_t v184;
  unint64_t v185;
  _QWORD *v186;
  _QWORD *v187;
  unint64_t v188;
  unint64_t *v189;
  _QWORD *v190;
  unint64_t v191;
  void *v192;
  uint64_t v193;
  unint64_t v194;
  unint64_t v195;
  unint64_t v196;
  unint64_t v197;
  float v198;
  float v199;
  float v200;
  float v201;
  _BOOL4 v202;
  _BOOL4 v203;
  _BOOL4 v204;
  _BOOL4 v205;
  uint64_t v206;
  mlir::mps *v207;
  uint64_t v208;
  uint64_t (*v209)(int, uint64_t);
  const void *v210;
  uint64_t v211;
  mlir::mps *v212;
  uint64_t v213;
  _QWORD *v214;
  _QWORD *v215;
  uint64_t v216;
  unint64_t v217;
  unint64_t v218;
  _QWORD *v219;
  _QWORD *v220;
  unint64_t v221;
  unint64_t *v222;
  _QWORD *v223;
  unint64_t v224;
  uint64_t v225;
  uint64_t *v226;
  llvm::APFloatBase *v227;
  void *v228;
  void *v229;
  void *v230;
  unint64_t v231;
  char v232;
  uint64_t v233;
  _QWORD *v234;
  _QWORD *v235;
  uint64_t v236;
  unint64_t v237;
  unint64_t v238;
  _QWORD *v239;
  _QWORD *v240;
  unint64_t v241;
  unint64_t *v242;
  _QWORD *v243;
  unint64_t v244;
  uint64_t v245;
  mlir::mps *v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  _QWORD *v250;
  _QWORD *v251;
  uint64_t v252;
  unint64_t v253;
  unint64_t v254;
  _QWORD *v255;
  _QWORD *v256;
  unint64_t v257;
  unint64_t *v258;
  _QWORD *v259;
  unint64_t v260;
  uint64_t v261;
  uint64_t v262;
  unint64_t v263;
  mlir::Builder *v264;
  uint64_t v265;
  uint64_t *v267;
  unint64_t v268;
  mlir::mps *v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  _QWORD v273[2];
  _QWORD v274[2];
  uint64_t v275;
  mlir::mps *v276;
  mlir::Operation *v277[3];
  unint64_t v278[2];
  __int128 v279;
  __int128 v280;
  __int128 v281;
  __int128 v282;
  __int128 v283;
  _BYTE v284[24];
  uint64_t v285[4];
  void *v286[2];
  __int128 v287;
  unint64_t v288;
  unint64_t v289;
  unint64_t v290;
  unint64_t v291;
  void *v292[2];
  __int128 v293;
  __int128 v294;
  __int128 v295;
  __int128 v296;
  __int128 v297;
  unsigned int v298[2];
  void *__dst;
  uint64_t v300;
  _BYTE v301[16];
  void *v302;
  uint64_t v303;
  _BYTE v304[16];
  _QWORD *v305;
  uint64_t v306;
  _QWORD v307[2];
  uint64_t *v308;
  uint64_t v309;
  _QWORD v310[2];
  mlir::Operation *v311;
  uint64_t v312;
  _BYTE v313[32];
  __int128 v314;
  uint64_t v315;

  v315 = *MEMORY[0x1E0C80C00];
  v6 = a3[5];
  v283 = a3[4];
  *(_OWORD *)v284 = v6;
  *(_QWORD *)&v284[16] = *((_QWORD *)a3 + 12);
  v7 = a3[1];
  v279 = *a3;
  v280 = v7;
  v8 = a3[3];
  v281 = a3[2];
  v282 = v8;
  v276 = a2;
  v314 = *(_OWORD *)&v284[8];
  v9 = *((_QWORD *)a2 + 3);
  v275 = mlir::ValueRange::dereference_iterator(&v314, 0);
  v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v276) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_10;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_10;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_10:
    v20 = 0;
  v274[0] = v10;
  v274[1] = v20;
  ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v279, 0);
  v22 = *(void **)&v284[8];
  v292[0] = *(void **)&v284[8];
  v292[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v22 = (void *)mlir::ValueRange::offset_base(v292, ODSOperandIndexAndLength);
  v292[0] = v22;
  v292[1] = 0;
  v23 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v292, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v269 = a2;
  if (!v23)
    goto LABEL_22;
  v24 = *v23;
  v25 = mlir::TypeID::get<mlir::ShapedType>();
  v26 = *(unsigned int *)(v24 + 16);
  if (!(_DWORD)v26)
    goto LABEL_22;
  v27 = *(_QWORD **)(v24 + 8);
  v28 = &v27[2 * v26];
  do
  {
    v29 = v26 >> 1;
    v30 = &v27[2 * (v26 >> 1)];
    v32 = *v30;
    v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25)
      v27 = v31;
    else
      v26 = v29;
  }
  while (v26);
  if (v27 != v28 && *v27 == v25)
    v33 = (void *)v27[1];
  else
LABEL_22:
    v33 = 0;
  v292[0] = v23;
  v292[1] = v33;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v292);
  v35 = v34;
  IndexFromDim = mlir::anec::getIndexFromDim(0, v34);
  v37 = mlir::anec::getIndexFromDim(1, v35);
  v38 = mlir::anec::getIndexFromDim(3, v35);
  v39 = mlir::anec::getIndexFromDim(4, v35);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v274);
  if (v40 <= 3)
  {
    v292[0] = &v293;
    *(_QWORD *)&v293 = IndexFromDim;
    *((_QWORD *)&v293 + 1) = v37;
    *(_QWORD *)&v294 = v37;
    *((_QWORD *)&v294 + 1) = v38;
    *(_QWORD *)&v295 = v38;
    *((_QWORD *)&v295 + 1) = IndexFromDim;
    v292[1] = (void *)0x600000006;
    *(_OWORD *)v286 = xmmword_1812464A0;
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    v42 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 2, IntegerType, 0);
    v43 = v42;
    if (v42)
    {
      v44 = v39;
      v45 = v9;
      v46 = *v42;
      v47 = mlir::TypeID::get<mlir::ShapedType>();
      v48 = *(unsigned int *)(v46 + 16);
      if ((_DWORD)v48)
      {
        v49 = *(_QWORD **)(v46 + 8);
        v50 = &v49[2 * v48];
        do
        {
          v51 = v48 >> 1;
          v52 = &v49[2 * (v48 >> 1)];
          v54 = *v52;
          v53 = v52 + 2;
          v48 += ~(v48 >> 1);
          if (v54 < v47)
            v49 = v53;
          else
            v48 = v51;
        }
        while (v48);
        v9 = v45;
        if (v49 == v50)
        {
          v55 = 0;
          v39 = v44;
        }
        else
        {
          v39 = v44;
          if (*v49 != v47)
            goto LABEL_33;
          v55 = v49[1];
        }
      }
      else
      {
        v55 = 0;
        v9 = v45;
        v39 = v44;
      }
LABEL_39:
      v311 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v43, v55, v292[0], 8 * LODWORD(v292[1]), 8, 1, 0);
      v275 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v9, &v275, (uint64_t *)&v311)- 16;
      if (v292[0] != &v293)
        free(v292[0]);
      goto LABEL_41;
    }
LABEL_33:
    v55 = 0;
    goto LABEL_39;
  }
LABEL_41:
  v56 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v276) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v56)
    goto LABEL_50;
  v57 = *v56;
  v58 = mlir::TypeID::get<mlir::ShapedType>();
  v59 = *(unsigned int *)(v57 + 16);
  if (!(_DWORD)v59)
    goto LABEL_50;
  v60 = *(_QWORD **)(v57 + 8);
  v61 = &v60[2 * v59];
  do
  {
    v62 = v59 >> 1;
    v63 = &v60[2 * (v59 >> 1)];
    v65 = *v63;
    v64 = v63 + 2;
    v59 += ~(v59 >> 1);
    if (v65 < v58)
      v60 = v64;
    else
      v59 = v62;
  }
  while (v59);
  if (v60 != v61 && *v60 == v58)
    v66 = v60[1];
  else
LABEL_50:
    v66 = 0;
  v273[0] = v56;
  v273[1] = v66;
  ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v273);
  v69 = v67;
  v311 = (mlir::Operation *)v313;
  v312 = 0x400000000;
  v70 = 8 * v67;
  if ((unint64_t)(8 * v67) < 0x21)
  {
    v71 = 0;
    v72 = (mlir::Operation *)v313;
    if (!v69)
      goto LABEL_56;
    goto LABEL_55;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v311, v313, (8 * v67) >> 3, 8);
  v71 = v312;
  v72 = v311;
  if (v69)
  {
LABEL_55:
    memcpy((char *)v72 + 8 * v71, ArgAttrsAttr, v70);
    v71 = v312;
    v72 = v311;
  }
LABEL_56:
  v73 = v71 + (v70 >> 3);
  LODWORD(v312) = v73;
  if (v73 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v311, (uint64_t)v72, 4 - v73, 1uLL);
    v72 = v311;
  }
  v74 = *((_QWORD *)v72 + v38);
  v268 = v39;
  v75 = *((_QWORD *)v72 + v39);
  v308 = v310;
  v310[0] = v74;
  v310[1] = v75;
  v309 = 0x200000002;
  ResizeLayout = mlir::mps::getResizeLayout(v276, v72);
  if ((ResizeLayout & 0xFF00000000) != 0)
  {
    v265 = ResizeLayout;
    if (ResizeLayout == 1)
    {
      v292[0] = &v293;
      *(_QWORD *)&v293 = v37;
      *((_QWORD *)&v293 + 1) = v38;
      *(_QWORD *)&v294 = v38;
      *((_QWORD *)&v294 + 1) = v39;
      *(_QWORD *)&v295 = v39;
      *((_QWORD *)&v295 + 1) = v37;
      v292[1] = (void *)0x600000006;
      *(_OWORD *)v286 = xmmword_1812464A0;
      v77 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
      v78 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 2, v77, 0);
      v79 = v78;
      if (v78)
      {
        v80 = v9;
        v81 = *v78;
        v82 = mlir::TypeID::get<mlir::ShapedType>();
        v83 = *(unsigned int *)(v81 + 16);
        if ((_DWORD)v83)
        {
          v84 = *(_QWORD **)(v81 + 8);
          v85 = &v84[2 * v83];
          do
          {
            v86 = v83 >> 1;
            v87 = &v84[2 * (v83 >> 1)];
            v89 = *v87;
            v88 = v87 + 2;
            v83 += ~(v83 >> 1);
            if (v89 < v82)
              v84 = v88;
            else
              v83 = v86;
          }
          while (v83);
          v9 = v80;
          if (v84 == v85)
            v90 = 0;
          else
            v90 = *v84 == v82 ? v84[1] : 0;
        }
        else
        {
          v90 = 0;
          v9 = v80;
        }
      }
      else
      {
        v90 = 0;
      }
      v305 = (_QWORD *)mlir::DenseElementsAttr::getFromRawBuffer(v79, v90, v292[0], 8 * LODWORD(v292[1]), 8, 1, 0);
      v275 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v9, &v275, (uint64_t *)&v305)- 16;
      v96 = v311;
      v97 = v308;
      *v308 = *((_QWORD *)v311 + v37);
      v97[1] = *((_QWORD *)v96 + v38);
      if (v292[0] != &v293)
        free(v292[0]);
    }
    v286[0] = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v276);
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v286);
    if (DefiningOp
      && (v99 = DefiningOp,
          v100 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          (*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v99 + 48) + 32))(*(_QWORD *)(v99 + 48), v100)))
    {
      v263 = v38;
      v292[0] = &v293;
      v292[1] = (void *)0x100000000;
      mlir::Operation::fold(v99, 0, 0, (uint64_t)v292);
      v101 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v292[0] & 0xFFFFFFFFFFFFFFF8));
      if (v292[0] != &v293)
        free(v292[0]);
      v95 = v269;
      if (v101)
      {
        v262 = v9;
        v305 = v307;
        v307[0] = 0;
        v307[1] = 0;
        v306 = 0x200000002;
        v302 = v304;
        memset_pattern16(v304, &unk_181233190, 0x10uLL);
        v303 = 0x200000002;
        GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v276);
        v292[0] = (void *)2;
        v264 = (mlir::Builder *)(a4 + 1);
        v103 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
        v104 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v292, 1, v103, 0);
        v105 = v104;
        if (v104)
        {
          v106 = *v104;
          v107 = mlir::TypeID::get<mlir::ShapedType>();
          v108 = *(unsigned int *)(v106 + 16);
          if ((_DWORD)v108)
          {
            v109 = *(_QWORD **)(v106 + 8);
            v110 = &v109[2 * v108];
            do
            {
              v111 = v108 >> 1;
              v112 = &v109[2 * (v108 >> 1)];
              v114 = *v112;
              v113 = v112 + 2;
              v108 += ~(v108 >> 1);
              if (v114 < v107)
                v109 = v113;
              else
                v108 = v111;
            }
            while (v108);
            v95 = v269;
            if (v109 == v110 || *v109 != v107)
              goto LABEL_95;
            v115 = v109[1];
          }
          else
          {
            v115 = 0;
            v95 = v269;
          }
LABEL_114:
          if (GateLayout == 1)
            v121 = (void **)&v305;
          else
            v121 = &v302;
          v122 = *v121;
          v123 = &v306;
          if (GateLayout != 1)
            v123 = &v303;
          v272 = mlir::DenseElementsAttr::getFromRawBuffer(v105, v115, v122, 8 * *(unsigned int *)v123, 8, 1, 0);
          __dst = v301;
          v300 = 0x200000000;
          InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v276);
          IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v276);
          if (!mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v276)
            && !mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v276))
          {
            goto LABEL_222;
          }
          v296 = v283;
          v297 = *(_OWORD *)v284;
          *(_QWORD *)v298 = *(_QWORD *)&v284[16];
          *(_OWORD *)v292 = v279;
          v293 = v280;
          v294 = v281;
          v295 = v282;
          v277[0] = v276;
          v127 = mlir::mps::getResizeLayout(v276, v126);
          if ((v127 & 0xFF00000000) == 0)
            goto LABEL_208;
          v128 = 8 * (int)v127;
          v129 = *(_QWORD *)((char *)&unk_181246668 + v128);
          v130 = *(_QWORD *)((char *)&unk_1812466A0 + v128);
          v131 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 2u);
          v132 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v131;
          if ((_DWORD)v131)
          {
            v132 = (void *)mlir::ValueRange::offset_base(v286, v131);
            v133 = v286[1];
          }
          else
          {
            v133 = 0;
          }
          if ((void *)(HIDWORD(v131) + v131) == v133
            || (v286[0] = v132, v286[1] = 0, !mlir::ValueRange::dereference_iterator(v286, 0)))
          {
            v137 = 1.0;
            v138 = 1.0;
          }
          else
          {
            v134 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 2u);
            v135 = (void *)*((_QWORD *)&v297 + 1);
            v286[0] = *((void **)&v297 + 1);
            v286[1] = (void *)v134;
            if ((_DWORD)v134)
            {
              v135 = (void *)mlir::ValueRange::offset_base(v286, v134);
              v136 = v286[1];
            }
            else
            {
              v136 = 0;
            }
            if ((void *)(HIDWORD(v134) + v134) == v136)
            {
              v160 = 0;
            }
            else
            {
              v286[0] = v135;
              v286[1] = 0;
              v160 = mlir::ValueRange::dereference_iterator(v286, 0);
            }
            v285[0] = v160;
            v161 = mlir::Value::getDefiningOp((mlir::Value *)v285);
            if (!v161)
              goto LABEL_208;
            v162 = v161;
            v163 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v162 + 48) + 32))(*(_QWORD *)(v162 + 48), v163))goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x100000000;
            mlir::Operation::fold(v162, 0, 0, (uint64_t)v286);
            v164 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v286[0] & 0xFFFFFFFFFFFFFFF8));
            v166 = v165;
            if (v286[0] != &v287)
              free(v286[0]);
            v95 = v269;
            if (!v164)
              goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x400000000;
            mlir::getIntValues<float>((uint64_t)v164, v166, (uint64_t)v286, 1);
            v167 = LODWORD(v286[1]);
            v137 = 1.0;
            v138 = 1.0;
            if (v129 < LODWORD(v286[1]))
            {
              v138 = *((float *)v286[0] + v129);
              v137 = *((float *)v286[0] + v130);
            }
            if (v286[0] != &v287)
              free(v286[0]);
            if (v129 >= v167)
              goto LABEL_208;
          }
          v139 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 3u);
          v140 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v139;
          if ((_DWORD)v139)
          {
            v140 = (void *)mlir::ValueRange::offset_base(v286, v139);
            v141 = v286[1];
          }
          else
          {
            v141 = 0;
          }
          if ((void *)(HIDWORD(v139) + v139) == v141
            || (v286[0] = v140, v286[1] = 0, !mlir::ValueRange::dereference_iterator(v286, 0)))
          {
            v145 = 0.0;
            v146 = 0.0;
          }
          else
          {
            v142 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 3u);
            v143 = (void *)*((_QWORD *)&v297 + 1);
            v286[0] = *((void **)&v297 + 1);
            v286[1] = (void *)v142;
            if ((_DWORD)v142)
            {
              v143 = (void *)mlir::ValueRange::offset_base(v286, v142);
              v144 = v286[1];
            }
            else
            {
              v144 = 0;
            }
            if ((void *)(HIDWORD(v142) + v142) == v144)
            {
              v168 = 0;
            }
            else
            {
              v286[0] = v143;
              v286[1] = 0;
              v168 = mlir::ValueRange::dereference_iterator(v286, 0);
            }
            v285[0] = v168;
            v169 = mlir::Value::getDefiningOp((mlir::Value *)v285);
            if (!v169)
              goto LABEL_208;
            v170 = v169;
            v171 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v170 + 48) + 32))(*(_QWORD *)(v170 + 48), v171))goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x100000000;
            mlir::Operation::fold(v170, 0, 0, (uint64_t)v286);
            v172 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v286[0] & 0xFFFFFFFFFFFFFFF8));
            v174 = v173;
            if (v286[0] != &v287)
              free(v286[0]);
            v95 = v269;
            if (!v172)
              goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x400000000;
            mlir::getIntValues<float>((uint64_t)v172, v174, (uint64_t)v286, 1);
            v175 = LODWORD(v286[1]);
            v145 = 0.0;
            v146 = 0.0;
            if (v129 < LODWORD(v286[1]))
            {
              v146 = *((float *)v286[0] + v129);
              v145 = *((float *)v286[0] + v130);
            }
            if (v286[0] != &v287)
              free(v286[0]);
            if (v129 >= v175)
              goto LABEL_208;
          }
          v147 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 0);
          v148 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v147;
          if (v147)
            v148 = (void *)mlir::ValueRange::offset_base(v286, v147);
          v286[0] = v148;
          v286[1] = 0;
          v149 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v286, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v149)
            goto LABEL_149;
          v150 = *v149;
          v151 = mlir::TypeID::get<mlir::ShapedType>();
          v152 = *(unsigned int *)(v150 + 16);
          if ((_DWORD)v152)
          {
            v153 = *(_QWORD **)(v150 + 8);
            v154 = &v153[2 * v152];
            do
            {
              v155 = v152 >> 1;
              v156 = &v153[2 * (v152 >> 1)];
              v158 = *v156;
              v157 = v156 + 2;
              v152 += ~(v152 >> 1);
              if (v158 < v151)
                v153 = v157;
              else
                v152 = v155;
            }
            while (v152);
            v95 = v269;
            if (v153 == v154 || *v153 != v151)
            {
LABEL_149:
              v159 = 0;
              goto LABEL_182;
            }
            v159 = (void *)v153[1];
          }
          else
          {
            v159 = 0;
            v95 = v269;
          }
LABEL_182:
          v286[0] = v149;
          v286[1] = v159;
          v176 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v286);
          v178 = v177;
          v179 = *(_QWORD *)(a1 + 96);
          v180 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v277);
          v181 = (uint64_t *)mlir::TypeConverter::convertType(v179, (void *)(*(_QWORD *)(v180 + 8) & 0xFFFFFFFFFFFFFFF8));
          v182 = v181;
          if (v181)
          {
            v183 = *v181;
            v184 = mlir::TypeID::get<mlir::ShapedType>();
            v185 = *(unsigned int *)(v183 + 16);
            if ((_DWORD)v185)
            {
              v186 = *(_QWORD **)(v183 + 8);
              v187 = &v186[2 * v185];
              do
              {
                v188 = v185 >> 1;
                v189 = &v186[2 * (v185 >> 1)];
                v191 = *v189;
                v190 = v189 + 2;
                v185 += ~(v185 >> 1);
                if (v191 < v184)
                  v186 = v190;
                else
                  v185 = v188;
              }
              while (v185);
              v95 = v269;
              if (v186 == v187 || *v186 != v184)
                goto LABEL_191;
              v192 = (void *)v186[1];
            }
            else
            {
              v192 = 0;
              v95 = v269;
            }
LABEL_194:
            v286[0] = v182;
            v286[1] = v192;
            v193 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v286);
            v195 = v194;
            v196 = mlir::anec::getIndexFromDim(3, v178);
            v197 = mlir::anec::getIndexFromDim(4, v195);
            v198 = (float)*(uint64_t *)(v176 + 8 * v196);
            v199 = (float)*(uint64_t *)(v176 + 8 * v197);
            v200 = (float)*(uint64_t *)(v193 + 8 * v196);
            v201 = (float)*(uint64_t *)(v193 + 8 * v197);
            v202 = v146 != 0.0;
            if (v145 != 0.0)
              v202 = 1;
            v203 = (v138 + -1.0) * 0.5 != v146 || (v137 + -1.0) * 0.5 != v145;
            v204 = v138 != (float)(v200 / v198) || v137 != (float)(v201 / v199);
            v205 = v138 != (float)((float)(v200 + -1.0) / (float)(v198 + -1.0))
                || v137 != (float)((float)(v201 + -1.0) / (float)(v199 + -1.0));
            if (v202 || v204)
            {
              if (v202 || v205)
              {
                if (v203 || v204)
                {
LABEL_208:
                  v206 = a4[2];
                  if (!v206)
                    goto LABEL_212;
                  v207 = v276;
                  if (!mlir::RewriterBase::Listener::classof(a4[2]))
                    goto LABEL_212;
                  v208 = *((_QWORD *)v207 + 3);
LABEL_211:
                  (*(void (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v206 + 64))(v206, v208, v209, v286);
LABEL_212:
                  v93 = 0;
                  v94 = 0;
LABEL_213:
                  if (__dst != v301)
                    free(__dst);
                  if (v302 != v304)
                    free(v302);
                  if (v305 != v307)
                    free(v305);
                  goto LABEL_101;
                }
                InferredResultTypes = 0;
                IsSize = 1;
              }
              else
              {
                IsSize = 1;
                InferredResultTypes = 1;
              }
            }
            else
            {
              IsSize = 0;
              InferredResultTypes = 0;
            }
LABEL_222:
            if (InferredResultTypes && IsSize)
            {
              v286[0] = &v287;
              v287 = 0uLL;
            }
            else
            {
              if (InferredResultTypes || IsSize)
              {
                if (InferredResultTypes || !IsSize)
                {
                  v206 = a4[2];
                  if (!v206)
                    goto LABEL_212;
                  v212 = v276;
                  if (!mlir::RewriterBase::Listener::classof(a4[2]))
                    goto LABEL_212;
                  v208 = *((_QWORD *)v212 + 3);
                  goto LABEL_211;
                }
                v286[0] = &v287;
                v210 = &unk_181233190;
              }
              else
              {
                v286[0] = &v287;
                v210 = &unk_181246500;
              }
              memset_pattern16(&v287, v210, 0x10uLL);
            }
            v286[1] = (void *)0x600000002;
            v211 = v300;
            if (v300 >= 2)
            {
              *(_OWORD *)__dst = v287;
            }
            else
            {
              if (HIDWORD(v300) > 1)
              {
                if ((_DWORD)v300)
                  memmove(__dst, &v287, 8 * v300);
                else
                  v211 = 0;
              }
              else
              {
                LODWORD(v300) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v301, 2uLL, 8);
                v211 = 0;
              }
              if (v211 != LODWORD(v286[1]))
                memcpy((char *)__dst + 8 * v211, (char *)v286[0] + 8 * v211, 8 * LODWORD(v286[1]) - 8 * v211);
            }
            LODWORD(v300) = 2;
            LODWORD(v286[1]) = 0;
            if (v286[0] != &v287)
              free(v286[0]);
            v286[0] = (void *)2;
            v213 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
            v214 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 1, v213, 0);
            v215 = v214;
            if (!v214)
              goto LABEL_254;
            v216 = *v214;
            v217 = mlir::TypeID::get<mlir::ShapedType>();
            v218 = *(unsigned int *)(v216 + 16);
            if (!(_DWORD)v218)
              goto LABEL_254;
            v219 = *(_QWORD **)(v216 + 8);
            v220 = &v219[2 * v218];
            do
            {
              v221 = v218 >> 1;
              v222 = &v219[2 * (v218 >> 1)];
              v224 = *v222;
              v223 = v222 + 2;
              v218 += ~(v218 >> 1);
              if (v224 < v217)
                v219 = v223;
              else
                v218 = v221;
            }
            while (v218);
            if (v219 != v220 && *v219 == v217)
              v225 = v219[1];
            else
LABEL_254:
              v225 = 0;
            v271 = mlir::DenseElementsAttr::getFromRawBuffer(v215, v225, __dst, 8 * v300, 8, 1, 0);
            v226 = v308;
            v267 = v308 + 1;
            v227 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v285, -1.0);
            v228 = llvm::APFloatBase::IEEEsingle(v227);
            llvm::APFloat::Storage::Storage(&v286[1], v285, v228);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v285);
            llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v277, -1.0);
            llvm::APFloat::Storage::Storage(&v285[1], v277, v228);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v277);
            v277[0] = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v264, v262, &v275, v226, v267, (uint64_t)v286, (uint64_t)v285, &v272, &v271);
            v229 = (void *)v285[1];
            v230 = llvm::APFloatBase::PPCDoubleDouble(v277[0]);
            if (v230 == v229)
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v285[1]);
            else
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v285[1]);
            v231 = v263;
            if (v230 == v286[1])
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v286[1]);
            else
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v286[1]);
            v232 = mlir::anec::Resize::verifyAttributesWithFamily((uint64_t *)v277, 4);
            v93 = v277[0];
            if (!v232)
            {
              mlir::ConversionPatternRewriter::eraseOp((mlir::ConversionPatternRewriter *)a4, v277[0]);
              v286[0] = "requested attributes are not compatible with hardware requirements";
              LOWORD(v288) = 259;
              v246 = v276;
              v285[0] = (uint64_t)v286;
              v247 = a4[2];
              if (v247 && mlir::RewriterBase::Listener::classof(a4[2]))
                (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v247 + 64))(v247, *((_QWORD *)v246 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v285);
              v93 = 0;
              v94 = 0;
              v95 = v269;
              goto LABEL_213;
            }
            if (v265 != 1)
            {
LABEL_282:
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v274);
              if (v248 > 3)
              {
                v94 = 1;
                v95 = v269;
              }
              else
              {
                v286[0] = &v287;
                *(_QWORD *)&v287 = v37;
                *((_QWORD *)&v287 + 1) = IndexFromDim;
                v288 = v231;
                v289 = v37;
                v290 = IndexFromDim;
                v291 = v231;
                v286[1] = (void *)0x600000006;
                *(_OWORD *)v285 = xmmword_1812464A0;
                v249 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
                v250 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v285, 2, v249, 0);
                v251 = v250;
                if (v250
                  && (v252 = *v250,
                      v253 = mlir::TypeID::get<mlir::ShapedType>(),
                      v254 = *(unsigned int *)(v252 + 16),
                      (_DWORD)v254))
                {
                  v255 = *(_QWORD **)(v252 + 8);
                  v256 = &v255[2 * v254];
                  do
                  {
                    v257 = v254 >> 1;
                    v258 = &v255[2 * (v254 >> 1)];
                    v260 = *v258;
                    v259 = v258 + 2;
                    v254 += ~(v254 >> 1);
                    if (v260 < v253)
                      v255 = v259;
                    else
                      v254 = v257;
                  }
                  while (v254);
                  v95 = v269;
                  if (v255 != v256 && *v255 == v253)
                    v261 = v255[1];
                  else
                    v261 = 0;
                }
                else
                {
                  v261 = 0;
                  v95 = v269;
                }
                v270 = mlir::DenseElementsAttr::getFromRawBuffer(v251, v261, v286[0], 8 * LODWORD(v286[1]), 8, 1, 0);
                v285[0] = (uint64_t)v93 - 16;
                v93 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v264, v262, v285, &v270);
                if (v286[0] != &v287)
                  free(v286[0]);
                v94 = 1;
              }
              goto LABEL_213;
            }
            v286[0] = &v287;
            *(_QWORD *)&v287 = v37;
            *((_QWORD *)&v287 + 1) = v268;
            v288 = v263;
            v289 = v37;
            v290 = v268;
            v291 = v263;
            v286[1] = (void *)0x600000006;
            *(_OWORD *)v285 = xmmword_1812464A0;
            v233 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
            v234 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v285, 2, v233, 0);
            v235 = v234;
            if (!v234)
              goto LABEL_272;
            v236 = *v234;
            v237 = mlir::TypeID::get<mlir::ShapedType>();
            v238 = *(unsigned int *)(v236 + 16);
            if ((_DWORD)v238)
            {
              v239 = *(_QWORD **)(v236 + 8);
              v240 = &v239[2 * v238];
              do
              {
                v241 = v238 >> 1;
                v242 = &v239[2 * (v238 >> 1)];
                v244 = *v242;
                v243 = v242 + 2;
                v238 += ~(v238 >> 1);
                if (v244 < v237)
                  v239 = v243;
                else
                  v238 = v241;
              }
              while (v238);
              v231 = v263;
              if (v239 == v240 || *v239 != v237)
              {
LABEL_272:
                v245 = 0;
                goto LABEL_280;
              }
              v245 = v239[1];
            }
            else
            {
              v245 = 0;
              v231 = v263;
            }
LABEL_280:
            v270 = mlir::DenseElementsAttr::getFromRawBuffer(v235, v245, v286[0], 8 * LODWORD(v286[1]), 8, 1, 0);
            v93 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v264, v262, v277, &v270);
            if (v286[0] != &v287)
              free(v286[0]);
            goto LABEL_282;
          }
LABEL_191:
          v192 = 0;
          goto LABEL_194;
        }
LABEL_95:
        v115 = 0;
        goto LABEL_114;
      }
    }
    else
    {
      v95 = v269;
    }
    v292[0] = "Shape operand was not a constant";
    LOWORD(v294) = 259;
    v116 = v276;
    v286[0] = v292;
    v117 = a4[2];
    if (v117 && mlir::RewriterBase::Listener::classof(a4[2]))
      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v117 + 64))(v117, *((_QWORD *)v116 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    v93 = 0;
    v94 = 0;
  }
  else
  {
    v292[0] = "Resize layout not supported";
    LOWORD(v294) = 259;
    v91 = v276;
    v286[0] = v292;
    v92 = a4[2];
    if (v92 && mlir::RewriterBase::Listener::classof(a4[2]))
      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v92 + 64))(v92, *((_QWORD *)v91 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    v93 = 0;
    v94 = 0;
    v95 = v269;
  }
LABEL_101:
  if (v308 != v310)
    free(v308);
  if (v311 != (mlir::Operation *)v313)
    free(v311);
  if (v94)
  {
    v292[0] = (char *)v93 - 16;
    v118 = 1;
    mlir::ValueRange::ValueRange(v278, (uint64_t)v292, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)v95, v278[0], v278[1]);
  }
  else
  {
    v292[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v294) = 259;
    v286[0] = v292;
    v119 = a4[2];
    if (v119 && mlir::RewriterBase::Listener::classof(v119))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v119 + 64))(v119, *((_QWORD *)v95 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    else
      return 0;
  }
  return v118;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)4>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)4>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

_QWORD *mlir::`anonymous namespace'::ConvertResize<(mlir::anec::Family)5>::~ConvertResize(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertResize<(mlir::anec::Family)5>::~ConvertResize(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, __int128 *a3, uint64_t *a4)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int ODSOperandIndexAndLength;
  void *v22;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  unint64_t v29;
  unint64_t *v30;
  _QWORD *v31;
  unint64_t v32;
  void *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t IndexFromDim;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t IntegerType;
  _QWORD *v42;
  _QWORD *v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  _QWORD *v49;
  _QWORD *v50;
  unint64_t v51;
  unint64_t *v52;
  _QWORD *v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const void *ArgAttrsAttr;
  uint64_t v69;
  size_t v70;
  unsigned int v71;
  mlir::Operation *v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t ResizeLayout;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  _QWORD *v84;
  _QWORD *v85;
  unint64_t v86;
  unint64_t *v87;
  _QWORD *v88;
  unint64_t v89;
  uint64_t v90;
  mlir::mps *v91;
  uint64_t v92;
  mlir::GenericProgramPoint *v93;
  int v94;
  mlir::mps *v95;
  mlir::Operation *v96;
  uint64_t *v97;
  uint64_t DefiningOp;
  uint64_t v99;
  uint64_t v100;
  uint64_t *v101;
  int GateLayout;
  uint64_t v103;
  _QWORD *v104;
  _QWORD *v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  _QWORD *v109;
  _QWORD *v110;
  unint64_t v111;
  unint64_t *v112;
  _QWORD *v113;
  unint64_t v114;
  uint64_t v115;
  mlir::mps *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  void **v121;
  void *v122;
  uint64_t *v123;
  _BOOL4 InferredResultTypes;
  _BOOL4 IsSize;
  mlir::Operation *v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  void *v132;
  void *v133;
  unint64_t v134;
  void *v135;
  void *v136;
  float v137;
  float v138;
  unint64_t v139;
  void *v140;
  void *v141;
  unint64_t v142;
  void *v143;
  void *v144;
  float v145;
  float v146;
  unsigned int v147;
  void *v148;
  uint64_t *v149;
  uint64_t v150;
  unint64_t v151;
  unint64_t v152;
  _QWORD *v153;
  _QWORD *v154;
  unint64_t v155;
  unint64_t *v156;
  _QWORD *v157;
  unint64_t v158;
  void *v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t *v164;
  uint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t *v172;
  uint64_t v173;
  uint64_t v174;
  unint64_t v175;
  uint64_t v176;
  unint64_t v177;
  unint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t *v181;
  uint64_t *v182;
  uint64_t v183;
  unint64_t v184;
  unint64_t v185;
  _QWORD *v186;
  _QWORD *v187;
  unint64_t v188;
  unint64_t *v189;
  _QWORD *v190;
  unint64_t v191;
  void *v192;
  uint64_t v193;
  unint64_t v194;
  unint64_t v195;
  unint64_t v196;
  unint64_t v197;
  float v198;
  float v199;
  float v200;
  float v201;
  _BOOL4 v202;
  _BOOL4 v203;
  _BOOL4 v204;
  _BOOL4 v205;
  uint64_t v206;
  mlir::mps *v207;
  uint64_t v208;
  uint64_t (*v209)(int, uint64_t);
  const void *v210;
  uint64_t v211;
  mlir::mps *v212;
  uint64_t v213;
  _QWORD *v214;
  _QWORD *v215;
  uint64_t v216;
  unint64_t v217;
  unint64_t v218;
  _QWORD *v219;
  _QWORD *v220;
  unint64_t v221;
  unint64_t *v222;
  _QWORD *v223;
  unint64_t v224;
  uint64_t v225;
  uint64_t *v226;
  llvm::APFloatBase *v227;
  void *v228;
  void *v229;
  void *v230;
  unint64_t v231;
  char v232;
  uint64_t v233;
  _QWORD *v234;
  _QWORD *v235;
  uint64_t v236;
  unint64_t v237;
  unint64_t v238;
  _QWORD *v239;
  _QWORD *v240;
  unint64_t v241;
  unint64_t *v242;
  _QWORD *v243;
  unint64_t v244;
  uint64_t v245;
  mlir::mps *v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  _QWORD *v250;
  _QWORD *v251;
  uint64_t v252;
  unint64_t v253;
  unint64_t v254;
  _QWORD *v255;
  _QWORD *v256;
  unint64_t v257;
  unint64_t *v258;
  _QWORD *v259;
  unint64_t v260;
  uint64_t v261;
  uint64_t v262;
  unint64_t v263;
  mlir::Builder *v264;
  uint64_t v265;
  uint64_t *v267;
  unint64_t v268;
  mlir::mps *v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  _QWORD v273[2];
  _QWORD v274[2];
  uint64_t v275;
  mlir::mps *v276;
  mlir::Operation *v277[3];
  unint64_t v278[2];
  __int128 v279;
  __int128 v280;
  __int128 v281;
  __int128 v282;
  __int128 v283;
  _BYTE v284[24];
  uint64_t v285[4];
  void *v286[2];
  __int128 v287;
  unint64_t v288;
  unint64_t v289;
  unint64_t v290;
  unint64_t v291;
  void *v292[2];
  __int128 v293;
  __int128 v294;
  __int128 v295;
  __int128 v296;
  __int128 v297;
  unsigned int v298[2];
  void *__dst;
  uint64_t v300;
  _BYTE v301[16];
  void *v302;
  uint64_t v303;
  _BYTE v304[16];
  _QWORD *v305;
  uint64_t v306;
  _QWORD v307[2];
  uint64_t *v308;
  uint64_t v309;
  _QWORD v310[2];
  mlir::Operation *v311;
  uint64_t v312;
  _BYTE v313[32];
  __int128 v314;
  uint64_t v315;

  v315 = *MEMORY[0x1E0C80C00];
  v6 = a3[5];
  v283 = a3[4];
  *(_OWORD *)v284 = v6;
  *(_QWORD *)&v284[16] = *((_QWORD *)a3 + 12);
  v7 = a3[1];
  v279 = *a3;
  v280 = v7;
  v8 = a3[3];
  v281 = a3[2];
  v282 = v8;
  v276 = a2;
  v314 = *(_OWORD *)&v284[8];
  v9 = *((_QWORD *)a2 + 3);
  v275 = mlir::ValueRange::dereference_iterator(&v314, 0);
  v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v276) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_10;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_10;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_10:
    v20 = 0;
  v274[0] = v10;
  v274[1] = v20;
  ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v279, 0);
  v22 = *(void **)&v284[8];
  v292[0] = *(void **)&v284[8];
  v292[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v22 = (void *)mlir::ValueRange::offset_base(v292, ODSOperandIndexAndLength);
  v292[0] = v22;
  v292[1] = 0;
  v23 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v292, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v269 = a2;
  if (!v23)
    goto LABEL_22;
  v24 = *v23;
  v25 = mlir::TypeID::get<mlir::ShapedType>();
  v26 = *(unsigned int *)(v24 + 16);
  if (!(_DWORD)v26)
    goto LABEL_22;
  v27 = *(_QWORD **)(v24 + 8);
  v28 = &v27[2 * v26];
  do
  {
    v29 = v26 >> 1;
    v30 = &v27[2 * (v26 >> 1)];
    v32 = *v30;
    v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25)
      v27 = v31;
    else
      v26 = v29;
  }
  while (v26);
  if (v27 != v28 && *v27 == v25)
    v33 = (void *)v27[1];
  else
LABEL_22:
    v33 = 0;
  v292[0] = v23;
  v292[1] = v33;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v292);
  v35 = v34;
  IndexFromDim = mlir::anec::getIndexFromDim(0, v34);
  v37 = mlir::anec::getIndexFromDim(1, v35);
  v38 = mlir::anec::getIndexFromDim(3, v35);
  v39 = mlir::anec::getIndexFromDim(4, v35);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v274);
  if (v40 <= 3)
  {
    v292[0] = &v293;
    *(_QWORD *)&v293 = IndexFromDim;
    *((_QWORD *)&v293 + 1) = v37;
    *(_QWORD *)&v294 = v37;
    *((_QWORD *)&v294 + 1) = v38;
    *(_QWORD *)&v295 = v38;
    *((_QWORD *)&v295 + 1) = IndexFromDim;
    v292[1] = (void *)0x600000006;
    *(_OWORD *)v286 = xmmword_1812464A0;
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    v42 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 2, IntegerType, 0);
    v43 = v42;
    if (v42)
    {
      v44 = v39;
      v45 = v9;
      v46 = *v42;
      v47 = mlir::TypeID::get<mlir::ShapedType>();
      v48 = *(unsigned int *)(v46 + 16);
      if ((_DWORD)v48)
      {
        v49 = *(_QWORD **)(v46 + 8);
        v50 = &v49[2 * v48];
        do
        {
          v51 = v48 >> 1;
          v52 = &v49[2 * (v48 >> 1)];
          v54 = *v52;
          v53 = v52 + 2;
          v48 += ~(v48 >> 1);
          if (v54 < v47)
            v49 = v53;
          else
            v48 = v51;
        }
        while (v48);
        v9 = v45;
        if (v49 == v50)
        {
          v55 = 0;
          v39 = v44;
        }
        else
        {
          v39 = v44;
          if (*v49 != v47)
            goto LABEL_33;
          v55 = v49[1];
        }
      }
      else
      {
        v55 = 0;
        v9 = v45;
        v39 = v44;
      }
LABEL_39:
      v311 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v43, v55, v292[0], 8 * LODWORD(v292[1]), 8, 1, 0);
      v275 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v9, &v275, (uint64_t *)&v311)- 16;
      if (v292[0] != &v293)
        free(v292[0]);
      goto LABEL_41;
    }
LABEL_33:
    v55 = 0;
    goto LABEL_39;
  }
LABEL_41:
  v56 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v276) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v56)
    goto LABEL_50;
  v57 = *v56;
  v58 = mlir::TypeID::get<mlir::ShapedType>();
  v59 = *(unsigned int *)(v57 + 16);
  if (!(_DWORD)v59)
    goto LABEL_50;
  v60 = *(_QWORD **)(v57 + 8);
  v61 = &v60[2 * v59];
  do
  {
    v62 = v59 >> 1;
    v63 = &v60[2 * (v59 >> 1)];
    v65 = *v63;
    v64 = v63 + 2;
    v59 += ~(v59 >> 1);
    if (v65 < v58)
      v60 = v64;
    else
      v59 = v62;
  }
  while (v59);
  if (v60 != v61 && *v60 == v58)
    v66 = v60[1];
  else
LABEL_50:
    v66 = 0;
  v273[0] = v56;
  v273[1] = v66;
  ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v273);
  v69 = v67;
  v311 = (mlir::Operation *)v313;
  v312 = 0x400000000;
  v70 = 8 * v67;
  if ((unint64_t)(8 * v67) < 0x21)
  {
    v71 = 0;
    v72 = (mlir::Operation *)v313;
    if (!v69)
      goto LABEL_56;
    goto LABEL_55;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v311, v313, (8 * v67) >> 3, 8);
  v71 = v312;
  v72 = v311;
  if (v69)
  {
LABEL_55:
    memcpy((char *)v72 + 8 * v71, ArgAttrsAttr, v70);
    v71 = v312;
    v72 = v311;
  }
LABEL_56:
  v73 = v71 + (v70 >> 3);
  LODWORD(v312) = v73;
  if (v73 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v311, (uint64_t)v72, 4 - v73, 1uLL);
    v72 = v311;
  }
  v74 = *((_QWORD *)v72 + v38);
  v268 = v39;
  v75 = *((_QWORD *)v72 + v39);
  v308 = v310;
  v310[0] = v74;
  v310[1] = v75;
  v309 = 0x200000002;
  ResizeLayout = mlir::mps::getResizeLayout(v276, v72);
  if ((ResizeLayout & 0xFF00000000) != 0)
  {
    v265 = ResizeLayout;
    if (ResizeLayout == 1)
    {
      v292[0] = &v293;
      *(_QWORD *)&v293 = v37;
      *((_QWORD *)&v293 + 1) = v38;
      *(_QWORD *)&v294 = v38;
      *((_QWORD *)&v294 + 1) = v39;
      *(_QWORD *)&v295 = v39;
      *((_QWORD *)&v295 + 1) = v37;
      v292[1] = (void *)0x600000006;
      *(_OWORD *)v286 = xmmword_1812464A0;
      v77 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
      v78 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 2, v77, 0);
      v79 = v78;
      if (v78)
      {
        v80 = v9;
        v81 = *v78;
        v82 = mlir::TypeID::get<mlir::ShapedType>();
        v83 = *(unsigned int *)(v81 + 16);
        if ((_DWORD)v83)
        {
          v84 = *(_QWORD **)(v81 + 8);
          v85 = &v84[2 * v83];
          do
          {
            v86 = v83 >> 1;
            v87 = &v84[2 * (v83 >> 1)];
            v89 = *v87;
            v88 = v87 + 2;
            v83 += ~(v83 >> 1);
            if (v89 < v82)
              v84 = v88;
            else
              v83 = v86;
          }
          while (v83);
          v9 = v80;
          if (v84 == v85)
            v90 = 0;
          else
            v90 = *v84 == v82 ? v84[1] : 0;
        }
        else
        {
          v90 = 0;
          v9 = v80;
        }
      }
      else
      {
        v90 = 0;
      }
      v305 = (_QWORD *)mlir::DenseElementsAttr::getFromRawBuffer(v79, v90, v292[0], 8 * LODWORD(v292[1]), 8, 1, 0);
      v275 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v9, &v275, (uint64_t *)&v305)- 16;
      v96 = v311;
      v97 = v308;
      *v308 = *((_QWORD *)v311 + v37);
      v97[1] = *((_QWORD *)v96 + v38);
      if (v292[0] != &v293)
        free(v292[0]);
    }
    v286[0] = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v276);
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v286);
    if (DefiningOp
      && (v99 = DefiningOp,
          v100 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          (*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v99 + 48) + 32))(*(_QWORD *)(v99 + 48), v100)))
    {
      v263 = v38;
      v292[0] = &v293;
      v292[1] = (void *)0x100000000;
      mlir::Operation::fold(v99, 0, 0, (uint64_t)v292);
      v101 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v292[0] & 0xFFFFFFFFFFFFFFF8));
      if (v292[0] != &v293)
        free(v292[0]);
      v95 = v269;
      if (v101)
      {
        v262 = v9;
        v305 = v307;
        v307[0] = 0;
        v307[1] = 0;
        v306 = 0x200000002;
        v302 = v304;
        memset_pattern16(v304, &unk_181233190, 0x10uLL);
        v303 = 0x200000002;
        GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v276);
        v292[0] = (void *)2;
        v264 = (mlir::Builder *)(a4 + 1);
        v103 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
        v104 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v292, 1, v103, 0);
        v105 = v104;
        if (v104)
        {
          v106 = *v104;
          v107 = mlir::TypeID::get<mlir::ShapedType>();
          v108 = *(unsigned int *)(v106 + 16);
          if ((_DWORD)v108)
          {
            v109 = *(_QWORD **)(v106 + 8);
            v110 = &v109[2 * v108];
            do
            {
              v111 = v108 >> 1;
              v112 = &v109[2 * (v108 >> 1)];
              v114 = *v112;
              v113 = v112 + 2;
              v108 += ~(v108 >> 1);
              if (v114 < v107)
                v109 = v113;
              else
                v108 = v111;
            }
            while (v108);
            v95 = v269;
            if (v109 == v110 || *v109 != v107)
              goto LABEL_95;
            v115 = v109[1];
          }
          else
          {
            v115 = 0;
            v95 = v269;
          }
LABEL_114:
          if (GateLayout == 1)
            v121 = (void **)&v305;
          else
            v121 = &v302;
          v122 = *v121;
          v123 = &v306;
          if (GateLayout != 1)
            v123 = &v303;
          v272 = mlir::DenseElementsAttr::getFromRawBuffer(v105, v115, v122, 8 * *(unsigned int *)v123, 8, 1, 0);
          __dst = v301;
          v300 = 0x200000000;
          InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v276);
          IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v276);
          if (!mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v276)
            && !mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v276))
          {
            goto LABEL_222;
          }
          v296 = v283;
          v297 = *(_OWORD *)v284;
          *(_QWORD *)v298 = *(_QWORD *)&v284[16];
          *(_OWORD *)v292 = v279;
          v293 = v280;
          v294 = v281;
          v295 = v282;
          v277[0] = v276;
          v127 = mlir::mps::getResizeLayout(v276, v126);
          if ((v127 & 0xFF00000000) == 0)
            goto LABEL_208;
          v128 = 8 * (int)v127;
          v129 = *(_QWORD *)((char *)&unk_181246668 + v128);
          v130 = *(_QWORD *)((char *)&unk_1812466A0 + v128);
          v131 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 2u);
          v132 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v131;
          if ((_DWORD)v131)
          {
            v132 = (void *)mlir::ValueRange::offset_base(v286, v131);
            v133 = v286[1];
          }
          else
          {
            v133 = 0;
          }
          if ((void *)(HIDWORD(v131) + v131) == v133
            || (v286[0] = v132, v286[1] = 0, !mlir::ValueRange::dereference_iterator(v286, 0)))
          {
            v137 = 1.0;
            v138 = 1.0;
          }
          else
          {
            v134 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 2u);
            v135 = (void *)*((_QWORD *)&v297 + 1);
            v286[0] = *((void **)&v297 + 1);
            v286[1] = (void *)v134;
            if ((_DWORD)v134)
            {
              v135 = (void *)mlir::ValueRange::offset_base(v286, v134);
              v136 = v286[1];
            }
            else
            {
              v136 = 0;
            }
            if ((void *)(HIDWORD(v134) + v134) == v136)
            {
              v160 = 0;
            }
            else
            {
              v286[0] = v135;
              v286[1] = 0;
              v160 = mlir::ValueRange::dereference_iterator(v286, 0);
            }
            v285[0] = v160;
            v161 = mlir::Value::getDefiningOp((mlir::Value *)v285);
            if (!v161)
              goto LABEL_208;
            v162 = v161;
            v163 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v162 + 48) + 32))(*(_QWORD *)(v162 + 48), v163))goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x100000000;
            mlir::Operation::fold(v162, 0, 0, (uint64_t)v286);
            v164 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v286[0] & 0xFFFFFFFFFFFFFFF8));
            v166 = v165;
            if (v286[0] != &v287)
              free(v286[0]);
            v95 = v269;
            if (!v164)
              goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x400000000;
            mlir::getIntValues<float>((uint64_t)v164, v166, (uint64_t)v286, 1);
            v167 = LODWORD(v286[1]);
            v137 = 1.0;
            v138 = 1.0;
            if (v129 < LODWORD(v286[1]))
            {
              v138 = *((float *)v286[0] + v129);
              v137 = *((float *)v286[0] + v130);
            }
            if (v286[0] != &v287)
              free(v286[0]);
            if (v129 >= v167)
              goto LABEL_208;
          }
          v139 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 3u);
          v140 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v139;
          if ((_DWORD)v139)
          {
            v140 = (void *)mlir::ValueRange::offset_base(v286, v139);
            v141 = v286[1];
          }
          else
          {
            v141 = 0;
          }
          if ((void *)(HIDWORD(v139) + v139) == v141
            || (v286[0] = v140, v286[1] = 0, !mlir::ValueRange::dereference_iterator(v286, 0)))
          {
            v145 = 0.0;
            v146 = 0.0;
          }
          else
          {
            v142 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 3u);
            v143 = (void *)*((_QWORD *)&v297 + 1);
            v286[0] = *((void **)&v297 + 1);
            v286[1] = (void *)v142;
            if ((_DWORD)v142)
            {
              v143 = (void *)mlir::ValueRange::offset_base(v286, v142);
              v144 = v286[1];
            }
            else
            {
              v144 = 0;
            }
            if ((void *)(HIDWORD(v142) + v142) == v144)
            {
              v168 = 0;
            }
            else
            {
              v286[0] = v143;
              v286[1] = 0;
              v168 = mlir::ValueRange::dereference_iterator(v286, 0);
            }
            v285[0] = v168;
            v169 = mlir::Value::getDefiningOp((mlir::Value *)v285);
            if (!v169)
              goto LABEL_208;
            v170 = v169;
            v171 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v170 + 48) + 32))(*(_QWORD *)(v170 + 48), v171))goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x100000000;
            mlir::Operation::fold(v170, 0, 0, (uint64_t)v286);
            v172 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v286[0] & 0xFFFFFFFFFFFFFFF8));
            v174 = v173;
            if (v286[0] != &v287)
              free(v286[0]);
            v95 = v269;
            if (!v172)
              goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x400000000;
            mlir::getIntValues<float>((uint64_t)v172, v174, (uint64_t)v286, 1);
            v175 = LODWORD(v286[1]);
            v145 = 0.0;
            v146 = 0.0;
            if (v129 < LODWORD(v286[1]))
            {
              v146 = *((float *)v286[0] + v129);
              v145 = *((float *)v286[0] + v130);
            }
            if (v286[0] != &v287)
              free(v286[0]);
            if (v129 >= v175)
              goto LABEL_208;
          }
          v147 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 0);
          v148 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v147;
          if (v147)
            v148 = (void *)mlir::ValueRange::offset_base(v286, v147);
          v286[0] = v148;
          v286[1] = 0;
          v149 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v286, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v149)
            goto LABEL_149;
          v150 = *v149;
          v151 = mlir::TypeID::get<mlir::ShapedType>();
          v152 = *(unsigned int *)(v150 + 16);
          if ((_DWORD)v152)
          {
            v153 = *(_QWORD **)(v150 + 8);
            v154 = &v153[2 * v152];
            do
            {
              v155 = v152 >> 1;
              v156 = &v153[2 * (v152 >> 1)];
              v158 = *v156;
              v157 = v156 + 2;
              v152 += ~(v152 >> 1);
              if (v158 < v151)
                v153 = v157;
              else
                v152 = v155;
            }
            while (v152);
            v95 = v269;
            if (v153 == v154 || *v153 != v151)
            {
LABEL_149:
              v159 = 0;
              goto LABEL_182;
            }
            v159 = (void *)v153[1];
          }
          else
          {
            v159 = 0;
            v95 = v269;
          }
LABEL_182:
          v286[0] = v149;
          v286[1] = v159;
          v176 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v286);
          v178 = v177;
          v179 = *(_QWORD *)(a1 + 96);
          v180 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v277);
          v181 = (uint64_t *)mlir::TypeConverter::convertType(v179, (void *)(*(_QWORD *)(v180 + 8) & 0xFFFFFFFFFFFFFFF8));
          v182 = v181;
          if (v181)
          {
            v183 = *v181;
            v184 = mlir::TypeID::get<mlir::ShapedType>();
            v185 = *(unsigned int *)(v183 + 16);
            if ((_DWORD)v185)
            {
              v186 = *(_QWORD **)(v183 + 8);
              v187 = &v186[2 * v185];
              do
              {
                v188 = v185 >> 1;
                v189 = &v186[2 * (v185 >> 1)];
                v191 = *v189;
                v190 = v189 + 2;
                v185 += ~(v185 >> 1);
                if (v191 < v184)
                  v186 = v190;
                else
                  v185 = v188;
              }
              while (v185);
              v95 = v269;
              if (v186 == v187 || *v186 != v184)
                goto LABEL_191;
              v192 = (void *)v186[1];
            }
            else
            {
              v192 = 0;
              v95 = v269;
            }
LABEL_194:
            v286[0] = v182;
            v286[1] = v192;
            v193 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v286);
            v195 = v194;
            v196 = mlir::anec::getIndexFromDim(3, v178);
            v197 = mlir::anec::getIndexFromDim(4, v195);
            v198 = (float)*(uint64_t *)(v176 + 8 * v196);
            v199 = (float)*(uint64_t *)(v176 + 8 * v197);
            v200 = (float)*(uint64_t *)(v193 + 8 * v196);
            v201 = (float)*(uint64_t *)(v193 + 8 * v197);
            v202 = v146 != 0.0;
            if (v145 != 0.0)
              v202 = 1;
            v203 = (v138 + -1.0) * 0.5 != v146 || (v137 + -1.0) * 0.5 != v145;
            v204 = v138 != (float)(v200 / v198) || v137 != (float)(v201 / v199);
            v205 = v138 != (float)((float)(v200 + -1.0) / (float)(v198 + -1.0))
                || v137 != (float)((float)(v201 + -1.0) / (float)(v199 + -1.0));
            if (v202 || v204)
            {
              if (v202 || v205)
              {
                if (v203 || v204)
                {
LABEL_208:
                  v206 = a4[2];
                  if (!v206)
                    goto LABEL_212;
                  v207 = v276;
                  if (!mlir::RewriterBase::Listener::classof(a4[2]))
                    goto LABEL_212;
                  v208 = *((_QWORD *)v207 + 3);
LABEL_211:
                  (*(void (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v206 + 64))(v206, v208, v209, v286);
LABEL_212:
                  v93 = 0;
                  v94 = 0;
LABEL_213:
                  if (__dst != v301)
                    free(__dst);
                  if (v302 != v304)
                    free(v302);
                  if (v305 != v307)
                    free(v305);
                  goto LABEL_101;
                }
                InferredResultTypes = 0;
                IsSize = 1;
              }
              else
              {
                IsSize = 1;
                InferredResultTypes = 1;
              }
            }
            else
            {
              IsSize = 0;
              InferredResultTypes = 0;
            }
LABEL_222:
            if (InferredResultTypes && IsSize)
            {
              v286[0] = &v287;
              v287 = 0uLL;
            }
            else
            {
              if (InferredResultTypes || IsSize)
              {
                if (InferredResultTypes || !IsSize)
                {
                  v206 = a4[2];
                  if (!v206)
                    goto LABEL_212;
                  v212 = v276;
                  if (!mlir::RewriterBase::Listener::classof(a4[2]))
                    goto LABEL_212;
                  v208 = *((_QWORD *)v212 + 3);
                  goto LABEL_211;
                }
                v286[0] = &v287;
                v210 = &unk_181233190;
              }
              else
              {
                v286[0] = &v287;
                v210 = &unk_181246500;
              }
              memset_pattern16(&v287, v210, 0x10uLL);
            }
            v286[1] = (void *)0x600000002;
            v211 = v300;
            if (v300 >= 2)
            {
              *(_OWORD *)__dst = v287;
            }
            else
            {
              if (HIDWORD(v300) > 1)
              {
                if ((_DWORD)v300)
                  memmove(__dst, &v287, 8 * v300);
                else
                  v211 = 0;
              }
              else
              {
                LODWORD(v300) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v301, 2uLL, 8);
                v211 = 0;
              }
              if (v211 != LODWORD(v286[1]))
                memcpy((char *)__dst + 8 * v211, (char *)v286[0] + 8 * v211, 8 * LODWORD(v286[1]) - 8 * v211);
            }
            LODWORD(v300) = 2;
            LODWORD(v286[1]) = 0;
            if (v286[0] != &v287)
              free(v286[0]);
            v286[0] = (void *)2;
            v213 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
            v214 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 1, v213, 0);
            v215 = v214;
            if (!v214)
              goto LABEL_254;
            v216 = *v214;
            v217 = mlir::TypeID::get<mlir::ShapedType>();
            v218 = *(unsigned int *)(v216 + 16);
            if (!(_DWORD)v218)
              goto LABEL_254;
            v219 = *(_QWORD **)(v216 + 8);
            v220 = &v219[2 * v218];
            do
            {
              v221 = v218 >> 1;
              v222 = &v219[2 * (v218 >> 1)];
              v224 = *v222;
              v223 = v222 + 2;
              v218 += ~(v218 >> 1);
              if (v224 < v217)
                v219 = v223;
              else
                v218 = v221;
            }
            while (v218);
            if (v219 != v220 && *v219 == v217)
              v225 = v219[1];
            else
LABEL_254:
              v225 = 0;
            v271 = mlir::DenseElementsAttr::getFromRawBuffer(v215, v225, __dst, 8 * v300, 8, 1, 0);
            v226 = v308;
            v267 = v308 + 1;
            v227 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v285, -1.0);
            v228 = llvm::APFloatBase::IEEEsingle(v227);
            llvm::APFloat::Storage::Storage(&v286[1], v285, v228);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v285);
            llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v277, -1.0);
            llvm::APFloat::Storage::Storage(&v285[1], v277, v228);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v277);
            v277[0] = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v264, v262, &v275, v226, v267, (uint64_t)v286, (uint64_t)v285, &v272, &v271);
            v229 = (void *)v285[1];
            v230 = llvm::APFloatBase::PPCDoubleDouble(v277[0]);
            if (v230 == v229)
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v285[1]);
            else
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v285[1]);
            v231 = v263;
            if (v230 == v286[1])
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v286[1]);
            else
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v286[1]);
            v232 = mlir::anec::Resize::verifyAttributesWithFamily((uint64_t *)v277, 5);
            v93 = v277[0];
            if (!v232)
            {
              mlir::ConversionPatternRewriter::eraseOp((mlir::ConversionPatternRewriter *)a4, v277[0]);
              v286[0] = "requested attributes are not compatible with hardware requirements";
              LOWORD(v288) = 259;
              v246 = v276;
              v285[0] = (uint64_t)v286;
              v247 = a4[2];
              if (v247 && mlir::RewriterBase::Listener::classof(a4[2]))
                (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v247 + 64))(v247, *((_QWORD *)v246 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v285);
              v93 = 0;
              v94 = 0;
              v95 = v269;
              goto LABEL_213;
            }
            if (v265 != 1)
            {
LABEL_282:
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v274);
              if (v248 > 3)
              {
                v94 = 1;
                v95 = v269;
              }
              else
              {
                v286[0] = &v287;
                *(_QWORD *)&v287 = v37;
                *((_QWORD *)&v287 + 1) = IndexFromDim;
                v288 = v231;
                v289 = v37;
                v290 = IndexFromDim;
                v291 = v231;
                v286[1] = (void *)0x600000006;
                *(_OWORD *)v285 = xmmword_1812464A0;
                v249 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
                v250 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v285, 2, v249, 0);
                v251 = v250;
                if (v250
                  && (v252 = *v250,
                      v253 = mlir::TypeID::get<mlir::ShapedType>(),
                      v254 = *(unsigned int *)(v252 + 16),
                      (_DWORD)v254))
                {
                  v255 = *(_QWORD **)(v252 + 8);
                  v256 = &v255[2 * v254];
                  do
                  {
                    v257 = v254 >> 1;
                    v258 = &v255[2 * (v254 >> 1)];
                    v260 = *v258;
                    v259 = v258 + 2;
                    v254 += ~(v254 >> 1);
                    if (v260 < v253)
                      v255 = v259;
                    else
                      v254 = v257;
                  }
                  while (v254);
                  v95 = v269;
                  if (v255 != v256 && *v255 == v253)
                    v261 = v255[1];
                  else
                    v261 = 0;
                }
                else
                {
                  v261 = 0;
                  v95 = v269;
                }
                v270 = mlir::DenseElementsAttr::getFromRawBuffer(v251, v261, v286[0], 8 * LODWORD(v286[1]), 8, 1, 0);
                v285[0] = (uint64_t)v93 - 16;
                v93 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v264, v262, v285, &v270);
                if (v286[0] != &v287)
                  free(v286[0]);
                v94 = 1;
              }
              goto LABEL_213;
            }
            v286[0] = &v287;
            *(_QWORD *)&v287 = v37;
            *((_QWORD *)&v287 + 1) = v268;
            v288 = v263;
            v289 = v37;
            v290 = v268;
            v291 = v263;
            v286[1] = (void *)0x600000006;
            *(_OWORD *)v285 = xmmword_1812464A0;
            v233 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
            v234 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v285, 2, v233, 0);
            v235 = v234;
            if (!v234)
              goto LABEL_272;
            v236 = *v234;
            v237 = mlir::TypeID::get<mlir::ShapedType>();
            v238 = *(unsigned int *)(v236 + 16);
            if ((_DWORD)v238)
            {
              v239 = *(_QWORD **)(v236 + 8);
              v240 = &v239[2 * v238];
              do
              {
                v241 = v238 >> 1;
                v242 = &v239[2 * (v238 >> 1)];
                v244 = *v242;
                v243 = v242 + 2;
                v238 += ~(v238 >> 1);
                if (v244 < v237)
                  v239 = v243;
                else
                  v238 = v241;
              }
              while (v238);
              v231 = v263;
              if (v239 == v240 || *v239 != v237)
              {
LABEL_272:
                v245 = 0;
                goto LABEL_280;
              }
              v245 = v239[1];
            }
            else
            {
              v245 = 0;
              v231 = v263;
            }
LABEL_280:
            v270 = mlir::DenseElementsAttr::getFromRawBuffer(v235, v245, v286[0], 8 * LODWORD(v286[1]), 8, 1, 0);
            v93 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v264, v262, v277, &v270);
            if (v286[0] != &v287)
              free(v286[0]);
            goto LABEL_282;
          }
LABEL_191:
          v192 = 0;
          goto LABEL_194;
        }
LABEL_95:
        v115 = 0;
        goto LABEL_114;
      }
    }
    else
    {
      v95 = v269;
    }
    v292[0] = "Shape operand was not a constant";
    LOWORD(v294) = 259;
    v116 = v276;
    v286[0] = v292;
    v117 = a4[2];
    if (v117 && mlir::RewriterBase::Listener::classof(a4[2]))
      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v117 + 64))(v117, *((_QWORD *)v116 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    v93 = 0;
    v94 = 0;
  }
  else
  {
    v292[0] = "Resize layout not supported";
    LOWORD(v294) = 259;
    v91 = v276;
    v286[0] = v292;
    v92 = a4[2];
    if (v92 && mlir::RewriterBase::Listener::classof(a4[2]))
      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v92 + 64))(v92, *((_QWORD *)v91 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    v93 = 0;
    v94 = 0;
    v95 = v269;
  }
LABEL_101:
  if (v308 != v310)
    free(v308);
  if (v311 != (mlir::Operation *)v313)
    free(v311);
  if (v94)
  {
    v292[0] = (char *)v93 - 16;
    v118 = 1;
    mlir::ValueRange::ValueRange(v278, (uint64_t)v292, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)v95, v278[0], v278[1]);
  }
  else
  {
    v292[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v294) = 259;
    v286[0] = v292;
    v119 = a4[2];
    if (v119 && mlir::RewriterBase::Listener::classof(v119))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v119 + 64))(v119, *((_QWORD *)v95 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    else
      return 0;
  }
  return v118;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)5>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)5>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

_QWORD *mlir::`anonymous namespace'::ConvertResize<(mlir::anec::Family)6>::~ConvertResize(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertResize<(mlir::anec::Family)6>::~ConvertResize(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::mps *a2, __int128 *a3, uint64_t *a4)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int ODSOperandIndexAndLength;
  void *v22;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  unint64_t v29;
  unint64_t *v30;
  _QWORD *v31;
  unint64_t v32;
  void *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t IndexFromDim;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t IntegerType;
  _QWORD *v42;
  _QWORD *v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  _QWORD *v49;
  _QWORD *v50;
  unint64_t v51;
  unint64_t *v52;
  _QWORD *v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const void *ArgAttrsAttr;
  uint64_t v69;
  size_t v70;
  unsigned int v71;
  mlir::Operation *v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t ResizeLayout;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  _QWORD *v84;
  _QWORD *v85;
  unint64_t v86;
  unint64_t *v87;
  _QWORD *v88;
  unint64_t v89;
  uint64_t v90;
  mlir::mps *v91;
  uint64_t v92;
  mlir::GenericProgramPoint *v93;
  int v94;
  mlir::mps *v95;
  mlir::Operation *v96;
  uint64_t *v97;
  uint64_t DefiningOp;
  uint64_t v99;
  uint64_t v100;
  uint64_t *v101;
  int GateLayout;
  uint64_t v103;
  _QWORD *v104;
  _QWORD *v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  _QWORD *v109;
  _QWORD *v110;
  unint64_t v111;
  unint64_t *v112;
  _QWORD *v113;
  unint64_t v114;
  uint64_t v115;
  mlir::mps *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  void **v121;
  void *v122;
  uint64_t *v123;
  _BOOL4 InferredResultTypes;
  _BOOL4 IsSize;
  mlir::Operation *v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  void *v132;
  void *v133;
  unint64_t v134;
  void *v135;
  void *v136;
  float v137;
  float v138;
  unint64_t v139;
  void *v140;
  void *v141;
  unint64_t v142;
  void *v143;
  void *v144;
  float v145;
  float v146;
  unsigned int v147;
  void *v148;
  uint64_t *v149;
  uint64_t v150;
  unint64_t v151;
  unint64_t v152;
  _QWORD *v153;
  _QWORD *v154;
  unint64_t v155;
  unint64_t *v156;
  _QWORD *v157;
  unint64_t v158;
  void *v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t *v164;
  uint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t *v172;
  uint64_t v173;
  uint64_t v174;
  unint64_t v175;
  uint64_t v176;
  unint64_t v177;
  unint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t *v181;
  uint64_t *v182;
  uint64_t v183;
  unint64_t v184;
  unint64_t v185;
  _QWORD *v186;
  _QWORD *v187;
  unint64_t v188;
  unint64_t *v189;
  _QWORD *v190;
  unint64_t v191;
  void *v192;
  uint64_t v193;
  unint64_t v194;
  unint64_t v195;
  unint64_t v196;
  unint64_t v197;
  float v198;
  float v199;
  float v200;
  float v201;
  _BOOL4 v202;
  _BOOL4 v203;
  _BOOL4 v204;
  _BOOL4 v205;
  uint64_t v206;
  mlir::mps *v207;
  uint64_t v208;
  uint64_t (*v209)(int, uint64_t);
  const void *v210;
  uint64_t v211;
  mlir::mps *v212;
  uint64_t v213;
  _QWORD *v214;
  _QWORD *v215;
  uint64_t v216;
  unint64_t v217;
  unint64_t v218;
  _QWORD *v219;
  _QWORD *v220;
  unint64_t v221;
  unint64_t *v222;
  _QWORD *v223;
  unint64_t v224;
  uint64_t v225;
  uint64_t *v226;
  llvm::APFloatBase *v227;
  void *v228;
  void *v229;
  void *v230;
  unint64_t v231;
  char v232;
  uint64_t v233;
  _QWORD *v234;
  _QWORD *v235;
  uint64_t v236;
  unint64_t v237;
  unint64_t v238;
  _QWORD *v239;
  _QWORD *v240;
  unint64_t v241;
  unint64_t *v242;
  _QWORD *v243;
  unint64_t v244;
  uint64_t v245;
  mlir::mps *v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  _QWORD *v250;
  _QWORD *v251;
  uint64_t v252;
  unint64_t v253;
  unint64_t v254;
  _QWORD *v255;
  _QWORD *v256;
  unint64_t v257;
  unint64_t *v258;
  _QWORD *v259;
  unint64_t v260;
  uint64_t v261;
  uint64_t v262;
  unint64_t v263;
  mlir::Builder *v264;
  uint64_t v265;
  uint64_t *v267;
  unint64_t v268;
  mlir::mps *v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  _QWORD v273[2];
  _QWORD v274[2];
  uint64_t v275;
  mlir::mps *v276;
  mlir::Operation *v277[3];
  unint64_t v278[2];
  __int128 v279;
  __int128 v280;
  __int128 v281;
  __int128 v282;
  __int128 v283;
  _BYTE v284[24];
  uint64_t v285[4];
  void *v286[2];
  __int128 v287;
  unint64_t v288;
  unint64_t v289;
  unint64_t v290;
  unint64_t v291;
  void *v292[2];
  __int128 v293;
  __int128 v294;
  __int128 v295;
  __int128 v296;
  __int128 v297;
  unsigned int v298[2];
  void *__dst;
  uint64_t v300;
  _BYTE v301[16];
  void *v302;
  uint64_t v303;
  _BYTE v304[16];
  _QWORD *v305;
  uint64_t v306;
  _QWORD v307[2];
  uint64_t *v308;
  uint64_t v309;
  _QWORD v310[2];
  mlir::Operation *v311;
  uint64_t v312;
  _BYTE v313[32];
  __int128 v314;
  uint64_t v315;

  v315 = *MEMORY[0x1E0C80C00];
  v6 = a3[5];
  v283 = a3[4];
  *(_OWORD *)v284 = v6;
  *(_QWORD *)&v284[16] = *((_QWORD *)a3 + 12);
  v7 = a3[1];
  v279 = *a3;
  v280 = v7;
  v8 = a3[3];
  v281 = a3[2];
  v282 = v8;
  v276 = a2;
  v314 = *(_OWORD *)&v284[8];
  v9 = *((_QWORD *)a2 + 3);
  v275 = mlir::ValueRange::dereference_iterator(&v314, 0);
  v10 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v276) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_10;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_10;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_10:
    v20 = 0;
  v274[0] = v10;
  v274[1] = v20;
  ODSOperandIndexAndLength = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)&v279, 0);
  v22 = *(void **)&v284[8];
  v292[0] = *(void **)&v284[8];
  v292[1] = (void *)ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v22 = (void *)mlir::ValueRange::offset_base(v292, ODSOperandIndexAndLength);
  v292[0] = v22;
  v292[1] = 0;
  v23 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v292, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  v269 = a2;
  if (!v23)
    goto LABEL_22;
  v24 = *v23;
  v25 = mlir::TypeID::get<mlir::ShapedType>();
  v26 = *(unsigned int *)(v24 + 16);
  if (!(_DWORD)v26)
    goto LABEL_22;
  v27 = *(_QWORD **)(v24 + 8);
  v28 = &v27[2 * v26];
  do
  {
    v29 = v26 >> 1;
    v30 = &v27[2 * (v26 >> 1)];
    v32 = *v30;
    v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25)
      v27 = v31;
    else
      v26 = v29;
  }
  while (v26);
  if (v27 != v28 && *v27 == v25)
    v33 = (void *)v27[1];
  else
LABEL_22:
    v33 = 0;
  v292[0] = v23;
  v292[1] = v33;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v292);
  v35 = v34;
  IndexFromDim = mlir::anec::getIndexFromDim(0, v34);
  v37 = mlir::anec::getIndexFromDim(1, v35);
  v38 = mlir::anec::getIndexFromDim(3, v35);
  v39 = mlir::anec::getIndexFromDim(4, v35);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v274);
  if (v40 <= 3)
  {
    v292[0] = &v293;
    *(_QWORD *)&v293 = IndexFromDim;
    *((_QWORD *)&v293 + 1) = v37;
    *(_QWORD *)&v294 = v37;
    *((_QWORD *)&v294 + 1) = v38;
    *(_QWORD *)&v295 = v38;
    *((_QWORD *)&v295 + 1) = IndexFromDim;
    v292[1] = (void *)0x600000006;
    *(_OWORD *)v286 = xmmword_1812464A0;
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    v42 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 2, IntegerType, 0);
    v43 = v42;
    if (v42)
    {
      v44 = v39;
      v45 = v9;
      v46 = *v42;
      v47 = mlir::TypeID::get<mlir::ShapedType>();
      v48 = *(unsigned int *)(v46 + 16);
      if ((_DWORD)v48)
      {
        v49 = *(_QWORD **)(v46 + 8);
        v50 = &v49[2 * v48];
        do
        {
          v51 = v48 >> 1;
          v52 = &v49[2 * (v48 >> 1)];
          v54 = *v52;
          v53 = v52 + 2;
          v48 += ~(v48 >> 1);
          if (v54 < v47)
            v49 = v53;
          else
            v48 = v51;
        }
        while (v48);
        v9 = v45;
        if (v49 == v50)
        {
          v55 = 0;
          v39 = v44;
        }
        else
        {
          v39 = v44;
          if (*v49 != v47)
            goto LABEL_33;
          v55 = v49[1];
        }
      }
      else
      {
        v55 = 0;
        v9 = v45;
        v39 = v44;
      }
LABEL_39:
      v311 = (mlir::Operation *)mlir::DenseElementsAttr::getFromRawBuffer(v43, v55, v292[0], 8 * LODWORD(v292[1]), 8, 1, 0);
      v275 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v9, &v275, (uint64_t *)&v311)- 16;
      if (v292[0] != &v293)
        free(v292[0]);
      goto LABEL_41;
    }
LABEL_33:
    v55 = 0;
    goto LABEL_39;
  }
LABEL_41:
  v56 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v276) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v56)
    goto LABEL_50;
  v57 = *v56;
  v58 = mlir::TypeID::get<mlir::ShapedType>();
  v59 = *(unsigned int *)(v57 + 16);
  if (!(_DWORD)v59)
    goto LABEL_50;
  v60 = *(_QWORD **)(v57 + 8);
  v61 = &v60[2 * v59];
  do
  {
    v62 = v59 >> 1;
    v63 = &v60[2 * (v59 >> 1)];
    v65 = *v63;
    v64 = v63 + 2;
    v59 += ~(v59 >> 1);
    if (v65 < v58)
      v60 = v64;
    else
      v59 = v62;
  }
  while (v59);
  if (v60 != v61 && *v60 == v58)
    v66 = v60[1];
  else
LABEL_50:
    v66 = 0;
  v273[0] = v56;
  v273[1] = v66;
  ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v273);
  v69 = v67;
  v311 = (mlir::Operation *)v313;
  v312 = 0x400000000;
  v70 = 8 * v67;
  if ((unint64_t)(8 * v67) < 0x21)
  {
    v71 = 0;
    v72 = (mlir::Operation *)v313;
    if (!v69)
      goto LABEL_56;
    goto LABEL_55;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v311, v313, (8 * v67) >> 3, 8);
  v71 = v312;
  v72 = v311;
  if (v69)
  {
LABEL_55:
    memcpy((char *)v72 + 8 * v71, ArgAttrsAttr, v70);
    v71 = v312;
    v72 = v311;
  }
LABEL_56:
  v73 = v71 + (v70 >> 3);
  LODWORD(v312) = v73;
  if (v73 <= 3)
  {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v311, (uint64_t)v72, 4 - v73, 1uLL);
    v72 = v311;
  }
  v74 = *((_QWORD *)v72 + v38);
  v268 = v39;
  v75 = *((_QWORD *)v72 + v39);
  v308 = v310;
  v310[0] = v74;
  v310[1] = v75;
  v309 = 0x200000002;
  ResizeLayout = mlir::mps::getResizeLayout(v276, v72);
  if ((ResizeLayout & 0xFF00000000) != 0)
  {
    v265 = ResizeLayout;
    if (ResizeLayout == 1)
    {
      v292[0] = &v293;
      *(_QWORD *)&v293 = v37;
      *((_QWORD *)&v293 + 1) = v38;
      *(_QWORD *)&v294 = v38;
      *((_QWORD *)&v294 + 1) = v39;
      *(_QWORD *)&v295 = v39;
      *((_QWORD *)&v295 + 1) = v37;
      v292[1] = (void *)0x600000006;
      *(_OWORD *)v286 = xmmword_1812464A0;
      v77 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
      v78 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 2, v77, 0);
      v79 = v78;
      if (v78)
      {
        v80 = v9;
        v81 = *v78;
        v82 = mlir::TypeID::get<mlir::ShapedType>();
        v83 = *(unsigned int *)(v81 + 16);
        if ((_DWORD)v83)
        {
          v84 = *(_QWORD **)(v81 + 8);
          v85 = &v84[2 * v83];
          do
          {
            v86 = v83 >> 1;
            v87 = &v84[2 * (v83 >> 1)];
            v89 = *v87;
            v88 = v87 + 2;
            v83 += ~(v83 >> 1);
            if (v89 < v82)
              v84 = v88;
            else
              v83 = v86;
          }
          while (v83);
          v9 = v80;
          if (v84 == v85)
            v90 = 0;
          else
            v90 = *v84 == v82 ? v84[1] : 0;
        }
        else
        {
          v90 = 0;
          v9 = v80;
        }
      }
      else
      {
        v90 = 0;
      }
      v305 = (_QWORD *)mlir::DenseElementsAttr::getFromRawBuffer(v79, v90, v292[0], 8 * LODWORD(v292[1]), 8, 1, 0);
      v275 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, v9, &v275, (uint64_t *)&v305)- 16;
      v96 = v311;
      v97 = v308;
      *v308 = *((_QWORD *)v311 + v37);
      v97[1] = *((_QWORD *)v96 + v38);
      if (v292[0] != &v293)
        free(v292[0]);
    }
    v286[0] = (void *)mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v276);
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v286);
    if (DefiningOp
      && (v99 = DefiningOp,
          v100 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          (*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v99 + 48) + 32))(*(_QWORD *)(v99 + 48), v100)))
    {
      v263 = v38;
      v292[0] = &v293;
      v292[1] = (void *)0x100000000;
      mlir::Operation::fold(v99, 0, 0, (uint64_t)v292);
      v101 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v292[0] & 0xFFFFFFFFFFFFFFF8));
      if (v292[0] != &v293)
        free(v292[0]);
      v95 = v269;
      if (v101)
      {
        v262 = v9;
        v305 = v307;
        v307[0] = 0;
        v307[1] = 0;
        v306 = 0x200000002;
        v302 = v304;
        memset_pattern16(v304, &unk_181233190, 0x10uLL);
        v303 = 0x200000002;
        GateLayout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v276);
        v292[0] = (void *)2;
        v264 = (mlir::Builder *)(a4 + 1);
        v103 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
        v104 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v292, 1, v103, 0);
        v105 = v104;
        if (v104)
        {
          v106 = *v104;
          v107 = mlir::TypeID::get<mlir::ShapedType>();
          v108 = *(unsigned int *)(v106 + 16);
          if ((_DWORD)v108)
          {
            v109 = *(_QWORD **)(v106 + 8);
            v110 = &v109[2 * v108];
            do
            {
              v111 = v108 >> 1;
              v112 = &v109[2 * (v108 >> 1)];
              v114 = *v112;
              v113 = v112 + 2;
              v108 += ~(v108 >> 1);
              if (v114 < v107)
                v109 = v113;
              else
                v108 = v111;
            }
            while (v108);
            v95 = v269;
            if (v109 == v110 || *v109 != v107)
              goto LABEL_95;
            v115 = v109[1];
          }
          else
          {
            v115 = 0;
            v95 = v269;
          }
LABEL_114:
          if (GateLayout == 1)
            v121 = (void **)&v305;
          else
            v121 = &v302;
          v122 = *v121;
          v123 = &v306;
          if (GateLayout != 1)
            v123 = &v303;
          v272 = mlir::DenseElementsAttr::getFromRawBuffer(v105, v115, v122, 8 * *(unsigned int *)v123, 8, 1, 0);
          __dst = v301;
          v300 = 0x200000000;
          InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v276);
          IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v276);
          if (!mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v276)
            && !mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v276))
          {
            goto LABEL_222;
          }
          v296 = v283;
          v297 = *(_OWORD *)v284;
          *(_QWORD *)v298 = *(_QWORD *)&v284[16];
          *(_OWORD *)v292 = v279;
          v293 = v280;
          v294 = v281;
          v295 = v282;
          v277[0] = v276;
          v127 = mlir::mps::getResizeLayout(v276, v126);
          if ((v127 & 0xFF00000000) == 0)
            goto LABEL_208;
          v128 = 8 * (int)v127;
          v129 = *(_QWORD *)((char *)&unk_181246668 + v128);
          v130 = *(_QWORD *)((char *)&unk_1812466A0 + v128);
          v131 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 2u);
          v132 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v131;
          if ((_DWORD)v131)
          {
            v132 = (void *)mlir::ValueRange::offset_base(v286, v131);
            v133 = v286[1];
          }
          else
          {
            v133 = 0;
          }
          if ((void *)(HIDWORD(v131) + v131) == v133
            || (v286[0] = v132, v286[1] = 0, !mlir::ValueRange::dereference_iterator(v286, 0)))
          {
            v137 = 1.0;
            v138 = 1.0;
          }
          else
          {
            v134 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 2u);
            v135 = (void *)*((_QWORD *)&v297 + 1);
            v286[0] = *((void **)&v297 + 1);
            v286[1] = (void *)v134;
            if ((_DWORD)v134)
            {
              v135 = (void *)mlir::ValueRange::offset_base(v286, v134);
              v136 = v286[1];
            }
            else
            {
              v136 = 0;
            }
            if ((void *)(HIDWORD(v134) + v134) == v136)
            {
              v160 = 0;
            }
            else
            {
              v286[0] = v135;
              v286[1] = 0;
              v160 = mlir::ValueRange::dereference_iterator(v286, 0);
            }
            v285[0] = v160;
            v161 = mlir::Value::getDefiningOp((mlir::Value *)v285);
            if (!v161)
              goto LABEL_208;
            v162 = v161;
            v163 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v162 + 48) + 32))(*(_QWORD *)(v162 + 48), v163))goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x100000000;
            mlir::Operation::fold(v162, 0, 0, (uint64_t)v286);
            v164 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v286[0] & 0xFFFFFFFFFFFFFFF8));
            v166 = v165;
            if (v286[0] != &v287)
              free(v286[0]);
            v95 = v269;
            if (!v164)
              goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x400000000;
            mlir::getIntValues<float>((uint64_t)v164, v166, (uint64_t)v286, 1);
            v167 = LODWORD(v286[1]);
            v137 = 1.0;
            v138 = 1.0;
            if (v129 < LODWORD(v286[1]))
            {
              v138 = *((float *)v286[0] + v129);
              v137 = *((float *)v286[0] + v130);
            }
            if (v286[0] != &v287)
              free(v286[0]);
            if (v129 >= v167)
              goto LABEL_208;
          }
          v139 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 3u);
          v140 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v139;
          if ((_DWORD)v139)
          {
            v140 = (void *)mlir::ValueRange::offset_base(v286, v139);
            v141 = v286[1];
          }
          else
          {
            v141 = 0;
          }
          if ((void *)(HIDWORD(v139) + v139) == v141
            || (v286[0] = v140, v286[1] = 0, !mlir::ValueRange::dereference_iterator(v286, 0)))
          {
            v145 = 0.0;
            v146 = 0.0;
          }
          else
          {
            v142 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 3u);
            v143 = (void *)*((_QWORD *)&v297 + 1);
            v286[0] = *((void **)&v297 + 1);
            v286[1] = (void *)v142;
            if ((_DWORD)v142)
            {
              v143 = (void *)mlir::ValueRange::offset_base(v286, v142);
              v144 = v286[1];
            }
            else
            {
              v144 = 0;
            }
            if ((void *)(HIDWORD(v142) + v142) == v144)
            {
              v168 = 0;
            }
            else
            {
              v286[0] = v143;
              v286[1] = 0;
              v168 = mlir::ValueRange::dereference_iterator(v286, 0);
            }
            v285[0] = v168;
            v169 = mlir::Value::getDefiningOp((mlir::Value *)v285);
            if (!v169)
              goto LABEL_208;
            v170 = v169;
            v171 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
            if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v170 + 48) + 32))(*(_QWORD *)(v170 + 48), v171))goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x100000000;
            mlir::Operation::fold(v170, 0, 0, (uint64_t)v286);
            v172 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v286[0] & 0xFFFFFFFFFFFFFFF8));
            v174 = v173;
            if (v286[0] != &v287)
              free(v286[0]);
            v95 = v269;
            if (!v172)
              goto LABEL_208;
            v286[0] = &v287;
            v286[1] = (void *)0x400000000;
            mlir::getIntValues<float>((uint64_t)v172, v174, (uint64_t)v286, 1);
            v175 = LODWORD(v286[1]);
            v145 = 0.0;
            v146 = 0.0;
            if (v129 < LODWORD(v286[1]))
            {
              v146 = *((float *)v286[0] + v129);
              v145 = *((float *)v286[0] + v130);
            }
            if (v286[0] != &v287)
              free(v286[0]);
            if (v129 >= v175)
              goto LABEL_208;
          }
          v147 = mlir::mps::detail::ResizeOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::mps::detail::ResizeOpGenericAdaptorBase *)v292, 0);
          v148 = (void *)*((_QWORD *)&v297 + 1);
          v286[0] = *((void **)&v297 + 1);
          v286[1] = (void *)v147;
          if (v147)
            v148 = (void *)mlir::ValueRange::offset_base(v286, v147);
          v286[0] = v148;
          v286[1] = 0;
          v149 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(v286, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v149)
            goto LABEL_149;
          v150 = *v149;
          v151 = mlir::TypeID::get<mlir::ShapedType>();
          v152 = *(unsigned int *)(v150 + 16);
          if ((_DWORD)v152)
          {
            v153 = *(_QWORD **)(v150 + 8);
            v154 = &v153[2 * v152];
            do
            {
              v155 = v152 >> 1;
              v156 = &v153[2 * (v152 >> 1)];
              v158 = *v156;
              v157 = v156 + 2;
              v152 += ~(v152 >> 1);
              if (v158 < v151)
                v153 = v157;
              else
                v152 = v155;
            }
            while (v152);
            v95 = v269;
            if (v153 == v154 || *v153 != v151)
            {
LABEL_149:
              v159 = 0;
              goto LABEL_182;
            }
            v159 = (void *)v153[1];
          }
          else
          {
            v159 = 0;
            v95 = v269;
          }
LABEL_182:
          v286[0] = v149;
          v286[1] = v159;
          v176 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v286);
          v178 = v177;
          v179 = *(_QWORD *)(a1 + 96);
          v180 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v277);
          v181 = (uint64_t *)mlir::TypeConverter::convertType(v179, (void *)(*(_QWORD *)(v180 + 8) & 0xFFFFFFFFFFFFFFF8));
          v182 = v181;
          if (v181)
          {
            v183 = *v181;
            v184 = mlir::TypeID::get<mlir::ShapedType>();
            v185 = *(unsigned int *)(v183 + 16);
            if ((_DWORD)v185)
            {
              v186 = *(_QWORD **)(v183 + 8);
              v187 = &v186[2 * v185];
              do
              {
                v188 = v185 >> 1;
                v189 = &v186[2 * (v185 >> 1)];
                v191 = *v189;
                v190 = v189 + 2;
                v185 += ~(v185 >> 1);
                if (v191 < v184)
                  v186 = v190;
                else
                  v185 = v188;
              }
              while (v185);
              v95 = v269;
              if (v186 == v187 || *v186 != v184)
                goto LABEL_191;
              v192 = (void *)v186[1];
            }
            else
            {
              v192 = 0;
              v95 = v269;
            }
LABEL_194:
            v286[0] = v182;
            v286[1] = v192;
            v193 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v286);
            v195 = v194;
            v196 = mlir::anec::getIndexFromDim(3, v178);
            v197 = mlir::anec::getIndexFromDim(4, v195);
            v198 = (float)*(uint64_t *)(v176 + 8 * v196);
            v199 = (float)*(uint64_t *)(v176 + 8 * v197);
            v200 = (float)*(uint64_t *)(v193 + 8 * v196);
            v201 = (float)*(uint64_t *)(v193 + 8 * v197);
            v202 = v146 != 0.0;
            if (v145 != 0.0)
              v202 = 1;
            v203 = (v138 + -1.0) * 0.5 != v146 || (v137 + -1.0) * 0.5 != v145;
            v204 = v138 != (float)(v200 / v198) || v137 != (float)(v201 / v199);
            v205 = v138 != (float)((float)(v200 + -1.0) / (float)(v198 + -1.0))
                || v137 != (float)((float)(v201 + -1.0) / (float)(v199 + -1.0));
            if (v202 || v204)
            {
              if (v202 || v205)
              {
                if (v203 || v204)
                {
LABEL_208:
                  v206 = a4[2];
                  if (!v206)
                    goto LABEL_212;
                  v207 = v276;
                  if (!mlir::RewriterBase::Listener::classof(a4[2]))
                    goto LABEL_212;
                  v208 = *((_QWORD *)v207 + 3);
LABEL_211:
                  (*(void (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v206 + 64))(v206, v208, v209, v286);
LABEL_212:
                  v93 = 0;
                  v94 = 0;
LABEL_213:
                  if (__dst != v301)
                    free(__dst);
                  if (v302 != v304)
                    free(v302);
                  if (v305 != v307)
                    free(v305);
                  goto LABEL_101;
                }
                InferredResultTypes = 0;
                IsSize = 1;
              }
              else
              {
                IsSize = 1;
                InferredResultTypes = 1;
              }
            }
            else
            {
              IsSize = 0;
              InferredResultTypes = 0;
            }
LABEL_222:
            if (InferredResultTypes && IsSize)
            {
              v286[0] = &v287;
              v287 = 0uLL;
            }
            else
            {
              if (InferredResultTypes || IsSize)
              {
                if (InferredResultTypes || !IsSize)
                {
                  v206 = a4[2];
                  if (!v206)
                    goto LABEL_212;
                  v212 = v276;
                  if (!mlir::RewriterBase::Listener::classof(a4[2]))
                    goto LABEL_212;
                  v208 = *((_QWORD *)v212 + 3);
                  goto LABEL_211;
                }
                v286[0] = &v287;
                v210 = &unk_181233190;
              }
              else
              {
                v286[0] = &v287;
                v210 = &unk_181246500;
              }
              memset_pattern16(&v287, v210, 0x10uLL);
            }
            v286[1] = (void *)0x600000002;
            v211 = v300;
            if (v300 >= 2)
            {
              *(_OWORD *)__dst = v287;
            }
            else
            {
              if (HIDWORD(v300) > 1)
              {
                if ((_DWORD)v300)
                  memmove(__dst, &v287, 8 * v300);
                else
                  v211 = 0;
              }
              else
              {
                LODWORD(v300) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v301, 2uLL, 8);
                v211 = 0;
              }
              if (v211 != LODWORD(v286[1]))
                memcpy((char *)__dst + 8 * v211, (char *)v286[0] + 8 * v211, 8 * LODWORD(v286[1]) - 8 * v211);
            }
            LODWORD(v300) = 2;
            LODWORD(v286[1]) = 0;
            if (v286[0] != &v287)
              free(v286[0]);
            v286[0] = (void *)2;
            v213 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
            v214 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v286, 1, v213, 0);
            v215 = v214;
            if (!v214)
              goto LABEL_254;
            v216 = *v214;
            v217 = mlir::TypeID::get<mlir::ShapedType>();
            v218 = *(unsigned int *)(v216 + 16);
            if (!(_DWORD)v218)
              goto LABEL_254;
            v219 = *(_QWORD **)(v216 + 8);
            v220 = &v219[2 * v218];
            do
            {
              v221 = v218 >> 1;
              v222 = &v219[2 * (v218 >> 1)];
              v224 = *v222;
              v223 = v222 + 2;
              v218 += ~(v218 >> 1);
              if (v224 < v217)
                v219 = v223;
              else
                v218 = v221;
            }
            while (v218);
            if (v219 != v220 && *v219 == v217)
              v225 = v219[1];
            else
LABEL_254:
              v225 = 0;
            v271 = mlir::DenseElementsAttr::getFromRawBuffer(v215, v225, __dst, 8 * v300, 8, 1, 0);
            v226 = v308;
            v267 = v308 + 1;
            v227 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v285, -1.0);
            v228 = llvm::APFloatBase::IEEEsingle(v227);
            llvm::APFloat::Storage::Storage(&v286[1], v285, v228);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v285);
            llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v277, -1.0);
            llvm::APFloat::Storage::Storage(&v285[1], v277, v228);
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v277);
            v277[0] = mlir::OpBuilder::create<mlir::anec::Resize,mlir::Value &,unsigned long long &,unsigned long long &,llvm::APFloat,llvm::APFloat,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &>(v264, v262, &v275, v226, v267, (uint64_t)v286, (uint64_t)v285, &v272, &v271);
            v229 = (void *)v285[1];
            v230 = llvm::APFloatBase::PPCDoubleDouble(v277[0]);
            if (v230 == v229)
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v285[1]);
            else
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v285[1]);
            v231 = v263;
            if (v230 == v286[1])
              llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v286[1]);
            else
              llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v286[1]);
            v232 = mlir::anec::Resize::verifyAttributesWithFamily((uint64_t *)v277, 6);
            v93 = v277[0];
            if (!v232)
            {
              mlir::ConversionPatternRewriter::eraseOp((mlir::ConversionPatternRewriter *)a4, v277[0]);
              v286[0] = "requested attributes are not compatible with hardware requirements";
              LOWORD(v288) = 259;
              v246 = v276;
              v285[0] = (uint64_t)v286;
              v247 = a4[2];
              if (v247 && mlir::RewriterBase::Listener::classof(a4[2]))
                (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v247 + 64))(v247, *((_QWORD *)v246 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v285);
              v93 = 0;
              v94 = 0;
              v95 = v269;
              goto LABEL_213;
            }
            if (v265 != 1)
            {
LABEL_282:
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v274);
              if (v248 > 3)
              {
                v94 = 1;
                v95 = v269;
              }
              else
              {
                v286[0] = &v287;
                *(_QWORD *)&v287 = v37;
                *((_QWORD *)&v287 + 1) = IndexFromDim;
                v288 = v231;
                v289 = v37;
                v290 = IndexFromDim;
                v291 = v231;
                v286[1] = (void *)0x600000006;
                *(_OWORD *)v285 = xmmword_1812464A0;
                v249 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
                v250 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v285, 2, v249, 0);
                v251 = v250;
                if (v250
                  && (v252 = *v250,
                      v253 = mlir::TypeID::get<mlir::ShapedType>(),
                      v254 = *(unsigned int *)(v252 + 16),
                      (_DWORD)v254))
                {
                  v255 = *(_QWORD **)(v252 + 8);
                  v256 = &v255[2 * v254];
                  do
                  {
                    v257 = v254 >> 1;
                    v258 = &v255[2 * (v254 >> 1)];
                    v260 = *v258;
                    v259 = v258 + 2;
                    v254 += ~(v254 >> 1);
                    if (v260 < v253)
                      v255 = v259;
                    else
                      v254 = v257;
                  }
                  while (v254);
                  v95 = v269;
                  if (v255 != v256 && *v255 == v253)
                    v261 = v255[1];
                  else
                    v261 = 0;
                }
                else
                {
                  v261 = 0;
                  v95 = v269;
                }
                v270 = mlir::DenseElementsAttr::getFromRawBuffer(v251, v261, v286[0], 8 * LODWORD(v286[1]), 8, 1, 0);
                v285[0] = (uint64_t)v93 - 16;
                v93 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v264, v262, v285, &v270);
                if (v286[0] != &v287)
                  free(v286[0]);
                v94 = 1;
              }
              goto LABEL_213;
            }
            v286[0] = &v287;
            *(_QWORD *)&v287 = v37;
            *((_QWORD *)&v287 + 1) = v268;
            v288 = v263;
            v289 = v37;
            v290 = v268;
            v291 = v263;
            v286[1] = (void *)0x600000006;
            *(_OWORD *)v285 = xmmword_1812464A0;
            v233 = mlir::Builder::getIntegerType(v264, 0x40u, 0);
            v234 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v285, 2, v233, 0);
            v235 = v234;
            if (!v234)
              goto LABEL_272;
            v236 = *v234;
            v237 = mlir::TypeID::get<mlir::ShapedType>();
            v238 = *(unsigned int *)(v236 + 16);
            if ((_DWORD)v238)
            {
              v239 = *(_QWORD **)(v236 + 8);
              v240 = &v239[2 * v238];
              do
              {
                v241 = v238 >> 1;
                v242 = &v239[2 * (v238 >> 1)];
                v244 = *v242;
                v243 = v242 + 2;
                v238 += ~(v238 >> 1);
                if (v244 < v237)
                  v239 = v243;
                else
                  v238 = v241;
              }
              while (v238);
              v231 = v263;
              if (v239 == v240 || *v239 != v237)
              {
LABEL_272:
                v245 = 0;
                goto LABEL_280;
              }
              v245 = v239[1];
            }
            else
            {
              v245 = 0;
              v231 = v263;
            }
LABEL_280:
            v270 = mlir::DenseElementsAttr::getFromRawBuffer(v235, v245, v286[0], 8 * LODWORD(v286[1]), 8, 1, 0);
            v93 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::anec::Resize &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)v264, v262, v277, &v270);
            if (v286[0] != &v287)
              free(v286[0]);
            goto LABEL_282;
          }
LABEL_191:
          v192 = 0;
          goto LABEL_194;
        }
LABEL_95:
        v115 = 0;
        goto LABEL_114;
      }
    }
    else
    {
      v95 = v269;
    }
    v292[0] = "Shape operand was not a constant";
    LOWORD(v294) = 259;
    v116 = v276;
    v286[0] = v292;
    v117 = a4[2];
    if (v117 && mlir::RewriterBase::Listener::classof(a4[2]))
      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v117 + 64))(v117, *((_QWORD *)v116 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    v93 = 0;
    v94 = 0;
  }
  else
  {
    v292[0] = "Resize layout not supported";
    LOWORD(v294) = 259;
    v91 = v276;
    v286[0] = v292;
    v92 = a4[2];
    if (v92 && mlir::RewriterBase::Listener::classof(a4[2]))
      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v92 + 64))(v92, *((_QWORD *)v91 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    v93 = 0;
    v94 = 0;
    v95 = v269;
  }
LABEL_101:
  if (v308 != v310)
    free(v308);
  if (v311 != (mlir::Operation *)v313)
    free(v311);
  if (v94)
  {
    v292[0] = (char *)v93 - 16;
    v118 = 1;
    mlir::ValueRange::ValueRange(v278, (uint64_t)v292, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp((uint64_t)a4, (unsigned int *)v95, v278[0], v278[1]);
  }
  else
  {
    v292[0] = "Conversion did not match a valid resize or a valid transformation supported by the hardware.";
    LOWORD(v294) = 259;
    v286[0] = v292;
    v119 = a4[2];
    if (v119 && mlir::RewriterBase::Listener::classof(v119))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v119 + 64))(v119, *((_QWORD *)v95 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ResizeOp &>(mlir::mps::ResizeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v286);
    else
      return 0;
  }
  return v118;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)6>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Resize with custom scale and offset values not supported on ANE.\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertResizeGeneric<(mlir::anec::Family)6>::tryConvertWithLegalInputs(mlir::mps::ResizeOp,mlir::mps::ResizeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported alignCorners, centerResult for Resize\n");
}

void mlir::`anonymous namespace'::ConvertInstanceNorm::~ConvertInstanceNorm(mlir::_anonymous_namespace_::ConvertInstanceNorm *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::InstanceNormOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::InstanceNormOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::InstanceNormOpGenericAdaptorBase::InstanceNormOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::InstanceNormOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::InstanceNormOpGenericAdaptorBase::InstanceNormOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::InstanceNormOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 48);
  v9 = *(_QWORD *)(a3 + 56);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      v29 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::InstanceNormOp &>(mlir::mps::InstanceNormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::InstanceNormOp &>(mlir::mps::InstanceNormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertInstanceNorm::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, mlir::scf::detail::IfOpGenericAdaptorBase *a3, uint64_t a4)
{
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  unsigned int ODSOperandIndexAndLength;
  unint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  unint64_t v30;
  unint64_t *v31;
  _QWORD *v32;
  unint64_t v33;
  uint64_t v34;
  mlir::MLIRContext *v35;
  uint64_t v36;
  uint64_t F16Type;
  uint64_t v38;
  unsigned int v39;
  unint64_t v40;
  uint64_t v41;
  mlir::GenericProgramPoint *v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t ElementTypeOrSelf;
  uint64_t v50;
  uint64_t v52[2];
  uint64_t v53;
  uint64_t v54[2];
  uint64_t v55[2];
  _QWORD v56[2];
  unsigned int *v57;
  __int128 v58;
  char v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v57 = a2;
  v6 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v56[0] = v6;
  v56[1] = v16;
  ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 1u);
  v18 = *((_QWORD *)a3 + 6);
  *(_QWORD *)&v58 = v18;
  *((_QWORD *)&v58 + 1) = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v18 = mlir::ValueRange::offset_base(&v58, ODSOperandIndexAndLength);
  v58 = v18;
  v19 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v58, 0);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v56);
  v55[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(v19, v20, 0, 0);
  v55[1] = v21;
  if (!(_BYTE)v21)
    return 0;
  v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 0);
  v23 = *((_QWORD *)a3 + 6);
  *(_QWORD *)&v58 = v23;
  *((_QWORD *)&v58 + 1) = v22;
  if (v22)
    v23 = mlir::ValueRange::offset_base(&v58, v22);
  v58 = v23;
  v24 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v58, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v24)
    goto LABEL_25;
  v25 = *v24;
  v26 = mlir::TypeID::get<mlir::ShapedType>();
  v27 = *(unsigned int *)(v25 + 16);
  if (!(_DWORD)v27)
    goto LABEL_25;
  v28 = *(_QWORD **)(v25 + 8);
  v29 = &v28[2 * v27];
  do
  {
    v30 = v27 >> 1;
    v31 = &v28[2 * (v27 >> 1)];
    v33 = *v31;
    v32 = v31 + 2;
    v27 += ~(v27 >> 1);
    if (v33 < v26)
      v28 = v32;
    else
      v27 = v30;
  }
  while (v27);
  if (v28 != v29 && *v28 == v26)
    v34 = v28[1];
  else
LABEL_25:
    v34 = 0;
  v54[0] = mlir::getRankPromotionTypeForANE((uint64_t)v24, v34);
  v54[1] = (uint64_t)v35;
  v36 = *((_QWORD *)v57 + 3);
  F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a4 + 8), v35);
  LOBYTE(v58) = 0;
  v59 = 0;
  v52[0] = mlir::ShapedType::cloneWith(v54, &v58, F16Type);
  v52[1] = v38;
  v39 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 0);
  v40 = *((_QWORD *)a3 + 6);
  *(_QWORD *)&v58 = v40;
  *((_QWORD *)&v58 + 1) = v39;
  if (v39)
    v40 = mlir::ValueRange::offset_base(&v58, v39);
  v58 = v40;
  *(_QWORD *)&v58 = mlir::ValueRange::dereference_iterator(&v58, 0);
  v53 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Cast,mlir::ShapedType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v36, v52, (uint64_t *)&v58)- 16;
  v41 = *((_QWORD *)v57 + 3);
  mlir::mps::detail::InstanceNormOpGenericAdaptorBase::getEpsilon(a3, (uint64_t)&v58);
  v42 = mlir::OpBuilder::create<mlir::anec::InstanceNorm,mlir::Value &,mlir::DenseIntElementsAttr &,llvm::APFloat>((mlir::Float32Type **)(a4 + 8), v41, &v53, v55, (uint64_t)&v58);
  v53 = (uint64_t)v42 - 16;
  v43 = (void *)*((_QWORD *)&v58 + 1);
  if (llvm::APFloatBase::PPCDoubleDouble(v42) == v43)
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)((char *)&v58 + 8));
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)((char *)&v58 + 8));
  v45 = *((_QWORD *)v57 + 3);
  v46 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 0);
  v47 = *((_QWORD *)a3 + 6);
  *(_QWORD *)&v58 = v47;
  *((_QWORD *)&v58 + 1) = v46;
  if (v46)
    v47 = mlir::ValueRange::offset_base(&v58, v46);
  v58 = v47;
  v48 = mlir::ValueRange::dereference_iterator(&v58, 0);
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(v48);
  LOBYTE(v58) = 0;
  v59 = 0;
  *(_QWORD *)&v58 = mlir::ShapedType::cloneWith(v54, &v58, ElementTypeOrSelf);
  *((_QWORD *)&v58 + 1) = v50;
  v53 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Cast,mlir::ShapedType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v45, (uint64_t *)&v58, &v53)- 16;
  v44 = 1;
  mlir::ConversionPatternRewriter::replaceOp(a4, v57, (uint64_t)&v53, 1);
  return v44;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::InstanceNormOp &>(mlir::mps::InstanceNormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::InstanceNorm,mlir::Value &,mlir::DenseIntElementsAttr &,llvm::APFloat>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  void *v16;
  llvm::APFloatBase *v17;
  void *v18;
  mlir::GenericProgramPoint *v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  char v27[8];
  _QWORD v28[3];
  _QWORD v29[39];

  v29[38] = *MEMORY[0x1E0C80C00];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.instance_norm", (const unsigned __int8 *)0x12, Context);
  if (!v12)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"anec.instance_norm";
    v25[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v11);
  v13 = *a3;
  v14 = *a4;
  v16 = *(void **)(a5 + 8);
  v15 = (_QWORD *)(a5 + 8);
  v18 = llvm::APFloatBase::PPCDoubleDouble(v17);
  if (v18 == v16)
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v28, v15);
  else
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v28, (uint64_t)v15);
  mlir::anec::InstanceNorm::build(a1, (uint64_t)v29, v13, v14, (uint64_t)v27);
  if (v18 == (void *)v28[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v28);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v28);
  v19 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((_QWORD *)v19 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InstanceNorm,void>::id)
    v20 = v19;
  else
    v20 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v20;
}

void mlir::`anonymous namespace'::ConvertPermute::~ConvertPermute(mlir::_anonymous_namespace_::ConvertPermute *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PermuteOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PermuteOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::PermuteOpGenericAdaptorBase::PermuteOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PermuteOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::PermuteOpGenericAdaptorBase::PermuteOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PermuteOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PermuteOp &>(mlir::mps::PermuteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PermuteOp &>(mlir::mps::PermuteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertPermute::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t DefiningOp;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  unsigned int *v11;
  __int128 v12;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t *v20;
  _QWORD *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  unint64_t v26;
  char PositivePromotedAxes;
  size_t v28;
  void *v29;
  char *v30;
  char *v31;
  uint64_t v32;
  unsigned int *v33;
  uint64_t v35;
  unsigned __int8 v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t Transpose;
  unsigned int *v40;
  uint64_t v41;
  unsigned int *v43;
  _QWORD v44[2];
  __int128 v45;
  void *v46;
  uint64_t v47;
  _BYTE v48[32];
  void *v49;
  uint64_t v50;
  _QWORD v51[8];

  v51[6] = *MEMORY[0x1E0C80C00];
  v43 = a2;
  v45 = *(_OWORD *)(a3 + 40);
  if (*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43) + 8) >= 8uLL)
    mlir::TypeID::get<mlir::ShapedType>();
  v46 = (void *)mlir::ValueRange::dereference_iterator(&v45, 1);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v46);
  if (DefiningOp)
  {
    v6 = DefiningOp;
    v7 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 48) + 32))(*(_QWORD *)(v6 + 48), v7))
    {
      v49 = v51;
      v50 = 0x100000000;
      mlir::Operation::fold(v6, 0, 0, (uint64_t)&v49);
      v9 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v49 & 0xFFFFFFFFFFFFFFF8));
      if (v9)
        v10 = v8;
      else
        v10 = 0;
      if (v49 != v51)
        free(v49);
      if (v9)
      {
        v11 = v43;
        v12 = v45;
        v13 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)v43 + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v13)
          goto LABEL_20;
        v14 = *v13;
        v15 = mlir::TypeID::get<mlir::ShapedType>();
        v16 = *(unsigned int *)(v14 + 16);
        if (!(_DWORD)v16)
          goto LABEL_20;
        v17 = *(_QWORD **)(v14 + 8);
        v18 = &v17[2 * v16];
        do
        {
          v19 = v16 >> 1;
          v20 = &v17[2 * (v16 >> 1)];
          v22 = *v20;
          v21 = v20 + 2;
          v16 += ~(v16 >> 1);
          if (v22 < v15)
            v17 = v21;
          else
            v16 = v19;
        }
        while (v16);
        if (v17 != v18 && *v17 == v15)
          v23 = v17[1];
        else
LABEL_20:
          v23 = 0;
        v44[0] = v13;
        v44[1] = v23;
        v49 = v51;
        v50 = 0x600000000;
        mlir::getIntValues<long long>((uint64_t)v9, v10, (uint64_t)&v49, 1);
        v46 = v48;
        v47 = 0x400000000;
        v24 = (uint64_t *)v49;
        v25 = v50;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v44);
        PositivePromotedAxes = mlir::getPositivePromotedAxes(v24, v25, v26, (uint64_t)&v46, 0, 0);
        if (PositivePromotedAxes)
        {
          if ((_DWORD)v47)
          {
            v28 = 8 * v47;
            v29 = v46;
            v30 = (char *)operator new(v28);
            memcpy(v30, v29, v28);
            v31 = &v30[v28];
          }
          else
          {
            v30 = 0;
            v31 = 0;
          }
          v36 = Transpose;
          v38 = Transpose >> 8;
          if (v30)
            operator delete(v30);
          v37 = 1;
        }
        else
        {
          v36 = 0;
          v37 = 0;
          v38 = 0;
        }
        if (v46 != v48)
          free(v46);
        if (v49 != v51)
          free(v49);
        v49 = (void *)(v36 | (v38 << 8));
        v50 = v37;
        v40 = v43;
        if (PositivePromotedAxes)
        {
          v35 = 1;
          mlir::ConversionPatternRewriter::replaceOp(a4, v43, (uint64_t)&v49, 1);
          return v35;
        }
        v41 = *(_QWORD *)(a4 + 16);
        if (v41 && mlir::RewriterBase::Listener::classof(v41))
        return 0;
      }
    }
  }
  v32 = *(_QWORD *)(a4 + 16);
  if (!v32)
    return 0;
  v33 = v43;
  if (!mlir::RewriterBase::Listener::classof(v32))
    return 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PermuteOp &>(mlir::mps::PermuteOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPermute::matchAndRewriteWithStaticShapes(mlir::mps::PermuteOp,mlir::mps::PermuteOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Permute can be lowered to Transpose only if indices argument is a constant \n");
}

uint64_t mlir::`anonymous namespace'::createTranspose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unint64_t a5, uint64_t a6)
{
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  int64x2_t *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  unint64_t v25;
  int64x2_t v26;
  int64x2_t *v27;
  int64x2_t v28;
  int64x2_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v47;
  _QWORD v48[2];
  void *v49;
  uint64_t v50;
  _BYTE v51[80];
  void *v52;
  unsigned int v53;
  int v54;
  _BYTE v55[32];
  _QWORD v56[2];
  void *v57[2];
  _QWORD v58[3];

  v58[1] = *MEMORY[0x1E0C80C00];
  v56[0] = a2;
  v56[1] = a3;
  v10 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_10;
  v11 = *v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_10;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_10:
    v20 = 0;
  v48[0] = v10;
  v48[1] = v20;
  v52 = v55;
  v54 = 4;
  if (a5 < 5)
  {
    if (!a5)
    {
      v53 = 0;
      v49 = v51;
      v50 = 0x500000000;
      goto LABEL_49;
    }
    bzero(v55, 8 * a5);
    v21 = (int64x2_t *)v55;
  }
  else
  {
    v53 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v55, a5, 8);
    v21 = (int64x2_t *)v52;
    bzero(v52, 8 * a5);
  }
  v53 = a5;
  if (!(_DWORD)a5)
    goto LABEL_38;
  v22 = (a5 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v22 < 3)
  {
    v23 = 0;
    v24 = (uint64_t *)v21;
    do
LABEL_21:
      *v24++ = v23++;
    while (v24 != (uint64_t *)((char *)v21 + 8 * a5));
    goto LABEL_22;
  }
  v25 = v22 + 1;
  v23 = (v22 + 1) & 0x3FFFFFFFFFFFFFFCLL;
  v24 = &v21->i64[v23];
  v26 = (int64x2_t)xmmword_181233120;
  v27 = v21 + 1;
  v28 = vdupq_n_s64(2uLL);
  v29 = vdupq_n_s64(4uLL);
  v30 = v23;
  do
  {
    v27[-1] = v26;
    *v27 = vaddq_s64(v26, v28);
    v26 = vaddq_s64(v26, v29);
    v27 += 2;
    v30 -= 4;
  }
  while (v30);
  if (v25 != v23)
    goto LABEL_21;
LABEL_22:
  if ((_DWORD)a5)
  {
    v31 = 8 * a5;
    do
    {
      v32 = v21->i64[0];
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v48);
      if (v32 == 2)
        v34 = 3;
      else
        v34 = v32;
      if (v32)
        v35 = 3;
      else
        v35 = 1;
      if (v33 != 2)
        v35 = v32;
      if (v33 != 3)
        v34 = v35;
      if (v33 < 2)
        v34 = 3;
      v21->i64[0] = v34;
      v21 = (int64x2_t *)((char *)v21 + 8);
      v31 -= 8;
    }
    while (v31);
    v21 = (int64x2_t *)v52;
    v36 = v53;
    goto LABEL_39;
  }
LABEL_38:
  v36 = a5;
LABEL_39:
  v49 = v51;
  v50 = 0x500000000;
  if (v36)
  {
    v37 = 0;
    v38 = 8 * v36 - 8;
    v39 = 8 * a5 - 8;
    do
    {
      v40 = *a4;
      v41 = v21->i64[0];
      if (*a4 != v21->i64[0])
      {
        if (v37 >= HIDWORD(v50))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v37 + 1, 16);
          v37 = v50;
        }
        v42 = (char *)v49 + 16 * v37;
        *v42 = v40;
        v42[1] = v41;
        v37 = v50 + 1;
        LODWORD(v50) = v50 + 1;
      }
      if (!v39)
        break;
      ++a4;
      v21 = (int64x2_t *)((char *)v21 + 8);
      v43 = v38;
      v38 -= 8;
      v39 -= 8;
    }
    while (v43);
  }
LABEL_49:
  v44 = *(_QWORD *)(a1 + 24);
  v47 = mlir::ValueRange::dereference_iterator(v56, 0);
  v57[0] = v58;
  v57[1] = (void *)0x100000000;
  mlir::OpBuilder::createOrFold<mlir::anec::Transpose,mlir::Value,llvm::SmallVector<std::pair<unsigned long long,unsigned long long>,5u> &>((mlir::Builder *)(a6 + 8), (uint64_t)v57, v44, &v47, (uint64_t)&v49);
  v45 = *(_QWORD *)v57[0];
  if (v57[0] != v58)
    free(v57[0]);
  if (v49 != v51)
    free(v49);
  if (v52 != v55)
    free(v52);
  return v45;
}

void mlir::OpBuilder::createOrFold<mlir::anec::Transpose,mlir::Value,llvm::SmallVector<std::pair<unsigned long long,unsigned long long>,5u> &>(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  const mlir::OperationState *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x1E0C80C00];
  v20 = a3;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.transpose", (const unsigned __int8 *)0xE, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"anec.transpose";
    v23[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a3, v11);
  mlir::anec::Transpose::build(a1, (uint64_t)v25, *a4, *(uint64_t **)a5, *(unsigned int *)(a5 + 8));
  v14 = (mlir::GenericProgramPoint *)mlir::Operation::create((mlir::Operation *)v25, v13);
  v15 = *((_QWORD *)a1 + 2);
  if (v15)
  {
    v16 = (uint64_t *)*((_QWORD *)a1 + 3);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v15 + 32, (uint64_t)v14);
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
    v17 = *v16;
    *v18 = *v16;
    v18[1] = (uint64_t)v16;
    *(_QWORD *)(v17 + 8) = v18;
    *v16 = (uint64_t)v18;
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
  }
  if (mlir::OpBuilder::tryFold(a1, (uint64_t)v14, a2))
  {
    mlir::Operation::erase(v14);
  }
  else
  {
    v19 = *((_QWORD *)a1 + 1);
    if (v19)
      (*(void (**)(uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)v19 + 16))(v19, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPermute::matchAndRewriteWithStaticShapes(mlir::mps::PermuteOp,mlir::mps::PermuteOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "failed: Could not extract valid positive and rank-promoted axes. \n");
}

void mlir::`anonymous namespace'::ConvertGatherND::~ConvertGatherND(mlir::_anonymous_namespace_::ConvertGatherND *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherNDOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherNDOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[56];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::GatherNDOpGenericAdaptorBase::GatherNDOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherNDOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[56];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::GatherNDOpGenericAdaptorBase::GatherNDOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::GatherNDOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 56);
  v9 = *(_QWORD *)(a3 + 64);
  v36 = v8;
  v37 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v28;
      v35 = *(_QWORD *)(a3 + 64);
      v29 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherNDOp &>(mlir::mps::GatherNDOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v37;
    if (v36 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherNDOp &>(mlir::mps::GatherNDOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertGatherND::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t *v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  unsigned int Count;
  uint64_t ArgAttrsAttr;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t result;
  mlir::MLIRContext *v48;
  uint64_t *v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  unint64_t v55;
  unint64_t *v56;
  _QWORD *v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t F16Type;
  uint64_t v61;
  mlir::MLIRContext *v62;
  uint64_t v63;
  uint64_t v64;
  _BYTE *v65;
  uint64_t v66;
  unsigned int v67;
  uint64_t v68;
  _BYTE *v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  uint64_t v76;
  uint64_t v77;
  char *v78;
  char *v79;
  size_t v80;
  unsigned int v81;
  unsigned int v82;
  unint64_t v83;
  char *v84;
  char *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unsigned int v91;
  uint64_t v92;
  uint64_t v93;
  _BYTE *v94;
  uint64_t v95;
  uint64_t *v96;
  uint64_t v97;
  unint64_t v98;
  unint64_t v99;
  _QWORD *v100;
  _QWORD *v101;
  unint64_t v102;
  unint64_t *v103;
  _QWORD *v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unsigned int v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  _QWORD *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t IntegerType;
  _QWORD *v122;
  _QWORD *v123;
  uint64_t v124;
  unint64_t v125;
  unint64_t v126;
  _QWORD *v127;
  _QWORD *v128;
  unint64_t v129;
  unint64_t *v130;
  _QWORD *v131;
  unint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  _QWORD *v136;
  _QWORD *v137;
  uint64_t v138;
  unint64_t v139;
  unint64_t v140;
  _QWORD *v141;
  _QWORD *v142;
  unint64_t v143;
  unint64_t *v144;
  _QWORD *v145;
  unint64_t v146;
  uint64_t v147;
  void *v148;
  mlir::AffineMap *v149;
  uint64_t OperandRange;
  uint64_t v151;
  uint64_t v152;
  void *v153;
  mlir::AffineMap *v154;
  mlir::AffineMap *v155;
  uint64_t v156;
  uint64_t *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  unint64_t v161;
  unint64_t v162;
  _QWORD *v163;
  _QWORD *v164;
  unint64_t v165;
  unint64_t *v166;
  _QWORD *v167;
  unint64_t v168;
  uint64_t v169;
  uint64_t v170;
  mlir::GenericProgramPoint *v171;
  mlir::GenericProgramPoint *v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t ElementTypeOrSelf;
  uint64_t v177;
  _QWORD v178[2];
  _QWORD v179[2];
  _QWORD v180[2];
  uint64_t v181;
  void *v182;
  uint64_t v183;
  _BYTE v184[40];
  void *v185;
  uint64_t v186;
  _BYTE v187[40];
  void *v188;
  uint64_t v189;
  _BYTE v190[40];
  void *v191;
  uint64_t v192;
  _BYTE v193[40];
  __int128 v194;
  unint64_t __src;
  uint64_t v196;
  __int128 v197;
  uint64_t v198;
  __int128 v199;
  uint64_t v200;

  v200 = *MEMORY[0x1E0C80C00];
  v181 = a2;
  v194 = *(_OWORD *)(a3 + 56);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v181) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v180[0] = v5;
  v180[1] = v15;
  v16 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v181) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_20;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_20;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_20:
    v26 = 0;
  v179[0] = v16;
  v179[1] = v26;
  v27 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v181) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27)
    goto LABEL_30;
  v28 = *v27;
  v29 = mlir::TypeID::get<mlir::ShapedType>();
  v30 = *(unsigned int *)(v28 + 16);
  if (!(_DWORD)v30)
    goto LABEL_30;
  v31 = *(_QWORD **)(v28 + 8);
  v32 = &v31[2 * v30];
  do
  {
    v33 = v30 >> 1;
    v34 = &v31[2 * (v30 >> 1)];
    v36 = *v34;
    v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29)
      v31 = v35;
    else
      v30 = v33;
  }
  while (v30);
  if (v31 != v32 && *v31 == v29)
    v37 = v31[1];
  else
LABEL_30:
    v37 = 0;
  v178[0] = v27;
  v178[1] = v37;
  Count = mlir::pdl_interp::CheckOperandCountOp::getCount((mlir::pdl_interp::CheckOperandCountOp *)&v181);
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v179);
  v41 = *(_QWORD *)(ArgAttrsAttr + 8 * v40 - 8);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v180);
  if (v42 > 5
    || (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v179), v43 > 5)
    || (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v178), v44 >= 6))
  {
    v45 = *(_QWORD *)(a4 + 16);
    if (!v45)
      return 0;
    v46 = v181;
    result = mlir::RewriterBase::Listener::classof(v45);
    if ((_DWORD)result)
    return result;
  }
  v177 = mlir::ValueRange::dereference_iterator(&v194, 1);
  ElementTypeOrSelf = mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v177 + 8) & 0xFFFFFFFFFFFFFFF8));
  if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) >= 9
    && !mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    v49 = (uint64_t *)(*(_QWORD *)(v177 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v49)
      goto LABEL_49;
    v50 = *v49;
    v51 = mlir::TypeID::get<mlir::ShapedType>();
    v52 = *(unsigned int *)(v50 + 16);
    if (!(_DWORD)v52)
      goto LABEL_49;
    v53 = *(_QWORD **)(v50 + 8);
    v54 = &v53[2 * v52];
    do
    {
      v55 = v52 >> 1;
      v56 = &v53[2 * (v52 >> 1)];
      v58 = *v56;
      v57 = v56 + 2;
      v52 += ~(v52 >> 1);
      if (v58 < v51)
        v53 = v57;
      else
        v52 = v55;
    }
    while (v52);
    if (v53 != v54 && *v53 == v51)
      v59 = v53[1];
    else
LABEL_49:
      v59 = 0;
    v191 = v49;
    v192 = v59;
    F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a4 + 8), v48);
    LOBYTE(v197) = 0;
    LOBYTE(v198) = 0;
    mlir::ShapedType::cloneWith((uint64_t *)&v191, &v197, F16Type);
    v61 = *(_QWORD *)(v181 + 24);
    v191 = (void *)mlir::Builder::getF16Type((mlir::Float16Type **)(a4 + 8), v62);
    *(_QWORD *)&v197 = &v198;
    *((_QWORD *)&v197 + 1) = 0x100000000;
    mlir::OpBuilder::createOrFold<mlir::mps::CastOp,mlir::Value &,mlir::FloatType>(a4 + 8, (uint64_t)&v197, v61, &v177, (uint64_t *)&v191);
    v63 = *(_QWORD *)v197;
    if ((uint64_t *)v197 != &v198)
      free((void *)v197);
    v177 = v63;
  }
  v64 = Count;
  v191 = v193;
  v192 = 0x500000000;
  v65 = (_BYTE *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v180);
  v66 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v180);
  v67 = 0;
  v69 = (_BYTE *)(v66 + 8 * v68);
  LODWORD(v192) = 0;
  v70 = (v69 - v65) >> 3;
  if (v70 > HIDWORD(v192))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v191, v193, v70, 8);
    v67 = v192;
  }
  if (v69 != v65)
  {
    memcpy((char *)v191 + 8 * v67, v65, v69 - v65);
    v67 = v192;
  }
  LODWORD(v192) = v67 + ((unint64_t)(v69 - v65) >> 3);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v179);
  v72 = v71 + ~(v41 + v64);
  v73 = v72 & ~(v72 >> 63);
  if (v72 >= 1)
  {
    v74 = v72 & ~(v72 >> 63);
    do
    {
      *(_QWORD *)&v197 = 1;
      llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191 + 8 * v64, (uint64_t *)&v197);
      --v74;
    }
    while (v74);
  }
  v75 = v192;
  v76 = 5 - v192;
  if (v192 <= 4)
  {
    v77 = v76 <= 1 ? 1 : 5 - v192;
    *(_QWORD *)&v197 = 1;
    llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191, (uint64_t *)&v197);
    if (v75 <= 3)
    {
      *(_QWORD *)&v197 = 1;
      llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191, (uint64_t *)&v197);
      if (v77 != 2)
      {
        *(_QWORD *)&v197 = 1;
        llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191, (uint64_t *)&v197);
        if (v77 != 3)
        {
          *(_QWORD *)&v197 = 1;
          llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191, (uint64_t *)&v197);
          if (v77 != 4)
          {
            *(_QWORD *)&v197 = 1;
            llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v191, (uint64_t)v191, (uint64_t *)&v197);
          }
        }
      }
    }
  }
  v188 = v190;
  v78 = (char *)v191;
  v79 = (char *)v191 + 8 * v76 + 8 * v64;
  v189 = 0x500000000;
  v80 = 8 * v76 + 8 * v64;
  if (v80 >= 0x29)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v188, v190, (uint64_t)v80 >> 3, 8);
    v81 = v189;
    if (v78 == v79)
      goto LABEL_77;
    goto LABEL_76;
  }
  v81 = 0;
  if (v191 != v79)
  {
LABEL_76:
    memcpy((char *)v188 + 8 * v81, v78, v80);
    v81 = v189;
  }
LABEL_77:
  v82 = v81 + (v80 >> 3);
  LODWORD(v189) = v82;
  v83 = -v72 & ~(-v72 >> 63);
  if (v72 < 0)
  {
    if (v83 <= 1)
      v95 = 1;
    else
      v95 = -v72 & ~(-v72 >> 63);
    do
    {
      if (v82 >= HIDWORD(v189))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v188, v190, v82 + 1, 8);
        v82 = v189;
      }
      *((_QWORD *)v188 + v82) = 1;
      v82 = v189 + 1;
      LODWORD(v189) = v189 + 1;
      --v95;
    }
    while (v95);
  }
  v84 = (char *)v188 + 8 * v82;
  v85 = (char *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v179) + 8 * v64);
  v86 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v179);
  llvm::SmallVectorImpl<mlir::Attribute>::insert<mlir::Attribute const*,void>((uint64_t)&v188, (uint64_t)v84, v85, (char *)(v86 + 8 * v87 - 8));
  v88 = v73 + v64 + v76;
  v89 = 5 - (v41 + v88);
  if (v89 >= 1)
  {
    v90 = 0;
    v91 = v189;
    do
    {
      if (v91 >= HIDWORD(v189))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v188, v190, v91 + 1, 8);
        v91 = v189;
      }
      *((_QWORD *)v188 + v91) = 1;
      v91 = v189 + 1;
      LODWORD(v189) = v189 + 1;
      ++v90;
    }
    while (v90 < v89);
  }
  v185 = v187;
  v186 = 0x500000000;
  LODWORD(v92) = 0;
  if (v41)
  {
    v93 = v41;
    do
    {
      if (v92 >= HIDWORD(v186))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v185, v187, v92 + 1, 8);
        LODWORD(v92) = v186;
      }
      *((_QWORD *)v185 + v92) = v88;
      LODWORD(v92) = v186 + 1;
      LODWORD(v186) = v186 + 1;
      ++v88;
      --v93;
    }
    while (v93);
    v94 = v185;
  }
  else
  {
    v94 = v187;
  }
  v182 = v184;
  v183 = 0x500000000;
  if (*(_QWORD *)&v94[8 * v92 - 8] <= 2uLL)
  {
    v92 = v92;
  }
  else
  {
    v96 = (uint64_t *)(*(_QWORD *)(v177 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v96)
      goto LABEL_107;
    v97 = *v96;
    v98 = mlir::TypeID::get<mlir::ShapedType>();
    v99 = *(unsigned int *)(v97 + 16);
    if (!(_DWORD)v99)
      goto LABEL_107;
    v100 = *(_QWORD **)(v97 + 8);
    v101 = &v100[2 * v99];
    do
    {
      v102 = v99 >> 1;
      v103 = &v100[2 * (v99 >> 1)];
      v105 = *v103;
      v104 = v103 + 2;
      v99 += ~(v99 >> 1);
      if (v105 < v98)
        v100 = v104;
      else
        v99 = v102;
    }
    while (v99);
    if (v100 != v101 && *v100 == v98)
      v106 = v100[1];
    else
LABEL_107:
      v106 = 0;
    *(_QWORD *)&v197 = v96;
    *((_QWORD *)&v197 + 1) = v106;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v197);
    v108 = v183;
    if (v107)
    {
      v109 = v107;
      v110 = 0;
      v111 = *((_QWORD *)v185 + v186 - 1);
      v112 = v83 + v107 - v111 + 1;
      v113 = v107 - 1;
      v114 = v83 - v111 + v107 + 1;
      do
      {
        if (v114 == v110)
          v115 = v113;
        else
          v115 = (__PAIR128__(v110, v112) - v110) >> 64;
        if (v108 >= HIDWORD(v183))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v182, v184, v108 + 1, 8);
          v108 = v183;
        }
        *((_QWORD *)v182 + v108) = v115;
        v108 = v183 + 1;
        LODWORD(v183) = v183 + 1;
        ++v110;
      }
      while (v109 != v110);
    }
    v116 = v182;
    v117 = *(_QWORD *)(v181 + 24);
    *(_QWORD *)&v197 = &v198;
    *((_QWORD *)&v197 + 1) = 0x500000000;
    if (v108)
    {
      v118 = 0;
      v119 = 8 * v108;
      do
      {
        if (v118 != v116[v118])
        {
          __src = v116[v118];
          v196 = v118;
          llvm::SmallVectorImpl<mlir::Attribute>::insert<mlir::Attribute const*,void>((uint64_t)&v197, v197 + 8 * DWORD2(v197), (char *)&__src, (char *)&v197);
        }
        ++v118;
        v119 -= 8;
      }
      while (v119);
      v120 = (unint64_t)DWORD2(v197) >> 1;
    }
    else
    {
      v120 = 0;
    }
    __src = v120;
    v196 = 2;
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
    v122 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&__src, 2, IntegerType, 0);
    v123 = v122;
    if (!v122)
      goto LABEL_134;
    v124 = *v122;
    v125 = mlir::TypeID::get<mlir::ShapedType>();
    v126 = *(unsigned int *)(v124 + 16);
    if (!(_DWORD)v126)
      goto LABEL_134;
    v127 = *(_QWORD **)(v124 + 8);
    v128 = &v127[2 * v126];
    do
    {
      v129 = v126 >> 1;
      v130 = &v127[2 * (v126 >> 1)];
      v132 = *v130;
      v131 = v130 + 2;
      v126 += ~(v126 >> 1);
      if (v132 < v125)
        v127 = v131;
      else
        v126 = v129;
    }
    while (v126);
    if (v127 != v128 && *v127 == v125)
      v133 = v127[1];
    else
LABEL_134:
      v133 = 0;
    v134 = mlir::DenseElementsAttr::getFromRawBuffer(v123, v133, v197, 8 * DWORD2(v197), 8, 1, 0);
    if ((uint64_t *)v197 != &v198)
      free((void *)v197);
    *(_QWORD *)&v197 = v134;
    v177 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), v117, &v177, (uint64_t *)&v197)- 16;
    v92 = v186;
  }
  *(_QWORD *)&v197 = v92;
  v135 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  v136 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v197, 1, v135, 0);
  v137 = v136;
  if (!v136)
    goto LABEL_147;
  v138 = *v136;
  v139 = mlir::TypeID::get<mlir::ShapedType>();
  v140 = *(unsigned int *)(v138 + 16);
  if (!(_DWORD)v140)
    goto LABEL_147;
  v141 = *(_QWORD **)(v138 + 8);
  v142 = &v141[2 * v140];
  do
  {
    v143 = v140 >> 1;
    v144 = &v141[2 * (v140 >> 1)];
    v146 = *v144;
    v145 = v144 + 2;
    v140 += ~(v140 >> 1);
    if (v146 < v139)
      v141 = v145;
    else
      v140 = v143;
  }
  while (v140);
  if (v141 != v142 && *v141 == v139)
    v147 = v141[1];
  else
LABEL_147:
    v147 = 0;
  __src = mlir::DenseElementsAttr::getFromRawBuffer(v137, v147, v185, 8 * v186, 8, 1, 0);
  v148 = v191;
  v149 = (mlir::AffineMap *)v192;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v180);
  v175 = mlir::MemRefType::get(v148, v149, OperandRange, 0, 0, 0);
  v197 = *(_OWORD *)v188;
  v198 = *((_QWORD *)v188 + 2) * v41;
  v199 = *(_OWORD *)((char *)v188 + 24);
  v151 = mlir::getElementTypeOrSelf(v177);
  v174 = mlir::MemRefType::get(&v197, (mlir::AffineMap *)5, v151, 0, 0, 0);
  v152 = *(_QWORD *)(v181 + 24);
  *(_QWORD *)&v197 = mlir::ValueRange::dereference_iterator(&v194, 0);
  v173 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v152, &v175, (uint64_t *)&v197)- 16;
  v177 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v181 + 24), &v174, &v177)- 16;
  v172 = mlir::OpBuilder::create<mlir::anec::GatherND,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(_QWORD *)(v181 + 24), &v173, &v177, (uint64_t *)&__src);
  v153 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v178);
  v155 = v154;
  v156 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v178);
  v157 = (uint64_t *)mlir::MemRefType::get(v153, v155, v156, 0, 0, 0);
  v158 = (uint64_t)v157;
  v159 = v181;
  if (!v157)
    goto LABEL_157;
  v160 = *v157;
  v161 = mlir::TypeID::get<mlir::ShapedType>();
  v162 = *(unsigned int *)(v160 + 16);
  if (!(_DWORD)v162)
    goto LABEL_157;
  v163 = *(_QWORD **)(v160 + 8);
  v164 = &v163[2 * v162];
  do
  {
    v165 = v162 >> 1;
    v166 = &v163[2 * (v162 >> 1)];
    v168 = *v166;
    v167 = v166 + 2;
    v162 += ~(v162 >> 1);
    if (v168 < v161)
      v163 = v167;
    else
      v162 = v165;
  }
  while (v162);
  if (v163 != v164 && *v163 == v161)
    v169 = v163[1];
  else
LABEL_157:
    v169 = 0;
  *(_QWORD *)&v197 = mlir::getRankPromotionTypeForANE(v158, v169);
  *((_QWORD *)&v197 + 1) = v170;
  v171 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType,mlir::anec::GatherND &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v159 + 24), (uint64_t *)&v197, &v172);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v159, v171);
  if (v182 != v184)
    free(v182);
  if (v185 != v187)
    free(v185);
  if (v188 != v190)
    free(v188);
  if (v191 != v193)
    free(v191);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherNDOp &>(mlir::mps::GatherNDOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::GatherND,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.gather_nd", (const unsigned __int8 *)0xE, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"anec.gather_nd";
    v19[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::anec::GatherND::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::GatherND,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertGatherND::matchAndRewriteWithStaticShapes(mlir::mps::GatherNDOp,mlir::mps::GatherNDOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Inputs / output with rank > 5 not supported");
}

void mlir::OpBuilder::createOrFold<mlir::mps::CastOp,mlir::Value &,mlir::FloatType>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  const mlir::OperationState *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x1E0C80C00];
  v20 = a3;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.cast";
    v23[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a3, v11);
  mlir::mps::CastOp::build((mlir::UnknownLoc **)a1, (uint64_t)v25, *a4, *a5);
  v14 = (mlir::GenericProgramPoint *)mlir::Operation::create((mlir::Operation *)v25, v13);
  v15 = *(_QWORD *)(a1 + 16);
  if (v15)
  {
    v16 = *(uint64_t **)(a1 + 24);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v15 + 32, (uint64_t)v14);
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
    v17 = *v16;
    *v18 = *v16;
    v18[1] = (uint64_t)v16;
    *(_QWORD *)(v17 + 8) = v18;
    *v16 = (uint64_t)v18;
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
  }
  if (mlir::OpBuilder::tryFold((_QWORD *)a1, (uint64_t)v14, a2))
  {
    mlir::Operation::erase(v14);
  }
  else
  {
    v19 = *(_QWORD *)(a1 + 8);
    if (v19)
      (*(void (**)(uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)v19 + 16))(v19, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType,mlir::anec::GatherND &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reshape", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.reshape";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4 - 16);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Reshape,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::`anonymous namespace'::ConvertGather::~ConvertGather(mlir::_anonymous_namespace_::ConvertGather *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[56];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::GatherOpGenericAdaptorBase::GatherOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::GatherOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[56];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::GatherOpGenericAdaptorBase::GatherOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::GatherOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 56);
  v9 = *(_QWORD *)(a3 + 64);
  v36 = v8;
  v37 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v28;
      v35 = *(_QWORD *)(a3 + 64);
      v29 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v37;
    if (v36 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertGather::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, mlir::mps::detail::GatherOpGenericAdaptorBase *a3, mlir::Float16Type **a4)
{
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  unint64_t v23;
  unint64_t *v24;
  _QWORD *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  unint64_t v34;
  unint64_t *v35;
  _QWORD *v36;
  unint64_t v37;
  uint64_t v38;
  unsigned int BatchDims;
  unsigned int ODSOperandIndexAndLength;
  unint64_t v41;
  mlir::MLIRContext *v42;
  char *v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  _QWORD *v47;
  _QWORD *v48;
  unint64_t v49;
  unint64_t *v50;
  _QWORD *v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t F16Type;
  uint64_t v55;
  mlir::MLIRContext *v56;
  uint64_t v57;
  unsigned int v58;
  unint64_t v59;
  uint64_t DefiningOp;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v63;
  int v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  unint64_t v70;
  unint64_t *v71;
  _QWORD *v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  const void *ArgAttrsAttr;
  uint64_t v82;
  int v83;
  uint64_t v84;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  char *v90;
  char *v91;
  uint64_t v92;
  unsigned int v93;
  unsigned int v94;
  uint64_t v95;
  const void *v96;
  uint64_t v97;
  size_t v98;
  unsigned int v99;
  unsigned int v100;
  uint64_t v101;
  uint64_t IntegerType;
  _QWORD *v103;
  _QWORD *v104;
  uint64_t v105;
  unint64_t v106;
  unint64_t v107;
  _QWORD *v108;
  _QWORD *v109;
  unint64_t v110;
  unint64_t *v111;
  _QWORD *v112;
  unint64_t v113;
  uint64_t v114;
  void *v115;
  mlir::AffineMap *v116;
  uint64_t OperandRange;
  void *v118;
  mlir::AffineMap *v119;
  uint64_t v120;
  uint64_t v121;
  unsigned int v122;
  unint64_t v123;
  void *v124;
  mlir::AffineMap *v125;
  mlir::AffineMap *v126;
  uint64_t v127;
  uint64_t *v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  unint64_t v132;
  unint64_t v133;
  _QWORD *v134;
  _QWORD *v135;
  unint64_t v136;
  unint64_t *v137;
  _QWORD *v138;
  unint64_t v139;
  uint64_t v140;
  uint64_t v141;
  mlir::GenericProgramPoint *v142;
  uint64_t v143;
  mlir::GenericProgramPoint *v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  _QWORD *ElementTypeOrSelf;
  uint64_t v149;
  _QWORD v150[2];
  _QWORD v151[2];
  _QWORD v152[2];
  uint64_t v153;
  uint64_t v154;
  __int128 v155;
  _BYTE v156[48];
  void *v157;
  uint64_t v158;
  _BYTE v159[40];
  char *v160;
  uint64_t v161;
  _BYTE v162[40];
  void *v163[2];
  uint64_t v164;
  uint64_t *v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t RankPromotionTypeForANE;
  uint64_t v169;
  uint64_t v170;

  v170 = *MEMORY[0x1E0C80C00];
  v153 = a2;
  v6 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v153) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v152[0] = v6;
  v152[1] = v16;
  v17 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v153) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v17)
    goto LABEL_20;
  v18 = *v17;
  v19 = mlir::TypeID::get<mlir::ShapedType>();
  v20 = *(unsigned int *)(v18 + 16);
  if (!(_DWORD)v20)
    goto LABEL_20;
  v21 = *(_QWORD **)(v18 + 8);
  v22 = &v21[2 * v20];
  do
  {
    v23 = v20 >> 1;
    v24 = &v21[2 * (v20 >> 1)];
    v26 = *v24;
    v25 = v24 + 2;
    v20 += ~(v20 >> 1);
    if (v26 < v19)
      v21 = v25;
    else
      v20 = v23;
  }
  while (v20);
  if (v21 != v22 && *v21 == v19)
    v27 = v21[1];
  else
LABEL_20:
    v27 = 0;
  v151[0] = v17;
  v151[1] = v27;
  v28 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v153) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v28)
    goto LABEL_30;
  v29 = *v28;
  v30 = mlir::TypeID::get<mlir::ShapedType>();
  v31 = *(unsigned int *)(v29 + 16);
  if (!(_DWORD)v31)
    goto LABEL_30;
  v32 = *(_QWORD **)(v29 + 8);
  v33 = &v32[2 * v31];
  do
  {
    v34 = v31 >> 1;
    v35 = &v32[2 * (v31 >> 1)];
    v37 = *v35;
    v36 = v35 + 2;
    v31 += ~(v31 >> 1);
    if (v37 < v30)
      v32 = v36;
    else
      v31 = v34;
  }
  while (v31);
  if (v32 != v33 && *v32 == v30)
    v38 = v32[1];
  else
LABEL_30:
    v38 = 0;
  v150[0] = v28;
  v150[1] = v38;
  BatchDims = mlir::mps::detail::GatherOpGenericAdaptorBase::getBatchDims(a3);
  ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 1u);
  v41 = *((_QWORD *)a3 + 7);
  *(_QWORD *)&v155 = v41;
  *((_QWORD *)&v155 + 1) = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v41 = mlir::ValueRange::offset_base(&v155, ODSOperandIndexAndLength);
  v155 = v41;
  v149 = mlir::ValueRange::dereference_iterator(&v155, 0);
  ElementTypeOrSelf = (_QWORD *)mlir::getElementTypeOrSelf(v149);
  if ((unint64_t)mlir::getElementBitWidth(ElementTypeOrSelf) >= 9
    && !mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    v43 = (char *)(*(_QWORD *)(v149 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v43)
      goto LABEL_44;
    v44 = *(_QWORD *)v43;
    v45 = mlir::TypeID::get<mlir::ShapedType>();
    v46 = *(unsigned int *)(v44 + 16);
    if (!(_DWORD)v46)
      goto LABEL_44;
    v47 = *(_QWORD **)(v44 + 8);
    v48 = &v47[2 * v46];
    do
    {
      v49 = v46 >> 1;
      v50 = &v47[2 * (v46 >> 1)];
      v52 = *v50;
      v51 = v50 + 2;
      v46 += ~(v46 >> 1);
      if (v52 < v45)
        v47 = v51;
      else
        v46 = v49;
    }
    while (v46);
    if (v47 != v48 && *v47 == v45)
      v53 = v47[1];
    else
LABEL_44:
      v53 = 0;
    v160 = v43;
    v161 = v53;
    F16Type = mlir::Builder::getF16Type(a4 + 1, v42);
    LOBYTE(v155) = 0;
    v156[0] = 0;
    mlir::ShapedType::cloneWith((uint64_t *)&v160, &v155, F16Type);
    v55 = *(_QWORD *)(v153 + 24);
    v160 = (char *)mlir::Builder::getF16Type(a4 + 1, v56);
    *(_QWORD *)&v155 = v156;
    *((_QWORD *)&v155 + 1) = 0x100000000;
    mlir::OpBuilder::createOrFold<mlir::mps::CastOp,mlir::Value &,mlir::FloatType>((uint64_t)(a4 + 1), (uint64_t)&v155, v55, &v149, (uint64_t *)&v160);
    v57 = *(_QWORD *)v155;
    if ((_BYTE *)v155 != v156)
      free((void *)v155);
    v149 = v57;
  }
  v58 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 2u);
  v59 = *((_QWORD *)a3 + 7);
  *(_QWORD *)&v155 = v59;
  *((_QWORD *)&v155 + 1) = v58;
  if (v58)
    v59 = mlir::ValueRange::offset_base(&v155, v58);
  v155 = v59;
  v160 = (char *)mlir::ValueRange::dereference_iterator(&v155, 0);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v160);
  if (!DefiningOp)
    return 0;
  v61 = DefiningOp;
  v62 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v61 + 48) + 32))(*(_QWORD *)(v61 + 48), v62))
    return 0;
  *(_QWORD *)&v155 = v156;
  *((_QWORD *)&v155 + 1) = 0x100000000;
  mlir::Operation::fold(v61, 0, 0, (uint64_t)&v155);
  v63 = (uint64_t *)(*(_QWORD *)v155 & 0xFFFFFFFFFFFFFFF8);
  v64 = mlir::DenseIntElementsAttr::classof((uint64_t)v63) & (v63 != 0);
  if (!v64)
    v63 = 0;
  if ((_BYTE *)v155 != v156)
    free((void *)v155);
  if ((v64 & 1) == 0)
    return 0;
  v165 = &v167;
  v166 = 0x100000000;
  if (!v63)
    goto LABEL_66;
  v65 = *v63;
  v66 = mlir::TypeID::get<mlir::ElementsAttr>();
  v67 = *(unsigned int *)(v65 + 16);
  if (!(_DWORD)v67)
    goto LABEL_66;
  v68 = *(_QWORD **)(v65 + 8);
  v69 = &v68[2 * v67];
  do
  {
    v70 = v67 >> 1;
    v71 = &v68[2 * (v67 >> 1)];
    v73 = *v71;
    v72 = v71 + 2;
    v67 += ~(v67 >> 1);
    if (v73 < v66)
      v68 = v72;
    else
      v67 = v70;
  }
  while (v67);
  if (v68 != v69 && *v68 == v66)
    v74 = v68[1];
  else
LABEL_66:
    v74 = 0;
  mlir::getIntValues<long long>((uint64_t)v63, v74, (uint64_t)&v165, 1);
  v163[0] = &v164;
  v163[1] = (void *)0x100000000;
  v75 = v165;
  v76 = v166;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152);
  if (mlir::getPositiveAxes(v75, v76, v77, (uint64_t)v163, 0, 0, 0))
  {
    v143 = *(_QWORD *)v163[0];
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152);
    v79 = v78;
    ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152);
    v82 = v80;
    v160 = v162;
    v161 = 0x500000000;
    if ((unint64_t)(8 * v80) < 0x29)
    {
      v83 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v160, v162, (8 * v80) >> 3, 8);
      v83 = v161;
    }
    v86 = BatchDims;
    if (v82)
    {
      memcpy(&v160[8 * v83], ArgAttrsAttr, 8 * v82);
      v83 = v161;
    }
    LODWORD(v161) = v83 + v82;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v151);
    if (v87)
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v151);
    else
      v88 = 1;
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v160, (uint64_t)&v160[8 * *(_QWORD *)v163[0]], v88 + ~(unint64_t)BatchDims, 1uLL);
    v89 = (5 - v161) & ~((5 - v161) >> 63);
    if (v161 <= 4)
      llvm::SmallVectorImpl<long long>::insert((uint64_t)&v160, (uint64_t)v160, (5 - v161) & ~((5 - v161) >> 63), 1uLL);
    v157 = v159;
    v90 = v160;
    v91 = &v160[8 * v89 + 8 * BatchDims];
    v158 = 0x500000000;
    v92 = v91 - v160;
    if ((unint64_t)(v91 - v160) < 0x29)
    {
      v93 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v157, v159, v92 >> 3, 8);
      v93 = v158;
    }
    if (v90 != v91)
    {
      memcpy((char *)v157 + 8 * v93, v90, v91 - v90);
      v93 = v158;
    }
    v94 = v93 + ((unint64_t)v92 >> 3);
    LODWORD(v158) = v94;
    if (*(_QWORD *)v163[0] - v86 >= 1)
      llvm::SmallVectorImpl<long long>::insert((uint64_t)&v157, (uint64_t)v157 + 8 * v94, *(_QWORD *)v163[0] - v86, 1uLL);
    v96 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v151);
    v97 = v95;
    *(_QWORD *)&v155 = v156;
    *((_QWORD *)&v155 + 1) = 0x600000000;
    v98 = 8 * v95;
    if ((unint64_t)(8 * v95) < 0x31)
    {
      v99 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v155, v156, (8 * v95) >> 3, 8);
      v99 = DWORD2(v155);
    }
    if (v97)
    {
      memcpy((void *)(v155 + 8 * v99), v96, v98);
      v99 = DWORD2(v155);
    }
    v100 = v99 + (v98 >> 3);
    DWORD2(v155) = v100;
    if (!v100)
    {
      if (HIDWORD(v155))
      {
        v101 = 0;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v155, v156, 1uLL, 8);
        v101 = DWORD2(v155);
      }
      *(_QWORD *)(v155 + 8 * v101) = 1;
      v100 = ++DWORD2(v155);
    }
    llvm::SmallVectorImpl<mlir::Attribute>::insert<mlir::Attribute const*,void>((uint64_t)&v157, (uint64_t)v157 + 8 * v158, (char *)(v155 + 8 * v86), (char *)(v155 + 8 * v100));
    if (v158 <= 4)
      llvm::SmallVectorImpl<long long>::insert((uint64_t)&v157, (uint64_t)v157 + 8 * v158, 5 - v158, 1uLL);
    RankPromotionTypeForANE = 1;
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
    v103 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&RankPromotionTypeForANE, 1, IntegerType, 0);
    v104 = v103;
    if (!v103)
      goto LABEL_111;
    v105 = *v103;
    v106 = mlir::TypeID::get<mlir::ShapedType>();
    v107 = *(unsigned int *)(v105 + 16);
    if (!(_DWORD)v107)
      goto LABEL_111;
    v108 = *(_QWORD **)(v105 + 8);
    v109 = &v108[2 * v107];
    do
    {
      v110 = v107 >> 1;
      v111 = &v108[2 * (v107 >> 1)];
      v113 = *v111;
      v112 = v111 + 2;
      v107 += ~(v107 >> 1);
      if (v113 < v106)
        v108 = v112;
      else
        v107 = v110;
    }
    while (v107);
    if (v108 != v109 && *v108 == v106)
      v114 = v108[1];
    else
LABEL_111:
      v114 = 0;
    v154 = ((5 - v79) & ~((5 - v79) >> 63)) + v143;
    v147 = mlir::DenseElementsAttr::getFromRawBuffer(v104, v114, &v154, 8, 8, 1, 0);
    v115 = v160;
    v116 = (mlir::AffineMap *)v161;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v152);
    v154 = mlir::MemRefType::get(v115, v116, OperandRange, 0, 0, 0);
    v118 = v157;
    v119 = (mlir::AffineMap *)v158;
    v120 = mlir::getElementTypeOrSelf(v149);
    v146 = mlir::MemRefType::get(v118, v119, v120, 0, 0, 0);
    v121 = *(_QWORD *)(v153 + 24);
    v122 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 0);
    v123 = *((_QWORD *)a3 + 7);
    RankPromotionTypeForANE = v123;
    v169 = v122;
    if (v122)
      v123 = mlir::ValueRange::offset_base(&RankPromotionTypeForANE, v122);
    RankPromotionTypeForANE = v123;
    v169 = 0;
    RankPromotionTypeForANE = mlir::ValueRange::dereference_iterator(&RankPromotionTypeForANE, 0);
    v145 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 1), v121, &v154, &RankPromotionTypeForANE)- 16;
    v149 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::MemRefType &,mlir::Value>((mlir::OpBuilder *)(a4 + 1), *(_QWORD *)(v153 + 24), &v146, &v149)- 16;
    v144 = mlir::OpBuilder::create<mlir::anec::GatherND,mlir::Value &,mlir::Value &,mlir::DenseIntElementsAttr &>(a4 + 1, *(_QWORD *)(v153 + 24), &v145, &v149, &v147);
    v124 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v150);
    v126 = v125;
    v127 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v150);
    v128 = (uint64_t *)mlir::MemRefType::get(v124, v126, v127, 0, 0, 0);
    v129 = (uint64_t)v128;
    v130 = v153;
    if (!v128)
      goto LABEL_123;
    v131 = *v128;
    v132 = mlir::TypeID::get<mlir::ShapedType>();
    v133 = *(unsigned int *)(v131 + 16);
    if (!(_DWORD)v133)
      goto LABEL_123;
    v134 = *(_QWORD **)(v131 + 8);
    v135 = &v134[2 * v133];
    do
    {
      v136 = v133 >> 1;
      v137 = &v134[2 * (v133 >> 1)];
      v139 = *v137;
      v138 = v137 + 2;
      v133 += ~(v133 >> 1);
      if (v139 < v132)
        v134 = v138;
      else
        v133 = v136;
    }
    while (v133);
    if (v134 != v135 && *v134 == v132)
      v140 = v134[1];
    else
LABEL_123:
      v140 = 0;
    RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v129, v140);
    v169 = v141;
    v142 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType,mlir::anec::GatherND &>((mlir::OpBuilder *)(a4 + 1), *(_QWORD *)(v130 + 24), &RankPromotionTypeForANE, &v144);
    (*((void (**)(mlir::Float16Type **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, v130, v142);
    if ((_BYTE *)v155 != v156)
      free((void *)v155);
    if (v157 != v159)
      free(v157);
    if (v160 != v162)
      free(v160);
    v84 = 1;
  }
  else
  {
    v84 = 0;
  }
  if (v163[0] != &v164)
    free(v163[0]);
  if (v165 != &v167)
    free(v165);
  return v84;
}

_QWORD *mlir::`anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::PixelShuffle>::~ConvertDepthToSpace2D(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::PixelShuffle>::~ConvertDepthToSpace2D(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthToSpace2DOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthToSpace2DOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[56];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::DepthToSpace2DOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DepthToSpace2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[56];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::DepthToSpace2DOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::DepthToSpace2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 56);
  v9 = *(_QWORD *)(a3 + 64);
  v36 = v8;
  v37 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v28;
      v35 = *(_QWORD *)(a3 + 64);
      v29 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthToSpace2DOp &>(mlir::mps::DepthToSpace2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v37;
    if (v36 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthToSpace2DOp &>(mlir::mps::DepthToSpace2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::PixelShuffle>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t InherentAttr;
  char v7;
  uint64_t IntegerType;
  uint64_t *v9;
  uint64_t Index;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  unint64_t v17;
  unint64_t *v18;
  _QWORD *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t Input;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  mlir::GenericProgramPoint *v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  _QWORD v37[3];
  __int128 v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v34 = a2;
  v38 = *(_OWORD *)(a3 + 56);
  if (!*(_BYTE *)(a2 + 47)
    || (InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"pixel_shuffle", 13), !v7))
  {
    if (mlir::DictionaryAttr::contains(a2 + 56, "pixel_shuffle", 0xDuLL))
      goto LABEL_4;
    return 0;
  }
  if (!InherentAttr)
    return 0;
LABEL_4:
  v35 = (void *)3;
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v35, 1, IntegerType, 0);
  Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  v11 = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  v35 = v37;
  v37[0] = Index;
  v37[1] = v11;
  v37[2] = 1;
  v36 = 0x300000003;
  if (!v9)
    goto LABEL_13;
  v12 = *v9;
  v13 = mlir::TypeID::get<mlir::ShapedType>();
  v14 = *(unsigned int *)(v12 + 16);
  if (!(_DWORD)v14)
    goto LABEL_13;
  v15 = *(_QWORD **)(v12 + 8);
  v16 = &v15[2 * v14];
  do
  {
    v17 = v14 >> 1;
    v18 = &v15[2 * (v14 >> 1)];
    v20 = *v18;
    v19 = v18 + 2;
    v14 += ~(v14 >> 1);
    if (v20 < v13)
      v15 = v19;
    else
      v14 = v17;
  }
  while (v14);
  if (v15 != v16 && *v15 == v13)
    v21 = v15[1];
  else
LABEL_13:
    v21 = 0;
  v33 = mlir::DenseElementsAttr::getFromRawBuffer(v9, v21, v35, 8 * v36, 8, 1, 0);
  v22 = v34;
  v23 = mlir::ValueRange::dereference_iterator(&v38, 0);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v34);
  v25 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v38, 1);
  v26 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v38, 2);
  v27 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v38, 3);
  {
    v28 = v34;
    v32 = mlir::ValueRange::dereference_iterator(&v38, 0);
    v29 = mlir::OpBuilder::create<mlir::anec::PixelShuffle,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(_QWORD *)(v28 + 24), &v32, &v33);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v28, v29);
    v30 = 1;
  }
  else
  {
    v30 = 0;
  }
  if (v35 != v37)
    free(v35);
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DepthToSpace2DOp &>(mlir::mps::DepthToSpace2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::`anonymous namespace'::convertDepthSpaceCommon<mlir::mps::DepthToSpace2DOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, _QWORD *a6, _QWORD *a7)
{
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t *v20;
  _QWORD *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  unint64_t v32;
  unint64_t *v33;
  _QWORD *v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t IndexFromDim;
  char v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t (*v45)(int, uint64_t);
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t (*v59)(int, uint64_t);
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64[4];
  void *__p;
  unsigned int v66;
  unint64_t SortedUniquePromotedPositiveAxesAttr;
  uint64_t v68;
  _QWORD v69[2];
  _QWORD v70[2];
  void *v71[2];
  _QWORD *v72;
  _QWORD *v73;
  _QWORD *v74;
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  v13 = (uint64_t *)(*(_QWORD *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v13)
    goto LABEL_10;
  v14 = *v13;
  v15 = mlir::TypeID::get<mlir::ShapedType>();
  v16 = *(unsigned int *)(v14 + 16);
  if (!(_DWORD)v16)
    goto LABEL_10;
  v17 = *(_QWORD **)(v14 + 8);
  v18 = &v17[2 * v16];
  do
  {
    v19 = v16 >> 1;
    v20 = &v17[2 * (v16 >> 1)];
    v22 = *v20;
    v21 = v20 + 2;
    v16 += ~(v16 >> 1);
    if (v22 < v15)
      v17 = v21;
    else
      v16 = v19;
  }
  while (v16);
  if (v17 != v18 && *v17 == v15)
    v23 = v17[1];
  else
LABEL_10:
    v23 = 0;
  v70[0] = v13;
  v70[1] = v23;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v70) & 1) == 0)
  {
    v43 = *(_QWORD *)(a2 + 16);
    if (v43 && mlir::RewriterBase::Listener::classof(v43))
    {
      v44 = *(_QWORD *)(a1 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v43 + 64))(v43, v44, v45, v71);
    }
    return 0;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v70);
  if (v24 != 4)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v70);
    if (v25 != 5)
    {
      v43 = *(_QWORD *)(a2 + 16);
      if (v43 && mlir::RewriterBase::Listener::classof(v43))
      {
        v44 = *(_QWORD *)(a1 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v43 + 64))(v43, v44, v45, v71);
      }
      return 0;
    }
  }
  v26 = (uint64_t *)(*(_QWORD *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v26)
    goto LABEL_23;
  v27 = *v26;
  v28 = mlir::TypeID::get<mlir::ShapedType>();
  v29 = *(unsigned int *)(v27 + 16);
  if (!(_DWORD)v29)
    goto LABEL_23;
  v30 = *(_QWORD **)(v27 + 8);
  v31 = &v30[2 * v29];
  do
  {
    v32 = v29 >> 1;
    v33 = &v30[2 * (v29 >> 1)];
    v35 = *v33;
    v34 = v33 + 2;
    v29 += ~(v29 >> 1);
    if (v35 < v28)
      v30 = v34;
    else
      v29 = v32;
  }
  while (v29);
  if (v30 != v31 && *v30 == v28)
    v36 = v30[1];
  else
LABEL_23:
    v36 = 0;
  v69[0] = v26;
  v69[1] = v36;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v70);
  IndexFromDim = mlir::anec::getIndexFromDim(1, v37);
  if (v39)
  {
    v40 = IndexFromDim;
    v71[0] = &v72;
    v72 = a7;
    v73 = a6;
    v74 = a5;
    v71[1] = (void *)0x300000003;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69);
    SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(a7, v41, 0, 0);
    v68 = v42;
    if (!(_BYTE)v42)
      goto LABEL_58;
    if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) != 1)
      goto LABEL_54;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
    mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&__p);
    if (v66 > 0x40)
    {
      v47 = *(_QWORD *)__p;
      operator delete[](__p);
      if (v40 != v47)
        goto LABEL_51;
    }
    else if (v40 != (uint64_t)((_QWORD)__p << -(uint64_t)v66) >> -(uint64_t)v66)
    {
      goto LABEL_51;
    }
    v48 = v73;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69);
    SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(v48, v49, 0, 0);
    v68 = v50;
    if (!(_BYTE)v50)
      goto LABEL_58;
    if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) != 1)
      goto LABEL_54;
    v51 = v40 + 1;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
    mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&__p);
    if (v66 < 0x41)
    {
      if (v51 != (uint64_t)((_QWORD)__p << -(uint64_t)v66) >> -(uint64_t)v66)
        goto LABEL_51;
LABEL_47:
      v53 = v74;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69);
      SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(v53, v54, 0, 0);
      v68 = v55;
      if ((_BYTE)v55)
      {
        if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) == 1)
        {
          v56 = v40 + 2;
          mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
          mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&__p);
          if (v66 >= 0x41)
          {
            v61 = *(_QWORD *)__p;
            operator delete[](__p);
            if (v56 != v61)
              goto LABEL_51;
          }
          else if (v56 != (uint64_t)((_QWORD)__p << -(uint64_t)v66) >> -(uint64_t)v66)
          {
            goto LABEL_51;
          }
          v46 = 1;
LABEL_59:
          if (v71[0] != &v72)
            free(v71[0]);
          return v46;
        }
LABEL_54:
        v57 = *(_QWORD *)(a2 + 16);
        if (v57 && mlir::RewriterBase::Listener::classof(v57))
        {
          v58 = *(_QWORD *)(a1 + 24);
          goto LABEL_57;
        }
      }
LABEL_58:
      v46 = 0;
      goto LABEL_59;
    }
    v52 = *(_QWORD *)__p;
    operator delete[](__p);
    if (v51 == v52)
      goto LABEL_47;
LABEL_51:
    v57 = *(_QWORD *)(a2 + 16);
    if (v57 && mlir::RewriterBase::Listener::classof(v57))
    {
      v58 = *(_QWORD *)(a1 + 24);
LABEL_57:
      v46 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(_QWORD *)v57 + 64))(v57, v58, v59, v64);
      goto LABEL_59;
    }
    goto LABEL_58;
  }
  v62 = std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::`anonymous namespace'::convertDepthSpaceCommon<mlir::mps::DepthToSpace2DOp>(mlir::mps::DepthToSpace2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::`anonymous namespace'::convertDepthSpaceCommon<mlir::mps::DepthToSpace2DOp>(mlir::mps::DepthToSpace2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, " only handling rank 4 or 5 input");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::`anonymous namespace'::convertDepthSpaceCommon<mlir::mps::DepthToSpace2DOp>(mlir::mps::DepthToSpace2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Channel <-> Space supports only 1 axis \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::`anonymous namespace'::convertDepthSpaceCommon<mlir::mps::DepthToSpace2DOp>(mlir::mps::DepthToSpace2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "only supporting NCHW in Depth <-> Space -> Channel <-> Space\n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::PixelShuffle,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.pixel_shuffle", (const unsigned __int8 *)0x12, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.pixel_shuffle";
    v17[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::PixelShuffle::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::PixelShuffle,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

_QWORD *mlir::`anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::ChannelToSpace>::~ConvertDepthToSpace2D(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::ChannelToSpace>::~ConvertDepthToSpace2D(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertDepthToSpace2D<mlir::anec::ChannelToSpace>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t InherentAttr;
  char v7;
  uint64_t v8;
  uint64_t IntegerType;
  uint64_t *v10;
  uint64_t Index;
  unsigned int v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  unint64_t *v19;
  _QWORD *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t Input;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  mlir::GenericProgramPoint *v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  _QWORD v37[3];
  __int128 v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v34 = a2;
  v38 = *(_OWORD *)(a3 + 56);
  if (*(_BYTE *)(a2 + 47) && (InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"pixel_shuffle", 13), v7))
  {
    if (InherentAttr)
      return 0;
  }
  else if ((mlir::DictionaryAttr::contains(a2 + 56, "pixel_shuffle", 0xDuLL) & 1) != 0)
  {
    return 0;
  }
  v35 = (void *)3;
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  v10 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v35, 1, IntegerType, 0);
  Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  v12 = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  v35 = v37;
  v37[0] = Index;
  v37[1] = v12;
  v37[2] = 1;
  v36 = 0x300000003;
  if (!v10)
    goto LABEL_15;
  v13 = *v10;
  v14 = mlir::TypeID::get<mlir::ShapedType>();
  v15 = *(unsigned int *)(v13 + 16);
  if (!(_DWORD)v15)
    goto LABEL_15;
  v16 = *(_QWORD **)(v13 + 8);
  v17 = &v16[2 * v15];
  do
  {
    v18 = v15 >> 1;
    v19 = &v16[2 * (v15 >> 1)];
    v21 = *v19;
    v20 = v19 + 2;
    v15 += ~(v15 >> 1);
    if (v21 < v14)
      v16 = v20;
    else
      v15 = v18;
  }
  while (v15);
  if (v16 != v17 && *v16 == v14)
    v22 = v16[1];
  else
LABEL_15:
    v22 = 0;
  v33 = mlir::DenseElementsAttr::getFromRawBuffer(v10, v22, v35, 8 * v36, 8, 1, 0);
  v23 = v34;
  v24 = mlir::ValueRange::dereference_iterator(&v38, 0);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v34);
  v26 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v38, 1);
  v27 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v38, 2);
  v28 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v38, 3);
  {
    v29 = v34;
    v32 = mlir::ValueRange::dereference_iterator(&v38, 0);
    v30 = mlir::OpBuilder::create<mlir::anec::ChannelToSpace,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(_QWORD *)(v29 + 24), &v32, &v33);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v29, v30);
    v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  if (v35 != v37)
    free(v35);
  return v8;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ChannelToSpace,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.channel_to_space", (const unsigned __int8 *)0x15, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.channel_to_space";
    v17[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ChannelToSpace::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ChannelToSpace,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

_QWORD *mlir::`anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::PixelUnshuffle>::~ConvertSpaceToDepth2D(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::PixelUnshuffle>::~ConvertSpaceToDepth2D(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToDepth2DOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToDepth2DOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[56];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SpaceToDepth2DOpGenericAdaptorBase::SpaceToDepth2DOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToDepth2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[56];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SpaceToDepth2DOpGenericAdaptorBase::SpaceToDepth2DOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SpaceToDepth2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 56);
  v9 = *(_QWORD *)(a3 + 64);
  v36 = v8;
  v37 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v28;
      v35 = *(_QWORD *)(a3 + 64);
      v29 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToDepth2DOp &>(mlir::mps::SpaceToDepth2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v37;
    if (v36 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToDepth2DOp &>(mlir::mps::SpaceToDepth2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::PixelUnshuffle>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t InherentAttr;
  char v7;
  uint64_t IntegerType;
  uint64_t *v9;
  uint64_t Index;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  unint64_t v17;
  unint64_t *v18;
  _QWORD *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t Input;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  mlir::GenericProgramPoint *v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  _QWORD v37[3];
  __int128 v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v34 = a2;
  v38 = *(_OWORD *)(a3 + 56);
  if (!*(_BYTE *)(a2 + 47)
    || (InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"pixel_shuffle", 13), !v7))
  {
    if (mlir::DictionaryAttr::contains(a2 + 56, "pixel_shuffle", 0xDuLL))
      goto LABEL_4;
    return 0;
  }
  if (!InherentAttr)
    return 0;
LABEL_4:
  v35 = (void *)3;
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v35, 1, IntegerType, 0);
  Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  v11 = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  v35 = v37;
  v37[0] = Index;
  v37[1] = v11;
  v37[2] = 1;
  v36 = 0x300000003;
  if (!v9)
    goto LABEL_13;
  v12 = *v9;
  v13 = mlir::TypeID::get<mlir::ShapedType>();
  v14 = *(unsigned int *)(v12 + 16);
  if (!(_DWORD)v14)
    goto LABEL_13;
  v15 = *(_QWORD **)(v12 + 8);
  v16 = &v15[2 * v14];
  do
  {
    v17 = v14 >> 1;
    v18 = &v15[2 * (v14 >> 1)];
    v20 = *v18;
    v19 = v18 + 2;
    v14 += ~(v14 >> 1);
    if (v20 < v13)
      v15 = v19;
    else
      v14 = v17;
  }
  while (v14);
  if (v15 != v16 && *v15 == v13)
    v21 = v15[1];
  else
LABEL_13:
    v21 = 0;
  v33 = mlir::DenseElementsAttr::getFromRawBuffer(v9, v21, v35, 8 * v36, 8, 1, 0);
  v22 = v34;
  v23 = mlir::ValueRange::dereference_iterator(&v38, 0);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v34);
  v25 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v38, 1);
  v26 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v38, 2);
  v27 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v38, 3);
  {
    v28 = v34;
    v32 = mlir::ValueRange::dereference_iterator(&v38, 0);
    v29 = mlir::OpBuilder::create<mlir::anec::PixelUnshuffle,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(_QWORD *)(v28 + 24), &v32, &v33);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v28, v29);
    v30 = 1;
  }
  else
  {
    v30 = 0;
  }
  if (v35 != v37)
    free(v35);
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToDepth2DOp &>(mlir::mps::SpaceToDepth2DOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::`anonymous namespace'::convertDepthSpaceCommon<mlir::mps::SpaceToDepth2DOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, _QWORD *a6, _QWORD *a7)
{
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t *v20;
  _QWORD *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  unint64_t v32;
  unint64_t *v33;
  _QWORD *v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t IndexFromDim;
  char v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t (*v45)(int, uint64_t);
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t (*v59)(int, uint64_t);
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64[4];
  void *__p;
  unsigned int v66;
  unint64_t SortedUniquePromotedPositiveAxesAttr;
  uint64_t v68;
  _QWORD v69[2];
  _QWORD v70[2];
  void *v71[2];
  _QWORD *v72;
  _QWORD *v73;
  _QWORD *v74;
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  v13 = (uint64_t *)(*(_QWORD *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v13)
    goto LABEL_10;
  v14 = *v13;
  v15 = mlir::TypeID::get<mlir::ShapedType>();
  v16 = *(unsigned int *)(v14 + 16);
  if (!(_DWORD)v16)
    goto LABEL_10;
  v17 = *(_QWORD **)(v14 + 8);
  v18 = &v17[2 * v16];
  do
  {
    v19 = v16 >> 1;
    v20 = &v17[2 * (v16 >> 1)];
    v22 = *v20;
    v21 = v20 + 2;
    v16 += ~(v16 >> 1);
    if (v22 < v15)
      v17 = v21;
    else
      v16 = v19;
  }
  while (v16);
  if (v17 != v18 && *v17 == v15)
    v23 = v17[1];
  else
LABEL_10:
    v23 = 0;
  v70[0] = v13;
  v70[1] = v23;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v70) & 1) == 0)
  {
    v43 = *(_QWORD *)(a2 + 16);
    if (v43 && mlir::RewriterBase::Listener::classof(v43))
    {
      v44 = *(_QWORD *)(a1 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v43 + 64))(v43, v44, v45, v71);
    }
    return 0;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v70);
  if (v24 != 4)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v70);
    if (v25 != 5)
    {
      v43 = *(_QWORD *)(a2 + 16);
      if (v43 && mlir::RewriterBase::Listener::classof(v43))
      {
        v44 = *(_QWORD *)(a1 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v43 + 64))(v43, v44, v45, v71);
      }
      return 0;
    }
  }
  v26 = (uint64_t *)(*(_QWORD *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v26)
    goto LABEL_23;
  v27 = *v26;
  v28 = mlir::TypeID::get<mlir::ShapedType>();
  v29 = *(unsigned int *)(v27 + 16);
  if (!(_DWORD)v29)
    goto LABEL_23;
  v30 = *(_QWORD **)(v27 + 8);
  v31 = &v30[2 * v29];
  do
  {
    v32 = v29 >> 1;
    v33 = &v30[2 * (v29 >> 1)];
    v35 = *v33;
    v34 = v33 + 2;
    v29 += ~(v29 >> 1);
    if (v35 < v28)
      v30 = v34;
    else
      v29 = v32;
  }
  while (v29);
  if (v30 != v31 && *v30 == v28)
    v36 = v30[1];
  else
LABEL_23:
    v36 = 0;
  v69[0] = v26;
  v69[1] = v36;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v70);
  IndexFromDim = mlir::anec::getIndexFromDim(1, v37);
  if (v39)
  {
    v40 = IndexFromDim;
    v71[0] = &v72;
    v72 = a7;
    v73 = a6;
    v74 = a5;
    v71[1] = (void *)0x300000003;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69);
    SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(a7, v41, 0, 0);
    v68 = v42;
    if (!(_BYTE)v42)
      goto LABEL_58;
    if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) != 1)
      goto LABEL_54;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
    mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&__p);
    if (v66 > 0x40)
    {
      v47 = *(_QWORD *)__p;
      operator delete[](__p);
      if (v40 != v47)
        goto LABEL_51;
    }
    else if (v40 != (uint64_t)((_QWORD)__p << -(uint64_t)v66) >> -(uint64_t)v66)
    {
      goto LABEL_51;
    }
    v48 = v73;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69);
    SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(v48, v49, 0, 0);
    v68 = v50;
    if (!(_BYTE)v50)
      goto LABEL_58;
    if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) != 1)
      goto LABEL_54;
    v51 = v40 + 1;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
    mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&__p);
    if (v66 < 0x41)
    {
      if (v51 != (uint64_t)((_QWORD)__p << -(uint64_t)v66) >> -(uint64_t)v66)
        goto LABEL_51;
LABEL_47:
      v53 = v74;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69);
      SortedUniquePromotedPositiveAxesAttr = mlir::getSortedUniquePromotedPositiveAxesAttr(v53, v54, 0, 0);
      v68 = v55;
      if ((_BYTE)v55)
      {
        if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&SortedUniquePromotedPositiveAxesAttr) == 1)
        {
          v56 = v40 + 2;
          mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v64, SortedUniquePromotedPositiveAxesAttr, 0);
          mlir::DenseElementsAttr::IntElementIterator::operator*(v64, (llvm::APInt *)&__p);
          if (v66 >= 0x41)
          {
            v61 = *(_QWORD *)__p;
            operator delete[](__p);
            if (v56 != v61)
              goto LABEL_51;
          }
          else if (v56 != (uint64_t)((_QWORD)__p << -(uint64_t)v66) >> -(uint64_t)v66)
          {
            goto LABEL_51;
          }
          v46 = 1;
LABEL_59:
          if (v71[0] != &v72)
            free(v71[0]);
          return v46;
        }
LABEL_54:
        v57 = *(_QWORD *)(a2 + 16);
        if (v57 && mlir::RewriterBase::Listener::classof(v57))
        {
          v58 = *(_QWORD *)(a1 + 24);
          goto LABEL_57;
        }
      }
LABEL_58:
      v46 = 0;
      goto LABEL_59;
    }
    v52 = *(_QWORD *)__p;
    operator delete[](__p);
    if (v51 == v52)
      goto LABEL_47;
LABEL_51:
    v57 = *(_QWORD *)(a2 + 16);
    if (v57 && mlir::RewriterBase::Listener::classof(v57))
    {
      v58 = *(_QWORD *)(a1 + 24);
LABEL_57:
      v46 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(_QWORD *)v57 + 64))(v57, v58, v59, v64);
      goto LABEL_59;
    }
    goto LABEL_58;
  }
  v62 = std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::`anonymous namespace'::convertDepthSpaceCommon<mlir::mps::SpaceToDepth2DOp>(mlir::mps::SpaceToDepth2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::`anonymous namespace'::convertDepthSpaceCommon<mlir::mps::SpaceToDepth2DOp>(mlir::mps::SpaceToDepth2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, " only handling rank 4 or 5 input");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::`anonymous namespace'::convertDepthSpaceCommon<mlir::mps::SpaceToDepth2DOp>(mlir::mps::SpaceToDepth2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Channel <-> Space supports only 1 axis \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::`anonymous namespace'::convertDepthSpaceCommon<mlir::mps::SpaceToDepth2DOp>(mlir::mps::SpaceToDepth2DOp,mlir::ConversionPatternRewriter &,mlir::Value,mlir::Value,mlir::Value,mlir::Value,mlir::Value)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "only supporting NCHW in Depth <-> Space -> Channel <-> Space\n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::PixelUnshuffle,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.pixel_unshuffle", (const unsigned __int8 *)0x14, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.pixel_unshuffle";
    v17[3] = 20;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::PixelUnshuffle::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::PixelUnshuffle,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

_QWORD *mlir::`anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::SpaceToChannel>::~ConvertSpaceToDepth2D(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::SpaceToChannel>::~ConvertSpaceToDepth2D(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertSpaceToDepth2D<mlir::anec::SpaceToChannel>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t InherentAttr;
  char v7;
  uint64_t v8;
  uint64_t IntegerType;
  uint64_t *v10;
  uint64_t Index;
  unsigned int v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  unint64_t *v19;
  _QWORD *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t Input;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  mlir::GenericProgramPoint *v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  _QWORD v37[3];
  __int128 v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v34 = a2;
  v38 = *(_OWORD *)(a3 + 56);
  if (*(_BYTE *)(a2 + 47) && (InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"pixel_shuffle", 13), v7))
  {
    if (InherentAttr)
      return 0;
  }
  else if ((mlir::DictionaryAttr::contains(a2 + 56, "pixel_shuffle", 0xDuLL) & 1) != 0)
  {
    return 0;
  }
  v35 = (void *)3;
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
  v10 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v35, 1, IntegerType, 0);
  Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  v12 = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v34);
  v35 = v37;
  v37[0] = Index;
  v37[1] = v12;
  v37[2] = 1;
  v36 = 0x300000003;
  if (!v10)
    goto LABEL_15;
  v13 = *v10;
  v14 = mlir::TypeID::get<mlir::ShapedType>();
  v15 = *(unsigned int *)(v13 + 16);
  if (!(_DWORD)v15)
    goto LABEL_15;
  v16 = *(_QWORD **)(v13 + 8);
  v17 = &v16[2 * v15];
  do
  {
    v18 = v15 >> 1;
    v19 = &v16[2 * (v15 >> 1)];
    v21 = *v19;
    v20 = v19 + 2;
    v15 += ~(v15 >> 1);
    if (v21 < v14)
      v16 = v20;
    else
      v15 = v18;
  }
  while (v15);
  if (v16 != v17 && *v16 == v14)
    v22 = v16[1];
  else
LABEL_15:
    v22 = 0;
  v33 = mlir::DenseElementsAttr::getFromRawBuffer(v10, v22, v35, 8 * v36, 8, 1, 0);
  v23 = v34;
  v24 = mlir::ValueRange::dereference_iterator(&v38, 0);
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v34);
  v26 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v38, 1);
  v27 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v38, 2);
  v28 = (_QWORD *)mlir::ValueRange::dereference_iterator(&v38, 3);
  {
    v29 = v34;
    v32 = mlir::ValueRange::dereference_iterator(&v38, 0);
    v30 = mlir::OpBuilder::create<mlir::anec::SpaceToChannel,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(_QWORD *)(v29 + 24), &v32, &v33);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v29, v30);
    v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  if (v35 != v37)
    free(v35);
  return v8;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::SpaceToChannel,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.space_to_channel", (const unsigned __int8 *)0x15, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.space_to_channel";
    v17[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::SpaceToChannel::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToChannel,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

_QWORD *mlir::`anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::~ConvertBatchToSpace(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::~ConvertBatchToSpace(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BatchToSpaceOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BatchToSpaceOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::BatchToSpaceOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BatchToSpaceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::BatchToSpaceOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::BatchToSpaceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 48);
  v9 = *(_QWORD *)(a3 + 56);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      v29 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BatchToSpaceOp &>(mlir::mps::BatchToSpaceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BatchToSpaceOp &>(mlir::mps::BatchToSpaceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5;
  char *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  unint64_t v25;
  unint64_t *v26;
  _QWORD *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  _QWORD *Filter;
  uint64_t v34;
  _QWORD *Bias;
  uint64_t v36;
  unint64_t IndexFromDim;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t (*v46)(int, uint64_t);
  uint64_t v47;
  uint64_t v48;
  uint64_t v50;
  uint64_t SparseShape;
  uint64_t v52;
  uint64_t NumElements;
  void *v54;
  int v55;
  uint64_t v56;
  BOOL v58;
  char *v59;
  uint64_t v60;
  unsigned int v61;
  void *v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  uint64_t IntegerType;
  _QWORD *v73;
  _QWORD *v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  unint64_t v80;
  unint64_t *v81;
  _QWORD *v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  mlir::GenericProgramPoint *v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92[2];
  uint64_t v93[2];
  uint64_t v94;
  uint64_t v95;
  void *v96[2];
  __int128 v97;
  __int128 v98;
  __int128 v99;
  char *v100;
  void *__p;
  uint64_t v102;
  __int128 v103;
  uint64_t v104;
  char *RankPromotionTypeForANE;
  uint64_t v106;
  _BYTE v107[24];
  __int128 v108;
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  v95 = a2;
  v108 = *(_OWORD *)(a3 + 48);
  v5 = mlir::ValueRange::dereference_iterator(&v108, 0);
  v94 = v5;
  v6 = (char *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *(_QWORD *)v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  RankPromotionTypeForANE = v6;
  v106 = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v18 = v17;
  v19 = (uint64_t *)(*(_QWORD *)(v5 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v19)
    goto LABEL_20;
  v20 = *v19;
  v21 = mlir::TypeID::get<mlir::ShapedType>();
  v22 = *(unsigned int *)(v20 + 16);
  if (!(_DWORD)v22)
    goto LABEL_20;
  v23 = *(_QWORD **)(v20 + 8);
  v24 = &v23[2 * v22];
  do
  {
    v25 = v22 >> 1;
    v26 = &v23[2 * (v22 >> 1)];
    v28 = *v26;
    v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21)
      v23 = v27;
    else
      v22 = v25;
  }
  while (v22);
  if (v23 != v24 && *v23 == v21)
    v29 = v23[1];
  else
LABEL_20:
    v29 = 0;
  RankPromotionTypeForANE = (char *)mlir::getRankPromotionTypeForANE((uint64_t)v19, v29);
  v106 = v30;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v32 = v31;
  Filter = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  v93[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Filter, v18, *(_QWORD *)(v95 + 24), 1);
  v93[1] = v34;
  if (!(_BYTE)v34)
  {
    v43 = a4[2];
    if (v43)
    {
      v47 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        v45 = *(_QWORD *)(v47 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(_QWORD *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  Bias = (_QWORD *)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v95);
  v92[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Bias, v18, *(_QWORD *)(v95 + 24), 1);
  v92[1] = v36;
  if (!(_BYTE)v36)
  {
    v43 = a4[2];
    if (v43)
    {
      v48 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        v45 = *(_QWORD *)(v48 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(_QWORD *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  IndexFromDim = mlir::anec::getIndexFromDim(0, v32);
  v38 = mlir::anec::getIndexFromDim(2, v32);
  v40 = v39;
  v91 = mlir::anec::getIndexFromDim(3, v32);
  v41 = mlir::anec::getIndexFromDim(4, v32);
  if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v92) != 1)
  {
LABEL_26:
    v43 = a4[2];
    if (v43)
    {
      v44 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        v45 = *(_QWORD *)(v44 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(_QWORD *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  v42 = mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&RankPromotionTypeForANE, v92[0], 0);
  mlir::DenseElementsAttr::IntElementIterator::operator*(v42, (llvm::APInt *)&__p);
  if (v102 >= 0x41)
  {
    v50 = *(_QWORD *)__p;
    operator delete[](__p);
    if (IndexFromDim != v50)
      goto LABEL_26;
  }
  else if (IndexFromDim != (uint64_t)((_QWORD)__p << -(uint64_t)v102) >> -(uint64_t)v102)
  {
    goto LABEL_26;
  }
  RankPromotionTypeForANE = v107;
  v106 = 0x300000000;
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v95);
  if (mlir::matchConstantWithIntVector<unsigned long long>(SparseShape, (uint64_t)&RankPromotionTypeForANE))
  {
    v89 = v41;
    v90 = v38;
    __p = &v103;
    v104 = 1;
    v103 = xmmword_181246578;
    v102 = 0x300000003;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v96, v93[0], 0);
    v98 = *(_OWORD *)v96;
    v99 = v97;
    v100 = RankPromotionTypeForANE;
    v52 = v93[0];
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v93);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v96, v52, NumElements);
    v54 = v96[0];
    v55 = LOBYTE(v96[1]);
    v56 = v97;
    v58 = (_QWORD)v99 == (_QWORD)v97 && BYTE8(v98) == LOBYTE(v96[1]) && (void *)v98 == v96[0];
    if (v58 || (v59 = &RankPromotionTypeForANE[8 * v106], v100 == v59))
    {
LABEL_84:
      *(_QWORD *)&v98 = 3;
      IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
      v73 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v98, 1, IntegerType, 0);
      v74 = v73;
      if (v73
        && (v75 = *v73, v76 = mlir::TypeID::get<mlir::ShapedType>(), v77 = *(unsigned int *)(v75 + 16), (_DWORD)v77))
      {
        v78 = *(_QWORD **)(v75 + 8);
        v79 = &v78[2 * v77];
        do
        {
          v80 = v77 >> 1;
          v81 = &v78[2 * (v77 >> 1)];
          v83 = *v81;
          v82 = v81 + 2;
          v77 += ~(v77 >> 1);
          if (v83 < v76)
            v78 = v82;
          else
            v77 = v80;
        }
        while (v77);
        if (v78 != v79 && *v78 == v76)
          v84 = v78[1];
        else
          v84 = 0;
      }
      else
      {
        v84 = 0;
      }
      v40 = 1;
      *(_QWORD *)&v98 = mlir::DenseElementsAttr::getFromRawBuffer(v74, v84, __p, 8 * v102, 8, 1, 0);
      v87 = v95;
      v88 = mlir::OpBuilder::create<mlir::anec::BatchToSpace,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, *(_QWORD *)(v95 + 24), &v94, (uint64_t *)&v98);
      (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v87, v88);
    }
    else
    {
      v60 = v40;
      while (1)
      {
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v98, (llvm::APInt *)v96);
        v61 = v96[1];
        v62 = v96[0];
        if (v60
          && (LODWORD(v96[1]) > 0x40
            ? (v63 = *(_QWORD *)v96[0])
            : (v63 = (uint64_t)v96[0] << -LOBYTE(v96[1]) >> -LOBYTE(v96[1])),
              v63 == v90))
        {
          *((_QWORD *)__p + 2) = *(_QWORD *)v100;
          v64 = 1;
        }
        else
        {
          v65 = LODWORD(v96[1]) > 0x40 ? *(_QWORD *)v96[0] : (uint64_t)v96[0] << -LOBYTE(v96[1]) >> -LOBYTE(v96[1]);
          if (v65 == v91)
          {
            *((_QWORD *)__p + 1) = *(_QWORD *)v100;
            v64 = 1;
          }
          else
          {
            v66 = *(_QWORD *)v100;
            if (v65 == v89)
            {
              *(_QWORD *)__p = v66;
              v64 = 1;
            }
            else if (v66 == 1)
            {
              v64 = 1;
            }
            else
            {
              v40 = a4[2];
              if (v40)
              {
                v67 = v95;
                if (mlir::RewriterBase::Listener::classof(a4[2]))
                else
                  v40 = 0;
              }
              v64 = 0;
            }
          }
        }
        if (v61 >= 0x41 && v62)
          operator delete[](v62);
        if (!v64)
          break;
        v68 = v100 + 8;
        *(_QWORD *)&v99 = v99 + 1;
        v100 += 8;
        if ((_QWORD)v99 == v56 && BYTE8(v98) == v55 && (_QWORD)v98 == (_QWORD)v54 || v68 == v59)
          goto LABEL_84;
      }
    }
    if (__p != &v103)
      free(__p);
  }
  else
  {
    v85 = a4[2];
    if (v85 && (v86 = v95, mlir::RewriterBase::Listener::classof(v85)))
    else
      v40 = 0;
  }
  if (RankPromotionTypeForANE != v107)
    free(RankPromotionTypeForANE);
  return v40;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BatchToSpaceOp &>(mlir::mps::BatchToSpaceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(mlir::mps::BatchToSpaceOp,mlir::mps::BatchToSpaceOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace spatial_axis operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(mlir::mps::BatchToSpaceOp,mlir::mps::BatchToSpaceOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace batch_axis operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(mlir::mps::BatchToSpaceOp,mlir::mps::BatchToSpaceOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace batch_axis operand must match with ANEC batch axis\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(mlir::mps::BatchToSpaceOp,mlir::mps::BatchToSpaceOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace block_dimensions operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBatchToSpace<mlir::mps::BatchToSpaceOp,mlir::anec::BatchToSpace>::matchAndRewriteWithStaticShapes(mlir::mps::BatchToSpaceOp,mlir::mps::BatchToSpaceOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace spatial_axes operand must match with ANEC spatial axes\n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::BatchToSpace,mlir::Value &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.batch_to_space", (const unsigned __int8 *)0x13, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.batch_to_space";
    v17[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::BatchToSpace::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::BatchToSpace,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

_QWORD *mlir::`anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::~ConvertBatchToSpace(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::~ConvertBatchToSpace(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToBatchOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToBatchOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SpaceToBatchOpGenericAdaptorBase::SpaceToBatchOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SpaceToBatchOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SpaceToBatchOpGenericAdaptorBase::SpaceToBatchOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SpaceToBatchOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 48);
  v9 = *(_QWORD *)(a3 + 56);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      v29 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToBatchOp &>(mlir::mps::SpaceToBatchOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToBatchOp &>(mlir::mps::SpaceToBatchOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5;
  char *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  unint64_t v25;
  unint64_t *v26;
  _QWORD *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  _QWORD *Filter;
  uint64_t v34;
  _QWORD *Bias;
  uint64_t v36;
  unint64_t IndexFromDim;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t (*v46)(int, uint64_t);
  uint64_t v47;
  uint64_t v48;
  uint64_t v50;
  uint64_t SparseShape;
  uint64_t v52;
  uint64_t NumElements;
  void *v54;
  int v55;
  uint64_t v56;
  BOOL v58;
  char *v59;
  uint64_t v60;
  unsigned int v61;
  void *v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  uint64_t IntegerType;
  _QWORD *v73;
  _QWORD *v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  unint64_t v80;
  unint64_t *v81;
  _QWORD *v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  mlir::GenericProgramPoint *v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92[2];
  uint64_t v93[2];
  uint64_t v94;
  uint64_t v95;
  void *v96[2];
  __int128 v97;
  __int128 v98;
  __int128 v99;
  char *v100;
  void *__p;
  uint64_t v102;
  __int128 v103;
  uint64_t v104;
  char *RankPromotionTypeForANE;
  uint64_t v106;
  _BYTE v107[24];
  __int128 v108;
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  v95 = a2;
  v108 = *(_OWORD *)(a3 + 48);
  v5 = mlir::ValueRange::dereference_iterator(&v108, 0);
  v94 = v5;
  v6 = (char *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *(_QWORD *)v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  RankPromotionTypeForANE = v6;
  v106 = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v18 = v17;
  v19 = (uint64_t *)(*(_QWORD *)(v5 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v19)
    goto LABEL_20;
  v20 = *v19;
  v21 = mlir::TypeID::get<mlir::ShapedType>();
  v22 = *(unsigned int *)(v20 + 16);
  if (!(_DWORD)v22)
    goto LABEL_20;
  v23 = *(_QWORD **)(v20 + 8);
  v24 = &v23[2 * v22];
  do
  {
    v25 = v22 >> 1;
    v26 = &v23[2 * (v22 >> 1)];
    v28 = *v26;
    v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21)
      v23 = v27;
    else
      v22 = v25;
  }
  while (v22);
  if (v23 != v24 && *v23 == v21)
    v29 = v23[1];
  else
LABEL_20:
    v29 = 0;
  RankPromotionTypeForANE = (char *)mlir::getRankPromotionTypeForANE((uint64_t)v19, v29);
  v106 = v30;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  v32 = v31;
  Filter = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v95);
  v93[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Filter, v18, *(_QWORD *)(v95 + 24), 1);
  v93[1] = v34;
  if (!(_BYTE)v34)
  {
    v43 = a4[2];
    if (v43)
    {
      v47 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        v45 = *(_QWORD *)(v47 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(_QWORD *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  Bias = (_QWORD *)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v95);
  v92[0] = mlir::getSortedUniquePromotedPositiveAxesAttr(Bias, v18, *(_QWORD *)(v95 + 24), 1);
  v92[1] = v36;
  if (!(_BYTE)v36)
  {
    v43 = a4[2];
    if (v43)
    {
      v48 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        v45 = *(_QWORD *)(v48 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(_QWORD *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  IndexFromDim = mlir::anec::getIndexFromDim(0, v32);
  v38 = mlir::anec::getIndexFromDim(2, v32);
  v40 = v39;
  v91 = mlir::anec::getIndexFromDim(3, v32);
  v41 = mlir::anec::getIndexFromDim(4, v32);
  if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v92) != 1)
  {
LABEL_26:
    v43 = a4[2];
    if (v43)
    {
      v44 = v95;
      if (mlir::RewriterBase::Listener::classof(v43))
      {
        v45 = *(_QWORD *)(v44 + 24);
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), char **))(*(_QWORD *)v43 + 64))(v43, v45, v46, &RankPromotionTypeForANE);
      }
    }
    return 0;
  }
  v42 = mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&RankPromotionTypeForANE, v92[0], 0);
  mlir::DenseElementsAttr::IntElementIterator::operator*(v42, (llvm::APInt *)&__p);
  if (v102 >= 0x41)
  {
    v50 = *(_QWORD *)__p;
    operator delete[](__p);
    if (IndexFromDim != v50)
      goto LABEL_26;
  }
  else if (IndexFromDim != (uint64_t)((_QWORD)__p << -(uint64_t)v102) >> -(uint64_t)v102)
  {
    goto LABEL_26;
  }
  RankPromotionTypeForANE = v107;
  v106 = 0x300000000;
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v95);
  if (mlir::matchConstantWithIntVector<unsigned long long>(SparseShape, (uint64_t)&RankPromotionTypeForANE))
  {
    v89 = v41;
    v90 = v38;
    __p = &v103;
    v104 = 1;
    v103 = xmmword_181246578;
    v102 = 0x300000003;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v96, v93[0], 0);
    v98 = *(_OWORD *)v96;
    v99 = v97;
    v100 = RankPromotionTypeForANE;
    v52 = v93[0];
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v93);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(v96, v52, NumElements);
    v54 = v96[0];
    v55 = LOBYTE(v96[1]);
    v56 = v97;
    v58 = (_QWORD)v99 == (_QWORD)v97 && BYTE8(v98) == LOBYTE(v96[1]) && (void *)v98 == v96[0];
    if (v58 || (v59 = &RankPromotionTypeForANE[8 * v106], v100 == v59))
    {
LABEL_84:
      *(_QWORD *)&v98 = 3;
      IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x40u, 0);
      v73 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v98, 1, IntegerType, 0);
      v74 = v73;
      if (v73
        && (v75 = *v73, v76 = mlir::TypeID::get<mlir::ShapedType>(), v77 = *(unsigned int *)(v75 + 16), (_DWORD)v77))
      {
        v78 = *(_QWORD **)(v75 + 8);
        v79 = &v78[2 * v77];
        do
        {
          v80 = v77 >> 1;
          v81 = &v78[2 * (v77 >> 1)];
          v83 = *v81;
          v82 = v81 + 2;
          v77 += ~(v77 >> 1);
          if (v83 < v76)
            v78 = v82;
          else
            v77 = v80;
        }
        while (v77);
        if (v78 != v79 && *v78 == v76)
          v84 = v78[1];
        else
          v84 = 0;
      }
      else
      {
        v84 = 0;
      }
      v40 = 1;
      *(_QWORD *)&v98 = mlir::DenseElementsAttr::getFromRawBuffer(v74, v84, __p, 8 * v102, 8, 1, 0);
      v87 = v95;
      v88 = mlir::OpBuilder::create<mlir::anec::SpaceToBatch,mlir::Value &,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)a4 + 1, *(_QWORD *)(v95 + 24), &v94, (uint64_t *)&v98);
      (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v87, v88);
    }
    else
    {
      v60 = v40;
      while (1)
      {
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v98, (llvm::APInt *)v96);
        v61 = v96[1];
        v62 = v96[0];
        if (v60
          && (LODWORD(v96[1]) > 0x40
            ? (v63 = *(_QWORD *)v96[0])
            : (v63 = (uint64_t)v96[0] << -LOBYTE(v96[1]) >> -LOBYTE(v96[1])),
              v63 == v90))
        {
          *((_QWORD *)__p + 2) = *(_QWORD *)v100;
          v64 = 1;
        }
        else
        {
          v65 = LODWORD(v96[1]) > 0x40 ? *(_QWORD *)v96[0] : (uint64_t)v96[0] << -LOBYTE(v96[1]) >> -LOBYTE(v96[1]);
          if (v65 == v91)
          {
            *((_QWORD *)__p + 1) = *(_QWORD *)v100;
            v64 = 1;
          }
          else
          {
            v66 = *(_QWORD *)v100;
            if (v65 == v89)
            {
              *(_QWORD *)__p = v66;
              v64 = 1;
            }
            else if (v66 == 1)
            {
              v64 = 1;
            }
            else
            {
              v40 = a4[2];
              if (v40)
              {
                v67 = v95;
                if (mlir::RewriterBase::Listener::classof(a4[2]))
                else
                  v40 = 0;
              }
              v64 = 0;
            }
          }
        }
        if (v61 >= 0x41 && v62)
          operator delete[](v62);
        if (!v64)
          break;
        v68 = v100 + 8;
        *(_QWORD *)&v99 = v99 + 1;
        v100 += 8;
        if ((_QWORD)v99 == v56 && BYTE8(v98) == v55 && (_QWORD)v98 == (_QWORD)v54 || v68 == v59)
          goto LABEL_84;
      }
    }
    if (__p != &v103)
      free(__p);
  }
  else
  {
    v85 = a4[2];
    if (v85 && (v86 = v95, mlir::RewriterBase::Listener::classof(v85)))
    else
      v40 = 0;
  }
  if (RankPromotionTypeForANE != v107)
    free(RankPromotionTypeForANE);
  return v40;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SpaceToBatchOp &>(mlir::mps::SpaceToBatchOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(mlir::mps::SpaceToBatchOp,mlir::mps::SpaceToBatchOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace spatial_axis operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(mlir::mps::SpaceToBatchOp,mlir::mps::SpaceToBatchOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace batch_axis operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(mlir::mps::SpaceToBatchOp,mlir::mps::SpaceToBatchOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace batch_axis operand must match with ANEC batch axis\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(mlir::mps::SpaceToBatchOp,mlir::mps::SpaceToBatchOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace block_dimensions operand must be constant\n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBatchToSpace<mlir::mps::SpaceToBatchOp,mlir::anec::SpaceToBatch>::matchAndRewriteWithStaticShapes(mlir::mps::SpaceToBatchOp,mlir::mps::SpaceToBatchOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "BatchToSpace spatial_axes operand must match with ANEC spatial axes\n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::SpaceToBatch,mlir::Value &,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.space_to_batch", (const unsigned __int8 *)0x13, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.space_to_batch";
    v17[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::SpaceToBatch::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToBatch,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

_QWORD *mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)0>::~ConvertTranspose(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)0>::~ConvertTranspose(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::TransposeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::TransposeOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::TransposeOpGenericAdaptorBase::TransposeOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::TransposeOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::TransposeOpGenericAdaptorBase::TransposeOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::TransposeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TransposeOp &>(mlir::mps::TransposeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TransposeOp &>(mlir::mps::TransposeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned int ODSOperandIndexAndLength;
  void *v20;
  uint64_t v21;
  unsigned int v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  mlir::GenericProgramPoint *v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  _QWORD v36[2];
  uint64_t v37;
  void *v38[2];
  _BYTE v39[48];
  void *v40;
  uint64_t v41;
  uint64_t v42[6];
  void *v43[2];
  uint64_t v44;
  void *v45[2];
  uint64_t v46;
  __int128 v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v37 = a2;
  v47 = *(_OWORD *)(a3 + 40);
  v6 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
  v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 1u);
  v20 = *(void **)(a3 + 40);
  v40 = v20;
  v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  v40 = v20;
  v41 = 0;
  v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45))
    goto LABEL_23;
  v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 2u);
  v23 = *(void **)(a3 + 40);
  v40 = v23;
  v41 = v22;
  if (v22)
    v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  v40 = v23;
  v41 = 0;
  v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    v25 = *(_QWORD *)v45[0];
    v26 = *(_QWORD *)v43[0];
    v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      v27 = v37;
      v28 = *(_QWORD *)v38[0];
      v34 = *((_QWORD *)v38[0] + 1);
      v35 = (uint64_t *)v28;
      v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(_QWORD *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(_QWORD *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v27, v29);
      v30 = 1;
    }
    else
    {
      v32 = v37;
      v35 = &v37;
      v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30))
        else
          v30 = 0;
      }
    }
    if (v38[0] != v39)
      free(v38[0]);
    if (v40 != v42)
      free(v40);
  }
  else
  {
LABEL_23:
    v30 = 0;
  }
  if (v43[0] != &v44)
    free(v43[0]);
  if (v45[0] != &v46)
    free(v45[0]);
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TransposeOp &>(mlir::mps::TransposeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)1>::~ConvertTranspose(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)1>::~ConvertTranspose(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned int ODSOperandIndexAndLength;
  void *v20;
  uint64_t v21;
  unsigned int v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  mlir::GenericProgramPoint *v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  _QWORD v36[2];
  uint64_t v37;
  void *v38[2];
  _BYTE v39[48];
  void *v40;
  uint64_t v41;
  uint64_t v42[6];
  void *v43[2];
  uint64_t v44;
  void *v45[2];
  uint64_t v46;
  __int128 v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v37 = a2;
  v47 = *(_OWORD *)(a3 + 40);
  v6 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
  v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 1u);
  v20 = *(void **)(a3 + 40);
  v40 = v20;
  v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  v40 = v20;
  v41 = 0;
  v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45))
    goto LABEL_23;
  v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 2u);
  v23 = *(void **)(a3 + 40);
  v40 = v23;
  v41 = v22;
  if (v22)
    v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  v40 = v23;
  v41 = 0;
  v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    v25 = *(_QWORD *)v45[0];
    v26 = *(_QWORD *)v43[0];
    v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      v27 = v37;
      v28 = *(_QWORD *)v38[0];
      v34 = *((_QWORD *)v38[0] + 1);
      v35 = (uint64_t *)v28;
      v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(_QWORD *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(_QWORD *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v27, v29);
      v30 = 1;
    }
    else
    {
      v32 = v37;
      v35 = &v37;
      v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30))
        else
          v30 = 0;
      }
    }
    if (v38[0] != v39)
      free(v38[0]);
    if (v40 != v42)
      free(v40);
  }
  else
  {
LABEL_23:
    v30 = 0;
  }
  if (v43[0] != &v44)
    free(v43[0]);
  if (v45[0] != &v46)
    free(v45[0]);
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)2>::~ConvertTranspose(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)2>::~ConvertTranspose(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned int ODSOperandIndexAndLength;
  void *v20;
  uint64_t v21;
  unsigned int v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  mlir::GenericProgramPoint *v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  _QWORD v36[2];
  uint64_t v37;
  void *v38[2];
  _BYTE v39[48];
  void *v40;
  uint64_t v41;
  uint64_t v42[6];
  void *v43[2];
  uint64_t v44;
  void *v45[2];
  uint64_t v46;
  __int128 v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v37 = a2;
  v47 = *(_OWORD *)(a3 + 40);
  v6 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
  v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 1u);
  v20 = *(void **)(a3 + 40);
  v40 = v20;
  v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  v40 = v20;
  v41 = 0;
  v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45))
    goto LABEL_23;
  v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 2u);
  v23 = *(void **)(a3 + 40);
  v40 = v23;
  v41 = v22;
  if (v22)
    v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  v40 = v23;
  v41 = 0;
  v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    v25 = *(_QWORD *)v45[0];
    v26 = *(_QWORD *)v43[0];
    v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      v27 = v37;
      v28 = *(_QWORD *)v38[0];
      v34 = *((_QWORD *)v38[0] + 1);
      v35 = (uint64_t *)v28;
      v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(_QWORD *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(_QWORD *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v27, v29);
      v30 = 1;
    }
    else
    {
      v32 = v37;
      v35 = &v37;
      v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30))
        else
          v30 = 0;
      }
    }
    if (v38[0] != v39)
      free(v38[0]);
    if (v40 != v42)
      free(v40);
  }
  else
  {
LABEL_23:
    v30 = 0;
  }
  if (v43[0] != &v44)
    free(v43[0]);
  if (v45[0] != &v46)
    free(v45[0]);
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)3>::~ConvertTranspose(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)3>::~ConvertTranspose(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned int ODSOperandIndexAndLength;
  void *v20;
  uint64_t v21;
  unsigned int v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  mlir::GenericProgramPoint *v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  _QWORD v36[2];
  uint64_t v37;
  void *v38[2];
  _BYTE v39[48];
  void *v40;
  uint64_t v41;
  uint64_t v42[6];
  void *v43[2];
  uint64_t v44;
  void *v45[2];
  uint64_t v46;
  __int128 v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v37 = a2;
  v47 = *(_OWORD *)(a3 + 40);
  v6 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
  v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 1u);
  v20 = *(void **)(a3 + 40);
  v40 = v20;
  v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  v40 = v20;
  v41 = 0;
  v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45))
    goto LABEL_23;
  v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 2u);
  v23 = *(void **)(a3 + 40);
  v40 = v23;
  v41 = v22;
  if (v22)
    v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  v40 = v23;
  v41 = 0;
  v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    v25 = *(_QWORD *)v45[0];
    v26 = *(_QWORD *)v43[0];
    v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      v27 = v37;
      v28 = *(_QWORD *)v38[0];
      v34 = *((_QWORD *)v38[0] + 1);
      v35 = (uint64_t *)v28;
      v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(_QWORD *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(_QWORD *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v27, v29);
      v30 = 1;
    }
    else
    {
      v32 = v37;
      v35 = &v37;
      v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30))
        else
          v30 = 0;
      }
    }
    if (v38[0] != v39)
      free(v38[0]);
    if (v40 != v42)
      free(v40);
  }
  else
  {
LABEL_23:
    v30 = 0;
  }
  if (v43[0] != &v44)
    free(v43[0]);
  if (v45[0] != &v46)
    free(v45[0]);
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)4>::~ConvertTranspose(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)4>::~ConvertTranspose(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned int ODSOperandIndexAndLength;
  void *v20;
  uint64_t v21;
  unsigned int v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  mlir::GenericProgramPoint *v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  _QWORD v36[2];
  uint64_t v37;
  void *v38[2];
  _BYTE v39[48];
  void *v40;
  uint64_t v41;
  uint64_t v42[6];
  void *v43[2];
  uint64_t v44;
  void *v45[2];
  uint64_t v46;
  __int128 v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v37 = a2;
  v47 = *(_OWORD *)(a3 + 40);
  v6 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
  v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 1u);
  v20 = *(void **)(a3 + 40);
  v40 = v20;
  v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  v40 = v20;
  v41 = 0;
  v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45))
    goto LABEL_23;
  v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 2u);
  v23 = *(void **)(a3 + 40);
  v40 = v23;
  v41 = v22;
  if (v22)
    v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  v40 = v23;
  v41 = 0;
  v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    v25 = *(_QWORD *)v45[0];
    v26 = *(_QWORD *)v43[0];
    v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      v27 = v37;
      v28 = *(_QWORD *)v38[0];
      v34 = *((_QWORD *)v38[0] + 1);
      v35 = (uint64_t *)v28;
      v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(_QWORD *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(_QWORD *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v27, v29);
      v30 = 1;
    }
    else
    {
      v32 = v37;
      v35 = &v37;
      v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30))
        else
          v30 = 0;
      }
    }
    if (v38[0] != v39)
      free(v38[0]);
    if (v40 != v42)
      free(v40);
  }
  else
  {
LABEL_23:
    v30 = 0;
  }
  if (v43[0] != &v44)
    free(v43[0]);
  if (v45[0] != &v46)
    free(v45[0]);
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)5>::~ConvertTranspose(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)5>::~ConvertTranspose(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned int ODSOperandIndexAndLength;
  void *v20;
  uint64_t v21;
  unsigned int v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  mlir::GenericProgramPoint *v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  _QWORD v36[2];
  uint64_t v37;
  void *v38[2];
  _BYTE v39[48];
  void *v40;
  uint64_t v41;
  uint64_t v42[6];
  void *v43[2];
  uint64_t v44;
  void *v45[2];
  uint64_t v46;
  __int128 v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v37 = a2;
  v47 = *(_OWORD *)(a3 + 40);
  v6 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
  v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 1u);
  v20 = *(void **)(a3 + 40);
  v40 = v20;
  v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  v40 = v20;
  v41 = 0;
  v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45))
    goto LABEL_23;
  v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 2u);
  v23 = *(void **)(a3 + 40);
  v40 = v23;
  v41 = v22;
  if (v22)
    v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  v40 = v23;
  v41 = 0;
  v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    v25 = *(_QWORD *)v45[0];
    v26 = *(_QWORD *)v43[0];
    v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      v27 = v37;
      v28 = *(_QWORD *)v38[0];
      v34 = *((_QWORD *)v38[0] + 1);
      v35 = (uint64_t *)v28;
      v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(_QWORD *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(_QWORD *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v27, v29);
      v30 = 1;
    }
    else
    {
      v32 = v37;
      v35 = &v37;
      v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30))
        else
          v30 = 0;
      }
    }
    if (v38[0] != v39)
      free(v38[0]);
    if (v40 != v42)
      free(v40);
  }
  else
  {
LABEL_23:
    v30 = 0;
  }
  if (v43[0] != &v44)
    free(v43[0]);
  if (v45[0] != &v46)
    free(v45[0]);
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)6>::~ConvertTranspose(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)6>::~ConvertTranspose(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned int ODSOperandIndexAndLength;
  void *v20;
  uint64_t v21;
  unsigned int v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  mlir::GenericProgramPoint *v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  _QWORD v36[2];
  uint64_t v37;
  void *v38[2];
  _BYTE v39[48];
  void *v40;
  uint64_t v41;
  uint64_t v42[6];
  void *v43[2];
  uint64_t v44;
  void *v45[2];
  uint64_t v46;
  __int128 v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v37 = a2;
  v47 = *(_OWORD *)(a3 + 40);
  v6 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
  v18 = v17;
  v45[0] = &v46;
  v45[1] = (void *)0x100000000;
  v43[0] = &v44;
  v43[1] = (void *)0x100000000;
  ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 1u);
  v20 = *(void **)(a3 + 40);
  v40 = v20;
  v41 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v20 = (void *)mlir::ValueRange::offset_base(&v40, ODSOperandIndexAndLength);
  v40 = v20;
  v41 = 0;
  v21 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (!mlir::matchConstantWithIntVector<long long>(v21, (uint64_t)v45))
    goto LABEL_23;
  v22 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)a3, 2u);
  v23 = *(void **)(a3 + 40);
  v40 = v23;
  v41 = v22;
  if (v22)
    v23 = (void *)mlir::ValueRange::offset_base(&v40, v22);
  v40 = v23;
  v41 = 0;
  v24 = mlir::ValueRange::dereference_iterator(&v40, 0);
  if (mlir::matchConstantWithIntVector<long long>(v24, (uint64_t)v43))
  {
    v25 = *(_QWORD *)v45[0];
    v26 = *(_QWORD *)v43[0];
    v40 = v42;
    v42[0] = v25;
    v42[1] = v26;
    v41 = 0x600000002;
    v38[0] = v39;
    v38[1] = (void *)0x600000000;
    if (mlir::getPositivePromotedAxes(v42, 2, v18, (uint64_t)v38, 0, 0))
    {
      v27 = v37;
      v28 = *(_QWORD *)v38[0];
      v34 = *((_QWORD *)v38[0] + 1);
      v35 = (uint64_t *)v28;
      v33 = mlir::ValueRange::dereference_iterator(&v47, 0);
      v29 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value &,unsigned long long &,unsigned long long &>((mlir::Builder *)(a4 + 1), *(_QWORD *)(v27 + 24), &v33, (uint64_t *)&v35, &v34);
      (*(void (**)(_QWORD *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, v27, v29);
      v30 = 1;
    }
    else
    {
      v32 = v37;
      v35 = &v37;
      v30 = a4[2];
      if (v30)
      {
        if (mlir::RewriterBase::Listener::classof(v30))
        else
          v30 = 0;
      }
    }
    if (v38[0] != v39)
      free(v38[0]);
    if (v40 != v42)
      free(v40);
  }
  else
  {
LABEL_23:
    v30 = 0;
  }
  if (v43[0] != &v44)
    free(v43[0]);
  if (v45[0] != &v46)
    free(v45[0]);
  return v30;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertTranspose<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::TransposeOp,mlir::mps::TransposeOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract positive axes from Op ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::~ConvertBroadcast(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::~ConvertBroadcast(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BroadcastToOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BroadcastToOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::BroadcastToOpGenericAdaptorBase::BroadcastToOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BroadcastToOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::BroadcastToOpGenericAdaptorBase::BroadcastToOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::BroadcastToOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BroadcastToOp &>(mlir::mps::BroadcastToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BroadcastToOp &>(mlir::mps::BroadcastToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, mlir::UnknownLoc **a4)
{
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  unint64_t v25;
  unint64_t *v26;
  _QWORD *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t RankPromotionTypeForANE;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t IndexFromDim;
  unint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t ArgAttrsAttr;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  mlir::GenericProgramPoint *v46;
  mlir::GenericProgramPoint *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t (*v50)(int, uint64_t);
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t (*v54)(int, uint64_t);
  unint64_t v55;
  unint64_t v56;
  _BYTE *v57;
  size_t v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  _QWORD *v63;
  _QWORD *v64;
  uint64_t v65;
  void *v66;
  mlir::AffineMap *v67;
  uint64_t v68;
  mlir::GenericProgramPoint *v69;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73[2];
  uint64_t OperandRange;
  _QWORD *v75;
  uint64_t v76;
  _QWORD v77[2];
  _QWORD *v78[2];
  void *SplatF16ElementsAttr;
  uint64_t v80;
  _BYTE v81[40];
  void *v82;
  uint64_t v83;
  _BYTE v84[32];
  _BYTE *v85;
  uint64_t v86;
  _BYTE v87[40];
  __int128 v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  v88 = *(_OWORD *)(a3 + 40);
  v6 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v88, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v75 = v6;
  v76 = v16;
  v85 = v87;
  v86 = 0x500000000;
  v17 = mlir::ValueRange::dereference_iterator(&v88, 1);
  if (!mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v85))
  {
    v48 = (uint64_t)a4[2];
    if (v48 && mlir::RewriterBase::Listener::classof(v48))
    {
      v49 = *(_QWORD *)(a2 + 24);
LABEL_35:
      v51 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v48 + 64))(v48, v49, v50, &SplatF16ElementsAttr);
      goto LABEL_57;
    }
LABEL_36:
    v51 = 0;
    goto LABEL_57;
  }
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v75);
  v18 = (uint64_t *)mlir::MemRefType::get(v85, (mlir::AffineMap *)v86, OperandRange, 0, 0, 0);
  v19 = (uint64_t)v18;
  if (!v18)
    goto LABEL_21;
  v20 = *v18;
  v21 = mlir::TypeID::get<mlir::ShapedType>();
  v22 = *(unsigned int *)(v20 + 16);
  if (!(_DWORD)v22)
    goto LABEL_21;
  v23 = *(_QWORD **)(v20 + 8);
  v24 = &v23[2 * v22];
  do
  {
    v25 = v22 >> 1;
    v26 = &v23[2 * (v22 >> 1)];
    v28 = *v26;
    v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21)
      v23 = v27;
    else
      v22 = v25;
  }
  while (v22);
  if (v23 != v24 && *v23 == v21)
    v29 = v23[1];
  else
LABEL_21:
    v29 = 0;
  RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v19, v29);
  v32 = v31;
  v73[0] = RankPromotionTypeForANE;
  v73[1] = v31;
  if (!mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    v48 = (uint64_t)a4[2];
    if (v48 && mlir::RewriterBase::Listener::classof(v48))
    {
      v49 = *(_QWORD *)(a2 + 24);
      goto LABEL_35;
    }
    goto LABEL_36;
  }
  v33 = mlir::getRankPromotionTypeForANE((uint64_t)v75, v76);
  v82 = v84;
  v83 = 0x400000000;
  if (mlir::getBroadcastIndices(v33, v34, RankPromotionTypeForANE, v32, (uint64_t)&v82))
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
    IndexFromDim = mlir::anec::getIndexFromDim(4, v35);
    if ((_DWORD)v83)
    {
      v37 = IndexFromDim;
      v38 = v82;
      v39 = 8 * v83;
      while (IndexFromDim != *v38)
      {
        ++v38;
        v39 -= 8;
        if (!v39)
        {
          v72 = mlir::ValueRange::dereference_iterator(&v88, 0);
          ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
          v42 = v41;
          v43 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          v44 = (_QWORD *)mlir::RankedTensorType::get(ArgAttrsAttr, v42, v43, 0);
          SplatF16ElementsAttr = mlir::createSplatF16ElementsAttr(v44, 0.0);
          v80 = v45;
          v46 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), *(_QWORD *)(a2 + 24), v73, (_QWORD **)&SplatF16ElementsAttr);
          v77[0] = mlir::ValueRange::dereference_iterator(&v88, 0);
          v77[1] = (char *)v46 - 16;
          mlir::ValueRange::ValueRange((unint64_t *)v78, (uint64_t)v77, 2uLL);
          v47 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::ValueRange>((uint64_t *)a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)v78);
          (*((void (**)(mlir::UnknownLoc **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, a2, v47);
          goto LABEL_54;
        }
      }
      v72 = mlir::ValueRange::dereference_iterator(&v88, 0);
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
      v56 = v55;
      SplatF16ElementsAttr = v81;
      HIDWORD(v80) = 5;
      if (v55 < 6)
      {
        if (!v55)
        {
LABEL_52:
          LODWORD(v80) = v56;
          v59 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
          v60 = SplatF16ElementsAttr;
          *((_QWORD *)SplatF16ElementsAttr + v37) = *(_QWORD *)(v59 + 8 * v37);
          v61 = v80;
          v62 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          v63 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v60, v61, v62, 0);
          v78[0] = mlir::createSplatF16ElementsAttr(v63, 1.0);
          v78[1] = v64;
          v65 = *(_QWORD *)(a2 + 24);
          v66 = SplatF16ElementsAttr;
          v67 = (mlir::AffineMap *)v80;
          v68 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          v71 = mlir::MemRefType::get(v66, v67, v68, 0, 0, 0);
          v77[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v65, &v71, v78);
          v71 = 0;
          v69 = mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::mps::ConstantOp &,decltype(nullptr)>(a4 + 1, *(_QWORD *)(a2 + 24), &v72, v77);
          (*((void (**)(mlir::UnknownLoc **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, a2, v69);
          if (SplatF16ElementsAttr != v81)
            free(SplatF16ElementsAttr);
LABEL_54:
          v51 = 1;
          goto LABEL_55;
        }
        v58 = 8 * v55;
        v57 = v81;
      }
      else
      {
        LODWORD(v80) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&SplatF16ElementsAttr, v81, v55, 8);
        v57 = SplatF16ElementsAttr;
        v58 = 8 * v56;
      }
      memset_pattern16(v57, &unk_181233190, v58);
      goto LABEL_52;
    }
    v52 = (uint64_t)a4[2];
    if (v52 && mlir::RewriterBase::Listener::classof(v52))
    {
      v53 = *(_QWORD *)(a2 + 24);
      goto LABEL_44;
    }
  }
  else
  {
    v52 = (uint64_t)a4[2];
    if (v52 && mlir::RewriterBase::Listener::classof(v52))
    {
      v53 = *(_QWORD *)(a2 + 24);
LABEL_44:
      v51 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v52 + 64))(v52, v53, v54, &SplatF16ElementsAttr);
      goto LABEL_55;
    }
  }
  v51 = 0;
LABEL_55:
  if (v82 != v84)
    free(v82);
LABEL_57:
  if (v85 != v87)
    free(v85);
  return v51;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::BroadcastToOp &>(mlir::mps::BroadcastToOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Only fp16 is supported for A11/A12 Broadcasts. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unable to determine A11/A12 Broadcast. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported A11/A12 Broadcast. \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::mps::ConstantOp &,decltype(nullptr)>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.matmul", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.matmul";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::MatMul::build(a1, (uint64_t)v19, *a3, *a4 - 16, 0);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::MatMul,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::ValueRange>(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.add", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"anec.add";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::anec::Ceil::build(a1, (uint64_t)v17, *a3, a3[1], 0, 0);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

_QWORD *mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::~ConvertBroadcast(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::~ConvertBroadcast(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, mlir::UnknownLoc **a4)
{
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  unint64_t v25;
  unint64_t *v26;
  _QWORD *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t RankPromotionTypeForANE;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t IndexFromDim;
  unint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t ArgAttrsAttr;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  mlir::GenericProgramPoint *v46;
  mlir::GenericProgramPoint *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t (*v50)(int, uint64_t);
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t (*v54)(int, uint64_t);
  unint64_t v55;
  unint64_t v56;
  _BYTE *v57;
  size_t v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  _QWORD *v63;
  _QWORD *v64;
  uint64_t v65;
  void *v66;
  mlir::AffineMap *v67;
  uint64_t v68;
  mlir::GenericProgramPoint *v69;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73[2];
  uint64_t OperandRange;
  _QWORD *v75;
  uint64_t v76;
  _QWORD v77[2];
  _QWORD *v78[2];
  void *SplatF16ElementsAttr;
  uint64_t v80;
  _BYTE v81[40];
  void *v82;
  uint64_t v83;
  _BYTE v84[32];
  _BYTE *v85;
  uint64_t v86;
  _BYTE v87[40];
  __int128 v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  v88 = *(_OWORD *)(a3 + 40);
  v6 = (_QWORD *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v88, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v75 = v6;
  v76 = v16;
  v85 = v87;
  v86 = 0x500000000;
  v17 = mlir::ValueRange::dereference_iterator(&v88, 1);
  if (!mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v85))
  {
    v48 = (uint64_t)a4[2];
    if (v48 && mlir::RewriterBase::Listener::classof(v48))
    {
      v49 = *(_QWORD *)(a2 + 24);
LABEL_35:
      v51 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v48 + 64))(v48, v49, v50, &SplatF16ElementsAttr);
      goto LABEL_57;
    }
LABEL_36:
    v51 = 0;
    goto LABEL_57;
  }
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v75);
  v18 = (uint64_t *)mlir::MemRefType::get(v85, (mlir::AffineMap *)v86, OperandRange, 0, 0, 0);
  v19 = (uint64_t)v18;
  if (!v18)
    goto LABEL_21;
  v20 = *v18;
  v21 = mlir::TypeID::get<mlir::ShapedType>();
  v22 = *(unsigned int *)(v20 + 16);
  if (!(_DWORD)v22)
    goto LABEL_21;
  v23 = *(_QWORD **)(v20 + 8);
  v24 = &v23[2 * v22];
  do
  {
    v25 = v22 >> 1;
    v26 = &v23[2 * (v22 >> 1)];
    v28 = *v26;
    v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21)
      v23 = v27;
    else
      v22 = v25;
  }
  while (v22);
  if (v23 != v24 && *v23 == v21)
    v29 = v23[1];
  else
LABEL_21:
    v29 = 0;
  RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE(v19, v29);
  v32 = v31;
  v73[0] = RankPromotionTypeForANE;
  v73[1] = v31;
  if (!mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    v48 = (uint64_t)a4[2];
    if (v48 && mlir::RewriterBase::Listener::classof(v48))
    {
      v49 = *(_QWORD *)(a2 + 24);
      goto LABEL_35;
    }
    goto LABEL_36;
  }
  v33 = mlir::getRankPromotionTypeForANE((uint64_t)v75, v76);
  v82 = v84;
  v83 = 0x400000000;
  if (mlir::getBroadcastIndices(v33, v34, RankPromotionTypeForANE, v32, (uint64_t)&v82))
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
    IndexFromDim = mlir::anec::getIndexFromDim(4, v35);
    if ((_DWORD)v83)
    {
      v37 = IndexFromDim;
      v38 = v82;
      v39 = 8 * v83;
      while (IndexFromDim != *v38)
      {
        ++v38;
        v39 -= 8;
        if (!v39)
        {
          v72 = mlir::ValueRange::dereference_iterator(&v88, 0);
          ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
          v42 = v41;
          v43 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          v44 = (_QWORD *)mlir::RankedTensorType::get(ArgAttrsAttr, v42, v43, 0);
          SplatF16ElementsAttr = mlir::createSplatF16ElementsAttr(v44, 0.0);
          v80 = v45;
          v46 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), *(_QWORD *)(a2 + 24), v73, (_QWORD **)&SplatF16ElementsAttr);
          v77[0] = mlir::ValueRange::dereference_iterator(&v88, 0);
          v77[1] = (char *)v46 - 16;
          mlir::ValueRange::ValueRange((unint64_t *)v78, (uint64_t)v77, 2uLL);
          v47 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::ValueRange>((uint64_t *)a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)v78);
          (*((void (**)(mlir::UnknownLoc **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, a2, v47);
          goto LABEL_54;
        }
      }
      v72 = mlir::ValueRange::dereference_iterator(&v88, 0);
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
      v56 = v55;
      SplatF16ElementsAttr = v81;
      HIDWORD(v80) = 5;
      if (v55 < 6)
      {
        if (!v55)
        {
LABEL_52:
          LODWORD(v80) = v56;
          v59 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
          v60 = SplatF16ElementsAttr;
          *((_QWORD *)SplatF16ElementsAttr + v37) = *(_QWORD *)(v59 + 8 * v37);
          v61 = v80;
          v62 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          v63 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v60, v61, v62, 0);
          v78[0] = mlir::createSplatF16ElementsAttr(v63, 1.0);
          v78[1] = v64;
          v65 = *(_QWORD *)(a2 + 24);
          v66 = SplatF16ElementsAttr;
          v67 = (mlir::AffineMap *)v80;
          v68 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v73);
          v71 = mlir::MemRefType::get(v66, v67, v68, 0, 0, 0);
          v77[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a4 + 1), v65, &v71, v78);
          v71 = 0;
          v69 = mlir::OpBuilder::create<mlir::anec::MatMul,mlir::Value &,mlir::mps::ConstantOp &,decltype(nullptr)>(a4 + 1, *(_QWORD *)(a2 + 24), &v72, v77);
          (*((void (**)(mlir::UnknownLoc **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, a2, v69);
          if (SplatF16ElementsAttr != v81)
            free(SplatF16ElementsAttr);
LABEL_54:
          v51 = 1;
          goto LABEL_55;
        }
        v58 = 8 * v55;
        v57 = v81;
      }
      else
      {
        LODWORD(v80) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&SplatF16ElementsAttr, v81, v55, 8);
        v57 = SplatF16ElementsAttr;
        v58 = 8 * v56;
      }
      memset_pattern16(v57, &unk_181233190, v58);
      goto LABEL_52;
    }
    v52 = (uint64_t)a4[2];
    if (v52 && mlir::RewriterBase::Listener::classof(v52))
    {
      v53 = *(_QWORD *)(a2 + 24);
      goto LABEL_44;
    }
  }
  else
  {
    v52 = (uint64_t)a4[2];
    if (v52 && mlir::RewriterBase::Listener::classof(v52))
    {
      v53 = *(_QWORD *)(a2 + 24);
LABEL_44:
      v51 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v52 + 64))(v52, v53, v54, &SplatF16ElementsAttr);
      goto LABEL_55;
    }
  }
  v51 = 0;
LABEL_55:
  if (v82 != v84)
    free(v82);
LABEL_57:
  if (v85 != v87)
    free(v85);
  return v51;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Only fp16 is supported for A11/A12 Broadcasts. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unable to determine A11/A12 Broadcast. \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Unsupported A11/A12 Broadcast. \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)2>::~ConvertBroadcast(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)2>::~ConvertBroadcast(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t OperandRange;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  mlir::GenericProgramPoint *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v36;
  uint64_t v37[2];
  _QWORD v38[2];
  void *v39;
  uint64_t v40;
  _BYTE v41[40];
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v42 = *(_OWORD *)(a3 + 40);
  v6 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v42, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v38[0] = v6;
  v38[1] = v16;
  v39 = v41;
  v40 = 0x500000000;
  v17 = mlir::ValueRange::dereference_iterator(&v42, 1);
  if (mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v39))
  {
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v38);
    v19 = (uint64_t *)mlir::MemRefType::get(v39, (mlir::AffineMap *)v40, OperandRange, 0, 0, 0);
    v20 = (uint64_t)v19;
    if (!v19)
      goto LABEL_21;
    v21 = *v19;
    v22 = mlir::TypeID::get<mlir::ShapedType>();
    v23 = *(unsigned int *)(v21 + 16);
    if (!(_DWORD)v23)
      goto LABEL_21;
    v24 = *(_QWORD **)(v21 + 8);
    v25 = &v24[2 * v23];
    do
    {
      v26 = v23 >> 1;
      v27 = &v24[2 * (v23 >> 1)];
      v29 = *v27;
      v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22)
        v24 = v28;
      else
        v23 = v26;
    }
    while (v23);
    if (v24 != v25 && *v24 == v22)
      v30 = v24[1];
    else
LABEL_21:
      v30 = 0;
    v37[0] = mlir::getRankPromotionTypeForANE(v20, v30);
    v37[1] = v31;
    v36 = mlir::ValueRange::dereference_iterator(&v42, 0);
    v32 = mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *(_QWORD *)(a2 + 24), v37, &v36);
    (*(void (**)(_QWORD *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v32);
    v33 = 1;
  }
  else
  {
    v34 = a4[2];
    if (v34 && mlir::RewriterBase::Listener::classof(v34))
    else
      v33 = 0;
  }
  if (v39 != v41)
    free(v39);
  return v33;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)3>::~ConvertBroadcast(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)3>::~ConvertBroadcast(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t OperandRange;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  mlir::GenericProgramPoint *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v36;
  uint64_t v37[2];
  _QWORD v38[2];
  void *v39;
  uint64_t v40;
  _BYTE v41[40];
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v42 = *(_OWORD *)(a3 + 40);
  v6 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v42, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v38[0] = v6;
  v38[1] = v16;
  v39 = v41;
  v40 = 0x500000000;
  v17 = mlir::ValueRange::dereference_iterator(&v42, 1);
  if (mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v39))
  {
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v38);
    v19 = (uint64_t *)mlir::MemRefType::get(v39, (mlir::AffineMap *)v40, OperandRange, 0, 0, 0);
    v20 = (uint64_t)v19;
    if (!v19)
      goto LABEL_21;
    v21 = *v19;
    v22 = mlir::TypeID::get<mlir::ShapedType>();
    v23 = *(unsigned int *)(v21 + 16);
    if (!(_DWORD)v23)
      goto LABEL_21;
    v24 = *(_QWORD **)(v21 + 8);
    v25 = &v24[2 * v23];
    do
    {
      v26 = v23 >> 1;
      v27 = &v24[2 * (v23 >> 1)];
      v29 = *v27;
      v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22)
        v24 = v28;
      else
        v23 = v26;
    }
    while (v23);
    if (v24 != v25 && *v24 == v22)
      v30 = v24[1];
    else
LABEL_21:
      v30 = 0;
    v37[0] = mlir::getRankPromotionTypeForANE(v20, v30);
    v37[1] = v31;
    v36 = mlir::ValueRange::dereference_iterator(&v42, 0);
    v32 = mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *(_QWORD *)(a2 + 24), v37, &v36);
    (*(void (**)(_QWORD *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v32);
    v33 = 1;
  }
  else
  {
    v34 = a4[2];
    if (v34 && mlir::RewriterBase::Listener::classof(v34))
    else
      v33 = 0;
  }
  if (v39 != v41)
    free(v39);
  return v33;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)4>::~ConvertBroadcast(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)4>::~ConvertBroadcast(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t OperandRange;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  mlir::GenericProgramPoint *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v36;
  uint64_t v37[2];
  _QWORD v38[2];
  void *v39;
  uint64_t v40;
  _BYTE v41[40];
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v42 = *(_OWORD *)(a3 + 40);
  v6 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v42, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v38[0] = v6;
  v38[1] = v16;
  v39 = v41;
  v40 = 0x500000000;
  v17 = mlir::ValueRange::dereference_iterator(&v42, 1);
  if (mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v39))
  {
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v38);
    v19 = (uint64_t *)mlir::MemRefType::get(v39, (mlir::AffineMap *)v40, OperandRange, 0, 0, 0);
    v20 = (uint64_t)v19;
    if (!v19)
      goto LABEL_21;
    v21 = *v19;
    v22 = mlir::TypeID::get<mlir::ShapedType>();
    v23 = *(unsigned int *)(v21 + 16);
    if (!(_DWORD)v23)
      goto LABEL_21;
    v24 = *(_QWORD **)(v21 + 8);
    v25 = &v24[2 * v23];
    do
    {
      v26 = v23 >> 1;
      v27 = &v24[2 * (v23 >> 1)];
      v29 = *v27;
      v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22)
        v24 = v28;
      else
        v23 = v26;
    }
    while (v23);
    if (v24 != v25 && *v24 == v22)
      v30 = v24[1];
    else
LABEL_21:
      v30 = 0;
    v37[0] = mlir::getRankPromotionTypeForANE(v20, v30);
    v37[1] = v31;
    v36 = mlir::ValueRange::dereference_iterator(&v42, 0);
    v32 = mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *(_QWORD *)(a2 + 24), v37, &v36);
    (*(void (**)(_QWORD *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v32);
    v33 = 1;
  }
  else
  {
    v34 = a4[2];
    if (v34 && mlir::RewriterBase::Listener::classof(v34))
    else
      v33 = 0;
  }
  if (v39 != v41)
    free(v39);
  return v33;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)5>::~ConvertBroadcast(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)5>::~ConvertBroadcast(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t OperandRange;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  mlir::GenericProgramPoint *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v36;
  uint64_t v37[2];
  _QWORD v38[2];
  void *v39;
  uint64_t v40;
  _BYTE v41[40];
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v42 = *(_OWORD *)(a3 + 40);
  v6 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v42, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v38[0] = v6;
  v38[1] = v16;
  v39 = v41;
  v40 = 0x500000000;
  v17 = mlir::ValueRange::dereference_iterator(&v42, 1);
  if (mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v39))
  {
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v38);
    v19 = (uint64_t *)mlir::MemRefType::get(v39, (mlir::AffineMap *)v40, OperandRange, 0, 0, 0);
    v20 = (uint64_t)v19;
    if (!v19)
      goto LABEL_21;
    v21 = *v19;
    v22 = mlir::TypeID::get<mlir::ShapedType>();
    v23 = *(unsigned int *)(v21 + 16);
    if (!(_DWORD)v23)
      goto LABEL_21;
    v24 = *(_QWORD **)(v21 + 8);
    v25 = &v24[2 * v23];
    do
    {
      v26 = v23 >> 1;
      v27 = &v24[2 * (v23 >> 1)];
      v29 = *v27;
      v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22)
        v24 = v28;
      else
        v23 = v26;
    }
    while (v23);
    if (v24 != v25 && *v24 == v22)
      v30 = v24[1];
    else
LABEL_21:
      v30 = 0;
    v37[0] = mlir::getRankPromotionTypeForANE(v20, v30);
    v37[1] = v31;
    v36 = mlir::ValueRange::dereference_iterator(&v42, 0);
    v32 = mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *(_QWORD *)(a2 + 24), v37, &v36);
    (*(void (**)(_QWORD *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v32);
    v33 = 1;
  }
  else
  {
    v34 = a4[2];
    if (v34 && mlir::RewriterBase::Listener::classof(v34))
    else
      v33 = 0;
  }
  if (v39 != v41)
    free(v39);
  return v33;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)6>::~ConvertBroadcast(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)6>::~ConvertBroadcast(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t OperandRange;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  mlir::GenericProgramPoint *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v36;
  uint64_t v37[2];
  _QWORD v38[2];
  void *v39;
  uint64_t v40;
  _BYTE v41[40];
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v42 = *(_OWORD *)(a3 + 40);
  v6 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v42, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v38[0] = v6;
  v38[1] = v16;
  v39 = v41;
  v40 = 0x500000000;
  v17 = mlir::ValueRange::dereference_iterator(&v42, 1);
  if (mlir::matchConstantWithIntVector<long long>(v17, (uint64_t)&v39))
  {
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v38);
    v19 = (uint64_t *)mlir::MemRefType::get(v39, (mlir::AffineMap *)v40, OperandRange, 0, 0, 0);
    v20 = (uint64_t)v19;
    if (!v19)
      goto LABEL_21;
    v21 = *v19;
    v22 = mlir::TypeID::get<mlir::ShapedType>();
    v23 = *(unsigned int *)(v21 + 16);
    if (!(_DWORD)v23)
      goto LABEL_21;
    v24 = *(_QWORD **)(v21 + 8);
    v25 = &v24[2 * v23];
    do
    {
      v26 = v23 >> 1;
      v27 = &v24[2 * (v23 >> 1)];
      v29 = *v27;
      v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22)
        v24 = v28;
      else
        v23 = v26;
    }
    while (v23);
    if (v24 != v25 && *v24 == v22)
      v30 = v24[1];
    else
LABEL_21:
      v30 = 0;
    v37[0] = mlir::getRankPromotionTypeForANE(v20, v30);
    v37[1] = v31;
    v36 = mlir::ValueRange::dereference_iterator(&v42, 0);
    v32 = mlir::OpBuilder::create<mlir::anec::Broadcast,mlir::MemRefType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *(_QWORD *)(a2 + 24), v37, &v36);
    (*(void (**)(_QWORD *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v32);
    v33 = 1;
  }
  else
  {
    v34 = a4[2];
    if (v34 && mlir::RewriterBase::Listener::classof(v34))
    else
      v33 = 0;
  }
  if (v39 != v41)
    free(v39);
  return v33;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertBroadcast<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::BroadcastToOp,mlir::mps::BroadcastToOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "Operand 1 should be constant. \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::~ConvertPadding(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::~ConvertPadding(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PadOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PadOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::PadOpGenericAdaptorBase::PadOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::PadOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::PadOpGenericAdaptorBase::PadOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::PadOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 48);
  v9 = *(_QWORD *)(a3 + 56);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      v29 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PadOp &>(mlir::mps::PadOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PadOp &>(mlir::mps::PadOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

void mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = *(_OWORD *)(a3 + 48);
  v3 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3)
    goto LABEL_10;
  v4 = *v3;
  v5 = mlir::TypeID::get<mlir::ShapedType>();
  v6 = *(unsigned int *)(v4 + 16);
  if (!(_DWORD)v6)
    goto LABEL_10;
  v7 = *(_QWORD **)(v4 + 8);
  v8 = &v7[2 * v6];
  do
  {
    v9 = v6 >> 1;
    v10 = &v7[2 * (v6 >> 1)];
    v12 = *v10;
    v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5)
      v7 = v11;
    else
      v6 = v9;
  }
  while (v6);
  if (v7 != v8 && *v7 == v5)
    v13 = v7[1];
  else
LABEL_10:
    v13 = 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PadOp &>(mlir::mps::PadOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::createPadding(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, unsigned int *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v12;
  mlir::anec *v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  unint64_t ReferenceFormatIndex;
  char v18;
  uint64_t v19;
  mlir::Builder *v20;
  uint64_t IntegerType;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  unint64_t v29;
  unint64_t *v30;
  _QWORD *v31;
  unint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  unint64_t v44;
  unint64_t *v45;
  _QWORD *v46;
  unint64_t v47;
  uint64_t v48;
  mlir::GenericProgramPoint *v49;
  uint64_t v52;
  uint64_t v53;
  __int128 v54;
  void *v55;
  uint64_t v56;
  _BYTE v57[40];
  void *v58;
  uint64_t v59;
  _OWORD v60[5];
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v58 = v60;
  memset(v60, 0, sizeof(v60));
  v59 = 0xA0000000ALL;
  v55 = v57;
  memset_pattern16(v57, &unk_181246510, 0x28uLL);
  v56 = 0x500000005;
  v12 = a5[2];
  if ((_DWORD)v12)
  {
    v13 = 0;
    v14 = 16 * v12;
    v15 = (_QWORD *)(*(_QWORD *)a5 + 8);
    do
    {
      ReferenceFormatIndex = mlir::anec::getReferenceFormatIndex(v13, a5[2], 5uLL);
      if (!v18)
        std::__throw_bad_optional_access[abi:nn180100]();
      v19 = *(v15 - 1);
      if (v19 || *v15)
      {
        v16 = (char *)v58 + 16 * ReferenceFormatIndex;
        *v16 = v19;
        v16[1] = *v15;
        *((_QWORD *)v55 + ReferenceFormatIndex) = a4;
      }
      v13 = (mlir::anec *)((char *)v13 + 1);
      v15 += 2;
      v14 -= 16;
    }
    while (v14);
  }
  v54 = xmmword_181233130;
  v20 = (mlir::Builder *)(a7 + 8);
  IntegerType = mlir::Builder::getIntegerType(v20, 0x40u, 0);
  v22 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v54, 2, IntegerType, 0);
  v23 = v22;
  if (v22 && (v24 = *v22, v25 = mlir::TypeID::get<mlir::ShapedType>(), v26 = *(unsigned int *)(v24 + 16), (_DWORD)v26))
  {
    v27 = *(_QWORD **)(v24 + 8);
    v28 = &v27[2 * v26];
    do
    {
      v29 = v26 >> 1;
      v30 = &v27[2 * (v26 >> 1)];
      v32 = *v30;
      v31 = v30 + 2;
      v26 += ~(v26 >> 1);
      if (v32 < v25)
        v27 = v31;
      else
        v26 = v29;
    }
    while (v26);
    v33 = a6;
    v34 = a1;
    if (v27 != v28 && *v27 == v25)
      v35 = v27[1];
    else
      v35 = 0;
  }
  else
  {
    v35 = 0;
    v33 = a6;
    v34 = a1;
  }
  v52 = mlir::DenseElementsAttr::getFromRawBuffer(v23, v35, v58, 8 * v59, 8, 1, 0);
  v53 = 5;
  v36 = mlir::Builder::getIntegerType(v20, 0x40u, 0);
  v37 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v53, 1, v36, 0);
  v38 = v37;
  if (!v37)
    goto LABEL_29;
  v39 = *v37;
  v40 = mlir::TypeID::get<mlir::ShapedType>();
  v41 = *(unsigned int *)(v39 + 16);
  if (!(_DWORD)v41)
    goto LABEL_29;
  v42 = *(_QWORD **)(v39 + 8);
  v43 = &v42[2 * v41];
  do
  {
    v44 = v41 >> 1;
    v45 = &v42[2 * (v41 >> 1)];
    v47 = *v45;
    v46 = v45 + 2;
    v41 += ~(v41 >> 1);
    if (v47 < v40)
      v42 = v46;
    else
      v41 = v44;
  }
  while (v41);
  if (v42 != v43 && *v42 == v40)
    v48 = v42[1];
  else
LABEL_29:
    v48 = 0;
  *(_QWORD *)&v54 = mlir::DenseElementsAttr::getFromRawBuffer(v38, v48, v55, 8 * v56, 8, 1, 0);
  v49 = mlir::OpBuilder::create<mlir::anec::Padding,mlir::Value const&,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &>((mlir::UnknownLoc **)v20, v34, a2, (uint64_t *)&v54, &v52, v33);
  if (v55 != v57)
    free(v55);
  if (v58 != v60)
    free(v58);
  return v49;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

void mlir::getListOfPairs<unsigned long long>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char *v4;
  uint64_t v5;
  unsigned int v6;
  char *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  void *v11;
  uint64_t v12;
  _QWORD v13[9];

  v13[8] = *MEMORY[0x1E0C80C00];
  v11 = v13;
  v12 = 0x800000000;
  mlir::getIntValues<unsigned long long>(a1, a2, (uint64_t)&v11, 1);
  v4 = (char *)v11;
  v5 = v12;
  if ((_DWORD)v12)
  {
    v6 = *(_DWORD *)(a3 + 8);
    v7 = (char *)v11;
    do
    {
      v8 = *(_OWORD *)v7;
      v7 += 16;
      v9 = v8;
      if (v6 >= *(_DWORD *)(a3 + 12))
      {
        v10 = v9;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v6 + 1, 16);
        *(_OWORD *)(*(_QWORD *)a3 + 16 * *(unsigned int *)(a3 + 8)) = v10;
        v6 = *(_DWORD *)(a3 + 8);
        v4 = (char *)v11;
        v5 = v12;
      }
      else
      {
        *(_OWORD *)(*(_QWORD *)a3 + 16 * v6) = v9;
      }
      *(_DWORD *)(a3 + 8) = ++v6;
    }
    while (v7 != &v4[8 * v5]);
  }
  if (v4 != (char *)v13)
    free(v4);
}

char *llvm::SmallVectorImpl<std::pair<unsigned long long,unsigned long long>>::insert<std::pair<unsigned long long,unsigned long long>*,void>(uint64_t a1, uint64_t a2, char *__src, char *a4)
{
  char *v5;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unsigned int v11;
  size_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unsigned int v21;
  __int128 *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  _QWORD *v26;
  _OWORD *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  size_t v39;
  size_t v40;
  unint64_t v41;
  size_t v42;
  BOOL v43;
  BOOL v44;
  BOOL v45;
  BOOL v46;
  BOOL v47;
  BOOL v48;
  BOOL v49;
  BOOL v50;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  double *v55;
  uint64_t v56;
  const double *v57;
  double *v58;
  _QWORD *v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  BOOL v65;
  char v66;
  BOOL v67;
  uint64_t v68;
  uint64_t v69;
  char *v70;
  char *v71;
  __int128 *v72;
  _OWORD *v73;
  uint64_t v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  uint64_t v79;
  char *v80;
  char *v81;
  uint64_t v82;
  __int128 v83;
  uint64_t v84;
  unint64_t v85;
  BOOL v87;
  BOOL v88;
  unint64_t v89;
  __int128 *v90;
  _OWORD *v91;
  unint64_t v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  uint64_t v99;
  uint64_t v100;
  float64x2x2_t v101;
  float64x2x2_t v102;

  v5 = __src;
  v7 = *(_QWORD *)a1;
  v8 = (a2 - *(_QWORD *)a1) >> 4;
  v10 = *(unsigned int *)(a1 + 8);
  v9 = *(unsigned int *)(a1 + 12);
  v11 = *(_DWORD *)(a1 + 8);
  v12 = a4 - __src;
  v13 = (a4 - __src) >> 4;
  v14 = v13 + v10;
  if (*(_QWORD *)a1 + 16 * v10 == a2)
  {
    if (v14 > v9)
    {
      v23 = v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v14, 16);
      v5 = v23;
      v11 = *(_DWORD *)(a1 + 8);
      v7 = *(_QWORD *)a1;
    }
    if (v5 != a4)
    {
      memcpy((void *)(v7 + 16 * v11), v5, v12);
      v11 = *(_DWORD *)(a1 + 8);
      v7 = *(_QWORD *)a1;
    }
    *(_DWORD *)(a1 + 8) = v11 + (v12 >> 4);
    return (char *)(v7 + 16 * v8);
  }
  else
  {
    v100 = a2 - *(_QWORD *)a1;
    if (v14 > v9)
    {
      v15 = v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v14, 16);
      v5 = v15;
      v7 = *(_QWORD *)a1;
      v10 = *(unsigned int *)(a1 + 8);
      v11 = *(_DWORD *)(a1 + 8);
    }
    v16 = (char *)(v7 + 16 * v8);
    v17 = v7 + 16 * v10;
    v18 = v17 - (_QWORD)v16;
    v19 = v8;
    v20 = (uint64_t)(v17 - (_QWORD)v16) >> 4;
    if (v20 < v13)
    {
      v21 = v11 + (v12 >> 4);
      *(_DWORD *)(a1 + 8) = v21;
      if (v19 == v10)
      {
        v22 = (__int128 *)v5;
        goto LABEL_103;
      }
      v79 = v19;
      v80 = v5;
      memcpy((void *)(v7 + 16 * v21 - 16 * v20), v16, v17 - (_QWORD)v16);
      if (v18 >= 0xE0)
      {
        v84 = v7 + (v100 & 0xFFFFFFFFFFFFFFF0);
        v85 = v84 + v18 - 8;
        v87 = v84 + 8 < (unint64_t)&v80[v18] && (unint64_t)(v80 + 8) < v84 + v18;
        v88 = v85 <= (unint64_t)v80 || v16 >= &v80[v18 - 8];
        if (!v88 || v87)
        {
          v81 = v16;
          v82 = (uint64_t)(v17 - (_QWORD)v16) >> 4;
          v22 = (__int128 *)v80;
        }
        else
        {
          v89 = 16 * (v20 & 0xFFFFFFFFFFFFFFFCLL);
          v81 = &v16[v89];
          v82 = (v18 >> 4) & 3;
          v22 = (__int128 *)&v80[v89];
          v90 = (__int128 *)(v80 + 32);
          v91 = (_OWORD *)(v7 + 16 * v79 + 32);
          v92 = v20 & 0xFFFFFFFFFFFFFFFCLL;
          do
          {
            v94 = *(v90 - 2);
            v93 = *(v90 - 1);
            v96 = *v90;
            v95 = v90[1];
            v90 += 4;
            *(v91 - 2) = v94;
            *(v91 - 1) = v93;
            *v91 = v96;
            v91[1] = v95;
            v91 += 4;
            v92 -= 4;
          }
          while (v92);
          if (v20 == (v20 & 0xFFFFFFFFFFFFFFFCLL))
          {
LABEL_103:
            if (v22 != (__int128 *)a4)
              memcpy((void *)(v7 + 16 * v10), v22, a4 - (char *)v22);
            return v16;
          }
        }
      }
      else
      {
        v81 = v16;
        v82 = (uint64_t)(v17 - (_QWORD)v16) >> 4;
        v22 = (__int128 *)v80;
      }
      do
      {
        v97 = *v22++;
        *(_OWORD *)v81 = v97;
        v81 += 16;
        --v82;
      }
      while (v82);
      goto LABEL_103;
    }
    v99 = v19;
    v24 = v10;
    if (v13 + v10 > *(unsigned int *)(a1 + 12))
    {
      v25 = v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v13 + v10, 16);
      v5 = v25;
      v24 = *(unsigned int *)(a1 + 8);
      v11 = *(_DWORD *)(a1 + 8);
    }
    v26 = (_QWORD *)(v17 - 16 * v13);
    if (a4 != v5)
    {
      v27 = (_OWORD *)(*(_QWORD *)a1 + 16 * v24);
      v28 = -16 * v13;
      do
      {
        *v27++ = *(_OWORD *)(v17 + v28);
        v28 += 16;
      }
      while (v28);
      v11 = *(_DWORD *)(a1 + 8);
    }
    *(_DWORD *)(a1 + 8) = v11 + v13;
    if (v26 != (_QWORD *)v16)
    {
      v29 = 16 * v10;
      v30 = 16 * v10 - 16 * (v13 + v99) - 16;
      if (v30 < 0x550)
        goto LABEL_60;
      v31 = v29 - 16;
      v32 = v29 - 16 - 16 * (v13 + v99);
      if (v7 - -16 * (v13 + v99) > v7 + v29 - 16)
        goto LABEL_60;
      v33 = v29 - 8;
      if (v7 + v33 - v32 > (unint64_t)(v7 + v33)
        || v7 + v31 - (v12 & 0xFFFFFFFFFFFFFFF0) - v32 > v7 + v31 - (v12 & 0xFFFFFFFFFFFFFFF0)
        || v7 + v33 - (v12 & 0xFFFFFFFFFFFFFFF0) - v32 > v7 + v33 - (v12 & 0xFFFFFFFFFFFFFFF0))
      {
        goto LABEL_60;
      }
      v34 = 16 * (v13 + v99);
      v35 = v31 - v34;
      v36 = v7 + v34;
      v37 = v7 + v33;
      v38 = v7 + v33 - (v31 - v34);
      v39 = v7 + v34 - (v12 & 0xFFFFFFFFFFFFFFF0);
      v40 = v33 - (v12 & 0xFFFFFFFFFFFFFFF0);
      v41 = v7 + v40;
      v42 = v7 + v40 - v35;
      v43 = v36 >= v7 + v40 || v39 >= v37;
      v44 = !v43;
      v45 = v36 >= (unint64_t)v26 || v42 >= v37;
      v46 = !v45;
      v47 = v38 >= v41 || v39 >= v17;
      v48 = !v47;
      v49 = v38 >= (unint64_t)v26 || v42 >= v17;
      v50 = !v49;
      if (v38 < v37 && v36 < v17)
        goto LABEL_60;
      if (v44)
        goto LABEL_60;
      if (v46)
        goto LABEL_60;
      if (v48)
        goto LABEL_60;
      if (v50)
        goto LABEL_60;
      v52 = (v30 >> 4) + 1;
      v53 = 16 * (v52 & 0x1FFFFFFFFFFFFFFCLL);
      v54 = v17 - v53;
      v26 = (_QWORD *)((char *)v26 - v53);
      v55 = (double *)(v17 - 32);
      v56 = v52 & 0x1FFFFFFFFFFFFFFCLL;
      do
      {
        v57 = &v55[-2 * v13];
        v101 = vld2q_f64(v57);
        v57 -= 4;
        v102 = vld2q_f64(v57);
        v58 = v55 - 4;
        vst2q_f64(v55, v101);
        vst2q_f64(v58, v102);
        v55 -= 8;
        v56 -= 4;
      }
      while (v56);
      v17 = v54;
      if (v52 != (v52 & 0x1FFFFFFFFFFFFFFCLL))
      {
LABEL_60:
        v59 = (_QWORD *)(v17 - 8);
        do
        {
          v60 = *(v26 - 2);
          v26 -= 2;
          *(v59 - 1) = v60;
          *v59 = v26[1];
          v59 -= 2;
        }
        while (v26 != (_QWORD *)v16);
      }
    }
    if (a4 != v5)
    {
      v61 = a4 - v5 - 16;
      if (v61 < 0x150
        || ((v62 = (v100 & 0xFFFFFFFFFFFFFFF0) + v7 + (v61 & 0xFFFFFFFFFFFFFFF0),
             v63 = v62 + 8,
             v64 = v62 + 16,
             v7 + (v100 & 0xFFFFFFFFFFFFFFF0) + 8 < (unint64_t)&v5[(v61 & 0xFFFFFFFFFFFFFFF0) + 16])
          ? (v65 = (unint64_t)(v5 + 8) >= v64)
          : (v65 = 1),
            v65 ? (v66 = 0) : (v66 = 1),
            v63 > (unint64_t)v5 ? (v67 = v16 >= &v5[(v61 & 0xFFFFFFFFFFFFFFF0) + 8]) : (v67 = 1),
            !v67 || (v66 & 1) != 0))
      {
        v70 = v16;
        v71 = v5;
      }
      else
      {
        v68 = (v61 >> 4) + 1;
        v69 = 16 * (v68 & 0x1FFFFFFFFFFFFFFCLL);
        v70 = &v16[v69];
        v71 = &v5[v69];
        v72 = (__int128 *)(v5 + 32);
        v73 = (_OWORD *)(v7 + 16 * v99 + 32);
        v74 = v68 & 0x1FFFFFFFFFFFFFFCLL;
        do
        {
          v76 = *(v72 - 2);
          v75 = *(v72 - 1);
          v78 = *v72;
          v77 = v72[1];
          v72 += 4;
          *(v73 - 2) = v76;
          *(v73 - 1) = v75;
          *v73 = v78;
          v73[1] = v77;
          v73 += 4;
          v74 -= 4;
        }
        while (v74);
        if (v68 == (v68 & 0x1FFFFFFFFFFFFFFCLL))
          return v16;
      }
      do
      {
        v83 = *(_OWORD *)v71;
        v71 += 16;
        *(_OWORD *)v70 = v83;
        v70 += 16;
      }
      while (v71 != a4);
    }
  }
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Padding,mlir::Value const&,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::FloatAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.padding", (const unsigned __int8 *)0xC, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.padding";
    v21[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::Padding::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Padding,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void std::deque<std::pair<mlir::anec::Dim,std::pair<unsigned long long,unsigned long long>>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  char *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  void *v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  BOOL v36;
  int64_t v37;
  unint64_t v38;
  char *v39;
  _QWORD *v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  int64_t v44;
  unint64_t v45;
  char *v46;
  unint64_t v47;
  char *v48;
  char *v49;
  char *v50;
  char *v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  __int128 *v55;
  _OWORD *v56;
  uint64_t v57;
  __int128 v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  __int128 *v63;
  _OWORD *v64;
  uint64_t v65;
  __int128 v66;
  uint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  char *v71;
  uint64_t v72;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = v2 >= 0xAA;
  v4 = v2 - 170;
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v4;
    v6 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v6 + 1);
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_57:
      *(_QWORD *)v5 = v8;
      *(_QWORD *)(a1 + 16) += 8;
      return;
    }
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v30 = (v5 - v9) >> 2;
      if (v5 == v9)
        v30 = 1;
      if (!(v30 >> 61))
      {
        v31 = v30 >> 2;
        v32 = 8 * v30;
        v33 = (char *)operator new(8 * v30);
        v34 = &v33[8 * v31];
        v35 = &v33[v32];
        v37 = v5 - v7;
        v36 = v5 == v7;
        v5 = v34;
        if (!v36)
        {
          v5 = &v34[v37 & 0xFFFFFFFFFFFFFFF8];
          v38 = v37 - 8;
          if ((unint64_t)(v37 - 8) >= 0x38)
          {
            v52 = &v33[8 * v31];
            v39 = v52;
            if ((unint64_t)(v52 - v7) >= 0x20)
            {
              v53 = (v38 >> 3) + 1;
              v54 = 8 * (v53 & 0x3FFFFFFFFFFFFFFCLL);
              v39 = &v34[v54];
              v7 += v54;
              v55 = (__int128 *)(v6 + 3);
              v56 = v52 + 16;
              v57 = v53 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v58 = *v55;
                *(v56 - 1) = *(v55 - 1);
                *v56 = v58;
                v55 += 2;
                v56 += 2;
                v57 -= 4;
              }
              while (v57);
              if (v53 == (v53 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_55;
            }
          }
          else
          {
            v39 = &v33[8 * v31];
          }
          do
          {
            v59 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v39 = v59;
            v39 += 8;
          }
          while (v39 != v5);
        }
        goto LABEL_55;
      }
LABEL_65:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_5:
    v11 = v10 >> 3;
    if (v11 >= -1)
      v12 = v11 + 1;
    else
      v12 = v11 + 2;
    v13 = v12 >> 1;
    v14 = -v13;
    v15 = &v7[-8 * v13];
    v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      v7 = *(char **)(a1 + 8);
    }
    v5 = &v15[v16];
    *(_QWORD *)(a1 + 8) = &v7[8 * v14];
    *(_QWORD *)(a1 + 16) = &v15[v16];
    goto LABEL_57;
  }
  v18 = *(char **)(a1 + 8);
  v17 = *(char **)(a1 + 16);
  v19 = v17 - v18;
  v20 = (v17 - v18) >> 3;
  v21 = *(char **)(a1 + 24);
  v22 = (uint64_t)&v21[-*(_QWORD *)a1];
  if (v20 < (unint64_t)(v22 >> 3))
  {
    if (v21 != v17)
    {
      v68 = (char *)operator new(0xFF0uLL);
      std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_back((char **)a1, &v68);
      return;
    }
    v68 = (char *)operator new(0xFF0uLL);
    std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_front((void **)a1, &v68);
    v40 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v40 + 1);
    v8 = *v40;
    *(_QWORD *)(a1 + 8) = v40 + 1;
    if (v5 != *(char **)(a1 + 24))
      goto LABEL_57;
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v41 = (v5 - v9) >> 2;
      if (v5 == v9)
        v41 = 1;
      if (!(v41 >> 61))
      {
        v42 = v41 >> 2;
        v43 = 8 * v41;
        v33 = (char *)operator new(8 * v41);
        v34 = &v33[8 * v42];
        v35 = &v33[v43];
        v44 = v5 - v7;
        v36 = v5 == v7;
        v5 = v34;
        if (!v36)
        {
          v5 = &v34[v44 & 0xFFFFFFFFFFFFFFF8];
          v45 = v44 - 8;
          if ((unint64_t)(v44 - 8) >= 0x38)
          {
            v60 = &v33[8 * v42];
            v46 = v60;
            if ((unint64_t)(v60 - v7) >= 0x20)
            {
              v61 = (v45 >> 3) + 1;
              v62 = 8 * (v61 & 0x3FFFFFFFFFFFFFFCLL);
              v46 = &v34[v62];
              v7 += v62;
              v63 = (__int128 *)(v40 + 3);
              v64 = v60 + 16;
              v65 = v61 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v66 = *v63;
                *(v64 - 1) = *(v63 - 1);
                *v64 = v66;
                v63 += 2;
                v64 += 2;
                v65 -= 4;
              }
              while (v65);
              if (v61 == (v61 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_55;
            }
          }
          else
          {
            v46 = &v33[8 * v42];
          }
          do
          {
            v67 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v46 = v67;
            v46 += 8;
          }
          while (v46 != v5);
        }
LABEL_55:
        *(_QWORD *)a1 = v33;
        *(_QWORD *)(a1 + 8) = v34;
        *(_QWORD *)(a1 + 16) = v5;
        *(_QWORD *)(a1 + 24) = v35;
        if (v9)
        {
          operator delete(v9);
          v5 = *(char **)(a1 + 16);
        }
        goto LABEL_57;
      }
      goto LABEL_65;
    }
    goto LABEL_5;
  }
  v23 = v22 >> 2;
  if (v21 == *(char **)a1)
    v24 = 1;
  else
    v24 = v23;
  v72 = a1 + 24;
  if (v24 >> 61)
    goto LABEL_65;
  v25 = (char *)operator new(8 * v24);
  v26 = &v25[8 * v20];
  v68 = v25;
  v69 = v26;
  v27 = &v25[8 * v24];
  v71 = v27;
  v28 = operator new(0xFF0uLL);
  if (v20 == v24)
  {
    if (v19 < 1)
    {
      if (v17 == v18)
        v47 = 1;
      else
        v47 = v19 >> 2;
      if (v47 >> 61)
        goto LABEL_65;
      v48 = (char *)operator new(8 * v47);
      v26 = &v48[8 * (v47 >> 2)];
      v27 = &v48[8 * v47];
      v68 = v48;
      v69 = v26;
      v71 = v27;
      operator delete(v25);
      v18 = *(char **)(a1 + 8);
      v17 = *(char **)(a1 + 16);
      v25 = v48;
    }
    else
    {
      v29 = v20 + 2;
      if (v20 >= -1)
        v29 = v20 + 1;
      v26 -= 8 * (v29 >> 1);
      v69 = v26;
    }
  }
  *(_QWORD *)v26 = v28;
  v49 = v26 + 8;
  v70 = v26 + 8;
  if (v17 == v18)
  {
    v17 = v18;
  }
  else
  {
    do
    {
      v17 -= 8;
      std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_front((void **)&v68, v17);
    }
    while (v17 != *(char **)(a1 + 8));
    v25 = v68;
    v26 = v69;
    v18 = *(char **)(a1 + 16);
    v49 = v70;
    v27 = v71;
  }
  v50 = *(char **)a1;
  *(_QWORD *)a1 = v25;
  *(_QWORD *)(a1 + 8) = v26;
  v68 = v50;
  v69 = v17;
  v51 = *(char **)(a1 + 24);
  *(_QWORD *)(a1 + 16) = v49;
  *(_QWORD *)(a1 + 24) = v27;
  v70 = v18;
  v71 = v51;
  if (v18 != v17)
    v70 = &v18[(v17 - v18 + 7) & 0xFFFFFFFFFFFFFFF8];
  if (v50)
    operator delete(v50);
}

_QWORD *mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::~ConvertPadding(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::~ConvertPadding(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

void mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = *(_OWORD *)(a3 + 48);
  v3 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3)
    goto LABEL_10;
  v4 = *v3;
  v5 = mlir::TypeID::get<mlir::ShapedType>();
  v6 = *(unsigned int *)(v4 + 16);
  if (!(_DWORD)v6)
    goto LABEL_10;
  v7 = *(_QWORD **)(v4 + 8);
  v8 = &v7[2 * v6];
  do
  {
    v9 = v6 >> 1;
    v10 = &v7[2 * (v6 >> 1)];
    v12 = *v10;
    v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5)
      v7 = v11;
    else
      v6 = v9;
  }
  while (v6);
  if (v7 != v8 && *v7 == v5)
    v13 = v7[1];
  else
LABEL_10:
    v13 = 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::~ConvertPadding(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::~ConvertPadding(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

void mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = *(_OWORD *)(a3 + 48);
  v3 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3)
    goto LABEL_10;
  v4 = *v3;
  v5 = mlir::TypeID::get<mlir::ShapedType>();
  v6 = *(unsigned int *)(v4 + 16);
  if (!(_DWORD)v6)
    goto LABEL_10;
  v7 = *(_QWORD **)(v4 + 8);
  v8 = &v7[2 * v6];
  do
  {
    v9 = v6 >> 1;
    v10 = &v7[2 * (v6 >> 1)];
    v12 = *v10;
    v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5)
      v7 = v11;
    else
      v6 = v9;
  }
  while (v6);
  if (v7 != v8 && *v7 == v5)
    v13 = v7[1];
  else
LABEL_10:
    v13 = 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::~ConvertPadding(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::~ConvertPadding(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

void mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = *(_OWORD *)(a3 + 48);
  v3 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3)
    goto LABEL_10;
  v4 = *v3;
  v5 = mlir::TypeID::get<mlir::ShapedType>();
  v6 = *(unsigned int *)(v4 + 16);
  if (!(_DWORD)v6)
    goto LABEL_10;
  v7 = *(_QWORD **)(v4 + 8);
  v8 = &v7[2 * v6];
  do
  {
    v9 = v6 >> 1;
    v10 = &v7[2 * (v6 >> 1)];
    v12 = *v10;
    v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5)
      v7 = v11;
    else
      v6 = v9;
  }
  while (v6);
  if (v7 != v8 && *v7 == v5)
    v13 = v7[1];
  else
LABEL_10:
    v13 = 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::~ConvertPadding(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::~ConvertPadding(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

void mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = *(_OWORD *)(a3 + 48);
  v3 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3)
    goto LABEL_10;
  v4 = *v3;
  v5 = mlir::TypeID::get<mlir::ShapedType>();
  v6 = *(unsigned int *)(v4 + 16);
  if (!(_DWORD)v6)
    goto LABEL_10;
  v7 = *(_QWORD **)(v4 + 8);
  v8 = &v7[2 * v6];
  do
  {
    v9 = v6 >> 1;
    v10 = &v7[2 * (v6 >> 1)];
    v12 = *v10;
    v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5)
      v7 = v11;
    else
      v6 = v9;
  }
  while (v6);
  if (v7 != v8 && *v7 == v5)
    v13 = v7[1];
  else
LABEL_10:
    v13 = 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::~ConvertPadding(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::~ConvertPadding(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

void mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = *(_OWORD *)(a3 + 48);
  v3 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3)
    goto LABEL_10;
  v4 = *v3;
  v5 = mlir::TypeID::get<mlir::ShapedType>();
  v6 = *(unsigned int *)(v4 + 16);
  if (!(_DWORD)v6)
    goto LABEL_10;
  v7 = *(_QWORD **)(v4 + 8);
  v8 = &v7[2 * v6];
  do
  {
    v9 = v6 >> 1;
    v10 = &v7[2 * (v6 >> 1)];
    v12 = *v10;
    v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5)
      v7 = v11;
    else
      v6 = v9;
  }
  while (v6);
  if (v7 != v8 && *v7 == v5)
    v13 = v7[1];
  else
LABEL_10:
    v13 = 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::~ConvertPadding(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::~ConvertPadding(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

void mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = *(_OWORD *)(a3 + 48);
  v3 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3)
    goto LABEL_10;
  v4 = *v3;
  v5 = mlir::TypeID::get<mlir::ShapedType>();
  v6 = *(unsigned int *)(v4 + 16);
  if (!(_DWORD)v6)
    goto LABEL_10;
  v7 = *(_QWORD **)(v4 + 8);
  v8 = &v7[2 * v6];
  do
  {
    v9 = v6 >> 1;
    v10 = &v7[2 * (v6 >> 1)];
    v12 = *v10;
    v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5)
      v7 = v11;
    else
      v6 = v9;
  }
  while (v6);
  if (v7 != v8 && *v7 == v5)
    v13 = v7[1];
  else
LABEL_10:
    v13 = 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant 'constant_values' attribute");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a 16-bit integer or floating-point attribute ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Attribute 'constant_values' do not represent a single-element integer or floating-point attribute ");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertPadding<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(mlir::mps::PadOp,mlir::mps::PadOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(mlir::Operation ***a1, uint64_t a2)
{
  mlir::Diagnostic *v3;
  mlir::Diagnostic *v4;

  v3 = (mlir::Diagnostic *)mlir::Diagnostic::operator<<(a2, "Failed to extract constant padding mode attribute");
  v4 = mlir::Diagnostic::operator<<(v3, **a1);
  return mlir::Diagnostic::operator<<((uint64_t)v4, " \n");
}

_QWORD *mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)0>::~ConvertSlice(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)0>::~ConvertSlice(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SliceOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SliceOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SliceOpGenericAdaptorBase::SliceOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SliceOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SliceOpGenericAdaptorBase::SliceOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SliceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t DefiningOp;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t Bias;
  unint64_t matched;
  uint64_t v25;
  uint64_t v26;
  uint64_t ArgAttrsAttr;
  unint64_t PositiveAxis;
  char v29;
  unint64_t v30;
  uint64_t SparseShape;
  unint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  mlir::GenericProgramPoint *v38;
  mlir::Operation *v39;
  uint64_t v40;
  uint64_t v41;
  mlir::Operation *v42;
  uint64_t v43;
  _QWORD v45[2];
  _QWORD *v46;
  uint64_t v47;
  mlir::Operation *v48;
  void **v49;
  void *v50[2];
  uint64_t v51;
  __int128 v52;
  void *v53[2];
  _BYTE v54[16];
  __int16 v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v48 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v46 = v5;
  v47 = v15;
  v50[0] = &v51;
  v50[1] = (void *)0x100000000;
  v45[0] = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v45);
  if (DefiningOp)
  {
    v17 = DefiningOp;
    v18 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v17 + 48) + 32))(*(_QWORD *)(v17 + 48), v18))
    {
      v53[0] = v54;
      v53[1] = (void *)0x100000000;
      mlir::Operation::fold(v17, 0, 0, (uint64_t)v53);
      v19 = (uint64_t *)(*(_QWORD *)v53[0] & 0xFFFFFFFFFFFFFFF8);
      v20 = mlir::DenseIntElementsAttr::classof((uint64_t)v19) & (v19 != 0);
      if (!v20)
        v19 = 0;
      if (v53[0] != v54)
        free(v53[0]);
      if ((v20 & 1) != 0)
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
        if (mlir::getPositivePromotedAxes(v19, v21, (uint64_t)v50, 0, 0))
        {
          v45[0] = mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
          v45[1] = v22;
          Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
          matched = mlir::matchConstantWithIntValue<int>(Bias);
          if ((matched & 0xFF00000000) != 0)
          {
            v25 = (int)matched;
            v26 = *(unsigned int *)v50[0];
            ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v45);
            PositiveAxis = mlir::tryGetPositiveAxis(v25, *(_QWORD *)(ArgAttrsAttr + 8 * v26), 0, 0, 0);
            if (v29)
            {
              v30 = PositiveAxis;
              SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v48);
              v32 = mlir::matchConstantWithIntValue<int>(SparseShape);
              if ((v32 & 0xFF00000000) != 0)
              {
                v33 = v32;
                v34 = *((_QWORD *)v48 + 3);
                v35 = mlir::ValueRange::dereference_iterator(&v52, 0);
                v36 = v33;
                v37 = 1;
                mlir::ConversionPatternRewriter::replaceOp(a4, v48, v38);
                goto LABEL_32;
              }
              goto LABEL_31;
            }
            v53[0] = "failed: could not extract a positive value for start attribute";
            v55 = 259;
            v42 = v48;
            v49 = v53;
            v43 = *((_QWORD *)a4 + 2);
            if (v43)
            {
              if (mlir::RewriterBase::Listener::classof(v43))
              {
                v41 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v43 + 64))(v43, *((_QWORD *)v42 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v49);
                goto LABEL_30;
              }
            }
          }
        }
        else
        {
          v53[0] = "failed: could not extract positive promoted axes";
          v55 = 259;
          v39 = v48;
          v45[0] = v53;
          v40 = *((_QWORD *)a4 + 2);
          if (v40 && mlir::RewriterBase::Listener::classof(v40))
          {
            v41 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v40 + 64))(v40, *((_QWORD *)v39 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v45);
LABEL_30:
            v37 = v41;
            goto LABEL_32;
          }
        }
      }
    }
  }
LABEL_31:
  v37 = 0;
LABEL_32:
  if (v50[0] != &v51)
    free(v50[0]);
  return v37;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

unint64_t mlir::matchConstantWithIntValue<int>(uint64_t a1)
{
  uint64_t DefiningOp;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t SingleInt;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  void *v14[2];
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  v13 = a1;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v13);
  if (!DefiningOp)
    goto LABEL_10;
  v2 = DefiningOp;
  v3 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 48) + 32))(*(_QWORD *)(v2 + 48), v3))
    goto LABEL_10;
  v14[0] = v15;
  v14[1] = (void *)0x100000000;
  mlir::Operation::fold(v2, 0, 0, (uint64_t)v14);
  v5 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v14[0] & 0xFFFFFFFFFFFFFFF8));
  v6 = v5 ? v4 : 0;
  if (v14[0] != v15)
    free(v14[0]);
  if (v5)
  {
    SingleInt = mlir::getSingleIntValue<int>((uint64_t)v5, v6);
    v8 = SingleInt & 0xFFFFFF0000000000;
    v9 = SingleInt & 0xFF00000000;
    v10 = SingleInt & 0xFFFFFF00;
    v11 = SingleInt;
  }
  else
  {
LABEL_10:
    v8 = 0;
    v9 = 0;
    v11 = 0;
    v10 = 0;
  }
  return v9 | v8 | v11 | v10;
}

mlir::GenericProgramPoint *mlir::`anonymous namespace'::makeInputViewOp<(mlir::anec::Family)0>(uint64_t a1, uint64_t a2, uint64_t a3, mlir::anec *a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t *v20;
  _QWORD *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  unint64_t v26;
  uint64_t DimFromIndex;
  unint64_t v28;
  unsigned int IndexFromDim;
  char v30;
  unsigned int v31;
  uint64_t ArgAttrsAttr;
  unint64_t v33;
  unint64_t v34;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  mlir::Builder *v41;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  mlir::GenericProgramPoint *OperandRange;
  _QWORD v51[2];
  uint64_t v52;

  v52 = a3;
  v13 = (uint64_t *)(*(_QWORD *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v13)
    goto LABEL_10;
  v14 = *v13;
  v15 = mlir::TypeID::get<mlir::ShapedType>();
  v16 = *(unsigned int *)(v14 + 16);
  if (!(_DWORD)v16)
    goto LABEL_10;
  v17 = *(_QWORD **)(v14 + 8);
  v18 = &v17[2 * v16];
  do
  {
    v19 = v16 >> 1;
    v20 = &v17[2 * (v16 >> 1)];
    v22 = *v20;
    v21 = v20 + 2;
    v16 += ~(v16 >> 1);
    if (v22 < v15)
      v17 = v21;
    else
      v16 = v19;
  }
  while (v16);
  if (v17 != v18 && *v17 == v15)
    v23 = v17[1];
  else
LABEL_10:
    v23 = 0;
  v51[0] = mlir::getRankPromotionTypeForANE((uint64_t)v13, v23);
  v51[1] = v24;
  OperandRange = (mlir::GenericProgramPoint *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v51);
  v25 = 12;
  if (!mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    v49 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v51);
    if (mlir::Type::isF32((mlir::Type *)&v49))
      v25 = 12;
    else
      v25 = 28;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v51);
  DimFromIndex = mlir::anec::getDimFromIndex(a4, v26);
  if ((DimFromIndex & 0xFF00000000) != 0)
  {
    if ((_DWORD)DimFromIndex != 4 || v25 >= a5)
    {
      v41 = (mlir::Builder *)(a1 + 8);
      v49 = a5;
      OperandRange = a4;
      v47 = a7;
      v48 = a6;
      return mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long,unsigned long long,unsigned long long,unsigned long long>(v41, a2, &v52, (uint64_t *)&OperandRange, &v49, &v48, &v47);
    }
    v45 = a6;
    v46 = a7;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v51);
    IndexFromDim = mlir::anec::getIndexFromDim(4, v28);
    if (v30)
    {
      v31 = IndexFromDim;
      ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v51);
      v33 = a5 / v25;
      v34 = a5 % v25;
      v36 = v33 > 1 && v34 == 0;
      v37 = v33 - v36;
      if (v33 != v36)
      {
        v38 = *(_QWORD *)(ArgAttrsAttr + 8 * v31);
        v39 = v25;
        do
        {
          v48 = v25;
          v49 = (uint64_t)a4;
          v47 = v38 - v39;
          OperandRange = mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,long long const&,unsigned long long &,long long &>((mlir::Builder *)(a1 + 8), a2, &v52, &v49, &v48, &v47);
          v52 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&OperandRange);
          v39 += v25;
          --v37;
        }
        while (v37);
      }
      if (v34)
        v40 = v34;
      else
        v40 = v25;
      v41 = (mlir::Builder *)(a1 + 8);
      v49 = v40;
      OperandRange = a4;
      v47 = v46;
      v48 = v45;
      return mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long,unsigned long long,unsigned long long,unsigned long long>(v41, a2, &v52, (uint64_t *)&OperandRange, &v49, &v48, &v47);
    }
  }
  v43 = std::__throw_bad_optional_access[abi:nn180100]();
  return (mlir::GenericProgramPoint *)mlir::getSingleIntValue<int>(v43, v44);
}

uint64_t mlir::getSingleIntValue<int>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t *ArgAttrsAttr;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  _QWORD v10[2];
  _QWORD v11[2];
  uint64_t v12;
  uint64_t v13;

  v12 = a1;
  v13 = a2;
  v11[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v12);
  v11[1] = v2;
  ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v11);
  if (mlir::ShapedType::getNumElements(ArgAttrsAttr, v4) == 1
    && (v10[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v12),
        v10[1] = v5,
        *(_UNKNOWN **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v10)
                     + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id))
  {
    LODWORD(v10[0]) = 0;
    mlir::copyElementsAttrData<int>(v12, v13, (uint64_t)v10, 1);
    v8 = v10[0] & 0xFFFFFF00;
    v6 = LOBYTE(v10[0]);
    v7 = 0x100000000;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
  }
  return v7 | v8 | v6;
}

void mlir::copyElementsAttrData<int>(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  _QWORD *Type;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t *v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  unsigned __int8 *ElementsAttrRawData;
  uint64_t v20;
  uint64_t v21;
  int64_t NumElements;
  uint64_t i;
  uint64_t v24;
  uint64_t j;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  _DWORD *v32;
  unint64_t v33;
  uint64_t k;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  _DWORD *v40;
  uint64_t m;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _DWORD *v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _DWORD *v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v67;
  int *v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  _DWORD *v75;
  int32x2_t v76;
  unint64_t v77;
  unint64_t v78;
  unsigned __int8 *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  _DWORD *v84;
  unsigned int IntOrFloatBitWidth;
  uint64_t v86;
  int32x2_t *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  _DWORD *v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  uint64_t OperandRange;
  _QWORD v108[2];
  uint64_t v109;
  uint64_t v110;
  void *v111[3];
  _QWORD v112[6];

  v112[5] = *MEMORY[0x1E0C80C00];
  v109 = a1;
  v110 = a2;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v109);
  v7 = Type;
  if (!Type)
    goto LABEL_10;
  v8 = *Type;
  v9 = mlir::TypeID::get<mlir::ShapedType>();
  v10 = *(unsigned int *)(v8 + 16);
  if (!(_DWORD)v10)
    goto LABEL_10;
  v11 = *(_QWORD **)(v8 + 8);
  v12 = &v11[2 * v10];
  do
  {
    v13 = v10 >> 1;
    v14 = &v11[2 * (v10 >> 1)];
    v16 = *v14;
    v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9)
      v11 = v15;
    else
      v10 = v13;
  }
  while (v10);
  if (v11 != v12 && *v11 == v9)
    v17 = v11[1];
  else
LABEL_10:
    v17 = 0;
  v108[0] = v7;
  v108[1] = v17;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v108);
  v18 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v109);
  ElementsAttrRawData = (unsigned __int8 *)mlir::getElementsAttrRawData(v109);
  v21 = v20;
  if (!v18 || a4)
  {
    NumElements = mlir::ElementsAttr::getNumElements(v109, v110);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
    {
      if (NumElements < 1)
        return;
      goto LABEL_17;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
    {
      if (NumElements < 1)
        return;
      goto LABEL_28;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
    {
      if (NumElements < 1)
        return;
      if ((unint64_t)NumElements >= 2)
      {
        v28 = 0;
        v27 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18)
            v29 = 0;
          else
            v29 = v28;
          if (v18)
            v30 = 0;
          else
            v30 = v28 + 1;
          v31 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v30];
          v32 = (_DWORD *)(a3 + 4 * v28);
          *v32 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v29];
          v32[1] = v31;
          v28 += 2;
        }
        while (v28 != v27);
        goto LABEL_204;
      }
      goto LABEL_37;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
    {
      if (NumElements < 1)
        return;
      goto LABEL_55;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      if (NumElements < 1)
        return;
      goto LABEL_62;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
    {
      if (NumElements < 1)
        return;
      goto LABEL_82;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      if (NumElements < 1)
        return;
      goto LABEL_93;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
    {
      if (NumElements < 1)
        return;
      goto LABEL_100;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1)
        return;
      goto LABEL_116;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1)
        return;
      goto LABEL_132;
    }
    if (mlir::Type::isF64((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1)
        return;
      goto LABEL_148;
    }
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1)
        return;
LABEL_163:
      if ((unint64_t)NumElements >= 2)
      {
        v86 = 0;
        v77 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        v87 = (int32x2_t *)a3;
        do
        {
          if (v18)
            v88 = 0;
          else
            v88 = v86;
          if (v18)
            v89 = 0;
          else
            v89 = v86 + 1;
          v76.i16[0] = *(_WORD *)&ElementsAttrRawData[2 * v88];
          v76.i16[2] = *(_WORD *)&ElementsAttrRawData[2 * v89];
          v76 = vcvt_s32_f32((float32x2_t)vshl_n_s32(v76, 0x10uLL));
          *v87++ = v76;
          v86 += 2;
        }
        while (v86 != v77);
        goto LABEL_246;
      }
      v77 = 0;
      do
      {
        if (v18)
          v105 = 0;
        else
          v105 = v77;
        *(_DWORD *)(a3 + 4 * v77++) = (int)COERCE_FLOAT(*(unsigned __int16 *)&ElementsAttrRawData[2 * v105] << 16);
LABEL_246:
        ;
      }
      while (NumElements != v77);
      return;
    }
  }
  else
  {
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
    {
      NumElements = 1;
LABEL_17:
      for (i = 0; i != NumElements; ++i)
      {
        if (v18)
          v24 = 0;
        else
          v24 = i;
        *(_DWORD *)(a3 + 4 * i) = ElementsAttrRawData[v24];
      }
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
    {
      NumElements = 1;
LABEL_28:
      for (j = 0; j != NumElements; ++j)
      {
        if (v18)
          v26 = 0;
        else
          v26 = j;
        *(_DWORD *)(a3 + 4 * j) = (char)ElementsAttrRawData[v26];
      }
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
    {
      NumElements = 1;
LABEL_37:
      v27 = 0;
      do
      {
        if (v18)
          v96 = 0;
        else
          v96 = v27;
        *(_DWORD *)(a3 + 4 * v27++) = *(unsigned __int16 *)&ElementsAttrRawData[2 * v96];
LABEL_204:
        ;
      }
      while (NumElements != v27);
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
    {
      NumElements = 1;
LABEL_55:
      if ((unint64_t)NumElements >= 2)
      {
        v36 = 0;
        v33 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18)
            v37 = 0;
          else
            v37 = v36;
          if (v18)
            v38 = 0;
          else
            v38 = v36 + 1;
          v39 = *(__int16 *)&ElementsAttrRawData[2 * v38];
          v40 = (_DWORD *)(a3 + 4 * v36);
          *v40 = *(__int16 *)&ElementsAttrRawData[2 * v37];
          v40[1] = v39;
          v36 += 2;
        }
        while (v36 != v33);
        goto LABEL_210;
      }
      v33 = 0;
      do
      {
        if (v18)
          v97 = 0;
        else
          v97 = v33;
        *(_DWORD *)(a3 + 4 * v33++) = *(__int16 *)&ElementsAttrRawData[2 * v97];
LABEL_210:
        ;
      }
      while (NumElements != v33);
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      NumElements = 1;
LABEL_62:
      for (k = 0; k != NumElements; ++k)
      {
        if (v18)
          v35 = 0;
        else
          v35 = k;
        *(_DWORD *)(a3 + 4 * k) = *(_DWORD *)&ElementsAttrRawData[4 * v35];
      }
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
    {
      NumElements = 1;
LABEL_82:
      for (m = 0; m != NumElements; ++m)
      {
        if (v18)
          v42 = 0;
        else
          v42 = m;
        *(_DWORD *)(a3 + 4 * m) = *(_DWORD *)&ElementsAttrRawData[4 * v42];
      }
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      NumElements = 1;
LABEL_93:
      if ((unint64_t)NumElements >= 2)
      {
        v45 = 0;
        v43 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18)
            v46 = 0;
          else
            v46 = v45;
          if (v18)
            v47 = 0;
          else
            v47 = v45 + 1;
          v48 = *(_QWORD *)&ElementsAttrRawData[8 * v47];
          v49 = (_DWORD *)(a3 + 4 * v45);
          *v49 = *(_QWORD *)&ElementsAttrRawData[8 * v46];
          v49[1] = v48;
          v45 += 2;
        }
        while (v45 != v43);
        goto LABEL_216;
      }
      v43 = 0;
      do
      {
        if (v18)
          v98 = 0;
        else
          v98 = v43;
        *(_DWORD *)(a3 + 4 * v43++) = *(_QWORD *)&ElementsAttrRawData[8 * v98];
LABEL_216:
        ;
      }
      while (NumElements != v43);
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
    {
      NumElements = 1;
LABEL_100:
      if ((unint64_t)NumElements >= 2)
      {
        v51 = 0;
        v44 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18)
            v52 = 0;
          else
            v52 = v51;
          if (v18)
            v53 = 0;
          else
            v53 = v51 + 1;
          v54 = *(_QWORD *)&ElementsAttrRawData[8 * v53];
          v55 = (_DWORD *)(a3 + 4 * v51);
          *v55 = *(_QWORD *)&ElementsAttrRawData[8 * v52];
          v55[1] = v54;
          v51 += 2;
        }
        while (v51 != v44);
        goto LABEL_222;
      }
      v44 = 0;
      do
      {
        if (v18)
          v99 = 0;
        else
          v99 = v44;
        *(_DWORD *)(a3 + 4 * v44++) = *(_QWORD *)&ElementsAttrRawData[8 * v99];
LABEL_222:
        ;
      }
      while (NumElements != v44);
      return;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
    {
      NumElements = 1;
LABEL_116:
      if ((unint64_t)NumElements >= 2)
      {
        v57 = 0;
        v50 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18)
            v58 = 0;
          else
            v58 = v57;
          if (v18)
            v59 = 0;
          else
            v59 = v57 + 1;
          _H0 = *(_WORD *)&ElementsAttrRawData[2 * v58];
          _H1 = *(_WORD *)&ElementsAttrRawData[2 * v59];
          __asm { FCVT            S0, H0 }
          v67 = (int)_S0;
          __asm { FCVT            S0, H1 }
          v69 = (int *)(a3 + 4 * v57);
          *v69 = v67;
          v69[1] = (int)_S0;
          v57 += 2;
        }
        while (v57 != v50);
        goto LABEL_228;
      }
      v50 = 0;
      do
      {
        if (v18)
          v100 = 0;
        else
          v100 = v50;
        _H0 = *(_WORD *)&ElementsAttrRawData[2 * v100];
        __asm { FCVT            S0, H0 }
        *(_DWORD *)(a3 + 4 * v50++) = (int)_S0;
LABEL_228:
        ;
      }
      while (NumElements != v50);
      return;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      NumElements = 1;
LABEL_132:
      if ((unint64_t)NumElements >= 2)
      {
        v71 = 0;
        v56 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18)
            v72 = 0;
          else
            v72 = v71;
          if (v18)
            v73 = 0;
          else
            v73 = v71 + 1;
          v74 = (int)*(float *)&ElementsAttrRawData[4 * v73];
          v75 = (_DWORD *)(a3 + 4 * v71);
          *v75 = (int)*(float *)&ElementsAttrRawData[4 * v72];
          v75[1] = v74;
          v71 += 2;
        }
        while (v71 != v56);
        goto LABEL_234;
      }
      v56 = 0;
      do
      {
        if (v18)
          v103 = 0;
        else
          v103 = v56;
        *(_DWORD *)(a3 + 4 * v56++) = (int)*(float *)&ElementsAttrRawData[4 * v103];
LABEL_234:
        ;
      }
      while (NumElements != v56);
      return;
    }
    if (mlir::Type::isF64((mlir::Type *)&OperandRange))
    {
      NumElements = 1;
LABEL_148:
      if ((unint64_t)NumElements >= 2)
      {
        v80 = 0;
        v70 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18)
            v81 = 0;
          else
            v81 = v80;
          if (v18)
            v82 = 0;
          else
            v82 = v80 + 1;
          v83 = (int)*(double *)&ElementsAttrRawData[8 * v82];
          v84 = (_DWORD *)(a3 + 4 * v80);
          *v84 = (int)*(double *)&ElementsAttrRawData[8 * v81];
          v84[1] = v83;
          v80 += 2;
        }
        while (v80 != v70);
        goto LABEL_240;
      }
      v70 = 0;
      do
      {
        if (v18)
          v104 = 0;
        else
          v104 = v70;
        *(_DWORD *)(a3 + 4 * v70++) = (int)*(double *)&ElementsAttrRawData[8 * v104];
LABEL_240:
        ;
      }
      while (NumElements != v70);
      return;
    }
    NumElements = 1;
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange))
      goto LABEL_163;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 1))
  {
    if (v18)
      v78 = 1;
    else
      v78 = NumElements;
    llvm::SmallVector<BOOL,40u>::SmallVector((uint64_t)v111, v78);
    mlir::detail::unpackBooleanData(ElementsAttrRawData, v21, (uint64_t)v111[0], (unint64_t)v111[1]);
    v79 = (unsigned __int8 *)v111[0];
    if (NumElements >= 1)
    {
      if (NumElements == 1)
      {
        v91 = 0;
        goto LABEL_248;
      }
      v90 = 0;
      v91 = NumElements & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v18)
          v92 = 0;
        else
          v92 = v90;
        if (v18)
          v93 = 0;
        else
          v93 = v90 + 1;
        v94 = v79[v93];
        v95 = (_DWORD *)(a3 + 4 * v90);
        *v95 = v79[v92];
        v95[1] = v94;
        v90 += 2;
      }
      while (v90 != v91);
      while (NumElements != v91)
      {
LABEL_248:
        if (v18)
          v106 = 0;
        else
          v106 = v91;
        *(_DWORD *)(a3 + 4 * v91++) = v79[v106];
      }
    }
    if (v79 != (unsigned __int8 *)v112)
      free(v79);
  }
  else
  {
    mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
    IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
    mlir::detail::unpackQuantizedData<int>(ElementsAttrRawData, v21, a3, NumElements, IntOrFloatBitWidth);
  }
}

unsigned __int8 *mlir::detail::unpackQuantizedData<int>(unsigned __int8 *result, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  unint64_t v12;
  uint64x2_t v13;
  int32x2_t v14;
  uint64_t v15;
  int32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;

  if (a2)
  {
    v5 = 0;
    v6 = ~(-1 << a5);
    v7 = a4;
    v8 = 8 / a5;
    do
    {
      v9 = v5 * v8;
      v10 = a4 - v5 * v8;
      if (v10 >= v8)
        v10 = 8 / a5;
      if (!v10)
        goto LABEL_3;
      v11 = *result;
      if (v7 >= v8)
        v12 = 8 / a5;
      else
        v12 = v7;
      v13 = (uint64x2_t)vdupq_n_s64(v12 - 1);
      v14 = vmovn_s64((int64x2_t)vcgeq_u64(v13, (uint64x2_t)xmmword_181233120));
      if ((v14.i8[0] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v9) = v6 & v11;
      if ((v14.i8[4] & 1) != 0)
        *(_DWORD *)(a3 + 4 * v9 + 4) = (v11 >> a5) & v6;
      v15 = ((_BYTE)v12 + 1) & 0x1E;
      if (v15 == 2)
        goto LABEL_3;
      v16 = vmovn_s64((int64x2_t)vcgtq_u64(v13, (uint64x2_t)xmmword_181233160));
      if ((v16.i8[0] & 1) != 0)
      {
        *(_DWORD *)(a3 + 4 * v9 + 8) = (v11 >> (2 * a5)) & v6;
        if ((v16.i8[4] & 1) != 0)
        {
LABEL_20:
          *(_DWORD *)(a3 + 4 * v9 + 12) = (v11 >> (3 * a5)) & v6;
          if (v15 == 4)
            goto LABEL_3;
          goto LABEL_21;
        }
      }
      else if ((v16.i8[4] & 1) != 0)
      {
        goto LABEL_20;
      }
      if (v15 == 4)
        goto LABEL_3;
LABEL_21:
      v17 = vmovn_s64((int64x2_t)vcgtq_u64(v13, (uint64x2_t)xmmword_181233170));
      if ((v17.i8[0] & 1) != 0)
      {
        *(_DWORD *)(a3 + 4 * v9 + 16) = (v11 >> (4 * a5)) & v6;
        if ((v17.i8[4] & 1) == 0)
        {
LABEL_23:
          if (v15 != 6)
            goto LABEL_27;
          goto LABEL_3;
        }
      }
      else if ((v17.i8[4] & 1) == 0)
      {
        goto LABEL_23;
      }
      *(_DWORD *)(a3 + 4 * v9 + 20) = (v11 >> (5 * a5)) & v6;
      if (v15 != 6)
      {
LABEL_27:
        v18 = vmovn_s64((int64x2_t)vcgtq_u64(v13, (uint64x2_t)xmmword_181233180));
        if ((v18.i8[0] & 1) != 0)
          *(_DWORD *)(a3 + 4 * v9 + 24) = (v11 >> (6 * a5)) & v6;
        if ((v18.i8[4] & 1) != 0)
          *(_DWORD *)(a3 + 4 * v9 + 28) = (v11 >> (7 * a5)) & v6;
      }
LABEL_3:
      ++v5;
      v7 -= v8;
      ++result;
      --a2;
    }
    while (a2);
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long,unsigned long long,unsigned long long,unsigned long long>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t *Context;
  uint64_t v15;
  char v16;
  mlir::GenericProgramPoint *v17;
  mlir::GenericProgramPoint *v18;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.input_view", (const unsigned __int8 *)0xF, Context);
  if (!v16)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"anec.input_view";
    v23[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::anec::InputView::build(a1, (uint64_t)v25, *a3, *a4, *a5, *a6, *a7);
  v17 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((_QWORD *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id)
    v18 = v17;
  else
    v18 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

_QWORD *mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)1>::~ConvertSlice(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)1>::~ConvertSlice(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t DefiningOp;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t Bias;
  unint64_t matched;
  uint64_t v25;
  uint64_t v26;
  uint64_t ArgAttrsAttr;
  unint64_t PositiveAxis;
  char v29;
  unint64_t v30;
  uint64_t SparseShape;
  unint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  mlir::GenericProgramPoint *v38;
  mlir::Operation *v39;
  uint64_t v40;
  uint64_t v41;
  mlir::Operation *v42;
  uint64_t v43;
  _QWORD v45[2];
  _QWORD *v46;
  uint64_t v47;
  mlir::Operation *v48;
  void **v49;
  void *v50[2];
  uint64_t v51;
  __int128 v52;
  void *v53[2];
  _BYTE v54[16];
  __int16 v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v48 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v46 = v5;
  v47 = v15;
  v50[0] = &v51;
  v50[1] = (void *)0x100000000;
  v45[0] = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v45);
  if (DefiningOp)
  {
    v17 = DefiningOp;
    v18 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v17 + 48) + 32))(*(_QWORD *)(v17 + 48), v18))
    {
      v53[0] = v54;
      v53[1] = (void *)0x100000000;
      mlir::Operation::fold(v17, 0, 0, (uint64_t)v53);
      v19 = (uint64_t *)(*(_QWORD *)v53[0] & 0xFFFFFFFFFFFFFFF8);
      v20 = mlir::DenseIntElementsAttr::classof((uint64_t)v19) & (v19 != 0);
      if (!v20)
        v19 = 0;
      if (v53[0] != v54)
        free(v53[0]);
      if ((v20 & 1) != 0)
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
        if (mlir::getPositivePromotedAxes(v19, v21, (uint64_t)v50, 0, 0))
        {
          v45[0] = mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
          v45[1] = v22;
          Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
          matched = mlir::matchConstantWithIntValue<int>(Bias);
          if ((matched & 0xFF00000000) != 0)
          {
            v25 = (int)matched;
            v26 = *(unsigned int *)v50[0];
            ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v45);
            PositiveAxis = mlir::tryGetPositiveAxis(v25, *(_QWORD *)(ArgAttrsAttr + 8 * v26), 0, 0, 0);
            if (v29)
            {
              v30 = PositiveAxis;
              SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v48);
              v32 = mlir::matchConstantWithIntValue<int>(SparseShape);
              if ((v32 & 0xFF00000000) != 0)
              {
                v33 = v32;
                v34 = *((_QWORD *)v48 + 3);
                v35 = mlir::ValueRange::dereference_iterator(&v52, 0);
                v36 = v33;
                v37 = 1;
                mlir::ConversionPatternRewriter::replaceOp(a4, v48, v38);
                goto LABEL_32;
              }
              goto LABEL_31;
            }
            v53[0] = "failed: could not extract a positive value for start attribute";
            v55 = 259;
            v42 = v48;
            v49 = v53;
            v43 = *((_QWORD *)a4 + 2);
            if (v43)
            {
              if (mlir::RewriterBase::Listener::classof(v43))
              {
                v41 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v43 + 64))(v43, *((_QWORD *)v42 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v49);
                goto LABEL_30;
              }
            }
          }
        }
        else
        {
          v53[0] = "failed: could not extract positive promoted axes";
          v55 = 259;
          v39 = v48;
          v45[0] = v53;
          v40 = *((_QWORD *)a4 + 2);
          if (v40 && mlir::RewriterBase::Listener::classof(v40))
          {
            v41 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v40 + 64))(v40, *((_QWORD *)v39 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v45);
LABEL_30:
            v37 = v41;
            goto LABEL_32;
          }
        }
      }
    }
  }
LABEL_31:
  v37 = 0;
LABEL_32:
  if (v50[0] != &v51)
    free(v50[0]);
  return v37;
}

_QWORD *mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)2>::~ConvertSlice(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)2>::~ConvertSlice(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t DefiningOp;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t Bias;
  unint64_t matched;
  uint64_t v25;
  uint64_t v26;
  uint64_t ArgAttrsAttr;
  unint64_t PositiveAxis;
  char v29;
  uint64_t v30;
  uint64_t SparseShape;
  unint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  mlir::GenericProgramPoint *v38;
  mlir::Operation *v39;
  uint64_t v40;
  uint64_t v41;
  mlir::Operation *v42;
  uint64_t v43;
  _QWORD v45[2];
  _QWORD *v46;
  uint64_t v47;
  mlir::Operation *v48;
  void **v49;
  void *v50[2];
  uint64_t v51;
  __int128 v52;
  void *v53[2];
  _BYTE v54[16];
  __int16 v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v48 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v46 = v5;
  v47 = v15;
  v50[0] = &v51;
  v50[1] = (void *)0x100000000;
  v45[0] = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v45);
  if (DefiningOp)
  {
    v17 = DefiningOp;
    v18 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v17 + 48) + 32))(*(_QWORD *)(v17 + 48), v18))
    {
      v53[0] = v54;
      v53[1] = (void *)0x100000000;
      mlir::Operation::fold(v17, 0, 0, (uint64_t)v53);
      v19 = (uint64_t *)(*(_QWORD *)v53[0] & 0xFFFFFFFFFFFFFFF8);
      v20 = mlir::DenseIntElementsAttr::classof((uint64_t)v19) & (v19 != 0);
      if (!v20)
        v19 = 0;
      if (v53[0] != v54)
        free(v53[0]);
      if ((v20 & 1) != 0)
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
        if (mlir::getPositivePromotedAxes(v19, v21, (uint64_t)v50, 0, 0))
        {
          v45[0] = mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
          v45[1] = v22;
          Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
          matched = mlir::matchConstantWithIntValue<int>(Bias);
          if ((matched & 0xFF00000000) != 0)
          {
            v25 = (int)matched;
            v26 = *(unsigned int *)v50[0];
            ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v45);
            PositiveAxis = mlir::tryGetPositiveAxis(v25, *(_QWORD *)(ArgAttrsAttr + 8 * v26), 0, 0, 0);
            if (v29)
            {
              v30 = PositiveAxis;
              SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v48);
              v32 = mlir::matchConstantWithIntValue<int>(SparseShape);
              if ((v32 & 0xFF00000000) != 0)
              {
                v33 = v32;
                v34 = *((_QWORD *)v48 + 3);
                v35 = mlir::ValueRange::dereference_iterator(&v52, 0);
                v36 = v33;
                v37 = 1;
                mlir::ConversionPatternRewriter::replaceOp(a4, v48, v38);
                goto LABEL_32;
              }
              goto LABEL_31;
            }
            v53[0] = "failed: could not extract a positive value for start attribute";
            v55 = 259;
            v42 = v48;
            v49 = v53;
            v43 = *((_QWORD *)a4 + 2);
            if (v43)
            {
              if (mlir::RewriterBase::Listener::classof(v43))
              {
                v41 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v43 + 64))(v43, *((_QWORD *)v42 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v49);
                goto LABEL_30;
              }
            }
          }
        }
        else
        {
          v53[0] = "failed: could not extract positive promoted axes";
          v55 = 259;
          v39 = v48;
          v45[0] = v53;
          v40 = *((_QWORD *)a4 + 2);
          if (v40 && mlir::RewriterBase::Listener::classof(v40))
          {
            v41 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v40 + 64))(v40, *((_QWORD *)v39 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v45);
LABEL_30:
            v37 = v41;
            goto LABEL_32;
          }
        }
      }
    }
  }
LABEL_31:
  v37 = 0;
LABEL_32:
  if (v50[0] != &v51)
    free(v50[0]);
  return v37;
}

mlir::GenericProgramPoint *mlir::`anonymous namespace'::makeInputViewOp<(mlir::anec::Family)2>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t *v20;
  _QWORD *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t OperandRange;
  _QWORD v30[2];
  uint64_t v31;

  v31 = a3;
  v13 = (uint64_t *)(*(_QWORD *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v13)
    goto LABEL_10;
  v14 = *v13;
  v15 = mlir::TypeID::get<mlir::ShapedType>();
  v16 = *(unsigned int *)(v14 + 16);
  if (!(_DWORD)v16)
    goto LABEL_10;
  v17 = *(_QWORD **)(v14 + 8);
  v18 = &v17[2 * v16];
  do
  {
    v19 = v16 >> 1;
    v20 = &v17[2 * (v16 >> 1)];
    v22 = *v20;
    v21 = v20 + 2;
    v16 += ~(v16 >> 1);
    if (v22 < v15)
      v17 = v21;
    else
      v16 = v19;
  }
  while (v16);
  if (v17 != v18 && *v17 == v15)
    v23 = v17[1];
  else
LABEL_10:
    v23 = 0;
  v30[0] = mlir::getRankPromotionTypeForANE((uint64_t)v13, v23);
  v30[1] = v24;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v30);
  if (!mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    v28 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v30);
    mlir::Type::isF32((mlir::Type *)&v28);
  }
  v28 = a5;
  OperandRange = a4;
  v26 = a7;
  v27 = a6;
  return mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value &,unsigned long long,unsigned long long,unsigned long long,unsigned long long>((mlir::Builder *)(a1 + 8), a2, &v31, &OperandRange, &v28, &v27, &v26);
}

_QWORD *mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)3>::~ConvertSlice(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)3>::~ConvertSlice(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t DefiningOp;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t Bias;
  unint64_t matched;
  uint64_t v25;
  uint64_t v26;
  uint64_t ArgAttrsAttr;
  unint64_t PositiveAxis;
  char v29;
  uint64_t v30;
  uint64_t SparseShape;
  unint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  mlir::GenericProgramPoint *v38;
  mlir::Operation *v39;
  uint64_t v40;
  uint64_t v41;
  mlir::Operation *v42;
  uint64_t v43;
  _QWORD v45[2];
  _QWORD *v46;
  uint64_t v47;
  mlir::Operation *v48;
  void **v49;
  void *v50[2];
  uint64_t v51;
  __int128 v52;
  void *v53[2];
  _BYTE v54[16];
  __int16 v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v48 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v46 = v5;
  v47 = v15;
  v50[0] = &v51;
  v50[1] = (void *)0x100000000;
  v45[0] = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v45);
  if (DefiningOp)
  {
    v17 = DefiningOp;
    v18 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v17 + 48) + 32))(*(_QWORD *)(v17 + 48), v18))
    {
      v53[0] = v54;
      v53[1] = (void *)0x100000000;
      mlir::Operation::fold(v17, 0, 0, (uint64_t)v53);
      v19 = (uint64_t *)(*(_QWORD *)v53[0] & 0xFFFFFFFFFFFFFFF8);
      v20 = mlir::DenseIntElementsAttr::classof((uint64_t)v19) & (v19 != 0);
      if (!v20)
        v19 = 0;
      if (v53[0] != v54)
        free(v53[0]);
      if ((v20 & 1) != 0)
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
        if (mlir::getPositivePromotedAxes(v19, v21, (uint64_t)v50, 0, 0))
        {
          v45[0] = mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
          v45[1] = v22;
          Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
          matched = mlir::matchConstantWithIntValue<int>(Bias);
          if ((matched & 0xFF00000000) != 0)
          {
            v25 = (int)matched;
            v26 = *(unsigned int *)v50[0];
            ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v45);
            PositiveAxis = mlir::tryGetPositiveAxis(v25, *(_QWORD *)(ArgAttrsAttr + 8 * v26), 0, 0, 0);
            if (v29)
            {
              v30 = PositiveAxis;
              SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v48);
              v32 = mlir::matchConstantWithIntValue<int>(SparseShape);
              if ((v32 & 0xFF00000000) != 0)
              {
                v33 = v32;
                v34 = *((_QWORD *)v48 + 3);
                v35 = mlir::ValueRange::dereference_iterator(&v52, 0);
                v36 = v33;
                v37 = 1;
                mlir::ConversionPatternRewriter::replaceOp(a4, v48, v38);
                goto LABEL_32;
              }
              goto LABEL_31;
            }
            v53[0] = "failed: could not extract a positive value for start attribute";
            v55 = 259;
            v42 = v48;
            v49 = v53;
            v43 = *((_QWORD *)a4 + 2);
            if (v43)
            {
              if (mlir::RewriterBase::Listener::classof(v43))
              {
                v41 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v43 + 64))(v43, *((_QWORD *)v42 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v49);
                goto LABEL_30;
              }
            }
          }
        }
        else
        {
          v53[0] = "failed: could not extract positive promoted axes";
          v55 = 259;
          v39 = v48;
          v45[0] = v53;
          v40 = *((_QWORD *)a4 + 2);
          if (v40 && mlir::RewriterBase::Listener::classof(v40))
          {
            v41 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v40 + 64))(v40, *((_QWORD *)v39 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v45);
LABEL_30:
            v37 = v41;
            goto LABEL_32;
          }
        }
      }
    }
  }
LABEL_31:
  v37 = 0;
LABEL_32:
  if (v50[0] != &v51)
    free(v50[0]);
  return v37;
}

_QWORD *mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)4>::~ConvertSlice(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)4>::~ConvertSlice(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t DefiningOp;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t Bias;
  unint64_t matched;
  uint64_t v25;
  uint64_t v26;
  uint64_t ArgAttrsAttr;
  unint64_t PositiveAxis;
  char v29;
  uint64_t v30;
  uint64_t SparseShape;
  unint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  mlir::GenericProgramPoint *v38;
  mlir::Operation *v39;
  uint64_t v40;
  uint64_t v41;
  mlir::Operation *v42;
  uint64_t v43;
  _QWORD v45[2];
  _QWORD *v46;
  uint64_t v47;
  mlir::Operation *v48;
  void **v49;
  void *v50[2];
  uint64_t v51;
  __int128 v52;
  void *v53[2];
  _BYTE v54[16];
  __int16 v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v48 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v46 = v5;
  v47 = v15;
  v50[0] = &v51;
  v50[1] = (void *)0x100000000;
  v45[0] = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v45);
  if (DefiningOp)
  {
    v17 = DefiningOp;
    v18 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v17 + 48) + 32))(*(_QWORD *)(v17 + 48), v18))
    {
      v53[0] = v54;
      v53[1] = (void *)0x100000000;
      mlir::Operation::fold(v17, 0, 0, (uint64_t)v53);
      v19 = (uint64_t *)(*(_QWORD *)v53[0] & 0xFFFFFFFFFFFFFFF8);
      v20 = mlir::DenseIntElementsAttr::classof((uint64_t)v19) & (v19 != 0);
      if (!v20)
        v19 = 0;
      if (v53[0] != v54)
        free(v53[0]);
      if ((v20 & 1) != 0)
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
        if (mlir::getPositivePromotedAxes(v19, v21, (uint64_t)v50, 0, 0))
        {
          v45[0] = mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
          v45[1] = v22;
          Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
          matched = mlir::matchConstantWithIntValue<int>(Bias);
          if ((matched & 0xFF00000000) != 0)
          {
            v25 = (int)matched;
            v26 = *(unsigned int *)v50[0];
            ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v45);
            PositiveAxis = mlir::tryGetPositiveAxis(v25, *(_QWORD *)(ArgAttrsAttr + 8 * v26), 0, 0, 0);
            if (v29)
            {
              v30 = PositiveAxis;
              SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v48);
              v32 = mlir::matchConstantWithIntValue<int>(SparseShape);
              if ((v32 & 0xFF00000000) != 0)
              {
                v33 = v32;
                v34 = *((_QWORD *)v48 + 3);
                v35 = mlir::ValueRange::dereference_iterator(&v52, 0);
                v36 = v33;
                v37 = 1;
                mlir::ConversionPatternRewriter::replaceOp(a4, v48, v38);
                goto LABEL_32;
              }
              goto LABEL_31;
            }
            v53[0] = "failed: could not extract a positive value for start attribute";
            v55 = 259;
            v42 = v48;
            v49 = v53;
            v43 = *((_QWORD *)a4 + 2);
            if (v43)
            {
              if (mlir::RewriterBase::Listener::classof(v43))
              {
                v41 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v43 + 64))(v43, *((_QWORD *)v42 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v49);
                goto LABEL_30;
              }
            }
          }
        }
        else
        {
          v53[0] = "failed: could not extract positive promoted axes";
          v55 = 259;
          v39 = v48;
          v45[0] = v53;
          v40 = *((_QWORD *)a4 + 2);
          if (v40 && mlir::RewriterBase::Listener::classof(v40))
          {
            v41 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v40 + 64))(v40, *((_QWORD *)v39 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v45);
LABEL_30:
            v37 = v41;
            goto LABEL_32;
          }
        }
      }
    }
  }
LABEL_31:
  v37 = 0;
LABEL_32:
  if (v50[0] != &v51)
    free(v50[0]);
  return v37;
}

_QWORD *mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)5>::~ConvertSlice(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)5>::~ConvertSlice(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t DefiningOp;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t Bias;
  unint64_t matched;
  uint64_t v25;
  uint64_t v26;
  uint64_t ArgAttrsAttr;
  unint64_t PositiveAxis;
  char v29;
  uint64_t v30;
  uint64_t SparseShape;
  unint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  mlir::GenericProgramPoint *v38;
  mlir::Operation *v39;
  uint64_t v40;
  uint64_t v41;
  mlir::Operation *v42;
  uint64_t v43;
  _QWORD v45[2];
  _QWORD *v46;
  uint64_t v47;
  mlir::Operation *v48;
  void **v49;
  void *v50[2];
  uint64_t v51;
  __int128 v52;
  void *v53[2];
  _BYTE v54[16];
  __int16 v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v48 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v46 = v5;
  v47 = v15;
  v50[0] = &v51;
  v50[1] = (void *)0x100000000;
  v45[0] = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v45);
  if (DefiningOp)
  {
    v17 = DefiningOp;
    v18 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v17 + 48) + 32))(*(_QWORD *)(v17 + 48), v18))
    {
      v53[0] = v54;
      v53[1] = (void *)0x100000000;
      mlir::Operation::fold(v17, 0, 0, (uint64_t)v53);
      v19 = (uint64_t *)(*(_QWORD *)v53[0] & 0xFFFFFFFFFFFFFFF8);
      v20 = mlir::DenseIntElementsAttr::classof((uint64_t)v19) & (v19 != 0);
      if (!v20)
        v19 = 0;
      if (v53[0] != v54)
        free(v53[0]);
      if ((v20 & 1) != 0)
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
        if (mlir::getPositivePromotedAxes(v19, v21, (uint64_t)v50, 0, 0))
        {
          v45[0] = mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
          v45[1] = v22;
          Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
          matched = mlir::matchConstantWithIntValue<int>(Bias);
          if ((matched & 0xFF00000000) != 0)
          {
            v25 = (int)matched;
            v26 = *(unsigned int *)v50[0];
            ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v45);
            PositiveAxis = mlir::tryGetPositiveAxis(v25, *(_QWORD *)(ArgAttrsAttr + 8 * v26), 0, 0, 0);
            if (v29)
            {
              v30 = PositiveAxis;
              SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v48);
              v32 = mlir::matchConstantWithIntValue<int>(SparseShape);
              if ((v32 & 0xFF00000000) != 0)
              {
                v33 = v32;
                v34 = *((_QWORD *)v48 + 3);
                v35 = mlir::ValueRange::dereference_iterator(&v52, 0);
                v36 = v33;
                v37 = 1;
                mlir::ConversionPatternRewriter::replaceOp(a4, v48, v38);
                goto LABEL_32;
              }
              goto LABEL_31;
            }
            v53[0] = "failed: could not extract a positive value for start attribute";
            v55 = 259;
            v42 = v48;
            v49 = v53;
            v43 = *((_QWORD *)a4 + 2);
            if (v43)
            {
              if (mlir::RewriterBase::Listener::classof(v43))
              {
                v41 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v43 + 64))(v43, *((_QWORD *)v42 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v49);
                goto LABEL_30;
              }
            }
          }
        }
        else
        {
          v53[0] = "failed: could not extract positive promoted axes";
          v55 = 259;
          v39 = v48;
          v45[0] = v53;
          v40 = *((_QWORD *)a4 + 2);
          if (v40 && mlir::RewriterBase::Listener::classof(v40))
          {
            v41 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v40 + 64))(v40, *((_QWORD *)v39 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v45);
LABEL_30:
            v37 = v41;
            goto LABEL_32;
          }
        }
      }
    }
  }
LABEL_31:
  v37 = 0;
LABEL_32:
  if (v50[0] != &v51)
    free(v50[0]);
  return v37;
}

_QWORD *mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)6>::~ConvertSlice(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)6>::~ConvertSlice(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertSlice<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::ConversionPatternRewriter *a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t DefiningOp;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t Bias;
  unint64_t matched;
  uint64_t v25;
  uint64_t v26;
  uint64_t ArgAttrsAttr;
  unint64_t PositiveAxis;
  char v29;
  uint64_t v30;
  uint64_t SparseShape;
  unint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  mlir::GenericProgramPoint *v38;
  mlir::Operation *v39;
  uint64_t v40;
  uint64_t v41;
  mlir::Operation *v42;
  uint64_t v43;
  _QWORD v45[2];
  _QWORD *v46;
  uint64_t v47;
  mlir::Operation *v48;
  void **v49;
  void *v50[2];
  uint64_t v51;
  __int128 v52;
  void *v53[2];
  _BYTE v54[16];
  __int16 v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v48 = a2;
  v52 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v48) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v46 = v5;
  v47 = v15;
  v50[0] = &v51;
  v50[1] = (void *)0x100000000;
  v45[0] = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v45);
  if (DefiningOp)
  {
    v17 = DefiningOp;
    v18 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v17 + 48) + 32))(*(_QWORD *)(v17 + 48), v18))
    {
      v53[0] = v54;
      v53[1] = (void *)0x100000000;
      mlir::Operation::fold(v17, 0, 0, (uint64_t)v53);
      v19 = (uint64_t *)(*(_QWORD *)v53[0] & 0xFFFFFFFFFFFFFFF8);
      v20 = mlir::DenseIntElementsAttr::classof((uint64_t)v19) & (v19 != 0);
      if (!v20)
        v19 = 0;
      if (v53[0] != v54)
        free(v53[0]);
      if ((v20 & 1) != 0)
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
        if (mlir::getPositivePromotedAxes(v19, v21, (uint64_t)v50, 0, 0))
        {
          v45[0] = mlir::getRankPromotionTypeForANE((uint64_t)v46, v47);
          v45[1] = v22;
          Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v48);
          matched = mlir::matchConstantWithIntValue<int>(Bias);
          if ((matched & 0xFF00000000) != 0)
          {
            v25 = (int)matched;
            v26 = *(unsigned int *)v50[0];
            ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v45);
            PositiveAxis = mlir::tryGetPositiveAxis(v25, *(_QWORD *)(ArgAttrsAttr + 8 * v26), 0, 0, 0);
            if (v29)
            {
              v30 = PositiveAxis;
              SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v48);
              v32 = mlir::matchConstantWithIntValue<int>(SparseShape);
              if ((v32 & 0xFF00000000) != 0)
              {
                v33 = v32;
                v34 = *((_QWORD *)v48 + 3);
                v35 = mlir::ValueRange::dereference_iterator(&v52, 0);
                v36 = v33;
                v37 = 1;
                mlir::ConversionPatternRewriter::replaceOp(a4, v48, v38);
                goto LABEL_32;
              }
              goto LABEL_31;
            }
            v53[0] = "failed: could not extract a positive value for start attribute";
            v55 = 259;
            v42 = v48;
            v49 = v53;
            v43 = *((_QWORD *)a4 + 2);
            if (v43)
            {
              if (mlir::RewriterBase::Listener::classof(v43))
              {
                v41 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v43 + 64))(v43, *((_QWORD *)v42 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v49);
                goto LABEL_30;
              }
            }
          }
        }
        else
        {
          v53[0] = "failed: could not extract positive promoted axes";
          v55 = 259;
          v39 = v48;
          v45[0] = v53;
          v40 = *((_QWORD *)a4 + 2);
          if (v40 && mlir::RewriterBase::Listener::classof(v40))
          {
            v41 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v40 + 64))(v40, *((_QWORD *)v39 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SliceOp &>(mlir::mps::SliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v45);
LABEL_30:
            v37 = v41;
            goto LABEL_32;
          }
        }
      }
    }
  }
LABEL_31:
  v37 = 0;
LABEL_32:
  if (v50[0] != &v51)
    free(v50[0]);
  return v37;
}

_QWORD *mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)0>::~ConvertStridedSlice(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)0>::~ConvertStridedSlice(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::StridedSliceOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::StridedSliceOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[72];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::StridedSliceOpGenericAdaptorBase::StridedSliceOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::StridedSliceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[72];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::StridedSliceOpGenericAdaptorBase::StridedSliceOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::StridedSliceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[5];
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 72);
  v9 = *(_QWORD *)(a3 + 80);
  v36 = v8;
  v37 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v28;
      v34[4] = *(_OWORD *)(a3 + 64);
      v35 = *(_QWORD *)(a3 + 80);
      v29 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v36 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v37 = v23;
      if (v36)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v36);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v36, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v37;
    if (v36 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  int64_t v16;
  int64_t v17;
  _BOOL4 IsSize;
  uint64_t v19;
  void **Filter;
  uint64_t v21;
  void **Bias;
  uint64_t v23;
  void **SparseShape;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int Index;
  uint64_t v29;
  unsigned int EndMask;
  uint64_t v31;
  unsigned int Groups;
  char *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  mlir::anec *i;
  uint64_t v39;
  uint64_t ArgAttrsAttr;
  _QWORD *j;
  uint64_t v42;
  mlir::anec **v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *k;
  uint64_t v48;
  uint64_t v49;
  mlir::anec **v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  _QWORD *m;
  uint64_t v59;
  mlir::anec **v60;
  mlir::anec **v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t *v69;
  mlir::anec *v70;
  uint64_t *v71;
  _QWORD *n;
  mlir::anec *v73;
  mlir::anec **v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  void *v78;
  mlir::AffineMap *v79;
  uint64_t ElementTypeOrSelf;
  uint64_t *v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int *v84;
  uint64_t *v86;
  uint64_t v87[2];
  _QWORD v88[2];
  _QWORD v89[2];
  char *v90;
  uint64_t v91;
  unint64_t v92[2];
  void *v93;
  uint64_t v94;
  _BYTE v95[32];
  mlir::anec **v96;
  uint64_t v97;
  _QWORD v98[6];
  _QWORD *v99;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  _BYTE v103[40];
  _QWORD **v104;
  _QWORD *v105;
  uint64_t v106;
  void *v107;
  uint64_t v108;
  _WORD v109[20];
  _QWORD **v110;
  _QWORD *v111;
  uint64_t v112;
  void *v113;
  uint64_t v114;
  _BYTE v115[40];
  void *v116[2];
  _BYTE v117[40];
  void *v118[2];
  _BYTE v119[40];
  __int128 v120;
  uint64_t v121;

  v121 = *MEMORY[0x1E0C80C00];
  v91 = a2;
  v120 = *(_OWORD *)(a3 + 72);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v107 = v5;
  v108 = v15;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v107);
  v17 = v16;
  IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v91);
  v118[0] = v119;
  v118[1] = (void *)0x500000000;
  v19 = v91;
  Filter = (void **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v91);
  {
    v63 = 0;
    goto LABEL_126;
  }
  v116[0] = v117;
  v116[1] = (void *)0x500000000;
  v21 = v91;
  Bias = (void **)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v91);
  {
    v113 = v115;
    v114 = 0x500000000;
    v23 = v91;
    SparseShape = (void **)mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v91);
    if ((_DWORD)v114)
    {
      v25 = (uint64_t *)v113;
      v26 = 8 * v114;
      while (*v25 > 0)
      {
        ++v25;
        v26 -= 8;
        if (!v26)
          goto LABEL_18;
      }
      v107 = "failed: non strictly positive strides are not supported";
      v109[8] = 259;
      v64 = v91;
      v101 = &v107;
      v65 = *(_QWORD *)(a4 + 16);
      if (v65 && mlir::RewriterBase::Listener::classof(v65))
      {
        v63 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v65 + 64))(v65, *(_QWORD *)(v64 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v101);
        goto LABEL_122;
      }
LABEL_89:
      v63 = 0;
LABEL_122:
      if (v113 != v115)
        free(v113);
      goto LABEL_124;
    }
LABEL_18:
    v107 = v109;
    v108 = 0x500000000;
    v111 = 0;
    v112 = 0;
    v110 = &v111;
    v27 = v91;
    Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v91);
    {
      v101 = v103;
      v102 = 0x500000000;
      v105 = 0;
      v106 = 0;
      v104 = &v105;
      v29 = v91;
      EndMask = mlir::mps::StridedSliceGradientOp::getEndMask((mlir::mps::StridedSliceGradientOp *)&v91);
      {
        v96 = (mlir::anec **)v98;
        v97 = 0x500000000;
        v99 = 0;
        v100 = 0;
        v98[5] = &v99;
        v31 = v91;
        Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v91);
        {
          v33 = (char *)mlir::ValueRange::dereference_iterator(&v120, 0);
          v90 = v33;
          v93 = (void *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
          v34 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
          v89[0] = mlir::getRankPromotionTypeForANE((uint64_t)v34, v35);
          v89[1] = v36;
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
          if (v37 >= 1)
          {
            for (i = 0; (uint64_t)i < v39; i = (mlir::anec *)((char *)i + 1))
            {
              ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
              if (v112)
              {
                for (j = v111; j; j = (_QWORD *)*j)
                {
                  v42 = j[4];
                  if ((uint64_t)i >= v42)
                  {
                    if (v42 >= (uint64_t)i)
                      goto LABEL_39;
                    ++j;
                  }
                }
              }
              else if ((_DWORD)v108)
              {
                v43 = (mlir::anec **)v107;
                v44 = 8 * v108;
                while (*v43 != i)
                {
                  ++v43;
                  v44 -= 8;
                  if (!v44)
                    goto LABEL_40;
                }
                if (v44)
                {
LABEL_39:
                  v45 = 0;
                  goto LABEL_41;
                }
              }
LABEL_40:
              v45 = *((_QWORD *)v118[0] + (_QWORD)i);
LABEL_41:
              v46 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (v106)
              {
                for (k = v105; k; k = (_QWORD *)*k)
                {
                  v48 = k[4];
                  if ((uint64_t)i >= v48)
                  {
                    if (v48 >= (uint64_t)i)
                    {
                      v49 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
                      goto LABEL_56;
                    }
                    ++k;
                  }
                }
LABEL_55:
                v49 = *((_QWORD *)v116[0] + (_QWORD)i);
                goto LABEL_56;
              }
              if (!(_DWORD)v102)
                goto LABEL_55;
              v50 = (mlir::anec **)v101;
              v51 = 8 * v102;
              while (*v50 != i)
              {
                ++v50;
                v51 -= 8;
                if (!v51)
                  goto LABEL_55;
              }
              v49 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (!v51)
                goto LABEL_55;
LABEL_56:
              v52 = *((_QWORD *)v113 + (_QWORD)i);
              v53 = v49 + v45;
              if (v49 == -1)
                v53 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (!IsSize)
                v53 = v49;
              v54 = (v46 & (v45 >> 63)) + v45;
              v55 = (v46 & (v53 >> 63)) + v53;
              if (v46 - 1 < v54)
                v54 = v46 - 1;
              v56 = v54 & ~(v54 >> 63);
              if (v46 >= v55)
                v57 = v55;
              else
                v57 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (v100)
              {
                for (m = v99; m; m = (_QWORD *)*m)
                {
                  v59 = m[4];
                  if ((uint64_t)i >= v59)
                  {
                    if (v59 >= (uint64_t)i)
                      goto LABEL_79;
                    ++m;
                  }
                }
              }
              else if ((_DWORD)v97)
              {
                v60 = v96;
                v61 = &v96[v97];
                while (*v60 != i)
                {
                  if (++v60 == v61)
                    goto LABEL_81;
                }
                if (v60 != v61)
                {
LABEL_79:
                  v62 = 1;
                  if (v46 == 1)
                    goto LABEL_24;
                  goto LABEL_23;
                }
              }
LABEL_81:
              v62 = (uint64_t)(v52 + ~v56 + (v57 & ~(v57 >> 63))) / v52;
              if (v62 == v46)
                goto LABEL_24;
LABEL_23:
              v90 = v33;
LABEL_24:
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
            }
          }
          if ((_DWORD)v97 || v100)
          {
            v93 = (void *)(*((_QWORD *)v33 + 1) & 0xFFFFFFFFFFFFFFF8);
            v88[0] = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
            v88[1] = v66;
            v93 = v95;
            v94 = 0x400000000;
            v67 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v88);
            if (v68)
            {
              v69 = (uint64_t *)v67;
              v70 = 0;
              v71 = (uint64_t *)(v67 + 8 * v68);
              do
              {
                if (v100)
                {
                  for (n = v99; n; n = (_QWORD *)*n)
                  {
                    v73 = (mlir::anec *)n[4];
                    if ((uint64_t)v70 >= (uint64_t)v73)
                    {
                      if ((uint64_t)v73 >= (uint64_t)v70)
                        goto LABEL_96;
                      ++n;
                    }
                  }
                }
                else if ((_DWORD)v97)
                {
                  v74 = v96;
                  v75 = 8 * v97;
                  while (*v74 != v70)
                  {
                    ++v74;
                    v75 -= 8;
                    if (!v75)
                      goto LABEL_109;
                  }
                  if (v75)
                    goto LABEL_96;
                }
LABEL_109:
                v76 = *v69;
                v77 = v94;
                if (v94 >= (unint64_t)HIDWORD(v94))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v95, v94 + 1, 8);
                  v77 = v94;
                }
                *((_QWORD *)v93 + v77) = v76;
                LODWORD(v94) = v94 + 1;
LABEL_96:
                v70 = (mlir::anec *)((char *)v70 + 1);
                ++v69;
              }
              while (v69 != v71);
            }
            v78 = v93;
            v79 = (mlir::AffineMap *)v94;
            ElementTypeOrSelf = mlir::getElementTypeOrSelf((uint64_t)v33);
            v86 = (uint64_t *)mlir::MemRefType::get(v78, v79, ElementTypeOrSelf, 0, 0, 0);
            v81 = mlir::Type::cast<mlir::ShapedType>(&v86);
            v87[0] = mlir::getRankPromotionTypeForANE((uint64_t)v81, v82);
            v87[1] = v83;
            v33 = (char *)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v91 + 24), v87, (uint64_t *)&v90)- 16;
            v90 = v33;
            if (v93 != v95)
            {
              free(v93);
              v33 = v90;
            }
          }
          v84 = (unsigned int *)v91;
          v93 = v33;
          v63 = 1;
          mlir::ValueRange::ValueRange(v92, (uint64_t)&v93, 1uLL);
          mlir::ConversionPatternRewriter::replaceOp(a4, v84, v92[0], v92[1]);
        }
        else
        {
          v63 = 0;
        }
        llvm::SmallSet<long long,5u,std::less<long long>>::~SmallSet((uint64_t)&v96);
      }
      else
      {
        v63 = 0;
      }
      std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v104, v105);
      if (v101 != v103)
        free(v101);
    }
    else
    {
      v63 = 0;
    }
    std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v110, v111);
    if (v107 != v109)
      free(v107);
    goto LABEL_122;
  }
  v63 = 0;
LABEL_124:
  if (v116[0] != v117)
    free(v116[0]);
LABEL_126:
  if (v118[0] != v119)
    free(v118[0]);
  return v63;
}

uint64_t mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)0>::promoteAxesValues(uint64_t a1, uint64_t a2, void **a3, unint64_t a4, uint64_t a5)
{
  uint64_t DefiningOp;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  void **v21;
  void *v22[2];
  _WORD v23[12];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v21 = a3;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v21);
  if (!DefiningOp)
    goto LABEL_11;
  v10 = DefiningOp;
  v11 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v10 + 48) + 32))(*(_QWORD *)(v10 + 48), v11))
    goto LABEL_11;
  v22[0] = v23;
  v22[1] = (void *)0x100000000;
  mlir::Operation::fold(v10, 0, 0, (uint64_t)v22);
  v13 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v22[0] & 0xFFFFFFFFFFFFFFF8));
  if (v13)
    v14 = v12;
  else
    v14 = 0;
  if (v22[0] != v23)
    free(v22[0]);
  if (v13)
  {
    v15 = 1;
    mlir::getIntValues<long long>((uint64_t)v13, v14, a5, 1);
    switch(*(_DWORD *)(a5 + 8))
    {
      case 0:
        v16 = *(_QWORD *)a5;
        v17 = a5;
        v18 = 4;
        goto LABEL_17;
      case 1:
        v16 = *(_QWORD *)a5;
        v17 = a5;
        v18 = 3;
LABEL_17:
        llvm::SmallVectorImpl<long long>::insert(v17, v16, v18, a4);
        v15 = 1;
        break;
      case 2:
        v15 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5 + 8, 1uLL, a4);
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5, 1uLL, a4);
        break;
      case 3:
        v15 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5 + 16, 1uLL, a4);
        break;
      default:
        return v15;
    }
  }
  else
  {
LABEL_11:
    v23[8] = 259;
    v21 = v22;
    v22[0] = "failed: axes value must be a constant";
    v19 = *(_QWORD *)(a1 + 16);
    if (v19 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v19 + 64))(v19, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v21);
    else
      return 0;
  }
  return v15;
}

uint64_t mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)0>::getFlagsToPositivePromotedAxes(uint64_t a1, uint64_t a2, unsigned int a3, int64_t a4, uint64_t a5)
{
  unsigned int v10;
  uint64_t v11;
  unsigned int i;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t **v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v19[4];
  __int16 v20;
  _QWORD *v21;
  void *v22;
  uint64_t v23;
  _BYTE v24[40];
  void *v25;
  uint64_t v26;
  _QWORD v27[6];

  v27[5] = *MEMORY[0x1E0C80C00];
  v25 = v27;
  v26 = 0x500000000;
  if (a4 < 1)
  {
    v10 = 0;
    v13 = v27;
  }
  else
  {
    v10 = 0;
    v11 = 0;
    for (i = 0; i < a4; v11 = ++i)
    {
      if (((a3 >> i) & 1) != 0)
      {
        if (v10 >= HIDWORD(v26))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v10 + 1, 8);
          v10 = v26;
        }
        *((_QWORD *)v25 + v10) = v11;
        v10 = v26 + 1;
        LODWORD(v26) = v26 + 1;
      }
    }
    v13 = (uint64_t *)v25;
  }
  v22 = v24;
  v23 = 0x500000000;
  if (mlir::getPositivePromotedAxes(v13, v10, a4, (uint64_t)&v22, 0, 0))
  {
    v14 = *(_QWORD **)(a5 + 64);
    *(_DWORD *)(a5 + 8) = 0;
    std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy(a5 + 56, v14);
    *(_QWORD *)(a5 + 56) = a5 + 64;
    *(_QWORD *)(a5 + 64) = 0;
    *(_QWORD *)(a5 + 72) = 0;
    if ((_DWORD)v23)
    {
      v15 = (uint64_t **)v22;
      v16 = 8 * v23;
      do
      {
        llvm::SmallSet<long long,5u,std::less<long long>>::insert(a5, v15++, (uint64_t)v19);
        v16 -= 8;
      }
      while (v16);
    }
    v17 = 1;
  }
  else
  {
    v19[0] = "failed: could not extract positive promoted axes";
    v20 = 259;
    v21 = v19;
    v17 = *(_QWORD *)(a1 + 16);
    if (v17)
    {
      if (mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
        v17 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v21);
      else
        v17 = 0;
    }
  }
  if (v22 != v24)
    free(v22);
  if (v25 != v27)
    free(v25);
  return v17;
}

uint64_t llvm::SmallSet<long long,5u,std::less<long long>>::~SmallSet(uint64_t a1)
{
  std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy(a1 + 56, *(_QWORD **)(a1 + 64));
  if (*(_QWORD *)a1 != a1 + 16)
    free(*(void **)a1);
  return a1;
}

void llvm::SmallSet<long long,5u,std::less<long long>>::insert(uint64_t a1@<X0>, uint64_t **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t *v6;
  uint64_t **v7;
  uint64_t *v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  char v14;
  uint64_t **v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;
  unsigned int v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t **v24;
  uint64_t **v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;

  if (!*(_QWORD *)(a1 + 72))
  {
    v15 = *(uint64_t ***)a1;
    v16 = *(unsigned int *)(a1 + 8);
    v17 = *a2;
    if (!(_DWORD)v16)
      goto LABEL_21;
    v18 = 8 * v16;
    v9 = *(uint64_t ***)a1;
    while (*v9 != v17)
    {
      ++v9;
      v18 -= 8;
      if (!v18)
        goto LABEL_20;
    }
    if (v18)
    {
      v19 = 0;
      v14 = 1;
      goto LABEL_25;
    }
LABEL_20:
    if (v16 <= 4)
    {
LABEL_21:
      if (v16 >= *(_DWORD *)(a1 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v16 + 1, 8);
        v16 = *(unsigned int *)(a1 + 8);
        v15 = *(uint64_t ***)a1;
      }
      v15[v16] = v17;
      v20 = *(_DWORD *)(a1 + 8) + 1;
      *(_DWORD *)(a1 + 8) = v20;
      v9 = (uint64_t **)(*(_QWORD *)a1 + 8 * v20 - 8);
      v14 = 1;
      goto LABEL_24;
    }
    v7 = (uint64_t **)(a1 + 64);
    do
    {
      v22 = *(uint64_t **)(a1 + 64);
      v23 = *(_QWORD *)(*(_QWORD *)a1 + 8 * v16 - 8);
      v24 = (uint64_t **)(a1 + 64);
      v25 = (uint64_t **)(a1 + 64);
      if (v22)
      {
        while (1)
        {
          while (1)
          {
            v25 = (uint64_t **)v22;
            v26 = v22[4];
            if (v23 >= v26)
              break;
            v22 = *v25;
            v24 = v25;
            if (!*v25)
              goto LABEL_37;
          }
          if (v26 >= v23)
            break;
          v22 = v25[1];
          if (!v22)
          {
            v24 = v25 + 1;
            goto LABEL_37;
          }
        }
      }
      else
      {
LABEL_37:
        v27 = (uint64_t *)operator new(0x28uLL);
        v27[4] = v23;
        *v27 = 0;
        v27[1] = 0;
        v27[2] = (uint64_t)v25;
        *v24 = v27;
        v28 = **(_QWORD **)(a1 + 56);
        if (v28)
        {
          *(_QWORD *)(a1 + 56) = v28;
          v21 = *v24;
        }
        else
        {
          v21 = v27;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 64), v21);
        ++*(_QWORD *)(a1 + 72);
        LODWORD(v16) = *(_DWORD *)(a1 + 8);
      }
      LODWORD(v16) = v16 - 1;
      *(_DWORD *)(a1 + 8) = v16;
    }
    while ((_DWORD)v16);
    v8 = *a2;
    v29 = *v7;
    v9 = (uint64_t **)(a1 + 64);
    if (*v7)
    {
      while (1)
      {
        while (1)
        {
          v9 = (uint64_t **)v29;
          v30 = v29[4];
          if ((uint64_t)v8 >= v30)
            break;
          v29 = *v9;
          v7 = v9;
          if (!*v9)
            goto LABEL_9;
        }
        if (v30 >= (uint64_t)v8)
          break;
        v29 = v9[1];
        if (!v29)
        {
LABEL_8:
          v7 = v9 + 1;
          goto LABEL_9;
        }
      }
      v14 = 0;
      goto LABEL_24;
    }
LABEL_9:
    v11 = (uint64_t *)v9;
    v9 = (uint64_t **)operator new(0x28uLL);
    v9[4] = v8;
    *v9 = 0;
    v9[1] = 0;
    v9[2] = v11;
    *v7 = (uint64_t *)v9;
    v12 = **(_QWORD **)(a1 + 56);
    v13 = (uint64_t *)v9;
    if (v12)
    {
      *(_QWORD *)(a1 + 56) = v12;
      v13 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 64), v13);
    v14 = 0;
    ++*(_QWORD *)(a1 + 72);
LABEL_24:
    v19 = 1;
    goto LABEL_25;
  }
  v7 = (uint64_t **)(a1 + 64);
  v6 = *(uint64_t **)(a1 + 64);
  v8 = *a2;
  if (!v6)
  {
    v9 = (uint64_t **)(a1 + 64);
    goto LABEL_9;
  }
  while (1)
  {
    while (1)
    {
      v9 = (uint64_t **)v6;
      v10 = (uint64_t *)v6[4];
      if ((uint64_t)v8 >= (uint64_t)v10)
        break;
      v6 = *v9;
      v7 = v9;
      if (!*v9)
        goto LABEL_9;
    }
    if ((uint64_t)v10 >= (uint64_t)v8)
      break;
    v6 = v9[1];
    if (!v6)
      goto LABEL_8;
  }
  v14 = 0;
  v19 = 0;
LABEL_25:
  *(_BYTE *)(a3 + 8) = v14;
  *(_QWORD *)a3 = v9;
  *(_BYTE *)(a3 + 16) = v19;
}

_QWORD *mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)1>::~ConvertStridedSlice(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)1>::~ConvertStridedSlice(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  int64_t v16;
  int64_t v17;
  _BOOL4 IsSize;
  uint64_t v19;
  void **Filter;
  uint64_t v21;
  void **Bias;
  uint64_t v23;
  void **SparseShape;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int Index;
  uint64_t v29;
  unsigned int EndMask;
  uint64_t v31;
  unsigned int Groups;
  char *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  mlir::anec *i;
  uint64_t v39;
  uint64_t ArgAttrsAttr;
  _QWORD *j;
  uint64_t v42;
  mlir::anec **v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *k;
  uint64_t v48;
  uint64_t v49;
  mlir::anec **v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  _QWORD *m;
  uint64_t v59;
  mlir::anec **v60;
  mlir::anec **v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t *v69;
  mlir::anec *v70;
  uint64_t *v71;
  _QWORD *n;
  mlir::anec *v73;
  mlir::anec **v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  void *v78;
  mlir::AffineMap *v79;
  uint64_t ElementTypeOrSelf;
  uint64_t *v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int *v84;
  uint64_t *v86;
  uint64_t v87[2];
  _QWORD v88[2];
  _QWORD v89[2];
  char *v90;
  uint64_t v91;
  unint64_t v92[2];
  void *v93;
  uint64_t v94;
  _BYTE v95[32];
  mlir::anec **v96;
  uint64_t v97;
  _QWORD v98[6];
  _QWORD *v99;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  _BYTE v103[40];
  _QWORD **v104;
  _QWORD *v105;
  uint64_t v106;
  void *v107;
  uint64_t v108;
  _WORD v109[20];
  _QWORD **v110;
  _QWORD *v111;
  uint64_t v112;
  void *v113;
  uint64_t v114;
  _BYTE v115[40];
  void *v116[2];
  _BYTE v117[40];
  void *v118[2];
  _BYTE v119[40];
  __int128 v120;
  uint64_t v121;

  v121 = *MEMORY[0x1E0C80C00];
  v91 = a2;
  v120 = *(_OWORD *)(a3 + 72);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v107 = v5;
  v108 = v15;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v107);
  v17 = v16;
  IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v91);
  v118[0] = v119;
  v118[1] = (void *)0x500000000;
  v19 = v91;
  Filter = (void **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v91);
  {
    v63 = 0;
    goto LABEL_126;
  }
  v116[0] = v117;
  v116[1] = (void *)0x500000000;
  v21 = v91;
  Bias = (void **)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v91);
  {
    v113 = v115;
    v114 = 0x500000000;
    v23 = v91;
    SparseShape = (void **)mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v91);
    if ((_DWORD)v114)
    {
      v25 = (uint64_t *)v113;
      v26 = 8 * v114;
      while (*v25 > 0)
      {
        ++v25;
        v26 -= 8;
        if (!v26)
          goto LABEL_18;
      }
      v107 = "failed: non strictly positive strides are not supported";
      v109[8] = 259;
      v64 = v91;
      v101 = &v107;
      v65 = *(_QWORD *)(a4 + 16);
      if (v65 && mlir::RewriterBase::Listener::classof(v65))
      {
        v63 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v65 + 64))(v65, *(_QWORD *)(v64 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v101);
        goto LABEL_122;
      }
LABEL_89:
      v63 = 0;
LABEL_122:
      if (v113 != v115)
        free(v113);
      goto LABEL_124;
    }
LABEL_18:
    v107 = v109;
    v108 = 0x500000000;
    v111 = 0;
    v112 = 0;
    v110 = &v111;
    v27 = v91;
    Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v91);
    {
      v101 = v103;
      v102 = 0x500000000;
      v105 = 0;
      v106 = 0;
      v104 = &v105;
      v29 = v91;
      EndMask = mlir::mps::StridedSliceGradientOp::getEndMask((mlir::mps::StridedSliceGradientOp *)&v91);
      {
        v96 = (mlir::anec **)v98;
        v97 = 0x500000000;
        v99 = 0;
        v100 = 0;
        v98[5] = &v99;
        v31 = v91;
        Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v91);
        {
          v33 = (char *)mlir::ValueRange::dereference_iterator(&v120, 0);
          v90 = v33;
          v93 = (void *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
          v34 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
          v89[0] = mlir::getRankPromotionTypeForANE((uint64_t)v34, v35);
          v89[1] = v36;
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
          if (v37 >= 1)
          {
            for (i = 0; (uint64_t)i < v39; i = (mlir::anec *)((char *)i + 1))
            {
              ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
              if (v112)
              {
                for (j = v111; j; j = (_QWORD *)*j)
                {
                  v42 = j[4];
                  if ((uint64_t)i >= v42)
                  {
                    if (v42 >= (uint64_t)i)
                      goto LABEL_39;
                    ++j;
                  }
                }
              }
              else if ((_DWORD)v108)
              {
                v43 = (mlir::anec **)v107;
                v44 = 8 * v108;
                while (*v43 != i)
                {
                  ++v43;
                  v44 -= 8;
                  if (!v44)
                    goto LABEL_40;
                }
                if (v44)
                {
LABEL_39:
                  v45 = 0;
                  goto LABEL_41;
                }
              }
LABEL_40:
              v45 = *((_QWORD *)v118[0] + (_QWORD)i);
LABEL_41:
              v46 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (v106)
              {
                for (k = v105; k; k = (_QWORD *)*k)
                {
                  v48 = k[4];
                  if ((uint64_t)i >= v48)
                  {
                    if (v48 >= (uint64_t)i)
                    {
                      v49 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
                      goto LABEL_56;
                    }
                    ++k;
                  }
                }
LABEL_55:
                v49 = *((_QWORD *)v116[0] + (_QWORD)i);
                goto LABEL_56;
              }
              if (!(_DWORD)v102)
                goto LABEL_55;
              v50 = (mlir::anec **)v101;
              v51 = 8 * v102;
              while (*v50 != i)
              {
                ++v50;
                v51 -= 8;
                if (!v51)
                  goto LABEL_55;
              }
              v49 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (!v51)
                goto LABEL_55;
LABEL_56:
              v52 = *((_QWORD *)v113 + (_QWORD)i);
              v53 = v49 + v45;
              if (v49 == -1)
                v53 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (!IsSize)
                v53 = v49;
              v54 = (v46 & (v45 >> 63)) + v45;
              v55 = (v46 & (v53 >> 63)) + v53;
              if (v46 - 1 < v54)
                v54 = v46 - 1;
              v56 = v54 & ~(v54 >> 63);
              if (v46 >= v55)
                v57 = v55;
              else
                v57 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (v100)
              {
                for (m = v99; m; m = (_QWORD *)*m)
                {
                  v59 = m[4];
                  if ((uint64_t)i >= v59)
                  {
                    if (v59 >= (uint64_t)i)
                      goto LABEL_79;
                    ++m;
                  }
                }
              }
              else if ((_DWORD)v97)
              {
                v60 = v96;
                v61 = &v96[v97];
                while (*v60 != i)
                {
                  if (++v60 == v61)
                    goto LABEL_81;
                }
                if (v60 != v61)
                {
LABEL_79:
                  v62 = 1;
                  if (v46 == 1)
                    goto LABEL_24;
                  goto LABEL_23;
                }
              }
LABEL_81:
              v62 = (uint64_t)(v52 + ~v56 + (v57 & ~(v57 >> 63))) / v52;
              if (v62 == v46)
                goto LABEL_24;
LABEL_23:
              v90 = v33;
LABEL_24:
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
            }
          }
          if ((_DWORD)v97 || v100)
          {
            v93 = (void *)(*((_QWORD *)v33 + 1) & 0xFFFFFFFFFFFFFFF8);
            v88[0] = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
            v88[1] = v66;
            v93 = v95;
            v94 = 0x400000000;
            v67 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v88);
            if (v68)
            {
              v69 = (uint64_t *)v67;
              v70 = 0;
              v71 = (uint64_t *)(v67 + 8 * v68);
              do
              {
                if (v100)
                {
                  for (n = v99; n; n = (_QWORD *)*n)
                  {
                    v73 = (mlir::anec *)n[4];
                    if ((uint64_t)v70 >= (uint64_t)v73)
                    {
                      if ((uint64_t)v73 >= (uint64_t)v70)
                        goto LABEL_96;
                      ++n;
                    }
                  }
                }
                else if ((_DWORD)v97)
                {
                  v74 = v96;
                  v75 = 8 * v97;
                  while (*v74 != v70)
                  {
                    ++v74;
                    v75 -= 8;
                    if (!v75)
                      goto LABEL_109;
                  }
                  if (v75)
                    goto LABEL_96;
                }
LABEL_109:
                v76 = *v69;
                v77 = v94;
                if (v94 >= (unint64_t)HIDWORD(v94))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v95, v94 + 1, 8);
                  v77 = v94;
                }
                *((_QWORD *)v93 + v77) = v76;
                LODWORD(v94) = v94 + 1;
LABEL_96:
                v70 = (mlir::anec *)((char *)v70 + 1);
                ++v69;
              }
              while (v69 != v71);
            }
            v78 = v93;
            v79 = (mlir::AffineMap *)v94;
            ElementTypeOrSelf = mlir::getElementTypeOrSelf((uint64_t)v33);
            v86 = (uint64_t *)mlir::MemRefType::get(v78, v79, ElementTypeOrSelf, 0, 0, 0);
            v81 = mlir::Type::cast<mlir::ShapedType>(&v86);
            v87[0] = mlir::getRankPromotionTypeForANE((uint64_t)v81, v82);
            v87[1] = v83;
            v33 = (char *)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v91 + 24), v87, (uint64_t *)&v90)- 16;
            v90 = v33;
            if (v93 != v95)
            {
              free(v93);
              v33 = v90;
            }
          }
          v84 = (unsigned int *)v91;
          v93 = v33;
          v63 = 1;
          mlir::ValueRange::ValueRange(v92, (uint64_t)&v93, 1uLL);
          mlir::ConversionPatternRewriter::replaceOp(a4, v84, v92[0], v92[1]);
        }
        else
        {
          v63 = 0;
        }
        llvm::SmallSet<long long,5u,std::less<long long>>::~SmallSet((uint64_t)&v96);
      }
      else
      {
        v63 = 0;
      }
      std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v104, v105);
      if (v101 != v103)
        free(v101);
    }
    else
    {
      v63 = 0;
    }
    std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v110, v111);
    if (v107 != v109)
      free(v107);
    goto LABEL_122;
  }
  v63 = 0;
LABEL_124:
  if (v116[0] != v117)
    free(v116[0]);
LABEL_126:
  if (v118[0] != v119)
    free(v118[0]);
  return v63;
}

uint64_t mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)1>::promoteAxesValues(uint64_t a1, uint64_t a2, void **a3, unint64_t a4, uint64_t a5)
{
  uint64_t DefiningOp;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  void **v21;
  void *v22[2];
  _WORD v23[12];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v21 = a3;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v21);
  if (!DefiningOp)
    goto LABEL_11;
  v10 = DefiningOp;
  v11 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v10 + 48) + 32))(*(_QWORD *)(v10 + 48), v11))
    goto LABEL_11;
  v22[0] = v23;
  v22[1] = (void *)0x100000000;
  mlir::Operation::fold(v10, 0, 0, (uint64_t)v22);
  v13 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v22[0] & 0xFFFFFFFFFFFFFFF8));
  if (v13)
    v14 = v12;
  else
    v14 = 0;
  if (v22[0] != v23)
    free(v22[0]);
  if (v13)
  {
    v15 = 1;
    mlir::getIntValues<long long>((uint64_t)v13, v14, a5, 1);
    switch(*(_DWORD *)(a5 + 8))
    {
      case 0:
        v16 = *(_QWORD *)a5;
        v17 = a5;
        v18 = 4;
        goto LABEL_17;
      case 1:
        v16 = *(_QWORD *)a5;
        v17 = a5;
        v18 = 3;
LABEL_17:
        llvm::SmallVectorImpl<long long>::insert(v17, v16, v18, a4);
        v15 = 1;
        break;
      case 2:
        v15 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5 + 8, 1uLL, a4);
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5, 1uLL, a4);
        break;
      case 3:
        v15 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5 + 16, 1uLL, a4);
        break;
      default:
        return v15;
    }
  }
  else
  {
LABEL_11:
    v23[8] = 259;
    v21 = v22;
    v22[0] = "failed: axes value must be a constant";
    v19 = *(_QWORD *)(a1 + 16);
    if (v19 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v19 + 64))(v19, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v21);
    else
      return 0;
  }
  return v15;
}

_QWORD *mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)2>::~ConvertStridedSlice(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)2>::~ConvertStridedSlice(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  int64_t v16;
  int64_t v17;
  _BOOL4 IsSize;
  uint64_t v19;
  void **Filter;
  uint64_t v21;
  void **Bias;
  uint64_t v23;
  void **SparseShape;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int Index;
  uint64_t v29;
  unsigned int EndMask;
  uint64_t v31;
  unsigned int Groups;
  char *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t i;
  uint64_t v39;
  uint64_t ArgAttrsAttr;
  _QWORD *j;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *k;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *m;
  uint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t *v71;
  _QWORD *n;
  uint64_t v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  void *v78;
  mlir::AffineMap *v79;
  uint64_t ElementTypeOrSelf;
  uint64_t *v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int *v84;
  uint64_t *v86;
  uint64_t v87[2];
  _QWORD v88[2];
  _QWORD v89[2];
  char *v90;
  uint64_t v91;
  unint64_t v92[2];
  void *v93;
  uint64_t v94;
  _BYTE v95[32];
  _QWORD *v96;
  uint64_t v97;
  _QWORD v98[6];
  _QWORD *v99;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  _BYTE v103[40];
  _QWORD **v104;
  _QWORD *v105;
  uint64_t v106;
  void *v107;
  uint64_t v108;
  _WORD v109[20];
  _QWORD **v110;
  _QWORD *v111;
  uint64_t v112;
  void *v113;
  uint64_t v114;
  _BYTE v115[40];
  void *v116[2];
  _BYTE v117[40];
  void *v118[2];
  _BYTE v119[40];
  __int128 v120;
  uint64_t v121;

  v121 = *MEMORY[0x1E0C80C00];
  v91 = a2;
  v120 = *(_OWORD *)(a3 + 72);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v107 = v5;
  v108 = v15;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v107);
  v17 = v16;
  IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v91);
  v118[0] = v119;
  v118[1] = (void *)0x500000000;
  v19 = v91;
  Filter = (void **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v91);
  {
    v63 = 0;
    goto LABEL_126;
  }
  v116[0] = v117;
  v116[1] = (void *)0x500000000;
  v21 = v91;
  Bias = (void **)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v91);
  {
    v113 = v115;
    v114 = 0x500000000;
    v23 = v91;
    SparseShape = (void **)mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v91);
    if ((_DWORD)v114)
    {
      v25 = (uint64_t *)v113;
      v26 = 8 * v114;
      while (*v25 > 0)
      {
        ++v25;
        v26 -= 8;
        if (!v26)
          goto LABEL_18;
      }
      v107 = "failed: non strictly positive strides are not supported";
      v109[8] = 259;
      v64 = v91;
      v101 = &v107;
      v65 = *(_QWORD *)(a4 + 16);
      if (v65 && mlir::RewriterBase::Listener::classof(v65))
      {
        v63 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v65 + 64))(v65, *(_QWORD *)(v64 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v101);
        goto LABEL_122;
      }
LABEL_89:
      v63 = 0;
LABEL_122:
      if (v113 != v115)
        free(v113);
      goto LABEL_124;
    }
LABEL_18:
    v107 = v109;
    v108 = 0x500000000;
    v111 = 0;
    v112 = 0;
    v110 = &v111;
    v27 = v91;
    Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v91);
    {
      v101 = v103;
      v102 = 0x500000000;
      v105 = 0;
      v106 = 0;
      v104 = &v105;
      v29 = v91;
      EndMask = mlir::mps::StridedSliceGradientOp::getEndMask((mlir::mps::StridedSliceGradientOp *)&v91);
      {
        v96 = v98;
        v97 = 0x500000000;
        v99 = 0;
        v100 = 0;
        v98[5] = &v99;
        v31 = v91;
        Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v91);
        {
          v33 = (char *)mlir::ValueRange::dereference_iterator(&v120, 0);
          v90 = v33;
          v93 = (void *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
          v34 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
          v89[0] = mlir::getRankPromotionTypeForANE((uint64_t)v34, v35);
          v89[1] = v36;
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
          if (v37 >= 1)
          {
            for (i = 0; i < v39; ++i)
            {
              ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
              if (v112)
              {
                for (j = v111; j; j = (_QWORD *)*j)
                {
                  v42 = j[4];
                  if (i >= v42)
                  {
                    if (v42 >= i)
                      goto LABEL_39;
                    ++j;
                  }
                }
              }
              else if ((_DWORD)v108)
              {
                v43 = v107;
                v44 = 8 * v108;
                while (*v43 != i)
                {
                  ++v43;
                  v44 -= 8;
                  if (!v44)
                    goto LABEL_40;
                }
                if (v44)
                {
LABEL_39:
                  v45 = 0;
                  goto LABEL_41;
                }
              }
LABEL_40:
              v45 = *((_QWORD *)v118[0] + i);
LABEL_41:
              v46 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (v106)
              {
                for (k = v105; k; k = (_QWORD *)*k)
                {
                  v48 = k[4];
                  if (i >= v48)
                  {
                    if (v48 >= i)
                    {
                      v49 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
                      goto LABEL_56;
                    }
                    ++k;
                  }
                }
LABEL_55:
                v49 = *((_QWORD *)v116[0] + i);
                goto LABEL_56;
              }
              if (!(_DWORD)v102)
                goto LABEL_55;
              v50 = v101;
              v51 = 8 * v102;
              while (*v50 != i)
              {
                ++v50;
                v51 -= 8;
                if (!v51)
                  goto LABEL_55;
              }
              v49 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (!v51)
                goto LABEL_55;
LABEL_56:
              v52 = *((_QWORD *)v113 + i);
              v53 = v49 + v45;
              if (v49 == -1)
                v53 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (!IsSize)
                v53 = v49;
              v54 = (v46 & (v45 >> 63)) + v45;
              v55 = (v46 & (v53 >> 63)) + v53;
              if (v46 - 1 < v54)
                v54 = v46 - 1;
              v56 = v54 & ~(v54 >> 63);
              if (v46 >= v55)
                v57 = v55;
              else
                v57 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (v100)
              {
                for (m = v99; m; m = (_QWORD *)*m)
                {
                  v59 = m[4];
                  if (i >= v59)
                  {
                    if (v59 >= i)
                      goto LABEL_79;
                    ++m;
                  }
                }
              }
              else if ((_DWORD)v97)
              {
                v60 = v96;
                v61 = &v96[v97];
                while (*v60 != i)
                {
                  if (++v60 == v61)
                    goto LABEL_81;
                }
                if (v60 != v61)
                {
LABEL_79:
                  v62 = 1;
                  if (v46 == 1)
                    goto LABEL_24;
                  goto LABEL_23;
                }
              }
LABEL_81:
              v62 = (v52 + ~v56 + (v57 & ~(v57 >> 63))) / v52;
              if (v62 == v46)
                goto LABEL_24;
LABEL_23:
              v90 = v33;
LABEL_24:
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
            }
          }
          if ((_DWORD)v97 || v100)
          {
            v93 = (void *)(*((_QWORD *)v33 + 1) & 0xFFFFFFFFFFFFFFF8);
            v88[0] = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
            v88[1] = v66;
            v93 = v95;
            v94 = 0x400000000;
            v67 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v88);
            if (v68)
            {
              v69 = (uint64_t *)v67;
              v70 = 0;
              v71 = (uint64_t *)(v67 + 8 * v68);
              do
              {
                if (v100)
                {
                  for (n = v99; n; n = (_QWORD *)*n)
                  {
                    v73 = n[4];
                    if (v70 >= v73)
                    {
                      if (v73 >= v70)
                        goto LABEL_96;
                      ++n;
                    }
                  }
                }
                else if ((_DWORD)v97)
                {
                  v74 = v96;
                  v75 = 8 * v97;
                  while (*v74 != v70)
                  {
                    ++v74;
                    v75 -= 8;
                    if (!v75)
                      goto LABEL_109;
                  }
                  if (v75)
                    goto LABEL_96;
                }
LABEL_109:
                v76 = *v69;
                v77 = v94;
                if (v94 >= (unint64_t)HIDWORD(v94))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v95, v94 + 1, 8);
                  v77 = v94;
                }
                *((_QWORD *)v93 + v77) = v76;
                LODWORD(v94) = v94 + 1;
LABEL_96:
                ++v70;
                ++v69;
              }
              while (v69 != v71);
            }
            v78 = v93;
            v79 = (mlir::AffineMap *)v94;
            ElementTypeOrSelf = mlir::getElementTypeOrSelf((uint64_t)v33);
            v86 = (uint64_t *)mlir::MemRefType::get(v78, v79, ElementTypeOrSelf, 0, 0, 0);
            v81 = mlir::Type::cast<mlir::ShapedType>(&v86);
            v87[0] = mlir::getRankPromotionTypeForANE((uint64_t)v81, v82);
            v87[1] = v83;
            v33 = (char *)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v91 + 24), v87, (uint64_t *)&v90)- 16;
            v90 = v33;
            if (v93 != v95)
            {
              free(v93);
              v33 = v90;
            }
          }
          v84 = (unsigned int *)v91;
          v93 = v33;
          v63 = 1;
          mlir::ValueRange::ValueRange(v92, (uint64_t)&v93, 1uLL);
          mlir::ConversionPatternRewriter::replaceOp(a4, v84, v92[0], v92[1]);
        }
        else
        {
          v63 = 0;
        }
        llvm::SmallSet<long long,5u,std::less<long long>>::~SmallSet((uint64_t)&v96);
      }
      else
      {
        v63 = 0;
      }
      std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v104, v105);
      if (v101 != v103)
        free(v101);
    }
    else
    {
      v63 = 0;
    }
    std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v110, v111);
    if (v107 != v109)
      free(v107);
    goto LABEL_122;
  }
  v63 = 0;
LABEL_124:
  if (v116[0] != v117)
    free(v116[0]);
LABEL_126:
  if (v118[0] != v119)
    free(v118[0]);
  return v63;
}

uint64_t mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)2>::promoteAxesValues(uint64_t a1, uint64_t a2, void **a3, unint64_t a4, uint64_t a5)
{
  uint64_t DefiningOp;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  void **v21;
  void *v22[2];
  _WORD v23[12];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v21 = a3;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v21);
  if (!DefiningOp)
    goto LABEL_11;
  v10 = DefiningOp;
  v11 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v10 + 48) + 32))(*(_QWORD *)(v10 + 48), v11))
    goto LABEL_11;
  v22[0] = v23;
  v22[1] = (void *)0x100000000;
  mlir::Operation::fold(v10, 0, 0, (uint64_t)v22);
  v13 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v22[0] & 0xFFFFFFFFFFFFFFF8));
  if (v13)
    v14 = v12;
  else
    v14 = 0;
  if (v22[0] != v23)
    free(v22[0]);
  if (v13)
  {
    v15 = 1;
    mlir::getIntValues<long long>((uint64_t)v13, v14, a5, 1);
    switch(*(_DWORD *)(a5 + 8))
    {
      case 0:
        v16 = *(_QWORD *)a5;
        v17 = a5;
        v18 = 4;
        goto LABEL_17;
      case 1:
        v16 = *(_QWORD *)a5;
        v17 = a5;
        v18 = 3;
LABEL_17:
        llvm::SmallVectorImpl<long long>::insert(v17, v16, v18, a4);
        v15 = 1;
        break;
      case 2:
        v15 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5 + 8, 1uLL, a4);
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5, 1uLL, a4);
        break;
      case 3:
        v15 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5 + 16, 1uLL, a4);
        break;
      default:
        return v15;
    }
  }
  else
  {
LABEL_11:
    v23[8] = 259;
    v21 = v22;
    v22[0] = "failed: axes value must be a constant";
    v19 = *(_QWORD *)(a1 + 16);
    if (v19 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v19 + 64))(v19, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v21);
    else
      return 0;
  }
  return v15;
}

_QWORD *mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)3>::~ConvertStridedSlice(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)3>::~ConvertStridedSlice(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  int64_t v16;
  int64_t v17;
  _BOOL4 IsSize;
  uint64_t v19;
  void **Filter;
  uint64_t v21;
  void **Bias;
  uint64_t v23;
  void **SparseShape;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int Index;
  uint64_t v29;
  unsigned int EndMask;
  uint64_t v31;
  unsigned int Groups;
  char *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t i;
  uint64_t v39;
  uint64_t ArgAttrsAttr;
  _QWORD *j;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *k;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *m;
  uint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t *v71;
  _QWORD *n;
  uint64_t v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  void *v78;
  mlir::AffineMap *v79;
  uint64_t ElementTypeOrSelf;
  uint64_t *v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int *v84;
  uint64_t *v86;
  uint64_t v87[2];
  _QWORD v88[2];
  _QWORD v89[2];
  char *v90;
  uint64_t v91;
  unint64_t v92[2];
  void *v93;
  uint64_t v94;
  _BYTE v95[32];
  _QWORD *v96;
  uint64_t v97;
  _QWORD v98[6];
  _QWORD *v99;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  _BYTE v103[40];
  _QWORD **v104;
  _QWORD *v105;
  uint64_t v106;
  void *v107;
  uint64_t v108;
  _WORD v109[20];
  _QWORD **v110;
  _QWORD *v111;
  uint64_t v112;
  void *v113;
  uint64_t v114;
  _BYTE v115[40];
  void *v116[2];
  _BYTE v117[40];
  void *v118[2];
  _BYTE v119[40];
  __int128 v120;
  uint64_t v121;

  v121 = *MEMORY[0x1E0C80C00];
  v91 = a2;
  v120 = *(_OWORD *)(a3 + 72);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v107 = v5;
  v108 = v15;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v107);
  v17 = v16;
  IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v91);
  v118[0] = v119;
  v118[1] = (void *)0x500000000;
  v19 = v91;
  Filter = (void **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v91);
  {
    v63 = 0;
    goto LABEL_126;
  }
  v116[0] = v117;
  v116[1] = (void *)0x500000000;
  v21 = v91;
  Bias = (void **)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v91);
  {
    v113 = v115;
    v114 = 0x500000000;
    v23 = v91;
    SparseShape = (void **)mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v91);
    if ((_DWORD)v114)
    {
      v25 = (uint64_t *)v113;
      v26 = 8 * v114;
      while (*v25 > 0)
      {
        ++v25;
        v26 -= 8;
        if (!v26)
          goto LABEL_18;
      }
      v107 = "failed: non strictly positive strides are not supported";
      v109[8] = 259;
      v64 = v91;
      v101 = &v107;
      v65 = *(_QWORD *)(a4 + 16);
      if (v65 && mlir::RewriterBase::Listener::classof(v65))
      {
        v63 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v65 + 64))(v65, *(_QWORD *)(v64 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v101);
        goto LABEL_122;
      }
LABEL_89:
      v63 = 0;
LABEL_122:
      if (v113 != v115)
        free(v113);
      goto LABEL_124;
    }
LABEL_18:
    v107 = v109;
    v108 = 0x500000000;
    v111 = 0;
    v112 = 0;
    v110 = &v111;
    v27 = v91;
    Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v91);
    {
      v101 = v103;
      v102 = 0x500000000;
      v105 = 0;
      v106 = 0;
      v104 = &v105;
      v29 = v91;
      EndMask = mlir::mps::StridedSliceGradientOp::getEndMask((mlir::mps::StridedSliceGradientOp *)&v91);
      {
        v96 = v98;
        v97 = 0x500000000;
        v99 = 0;
        v100 = 0;
        v98[5] = &v99;
        v31 = v91;
        Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v91);
        {
          v33 = (char *)mlir::ValueRange::dereference_iterator(&v120, 0);
          v90 = v33;
          v93 = (void *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
          v34 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
          v89[0] = mlir::getRankPromotionTypeForANE((uint64_t)v34, v35);
          v89[1] = v36;
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
          if (v37 >= 1)
          {
            for (i = 0; i < v39; ++i)
            {
              ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
              if (v112)
              {
                for (j = v111; j; j = (_QWORD *)*j)
                {
                  v42 = j[4];
                  if (i >= v42)
                  {
                    if (v42 >= i)
                      goto LABEL_39;
                    ++j;
                  }
                }
              }
              else if ((_DWORD)v108)
              {
                v43 = v107;
                v44 = 8 * v108;
                while (*v43 != i)
                {
                  ++v43;
                  v44 -= 8;
                  if (!v44)
                    goto LABEL_40;
                }
                if (v44)
                {
LABEL_39:
                  v45 = 0;
                  goto LABEL_41;
                }
              }
LABEL_40:
              v45 = *((_QWORD *)v118[0] + i);
LABEL_41:
              v46 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (v106)
              {
                for (k = v105; k; k = (_QWORD *)*k)
                {
                  v48 = k[4];
                  if (i >= v48)
                  {
                    if (v48 >= i)
                    {
                      v49 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
                      goto LABEL_56;
                    }
                    ++k;
                  }
                }
LABEL_55:
                v49 = *((_QWORD *)v116[0] + i);
                goto LABEL_56;
              }
              if (!(_DWORD)v102)
                goto LABEL_55;
              v50 = v101;
              v51 = 8 * v102;
              while (*v50 != i)
              {
                ++v50;
                v51 -= 8;
                if (!v51)
                  goto LABEL_55;
              }
              v49 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (!v51)
                goto LABEL_55;
LABEL_56:
              v52 = *((_QWORD *)v113 + i);
              v53 = v49 + v45;
              if (v49 == -1)
                v53 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (!IsSize)
                v53 = v49;
              v54 = (v46 & (v45 >> 63)) + v45;
              v55 = (v46 & (v53 >> 63)) + v53;
              if (v46 - 1 < v54)
                v54 = v46 - 1;
              v56 = v54 & ~(v54 >> 63);
              if (v46 >= v55)
                v57 = v55;
              else
                v57 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (v100)
              {
                for (m = v99; m; m = (_QWORD *)*m)
                {
                  v59 = m[4];
                  if (i >= v59)
                  {
                    if (v59 >= i)
                      goto LABEL_79;
                    ++m;
                  }
                }
              }
              else if ((_DWORD)v97)
              {
                v60 = v96;
                v61 = &v96[v97];
                while (*v60 != i)
                {
                  if (++v60 == v61)
                    goto LABEL_81;
                }
                if (v60 != v61)
                {
LABEL_79:
                  v62 = 1;
                  if (v46 == 1)
                    goto LABEL_24;
                  goto LABEL_23;
                }
              }
LABEL_81:
              v62 = (v52 + ~v56 + (v57 & ~(v57 >> 63))) / v52;
              if (v62 == v46)
                goto LABEL_24;
LABEL_23:
              v90 = v33;
LABEL_24:
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
            }
          }
          if ((_DWORD)v97 || v100)
          {
            v93 = (void *)(*((_QWORD *)v33 + 1) & 0xFFFFFFFFFFFFFFF8);
            v88[0] = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
            v88[1] = v66;
            v93 = v95;
            v94 = 0x400000000;
            v67 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v88);
            if (v68)
            {
              v69 = (uint64_t *)v67;
              v70 = 0;
              v71 = (uint64_t *)(v67 + 8 * v68);
              do
              {
                if (v100)
                {
                  for (n = v99; n; n = (_QWORD *)*n)
                  {
                    v73 = n[4];
                    if (v70 >= v73)
                    {
                      if (v73 >= v70)
                        goto LABEL_96;
                      ++n;
                    }
                  }
                }
                else if ((_DWORD)v97)
                {
                  v74 = v96;
                  v75 = 8 * v97;
                  while (*v74 != v70)
                  {
                    ++v74;
                    v75 -= 8;
                    if (!v75)
                      goto LABEL_109;
                  }
                  if (v75)
                    goto LABEL_96;
                }
LABEL_109:
                v76 = *v69;
                v77 = v94;
                if (v94 >= (unint64_t)HIDWORD(v94))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v95, v94 + 1, 8);
                  v77 = v94;
                }
                *((_QWORD *)v93 + v77) = v76;
                LODWORD(v94) = v94 + 1;
LABEL_96:
                ++v70;
                ++v69;
              }
              while (v69 != v71);
            }
            v78 = v93;
            v79 = (mlir::AffineMap *)v94;
            ElementTypeOrSelf = mlir::getElementTypeOrSelf((uint64_t)v33);
            v86 = (uint64_t *)mlir::MemRefType::get(v78, v79, ElementTypeOrSelf, 0, 0, 0);
            v81 = mlir::Type::cast<mlir::ShapedType>(&v86);
            v87[0] = mlir::getRankPromotionTypeForANE((uint64_t)v81, v82);
            v87[1] = v83;
            v33 = (char *)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v91 + 24), v87, (uint64_t *)&v90)- 16;
            v90 = v33;
            if (v93 != v95)
            {
              free(v93);
              v33 = v90;
            }
          }
          v84 = (unsigned int *)v91;
          v93 = v33;
          v63 = 1;
          mlir::ValueRange::ValueRange(v92, (uint64_t)&v93, 1uLL);
          mlir::ConversionPatternRewriter::replaceOp(a4, v84, v92[0], v92[1]);
        }
        else
        {
          v63 = 0;
        }
        llvm::SmallSet<long long,5u,std::less<long long>>::~SmallSet((uint64_t)&v96);
      }
      else
      {
        v63 = 0;
      }
      std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v104, v105);
      if (v101 != v103)
        free(v101);
    }
    else
    {
      v63 = 0;
    }
    std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v110, v111);
    if (v107 != v109)
      free(v107);
    goto LABEL_122;
  }
  v63 = 0;
LABEL_124:
  if (v116[0] != v117)
    free(v116[0]);
LABEL_126:
  if (v118[0] != v119)
    free(v118[0]);
  return v63;
}

uint64_t mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)3>::promoteAxesValues(uint64_t a1, uint64_t a2, void **a3, unint64_t a4, uint64_t a5)
{
  uint64_t DefiningOp;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  void **v21;
  void *v22[2];
  _WORD v23[12];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v21 = a3;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v21);
  if (!DefiningOp)
    goto LABEL_11;
  v10 = DefiningOp;
  v11 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v10 + 48) + 32))(*(_QWORD *)(v10 + 48), v11))
    goto LABEL_11;
  v22[0] = v23;
  v22[1] = (void *)0x100000000;
  mlir::Operation::fold(v10, 0, 0, (uint64_t)v22);
  v13 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v22[0] & 0xFFFFFFFFFFFFFFF8));
  if (v13)
    v14 = v12;
  else
    v14 = 0;
  if (v22[0] != v23)
    free(v22[0]);
  if (v13)
  {
    v15 = 1;
    mlir::getIntValues<long long>((uint64_t)v13, v14, a5, 1);
    switch(*(_DWORD *)(a5 + 8))
    {
      case 0:
        v16 = *(_QWORD *)a5;
        v17 = a5;
        v18 = 4;
        goto LABEL_17;
      case 1:
        v16 = *(_QWORD *)a5;
        v17 = a5;
        v18 = 3;
LABEL_17:
        llvm::SmallVectorImpl<long long>::insert(v17, v16, v18, a4);
        v15 = 1;
        break;
      case 2:
        v15 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5 + 8, 1uLL, a4);
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5, 1uLL, a4);
        break;
      case 3:
        v15 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5 + 16, 1uLL, a4);
        break;
      default:
        return v15;
    }
  }
  else
  {
LABEL_11:
    v23[8] = 259;
    v21 = v22;
    v22[0] = "failed: axes value must be a constant";
    v19 = *(_QWORD *)(a1 + 16);
    if (v19 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v19 + 64))(v19, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v21);
    else
      return 0;
  }
  return v15;
}

_QWORD *mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)4>::~ConvertStridedSlice(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)4>::~ConvertStridedSlice(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  int64_t v16;
  int64_t v17;
  _BOOL4 IsSize;
  uint64_t v19;
  void **Filter;
  uint64_t v21;
  void **Bias;
  uint64_t v23;
  void **SparseShape;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int Index;
  uint64_t v29;
  unsigned int EndMask;
  uint64_t v31;
  unsigned int Groups;
  char *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t i;
  uint64_t v39;
  uint64_t ArgAttrsAttr;
  _QWORD *j;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *k;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *m;
  uint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t *v71;
  _QWORD *n;
  uint64_t v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  void *v78;
  mlir::AffineMap *v79;
  uint64_t ElementTypeOrSelf;
  uint64_t *v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int *v84;
  uint64_t *v86;
  uint64_t v87[2];
  _QWORD v88[2];
  _QWORD v89[2];
  char *v90;
  uint64_t v91;
  unint64_t v92[2];
  void *v93;
  uint64_t v94;
  _BYTE v95[32];
  _QWORD *v96;
  uint64_t v97;
  _QWORD v98[6];
  _QWORD *v99;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  _BYTE v103[40];
  _QWORD **v104;
  _QWORD *v105;
  uint64_t v106;
  void *v107;
  uint64_t v108;
  _WORD v109[20];
  _QWORD **v110;
  _QWORD *v111;
  uint64_t v112;
  void *v113;
  uint64_t v114;
  _BYTE v115[40];
  void *v116[2];
  _BYTE v117[40];
  void *v118[2];
  _BYTE v119[40];
  __int128 v120;
  uint64_t v121;

  v121 = *MEMORY[0x1E0C80C00];
  v91 = a2;
  v120 = *(_OWORD *)(a3 + 72);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v107 = v5;
  v108 = v15;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v107);
  v17 = v16;
  IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v91);
  v118[0] = v119;
  v118[1] = (void *)0x500000000;
  v19 = v91;
  Filter = (void **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v91);
  {
    v63 = 0;
    goto LABEL_126;
  }
  v116[0] = v117;
  v116[1] = (void *)0x500000000;
  v21 = v91;
  Bias = (void **)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v91);
  {
    v113 = v115;
    v114 = 0x500000000;
    v23 = v91;
    SparseShape = (void **)mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v91);
    if ((_DWORD)v114)
    {
      v25 = (uint64_t *)v113;
      v26 = 8 * v114;
      while (*v25 > 0)
      {
        ++v25;
        v26 -= 8;
        if (!v26)
          goto LABEL_18;
      }
      v107 = "failed: non strictly positive strides are not supported";
      v109[8] = 259;
      v64 = v91;
      v101 = &v107;
      v65 = *(_QWORD *)(a4 + 16);
      if (v65 && mlir::RewriterBase::Listener::classof(v65))
      {
        v63 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v65 + 64))(v65, *(_QWORD *)(v64 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v101);
        goto LABEL_122;
      }
LABEL_89:
      v63 = 0;
LABEL_122:
      if (v113 != v115)
        free(v113);
      goto LABEL_124;
    }
LABEL_18:
    v107 = v109;
    v108 = 0x500000000;
    v111 = 0;
    v112 = 0;
    v110 = &v111;
    v27 = v91;
    Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v91);
    {
      v101 = v103;
      v102 = 0x500000000;
      v105 = 0;
      v106 = 0;
      v104 = &v105;
      v29 = v91;
      EndMask = mlir::mps::StridedSliceGradientOp::getEndMask((mlir::mps::StridedSliceGradientOp *)&v91);
      {
        v96 = v98;
        v97 = 0x500000000;
        v99 = 0;
        v100 = 0;
        v98[5] = &v99;
        v31 = v91;
        Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v91);
        {
          v33 = (char *)mlir::ValueRange::dereference_iterator(&v120, 0);
          v90 = v33;
          v93 = (void *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
          v34 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
          v89[0] = mlir::getRankPromotionTypeForANE((uint64_t)v34, v35);
          v89[1] = v36;
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
          if (v37 >= 1)
          {
            for (i = 0; i < v39; ++i)
            {
              ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
              if (v112)
              {
                for (j = v111; j; j = (_QWORD *)*j)
                {
                  v42 = j[4];
                  if (i >= v42)
                  {
                    if (v42 >= i)
                      goto LABEL_39;
                    ++j;
                  }
                }
              }
              else if ((_DWORD)v108)
              {
                v43 = v107;
                v44 = 8 * v108;
                while (*v43 != i)
                {
                  ++v43;
                  v44 -= 8;
                  if (!v44)
                    goto LABEL_40;
                }
                if (v44)
                {
LABEL_39:
                  v45 = 0;
                  goto LABEL_41;
                }
              }
LABEL_40:
              v45 = *((_QWORD *)v118[0] + i);
LABEL_41:
              v46 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (v106)
              {
                for (k = v105; k; k = (_QWORD *)*k)
                {
                  v48 = k[4];
                  if (i >= v48)
                  {
                    if (v48 >= i)
                    {
                      v49 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
                      goto LABEL_56;
                    }
                    ++k;
                  }
                }
LABEL_55:
                v49 = *((_QWORD *)v116[0] + i);
                goto LABEL_56;
              }
              if (!(_DWORD)v102)
                goto LABEL_55;
              v50 = v101;
              v51 = 8 * v102;
              while (*v50 != i)
              {
                ++v50;
                v51 -= 8;
                if (!v51)
                  goto LABEL_55;
              }
              v49 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (!v51)
                goto LABEL_55;
LABEL_56:
              v52 = *((_QWORD *)v113 + i);
              v53 = v49 + v45;
              if (v49 == -1)
                v53 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (!IsSize)
                v53 = v49;
              v54 = (v46 & (v45 >> 63)) + v45;
              v55 = (v46 & (v53 >> 63)) + v53;
              if (v46 - 1 < v54)
                v54 = v46 - 1;
              v56 = v54 & ~(v54 >> 63);
              if (v46 >= v55)
                v57 = v55;
              else
                v57 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (v100)
              {
                for (m = v99; m; m = (_QWORD *)*m)
                {
                  v59 = m[4];
                  if (i >= v59)
                  {
                    if (v59 >= i)
                      goto LABEL_79;
                    ++m;
                  }
                }
              }
              else if ((_DWORD)v97)
              {
                v60 = v96;
                v61 = &v96[v97];
                while (*v60 != i)
                {
                  if (++v60 == v61)
                    goto LABEL_81;
                }
                if (v60 != v61)
                {
LABEL_79:
                  v62 = 1;
                  if (v46 == 1)
                    goto LABEL_24;
                  goto LABEL_23;
                }
              }
LABEL_81:
              v62 = (v52 + ~v56 + (v57 & ~(v57 >> 63))) / v52;
              if (v62 == v46)
                goto LABEL_24;
LABEL_23:
              v90 = v33;
LABEL_24:
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
            }
          }
          if ((_DWORD)v97 || v100)
          {
            v93 = (void *)(*((_QWORD *)v33 + 1) & 0xFFFFFFFFFFFFFFF8);
            v88[0] = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
            v88[1] = v66;
            v93 = v95;
            v94 = 0x400000000;
            v67 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v88);
            if (v68)
            {
              v69 = (uint64_t *)v67;
              v70 = 0;
              v71 = (uint64_t *)(v67 + 8 * v68);
              do
              {
                if (v100)
                {
                  for (n = v99; n; n = (_QWORD *)*n)
                  {
                    v73 = n[4];
                    if (v70 >= v73)
                    {
                      if (v73 >= v70)
                        goto LABEL_96;
                      ++n;
                    }
                  }
                }
                else if ((_DWORD)v97)
                {
                  v74 = v96;
                  v75 = 8 * v97;
                  while (*v74 != v70)
                  {
                    ++v74;
                    v75 -= 8;
                    if (!v75)
                      goto LABEL_109;
                  }
                  if (v75)
                    goto LABEL_96;
                }
LABEL_109:
                v76 = *v69;
                v77 = v94;
                if (v94 >= (unint64_t)HIDWORD(v94))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v95, v94 + 1, 8);
                  v77 = v94;
                }
                *((_QWORD *)v93 + v77) = v76;
                LODWORD(v94) = v94 + 1;
LABEL_96:
                ++v70;
                ++v69;
              }
              while (v69 != v71);
            }
            v78 = v93;
            v79 = (mlir::AffineMap *)v94;
            ElementTypeOrSelf = mlir::getElementTypeOrSelf((uint64_t)v33);
            v86 = (uint64_t *)mlir::MemRefType::get(v78, v79, ElementTypeOrSelf, 0, 0, 0);
            v81 = mlir::Type::cast<mlir::ShapedType>(&v86);
            v87[0] = mlir::getRankPromotionTypeForANE((uint64_t)v81, v82);
            v87[1] = v83;
            v33 = (char *)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v91 + 24), v87, (uint64_t *)&v90)- 16;
            v90 = v33;
            if (v93 != v95)
            {
              free(v93);
              v33 = v90;
            }
          }
          v84 = (unsigned int *)v91;
          v93 = v33;
          v63 = 1;
          mlir::ValueRange::ValueRange(v92, (uint64_t)&v93, 1uLL);
          mlir::ConversionPatternRewriter::replaceOp(a4, v84, v92[0], v92[1]);
        }
        else
        {
          v63 = 0;
        }
        llvm::SmallSet<long long,5u,std::less<long long>>::~SmallSet((uint64_t)&v96);
      }
      else
      {
        v63 = 0;
      }
      std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v104, v105);
      if (v101 != v103)
        free(v101);
    }
    else
    {
      v63 = 0;
    }
    std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v110, v111);
    if (v107 != v109)
      free(v107);
    goto LABEL_122;
  }
  v63 = 0;
LABEL_124:
  if (v116[0] != v117)
    free(v116[0]);
LABEL_126:
  if (v118[0] != v119)
    free(v118[0]);
  return v63;
}

uint64_t mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)4>::promoteAxesValues(uint64_t a1, uint64_t a2, void **a3, unint64_t a4, uint64_t a5)
{
  uint64_t DefiningOp;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  void **v21;
  void *v22[2];
  _WORD v23[12];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v21 = a3;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v21);
  if (!DefiningOp)
    goto LABEL_11;
  v10 = DefiningOp;
  v11 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v10 + 48) + 32))(*(_QWORD *)(v10 + 48), v11))
    goto LABEL_11;
  v22[0] = v23;
  v22[1] = (void *)0x100000000;
  mlir::Operation::fold(v10, 0, 0, (uint64_t)v22);
  v13 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v22[0] & 0xFFFFFFFFFFFFFFF8));
  if (v13)
    v14 = v12;
  else
    v14 = 0;
  if (v22[0] != v23)
    free(v22[0]);
  if (v13)
  {
    v15 = 1;
    mlir::getIntValues<long long>((uint64_t)v13, v14, a5, 1);
    switch(*(_DWORD *)(a5 + 8))
    {
      case 0:
        v16 = *(_QWORD *)a5;
        v17 = a5;
        v18 = 4;
        goto LABEL_17;
      case 1:
        v16 = *(_QWORD *)a5;
        v17 = a5;
        v18 = 3;
LABEL_17:
        llvm::SmallVectorImpl<long long>::insert(v17, v16, v18, a4);
        v15 = 1;
        break;
      case 2:
        v15 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5 + 8, 1uLL, a4);
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5, 1uLL, a4);
        break;
      case 3:
        v15 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5 + 16, 1uLL, a4);
        break;
      default:
        return v15;
    }
  }
  else
  {
LABEL_11:
    v23[8] = 259;
    v21 = v22;
    v22[0] = "failed: axes value must be a constant";
    v19 = *(_QWORD *)(a1 + 16);
    if (v19 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v19 + 64))(v19, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v21);
    else
      return 0;
  }
  return v15;
}

_QWORD *mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)5>::~ConvertStridedSlice(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)5>::~ConvertStridedSlice(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  int64_t v16;
  int64_t v17;
  _BOOL4 IsSize;
  uint64_t v19;
  void **Filter;
  uint64_t v21;
  void **Bias;
  uint64_t v23;
  void **SparseShape;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int Index;
  uint64_t v29;
  unsigned int EndMask;
  uint64_t v31;
  unsigned int Groups;
  char *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t i;
  uint64_t v39;
  uint64_t ArgAttrsAttr;
  _QWORD *j;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *k;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *m;
  uint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t *v71;
  _QWORD *n;
  uint64_t v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  void *v78;
  mlir::AffineMap *v79;
  uint64_t ElementTypeOrSelf;
  uint64_t *v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int *v84;
  uint64_t *v86;
  uint64_t v87[2];
  _QWORD v88[2];
  _QWORD v89[2];
  char *v90;
  uint64_t v91;
  unint64_t v92[2];
  void *v93;
  uint64_t v94;
  _BYTE v95[32];
  _QWORD *v96;
  uint64_t v97;
  _QWORD v98[6];
  _QWORD *v99;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  _BYTE v103[40];
  _QWORD **v104;
  _QWORD *v105;
  uint64_t v106;
  void *v107;
  uint64_t v108;
  _WORD v109[20];
  _QWORD **v110;
  _QWORD *v111;
  uint64_t v112;
  void *v113;
  uint64_t v114;
  _BYTE v115[40];
  void *v116[2];
  _BYTE v117[40];
  void *v118[2];
  _BYTE v119[40];
  __int128 v120;
  uint64_t v121;

  v121 = *MEMORY[0x1E0C80C00];
  v91 = a2;
  v120 = *(_OWORD *)(a3 + 72);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v107 = v5;
  v108 = v15;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v107);
  v17 = v16;
  IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v91);
  v118[0] = v119;
  v118[1] = (void *)0x500000000;
  v19 = v91;
  Filter = (void **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v91);
  {
    v63 = 0;
    goto LABEL_126;
  }
  v116[0] = v117;
  v116[1] = (void *)0x500000000;
  v21 = v91;
  Bias = (void **)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v91);
  {
    v113 = v115;
    v114 = 0x500000000;
    v23 = v91;
    SparseShape = (void **)mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v91);
    if ((_DWORD)v114)
    {
      v25 = (uint64_t *)v113;
      v26 = 8 * v114;
      while (*v25 > 0)
      {
        ++v25;
        v26 -= 8;
        if (!v26)
          goto LABEL_18;
      }
      v107 = "failed: non strictly positive strides are not supported";
      v109[8] = 259;
      v64 = v91;
      v101 = &v107;
      v65 = *(_QWORD *)(a4 + 16);
      if (v65 && mlir::RewriterBase::Listener::classof(v65))
      {
        v63 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v65 + 64))(v65, *(_QWORD *)(v64 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v101);
        goto LABEL_122;
      }
LABEL_89:
      v63 = 0;
LABEL_122:
      if (v113 != v115)
        free(v113);
      goto LABEL_124;
    }
LABEL_18:
    v107 = v109;
    v108 = 0x500000000;
    v111 = 0;
    v112 = 0;
    v110 = &v111;
    v27 = v91;
    Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v91);
    {
      v101 = v103;
      v102 = 0x500000000;
      v105 = 0;
      v106 = 0;
      v104 = &v105;
      v29 = v91;
      EndMask = mlir::mps::StridedSliceGradientOp::getEndMask((mlir::mps::StridedSliceGradientOp *)&v91);
      {
        v96 = v98;
        v97 = 0x500000000;
        v99 = 0;
        v100 = 0;
        v98[5] = &v99;
        v31 = v91;
        Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v91);
        {
          v33 = (char *)mlir::ValueRange::dereference_iterator(&v120, 0);
          v90 = v33;
          v93 = (void *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
          v34 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
          v89[0] = mlir::getRankPromotionTypeForANE((uint64_t)v34, v35);
          v89[1] = v36;
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
          if (v37 >= 1)
          {
            for (i = 0; i < v39; ++i)
            {
              ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
              if (v112)
              {
                for (j = v111; j; j = (_QWORD *)*j)
                {
                  v42 = j[4];
                  if (i >= v42)
                  {
                    if (v42 >= i)
                      goto LABEL_39;
                    ++j;
                  }
                }
              }
              else if ((_DWORD)v108)
              {
                v43 = v107;
                v44 = 8 * v108;
                while (*v43 != i)
                {
                  ++v43;
                  v44 -= 8;
                  if (!v44)
                    goto LABEL_40;
                }
                if (v44)
                {
LABEL_39:
                  v45 = 0;
                  goto LABEL_41;
                }
              }
LABEL_40:
              v45 = *((_QWORD *)v118[0] + i);
LABEL_41:
              v46 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (v106)
              {
                for (k = v105; k; k = (_QWORD *)*k)
                {
                  v48 = k[4];
                  if (i >= v48)
                  {
                    if (v48 >= i)
                    {
                      v49 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
                      goto LABEL_56;
                    }
                    ++k;
                  }
                }
LABEL_55:
                v49 = *((_QWORD *)v116[0] + i);
                goto LABEL_56;
              }
              if (!(_DWORD)v102)
                goto LABEL_55;
              v50 = v101;
              v51 = 8 * v102;
              while (*v50 != i)
              {
                ++v50;
                v51 -= 8;
                if (!v51)
                  goto LABEL_55;
              }
              v49 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (!v51)
                goto LABEL_55;
LABEL_56:
              v52 = *((_QWORD *)v113 + i);
              v53 = v49 + v45;
              if (v49 == -1)
                v53 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (!IsSize)
                v53 = v49;
              v54 = (v46 & (v45 >> 63)) + v45;
              v55 = (v46 & (v53 >> 63)) + v53;
              if (v46 - 1 < v54)
                v54 = v46 - 1;
              v56 = v54 & ~(v54 >> 63);
              if (v46 >= v55)
                v57 = v55;
              else
                v57 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (v100)
              {
                for (m = v99; m; m = (_QWORD *)*m)
                {
                  v59 = m[4];
                  if (i >= v59)
                  {
                    if (v59 >= i)
                      goto LABEL_79;
                    ++m;
                  }
                }
              }
              else if ((_DWORD)v97)
              {
                v60 = v96;
                v61 = &v96[v97];
                while (*v60 != i)
                {
                  if (++v60 == v61)
                    goto LABEL_81;
                }
                if (v60 != v61)
                {
LABEL_79:
                  v62 = 1;
                  if (v46 == 1)
                    goto LABEL_24;
                  goto LABEL_23;
                }
              }
LABEL_81:
              v62 = (v52 + ~v56 + (v57 & ~(v57 >> 63))) / v52;
              if (v62 == v46)
                goto LABEL_24;
LABEL_23:
              v90 = v33;
LABEL_24:
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
            }
          }
          if ((_DWORD)v97 || v100)
          {
            v93 = (void *)(*((_QWORD *)v33 + 1) & 0xFFFFFFFFFFFFFFF8);
            v88[0] = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
            v88[1] = v66;
            v93 = v95;
            v94 = 0x400000000;
            v67 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v88);
            if (v68)
            {
              v69 = (uint64_t *)v67;
              v70 = 0;
              v71 = (uint64_t *)(v67 + 8 * v68);
              do
              {
                if (v100)
                {
                  for (n = v99; n; n = (_QWORD *)*n)
                  {
                    v73 = n[4];
                    if (v70 >= v73)
                    {
                      if (v73 >= v70)
                        goto LABEL_96;
                      ++n;
                    }
                  }
                }
                else if ((_DWORD)v97)
                {
                  v74 = v96;
                  v75 = 8 * v97;
                  while (*v74 != v70)
                  {
                    ++v74;
                    v75 -= 8;
                    if (!v75)
                      goto LABEL_109;
                  }
                  if (v75)
                    goto LABEL_96;
                }
LABEL_109:
                v76 = *v69;
                v77 = v94;
                if (v94 >= (unint64_t)HIDWORD(v94))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v95, v94 + 1, 8);
                  v77 = v94;
                }
                *((_QWORD *)v93 + v77) = v76;
                LODWORD(v94) = v94 + 1;
LABEL_96:
                ++v70;
                ++v69;
              }
              while (v69 != v71);
            }
            v78 = v93;
            v79 = (mlir::AffineMap *)v94;
            ElementTypeOrSelf = mlir::getElementTypeOrSelf((uint64_t)v33);
            v86 = (uint64_t *)mlir::MemRefType::get(v78, v79, ElementTypeOrSelf, 0, 0, 0);
            v81 = mlir::Type::cast<mlir::ShapedType>(&v86);
            v87[0] = mlir::getRankPromotionTypeForANE((uint64_t)v81, v82);
            v87[1] = v83;
            v33 = (char *)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v91 + 24), v87, (uint64_t *)&v90)- 16;
            v90 = v33;
            if (v93 != v95)
            {
              free(v93);
              v33 = v90;
            }
          }
          v84 = (unsigned int *)v91;
          v93 = v33;
          v63 = 1;
          mlir::ValueRange::ValueRange(v92, (uint64_t)&v93, 1uLL);
          mlir::ConversionPatternRewriter::replaceOp(a4, v84, v92[0], v92[1]);
        }
        else
        {
          v63 = 0;
        }
        llvm::SmallSet<long long,5u,std::less<long long>>::~SmallSet((uint64_t)&v96);
      }
      else
      {
        v63 = 0;
      }
      std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v104, v105);
      if (v101 != v103)
        free(v101);
    }
    else
    {
      v63 = 0;
    }
    std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v110, v111);
    if (v107 != v109)
      free(v107);
    goto LABEL_122;
  }
  v63 = 0;
LABEL_124:
  if (v116[0] != v117)
    free(v116[0]);
LABEL_126:
  if (v118[0] != v119)
    free(v118[0]);
  return v63;
}

uint64_t mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)5>::promoteAxesValues(uint64_t a1, uint64_t a2, void **a3, unint64_t a4, uint64_t a5)
{
  uint64_t DefiningOp;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  void **v21;
  void *v22[2];
  _WORD v23[12];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v21 = a3;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v21);
  if (!DefiningOp)
    goto LABEL_11;
  v10 = DefiningOp;
  v11 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v10 + 48) + 32))(*(_QWORD *)(v10 + 48), v11))
    goto LABEL_11;
  v22[0] = v23;
  v22[1] = (void *)0x100000000;
  mlir::Operation::fold(v10, 0, 0, (uint64_t)v22);
  v13 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v22[0] & 0xFFFFFFFFFFFFFFF8));
  if (v13)
    v14 = v12;
  else
    v14 = 0;
  if (v22[0] != v23)
    free(v22[0]);
  if (v13)
  {
    v15 = 1;
    mlir::getIntValues<long long>((uint64_t)v13, v14, a5, 1);
    switch(*(_DWORD *)(a5 + 8))
    {
      case 0:
        v16 = *(_QWORD *)a5;
        v17 = a5;
        v18 = 4;
        goto LABEL_17;
      case 1:
        v16 = *(_QWORD *)a5;
        v17 = a5;
        v18 = 3;
LABEL_17:
        llvm::SmallVectorImpl<long long>::insert(v17, v16, v18, a4);
        v15 = 1;
        break;
      case 2:
        v15 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5 + 8, 1uLL, a4);
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5, 1uLL, a4);
        break;
      case 3:
        v15 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5 + 16, 1uLL, a4);
        break;
      default:
        return v15;
    }
  }
  else
  {
LABEL_11:
    v23[8] = 259;
    v21 = v22;
    v22[0] = "failed: axes value must be a constant";
    v19 = *(_QWORD *)(a1 + 16);
    if (v19 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v19 + 64))(v19, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v21);
    else
      return 0;
  }
  return v15;
}

_QWORD *mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)6>::~ConvertStridedSlice(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)6>::~ConvertStridedSlice(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  int64_t v16;
  int64_t v17;
  _BOOL4 IsSize;
  uint64_t v19;
  void **Filter;
  uint64_t v21;
  void **Bias;
  uint64_t v23;
  void **SparseShape;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int Index;
  uint64_t v29;
  unsigned int EndMask;
  uint64_t v31;
  unsigned int Groups;
  char *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t i;
  uint64_t v39;
  uint64_t ArgAttrsAttr;
  _QWORD *j;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *k;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *m;
  uint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t *v71;
  _QWORD *n;
  uint64_t v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  void *v78;
  mlir::AffineMap *v79;
  uint64_t ElementTypeOrSelf;
  uint64_t *v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int *v84;
  uint64_t *v86;
  uint64_t v87[2];
  _QWORD v88[2];
  _QWORD v89[2];
  char *v90;
  uint64_t v91;
  unint64_t v92[2];
  void *v93;
  uint64_t v94;
  _BYTE v95[32];
  _QWORD *v96;
  uint64_t v97;
  _QWORD v98[6];
  _QWORD *v99;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  _BYTE v103[40];
  _QWORD **v104;
  _QWORD *v105;
  uint64_t v106;
  void *v107;
  uint64_t v108;
  _WORD v109[20];
  _QWORD **v110;
  _QWORD *v111;
  uint64_t v112;
  void *v113;
  uint64_t v114;
  _BYTE v115[40];
  void *v116[2];
  _BYTE v117[40];
  void *v118[2];
  _BYTE v119[40];
  __int128 v120;
  uint64_t v121;

  v121 = *MEMORY[0x1E0C80C00];
  v91 = a2;
  v120 = *(_OWORD *)(a3 + 72);
  v5 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v107 = v5;
  v108 = v15;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v107);
  v17 = v16;
  IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v91);
  v118[0] = v119;
  v118[1] = (void *)0x500000000;
  v19 = v91;
  Filter = (void **)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v91);
  {
    v63 = 0;
    goto LABEL_126;
  }
  v116[0] = v117;
  v116[1] = (void *)0x500000000;
  v21 = v91;
  Bias = (void **)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v91);
  {
    v113 = v115;
    v114 = 0x500000000;
    v23 = v91;
    SparseShape = (void **)mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v91);
    if ((_DWORD)v114)
    {
      v25 = (uint64_t *)v113;
      v26 = 8 * v114;
      while (*v25 > 0)
      {
        ++v25;
        v26 -= 8;
        if (!v26)
          goto LABEL_18;
      }
      v107 = "failed: non strictly positive strides are not supported";
      v109[8] = 259;
      v64 = v91;
      v101 = &v107;
      v65 = *(_QWORD *)(a4 + 16);
      if (v65 && mlir::RewriterBase::Listener::classof(v65))
      {
        v63 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v65 + 64))(v65, *(_QWORD *)(v64 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::StridedSliceOp &>(mlir::mps::StridedSliceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v101);
        goto LABEL_122;
      }
LABEL_89:
      v63 = 0;
LABEL_122:
      if (v113 != v115)
        free(v113);
      goto LABEL_124;
    }
LABEL_18:
    v107 = v109;
    v108 = 0x500000000;
    v111 = 0;
    v112 = 0;
    v110 = &v111;
    v27 = v91;
    Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v91);
    {
      v101 = v103;
      v102 = 0x500000000;
      v105 = 0;
      v106 = 0;
      v104 = &v105;
      v29 = v91;
      EndMask = mlir::mps::StridedSliceGradientOp::getEndMask((mlir::mps::StridedSliceGradientOp *)&v91);
      {
        v96 = v98;
        v97 = 0x500000000;
        v99 = 0;
        v100 = 0;
        v98[5] = &v99;
        v31 = v91;
        Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v91);
        {
          v33 = (char *)mlir::ValueRange::dereference_iterator(&v120, 0);
          v90 = v33;
          v93 = (void *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91) + 8) & 0xFFFFFFFFFFFFFFF8);
          v34 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
          v89[0] = mlir::getRankPromotionTypeForANE((uint64_t)v34, v35);
          v89[1] = v36;
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
          if (v37 >= 1)
          {
            for (i = 0; i < v39; ++i)
            {
              ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
              if (v112)
              {
                for (j = v111; j; j = (_QWORD *)*j)
                {
                  v42 = j[4];
                  if (i >= v42)
                  {
                    if (v42 >= i)
                      goto LABEL_39;
                    ++j;
                  }
                }
              }
              else if ((_DWORD)v108)
              {
                v43 = v107;
                v44 = 8 * v108;
                while (*v43 != i)
                {
                  ++v43;
                  v44 -= 8;
                  if (!v44)
                    goto LABEL_40;
                }
                if (v44)
                {
LABEL_39:
                  v45 = 0;
                  goto LABEL_41;
                }
              }
LABEL_40:
              v45 = *((_QWORD *)v118[0] + i);
LABEL_41:
              v46 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (v106)
              {
                for (k = v105; k; k = (_QWORD *)*k)
                {
                  v48 = k[4];
                  if (i >= v48)
                  {
                    if (v48 >= i)
                    {
                      v49 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
                      goto LABEL_56;
                    }
                    ++k;
                  }
                }
LABEL_55:
                v49 = *((_QWORD *)v116[0] + i);
                goto LABEL_56;
              }
              if (!(_DWORD)v102)
                goto LABEL_55;
              v50 = v101;
              v51 = 8 * v102;
              while (*v50 != i)
              {
                ++v50;
                v51 -= 8;
                if (!v51)
                  goto LABEL_55;
              }
              v49 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (!v51)
                goto LABEL_55;
LABEL_56:
              v52 = *((_QWORD *)v113 + i);
              v53 = v49 + v45;
              if (v49 == -1)
                v53 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (!IsSize)
                v53 = v49;
              v54 = (v46 & (v45 >> 63)) + v45;
              v55 = (v46 & (v53 >> 63)) + v53;
              if (v46 - 1 < v54)
                v54 = v46 - 1;
              v56 = v54 & ~(v54 >> 63);
              if (v46 >= v55)
                v57 = v55;
              else
                v57 = *(_QWORD *)(ArgAttrsAttr + 8 * i);
              if (v100)
              {
                for (m = v99; m; m = (_QWORD *)*m)
                {
                  v59 = m[4];
                  if (i >= v59)
                  {
                    if (v59 >= i)
                      goto LABEL_79;
                    ++m;
                  }
                }
              }
              else if ((_DWORD)v97)
              {
                v60 = v96;
                v61 = &v96[v97];
                while (*v60 != i)
                {
                  if (++v60 == v61)
                    goto LABEL_81;
                }
                if (v60 != v61)
                {
LABEL_79:
                  v62 = 1;
                  if (v46 == 1)
                    goto LABEL_24;
                  goto LABEL_23;
                }
              }
LABEL_81:
              v62 = (v52 + ~v56 + (v57 & ~(v57 >> 63))) / v52;
              if (v62 == v46)
                goto LABEL_24;
LABEL_23:
              v90 = v33;
LABEL_24:
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v89);
            }
          }
          if ((_DWORD)v97 || v100)
          {
            v93 = (void *)(*((_QWORD *)v33 + 1) & 0xFFFFFFFFFFFFFFF8);
            v88[0] = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v93);
            v88[1] = v66;
            v93 = v95;
            v94 = 0x400000000;
            v67 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v88);
            if (v68)
            {
              v69 = (uint64_t *)v67;
              v70 = 0;
              v71 = (uint64_t *)(v67 + 8 * v68);
              do
              {
                if (v100)
                {
                  for (n = v99; n; n = (_QWORD *)*n)
                  {
                    v73 = n[4];
                    if (v70 >= v73)
                    {
                      if (v73 >= v70)
                        goto LABEL_96;
                      ++n;
                    }
                  }
                }
                else if ((_DWORD)v97)
                {
                  v74 = v96;
                  v75 = 8 * v97;
                  while (*v74 != v70)
                  {
                    ++v74;
                    v75 -= 8;
                    if (!v75)
                      goto LABEL_109;
                  }
                  if (v75)
                    goto LABEL_96;
                }
LABEL_109:
                v76 = *v69;
                v77 = v94;
                if (v94 >= (unint64_t)HIDWORD(v94))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v95, v94 + 1, 8);
                  v77 = v94;
                }
                *((_QWORD *)v93 + v77) = v76;
                LODWORD(v94) = v94 + 1;
LABEL_96:
                ++v70;
                ++v69;
              }
              while (v69 != v71);
            }
            v78 = v93;
            v79 = (mlir::AffineMap *)v94;
            ElementTypeOrSelf = mlir::getElementTypeOrSelf((uint64_t)v33);
            v86 = (uint64_t *)mlir::MemRefType::get(v78, v79, ElementTypeOrSelf, 0, 0, 0);
            v81 = mlir::Type::cast<mlir::ShapedType>(&v86);
            v87[0] = mlir::getRankPromotionTypeForANE((uint64_t)v81, v82);
            v87[1] = v83;
            v33 = (char *)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v91 + 24), v87, (uint64_t *)&v90)- 16;
            v90 = v33;
            if (v93 != v95)
            {
              free(v93);
              v33 = v90;
            }
          }
          v84 = (unsigned int *)v91;
          v93 = v33;
          v63 = 1;
          mlir::ValueRange::ValueRange(v92, (uint64_t)&v93, 1uLL);
          mlir::ConversionPatternRewriter::replaceOp(a4, v84, v92[0], v92[1]);
        }
        else
        {
          v63 = 0;
        }
        llvm::SmallSet<long long,5u,std::less<long long>>::~SmallSet((uint64_t)&v96);
      }
      else
      {
        v63 = 0;
      }
      std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v104, v105);
      if (v101 != v103)
        free(v101);
    }
    else
    {
      v63 = 0;
    }
    std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v110, v111);
    if (v107 != v109)
      free(v107);
    goto LABEL_122;
  }
  v63 = 0;
LABEL_124:
  if (v116[0] != v117)
    free(v116[0]);
LABEL_126:
  if (v118[0] != v119)
    free(v118[0]);
  return v63;
}

uint64_t mlir::`anonymous namespace'::ConvertStridedSlice<(mlir::anec::Family)6>::promoteAxesValues(uint64_t a1, uint64_t a2, void **a3, unint64_t a4, uint64_t a5)
{
  uint64_t DefiningOp;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  void **v21;
  void *v22[2];
  _WORD v23[12];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v21 = a3;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v21);
  if (!DefiningOp)
    goto LABEL_11;
  v10 = DefiningOp;
  v11 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v10 + 48) + 32))(*(_QWORD *)(v10 + 48), v11))
    goto LABEL_11;
  v22[0] = v23;
  v22[1] = (void *)0x100000000;
  mlir::Operation::fold(v10, 0, 0, (uint64_t)v22);
  v13 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v22[0] & 0xFFFFFFFFFFFFFFF8));
  if (v13)
    v14 = v12;
  else
    v14 = 0;
  if (v22[0] != v23)
    free(v22[0]);
  if (v13)
  {
    v15 = 1;
    mlir::getIntValues<long long>((uint64_t)v13, v14, a5, 1);
    switch(*(_DWORD *)(a5 + 8))
    {
      case 0:
        v16 = *(_QWORD *)a5;
        v17 = a5;
        v18 = 4;
        goto LABEL_17;
      case 1:
        v16 = *(_QWORD *)a5;
        v17 = a5;
        v18 = 3;
LABEL_17:
        llvm::SmallVectorImpl<long long>::insert(v17, v16, v18, a4);
        v15 = 1;
        break;
      case 2:
        v15 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5 + 8, 1uLL, a4);
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5, 1uLL, a4);
        break;
      case 3:
        v15 = 1;
        llvm::SmallVectorImpl<long long>::insert(a5, *(_QWORD *)a5 + 16, 1uLL, a4);
        break;
      default:
        return v15;
    }
  }
  else
  {
LABEL_11:
    v23[8] = 259;
    v21 = v22;
    v22[0] = "failed: axes value must be a constant";
    v19 = *(_QWORD *)(a1 + 16);
    if (v19 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v19 + 64))(v19, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v21);
    else
      return 0;
  }
  return v15;
}

_QWORD *mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)0>::~ConvertCrop(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)0>::~ConvertCrop(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CropOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CropOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::CropOpGenericAdaptorBase::CropOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CropOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::CropOpGenericAdaptorBase::CropOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::CropOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropOp &>(mlir::mps::CropOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropOp &>(mlir::mps::CropOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *Filter;
  unint64_t v17;
  uint64_t *SortedUniquePromotedPositiveAxesAttr;
  char v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t Bias;
  unint64_t matched;
  int v34;
  uint64_t SparseShape;
  unint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  mlir::GenericProgramPoint *v42;
  uint64_t v43;
  mlir::Operation *v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  _QWORD v50[2];
  _QWORD *v51;
  uint64_t v52;
  mlir::Operation *v53;
  __int128 v54;
  void *v55[2];
  _WORD v56[12];
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v53 = a2;
  v54 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v53) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v51 = v5;
  v52 = v15;
  Filter = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v53);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v51);
  SortedUniquePromotedPositiveAxesAttr = (uint64_t *)mlir::getSortedUniquePromotedPositiveAxesAttr(Filter, v17, 0, 0);
  if (v19)
  {
    v20 = (uint64_t)SortedUniquePromotedPositiveAxesAttr;
    v55[0] = v56;
    v55[1] = (void *)0x100000000;
    if (!SortedUniquePromotedPositiveAxesAttr)
      goto LABEL_21;
    v21 = *SortedUniquePromotedPositiveAxesAttr;
    v22 = mlir::TypeID::get<mlir::ElementsAttr>();
    v23 = *(unsigned int *)(v21 + 16);
    if (!(_DWORD)v23)
      goto LABEL_21;
    v24 = *(_QWORD **)(v21 + 8);
    v25 = &v24[2 * v23];
    do
    {
      v26 = v23 >> 1;
      v27 = &v24[2 * (v23 >> 1)];
      v29 = *v27;
      v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22)
        v24 = v28;
      else
        v23 = v26;
    }
    while (v23);
    if (v24 != v25 && *v24 == v22)
      v30 = v24[1];
    else
LABEL_21:
      v30 = 0;
    mlir::getIntValues<unsigned long long>(v20, v30, (uint64_t)v55, 1);
    v50[0] = mlir::getRankPromotionTypeForANE((uint64_t)v51, v52);
    v50[1] = v31;
    Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v53);
    matched = mlir::matchConstantWithIntValue<int>(Bias);
    v49 = matched;
    if ((matched & 0xFF00000000) != 0
      && (v34 = matched,
          SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v53),
          v36 = mlir::matchConstantWithIntValue<int>(SparseShape),
          (v36 & 0xFF00000000) != 0))
    {
      v37 = v36;
      v38 = *(unsigned int *)v55[0];
      v39 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50) + 8 * v38);
      v40 = *((_QWORD *)v53 + 3);
      v48 = mlir::ValueRange::dereference_iterator(&v54, 0);
      v41 = *(_QWORD *)v55[0];
      v46 = v39 - (v37 + (uint64_t)v34);
      v47 = v41;
      v42 = mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,unsigned long long,int &,unsigned long long>((mlir::Builder *)(a4 + 1), v40, &v48, &v47, (int *)&v49, &v46);
      mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, v53, v42);
      v43 = 1;
    }
    else
    {
      v43 = 0;
    }
    if (v55[0] != v56)
      free(v55[0]);
  }
  else
  {
    v55[0] = "could not extract positive promoted axes";
    v56[8] = 259;
    v44 = v53;
    v50[0] = v55;
    v43 = a4[2];
    if (v43)
    {
      if (mlir::RewriterBase::Listener::classof(v43))
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v43 + 64))(v43, *((_QWORD *)v44 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropOp &>(mlir::mps::CropOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v50);
      else
        return 0;
    }
  }
  return v43;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropOp &>(mlir::mps::CropOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,unsigned long long,int &,unsigned long long>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, int *a5, uint64_t *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.input_view", (const unsigned __int8 *)0xF, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.input_view";
    v21[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::anec::InputView::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

_QWORD *mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)1>::~ConvertCrop(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)1>::~ConvertCrop(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *Filter;
  unint64_t v17;
  uint64_t *SortedUniquePromotedPositiveAxesAttr;
  char v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t Bias;
  unint64_t matched;
  int v34;
  uint64_t SparseShape;
  unint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  mlir::GenericProgramPoint *v42;
  uint64_t v43;
  mlir::Operation *v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  _QWORD v50[2];
  _QWORD *v51;
  uint64_t v52;
  mlir::Operation *v53;
  __int128 v54;
  void *v55[2];
  _WORD v56[12];
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v53 = a2;
  v54 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v53) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v51 = v5;
  v52 = v15;
  Filter = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v53);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v51);
  SortedUniquePromotedPositiveAxesAttr = (uint64_t *)mlir::getSortedUniquePromotedPositiveAxesAttr(Filter, v17, 0, 0);
  if (v19)
  {
    v20 = (uint64_t)SortedUniquePromotedPositiveAxesAttr;
    v55[0] = v56;
    v55[1] = (void *)0x100000000;
    if (!SortedUniquePromotedPositiveAxesAttr)
      goto LABEL_21;
    v21 = *SortedUniquePromotedPositiveAxesAttr;
    v22 = mlir::TypeID::get<mlir::ElementsAttr>();
    v23 = *(unsigned int *)(v21 + 16);
    if (!(_DWORD)v23)
      goto LABEL_21;
    v24 = *(_QWORD **)(v21 + 8);
    v25 = &v24[2 * v23];
    do
    {
      v26 = v23 >> 1;
      v27 = &v24[2 * (v23 >> 1)];
      v29 = *v27;
      v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22)
        v24 = v28;
      else
        v23 = v26;
    }
    while (v23);
    if (v24 != v25 && *v24 == v22)
      v30 = v24[1];
    else
LABEL_21:
      v30 = 0;
    mlir::getIntValues<unsigned long long>(v20, v30, (uint64_t)v55, 1);
    v50[0] = mlir::getRankPromotionTypeForANE((uint64_t)v51, v52);
    v50[1] = v31;
    Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v53);
    matched = mlir::matchConstantWithIntValue<int>(Bias);
    v49 = matched;
    if ((matched & 0xFF00000000) != 0
      && (v34 = matched,
          SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v53),
          v36 = mlir::matchConstantWithIntValue<int>(SparseShape),
          (v36 & 0xFF00000000) != 0))
    {
      v37 = v36;
      v38 = *(unsigned int *)v55[0];
      v39 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50) + 8 * v38);
      v40 = *((_QWORD *)v53 + 3);
      v48 = mlir::ValueRange::dereference_iterator(&v54, 0);
      v41 = *(_QWORD *)v55[0];
      v46 = v39 - (v37 + (uint64_t)v34);
      v47 = v41;
      v42 = mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,unsigned long long,int &,unsigned long long>((mlir::Builder *)(a4 + 1), v40, &v48, &v47, (int *)&v49, &v46);
      mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, v53, v42);
      v43 = 1;
    }
    else
    {
      v43 = 0;
    }
    if (v55[0] != v56)
      free(v55[0]);
  }
  else
  {
    v55[0] = "could not extract positive promoted axes";
    v56[8] = 259;
    v44 = v53;
    v50[0] = v55;
    v43 = a4[2];
    if (v43)
    {
      if (mlir::RewriterBase::Listener::classof(v43))
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v43 + 64))(v43, *((_QWORD *)v44 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropOp &>(mlir::mps::CropOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v50);
      else
        return 0;
    }
  }
  return v43;
}

_QWORD *mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)2>::~ConvertCrop(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)2>::~ConvertCrop(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)2>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *Filter;
  unint64_t v17;
  uint64_t *SortedUniquePromotedPositiveAxesAttr;
  char v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t Bias;
  unint64_t matched;
  int v34;
  uint64_t SparseShape;
  unint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  mlir::GenericProgramPoint *v42;
  uint64_t v43;
  mlir::Operation *v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  _QWORD v50[2];
  _QWORD *v51;
  uint64_t v52;
  mlir::Operation *v53;
  __int128 v54;
  void *v55[2];
  _WORD v56[12];
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v53 = a2;
  v54 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v53) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v51 = v5;
  v52 = v15;
  Filter = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v53);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v51);
  SortedUniquePromotedPositiveAxesAttr = (uint64_t *)mlir::getSortedUniquePromotedPositiveAxesAttr(Filter, v17, 0, 0);
  if (v19)
  {
    v20 = (uint64_t)SortedUniquePromotedPositiveAxesAttr;
    v55[0] = v56;
    v55[1] = (void *)0x100000000;
    if (!SortedUniquePromotedPositiveAxesAttr)
      goto LABEL_21;
    v21 = *SortedUniquePromotedPositiveAxesAttr;
    v22 = mlir::TypeID::get<mlir::ElementsAttr>();
    v23 = *(unsigned int *)(v21 + 16);
    if (!(_DWORD)v23)
      goto LABEL_21;
    v24 = *(_QWORD **)(v21 + 8);
    v25 = &v24[2 * v23];
    do
    {
      v26 = v23 >> 1;
      v27 = &v24[2 * (v23 >> 1)];
      v29 = *v27;
      v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22)
        v24 = v28;
      else
        v23 = v26;
    }
    while (v23);
    if (v24 != v25 && *v24 == v22)
      v30 = v24[1];
    else
LABEL_21:
      v30 = 0;
    mlir::getIntValues<unsigned long long>(v20, v30, (uint64_t)v55, 1);
    v50[0] = mlir::getRankPromotionTypeForANE((uint64_t)v51, v52);
    v50[1] = v31;
    Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v53);
    matched = mlir::matchConstantWithIntValue<int>(Bias);
    v49 = matched;
    if ((matched & 0xFF00000000) != 0
      && (v34 = matched,
          SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v53),
          v36 = mlir::matchConstantWithIntValue<int>(SparseShape),
          (v36 & 0xFF00000000) != 0))
    {
      v37 = v36;
      v38 = *(unsigned int *)v55[0];
      v39 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50) + 8 * v38);
      v40 = *((_QWORD *)v53 + 3);
      v48 = mlir::ValueRange::dereference_iterator(&v54, 0);
      v41 = *(_QWORD *)v55[0];
      v46 = v39 - (v37 + (uint64_t)v34);
      v47 = v41;
      v42 = mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,unsigned long long,int &,unsigned long long>((mlir::Builder *)(a4 + 1), v40, &v48, &v47, (int *)&v49, &v46);
      mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, v53, v42);
      v43 = 1;
    }
    else
    {
      v43 = 0;
    }
    if (v55[0] != v56)
      free(v55[0]);
  }
  else
  {
    v55[0] = "could not extract positive promoted axes";
    v56[8] = 259;
    v44 = v53;
    v50[0] = v55;
    v43 = a4[2];
    if (v43)
    {
      if (mlir::RewriterBase::Listener::classof(v43))
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v43 + 64))(v43, *((_QWORD *)v44 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropOp &>(mlir::mps::CropOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v50);
      else
        return 0;
    }
  }
  return v43;
}

_QWORD *mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)3>::~ConvertCrop(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)3>::~ConvertCrop(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)3>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *Filter;
  unint64_t v17;
  uint64_t *SortedUniquePromotedPositiveAxesAttr;
  char v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t Bias;
  unint64_t matched;
  int v34;
  uint64_t SparseShape;
  unint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  mlir::GenericProgramPoint *v42;
  uint64_t v43;
  mlir::Operation *v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  _QWORD v50[2];
  _QWORD *v51;
  uint64_t v52;
  mlir::Operation *v53;
  __int128 v54;
  void *v55[2];
  _WORD v56[12];
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v53 = a2;
  v54 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v53) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v51 = v5;
  v52 = v15;
  Filter = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v53);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v51);
  SortedUniquePromotedPositiveAxesAttr = (uint64_t *)mlir::getSortedUniquePromotedPositiveAxesAttr(Filter, v17, 0, 0);
  if (v19)
  {
    v20 = (uint64_t)SortedUniquePromotedPositiveAxesAttr;
    v55[0] = v56;
    v55[1] = (void *)0x100000000;
    if (!SortedUniquePromotedPositiveAxesAttr)
      goto LABEL_21;
    v21 = *SortedUniquePromotedPositiveAxesAttr;
    v22 = mlir::TypeID::get<mlir::ElementsAttr>();
    v23 = *(unsigned int *)(v21 + 16);
    if (!(_DWORD)v23)
      goto LABEL_21;
    v24 = *(_QWORD **)(v21 + 8);
    v25 = &v24[2 * v23];
    do
    {
      v26 = v23 >> 1;
      v27 = &v24[2 * (v23 >> 1)];
      v29 = *v27;
      v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22)
        v24 = v28;
      else
        v23 = v26;
    }
    while (v23);
    if (v24 != v25 && *v24 == v22)
      v30 = v24[1];
    else
LABEL_21:
      v30 = 0;
    mlir::getIntValues<unsigned long long>(v20, v30, (uint64_t)v55, 1);
    v50[0] = mlir::getRankPromotionTypeForANE((uint64_t)v51, v52);
    v50[1] = v31;
    Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v53);
    matched = mlir::matchConstantWithIntValue<int>(Bias);
    v49 = matched;
    if ((matched & 0xFF00000000) != 0
      && (v34 = matched,
          SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v53),
          v36 = mlir::matchConstantWithIntValue<int>(SparseShape),
          (v36 & 0xFF00000000) != 0))
    {
      v37 = v36;
      v38 = *(unsigned int *)v55[0];
      v39 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50) + 8 * v38);
      v40 = *((_QWORD *)v53 + 3);
      v48 = mlir::ValueRange::dereference_iterator(&v54, 0);
      v41 = *(_QWORD *)v55[0];
      v46 = v39 - (v37 + (uint64_t)v34);
      v47 = v41;
      v42 = mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,unsigned long long,int &,unsigned long long>((mlir::Builder *)(a4 + 1), v40, &v48, &v47, (int *)&v49, &v46);
      mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, v53, v42);
      v43 = 1;
    }
    else
    {
      v43 = 0;
    }
    if (v55[0] != v56)
      free(v55[0]);
  }
  else
  {
    v55[0] = "could not extract positive promoted axes";
    v56[8] = 259;
    v44 = v53;
    v50[0] = v55;
    v43 = a4[2];
    if (v43)
    {
      if (mlir::RewriterBase::Listener::classof(v43))
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v43 + 64))(v43, *((_QWORD *)v44 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropOp &>(mlir::mps::CropOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v50);
      else
        return 0;
    }
  }
  return v43;
}

_QWORD *mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)4>::~ConvertCrop(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)4>::~ConvertCrop(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)4>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *Filter;
  unint64_t v17;
  uint64_t *SortedUniquePromotedPositiveAxesAttr;
  char v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t Bias;
  unint64_t matched;
  int v34;
  uint64_t SparseShape;
  unint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  mlir::GenericProgramPoint *v42;
  uint64_t v43;
  mlir::Operation *v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  _QWORD v50[2];
  _QWORD *v51;
  uint64_t v52;
  mlir::Operation *v53;
  __int128 v54;
  void *v55[2];
  _WORD v56[12];
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v53 = a2;
  v54 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v53) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v51 = v5;
  v52 = v15;
  Filter = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v53);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v51);
  SortedUniquePromotedPositiveAxesAttr = (uint64_t *)mlir::getSortedUniquePromotedPositiveAxesAttr(Filter, v17, 0, 0);
  if (v19)
  {
    v20 = (uint64_t)SortedUniquePromotedPositiveAxesAttr;
    v55[0] = v56;
    v55[1] = (void *)0x100000000;
    if (!SortedUniquePromotedPositiveAxesAttr)
      goto LABEL_21;
    v21 = *SortedUniquePromotedPositiveAxesAttr;
    v22 = mlir::TypeID::get<mlir::ElementsAttr>();
    v23 = *(unsigned int *)(v21 + 16);
    if (!(_DWORD)v23)
      goto LABEL_21;
    v24 = *(_QWORD **)(v21 + 8);
    v25 = &v24[2 * v23];
    do
    {
      v26 = v23 >> 1;
      v27 = &v24[2 * (v23 >> 1)];
      v29 = *v27;
      v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22)
        v24 = v28;
      else
        v23 = v26;
    }
    while (v23);
    if (v24 != v25 && *v24 == v22)
      v30 = v24[1];
    else
LABEL_21:
      v30 = 0;
    mlir::getIntValues<unsigned long long>(v20, v30, (uint64_t)v55, 1);
    v50[0] = mlir::getRankPromotionTypeForANE((uint64_t)v51, v52);
    v50[1] = v31;
    Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v53);
    matched = mlir::matchConstantWithIntValue<int>(Bias);
    v49 = matched;
    if ((matched & 0xFF00000000) != 0
      && (v34 = matched,
          SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v53),
          v36 = mlir::matchConstantWithIntValue<int>(SparseShape),
          (v36 & 0xFF00000000) != 0))
    {
      v37 = v36;
      v38 = *(unsigned int *)v55[0];
      v39 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50) + 8 * v38);
      v40 = *((_QWORD *)v53 + 3);
      v48 = mlir::ValueRange::dereference_iterator(&v54, 0);
      v41 = *(_QWORD *)v55[0];
      v46 = v39 - (v37 + (uint64_t)v34);
      v47 = v41;
      v42 = mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,unsigned long long,int &,unsigned long long>((mlir::Builder *)(a4 + 1), v40, &v48, &v47, (int *)&v49, &v46);
      mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, v53, v42);
      v43 = 1;
    }
    else
    {
      v43 = 0;
    }
    if (v55[0] != v56)
      free(v55[0]);
  }
  else
  {
    v55[0] = "could not extract positive promoted axes";
    v56[8] = 259;
    v44 = v53;
    v50[0] = v55;
    v43 = a4[2];
    if (v43)
    {
      if (mlir::RewriterBase::Listener::classof(v43))
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v43 + 64))(v43, *((_QWORD *)v44 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropOp &>(mlir::mps::CropOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v50);
      else
        return 0;
    }
  }
  return v43;
}

_QWORD *mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)5>::~ConvertCrop(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)5>::~ConvertCrop(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)5>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *Filter;
  unint64_t v17;
  uint64_t *SortedUniquePromotedPositiveAxesAttr;
  char v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t Bias;
  unint64_t matched;
  int v34;
  uint64_t SparseShape;
  unint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  mlir::GenericProgramPoint *v42;
  uint64_t v43;
  mlir::Operation *v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  _QWORD v50[2];
  _QWORD *v51;
  uint64_t v52;
  mlir::Operation *v53;
  __int128 v54;
  void *v55[2];
  _WORD v56[12];
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v53 = a2;
  v54 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v53) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v51 = v5;
  v52 = v15;
  Filter = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v53);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v51);
  SortedUniquePromotedPositiveAxesAttr = (uint64_t *)mlir::getSortedUniquePromotedPositiveAxesAttr(Filter, v17, 0, 0);
  if (v19)
  {
    v20 = (uint64_t)SortedUniquePromotedPositiveAxesAttr;
    v55[0] = v56;
    v55[1] = (void *)0x100000000;
    if (!SortedUniquePromotedPositiveAxesAttr)
      goto LABEL_21;
    v21 = *SortedUniquePromotedPositiveAxesAttr;
    v22 = mlir::TypeID::get<mlir::ElementsAttr>();
    v23 = *(unsigned int *)(v21 + 16);
    if (!(_DWORD)v23)
      goto LABEL_21;
    v24 = *(_QWORD **)(v21 + 8);
    v25 = &v24[2 * v23];
    do
    {
      v26 = v23 >> 1;
      v27 = &v24[2 * (v23 >> 1)];
      v29 = *v27;
      v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22)
        v24 = v28;
      else
        v23 = v26;
    }
    while (v23);
    if (v24 != v25 && *v24 == v22)
      v30 = v24[1];
    else
LABEL_21:
      v30 = 0;
    mlir::getIntValues<unsigned long long>(v20, v30, (uint64_t)v55, 1);
    v50[0] = mlir::getRankPromotionTypeForANE((uint64_t)v51, v52);
    v50[1] = v31;
    Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v53);
    matched = mlir::matchConstantWithIntValue<int>(Bias);
    v49 = matched;
    if ((matched & 0xFF00000000) != 0
      && (v34 = matched,
          SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v53),
          v36 = mlir::matchConstantWithIntValue<int>(SparseShape),
          (v36 & 0xFF00000000) != 0))
    {
      v37 = v36;
      v38 = *(unsigned int *)v55[0];
      v39 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50) + 8 * v38);
      v40 = *((_QWORD *)v53 + 3);
      v48 = mlir::ValueRange::dereference_iterator(&v54, 0);
      v41 = *(_QWORD *)v55[0];
      v46 = v39 - (v37 + (uint64_t)v34);
      v47 = v41;
      v42 = mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,unsigned long long,int &,unsigned long long>((mlir::Builder *)(a4 + 1), v40, &v48, &v47, (int *)&v49, &v46);
      mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, v53, v42);
      v43 = 1;
    }
    else
    {
      v43 = 0;
    }
    if (v55[0] != v56)
      free(v55[0]);
  }
  else
  {
    v55[0] = "could not extract positive promoted axes";
    v56[8] = 259;
    v44 = v53;
    v50[0] = v55;
    v43 = a4[2];
    if (v43)
    {
      if (mlir::RewriterBase::Listener::classof(v43))
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v43 + 64))(v43, *((_QWORD *)v44 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropOp &>(mlir::mps::CropOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v50);
      else
        return 0;
    }
  }
  return v43;
}

_QWORD *mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)6>::~ConvertCrop(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)6>::~ConvertCrop(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertCrop<(mlir::anec::Family)6>::matchAndRewriteWithStaticShapes(uint64_t a1, mlir::Operation *a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *Filter;
  unint64_t v17;
  uint64_t *SortedUniquePromotedPositiveAxesAttr;
  char v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t Bias;
  unint64_t matched;
  int v34;
  uint64_t SparseShape;
  unint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  mlir::GenericProgramPoint *v42;
  uint64_t v43;
  mlir::Operation *v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  _QWORD v50[2];
  _QWORD *v51;
  uint64_t v52;
  mlir::Operation *v53;
  __int128 v54;
  void *v55[2];
  _WORD v56[12];
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v53 = a2;
  v54 = *(_OWORD *)(a3 + 40);
  v5 = (_QWORD *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v53) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v51 = v5;
  v52 = v15;
  Filter = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v53);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v51);
  SortedUniquePromotedPositiveAxesAttr = (uint64_t *)mlir::getSortedUniquePromotedPositiveAxesAttr(Filter, v17, 0, 0);
  if (v19)
  {
    v20 = (uint64_t)SortedUniquePromotedPositiveAxesAttr;
    v55[0] = v56;
    v55[1] = (void *)0x100000000;
    if (!SortedUniquePromotedPositiveAxesAttr)
      goto LABEL_21;
    v21 = *SortedUniquePromotedPositiveAxesAttr;
    v22 = mlir::TypeID::get<mlir::ElementsAttr>();
    v23 = *(unsigned int *)(v21 + 16);
    if (!(_DWORD)v23)
      goto LABEL_21;
    v24 = *(_QWORD **)(v21 + 8);
    v25 = &v24[2 * v23];
    do
    {
      v26 = v23 >> 1;
      v27 = &v24[2 * (v23 >> 1)];
      v29 = *v27;
      v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22)
        v24 = v28;
      else
        v23 = v26;
    }
    while (v23);
    if (v24 != v25 && *v24 == v22)
      v30 = v24[1];
    else
LABEL_21:
      v30 = 0;
    mlir::getIntValues<unsigned long long>(v20, v30, (uint64_t)v55, 1);
    v50[0] = mlir::getRankPromotionTypeForANE((uint64_t)v51, v52);
    v50[1] = v31;
    Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v53);
    matched = mlir::matchConstantWithIntValue<int>(Bias);
    v49 = matched;
    if ((matched & 0xFF00000000) != 0
      && (v34 = matched,
          SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v53),
          v36 = mlir::matchConstantWithIntValue<int>(SparseShape),
          (v36 & 0xFF00000000) != 0))
    {
      v37 = v36;
      v38 = *(unsigned int *)v55[0];
      v39 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50) + 8 * v38);
      v40 = *((_QWORD *)v53 + 3);
      v48 = mlir::ValueRange::dereference_iterator(&v54, 0);
      v41 = *(_QWORD *)v55[0];
      v46 = v39 - (v37 + (uint64_t)v34);
      v47 = v41;
      v42 = mlir::OpBuilder::create<mlir::anec::InputView,mlir::Value,unsigned long long,int &,unsigned long long>((mlir::Builder *)(a4 + 1), v40, &v48, &v47, (int *)&v49, &v46);
      mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, v53, v42);
      v43 = 1;
    }
    else
    {
      v43 = 0;
    }
    if (v55[0] != v56)
      free(v55[0]);
  }
  else
  {
    v55[0] = "could not extract positive promoted axes";
    v56[8] = 259;
    v44 = v53;
    v50[0] = v55;
    v43 = a4[2];
    if (v43)
    {
      if (mlir::RewriterBase::Listener::classof(v43))
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v43 + 64))(v43, *((_QWORD *)v44 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CropOp &>(mlir::mps::CropOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v50);
      else
        return 0;
    }
  }
  return v43;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::CosOp,mlir::anec::Cos>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E29980;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_1807B613C()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::CosOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CosOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::CosOpGenericAdaptorBase::CosOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::CosOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::CosOpGenericAdaptorBase::CosOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::CosOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CosOp &>(mlir::mps::CosOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CosOp &>(mlir::mps::CosOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::CosOp,mlir::anec::Cos>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::Cos,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::CosOp &>(mlir::mps::CosOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::CosOp,mlir::anec::Cos>::matchAndRewriteWithStaticShapes(mlir::mps::CosOp,mlir::mps::CosOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Cos,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.cos", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.cos";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Cos,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SinOp,mlir::anec::Sin>::~ConvertElementwiseUnary(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  llvm::detail::DoubleAPFloat *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;

  *(_QWORD *)a1 = off_1E0E29B40;
  v2 = *(char **)(a1 + 128);
  v3 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v3)
  {
    v4 = 56 * v3;
    do
    {
      while (1)
      {
        v5 = (void **)&v2[v4];
        if (v2[v4 - 1] < 0)
          operator delete(*(v5 - 3));
        v7 = *(v5 - 6);
        v6 = (llvm::detail::DoubleAPFloat *)(v5 - 6);
        if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v7)
          break;
        llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
        v4 -= 56;
        if (!v4)
          goto LABEL_8;
      }
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      v4 -= 56;
    }
    while (v4);
LABEL_8:
    v2 = *(char **)(a1 + 128);
  }
  if (v2 != (char *)(a1 + 144))
    free(v2);
  v8 = *(unsigned int *)(a1 + 120);
  v9 = *(_QWORD *)(a1 + 104);
  if ((_DWORD)v8)
  {
    v10 = 32 * v8;
    do
    {
      if (*(_DWORD *)v9 <= 0xFFFFFFFD && *(char *)(v9 + 31) < 0)
        operator delete(*(void **)(v9 + 8));
      v9 += 32;
      v10 -= 32;
    }
    while (v10);
    v9 = *(_QWORD *)(a1 + 104);
    v11 = (void *)(32 * *(unsigned int *)(a1 + 120));
  }
  else
  {
    v11 = 0;
  }
  llvm::deallocate_buffer((llvm *)v9, v11);
}

{
}

_QWORD *sub_1807B6D34()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v1 = (_QWORD *)v0[10];
  if (v1 != v0 + 12)
    free(v1);
  v2 = (_QWORD *)v0[4];
  if (v2 != v0 + 6)
    free(v2);
  return v0;
}

uint64_t mlir::OpConversionPattern<mlir::mps::SinOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SinOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SinOpGenericAdaptorBase::SinOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SinOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SinOpGenericAdaptorBase::SinOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::SinOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SinOp &>(mlir::mps::SinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SinOp &>(mlir::mps::SinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SinOp,mlir::anec::Sin>::matchAndRewriteWithStaticShapes(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  mlir::Float16Type **v10;
  llvm::APFloatBase *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;
  int v20;
  BOOL v21;
  char v22;
  llvm::APFloatBase *v23;
  void *v24;
  llvm::APFloatBase *v25;
  void *v26;
  mlir::MLIRContext *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t F16Type;
  uint64_t FloatAttr;
  llvm::APFloatBase *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  mlir::Float16Type **v39;
  uint64_t v40;
  uint64_t v41;
  const llvm::detail::DoubleAPFloat *v42;
  llvm::APFloatBase *v43;
  void *v44;
  mlir::MLIRContext *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::GenericProgramPoint *v51;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[2];
  _BYTE v60[24];
  _QWORD *v61;
  _QWORD v62[3];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  uint64_t v67;
  _BYTE v68[32];
  void *v69[2];
  _QWORD v70[11];

  v5 = a1;
  v70[9] = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a3 + 40);
  v6 = *(_QWORD *)(a3 + 48);
  v69[0] = v70;
  v69[1] = (void *)0x400000000;
  v70[8] = 4;
  v65 = 0;
  v66 = v68;
  v67 = 0x400000000;
  v63 = 0;
  v64 = v7;
  v55 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = 0;
    v10 = (mlir::Float16Type **)(a4 + 1);
    do
    {
      a1 = (llvm::APFloatBase *)mlir::ValueRange::dereference_iterator(&v64, v8);
      v11 = a1;
      v12 = *((_QWORD *)v5 + 13);
      v13 = *((unsigned int *)v5 + 30);
      if ((_DWORD)v13)
      {
        v14 = v13 - 1;
        v15 = (_DWORD *)(v12 + 32 * (((_DWORD)v13 - 1) & (37 * v9)));
        v16 = *v15;
        if (*v15 == v9)
        {
LABEL_5:
          v17 = (_DWORD *)(v12 + 32 * v13);
          goto LABEL_11;
        }
        v18 = 1;
        LODWORD(v19) = v14 & (37 * v9);
        while (v16 != -1)
        {
          v20 = v19 + v18++;
          v19 = v20 & v14;
          v16 = *(_DWORD *)(v12 + 32 * v19);
          if (v16 == v9)
          {
            v15 = (_DWORD *)(v12 + 32 * v19);
            goto LABEL_5;
          }
        }
      }
      v15 = (_DWORD *)(v12 + 32 * v13);
      v17 = v15;
LABEL_11:
      v59[0] = v15;
      v59[1] = v17;
      if ((_DWORD *)(v12 + 32 * v13) == v15)
      {
        v35 = v67;
        if (v67 >= (unint64_t)HIDWORD(v67))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v68, v67 + 1, 8);
          v35 = v67;
        }
        *((_QWORD *)v66 + v35) = v11;
        LODWORD(v67) = v67 + 1;
      }
      else
      {
        v56 = &v58;
        v57 = 0x100000000;
        if (mlir::matchConstantWithFloatVector<float>((uint64_t)a1, (uint64_t)&v56))
          v21 = (_DWORD)v57 == 1;
        else
          v21 = 0;
        v22 = v21;
        if (v21)
        {
          v23 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v60, *(float *)v56);
          v24 = llvm::APFloatBase::IEEEsingle(v23);
          llvm::APFloat::Storage::Storage(v62, v60, v24);
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v60);
          v26 = llvm::APFloatBase::IEEEhalf(v25);
          v60[0] = 0;
          llvm::APFloat::convert((uint64_t)&v61, v26, 1, v60);
          v28 = *(char *)(v59[0] + 31);
          if (v28 >= 0)
            v29 = v59[0] + 8;
          else
            v29 = *(_QWORD *)(v59[0] + 8);
          if (v28 >= 0)
            v30 = *(unsigned __int8 *)(v59[0] + 31);
          else
            v30 = *(_QWORD *)(v59[0] + 16);
          F16Type = mlir::Builder::getF16Type(v10, v27);
          FloatAttr = mlir::Builder::getFloatAttr((uint64_t)v10, F16Type, (uint64_t)&v61);
          v33 = (llvm::APFloatBase *)mlir::NamedAttrList::set((uint64_t)v69, v29, v30, FloatAttr);
          v34 = (void *)v62[0];
          if (llvm::APFloatBase::PPCDoubleDouble(v33) == v34)
            llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
          else
            llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
        }
        else
        {
          v61 = v59;
          v4 = a4[2];
          if (v4)
          {
            if (mlir::RewriterBase::Listener::classof(a4[2]))
            else
              v4 = 0;
          }
        }
        a1 = (llvm::APFloatBase *)v56;
        if (v56 != &v58)
          free(v56);
        if ((v22 & 1) == 0)
          goto LABEL_57;
      }
      v9 = v63 + 1;
      v8 = v65 + 1;
      ++v63;
      ++v65;
    }
    while (v64 != v7 || v8 != v55);
  }
  v36 = *((unsigned int *)v5 + 34);
  if ((_DWORD)v36)
  {
    v37 = *((_QWORD *)v5 + 16);
    v38 = llvm::APFloatBase::PPCDoubleDouble(a1);
    v39 = (mlir::Float16Type **)(a4 + 1);
    v40 = 56 * v36;
    v41 = v37 + 32;
    do
    {
      v42 = (const llvm::detail::DoubleAPFloat *)(v41 - 24);
      if (v38 == *(void **)(v41 - 24))
        v43 = llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62, v42);
      else
        v43 = (llvm::APFloatBase *)llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v62, v42);
      v44 = llvm::APFloatBase::IEEEhalf(v43);
      v60[0] = 0;
      llvm::APFloat::convert((uint64_t)&v61, v44, 1, v60);
      v46 = *(char *)(v41 + 23);
      if (v46 >= 0)
        v47 = v41;
      else
        v47 = *(_QWORD *)v41;
      if (v46 >= 0)
        v48 = *(unsigned __int8 *)(v41 + 23);
      else
        v48 = *(_QWORD *)(v41 + 8);
      v49 = mlir::Builder::getF16Type(v39, v45);
      v50 = mlir::Builder::getFloatAttr((uint64_t)v39, v49, (uint64_t)&v61);
      mlir::NamedAttrList::append((uint64_t)v69, v47, v48, v50);
      if (v38 == (void *)v62[0])
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
      v41 += 56;
      v40 -= 56;
    }
    while (v40);
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v61, (uint64_t)v66, v67);
  v51 = mlir::OpBuilder::create<mlir::anec::Sin,mlir::ValueRange,mlir::NamedAttrList &>(a4 + 1, *(_QWORD *)(a2 + 24), (uint64_t *)&v61, (uint64_t)v69);
  (*(void (**)(uint64_t *, uint64_t, mlir::GenericProgramPoint *))(*a4 + 32))(a4, a2, v51);
  v4 = 1;
LABEL_57:
  if (v66 != v68)
    free(v66);
  if (v69[0] != v70)
    free(v69[0]);
  return v4;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::SinOp &>(mlir::mps::SinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::`anonymous namespace'::ConvertElementwiseUnary<mlir::mps::SinOp,mlir::anec::Sin>::matchAndRewriteWithStaticShapes(mlir::mps::SinOp,mlir::mps::SinOpAdaptor,mlir::ConversionPatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(unsigned int ***a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  uint64_t v16;

  v3 = mlir::Diagnostic::operator<<(a2, "Failed to extract fpValues from Operand ");
  v4 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  v6 = ***a1;
  v15 = 5;
  v16 = v6;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v15;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v12 = v7 + 1;
    v13 = v5 + 24 * v7 > (unint64_t)&v15;
    if (v5 <= (unint64_t)&v15 && v13)
    {
      v14 = (char *)&v15 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = (int *)&v14[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v3 + 32), v12, 24);
      v5 = *(_QWORD *)(v3 + 16);
      v8 = &v15;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v3 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = *((_QWORD *)v8 + 2);
  *(_OWORD *)v9 = v10;
  ++*(_DWORD *)(v3 + 24);
  return mlir::Diagnostic::operator<<(v3, " \n");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Sin,mlir::ValueRange,mlir::NamedAttrList &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.sin", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"anec.sin";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v12 = *a3;
  v11 = a3[1];
  v13 = (const void *)mlir::NamedAttrList::operator llvm::ArrayRef<mlir::NamedAttribute>(a4);
  mlir::anec::Ceil::build(a1, (uint64_t)v23, v12, v11, v13, v14);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Sin,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

_QWORD *mlir::`anonymous namespace'::FoldOperation<mlir::mps::IdentityOp>::~FoldOperation(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::FoldOperation<mlir::mps::IdentityOp>::~FoldOperation(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::IdentityOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::IdentityOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::IdentityOpGenericAdaptorBase::IdentityOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::IdentityOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::IdentityOpGenericAdaptorBase::IdentityOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::IdentityOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _QWORD v29[2];
  _QWORD *v30;
  _QWORD v31[4];
  __int16 v32;
  _OWORD v33[3];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 40);
  v9 = *(_QWORD *)(a3 + 48);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v33[0] = *(_OWORD *)a3;
      v33[1] = v28;
      v33[2] = *(_OWORD *)(a3 + 32);
      v34 = *(_QWORD *)(a3 + 48);
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v33, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v31[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v32 = 259;
    v29[0] = v31;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::IdentityOp &>(mlir::mps::IdentityOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v29);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v29[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v29[1] = v13;
    if (v29[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v29))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v32 = 259;
  v30 = v31;
  v31[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::IdentityOp &>(mlir::mps::IdentityOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v30);
  return result;
}

uint64_t mlir::`anonymous namespace'::FoldOperation<mlir::mps::IdentityOp>::matchAndRewriteWithStaticShapes(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  mlir::ConversionPatternRewriter::replaceOp(a4, a2, *(_QWORD *)(a3 + 40), *(_QWORD *)(a3 + 48));
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::IdentityOp &>(mlir::mps::IdentityOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

void mlir::`anonymous namespace'::ConvertNormalization::~ConvertNormalization(mlir::_anonymous_namespace_::ConvertNormalization *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NormalizationOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NormalizationOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::NormalizationOpGenericAdaptorBase::NormalizationOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NormalizationOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::NormalizationOpGenericAdaptorBase::NormalizationOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::NormalizationOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 48);
  v9 = *(_QWORD *)(a3 + 56);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      v29 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NormalizationOp &>(mlir::mps::NormalizationOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NormalizationOp &>(mlir::mps::NormalizationOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertNormalization::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  llvm::APFloatBase *Epsilon;
  void *v7;
  mlir::GenericProgramPoint *v8;
  unsigned int *v9;
  void *v10;
  llvm::APFloatBase *v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  unint64_t v20[2];
  _BYTE v21[8];
  _QWORD v22[3];
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v18 = a2;
  v23 = *(_OWORD *)(a3 + 48);
  v17 = mlir::ValueRange::dereference_iterator(&v23, 0);
  v16 = mlir::ValueRange::dereference_iterator(&v23, 1);
  v15 = mlir::ValueRange::dereference_iterator(&v23, 2);
  v14 = mlir::ValueRange::dereference_iterator(&v23, 3);
  v13 = mlir::ValueRange::dereference_iterator(&v23, 4);
  v17 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseSub,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v17, &v16)- 16;
  Epsilon = mlir::mps::InstanceNormOp::getEpsilon((mlir::mps::InstanceNormOp *)&v18, (uint64_t)v21);
  v7 = llvm::APFloatBase::IEEEhalf(Epsilon);
  LOBYTE(v19) = 0;
  llvm::APFloat::convert((uint64_t)v21, v7, 1, &v19);
  v15 = (uint64_t)mlir::OpBuilder::create<mlir::anec::Rsqrt,mlir::Value &,llvm::APFloat &>((mlir::Float16Type **)(a4 + 8), *(_QWORD *)(v18 + 24), &v15, (uint64_t)v21)- 16;
  v17 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value,mlir::Value&>((uint64_t *)(a4 + 8), *(_QWORD *)(v18 + 24), &v17, &v15)- 16;
  v17 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value,mlir::Value&>((uint64_t *)(a4 + 8), *(_QWORD *)(v18 + 24), &v17, &v14)- 16;
  v8 = mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(v18 + 24), &v17, &v13);
  v9 = (unsigned int *)v18;
  v19 = (char *)v8 - 16;
  mlir::ValueRange::ValueRange(v20, (uint64_t)&v19, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v9, v20[0], v20[1]);
  v10 = (void *)v22[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v11) == v10)
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v22);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v22);
  return 1;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::NormalizationOp &>(mlir::mps::NormalizationOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseSub,mlir::Value &,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.sub", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.sub";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseSub,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Rsqrt,mlir::Value &,llvm::APFloat &>(mlir::Float16Type **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  const llvm::detail::DoubleAPFloat *v12;
  void *v13;
  llvm::APFloatBase *v14;
  void *v15;
  mlir::GenericProgramPoint *v16;
  mlir::GenericProgramPoint *v17;
  uint64_t v19;
  const char *v20;
  __int16 v21;
  uint64_t v22[4];
  __int16 v23;
  char v24[8];
  _QWORD v25[3];
  _QWORD v26[39];

  v26[38] = *MEMORY[0x1E0C80C00];
  v19 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v19);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.r_sqrt", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v23 = 1283;
    v22[2] = (uint64_t)"anec.r_sqrt";
    v22[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v21 = 259;
    llvm::operator+(v22, (uint64_t *)&v20, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v9);
  v11 = *a3;
  v13 = *(void **)(a4 + 8);
  v12 = (const llvm::detail::DoubleAPFloat *)(a4 + 8);
  v15 = llvm::APFloatBase::PPCDoubleDouble(v14);
  if (v15 == v13)
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v25, v12);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v25, v12);
  mlir::anec::Rsqrt::build(a1, (uint64_t)v26, v11, (uint64_t)v24);
  if (v15 == (void *)v25[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v25);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v25);
  v16 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v26);
  if (*(_UNKNOWN **)(*((_QWORD *)v16 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Rsqrt,void>::id)
    v17 = v16;
  else
    v17 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v17;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ElementwiseAdd,mlir::Value &,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.add", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"anec.add";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::ElementwiseAdd::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::`anonymous namespace'::ConvertReductionVariance::~ConvertReductionVariance(mlir::_anonymous_namespace_::ConvertReductionVariance *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReductionVarianceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 48);
  v9 = *(_QWORD *)(a3 + 56);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      v29 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionVarianceOp &>(mlir::mps::ReductionVarianceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionVarianceOp &>(mlir::mps::ReductionVarianceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertReductionVariance::matchAndRewriteWithStaticShapes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t *v16;
  _QWORD *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  unint64_t v27;
  unint64_t *v28;
  _QWORD *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t NumElements;
  uint64_t v34;
  BOOL v35;
  unsigned int *p_p;
  uint64_t v37;
  uint64_t v38;
  llvm::APFloatBase *v39;
  void *v40;
  llvm::APFloatBase *v41;
  void *v42;
  uint64_t *v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  _QWORD *v47;
  _QWORD *v48;
  unint64_t v49;
  unint64_t *v50;
  _QWORD *v51;
  unint64_t v52;
  uint64_t v53;
  llvm::APFloatBase *RankPromotionTypeForANE;
  uint64_t v55;
  mlir::GenericProgramPoint *v56;
  void *v57;
  uint64_t v58;
  unsigned int *v59;
  const void ****v60;
  uint64_t v61;
  mlir::GenericProgramPoint *v63;
  void *__p;
  unsigned int v65;
  uint64_t *v66;
  unsigned __int8 v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD v70[2];
  uint64_t *v71;
  unint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75[2];
  pthread_rwlock_t *v76[67];
  _QWORD v77[2];
  uint64_t *v78;
  void *v79;
  uint64_t v80;
  __int16 v81;
  uint64_t v82;

  v82 = *MEMORY[0x1E0C80C00];
  v74 = a2;
  v7 = *(_QWORD *)(a3 + 56);
  v77[0] = *(_QWORD *)(a3 + 48);
  v6 = v77[0];
  v77[1] = v7;
  mlir::TypeConverter::TypeConverter((mlir::TypeConverter *)v76, *(const mlir::TypeConverter **)(a1 + 96));
  v73 = v8;
  if (!(_BYTE)v8)
  {
    v78 = (uint64_t *)"failed to convert operand axes";
    v81 = 259;
    v66 = (uint64_t *)&v78;
    v58 = *(_QWORD *)(a4 + 16);
    if (v58 && mlir::RewriterBase::Listener::classof(v58))
      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(_QWORD *)v58 + 64))(v58, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionVarianceOp &>(mlir::mps::ReductionVarianceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v66);
LABEL_58:
    mlir::TypeConverter::~TypeConverter(v76);
  }
  v71 = (uint64_t *)mlir::ValueRange::dereference_iterator(v77, 0);
  v9 = (uint64_t *)(v71[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v9)
    goto LABEL_11;
  v10 = *v9;
  v11 = mlir::TypeID::get<mlir::ShapedType>();
  v12 = *(unsigned int *)(v10 + 16);
  if (!(_DWORD)v12)
    goto LABEL_11;
  v13 = *(_QWORD **)(v10 + 8);
  v14 = &v13[2 * v12];
  do
  {
    v15 = v12 >> 1;
    v16 = &v13[2 * (v12 >> 1)];
    v18 = *v16;
    v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11)
      v13 = v17;
    else
      v12 = v15;
  }
  while (v12);
  if (v13 != v14 && *v13 == v11)
    v19 = v13[1];
  else
LABEL_11:
    v19 = 0;
  v70[0] = mlir::getRankPromotionTypeForANE((uint64_t)v9, v19);
  v70[1] = v20;
  v69 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ReduceAvg,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(_QWORD *)(v74 + 24), (uint64_t *)&v71, (uint64_t *)&v72)- 16;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v74))
  {
    v21 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v74) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v21)
      goto LABEL_22;
    v22 = *v21;
    v23 = mlir::TypeID::get<mlir::ShapedType>();
    v24 = *(unsigned int *)(v22 + 16);
    if (!(_DWORD)v24)
      goto LABEL_22;
    v25 = *(_QWORD **)(v22 + 8);
    v26 = &v25[2 * v24];
    do
    {
      v27 = v24 >> 1;
      v28 = &v25[2 * (v24 >> 1)];
      v30 = *v28;
      v29 = v28 + 2;
      v24 += ~(v24 >> 1);
      if (v30 < v23)
        v25 = v29;
      else
        v24 = v27;
    }
    while (v24);
    if (v25 != v26 && *v25 == v23)
      v31 = v25[1];
    else
LABEL_22:
      v31 = 0;
    v78 = v21;
    v79 = (void *)v31;
  }
  v71 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::anec::ElementwiseSub,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(v74 + 24), (uint64_t *)&v71, &v69)- 16);
  v71 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value,mlir::Value&>((uint64_t *)(a4 + 8), *(_QWORD *)(v74 + 24), (uint64_t *)&v71, (uint64_t *)&v71)- 16);
  v71 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::anec::ReduceSum,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a4 + 8), *(_QWORD *)(v74 + 24), (uint64_t *)&v71, (uint64_t *)&v72)- 16);
  if ((_BYTE)v73)
  {
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v78, v72, 0);
    v32 = v72;
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v72);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v66, v32, NumElements);
    v34 = 1;
    while (1)
    {
      v35 = v78 == v66 && v79 == v67;
      if (v35 && v80 == v68)
        break;
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v78, (llvm::APInt *)&__p);
      if (v65 >= 0x41)
        p_p = (unsigned int *)__p;
      else
        p_p = (unsigned int *)&__p;
      v37 = *p_p;
      v38 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v70) + 8 * v37);
      if (v65 >= 0x41 && __p)
        operator delete[](__p);
      v34 *= v38;
      ++v80;
    }
    if (v34 != 1)
    {
      v39 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)&v66, 1.0 / ((double)v34 + -1.0));
      v40 = llvm::APFloatBase::IEEEdouble(v39);
      llvm::APFloat::Storage::Storage(&v79, &v66, v40);
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v66);
      v42 = llvm::APFloatBase::IEEEhalf(v41);
      LOBYTE(v66) = 0;
      llvm::APFloat::convert((uint64_t)&v78, v42, 1, &v66);
      v43 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v74) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v43)
        goto LABEL_49;
      v44 = *v43;
      v45 = mlir::TypeID::get<mlir::ShapedType>();
      v46 = *(unsigned int *)(v44 + 16);
      if (!(_DWORD)v46)
        goto LABEL_49;
      v47 = *(_QWORD **)(v44 + 8);
      v48 = &v47[2 * v46];
      do
      {
        v49 = v46 >> 1;
        v50 = &v47[2 * (v46 >> 1)];
        v52 = *v50;
        v51 = v50 + 2;
        v46 += ~(v46 >> 1);
        if (v52 < v45)
          v47 = v51;
        else
          v46 = v49;
      }
      while (v46);
      if (v47 != v48 && *v47 == v45)
        v53 = v47[1];
      else
LABEL_49:
        v53 = 0;
      RankPromotionTypeForANE = (llvm::APFloatBase *)mlir::getRankPromotionTypeForANE((uint64_t)v43, v53);
      v66 = (uint64_t *)mlir::DenseElementsAttr::get(RankPromotionTypeForANE, v55, (uint64_t)&v78, 1);
      __p = (void *)mlir::TypeConverter::convertType((uint64_t)v76, RankPromotionTypeForANE);
      v63 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::MemRefType &,mlir::mps::MPSBufferTensorAttr &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v74 + 24), (uint64_t *)&__p, &v66);
      v56 = mlir::OpBuilder::create<mlir::anec::ElementwiseMult,mlir::Value &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *(_QWORD *)(v74 + 24), (uint64_t *)&v71, &v63);
      v71 = (uint64_t *)((char *)v56 - 16);
      v57 = v79;
      if (llvm::APFloatBase::PPCDoubleDouble(v56) == v57)
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v79);
      else
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v79);
    }
    v59 = (unsigned int *)v74;
    v78 = v71;
    mlir::ValueRange::ValueRange(v75, (uint64_t)&v78, 1uLL);
    mlir::ConversionPatternRewriter::replaceOp(a4, v59, v75[0], v75[1]);
    goto LABEL_58;
  }
  v60 = (const void ****)std::__throw_bad_optional_access[abi:nn180100]();
  return llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionVarianceOp &>(mlir::mps::ReductionVarianceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(v60, v61);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionVarianceOp &>(mlir::mps::ReductionVarianceOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

_QWORD *mlir::`anonymous namespace'::ConvertReductionArg<mlir::mps::ReductionArgMinOp,(mlir::anec::Family)0>::~ConvertReductionArg(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReductionArg<mlir::mps::ReductionArgMinOp,(mlir::anec::Family)0>::~ConvertReductionArg(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionArgMinOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionArgMinOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ReductionArgMinOpGenericAdaptorBase::ReductionArgMinOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionArgMinOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ReductionArgMinOpGenericAdaptorBase::ReductionArgMinOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::`anonymous namespace'::OpConversionPatternMPSToANEC<mlir::mps::ReductionArgMinOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  uint64_t v23;
  _QWORD *ArgAttrsAttr;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  _QWORD v30[2];
  _QWORD *v31;
  _QWORD v32[4];
  __int16 v33;
  _OWORD v34[4];
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 48);
  v9 = *(_QWORD *)(a3 + 56);
  v35 = v8;
  v36 = 0;
  if (!v9)
  {
LABEL_18:
    v19 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v19)
      v20 = a2 - 16;
    else
      v20 = 0;
    if (!(_DWORD)v19)
    {
LABEL_36:
      v28 = *(_OWORD *)(a3 + 16);
      v34[0] = *(_OWORD *)a3;
      v34[1] = v28;
      v29 = *(_OWORD *)(a3 + 48);
      v34[2] = *(_OWORD *)(a3 + 32);
      v34[3] = v29;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(_QWORD *)a1 + 88))(a1, a2, v34, a4);
    }
    v21 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, v21);
      v35 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
      v36 = v23;
      if (v35)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35)
          || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v35))
        {
          goto LABEL_32;
        }
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v35);
        if (v25)
          break;
      }
LABEL_23:
      if (++v21 == v19)
        goto LABEL_36;
    }
    v26 = 8 * v25;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v26 -= 8;
      if (!v26)
        goto LABEL_23;
    }
LABEL_32:
    v32[0] = "failed: mps ops with unranked output types or dynamic shapes are not supported on ANEs.";
    v33 = 259;
    v30[0] = v32;
    v27 = *(_QWORD *)(a4 + 16);
    if (v27)
    {
      result = mlir::RewriterBase::Listener::classof(v27);
      if ((_DWORD)result)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v27 + 64))(v27, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionArgMinOp &>(mlir::mps::ReductionArgMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v30);
      return result;
    }
    return 0;
  }
  v10 = 0;
  while (1)
  {
    v12 = mlir::ValueRange::dereference_iterator(&v35, v10);
    v30[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v30[1] = v13;
    if (v30[0])
    {
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30)
        || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v30))
      {
        goto LABEL_15;
      }
      v14 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v30);
      if (v15)
        break;
    }
LABEL_3:
    v10 = ++v36;
    if (v35 == v8 && v10 == v9)
      goto LABEL_18;
  }
  v16 = 8 * v15;
  while (*v14 != 0x8000000000000000)
  {
    ++v14;
    v16 -= 8;
    if (!v16)
      goto LABEL_3;
  }
LABEL_15:
  v33 = 259;
  v31 = v32;
  v32[0] = "failed: unranked input types or dynamic shapes are not supported on ANEs.";
  v17 = *(_QWORD *)(a4 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v17);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionArgMinOp &>(mlir::mps::ReductionArgMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v31);
  return result;
}

uint64_t mlir::`anonymous namespace'::ConvertReductionArg<mlir::mps::ReductionArgMinOp,(mlir::anec::Family)0>::matchAndRewriteWithStaticShapes(int a1, unsigned int *a2, mlir::scf::detail::ConditionOpGenericAdaptorBase *this, uint64_t a4)
{
  unsigned int ODSOperandIndexAndLength;
  void *v7;
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  void *v23;
  uint64_t DefiningOp;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  int v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  unint64_t v36;
  unint64_t *v37;
  _QWORD *v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unsigned int v42;
  void *v43;
  unint64_t v44;
  unsigned int IndexFromDim;
  char v46;
  unsigned int v47;
  unint64_t v48;
  unsigned int v49;
  char v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  uint64_t v55;
  int v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t *v59;
  unint64_t v60;
  char *v61;
  uint64_t *v62;
  unint64_t v63;
  uint64_t v64;
  __int128 *v65;
  _OWORD *v66;
  uint64_t v67;
  __int128 v68;
  uint64_t v69;
  uint64_t v70;
  mlir::Builder *v71;
  uint64_t v72;
  uint64_t IntegerType;
  _QWORD *v74;
  _QWORD *v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  _QWORD *v80;
  _QWORD *v81;
  unint64_t v82;
  unint64_t *v83;
  _QWORD *v84;
  unint64_t v85;
  uint64_t *v86;
  uint64_t v87;
  uint64_t v88;
  _QWORD *v89;
  _QWORD *v90;
  uint64_t v91;
  unint64_t v92;
  unint64_t v93;
  _QWORD *v94;
  _QWORD *v95;
  unint64_t v96;
  unint64_t *v97;
  _QWORD *v98;
  unint64_t v99;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  uint64_t v103;
  _QWORD *v104;
  _QWORD *v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  _QWORD *v109;
  _QWORD *v110;
  unint64_t v111;
  unint64_t *v112;
  _QWORD *v113;
  unint64_t v114;
  uint64_t v115;
  void *v116;
  uint64_t v117;
  uint64_t v118;
  _QWORD *v119;
  _QWORD *v120;
  uint64_t v121;
  unint64_t v122;
  unint64_t v123;
  _QWORD *v124;
  _QWORD *v125;
  unint64_t v126;
  unint64_t *v127;
  _QWORD *v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t *v131;
  uint64_t v132;
  unint64_t v133;
  unint64_t v134;
  _QWORD *v135;
  _QWORD *v136;
  unint64_t v137;
  unint64_t *v138;
  _QWORD *v139;
  unint64_t v140;
  uint64_t v141;
  uint64_t v142;
  void *ArgAttrsAttr;
  mlir::AffineMap *v144;
  mlir::AffineMap *v145;
  uint64_t ElementTypeOrSelf;
  uint64_t v147;
  const void ****v149;
  uint64_t v150;
  uint64_t *v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  _QWORD v157[2];
  unsigned int *v158;
  _QWORD v159[2];
  void *RankPromotionTypeForANE;
  uint64_t v161;
  _OWORD v162[2];
  void *v163;
  uint64_t v164;
  _BYTE v165[16];
  uint64_t *v166;
  uint64_t v167;
  uint64_t v168;
  char *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172[3];

  v172[1] = *MEMORY[0x1E0C80C00];
  v158 = a2;
  ODSOperandIndexAndLength = mlir::scf::detail::ConditionOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0, *((_DWORD *)this + 14));
  v7 = (void *)*((_QWORD *)this + 6);
  RankPromotionTypeForANE = v7;
  v161 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v7 = (void *)mlir::ValueRange::offset_base(&RankPromotionTypeForANE, ODSOperandIndexAndLength);
  RankPromotionTypeForANE = v7;
  v161 = 0;
  v8 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&RankPromotionTypeForANE, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8)
    goto LABEL_12;
  v9 = *v8;
  v10 = mlir::TypeID::get<mlir::ShapedType>();
  v11 = *(unsigned int *)(v9 + 16);
  if (!(_DWORD)v11)
    goto LABEL_12;
  v12 = *(_QWORD **)(v9 + 8);
  v13 = &v12[2 * v11];
  do
  {
    v14 = v11 >> 1;
    v15 = &v12[2 * (v11 >> 1)];
    v17 = *v15;
    v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10)
      v12 = v16;
    else
      v11 = v14;
  }
  while (v11);
  if (v12 != v13 && *v12 == v10)
    v18 = v12[1];
  else
LABEL_12:
    v18 = 0;
  v157[0] = mlir::getRankPromotionTypeForANE((uint64_t)v8, v18);
  v157[1] = v19;
  v20 = mlir::scf::detail::ConditionOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 1u, *((_DWORD *)this + 14));
  v21 = (void *)*((_QWORD *)this + 6);
  RankPromotionTypeForANE = v21;
  v161 = v20;
  if ((_DWORD)v20)
  {
    v21 = (void *)mlir::ValueRange::offset_base(&RankPromotionTypeForANE, v20);
    v22 = v161;
  }
  else
  {
    v22 = 0;
  }
  if (HIDWORD(v20) + (_DWORD)v20 == v22
    || (RankPromotionTypeForANE = v21,
        v161 = 0,
        (v23 = (void *)mlir::ValueRange::dereference_iterator(&RankPromotionTypeForANE, 0)) == 0))
  {
    v27 = 0;
  }
  else
  {
    v163 = v23;
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v163);
    if (!DefiningOp)
      return 0;
    v25 = DefiningOp;
    v26 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v25 + 48) + 32))(*(_QWORD *)(v25 + 48), v26))
      return 0;
    RankPromotionTypeForANE = v162;
    v161 = 0x100000000;
    mlir::Operation::fold(v25, 0, 0, (uint64_t)&RankPromotionTypeForANE);
    v27 = (uint64_t *)(*(_QWORD *)RankPromotionTypeForANE & 0xFFFFFFFFFFFFFFF8);
    v28 = mlir::DenseIntElementsAttr::classof((uint64_t)v27) & (v27 != 0);
    if (!v28)
      v27 = 0;
    if (RankPromotionTypeForANE != v162)
      free(RankPromotionTypeForANE);
    if ((v28 & 1) == 0)
      return 0;
  }
  v169 = (char *)&v171;
  v170 = 0x100000000;
  v30 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v158) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v30)
    goto LABEL_36;
  v31 = *v30;
  v32 = mlir::TypeID::get<mlir::ShapedType>();
  v33 = *(unsigned int *)(v31 + 16);
  if (!(_DWORD)v33)
    goto LABEL_36;
  v34 = *(_QWORD **)(v31 + 8);
  v35 = &v34[2 * v33];
  do
  {
    v36 = v33 >> 1;
    v37 = &v34[2 * (v33 >> 1)];
    v39 = *v37;
    v38 = v37 + 2;
    v33 += ~(v33 >> 1);
    if (v39 < v32)
      v34 = v38;
    else
      v33 = v36;
  }
  while (v33);
  if (v34 != v35 && *v34 == v32)
    v40 = v34[1];
  else
LABEL_36:
    v40 = 0;
  RankPromotionTypeForANE = v30;
  v161 = v40;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  if (!mlir::getPositivePromotedAxes(v27, v41, (uint64_t)&v169, 0, 0))
    goto LABEL_119;
  v42 = mlir::scf::detail::ConditionOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0, *((_DWORD *)this + 14));
  v43 = (void *)*((_QWORD *)this + 6);
  RankPromotionTypeForANE = v43;
  v161 = v42;
  if (v42)
    v43 = (void *)mlir::ValueRange::offset_base(&RankPromotionTypeForANE, v42);
  RankPromotionTypeForANE = v43;
  v161 = 0;
  v155 = 0;
  v156 = mlir::ValueRange::dereference_iterator(&RankPromotionTypeForANE, 0);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v157);
  IndexFromDim = mlir::anec::getIndexFromDim(3, v44);
  if (v46)
  {
    v47 = IndexFromDim;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v157);
    v49 = mlir::anec::getIndexFromDim(3, v48);
    if (v50)
    {
      v51 = v49;
      v52 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v157) + 8 * v47);
      v53 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v157) + 8 * v51);
      v54 = v169;
      v55 = v170;
      v166 = &v168;
      v167 = 0x100000000;
      if (v170 < 2)
      {
        v56 = 0;
        if (!(_DWORD)v170)
        {
          v151 = &v168;
          goto LABEL_56;
        }
        v58 = 0;
        v57 = &v168;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v166, &v168, v170, 8);
        v56 = v167;
        v57 = v166;
        v58 = v167;
      }
      v59 = &v57[v58];
      v60 = (v55 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      v151 = v57;
      if (v60 >= 7)
      {
        v62 = &v57[v58];
        v61 = v54;
        if ((unint64_t)((char *)v62 - v54) >= 0x20)
        {
          v63 = v60 + 1;
          v64 = 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL);
          v59 = (uint64_t *)((char *)v59 + v64);
          v61 = &v54[v64];
          v65 = (__int128 *)(v54 + 16);
          v66 = v62 + 2;
          v67 = v63 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v68 = *v65;
            *(v66 - 1) = *(v65 - 1);
            *v66 = v68;
            v65 += 2;
            v66 += 2;
            v67 -= 4;
          }
          while (v67);
          if (v63 == (v63 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_56:
            v70 = (v56 + v55);
            LODWORD(v167) = v56 + v55;
            v163 = v165;
            memset_pattern16(v165, &unk_181233190, 0x10uLL);
            v164 = 0x200000002;
            RankPromotionTypeForANE = v162;
            memset(v162, 0, sizeof(v162));
            v161 = 0x400000004;
            v71 = (mlir::Builder *)(a4 + 8);
            v72 = *((_QWORD *)v158 + 3);
            v159[0] = v70;
            IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
            v74 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v159, 1, IntegerType, 0);
            v75 = v74;
            if (v74)
            {
              v76 = a4;
              v77 = *v74;
              v78 = mlir::TypeID::get<mlir::ShapedType>();
              v79 = *(unsigned int *)(v77 + 16);
              if ((_DWORD)v79)
              {
                v80 = *(_QWORD **)(v77 + 8);
                v81 = &v80[2 * v79];
                do
                {
                  v82 = v79 >> 1;
                  v83 = &v80[2 * (v79 >> 1)];
                  v85 = *v83;
                  v84 = v83 + 2;
                  v79 += ~(v79 >> 1);
                  if (v85 < v78)
                    v80 = v84;
                  else
                    v79 = v82;
                }
                while (v79);
                a4 = v76;
                if (v80 != v81)
                {
                  v86 = v151;
                  if (*v80 == v78)
                    v87 = v80[1];
                  else
                    v87 = 0;
                  goto LABEL_72;
                }
                v87 = 0;
              }
              else
              {
                v87 = 0;
                a4 = v76;
              }
              v86 = v151;
            }
            else
            {
              v87 = 0;
              v86 = v151;
            }
LABEL_72:
            v154 = mlir::DenseElementsAttr::getFromRawBuffer(v75, v87, v86, 8 * v70, 8, 1, 0);
            v159[0] = v52;
            v159[1] = v53;
            v172[0] = 2;
            v88 = mlir::Builder::getIntegerType(v71, 0x40u, 0);
            v89 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v172, 1, v88, 0);
            v90 = v89;
            if (!v89)
              goto LABEL_81;
            v91 = *v89;
            v92 = mlir::TypeID::get<mlir::ShapedType>();
            v93 = *(unsigned int *)(v91 + 16);
            if (!(_DWORD)v93)
              goto LABEL_81;
            v94 = *(_QWORD **)(v91 + 8);
            v95 = &v94[2 * v93];
            do
            {
              v96 = v93 >> 1;
              v97 = &v94[2 * (v93 >> 1)];
              v99 = *v97;
              v98 = v97 + 2;
              v93 += ~(v93 >> 1);
              if (v99 < v92)
                v94 = v98;
              else
                v93 = v96;
            }
            while (v93);
            if (v94 != v95 && *v94 == v92)
              v100 = v94[1];
            else
LABEL_81:
              v100 = 0;
            v153 = mlir::DenseElementsAttr::getFromRawBuffer(v90, v100, v159, 16, 8, 1, 0);
            v101 = v163;
            v102 = v164;
            v172[0] = v164;
            v103 = mlir::Builder::getIntegerType(v71, 0x40u, 0);
            v104 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v172, 1, v103, 0);
            v105 = v104;
            if (!v104)
              goto LABEL_91;
            v106 = *v104;
            v107 = mlir::TypeID::get<mlir::ShapedType>();
            v108 = *(unsigned int *)(v106 + 16);
            if (!(_DWORD)v108)
              goto LABEL_91;
            v109 = *(_QWORD **)(v106 + 8);
            v110 = &v109[2 * v108];
            do
            {
              v111 = v108 >> 1;
              v112 = &v109[2 * (v108 >> 1)];
              v114 = *v112;
              v113 = v112 + 2;
              v108 += ~(v108 >> 1);
              if (v114 < v107)
                v109 = v113;
              else
                v108 = v111;
            }
            while (v108);
            if (v109 != v110 && *v109 == v107)
              v115 = v109[1];
            else
LABEL_91:
              v115 = 0;
            v152 = mlir::DenseElementsAttr::getFromRawBuffer(v105, v115, v101, 8 * v102, 8, 1, 0);
            v116 = RankPromotionTypeForANE;
            v117 = v161;
            v172[0] = v161;
            v118 = mlir::Builder::getIntegerType(v71, 0x40u, 0);
            v119 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v172, 1, v118, 0);
            v120 = v119;
            if (!v119)
              goto LABEL_101;
            v121 = *v119;
            v122 = mlir::TypeID::get<mlir::ShapedType>();
            v123 = *(unsigned int *)(v121 + 16);
            if (!(_DWORD)v123)
              goto LABEL_101;
            v124 = *(_QWORD **)(v121 + 8);
            v125 = &v124[2 * v123];
            do
            {
              v126 = v123 >> 1;
              v127 = &v124[2 * (v123 >> 1)];
              v129 = *v127;
              v128 = v127 + 2;
              v123 += ~(v123 >> 1);
              if (v129 < v122)
                v124 = v128;
              else
                v123 = v126;
            }
            while (v123);
            if (v124 != v125 && *v124 == v122)
              v130 = v124[1];
            else
LABEL_101:
              v130 = 0;
            v172[0] = mlir::DenseElementsAttr::getFromRawBuffer(v120, v130, v116, 8 * v117, 8, 1, 0);
            v156 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ArgMinMax,mlir::Value &,mlir::DenseIntElementsAttr,mlir::anec::ArgMinMaxMode &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr>((uint64_t *)v71, v72, &v156, &v154, &v155, &v153, &v152, v172)- 16;
            if (RankPromotionTypeForANE != v162)
              free(RankPromotionTypeForANE);
            if (v163 != v165)
              free(v163);
            if (v166 != &v168)
              free(v166);
            v131 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v158) + 8) & 0xFFFFFFFFFFFFFFF8);
            if (!v131)
              goto LABEL_117;
            v132 = *v131;
            v133 = mlir::TypeID::get<mlir::ShapedType>();
            v134 = *(unsigned int *)(v132 + 16);
            if (!(_DWORD)v134)
              goto LABEL_117;
            v135 = *(_QWORD **)(v132 + 8);
            v136 = &v135[2 * v134];
            do
            {
              v137 = v134 >> 1;
              v138 = &v135[2 * (v134 >> 1)];
              v140 = *v138;
              v139 = v138 + 2;
              v134 += ~(v134 >> 1);
              if (v140 < v133)
                v135 = v139;
              else
                v134 = v137;
            }
            while (v134);
            if (v135 != v136 && *v135 == v133)
              v141 = v135[1];
            else
LABEL_117:
              v141 = 0;
            RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE((uint64_t)v131, v141);
            v161 = v142;
            ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
            v145 = v144;
            ElementTypeOrSelf = mlir::getElementTypeOrSelf(v156);
            v147 = mlir::MemRefType::get(ArgAttrsAttr, v145, ElementTypeOrSelf, 0, 0, 0);
            if (v147 == (*(_QWORD *)(v156 + 8) & 0xFFFFFFFFFFFFFFF8))
            {
              v29 = 1;
              mlir::ConversionPatternRewriter::replaceOp(a4, v158, (uint64_t)&v156, 1);
LABEL_121:
              if (v169 != (char *)&v171)
                free(v169);
              return v29;
            }
LABEL_119:
            v29 = 0;
            goto LABEL_121;
          }
        }
      }
      else
      {
        v61 = v54;
      }
      do
      {
        v69 = *(_QWORD *)v61;
        v61 += 8;
        *v59++ = v69;
      }
      while (v61 != &v54[8 * v55]);
      goto LABEL_56;
    }
  }
  v149 = (const void ****)std::__throw_bad_optional_access[abi:nn180100]();
  return llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionArgMinOp &>(mlir::mps::ReductionArgMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(v149, v150);
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReductionArgMinOp &>(mlir::mps::ReductionArgMinOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::ArgMinMax,mlir::Value &,mlir::DenseIntElementsAttr,mlir::anec::ArgMinMaxMode &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  uint64_t *Context;
  uint64_t v17;
  char v18;
  mlir::GenericProgramPoint *v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  _QWORD v27[39];

  v27[38] = *MEMORY[0x1E0C80C00];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.arg_min_max", (const unsigned __int8 *)0x10, Context);
  if (!v18)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"anec.arg_min_max";
    v25[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v27, a2, v17);
  mlir::anec::ArgMinMax::build(a1, (uint64_t)v27, *a3, *a4, *a5, *a6, *a7, *a8);
  v19 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v27);
  if (*(_UNKNOWN **)(*((_QWORD *)v19 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::ArgMinMax,void>::id)
    v20 = v19;
  else
    v20 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  return v20;
}

_QWORD *mlir::`anonymous namespace'::ConvertReductionArg<mlir::mps::ReductionArgMinOp,(mlir::anec::Family)1>::~ConvertReductionArg(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::`anonymous namespace'::ConvertReductionArg<mlir::mps::ReductionArgMinOp,(mlir::anec::Family)1>::~ConvertReductionArg(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::`anonymous namespace'::ConvertReductionArg<mlir::mps::ReductionArgMinOp,(mlir::anec::Family)1>::matchAndRewriteWithStaticShapes(int a1, unsigned int *a2, mlir::scf::detail::ConditionOpGenericAdaptorBase *this, uint64_t a4)
{
  unsigned int ODSOperandIndexAndLength;
  void *v7;
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  void *v23;
  uint64_t DefiningOp;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  int v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  unint64_t v36;
  unint64_t *v37;
  _QWORD *v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unsigned int v42;
  void *v43;
  unint64_t v44;
  unsigned int IndexFromDim;
  char v46;
  unsigned int v47;
  unint64_t v48;
  unsigned int v49;
  char v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  uint64_t v55;
  int v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t *v59;
  unint64_t v60;
  char *v61;
  uint64_t *v62;
  unint64_t v63;
  uint64_t v64;
  __int128 *v65;
  _OWORD *v66;
  uint64_t v67;
  __int128 v68;
  uint64_t v69;
  uint64_t v70;
  mlir::Builder *v71;
  uint64_t v72;
  uint64_t IntegerType;
  _QWORD *v74;
  _QWORD *v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  _QWORD *v80;
  _QWORD *v81;
  unint64_t v82;
  unint64_t *v83;
  _QWORD *v84;
  unint64_t v85;
  uint64_t *v86;
  uint64_t v87;
  uint64_t v88;
  _QWORD *v89;
  _QWORD *v90;
  uint64_t v91;
  unint64_t v92;
  unint64_t v93;
  _QWORD *v94;
  _QWORD *v95;
  unint64_t v96;
  unint64_t *v97;
  _QWORD *v98;
  unint64_t v99;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  uint64_t v103;
  _QWORD *v104;
  _QWORD *v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  _QWORD *v109;
  _QWORD *v110;
  unint64_t v111;
  unint64_t *v112;
  _QWORD *v113;
  unint64_t v114;
  uint64_t v115;
  void *v116;
  uint64_t v117;
  uint64_t v118;
  _QWORD *v119;
  _QWORD *v120;
  uint64_t v121;
  unint64_t v122;
  unint64_t v123;
  _QWORD *v124;
  _QWORD *v125;
  unint64_t v126;
  unint64_t *v127;
  _QWORD *v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t *v131;
  uint64_t v132;
  unint64_t v133;
  unint64_t v134;
  _QWORD *v135;
  _QWORD *v136;
  unint64_t v137;
  unint64_t *v138;
  _QWORD *v139;
  unint64_t v140;
  uint64_t v141;
  uint64_t v142;
  void *ArgAttrsAttr;
  mlir::AffineMap *v144;
  mlir::AffineMap *v145;
  uint64_t ElementTypeOrSelf;
  uint64_t v147;
  uint64_t v149;
  uint64_t *v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  _QWORD v156[2];
  unsigned int *v157;
  _QWORD v158[2];
  void *RankPromotionTypeForANE;
  uint64_t v160;
  _OWORD v161[2];
  void *v162;
  uint64_t v163;
  _BYTE v164[16];
  uint64_t *v165;
  uint64_t v166;
  uint64_t v167;
  char *v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171[3];

  v171[1] = *MEMORY[0x1E0C80C00];
  v157 = a2;
  ODSOperandIndexAndLength = mlir::scf::detail::ConditionOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0, *((_DWORD *)this + 14));
  v7 = (void *)*((_QWORD *)this + 6);
  RankPromotionTypeForANE = v7;
  v160 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v7 = (void *)mlir::ValueRange::offset_base(&RankPromotionTypeForANE, ODSOperandIndexAndLength);
  RankPromotionTypeForANE = v7;
  v160 = 0;
  v8 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&RankPromotionTypeForANE, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8)
    goto LABEL_12;
  v9 = *v8;
  v10 = mlir::TypeID::get<mlir::ShapedType>();
  v11 = *(unsigned int *)(v9 + 16);
  if (!(_DWORD)v11)
    goto LABEL_12;
  v12 = *(_QWORD **)(v9 + 8);
  v13 = &v12[2 * v11];
  do
  {
    v14 = v11 >> 1;
    v15 = &v12[2 * (v11 >> 1)];
    v17 = *v15;
    v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10)
      v12 = v16;
    else
      v11 = v14;
  }
  while (v11);
  if (v12 != v13 && *v12 == v10)
    v18 = v12[1];
  else
LABEL_12:
    v18 = 0;
  v156[0] = mlir::getRankPromotionTypeForANE((uint64_t)v8, v18);
  v156[1] = v19;
  v20 = mlir::scf::detail::ConditionOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 1u, *((_DWORD *)this + 14));
  v21 = (void *)*((_QWORD *)this + 6);
  RankPromotionTypeForANE = v21;
  v160 = v20;
  if ((_DWORD)v20)
  {
    v21 = (void *)mlir::ValueRange::offset_base(&RankPromotionTypeForANE, v20);
    v22 = v160;
  }
  else
  {
    v22 = 0;
  }
  if (HIDWORD(v20) + (_DWORD)v20 == v22
    || (RankPromotionTypeForANE = v21,
        v160 = 0,
        (v23 = (void *)mlir::ValueRange::dereference_iterator(&RankPromotionTypeForANE, 0)) == 0))
  {
    v27 = 0;
  }
  else
  {
    v162 = v23;
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v162);
    if (!DefiningOp)
      return 0;
    v25 = DefiningOp;
    v26 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v25 + 48) + 32))(*(_QWORD *)(v25 + 48), v26))
      return 0;
    RankPromotionTypeForANE = v161;
    v160 = 0x100000000;
    mlir::Operation::fold(v25, 0, 0, (uint64_t)&RankPromotionTypeForANE);
    v27 = (uint64_t *)(*(_QWORD *)RankPromotionTypeForANE & 0xFFFFFFFFFFFFFFF8);
    v28 = mlir::DenseIntElementsAttr::classof((uint64_t)v27) & (v27 != 0);
    if (!v28)
      v27 = 0;
    if (RankPromotionTypeForANE != v161)
      free(RankPromotionTypeForANE);
    if ((v28 & 1) == 0)
      return 0;
  }
  v168 = (char *)&v170;
  v169 = 0x100000000;
  v30 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v157) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v30)
    goto LABEL_36;
  v31 = *v30;
  v32 = mlir::TypeID::get<mlir::ShapedType>();
  v33 = *(unsigned int *)(v31 + 16);
  if (!(_DWORD)v33)
    goto LABEL_36;
  v34 = *(_QWORD **)(v31 + 8);
  v35 = &v34[2 * v33];
  do
  {
    v36 = v33 >> 1;
    v37 = &v34[2 * (v33 >> 1)];
    v39 = *v37;
    v38 = v37 + 2;
    v33 += ~(v33 >> 1);
    if (v39 < v32)
      v34 = v38;
    else
      v33 = v36;
  }
  while (v33);
  if (v34 != v35 && *v34 == v32)
    v40 = v34[1];
  else
LABEL_36:
    v40 = 0;
  RankPromotionTypeForANE = v30;
  v160 = v40;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
  if (!mlir::getPositivePromotedAxes(v27, v41, (uint64_t)&v168, 0, 0))
    goto LABEL_119;
  v42 = mlir::scf::detail::ConditionOpGenericAdaptorBase::getODSOperandIndexAndLength(this, 0, *((_DWORD *)this + 14));
  v43 = (void *)*((_QWORD *)this + 6);
  RankPromotionTypeForANE = v43;
  v160 = v42;
  if (v42)
    v43 = (void *)mlir::ValueRange::offset_base(&RankPromotionTypeForANE, v42);
  RankPromotionTypeForANE = v43;
  v160 = 0;
  v154 = 0;
  v155 = mlir::ValueRange::dereference_iterator(&RankPromotionTypeForANE, 0);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v156);
  IndexFromDim = mlir::anec::getIndexFromDim(3, v44);
  if (v46)
  {
    v47 = IndexFromDim;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v156);
    v49 = mlir::anec::getIndexFromDim(3, v48);
    if (v50)
    {
      v51 = v49;
      v52 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v156) + 8 * v47);
      v53 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v156) + 8 * v51);
      v54 = v168;
      v55 = v169;
      v165 = &v167;
      v166 = 0x100000000;
      if (v169 < 2)
      {
        v56 = 0;
        if (!(_DWORD)v169)
        {
          v150 = &v167;
          goto LABEL_56;
        }
        v58 = 0;
        v57 = &v167;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v165, &v167, v169, 8);
        v56 = v166;
        v57 = v165;
        v58 = v166;
      }
      v59 = &v57[v58];
      v60 = (v55 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      v150 = v57;
      if (v60 >= 7)
      {
        v62 = &v57[v58];
        v61 = v54;
        if ((unint64_t)((char *)v62 - v54) >= 0x20)
        {
          v63 = v60 + 1;
          v64 = 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL);
          v59 = (uint64_t *)((char *)v59 + v64);
          v61 = &v54[v64];
          v65 = (__int128 *)(v54 + 16);
          v66 = v62 + 2;
          v67 = v63 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v68 = *v65;
            *(v66 - 1) = *(v65 - 1);
            *v66 = v68;
            v65 += 2;
            v66 += 2;
            v67 -= 4;
          }
          while (v67);
          if (v63 == (v63 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_56:
            v70 = (v56 + v55);
            LODWORD(v166) = v56 + v55;
            v162 = v164;
            memset_pattern16(v164, &unk_181233190, 0x10uLL);
            v163 = 0x200000002;
            RankPromotionTypeForANE = v161;
            memset(v161, 0, sizeof(v161));
            v160 = 0x400000004;
            v71 = (mlir::Builder *)(a4 + 8);
            v72 = *((_QWORD *)v157 + 3);
            v158[0] = v70;
            IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x40u, 0);
            v74 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v158, 1, IntegerType, 0);
            v75 = v74;
            if (v74)
            {
              v76 = a4;
              v77 = *v74;
              v78 = mlir::TypeID::get<mlir::ShapedType>();
              v79 = *(unsigned int *)(v77 + 16);
              if ((_DWORD)v79)
              {
                v80 = *(_QWORD **)(v77 + 8);
                v81 = &v80[2 * v79];
                do
                {
                  v82 = v79 >> 1;
                  v83 = &v80[2 * (v79 >> 1)];
                  v85 = *v83;
                  v84 = v83 + 2;
                  v79 += ~(v79 >> 1);
                  if (v85 < v78)
                    v80 = v84;
                  else
                    v79 = v82;
                }
                while (v79);
                a4 = v76;
                if (v80 != v81)
                {
                  v86 = v150;
                  if (*v80 == v78)
                    v87 = v80[1];
                  else
                    v87 = 0;
                  goto LABEL_72;
                }
                v87 = 0;
              }
              else
              {
                v87 = 0;
                a4 = v76;
              }
              v86 = v150;
            }
            else
            {
              v87 = 0;
              v86 = v150;
            }
LABEL_72:
            v153 = mlir::DenseElementsAttr::getFromRawBuffer(v75, v87, v86, 8 * v70, 8, 1, 0);
            v158[0] = v52;
            v158[1] = v53;
            v171[0] = 2;
            v88 = mlir::Builder::getIntegerType(v71, 0x40u, 0);
            v89 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v171, 1, v88, 0);
            v90 = v89;
            if (!v89)
              goto LABEL_81;
            v91 = *v89;
            v92 = mlir::TypeID::get<mlir::ShapedType>();
            v93 = *(unsigned int *)(v91 + 16);
            if (!(_DWORD)v93)
              goto LABEL_81;
            v94 = *(_QWORD **)(v91 + 8);
            v95 = &v94[2 * v93];
            do
            {
              v96 = v93 >> 1;
              v97 = &v94[2 * (v93 >> 1)];
              v99 = *v97;
              v98 = v97 + 2;
              v93 += ~(v93 >> 1);
              if (v99 < v92)
                v94 = v98;
              else
                v93 = v96;
            }
            while (v93);
            if (v94 != v95 && *v94 == v92)
              v100 = v94[1];
            else
LABEL_81:
              v100 = 0;
            v152 = mlir::DenseElementsAttr::getFromRawBuffer(v90, v100, v158, 16, 8, 1, 0);
            v101 = v162;
            v102 = v163;
            v171[0] = v163;
            v103 = mlir::Builder::getIntegerType(v71, 0x40u, 0);
            v104 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v171, 1, v103, 0);
            v105 = v104;
            if (!v104)
              goto LABEL_91;
            v106 = *v104;
            v107 = mlir::TypeID::get<mlir::ShapedType>();
            v108 = *(unsigned int *)(v106 + 16);
            if (!(_DWORD)v108)
              goto LABEL_91;
            v109 = *(_QWORD **)(v106 + 8);
            v110 = &v109[2 * v108];
            do
            {
              v111 = v108 >> 1;
              v112 = &v109[2 * (v108 >> 1)];
              v114 = *v112;
              v113 = v112 + 2;
              v108 += ~(v108 >> 1);
              if (v114 < v107)
                v109 = v113;
              else
                v108 = v111;
            }
            while (v108);
            if (v109 != v110 && *v109 == v107)
              v115 = v109[1];
            else
LABEL_91:
              v115 = 0;
            v151 = mlir::DenseElementsAttr::getFromRawBuffer(v105, v115, v101, 8 * v102, 8, 1, 0);
            v116 = RankPromotionTypeForANE;
            v117 = v160;
            v171[0] = v160;
            v118 = mlir::Builder::getIntegerType(v71, 0x40u, 0);
            v119 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v171, 1, v118, 0);
            v120 = v119;
            if (!v119)
              goto LABEL_101;
            v121 = *v119;
            v122 = mlir::TypeID::get<mlir::ShapedType>();
            v123 = *(unsigned int *)(v121 + 16);
            if (!(_DWORD)v123)
              goto LABEL_101;
            v124 = *(_QWORD **)(v121 + 8);
            v125 = &v124[2 * v123];
            do
            {
              v126 = v123 >> 1;
              v127 = &v124[2 * (v123 >> 1)];
              v129 = *v127;
              v128 = v127 + 2;
              v123 += ~(v123 >> 1);
              if (v129 < v122)
                v124 = v128;
              else
                v123 = v126;
            }
            while (v123);
            if (v124 != v125 && *v124 == v122)
              v130 = v124[1];
            else
LABEL_101:
              v130 = 0;
            v171[0] = mlir::DenseElementsAttr::getFromRawBuffer(v120, v130, v116, 8 * v117, 8, 1, 0);
            v155 = (uint64_t)mlir::OpBuilder::create<mlir::anec::ArgMinMax,mlir::Value &,mlir::DenseIntElementsAttr,mlir::anec::ArgMinMaxMode &,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr>((uint64_t *)v71, v72, &v155, &v153, &v154, &v152, &v151, v171)- 16;
            if (RankPromotionTypeForANE != v161)
              free(RankPromotionTypeForANE);
            if (v162 != v164)
              free(v162);
            if (v165 != &v167)
              free(v165);
            v131 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v157) + 8) & 0xFFFFFFFFFFFFFFF8);
            if (!v131)
              goto LABEL_117;
            v132 = *v131;
            v133 = mlir::TypeID::get<mlir::ShapedType>();
            v134 = *(unsigned int *)(v132 + 16);
            if (!(_DWORD)v134)
              goto LABEL_117;
            v135 = *(_QWORD **)(v132 + 8);
            v136 = &v135[2 * v134];
            do
            {
              v137 = v134 >> 1;
              v138 = &v135[2 * (v134 >> 1)];
              v140 = *v138;
              v139 = v138 + 2;
              v134 += ~(v134 >> 1);
              if (v140 < v133)
                v135 = v139;
              else
                v134 = v137;
            }
            while (v134);
            if (v135 != v136 && *v135 == v133)
              v141 = v135[1];
            else
LABEL_117:
              v141 = 0;
            RankPromotionTypeForANE = (void *)mlir::getRankPromotionTypeForANE((uint64_t)v131, v141);
            v160 = v142;
            ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&RankPromotionTypeForANE);
            v145 = v144;
            ElementTypeOrSelf = mlir::getElementTypeOrSelf(v155);
            v147 = mlir::MemRefType::get(ArgAttrsAttr, v145, ElementTypeOrSelf, 0, 0, 0);
            if (v147 == (*(_QWORD *)(v155 + 8) & 0xFFFFFFFFFFFFFFF8))
            {
              v29 = 1;
              mlir::ConversionPatternRewriter::replaceOp(a4, v157, (uint64_t)&v155, 1);
LABEL_121:
              if (v168 != (char *)&v170)
                free(v168);
              return v29;
            }
LABEL_119:
            v29 = 0;
            goto LABEL_121;
          }
        }
      }
      else
      {
        v61 = v54;
      }
      do
      {
        v69 = *(_QWORD *)v61;
        v61 += 8;
        *v59++ = v69;
      }
      while (v61 != &v54[8 * v55]);
      goto LABEL_56;
    }
  }
  v149 = std::__throw_bad_optional_access[abi:nn180100]();
}

