void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::NegOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::NegOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::NegOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = (_QWORD **)__p[0];
    if (__p[0])
    {
      v24 = (_QWORD **)__p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::PowOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::PowOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::PowOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = (_QWORD **)__p[0];
    if (__p[0])
    {
      v24 = (_QWORD **)__p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ReOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ReOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ReOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = (_QWORD **)__p[0];
    if (__p[0])
    {
      v24 = (_QWORD **)__p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::RsqrtOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = (_QWORD **)__p[0];
    if (__p[0])
    {
      v24 = (_QWORD **)__p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SignOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SignOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SignOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = (_QWORD **)__p[0];
    if (__p[0])
    {
      v24 = (_QWORD **)__p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SinOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SinOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SinOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = (_QWORD **)__p[0];
    if (__p[0])
    {
      v24 = (_QWORD **)__p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SqrtOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = (_QWORD **)__p[0];
    if (__p[0])
    {
      v24 = (_QWORD **)__p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SubOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SubOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SubOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = (_QWORD **)__p[0];
    if (__p[0])
    {
      v24 = (_QWORD **)__p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::TanOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = (_QWORD **)__p[0];
    if (__p[0])
    {
      v24 = (_QWORD **)__p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::TanhOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = (_QWORD **)__p[0];
    if (__p[0])
    {
      v24 = (_QWORD **)__p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

mlir::complex::ComplexDialect *mlir::complex::ComplexDialect::ComplexDialect(mlir::complex::ComplexDialect *this, mlir::MLIRContext *a2)
{
  _QWORD *v3;
  uint64_t *v4;
  uint64_t *v6;

  v3 = (_QWORD *)mlir::Dialect::Dialect((uint64_t)this, (uint64_t)"complex", 7, (uint64_t)a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ComplexDialect,void>::id);
  *v3 = off_1E0E4EC80;
  v4 = (uint64_t *)v3[4];
  if (!mlir::MLIRContext::isDialectLoading(v4, (uint64_t)"arith", 5))
  {
    v6 = v4;
    mlir::MLIRContext::getOrLoadDialect(v4, (uint64_t)"arith", 5, (uint64_t)&mlir::detail::TypeIDResolver<mlir::arith::ArithDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::arith::ArithDialect * mlir::MLIRContext::getOrLoadDialect<mlir::arith::ArithDialect>(void)::{lambda(void)#1}>, (uint64_t)&v6);
  }
  mlir::Dialect::addOperations<mlir::complex::AbsOp,mlir::complex::AddOp,mlir::complex::AngleOp,mlir::complex::Atan2Op,mlir::complex::BitcastOp,mlir::complex::ConjOp,mlir::complex::ConstantOp,mlir::complex::CosOp,mlir::complex::CreateOp,mlir::complex::DivOp,mlir::complex::EqualOp,mlir::complex::ExpOp,mlir::complex::Expm1Op,mlir::complex::ImOp,mlir::complex::Log1pOp,mlir::complex::LogOp,mlir::complex::MulOp,mlir::complex::NegOp,mlir::complex::NotEqualOp,mlir::complex::PowOp,mlir::complex::ReOp,mlir::complex::RsqrtOp,mlir::complex::SignOp,mlir::complex::SinOp,mlir::complex::SqrtOp,mlir::complex::SubOp,mlir::complex::TanOp,mlir::complex::TanhOp>((uint64_t)this);
  mlir::Dialect::addAttribute<mlir::complex::NumberAttr>((uint64_t)this);
  return this;
}

void mlir::complex::ComplexDialect::~ComplexDialect(llvm **this)
{
  mlir::Dialect::~Dialect(this);
}

void sub_18034AAB4(void *__p)
{
  operator delete(__p);
}

uint64_t mlir::Dialect::addOperations<mlir::complex::AbsOp,mlir::complex::AddOp,mlir::complex::AngleOp,mlir::complex::Atan2Op,mlir::complex::BitcastOp,mlir::complex::ConjOp,mlir::complex::ConstantOp,mlir::complex::CosOp,mlir::complex::CreateOp,mlir::complex::DivOp,mlir::complex::EqualOp,mlir::complex::ExpOp,mlir::complex::Expm1Op,mlir::complex::ImOp,mlir::complex::Log1pOp,mlir::complex::LogOp,mlir::complex::MulOp,mlir::complex::NegOp,mlir::complex::NotEqualOp,mlir::complex::PowOp,mlir::complex::ReOp,mlir::complex::RsqrtOp,mlir::complex::SignOp,mlir::complex::SinOp,mlir::complex::SqrtOp,mlir::complex::SubOp,mlir::complex::TanOp,mlir::complex::TanhOp>(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  _QWORD *v52;
  uint64_t result;
  _QWORD *v54;

  v2 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::Model(v2, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::AbsOp::getAttributeNames(void)::attrNames, 1);
  v3 = (uint64_t)v54;
  v54 = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::Model(v4, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::AddOp::getAttributeNames(void)::attrNames, 1);
  v5 = (uint64_t)v54;
  v54 = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::Model(v6, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::AngleOp::getAttributeNames(void)::attrNames, 1);
  v7 = (uint64_t)v54;
  v54 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  v8 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::Model(v8, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::Atan2Op::getAttributeNames(void)::attrNames, 1);
  v9 = (uint64_t)v54;
  v54 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  mlir::RegisteredOperationName::insert<mlir::complex::BitcastOp>(a1);
  v10 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::Model(v10, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::ConjOp::getAttributeNames(void)::attrNames, 1);
  v11 = (uint64_t)v54;
  v54 = 0;
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
  v12 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::Model(v12, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::ConstantOp::getAttributeNames(void)::attrNames, 1);
  v13 = (uint64_t)v54;
  v54 = 0;
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  v14 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::Model(v14, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::CosOp::getAttributeNames(void)::attrNames, 1);
  v15 = (uint64_t)v54;
  v54 = 0;
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  mlir::RegisteredOperationName::insert<mlir::complex::CreateOp>(a1);
  v16 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::Model(v16, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::DivOp::getAttributeNames(void)::attrNames, 1);
  v17 = (uint64_t)v54;
  v54 = 0;
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
  v18 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::Model(v18, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, 0, 0);
  v19 = (uint64_t)v54;
  v54 = 0;
  if (v19)
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
  v20 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::Model(v20, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::ExpOp::getAttributeNames(void)::attrNames, 1);
  v21 = (uint64_t)v54;
  v54 = 0;
  if (v21)
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
  v22 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::Model(v22, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::Expm1Op::getAttributeNames(void)::attrNames, 1);
  v23 = (uint64_t)v54;
  v54 = 0;
  if (v23)
    (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
  v24 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::Model(v24, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::ImOp::getAttributeNames(void)::attrNames, 1);
  v25 = (uint64_t)v54;
  v54 = 0;
  if (v25)
    (*(void (**)(uint64_t))(*(_QWORD *)v25 + 8))(v25);
  v26 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::Model(v26, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::Log1pOp::getAttributeNames(void)::attrNames, 1);
  v27 = (uint64_t)v54;
  v54 = 0;
  if (v27)
    (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
  v28 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::Model(v28, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::LogOp::getAttributeNames(void)::attrNames, 1);
  v29 = (uint64_t)v54;
  v54 = 0;
  if (v29)
    (*(void (**)(uint64_t))(*(_QWORD *)v29 + 8))(v29);
  v30 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::Model(v30, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::MulOp::getAttributeNames(void)::attrNames, 1);
  v31 = (uint64_t)v54;
  v54 = 0;
  if (v31)
    (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
  v32 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::Model(v32, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::NegOp::getAttributeNames(void)::attrNames, 1);
  v33 = (uint64_t)v54;
  v54 = 0;
  if (v33)
    (*(void (**)(uint64_t))(*(_QWORD *)v33 + 8))(v33);
  v34 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::Model(v34, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, 0, 0);
  v35 = (uint64_t)v54;
  v54 = 0;
  if (v35)
    (*(void (**)(uint64_t))(*(_QWORD *)v35 + 8))(v35);
  v36 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::Model(v36, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::PowOp::getAttributeNames(void)::attrNames, 1);
  v37 = (uint64_t)v54;
  v54 = 0;
  if (v37)
    (*(void (**)(uint64_t))(*(_QWORD *)v37 + 8))(v37);
  v38 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::Model(v38, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::ReOp::getAttributeNames(void)::attrNames, 1);
  v39 = (uint64_t)v54;
  v54 = 0;
  if (v39)
    (*(void (**)(uint64_t))(*(_QWORD *)v39 + 8))(v39);
  v40 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::Model(v40, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::RsqrtOp::getAttributeNames(void)::attrNames, 1);
  v41 = (uint64_t)v54;
  v54 = 0;
  if (v41)
    (*(void (**)(uint64_t))(*(_QWORD *)v41 + 8))(v41);
  v42 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::Model(v42, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::SignOp::getAttributeNames(void)::attrNames, 1);
  v43 = (uint64_t)v54;
  v54 = 0;
  if (v43)
    (*(void (**)(uint64_t))(*(_QWORD *)v43 + 8))(v43);
  v44 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::Model(v44, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::SinOp::getAttributeNames(void)::attrNames, 1);
  v45 = (uint64_t)v54;
  v54 = 0;
  if (v45)
    (*(void (**)(uint64_t))(*(_QWORD *)v45 + 8))(v45);
  v46 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::Model(v46, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::SqrtOp::getAttributeNames(void)::attrNames, 1);
  v47 = (uint64_t)v54;
  v54 = 0;
  if (v47)
    (*(void (**)(uint64_t))(*(_QWORD *)v47 + 8))(v47);
  v48 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::Model(v48, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::SubOp::getAttributeNames(void)::attrNames, 1);
  v49 = (uint64_t)v54;
  v54 = 0;
  if (v49)
    (*(void (**)(uint64_t))(*(_QWORD *)v49 + 8))(v49);
  v50 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::Model(v50, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::TanOp::getAttributeNames(void)::attrNames, 1);
  v51 = (uint64_t)v54;
  v54 = 0;
  if (v51)
    (*(void (**)(uint64_t))(*(_QWORD *)v51 + 8))(v51);
  v52 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::Model(v52, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::TanhOp::getAttributeNames(void)::attrNames, 1);
  result = (uint64_t)v54;
  v54 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

mlir::GenericProgramPoint *mlir::complex::ComplexDialect::materializeConstant(uint64_t a1, mlir::OpBuilder *a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v10;
  uint64_t v11;

  v11 = a4;
  if (!mlir::complex::ConstantOp::isBuildableWith((uint64_t)a3, a4))
    return mlir::arith::ConstantOp::materialize(a2, a3, a4, a5);
  v10 = a3;
  return mlir::OpBuilder::create<mlir::complex::ConstantOp,mlir::Type &,mlir::ArrayAttr>(a2, a5, &v11, (uint64_t *)&v10);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::complex::ConstantOp,mlir::Type &,mlir::ArrayAttr>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"complex.constant", (const unsigned __int8 *)0x10, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"complex.constant";
    v17[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::complex::ConstantOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::ConstantOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

llvm::APFloatBase *mlir::complex::NumberAttr::get(uint64_t a1, double a2, double a3)
{
  llvm::APFloatBase *v5;
  void *v6;
  void *FloatSemantics;
  void *v8;
  mlir::MLIRContext *Context;
  llvm::APFloatBase *AttributeUniquer;
  llvm::APFloatBase *v11;
  void *v12;
  void *v13;
  char v15;
  uint64_t Value;
  uint64_t v17;
  _QWORD v18[3];
  _BYTE v19[8];
  _QWORD v20[3];
  _BYTE v21[8];
  _QWORD v22[4];

  v22[3] = *MEMORY[0x1E0C80C00];
  v17 = a1;
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v17);
  v5 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v19, a2);
  v6 = llvm::APFloatBase::IEEEdouble(v5);
  llvm::APFloat::Storage::Storage(v22, v19, v6);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v19);
  v15 = 0;
  FloatSemantics = mlir::FloatType::getFloatSemantics((llvm::APFloatBase *)&Value);
  llvm::APFloat::convert((uint64_t)v21, FloatSemantics, 1, &v15);
  llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v18, a3);
  llvm::APFloat::Storage::Storage(v20, v18, v6);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v18);
  v8 = mlir::FloatType::getFloatSemantics((llvm::APFloatBase *)&Value);
  llvm::APFloat::convert((uint64_t)v19, v8, 1, &v15);
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
  AttributeUniquer = (llvm::APFloatBase *)mlir::MLIRContext::getAttributeUniquer(Context);
  v18[0] = &mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id;
  v18[1] = Context;
  v11 = (llvm::APFloatBase *)mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir7complex6detail17NumberAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_10NumberAttrEJRNS_7APFloatESE_RNS1_11ComplexTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESJ_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSL_E_EEvlS5_, (uint64_t)v18, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id, (uint64_t)v21, (uint64_t)v19, &v17);
  v12 = (void *)v20[0];
  v13 = llvm::APFloatBase::PPCDoubleDouble(v11);
  if (v13 == v12)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v20);
    if (v13 != (void *)v22[0])
      goto LABEL_3;
LABEL_6:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v22);
    return v11;
  }
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v20);
  if (v13 == (void *)v22[0])
    goto LABEL_6;
LABEL_3:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v22);
  return v11;
}

llvm::APFloatBase *mlir::complex::ComplexDialect::parseAttribute(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  llvm::APFloatBase *v8;
  const void **v9;
  const void ***v10;
  char *v11;
  char *v12;
  __int128 v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void **v18;
  const char *v19;
  const void ***v20;
  char *v21;
  char *v22;
  __int128 v23;
  _QWORD **v24;
  _QWORD **v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  void *v30;
  void *v31;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  int64_t v36;
  int64_t v37;
  int64_t v38;
  char v39[32];
  __int16 v40;
  const void **v41;
  const char *v42;
  uint64_t v43;
  __int16 v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD **v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
  v45 = a2;
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
  BYTE2(v49) = 0;
  v47 = 0;
  v48 = 0;
  v46 = v5;
  LOBYTE(v49) = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a2 + 608))(a2, &v47))
  {
    LOWORD(v49) = 256;
    if (!BYTE2(v49))
      BYTE2(v49) = 1;
    goto LABEL_15;
  }
  v41 = (const void **)"number";
  v42 = (const char *)6;
  if (BYTE2(v49))
    goto LABEL_15;
  v6 = (const char *)v48;
  if (!v48)
  {
    (*(void (**)(uint64_t, const void ***, uint64_t))(*(_QWORD *)v45 + 616))(v45, &v41, 1);
    if (!BYTE2(v49))
    {
      v6 = (const char *)v48;
      goto LABEL_45;
    }
LABEL_15:
    v6 = 0;
    v9 = 0;
    v8 = 0;
    if ((unsigned __int16)mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::operator mlir::OptionalParseResult(&v45) > 0xFFu)
      return v8;
    goto LABEL_16;
  }
  if (v48 == (void *)6 && *(_DWORD *)v47 == 1651340654 && *(_WORD *)(v47 + 4) == 29285)
  {
    v8 = mlir::complex::NumberAttr::parse(a2);
    v6 = 0;
    v9 = 0;
    LOBYTE(v49) = v8 != 0;
    *(_WORD *)((char *)&v49 + 1) = 257;
    if ((unsigned __int16)mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::operator mlir::OptionalParseResult(&v45) > 0xFFu)
      return v8;
    goto LABEL_16;
  }
LABEL_45:
  v8 = 0;
  v9 = (const void **)v47;
  LOWORD(v49) = 0;
  BYTE2(v49) = 1;
  if ((unsigned __int16)mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::operator mlir::OptionalParseResult(&v45) > 0xFFu)
    return v8;
LABEL_16:
  v40 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)a2 + 24))(&v45, a2, v4, v39);
  if (v45)
  {
    LODWORD(v41) = 3;
    v43 = 19;
    v10 = &v41;
    v11 = (char *)v48;
    if (v49 >= v50)
    {
      v33 = v49 + 1;
      if (v48 <= &v41 && (char *)v48 + 24 * v49 > (char *)&v41)
      {
        v36 = (char *)&v41 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v33, 24);
        v11 = (char *)v48;
        v10 = (const void ***)((char *)v48 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v33, 24);
        v10 = &v41;
        v11 = (char *)v48;
      }
    }
    v12 = &v11[24 * v49];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = v10[2];
    *(_OWORD *)v12 = v13;
    ++v49;
    if (v45)
    {
      v44 = 261;
      v41 = v9;
      v42 = v6;
      mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
      if (v45)
      {
        LODWORD(v41) = 3;
        v43 = 14;
        v14 = &v41;
        v15 = (char *)v48;
        if (v49 >= v50)
        {
          v34 = v49 + 1;
          if (v48 <= &v41 && (char *)v48 + 24 * v49 > (char *)&v41)
          {
            v37 = (char *)&v41 - (_BYTE *)v48;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v34, 24);
            v15 = (char *)v48;
            v14 = (const void ***)((char *)v48 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v34, 24);
            v14 = &v41;
            v15 = (char *)v48;
          }
        }
        v16 = &v15[24 * v49];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = v14[2];
        *(_OWORD *)v16 = v17;
        ++v49;
        if (v45)
        {
          v18 = *(const void ***)(a1 + 8);
          v19 = *(const char **)(a1 + 16);
          v44 = 261;
          v41 = v18;
          v42 = v19;
          mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
          if (v45)
          {
            LODWORD(v41) = 3;
            v43 = 1;
            v20 = &v41;
            v21 = (char *)v48;
            if (v49 >= v50)
            {
              v35 = v49 + 1;
              if (v48 <= &v41 && (char *)v48 + 24 * v49 > (char *)&v41)
              {
                v38 = (char *)&v41 - (_BYTE *)v48;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
                v21 = (char *)v48;
                v20 = (const void ***)((char *)v48 + v38);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
                v20 = &v41;
                v21 = (char *)v48;
              }
            }
            v22 = &v21[24 * v49];
            v23 = *(_OWORD *)v20;
            *((_QWORD *)v22 + 2) = v20[2];
            *(_OWORD *)v22 = v23;
            ++v49;
            if (v45)
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
          }
        }
      }
    }
  }
  if (v56)
  {
    v24 = (_QWORD **)__p;
    if (__p)
    {
      v25 = v55;
      v26 = __p;
      if (v55 != __p)
      {
        do
          v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        v26 = __p;
      }
      v55 = v24;
      operator delete(v26);
    }
    v27 = v52;
    if (v52)
    {
      v28 = v53;
      v29 = v52;
      if (v53 != v52)
      {
        do
        {
          v31 = (void *)*--v28;
          v30 = v31;
          *v28 = 0;
          if (v31)
            operator delete[](v30);
        }
        while (v28 != v27);
        v29 = v52;
      }
      v53 = v27;
      operator delete(v29);
    }
    if (v48 != v51)
      free(v48);
  }
  return 0;
}

void mlir::complex::ComplexDialect::printAttribute(uint64_t a1, uint64_t a2, mlir::AsmPrinter *a3)
{
  llvm::raw_ostream *v4;
  uint64_t v5;
  uint64_t v6;

  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id)
  {
    v6 = a2;
    v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v5 = *((_QWORD *)v4 + 4);
    if ((unint64_t)(*((_QWORD *)v4 + 3) - v5) > 5)
    {
      *(_WORD *)(v5 + 4) = 29285;
      *(_DWORD *)v5 = 1651340654;
      *((_QWORD *)v4 + 4) += 6;
    }
    else
    {
      llvm::raw_ostream::write(v4, "number", 6uLL);
    }
    mlir::complex::NumberAttr::print((mlir::complex::NumberAttr *)&v6, a3);
  }
}

void mlir::complex::NumberAttr::print(mlir::complex::NumberAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _WORD *v5;
  uint64_t Value;
  llvm::raw_ostream *v7;
  _BYTE *v8;
  const llvm::detail::DoubleAPFloat *v9;
  void *v10;
  void *v11;
  llvm::raw_ostream *v12;
  _WORD *v13;
  const llvm::detail::DoubleAPFloat *v14;
  llvm::raw_ostream *v15;
  _BYTE *v16;
  uint64_t v17;
  _BYTE v18[8];
  _QWORD v19[3];
  _BYTE v20[8];
  _QWORD v21[4];

  v21[3] = *MEMORY[0x1E0C80C00];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_WORD *)*((_QWORD *)v4 + 4);
  if (*((_QWORD *)v4 + 3) - (_QWORD)v5 > 1uLL)
  {
    *v5 = 14908;
    *((_QWORD *)v4 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v4, "<:", 2uLL);
  }
  v17 = *(_QWORD *)(*(_QWORD *)this + 72);
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v17);
  (*(void (**)(mlir::AsmPrinter *, uint64_t))(*(_QWORD *)a2 + 32))(a2, Value);
  v7 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v8 = (_BYTE *)*((_QWORD *)v7 + 4);
  if (*((_BYTE **)v7 + 3) == v8)
  {
    v7 = llvm::raw_ostream::write(v7, " ", 1uLL);
  }
  else
  {
    *v8 = 32;
    ++*((_QWORD *)v7 + 4);
  }
  v9 = (const llvm::detail::DoubleAPFloat *)(*(_QWORD *)this + 16);
  v10 = *(void **)v9;
  v11 = llvm::APFloatBase::PPCDoubleDouble(v7);
  if (v11 == v10)
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v21, v9);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v21, v9);
  (*(void (**)(mlir::AsmPrinter *, _BYTE *))(*(_QWORD *)a2 + 24))(a2, v20);
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_WORD *)*((_QWORD *)v12 + 4);
  if (*((_QWORD *)v12 + 3) - (_QWORD)v13 > 1uLL)
  {
    *v13 = 8236;
    *((_QWORD *)v12 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v12, ", ", 2uLL);
  }
  v14 = (const llvm::detail::DoubleAPFloat *)(*(_QWORD *)this + 48);
  if (v11 == *(void **)v14)
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v19, v14);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v19, v14);
  (*(void (**)(mlir::AsmPrinter *, _BYTE *))(*(_QWORD *)a2 + 24))(a2, v18);
  v15 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v16 = (_BYTE *)*((_QWORD *)v15 + 4);
  if (*((_BYTE **)v15 + 3) != v16)
  {
    *v16 = 62;
    ++*((_QWORD *)v15 + 4);
    if (v11 != (void *)v19[0])
      goto LABEL_18;
LABEL_22:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v19);
    if (v11 != (void *)v21[0])
      goto LABEL_19;
LABEL_23:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v21);
    return;
  }
  llvm::raw_ostream::write(v15, ">", 1uLL);
  if (v11 == (void *)v19[0])
    goto LABEL_22;
LABEL_18:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v19);
  if (v11 == (void *)v21[0])
    goto LABEL_23;
LABEL_19:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v21);
}

llvm::APFloatBase *mlir::complex::NumberAttr::parse(uint64_t a1)
{
  uint64_t v2;
  double v4;
  double v5;
  uint64_t v6;

  v6 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v4 = 0.0;
  v5 = 0.0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 504))(a1, &v6)
    || !(*(unsigned __int8 (**)(uint64_t, double *))(*(_QWORD *)a1 + 344))(a1, &v5)
    || !(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1)
    || !(*(unsigned __int8 (**)(uint64_t, double *))(*(_QWORD *)a1 + 344))(a1, &v4)
    || !(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 168))(a1))
  {
    return 0;
  }
  v2 = mlir::ComplexType::get(v6);
  return mlir::complex::NumberAttr::get(v2, v5, v4);
}

mlir::arith::ArithDialect *llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::arith::ArithDialect * mlir::MLIRContext::getOrLoadDialect<mlir::arith::ArithDialect>(void)::{lambda(void)#1}>@<X0>(mlir::MLIRContext **a1@<X0>, mlir::arith::ArithDialect **a2@<X8>)
{
  mlir::MLIRContext *v3;
  mlir::arith::ArithDialect *v4;
  mlir::arith::ArithDialect *result;

  v3 = *a1;
  v4 = (mlir::arith::ArithDialect *)operator new(0x60uLL);
  result = mlir::arith::ArithDialect::ArithDialect(v4, v3);
  *a2 = result;
  return result;
}

uint64_t mlir::RegisteredOperationName::insert<mlir::complex::BitcastOp>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t result;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v2 = operator new(0x70uLL);
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::BitcastOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::BitcastOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"complex.bitcast", 15, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::BitcastOp,void>::id, (uint64_t)&v9);
  v3 = v9;
  if ((_DWORD)v10)
  {
    v4 = 16 * v10;
    v5 = (void **)((char *)v9 + 8);
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v3 = v9;
  }
  if (v3 != v11)
    free(v3);
  *v2 = &unk_1E0E47320;
  v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  result = (uint64_t)v8;
  v8 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t mlir::RegisteredOperationName::insert<mlir::complex::CreateOp>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t result;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v2 = operator new(0x70uLL);
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CreateOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CreateOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"complex.create", 14, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::CreateOp,void>::id, (uint64_t)&v9);
  v3 = v9;
  if ((_DWORD)v10)
  {
    v4 = 16 * v10;
    v5 = (void **)((char *)v9 + 8);
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v3 = v9;
  }
  if (v3 != v11)
    free(v3);
  *v2 = &unk_1E0E47258;
  v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  result = (uint64_t)v8;
  v8 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AbsOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.abs", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::AbsOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E46128;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::AbsOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AbsOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AbsOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AbsOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AbsOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AbsOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.abs";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  __guard *v8;
  __guard v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **p_vtable;
  void *v21;
  unsigned __int8 v22;
  void **v23;
  void *v24;
  unsigned __int8 v25;
  void **v26;
  void *v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  __guard *v32;
  __guard v33;
  unsigned __int8 v34;
  __guard *v35;
  __guard v36;
  unsigned __int8 v37;
  uint64_t *v38;
  int v52;
  int v53;
  unint64_t v54;
  unint64_t v55;
  const char *v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  unint64_t v63;
  unint64_t v64;
  const char *v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  int v70;
  int v71;
  unint64_t v72;
  unint64_t v73;
  const char *v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  unint64_t v81;
  unint64_t v82;
  const char *v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  int v88;
  int v89;
  unint64_t v90;
  unint64_t v91;
  const char *v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  unint64_t v99;
  unint64_t v100;
  const char *v101;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  int v106;
  int v107;
  unint64_t v108;
  unint64_t v109;
  const char *v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  int v115;
  int v116;
  unint64_t v117;
  unint64_t v118;
  const char *v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  int v124;
  int v125;
  unint64_t v126;
  unint64_t v127;
  const char *v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t v132;
  int v133;
  int v134;
  unint64_t v135;
  unint64_t v136;
  const char *v137;
  unint64_t v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  int v142;
  int v143;
  unint64_t v144;
  unint64_t v145;
  const char *v146;
  unint64_t v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  int v151;
  int v152;
  unint64_t v153;
  unint64_t v154;
  const char *v155;
  unint64_t v156;
  uint64_t v157;
  unint64_t v158;
  uint64_t v159;
  int v160;
  int v161;
  unint64_t v162;
  unint64_t v163;
  const char *v164;
  unint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  __guard v169;
  __guard v170;
  __guard v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  void *v179;
  void *v180;
  void *v181;
  void *v182;
  void *v183;
  void *v184;
  void *v185;
  void *v186;
  void *v187;
  void *v188;
  void *v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  __guard v214;
  __guard v215;
  __guard v216;
  __guard v217;
  __guard v218;
  __guard v219;
  __guard v220;
  __guard v221;
  __guard v222;
  __guard v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  void *v247;
  void *v248;
  void *v249;
  void *v250;
  void *v251;
  void *v252;
  void *v253;
  void *v254;
  void *v255;
  void *v256;
  void *v257;
  void *v258;
  void *v259;
  const char *v260;
  unint64_t v261;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v247 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v53 = v52;
    a1 = v247;
    if (v53)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v261 = 83;
      v54 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v54)
        v55 = v54;
      else
        v55 = v261;
      v56 = &v260[v55];
      v57 = v261 - v55;
      if (v261 - v55 >= 0x12)
        v58 = 18;
      else
        v58 = v261 - v55;
      v59 = v57 - v58;
      if (v59 >= v59 - 1)
        v60 = v59 - 1;
      else
        v60 = v59;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v56[v58], v60);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v247;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v235 = v3;
    v248 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v62 = v61;
    v3 = v235;
    a1 = v248;
    if (v62)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v261 = 81;
      v63 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v63)
        v64 = v63;
      else
        v64 = v261;
      v65 = &v260[v64];
      v66 = v261 - v64;
      if (v261 - v64 >= 0x12)
        v67 = 18;
      else
        v67 = v261 - v64;
      v68 = v66 - v67;
      if (v68 >= v68 - 1)
        v69 = v68 - 1;
      else
        v69 = v68;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v65[v67], v69);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v235;
      a1 = v248;
    }
  }
  v6 = v5[211];
  if ((v7 & 1) == 0)
  {
    v236 = v3;
    v249 = a1;
    v224 = v6;
    v6 = v224;
    v3 = v236;
    v71 = v70;
    a1 = v249;
    if (v71)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl<Empty>]";
      v261 = 109;
      v72 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v72)
        v73 = v72;
      else
        v73 = v261;
      v74 = &v260[v73];
      v75 = v261 - v73;
      if (v261 - v73 >= 0x12)
        v76 = 18;
      else
        v76 = v261 - v73;
      v77 = v75 - v76;
      if (v77 >= v77 - 1)
        v78 = v77 - 1;
      else
        v78 = v77;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v74[v76], v78);
      v6 = v224;
      v3 = v236;
      a1 = v249;
    }
  }
  v9 = v8[359];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v237 = v3;
    v250 = a1;
    v214 = v9;
    v225 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v214;
    v6 = v225;
    v80 = v79;
    v3 = v237;
    a1 = v250;
    if (v80)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v261 = 86;
      v81 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v81)
        v82 = v81;
      else
        v82 = v261;
      v83 = &v260[v82];
      v84 = v261 - v82;
      if (v261 - v82 >= 0x12)
        v85 = 18;
      else
        v85 = v261 - v82;
      v86 = v84 - v85;
      if (v86 >= v86 - 1)
        v87 = v86 - 1;
      else
        v87 = v86;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v83[v85], v87);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v214;
      v6 = v225;
      v3 = v237;
      a1 = v250;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v238 = v3;
    v251 = a1;
    v215 = v9;
    v226 = v6;
    v205 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v205;
    v9 = v215;
    v6 = v226;
    v89 = v88;
    v3 = v238;
    a1 = v251;
    if (v89)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v261 = 82;
      v90 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v90)
        v91 = v90;
      else
        v91 = v261;
      v92 = &v260[v91];
      v93 = v261 - v91;
      if (v261 - v91 >= 0x12)
        v94 = 18;
      else
        v94 = v261 - v91;
      v95 = v93 - v94;
      if (v95 >= v95 - 1)
        v96 = v95 - 1;
      else
        v96 = v95;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v92[v94], v96);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v205;
      v9 = v215;
      v6 = v226;
      v3 = v238;
      a1 = v251;
    }
  }
  v15 = v14[181];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v239 = v3;
    v252 = a1;
    v216 = v9;
    v227 = v6;
    v197 = v15;
    v206 = v12;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v197;
    v12 = v206;
    v9 = v216;
    v6 = v227;
    v98 = v97;
    v3 = v239;
    a1 = v252;
    if (v98)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v261 = 84;
      v99 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v99)
        v100 = v99;
      else
        v100 = v261;
      v101 = &v260[v100];
      v102 = v261 - v100;
      if (v261 - v100 >= 0x12)
        v103 = 18;
      else
        v103 = v261 - v100;
      v104 = v102 - v103;
      if (v104 >= v104 - 1)
        v105 = v104 - 1;
      else
        v105 = v104;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v101[v103], v105);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v197;
      v12 = v206;
      v9 = v216;
      v6 = v227;
      v3 = v239;
      a1 = v252;
    }
  }
  v18 = v17[192];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v240 = v3;
    v253 = a1;
    v217 = v9;
    v228 = v6;
    v198 = v15;
    v207 = v12;
    v190 = v18;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v190;
    v15 = v198;
    v12 = v207;
    v9 = v217;
    v6 = v228;
    v107 = v106;
    v3 = v240;
    a1 = v253;
    if (v107)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v261 = 89;
      v108 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v108)
        v109 = v108;
      else
        v109 = v261;
      v110 = &v260[v109];
      v111 = v261 - v109;
      if (v261 - v109 >= 0x12)
        v112 = 18;
      else
        v112 = v261 - v109;
      v113 = v111 - v112;
      if (v113 >= v113 - 1)
        v114 = v113 - 1;
      else
        v114 = v113;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v110[v112], v114);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v190;
      v15 = v198;
      v12 = v207;
      v9 = v217;
      v6 = v228;
      v3 = v240;
      a1 = v253;
    }
  }
  v21 = p_vtable[481];
  v23 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v22 & 1) == 0)
  {
    v241 = v3;
    v254 = a1;
    v218 = v9;
    v229 = v6;
    v199 = v15;
    v208 = v12;
    v184 = v21;
    v191 = v18;
    v23 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v21 = v184;
    v18 = v191;
    v15 = v199;
    v12 = v208;
    v9 = v218;
    v6 = v229;
    v116 = v115;
    v3 = v241;
    a1 = v254;
    if (v116)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v261 = 95;
      v117 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v117)
        v118 = v117;
      else
        v118 = v261;
      v119 = &v260[v118];
      v120 = v261 - v118;
      if (v261 - v118 >= 0x12)
        v121 = 18;
      else
        v121 = v261 - v118;
      v122 = v120 - v121;
      if (v122 >= v122 - 1)
        v123 = v122 - 1;
      else
        v123 = v122;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v119[v121], v123);
      v23 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v21 = v184;
      v18 = v191;
      v15 = v199;
      v12 = v208;
      v9 = v218;
      v6 = v229;
      v3 = v241;
      a1 = v254;
    }
  }
  v24 = v23[486];
  v26 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v25 & 1) == 0)
  {
    v242 = v3;
    v255 = a1;
    v219 = v9;
    v230 = v6;
    v200 = v15;
    v209 = v12;
    v185 = v21;
    v192 = v18;
    v179 = v24;
    v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v24 = v179;
    v21 = v185;
    v18 = v192;
    v15 = v200;
    v12 = v209;
    v9 = v219;
    v6 = v230;
    v125 = v124;
    v3 = v242;
    a1 = v255;
    if (v125)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v261 = 99;
      v126 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v126)
        v127 = v126;
      else
        v127 = v261;
      v128 = &v260[v127];
      v129 = v261 - v127;
      if (v261 - v127 >= 0x12)
        v130 = 18;
      else
        v130 = v261 - v127;
      v131 = v129 - v130;
      if (v131 >= v131 - 1)
        v132 = v131 - 1;
      else
        v132 = v131;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v128[v130], v132);
      v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v24 = v179;
      v21 = v185;
      v18 = v192;
      v15 = v200;
      v12 = v209;
      v9 = v219;
      v6 = v230;
      v3 = v242;
      a1 = v255;
    }
  }
  v27 = v26[504];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v243 = v3;
    v256 = a1;
    v220 = v9;
    v231 = v6;
    v201 = v15;
    v210 = v12;
    v186 = v21;
    v193 = v18;
    v175 = v27;
    v180 = v24;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v175;
    v24 = v180;
    v21 = v186;
    v18 = v193;
    v15 = v201;
    v12 = v210;
    v9 = v220;
    v6 = v231;
    v134 = v133;
    v3 = v243;
    a1 = v256;
    if (v134)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v261 = 93;
      v135 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v135)
        v136 = v135;
      else
        v136 = v261;
      v137 = &v260[v136];
      v138 = v261 - v136;
      if (v261 - v136 >= 0x12)
        v139 = 18;
      else
        v139 = v261 - v136;
      v140 = v138 - v139;
      if (v140 >= v140 - 1)
        v141 = v140 - 1;
      else
        v141 = v140;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v137[v139], v141);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v175;
      v24 = v180;
      v21 = v186;
      v18 = v193;
      v15 = v201;
      v12 = v210;
      v9 = v220;
      v6 = v231;
      v3 = v243;
      a1 = v256;
    }
  }
  v30 = v29[158];
  if ((v31 & 1) == 0)
  {
    v244 = v3;
    v257 = a1;
    v221 = v9;
    v232 = v6;
    v202 = v15;
    v211 = v12;
    v187 = v21;
    v194 = v18;
    v176 = v27;
    v181 = v24;
    v172 = v30;
    v30 = v172;
    v27 = v176;
    v24 = v181;
    v21 = v187;
    v18 = v194;
    v15 = v202;
    v12 = v211;
    v9 = v221;
    v6 = v232;
    v143 = v142;
    v3 = v244;
    a1 = v257;
    if (v143)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Elementwise<Empty>]";
      v261 = 83;
      v144 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v144)
        v145 = v144;
      else
        v145 = v261;
      v146 = &v260[v145];
      v147 = v261 - v145;
      if (v261 - v145 >= 0x12)
        v148 = 18;
      else
        v148 = v261 - v145;
      v149 = v147 - v148;
      if (v149 >= v149 - 1)
        v150 = v149 - 1;
      else
        v150 = v149;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Elementwise<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Elementwise>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v146[v148], v150);
      v30 = v172;
      v27 = v176;
      v24 = v181;
      v21 = v187;
      v18 = v194;
      v15 = v202;
      v12 = v211;
      v9 = v221;
      v6 = v232;
      v3 = v244;
      a1 = v257;
    }
  }
  v33 = v32[220];
  if ((v34 & 1) == 0)
  {
    v245 = v3;
    v258 = a1;
    v222 = v9;
    v233 = v6;
    v203 = v15;
    v212 = v12;
    v188 = v21;
    v195 = v18;
    v177 = v27;
    v182 = v24;
    v170 = v33;
    v173 = v30;
    v33 = v170;
    v30 = v173;
    v27 = v177;
    v24 = v182;
    v21 = v188;
    v18 = v195;
    v15 = v203;
    v12 = v212;
    v9 = v222;
    v6 = v233;
    v152 = v151;
    v3 = v245;
    a1 = v258;
    if (v152)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface::Trait<Empty>]";
      v261 = 99;
      v153 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v153)
        v154 = v153;
      else
        v154 = v261;
      v155 = &v260[v154];
      v156 = v261 - v154;
      if (v261 - v154 >= 0x12)
        v157 = 18;
      else
        v157 = v261 - v154;
      v158 = v156 - v157;
      if (v158 >= v158 - 1)
        v159 = v158 - 1;
      else
        v159 = v158;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::arith::ArithFastMathInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v155[v157], v159);
      v33 = v170;
      v30 = v173;
      v27 = v177;
      v24 = v182;
      v21 = v188;
      v18 = v195;
      v15 = v203;
      v12 = v212;
      v9 = v222;
      v6 = v233;
      v3 = v245;
      a1 = v258;
    }
  }
  v36 = v35[216];
  v38 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v37 & 1) == 0)
  {
    v246 = v3;
    v259 = a1;
    v223 = v9;
    v234 = v6;
    v204 = v15;
    v213 = v12;
    v189 = v21;
    v196 = v18;
    v178 = v27;
    v183 = v24;
    v171 = v33;
    v174 = v30;
    v169 = v36;
    v38 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v36 = v169;
    v33 = v171;
    v30 = v174;
    v27 = v178;
    v24 = v183;
    v21 = v189;
    v18 = v196;
    v15 = v204;
    v12 = v213;
    v9 = v223;
    v6 = v234;
    v161 = v160;
    v3 = v246;
    a1 = v259;
    if (v161)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v261 = 90;
      v162 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v162)
        v163 = v162;
      else
        v163 = v261;
      v164 = &v260[v163];
      v165 = v261 - v163;
      if (v261 - v163 >= 0x12)
        v166 = 18;
      else
        v166 = v261 - v163;
      v167 = v165 - v166;
      if (v167 >= v167 - 1)
        v168 = v167 - 1;
      else
        v168 = v167;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v164[v166], v168);
      v38 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v36 = v169;
      v33 = v171;
      v30 = v174;
      v27 = v178;
      v24 = v183;
      v21 = v189;
      v18 = v196;
      v15 = v204;
      v12 = v213;
      v9 = v223;
      v6 = v234;
      v3 = v246;
      a1 = v259;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == (_QWORD)a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == (_QWORD)a1
      || v33 == (_QWORD)a1
      || v36 == (_QWORD)a1
      || v38[152] == (_QWORD)a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v8 = a1, mlir::complex::AbsOp::verifyInvariantsImpl((uint64_t **)&v8)))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AddOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.add", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::AddOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E461F0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::AddOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AddOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AddOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AddOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AddOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AddOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.add";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  mlir::complex::detail::AddOpGenericAdaptorBase::AddOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::AddOp::fold(&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  __guard *v8;
  __guard v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **p_vtable;
  void *v21;
  unsigned __int8 v22;
  void **v23;
  void *v24;
  unsigned __int8 v25;
  void **v26;
  void *v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  uint64_t v33;
  unsigned __int8 v34;
  __guard *v35;
  __guard v36;
  unsigned __int8 v37;
  __guard *v38;
  __guard v39;
  unsigned __int8 v40;
  uint64_t *v41;
  int v56;
  int v57;
  unint64_t v58;
  unint64_t v59;
  const char *v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  int v65;
  int v66;
  unint64_t v67;
  unint64_t v68;
  const char *v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  int v74;
  int v75;
  unint64_t v76;
  unint64_t v77;
  const char *v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  int v83;
  int v84;
  unint64_t v85;
  unint64_t v86;
  const char *v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  int v92;
  int v93;
  unint64_t v94;
  unint64_t v95;
  const char *v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  int v101;
  int v102;
  unint64_t v103;
  unint64_t v104;
  const char *v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  int v110;
  int v111;
  unint64_t v112;
  unint64_t v113;
  const char *v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  int v119;
  int v120;
  unint64_t v121;
  unint64_t v122;
  const char *v123;
  unint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  int v128;
  int v129;
  unint64_t v130;
  unint64_t v131;
  const char *v132;
  unint64_t v133;
  uint64_t v134;
  unint64_t v135;
  uint64_t v136;
  int v137;
  int v138;
  unint64_t v139;
  unint64_t v140;
  const char *v141;
  unint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  int v146;
  int v147;
  unint64_t v148;
  unint64_t v149;
  const char *v150;
  unint64_t v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t v154;
  int v155;
  int v156;
  unint64_t v157;
  unint64_t v158;
  const char *v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  int v164;
  int v165;
  unint64_t v166;
  unint64_t v167;
  const char *v168;
  unint64_t v169;
  uint64_t v170;
  unint64_t v171;
  uint64_t v172;
  int v173;
  int v174;
  unint64_t v175;
  unint64_t v176;
  const char *v177;
  unint64_t v178;
  uint64_t v179;
  unint64_t v180;
  uint64_t v181;
  __guard v182;
  __guard v183;
  __guard v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  void *v192;
  void *v193;
  void *v194;
  void *v195;
  void *v196;
  void *v197;
  void *v198;
  void *v199;
  void *v200;
  void *v201;
  void *v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  void *v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  __guard v237;
  __guard v238;
  __guard v239;
  __guard v240;
  __guard v241;
  __guard v242;
  __guard v243;
  __guard v244;
  __guard v245;
  __guard v246;
  __guard v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  void *v273;
  void *v274;
  void *v275;
  void *v276;
  void *v277;
  void *v278;
  void *v279;
  void *v280;
  void *v281;
  void *v282;
  void *v283;
  void *v284;
  void *v285;
  void *v286;
  const char *v287;
  unint64_t v288;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v273 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v57 = v56;
    a1 = v273;
    if (v57)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v288 = 83;
      v58 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v58)
        v59 = v58;
      else
        v59 = v288;
      v60 = &v287[v59];
      v61 = v288 - v59;
      if (v288 - v59 >= 0x12)
        v62 = 18;
      else
        v62 = v288 - v59;
      v63 = v61 - v62;
      if (v63 >= v63 - 1)
        v64 = v63 - 1;
      else
        v64 = v63;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v60[v62], v64);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v273;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v260 = v3;
    v274 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v66 = v65;
    v3 = v260;
    a1 = v274;
    if (v66)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v288 = 81;
      v67 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v67)
        v68 = v67;
      else
        v68 = v288;
      v69 = &v287[v68];
      v70 = v288 - v68;
      if (v288 - v68 >= 0x12)
        v71 = 18;
      else
        v71 = v288 - v68;
      v72 = v70 - v71;
      if (v72 >= v72 - 1)
        v73 = v72 - 1;
      else
        v73 = v72;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v69[v71], v73);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v260;
      a1 = v274;
    }
  }
  v6 = v5[211];
  if ((v7 & 1) == 0)
  {
    v261 = v3;
    v275 = a1;
    v248 = v6;
    v6 = v248;
    v3 = v261;
    v75 = v74;
    a1 = v275;
    if (v75)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<Empty>]";
      v288 = 111;
      v76 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v76)
        v77 = v76;
      else
        v77 = v288;
      v78 = &v287[v77];
      v79 = v288 - v77;
      if (v288 - v77 >= 0x12)
        v80 = 18;
      else
        v80 = v288 - v77;
      v81 = v79 - v80;
      if (v81 >= v81 - 1)
        v82 = v81 - 1;
      else
        v82 = v81;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v78[v80], v82);
      v6 = v248;
      v3 = v261;
      a1 = v275;
    }
  }
  v9 = v8[363];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v262 = v3;
    v276 = a1;
    v237 = v9;
    v249 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v237;
    v6 = v249;
    v84 = v83;
    v3 = v262;
    a1 = v276;
    if (v84)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v288 = 86;
      v85 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v85)
        v86 = v85;
      else
        v86 = v288;
      v87 = &v287[v86];
      v88 = v288 - v86;
      if (v288 - v86 >= 0x12)
        v89 = 18;
      else
        v89 = v288 - v86;
      v90 = v88 - v89;
      if (v90 >= v90 - 1)
        v91 = v90 - 1;
      else
        v91 = v90;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v87[v89], v91);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v237;
      v6 = v249;
      v3 = v262;
      a1 = v276;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v263 = v3;
    v277 = a1;
    v238 = v9;
    v250 = v6;
    v227 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v227;
    v9 = v238;
    v6 = v250;
    v93 = v92;
    v3 = v263;
    a1 = v277;
    if (v93)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v288 = 90;
      v94 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v94)
        v95 = v94;
      else
        v95 = v288;
      v96 = &v287[v95];
      v97 = v288 - v95;
      if (v288 - v95 >= 0x12)
        v98 = 18;
      else
        v98 = v288 - v95;
      v99 = v97 - v98;
      if (v99 >= v99 - 1)
        v100 = v99 - 1;
      else
        v100 = v99;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v96[v98], v100);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v227;
      v9 = v238;
      v6 = v250;
      v3 = v263;
      a1 = v277;
    }
  }
  v15 = v14[208];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v264 = v3;
    v278 = a1;
    v239 = v9;
    v251 = v6;
    v218 = v15;
    v228 = v12;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v218;
    v12 = v228;
    v9 = v239;
    v6 = v251;
    v102 = v101;
    v3 = v264;
    a1 = v278;
    if (v102)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v288 = 84;
      v103 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v103)
        v104 = v103;
      else
        v104 = v288;
      v105 = &v287[v104];
      v106 = v288 - v104;
      if (v288 - v104 >= 0x12)
        v107 = 18;
      else
        v107 = v288 - v104;
      v108 = v106 - v107;
      if (v108 >= v108 - 1)
        v109 = v108 - 1;
      else
        v109 = v108;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v105[v107], v109);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v218;
      v12 = v228;
      v9 = v239;
      v6 = v251;
      v3 = v264;
      a1 = v278;
    }
  }
  v18 = v17[192];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v265 = v3;
    v279 = a1;
    v240 = v9;
    v252 = v6;
    v219 = v15;
    v229 = v12;
    v210 = v18;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v210;
    v15 = v219;
    v12 = v229;
    v9 = v240;
    v6 = v252;
    v111 = v110;
    v3 = v265;
    a1 = v279;
    if (v111)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v288 = 89;
      v112 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v112)
        v113 = v112;
      else
        v113 = v288;
      v114 = &v287[v113];
      v115 = v288 - v113;
      if (v288 - v113 >= 0x12)
        v116 = 18;
      else
        v116 = v288 - v113;
      v117 = v115 - v116;
      if (v117 >= v117 - 1)
        v118 = v117 - 1;
      else
        v118 = v117;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v114[v116], v118);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v210;
      v15 = v219;
      v12 = v229;
      v9 = v240;
      v6 = v252;
      v3 = v265;
      a1 = v279;
    }
  }
  v21 = p_vtable[481];
  v23 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v22 & 1) == 0)
  {
    v266 = v3;
    v280 = a1;
    v241 = v9;
    v253 = v6;
    v220 = v15;
    v230 = v12;
    v203 = v21;
    v211 = v18;
    v23 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v21 = v203;
    v18 = v211;
    v15 = v220;
    v12 = v230;
    v9 = v241;
    v6 = v253;
    v120 = v119;
    v3 = v266;
    a1 = v280;
    if (v120)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v288 = 95;
      v121 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v121)
        v122 = v121;
      else
        v122 = v288;
      v123 = &v287[v122];
      v124 = v288 - v122;
      if (v288 - v122 >= 0x12)
        v125 = 18;
      else
        v125 = v288 - v122;
      v126 = v124 - v125;
      if (v126 >= v126 - 1)
        v127 = v126 - 1;
      else
        v127 = v126;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v123[v125], v127);
      v23 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v21 = v203;
      v18 = v211;
      v15 = v220;
      v12 = v230;
      v9 = v241;
      v6 = v253;
      v3 = v266;
      a1 = v280;
    }
  }
  v24 = v23[486];
  v26 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v25 & 1) == 0)
  {
    v267 = v3;
    v281 = a1;
    v242 = v9;
    v254 = v6;
    v221 = v15;
    v231 = v12;
    v204 = v21;
    v212 = v18;
    v197 = v24;
    v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v24 = v197;
    v21 = v204;
    v18 = v212;
    v15 = v221;
    v12 = v231;
    v9 = v242;
    v6 = v254;
    v129 = v128;
    v3 = v267;
    a1 = v281;
    if (v129)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v288 = 99;
      v130 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v130)
        v131 = v130;
      else
        v131 = v288;
      v132 = &v287[v131];
      v133 = v288 - v131;
      if (v288 - v131 >= 0x12)
        v134 = 18;
      else
        v134 = v288 - v131;
      v135 = v133 - v134;
      if (v135 >= v135 - 1)
        v136 = v135 - 1;
      else
        v136 = v135;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v132[v134], v136);
      v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v24 = v197;
      v21 = v204;
      v18 = v212;
      v15 = v221;
      v12 = v231;
      v9 = v242;
      v6 = v254;
      v3 = v267;
      a1 = v281;
    }
  }
  v27 = v26[504];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v268 = v3;
    v282 = a1;
    v243 = v9;
    v255 = v6;
    v222 = v15;
    v232 = v12;
    v205 = v21;
    v213 = v18;
    v192 = v27;
    v198 = v24;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v192;
    v24 = v198;
    v21 = v205;
    v18 = v213;
    v15 = v222;
    v12 = v232;
    v9 = v243;
    v6 = v255;
    v138 = v137;
    v3 = v268;
    a1 = v282;
    if (v138)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v288 = 93;
      v139 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v139)
        v140 = v139;
      else
        v140 = v288;
      v141 = &v287[v140];
      v142 = v288 - v140;
      if (v288 - v140 >= 0x12)
        v143 = 18;
      else
        v143 = v288 - v140;
      v144 = v142 - v143;
      if (v144 >= v144 - 1)
        v145 = v144 - 1;
      else
        v145 = v144;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v141[v143], v145);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v192;
      v24 = v198;
      v21 = v205;
      v18 = v213;
      v15 = v222;
      v12 = v232;
      v9 = v243;
      v6 = v255;
      v3 = v268;
      a1 = v282;
    }
  }
  v30 = v29[158];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v269 = v3;
    v283 = a1;
    v244 = v9;
    v256 = v6;
    v223 = v15;
    v233 = v12;
    v206 = v21;
    v214 = v18;
    v193 = v27;
    v199 = v24;
    v188 = v30;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v188;
    v27 = v193;
    v24 = v199;
    v21 = v206;
    v18 = v214;
    v15 = v223;
    v12 = v233;
    v9 = v244;
    v6 = v256;
    v147 = v146;
    v3 = v269;
    a1 = v283;
    if (v147)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultType<Empty>]";
      v288 = 97;
      v148 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v148)
        v149 = v148;
      else
        v149 = v288;
      v150 = &v287[v149];
      v151 = v288 - v149;
      if (v288 - v149 >= 0x12)
        v152 = 18;
      else
        v152 = v288 - v149;
      v153 = v151 - v152;
      if (v153 >= v153 - 1)
        v154 = v153 - 1;
      else
        v154 = v153;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v150[v152], v154);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v188;
      v27 = v193;
      v24 = v199;
      v21 = v206;
      v18 = v214;
      v15 = v223;
      v12 = v233;
      v9 = v244;
      v6 = v256;
      v3 = v269;
      a1 = v283;
    }
  }
  v33 = v32[205];
  if ((v34 & 1) == 0)
  {
    v270 = v3;
    v284 = a1;
    v245 = v9;
    v257 = v6;
    v224 = v15;
    v234 = v12;
    v207 = v21;
    v215 = v18;
    v194 = v27;
    v200 = v24;
    v185 = v33;
    v189 = v30;
    v33 = v185;
    v30 = v189;
    v27 = v194;
    v24 = v200;
    v21 = v207;
    v18 = v215;
    v15 = v224;
    v12 = v234;
    v9 = v245;
    v6 = v257;
    v156 = v155;
    v3 = v270;
    a1 = v284;
    if (v156)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Elementwise<Empty>]";
      v288 = 83;
      v157 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v157)
        v158 = v157;
      else
        v158 = v288;
      v159 = &v287[v158];
      v160 = v288 - v158;
      if (v288 - v158 >= 0x12)
        v161 = 18;
      else
        v161 = v288 - v158;
      v162 = v160 - v161;
      if (v162 >= v162 - 1)
        v163 = v162 - 1;
      else
        v163 = v162;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Elementwise<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Elementwise>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v159[v161], v163);
      v33 = v185;
      v30 = v189;
      v27 = v194;
      v24 = v200;
      v21 = v207;
      v18 = v215;
      v15 = v224;
      v12 = v234;
      v9 = v245;
      v6 = v257;
      v3 = v270;
      a1 = v284;
    }
  }
  v36 = v35[220];
  if ((v37 & 1) == 0)
  {
    v271 = v3;
    v285 = a1;
    v246 = v9;
    v258 = v6;
    v225 = v15;
    v235 = v12;
    v208 = v21;
    v216 = v18;
    v195 = v27;
    v201 = v24;
    v186 = v33;
    v190 = v30;
    v183 = v36;
    v36 = v183;
    v33 = v186;
    v30 = v190;
    v27 = v195;
    v24 = v201;
    v21 = v208;
    v18 = v216;
    v15 = v225;
    v12 = v235;
    v9 = v246;
    v6 = v258;
    v165 = v164;
    v3 = v271;
    a1 = v285;
    if (v165)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface::Trait<Empty>]";
      v288 = 99;
      v166 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v166)
        v167 = v166;
      else
        v167 = v288;
      v168 = &v287[v167];
      v169 = v288 - v167;
      if (v288 - v167 >= 0x12)
        v170 = 18;
      else
        v170 = v288 - v167;
      v171 = v169 - v170;
      if (v171 >= v171 - 1)
        v172 = v171 - 1;
      else
        v172 = v171;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::arith::ArithFastMathInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v168[v170], v172);
      v36 = v183;
      v33 = v186;
      v30 = v190;
      v27 = v195;
      v24 = v201;
      v21 = v208;
      v18 = v216;
      v15 = v225;
      v12 = v235;
      v9 = v246;
      v6 = v258;
      v3 = v271;
      a1 = v285;
    }
  }
  v39 = v38[216];
  v41 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v40 & 1) == 0)
  {
    v272 = v3;
    v286 = a1;
    v247 = v9;
    v259 = v6;
    v226 = v15;
    v236 = v12;
    v209 = v21;
    v217 = v18;
    v196 = v27;
    v202 = v24;
    v187 = v33;
    v191 = v30;
    v182 = v39;
    v184 = v36;
    v41 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v39 = v182;
    v36 = v184;
    v33 = v187;
    v30 = v191;
    v27 = v196;
    v24 = v202;
    v21 = v209;
    v18 = v217;
    v15 = v226;
    v12 = v236;
    v9 = v247;
    v6 = v259;
    v174 = v173;
    v3 = v272;
    a1 = v286;
    if (v174)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v288 = 90;
      v175 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v175)
        v176 = v175;
      else
        v176 = v288;
      v177 = &v287[v176];
      v178 = v288 - v176;
      if (v288 - v176 >= 0x12)
        v179 = 18;
      else
        v179 = v288 - v176;
      v180 = v178 - v179;
      if (v180 >= v180 - 1)
        v181 = v180 - 1;
      else
        v181 = v180;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v177[v179], v181);
      v41 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v39 = v182;
      v36 = v184;
      v33 = v187;
      v30 = v191;
      v27 = v196;
      v24 = v202;
      v21 = v209;
      v18 = v217;
      v15 = v226;
      v12 = v236;
      v9 = v247;
      v6 = v259;
      v3 = v272;
      a1 = v286;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == (_QWORD)a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == (_QWORD)a1
      || v33 == (_QWORD)a1
      || v36 == (_QWORD)a1
      || v39 == (_QWORD)a1
      || v41[152] == (_QWORD)a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (v8 = a1, mlir::complex::AddOp::verifyInvariantsImpl((uint64_t **)&v8))
    && mlir::OpTrait::impl::verifySameOperandsAndResultType(a1, v5))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AngleOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.angle", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::AngleOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E46DA8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::AngleOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AngleOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AngleOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AngleOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AngleOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AngleOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.angle";
  v16[1] = 13;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v8 = a1, mlir::complex::AbsOp::verifyInvariantsImpl((uint64_t **)&v8)))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Atan2Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.atan2", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::Atan2Op,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E46E70;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::Atan2Op::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Atan2Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Atan2Op>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Atan2Op>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Atan2Op>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Atan2Op>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.atan2";
  v16[1] = 13;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

void mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::complex::BitcastOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::BitcastOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::BitcastOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::BitcastOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::BitcastOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::BitcastOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::BitcastOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::BitcastOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int *v13;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  mlir::complex::detail::BitcastOpGenericAdaptorBase::BitcastOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::BitcastOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 4 == (unsigned int *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::BitcastOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneOperand(a1, v5))
    return 0;
  v7 = a1;
  if (!mlir::complex::BitcastOp::verifyInvariantsImpl((mlir::complex::BitcastOp *)&v7))
    return 0;
  v7 = a1;
  return mlir::complex::BitcastOp::verify((uint64_t **)&v7) != 0;
}

uint64_t mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConjOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.conj", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ConjOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E46A88;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::ConjOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConjOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConjOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConjOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ConjOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ConjOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.conj";
  v16[1] = 12;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  mlir::complex::detail::ConjOpGenericAdaptorBase::ConjOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::ConjOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  __guard *v8;
  __guard v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **p_vtable;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  void **v26;
  void *v27;
  unsigned __int8 v28;
  void **v29;
  void *v30;
  unsigned __int8 v31;
  uint64_t *v32;
  uint64_t v33;
  unsigned __int8 v34;
  __guard *v35;
  __guard v36;
  unsigned __int8 v37;
  __guard *v38;
  __guard v39;
  unsigned __int8 v40;
  uint64_t *v41;
  int v56;
  int v57;
  unint64_t v58;
  unint64_t v59;
  const char *v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  int v65;
  int v66;
  unint64_t v67;
  unint64_t v68;
  const char *v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  int v74;
  int v75;
  unint64_t v76;
  unint64_t v77;
  const char *v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  int v83;
  int v84;
  unint64_t v85;
  unint64_t v86;
  const char *v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  int v92;
  int v93;
  unint64_t v94;
  unint64_t v95;
  const char *v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  int v101;
  int v102;
  unint64_t v103;
  unint64_t v104;
  const char *v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  int v110;
  int v111;
  unint64_t v112;
  unint64_t v113;
  const char *v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  int v119;
  int v120;
  unint64_t v121;
  unint64_t v122;
  const char *v123;
  unint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  int v128;
  int v129;
  unint64_t v130;
  unint64_t v131;
  const char *v132;
  unint64_t v133;
  uint64_t v134;
  unint64_t v135;
  uint64_t v136;
  int v137;
  int v138;
  unint64_t v139;
  unint64_t v140;
  const char *v141;
  unint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  int v146;
  int v147;
  unint64_t v148;
  unint64_t v149;
  const char *v150;
  unint64_t v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t v154;
  int v155;
  int v156;
  unint64_t v157;
  unint64_t v158;
  const char *v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  int v164;
  int v165;
  unint64_t v166;
  unint64_t v167;
  const char *v168;
  unint64_t v169;
  uint64_t v170;
  unint64_t v171;
  uint64_t v172;
  int v173;
  int v174;
  unint64_t v175;
  unint64_t v176;
  const char *v177;
  unint64_t v178;
  uint64_t v179;
  unint64_t v180;
  uint64_t v181;
  __guard v182;
  __guard v183;
  __guard v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  void *v188;
  void *v189;
  void *v190;
  void *v191;
  void *v192;
  void *v193;
  void *v194;
  void *v195;
  void *v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  void *v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  __guard v237;
  __guard v238;
  __guard v239;
  __guard v240;
  __guard v241;
  __guard v242;
  __guard v243;
  __guard v244;
  __guard v245;
  __guard v246;
  __guard v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  void *v273;
  void *v274;
  void *v275;
  void *v276;
  void *v277;
  void *v278;
  void *v279;
  void *v280;
  void *v281;
  void *v282;
  void *v283;
  void *v284;
  void *v285;
  void *v286;
  const char *v287;
  unint64_t v288;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v273 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v57 = v56;
    a1 = v273;
    if (v57)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v288 = 83;
      v58 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v58)
        v59 = v58;
      else
        v59 = v288;
      v60 = &v287[v59];
      v61 = v288 - v59;
      if (v288 - v59 >= 0x12)
        v62 = 18;
      else
        v62 = v288 - v59;
      v63 = v61 - v62;
      if (v63 >= v63 - 1)
        v64 = v63 - 1;
      else
        v64 = v63;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v60[v62], v64);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v273;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v260 = v3;
    v274 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v66 = v65;
    v3 = v260;
    a1 = v274;
    if (v66)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v288 = 81;
      v67 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v67)
        v68 = v67;
      else
        v68 = v288;
      v69 = &v287[v68];
      v70 = v288 - v68;
      if (v288 - v68 >= 0x12)
        v71 = 18;
      else
        v71 = v288 - v68;
      v72 = v70 - v71;
      if (v72 >= v72 - 1)
        v73 = v72 - 1;
      else
        v73 = v72;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v69[v71], v73);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v260;
      a1 = v274;
    }
  }
  v6 = v5[211];
  if ((v7 & 1) == 0)
  {
    v261 = v3;
    v275 = a1;
    v248 = v6;
    v6 = v248;
    v3 = v261;
    v75 = v74;
    a1 = v275;
    if (v75)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<Empty>]";
      v288 = 111;
      v76 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v76)
        v77 = v76;
      else
        v77 = v288;
      v78 = &v287[v77];
      v79 = v288 - v77;
      if (v288 - v77 >= 0x12)
        v80 = 18;
      else
        v80 = v288 - v77;
      v81 = v79 - v80;
      if (v81 >= v81 - 1)
        v82 = v81 - 1;
      else
        v82 = v81;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v78[v80], v82);
      v6 = v248;
      v3 = v261;
      a1 = v275;
    }
  }
  v9 = v8[363];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v262 = v3;
    v276 = a1;
    v237 = v9;
    v249 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v237;
    v6 = v249;
    v84 = v83;
    v3 = v262;
    a1 = v276;
    if (v84)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v288 = 86;
      v85 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v85)
        v86 = v85;
      else
        v86 = v288;
      v87 = &v287[v86];
      v88 = v288 - v86;
      if (v288 - v86 >= 0x12)
        v89 = 18;
      else
        v89 = v288 - v86;
      v90 = v88 - v89;
      if (v90 >= v90 - 1)
        v91 = v90 - 1;
      else
        v91 = v90;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v87[v89], v91);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v237;
      v6 = v249;
      v3 = v262;
      a1 = v276;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v263 = v3;
    v277 = a1;
    v238 = v9;
    v250 = v6;
    v227 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v227;
    v9 = v238;
    v6 = v250;
    v93 = v92;
    v3 = v263;
    a1 = v277;
    if (v93)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v288 = 82;
      v94 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v94)
        v95 = v94;
      else
        v95 = v288;
      v96 = &v287[v95];
      v97 = v288 - v95;
      if (v288 - v95 >= 0x12)
        v98 = 18;
      else
        v98 = v288 - v95;
      v99 = v97 - v98;
      if (v99 >= v99 - 1)
        v100 = v99 - 1;
      else
        v100 = v99;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v96[v98], v100);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v227;
      v9 = v238;
      v6 = v250;
      v3 = v263;
      a1 = v277;
    }
  }
  v15 = v14[181];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v264 = v3;
    v278 = a1;
    v239 = v9;
    v251 = v6;
    v218 = v15;
    v228 = v12;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v218;
    v12 = v228;
    v9 = v239;
    v6 = v251;
    v102 = v101;
    v3 = v264;
    a1 = v278;
    if (v102)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v288 = 84;
      v103 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v103)
        v104 = v103;
      else
        v104 = v288;
      v105 = &v287[v104];
      v106 = v288 - v104;
      if (v288 - v104 >= 0x12)
        v107 = 18;
      else
        v107 = v288 - v104;
      v108 = v106 - v107;
      if (v108 >= v108 - 1)
        v109 = v108 - 1;
      else
        v109 = v108;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v105[v107], v109);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v218;
      v12 = v228;
      v9 = v239;
      v6 = v251;
      v3 = v264;
      a1 = v278;
    }
  }
  v18 = v17[192];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v265 = v3;
    v279 = a1;
    v240 = v9;
    v252 = v6;
    v219 = v15;
    v229 = v12;
    v210 = v18;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v210;
    v15 = v219;
    v12 = v229;
    v9 = v240;
    v6 = v252;
    v111 = v110;
    v3 = v265;
    a1 = v279;
    if (v111)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v288 = 89;
      v112 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v112)
        v113 = v112;
      else
        v113 = v288;
      v114 = &v287[v113];
      v115 = v288 - v113;
      if (v288 - v113 >= 0x12)
        v116 = 18;
      else
        v116 = v288 - v113;
      v117 = v115 - v116;
      if (v117 >= v117 - 1)
        v118 = v117 - 1;
      else
        v118 = v117;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v114[v116], v118);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v210;
      v15 = v219;
      v12 = v229;
      v9 = v240;
      v6 = v252;
      v3 = v265;
      a1 = v279;
    }
  }
  v21 = p_vtable[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v266 = v3;
    v280 = a1;
    v241 = v9;
    v253 = v6;
    v220 = v15;
    v230 = v12;
    v203 = v21;
    v211 = v18;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v203;
    v18 = v211;
    v15 = v220;
    v12 = v230;
    v9 = v241;
    v6 = v253;
    v120 = v119;
    v3 = v266;
    a1 = v280;
    if (v120)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultType<Empty>]";
      v288 = 97;
      v121 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v121)
        v122 = v121;
      else
        v122 = v288;
      v123 = &v287[v122];
      v124 = v288 - v122;
      if (v288 - v122 >= 0x12)
        v125 = 18;
      else
        v125 = v288 - v122;
      v126 = v124 - v125;
      if (v126 >= v126 - 1)
        v127 = v126 - 1;
      else
        v127 = v126;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v123[v125], v127);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v203;
      v18 = v211;
      v15 = v220;
      v12 = v230;
      v9 = v241;
      v6 = v253;
      v3 = v266;
      a1 = v280;
    }
  }
  v24 = v23[205];
  v26 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v25 & 1) == 0)
  {
    v267 = v3;
    v281 = a1;
    v242 = v9;
    v254 = v6;
    v221 = v15;
    v231 = v12;
    v204 = v21;
    v212 = v18;
    v197 = v24;
    v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v24 = v197;
    v21 = v204;
    v18 = v212;
    v15 = v221;
    v12 = v231;
    v9 = v242;
    v6 = v254;
    v129 = v128;
    v3 = v267;
    a1 = v281;
    if (v129)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v288 = 95;
      v130 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v130)
        v131 = v130;
      else
        v131 = v288;
      v132 = &v287[v131];
      v133 = v288 - v131;
      if (v288 - v131 >= 0x12)
        v134 = 18;
      else
        v134 = v288 - v131;
      v135 = v133 - v134;
      if (v135 >= v135 - 1)
        v136 = v135 - 1;
      else
        v136 = v135;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v132[v134], v136);
      v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v24 = v197;
      v21 = v204;
      v18 = v212;
      v15 = v221;
      v12 = v231;
      v9 = v242;
      v6 = v254;
      v3 = v267;
      a1 = v281;
    }
  }
  v27 = v26[486];
  v29 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v28 & 1) == 0)
  {
    v268 = v3;
    v282 = a1;
    v243 = v9;
    v255 = v6;
    v222 = v15;
    v232 = v12;
    v205 = v21;
    v213 = v18;
    v192 = v27;
    v198 = v24;
    v29 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v27 = v192;
    v24 = v198;
    v21 = v205;
    v18 = v213;
    v15 = v222;
    v12 = v232;
    v9 = v243;
    v6 = v255;
    v138 = v137;
    v3 = v268;
    a1 = v282;
    if (v138)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v288 = 99;
      v139 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v139)
        v140 = v139;
      else
        v140 = v288;
      v141 = &v287[v140];
      v142 = v288 - v140;
      if (v288 - v140 >= 0x12)
        v143 = 18;
      else
        v143 = v288 - v140;
      v144 = v142 - v143;
      if (v144 >= v144 - 1)
        v145 = v144 - 1;
      else
        v145 = v144;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v141[v143], v145);
      v29 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v27 = v192;
      v24 = v198;
      v21 = v205;
      v18 = v213;
      v15 = v222;
      v12 = v232;
      v9 = v243;
      v6 = v255;
      v3 = v268;
      a1 = v282;
    }
  }
  v30 = v29[504];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v269 = v3;
    v283 = a1;
    v244 = v9;
    v256 = v6;
    v223 = v15;
    v233 = v12;
    v206 = v21;
    v214 = v18;
    v193 = v27;
    v199 = v24;
    v188 = v30;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v188;
    v27 = v193;
    v24 = v199;
    v21 = v206;
    v18 = v214;
    v15 = v223;
    v12 = v233;
    v9 = v244;
    v6 = v256;
    v147 = v146;
    v3 = v269;
    a1 = v283;
    if (v147)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v288 = 93;
      v148 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v148)
        v149 = v148;
      else
        v149 = v288;
      v150 = &v287[v149];
      v151 = v288 - v149;
      if (v288 - v149 >= 0x12)
        v152 = 18;
      else
        v152 = v288 - v149;
      v153 = v151 - v152;
      if (v153 >= v153 - 1)
        v154 = v153 - 1;
      else
        v154 = v153;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v150[v152], v154);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v188;
      v27 = v193;
      v24 = v199;
      v21 = v206;
      v18 = v214;
      v15 = v223;
      v12 = v233;
      v9 = v244;
      v6 = v256;
      v3 = v269;
      a1 = v283;
    }
  }
  v33 = v32[158];
  if ((v34 & 1) == 0)
  {
    v270 = v3;
    v284 = a1;
    v245 = v9;
    v257 = v6;
    v224 = v15;
    v234 = v12;
    v207 = v21;
    v215 = v18;
    v194 = v27;
    v200 = v24;
    v185 = v33;
    v189 = v30;
    v33 = v185;
    v30 = v189;
    v27 = v194;
    v24 = v200;
    v21 = v207;
    v18 = v215;
    v15 = v224;
    v12 = v234;
    v9 = v245;
    v6 = v257;
    v156 = v155;
    v3 = v270;
    a1 = v284;
    if (v156)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Elementwise<Empty>]";
      v288 = 83;
      v157 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v157)
        v158 = v157;
      else
        v158 = v288;
      v159 = &v287[v158];
      v160 = v288 - v158;
      if (v288 - v158 >= 0x12)
        v161 = 18;
      else
        v161 = v288 - v158;
      v162 = v160 - v161;
      if (v162 >= v162 - 1)
        v163 = v162 - 1;
      else
        v163 = v162;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Elementwise<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Elementwise>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v159[v161], v163);
      v33 = v185;
      v30 = v189;
      v27 = v194;
      v24 = v200;
      v21 = v207;
      v18 = v215;
      v15 = v224;
      v12 = v234;
      v9 = v245;
      v6 = v257;
      v3 = v270;
      a1 = v284;
    }
  }
  v36 = v35[220];
  if ((v37 & 1) == 0)
  {
    v271 = v3;
    v285 = a1;
    v246 = v9;
    v258 = v6;
    v225 = v15;
    v235 = v12;
    v208 = v21;
    v216 = v18;
    v195 = v27;
    v201 = v24;
    v186 = v33;
    v190 = v30;
    v183 = v36;
    v36 = v183;
    v33 = v186;
    v30 = v190;
    v27 = v195;
    v24 = v201;
    v21 = v208;
    v18 = v216;
    v15 = v225;
    v12 = v235;
    v9 = v246;
    v6 = v258;
    v165 = v164;
    v3 = v271;
    a1 = v285;
    if (v165)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface::Trait<Empty>]";
      v288 = 99;
      v166 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v166)
        v167 = v166;
      else
        v167 = v288;
      v168 = &v287[v167];
      v169 = v288 - v167;
      if (v288 - v167 >= 0x12)
        v170 = 18;
      else
        v170 = v288 - v167;
      v171 = v169 - v170;
      if (v171 >= v171 - 1)
        v172 = v171 - 1;
      else
        v172 = v171;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::arith::ArithFastMathInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v168[v170], v172);
      v36 = v183;
      v33 = v186;
      v30 = v190;
      v27 = v195;
      v24 = v201;
      v21 = v208;
      v18 = v216;
      v15 = v225;
      v12 = v235;
      v9 = v246;
      v6 = v258;
      v3 = v271;
      a1 = v285;
    }
  }
  v39 = v38[216];
  v41 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v40 & 1) == 0)
  {
    v272 = v3;
    v286 = a1;
    v247 = v9;
    v259 = v6;
    v226 = v15;
    v236 = v12;
    v209 = v21;
    v217 = v18;
    v196 = v27;
    v202 = v24;
    v187 = v33;
    v191 = v30;
    v182 = v39;
    v184 = v36;
    v41 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v39 = v182;
    v36 = v184;
    v33 = v187;
    v30 = v191;
    v27 = v196;
    v24 = v202;
    v21 = v209;
    v18 = v217;
    v15 = v226;
    v12 = v236;
    v9 = v247;
    v6 = v259;
    v174 = v173;
    v3 = v272;
    a1 = v286;
    if (v174)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v288 = 90;
      v175 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v175)
        v176 = v175;
      else
        v176 = v288;
      v177 = &v287[v176];
      v178 = v288 - v176;
      if (v288 - v176 >= 0x12)
        v179 = 18;
      else
        v179 = v288 - v176;
      v180 = v178 - v179;
      if (v180 >= v180 - 1)
        v181 = v180 - 1;
      else
        v181 = v180;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v177[v179], v181);
      v41 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v39 = v182;
      v36 = v184;
      v33 = v187;
      v30 = v191;
      v27 = v196;
      v24 = v202;
      v21 = v209;
      v18 = v217;
      v15 = v226;
      v12 = v236;
      v9 = v247;
      v6 = v259;
      v3 = v272;
      a1 = v286;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == (_QWORD)a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == a1
      || v30 == a1
      || v33 == (_QWORD)a1
      || v36 == (_QWORD)a1
      || v39 == (_QWORD)a1
      || v41[152] == (_QWORD)a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::Operation *v7;
  mlir::OpTrait::impl *v9;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v9 = a1, mlir::complex::ConjOp::verifyInvariantsImpl((uint64_t **)&v9))
    && mlir::OpTrait::impl::verifySameOperandsAndResultType(a1, v6))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v7) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.constant", 16, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ConstantOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E45E08;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::ConstantOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::ConstantOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::complex::ConstantOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::ConstantOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::complex::ConstantOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::complex::ConstantOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::ConstantOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::CmpFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConstantOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConstantOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x20uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getDefaultDialect;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[139], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::complex::ConstantOp::getAsmResultNames(&v5, a3, a4);
}

const char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getDefaultDialect()
{
  return "";
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  mlir::complex::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::ConstantOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  __guard *v8;
  __guard v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **p_vtable;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  void **v26;
  void *v27;
  unsigned __int8 v28;
  void **v29;
  void *v30;
  unsigned __int8 v31;
  uint64_t *v32;
  uint64_t v33;
  unsigned __int8 v34;
  uint64_t *v35;
  int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  const char *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  const char *v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  unint64_t v86;
  unint64_t v87;
  const char *v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  const char *v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  unint64_t v104;
  unint64_t v105;
  const char *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unint64_t v113;
  unint64_t v114;
  const char *v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  unint64_t v122;
  unint64_t v123;
  const char *v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  int v129;
  int v130;
  unint64_t v131;
  unint64_t v132;
  const char *v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  unint64_t v140;
  unint64_t v141;
  const char *v142;
  unint64_t v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  int v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  const char *v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  uint64_t v156;
  void *v157;
  void *v158;
  void *v159;
  void *v160;
  void *v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  void *v166;
  void *v167;
  void *v168;
  void *v169;
  void *v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  __guard v192;
  __guard v193;
  __guard v194;
  __guard v195;
  __guard v196;
  __guard v197;
  __guard v198;
  __guard v199;
  __guard v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  void *v222;
  void *v223;
  void *v224;
  void *v225;
  void *v226;
  void *v227;
  void *v228;
  void *v229;
  void *v230;
  void *v231;
  void *v232;
  void *v233;
  const char *v234;
  unint64_t v235;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v222 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v49 = v48;
    a1 = v222;
    if (v49)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v235 = 83;
      v50 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v50)
        v51 = v50;
      else
        v51 = v235;
      v52 = &v234[v51];
      v53 = v235 - v51;
      if (v235 - v51 >= 0x12)
        v54 = 18;
      else
        v54 = v235 - v51;
      v55 = v53 - v54;
      if (v55 >= v55 - 1)
        v56 = v55 - 1;
      else
        v56 = v55;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v222;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v211 = v3;
    v223 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v58 = v57;
    v3 = v211;
    a1 = v223;
    if (v58)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v235 = 81;
      v59 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v59)
        v60 = v59;
      else
        v60 = v235;
      v61 = &v234[v60];
      v62 = v235 - v60;
      if (v235 - v60 >= 0x12)
        v63 = 18;
      else
        v63 = v235 - v60;
      v64 = v62 - v63;
      if (v64 >= v64 - 1)
        v65 = v64 - 1;
      else
        v65 = v64;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v211;
      a1 = v223;
    }
  }
  v6 = v5[211];
  if ((v7 & 1) == 0)
  {
    v212 = v3;
    v224 = a1;
    v201 = v6;
    v6 = v201;
    v3 = v212;
    v67 = v66;
    a1 = v224;
    if (v67)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<Empty>]";
      v235 = 111;
      v68 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v68)
        v69 = v68;
      else
        v69 = v235;
      v70 = &v234[v69];
      v71 = v235 - v69;
      if (v235 - v69 >= 0x12)
        v72 = 18;
      else
        v72 = v235 - v69;
      v73 = v71 - v72;
      if (v73 >= v73 - 1)
        v74 = v73 - 1;
      else
        v74 = v73;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      v6 = v201;
      v3 = v212;
      a1 = v224;
    }
  }
  v9 = v8[363];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v213 = v3;
    v225 = a1;
    v202 = v6;
    v192 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v192;
    v6 = v202;
    v3 = v213;
    v76 = v75;
    a1 = v225;
    if (v76)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v235 = 86;
      v77 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v77)
        v78 = v77;
      else
        v78 = v235;
      v79 = &v234[v78];
      v80 = v235 - v78;
      if (v235 - v78 >= 0x12)
        v81 = 18;
      else
        v81 = v235 - v78;
      v82 = v80 - v81;
      if (v82 >= v82 - 1)
        v83 = v82 - 1;
      else
        v83 = v82;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v192;
      v6 = v202;
      v3 = v213;
      a1 = v225;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v214 = v3;
    v226 = a1;
    v203 = v6;
    v184 = v12;
    v193 = v9;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v184;
    v9 = v193;
    v6 = v203;
    v3 = v214;
    v85 = v84;
    a1 = v226;
    if (v85)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroOperands<Empty>]";
      v235 = 84;
      v86 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v86)
        v87 = v86;
      else
        v87 = v235;
      v88 = &v234[v87];
      v89 = v235 - v87;
      if (v235 - v87 >= 0x12)
        v90 = 18;
      else
        v90 = v235 - v87;
      v91 = v89 - v90;
      if (v91 >= v91 - 1)
        v92 = v91 - 1;
      else
        v92 = v91;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v184;
      v9 = v193;
      v6 = v203;
      v3 = v214;
      a1 = v226;
    }
  }
  v15 = v14[193];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v215 = v3;
    v227 = a1;
    v204 = v6;
    v185 = v12;
    v194 = v9;
    v177 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v177;
    v12 = v185;
    v9 = v194;
    v6 = v204;
    v3 = v215;
    v94 = v93;
    a1 = v227;
    if (v94)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v235 = 84;
      v95 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v95)
        v96 = v95;
      else
        v96 = v235;
      v97 = &v234[v96];
      v98 = v235 - v96;
      if (v235 - v96 >= 0x12)
        v99 = 18;
      else
        v99 = v235 - v96;
      v100 = v98 - v99;
      if (v100 >= v100 - 1)
        v101 = v100 - 1;
      else
        v101 = v100;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v177;
      v12 = v185;
      v9 = v194;
      v6 = v204;
      v3 = v215;
      a1 = v227;
    }
  }
  v18 = v17[192];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v216 = v3;
    v228 = a1;
    v205 = v6;
    v186 = v12;
    v195 = v9;
    v171 = v18;
    v178 = v15;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v171;
    v15 = v178;
    v12 = v186;
    v9 = v195;
    v6 = v205;
    v3 = v216;
    v103 = v102;
    a1 = v228;
    if (v103)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v235 = 89;
      v104 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v104)
        v105 = v104;
      else
        v105 = v235;
      v106 = &v234[v105];
      v107 = v235 - v105;
      if (v235 - v105 >= 0x12)
        v108 = 18;
      else
        v108 = v235 - v105;
      v109 = v107 - v108;
      if (v109 >= v109 - 1)
        v110 = v109 - 1;
      else
        v110 = v109;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v171;
      v15 = v178;
      v12 = v186;
      v9 = v195;
      v6 = v205;
      v3 = v216;
      a1 = v228;
    }
  }
  v21 = p_vtable[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v217 = v3;
    v229 = a1;
    v206 = v6;
    v187 = v12;
    v196 = v9;
    v172 = v18;
    v179 = v15;
    v166 = v21;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v166;
    v18 = v172;
    v15 = v179;
    v12 = v187;
    v9 = v196;
    v6 = v206;
    v3 = v217;
    v112 = v111;
    a1 = v229;
    if (v112)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ConstantLike<Empty>]";
      v235 = 84;
      v113 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v113)
        v114 = v113;
      else
        v114 = v235;
      v115 = &v234[v114];
      v116 = v235 - v114;
      if (v235 - v114 >= 0x12)
        v117 = 18;
      else
        v117 = v235 - v114;
      v118 = v116 - v117;
      if (v118 >= v118 - 1)
        v119 = v118 - 1;
      else
        v119 = v118;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v166;
      v18 = v172;
      v15 = v179;
      v12 = v187;
      v9 = v196;
      v6 = v206;
      v3 = v217;
      a1 = v229;
    }
  }
  v24 = v23[189];
  v26 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v25 & 1) == 0)
  {
    v218 = v3;
    v230 = a1;
    v207 = v6;
    v188 = v12;
    v197 = v9;
    v173 = v18;
    v180 = v15;
    v162 = v24;
    v167 = v21;
    v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v24 = v162;
    v21 = v167;
    v18 = v173;
    v15 = v180;
    v12 = v188;
    v9 = v197;
    v6 = v207;
    v3 = v218;
    v121 = v120;
    a1 = v230;
    if (v121)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v235 = 95;
      v122 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v122)
        v123 = v122;
      else
        v123 = v235;
      v124 = &v234[v123];
      v125 = v235 - v123;
      if (v235 - v123 >= 0x12)
        v126 = 18;
      else
        v126 = v235 - v123;
      v127 = v125 - v126;
      if (v127 >= v127 - 1)
        v128 = v127 - 1;
      else
        v128 = v127;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v24 = v162;
      v21 = v167;
      v18 = v173;
      v15 = v180;
      v12 = v188;
      v9 = v197;
      v6 = v207;
      v3 = v218;
      a1 = v230;
    }
  }
  v27 = v26[486];
  v29 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v28 & 1) == 0)
  {
    v219 = v3;
    v231 = a1;
    v208 = v6;
    v189 = v12;
    v198 = v9;
    v174 = v18;
    v181 = v15;
    v163 = v24;
    v168 = v21;
    v159 = v27;
    v29 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v27 = v159;
    v24 = v163;
    v21 = v168;
    v18 = v174;
    v15 = v181;
    v12 = v189;
    v9 = v198;
    v6 = v208;
    v3 = v219;
    v130 = v129;
    a1 = v231;
    if (v130)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v235 = 99;
      v131 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v131)
        v132 = v131;
      else
        v132 = v235;
      v133 = &v234[v132];
      v134 = v235 - v132;
      if (v235 - v132 >= 0x12)
        v135 = 18;
      else
        v135 = v235 - v132;
      v136 = v134 - v135;
      if (v136 >= v136 - 1)
        v137 = v136 - 1;
      else
        v137 = v136;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      v29 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v27 = v159;
      v24 = v163;
      v21 = v168;
      v18 = v174;
      v15 = v181;
      v12 = v189;
      v9 = v198;
      v6 = v208;
      v3 = v219;
      a1 = v231;
    }
  }
  v30 = v29[504];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v220 = v3;
    v232 = a1;
    v209 = v6;
    v190 = v12;
    v199 = v9;
    v175 = v18;
    v182 = v15;
    v164 = v24;
    v169 = v21;
    v157 = v30;
    v160 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v157;
    v27 = v160;
    v24 = v164;
    v21 = v169;
    v18 = v175;
    v15 = v182;
    v12 = v190;
    v9 = v199;
    v6 = v209;
    v3 = v220;
    v139 = v138;
    a1 = v232;
    if (v139)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v235 = 93;
      v140 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v140)
        v141 = v140;
      else
        v141 = v235;
      v142 = &v234[v141];
      v143 = v235 - v141;
      if (v235 - v141 >= 0x12)
        v144 = 18;
      else
        v144 = v235 - v141;
      v145 = v143 - v144;
      if (v145 >= v145 - 1)
        v146 = v145 - 1;
      else
        v146 = v145;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v157;
      v27 = v160;
      v24 = v164;
      v21 = v169;
      v18 = v175;
      v15 = v182;
      v12 = v190;
      v9 = v199;
      v6 = v209;
      v3 = v220;
      a1 = v232;
    }
  }
  v33 = v32[158];
  v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v34 & 1) == 0)
  {
    v221 = v3;
    v233 = a1;
    v210 = v6;
    v191 = v12;
    v200 = v9;
    v176 = v18;
    v183 = v15;
    v165 = v24;
    v170 = v21;
    v158 = v30;
    v161 = v27;
    v156 = v33;
    v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v33 = v156;
    v30 = v158;
    v27 = v161;
    v24 = v165;
    v21 = v170;
    v18 = v176;
    v15 = v183;
    v12 = v191;
    v9 = v200;
    v6 = v210;
    v3 = v221;
    v148 = v147;
    a1 = v233;
    if (v148)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v235 = 86;
      v149 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v149)
        v150 = v149;
      else
        v150 = v235;
      v151 = &v234[v150];
      v152 = v235 - v150;
      if (v235 - v150 >= 0x12)
        v153 = 18;
      else
        v153 = v235 - v150;
      v154 = v152 - v153;
      if (v154 >= v154 - 1)
        v155 = v154 - 1;
      else
        v155 = v154;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v33 = v156;
      v30 = v158;
      v27 = v161;
      v24 = v165;
      v21 = v170;
      v18 = v176;
      v15 = v183;
      v12 = v191;
      v9 = v200;
      v6 = v210;
      v3 = v221;
      a1 = v233;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == (_QWORD)a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == a1
      || v30 == a1
      || v33 == (_QWORD)a1
      || v35[138] == (_QWORD)a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::ConstantOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroOperands(a1, v5))
    return 0;
  v7 = a1;
  if (!mlir::complex::ConstantOp::verifyInvariantsImpl((uint64_t **)&v7))
    return 0;
  v7 = a1;
  return mlir::complex::ConstantOp::verify((uint64_t **)&v7) != 0;
}

uint64_t mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CosOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.cos", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::CosOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E462B8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::foldHook()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::CosOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CosOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CosOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CosOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::CosOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::CosOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.cos";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::CreateOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  unsigned int *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, unsigned int *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                              + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CreateOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CreateOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CreateOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CreateOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CreateOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CreateOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int *v13;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  mlir::complex::detail::CreateOpGenericAdaptorBase::CreateOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::CreateOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 4 == (unsigned int *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  __guard *v8;
  __guard v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **p_vtable;
  void *v21;
  unsigned __int8 v22;
  void **v23;
  void *v24;
  unsigned __int8 v25;
  uint64_t *v26;
  int v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  const char *v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  const char *v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  unint64_t v56;
  unint64_t v57;
  const char *v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  unint64_t v65;
  unint64_t v66;
  const char *v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  unint64_t v74;
  unint64_t v75;
  const char *v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  unint64_t v83;
  unint64_t v84;
  const char *v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  unint64_t v92;
  unint64_t v93;
  const char *v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  unint64_t v101;
  unint64_t v102;
  const char *v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  unint64_t v110;
  unint64_t v111;
  const char *v112;
  unint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  void *v117;
  void *v118;
  void *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  __guard v132;
  __guard v133;
  __guard v134;
  __guard v135;
  __guard v136;
  __guard v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  void *v153;
  void *v154;
  void *v155;
  void *v156;
  void *v157;
  void *v158;
  void *v159;
  void *v160;
  void *v161;
  const char *v162;
  unint64_t v163;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v153 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v37 = v36;
    a1 = v153;
    if (v37)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v163 = 83;
      v38 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v38)
        v39 = v38;
      else
        v39 = v163;
      v40 = &v162[v39];
      v41 = v163 - v39;
      if (v163 - v39 >= 0x12)
        v42 = 18;
      else
        v42 = v163 - v39;
      v43 = v41 - v42;
      if (v43 >= v43 - 1)
        v44 = v43 - 1;
      else
        v44 = v43;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v153;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v145 = v3;
    v154 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v46 = v45;
    v3 = v145;
    a1 = v154;
    if (v46)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v163 = 81;
      v47 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v47)
        v48 = v47;
      else
        v48 = v163;
      v49 = &v162[v48];
      v50 = v163 - v48;
      if (v163 - v48 >= 0x12)
        v51 = 18;
      else
        v51 = v163 - v48;
      v52 = v50 - v51;
      if (v52 >= v52 - 1)
        v53 = v52 - 1;
      else
        v53 = v52;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v145;
      a1 = v154;
    }
  }
  v6 = v5[211];
  if ((v7 & 1) == 0)
  {
    v146 = v3;
    v155 = a1;
    v138 = v6;
    v6 = v138;
    v55 = v54;
    v3 = v146;
    a1 = v155;
    if (v55)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<Empty>]";
      v163 = 111;
      v56 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v56)
        v57 = v56;
      else
        v57 = v163;
      v58 = &v162[v57];
      v59 = v163 - v57;
      if (v163 - v57 >= 0x12)
        v60 = 18;
      else
        v60 = v163 - v57;
      v61 = v59 - v60;
      if (v61 >= v61 - 1)
        v62 = v61 - 1;
      else
        v62 = v61;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      v6 = v138;
      v3 = v146;
      a1 = v155;
    }
  }
  v9 = v8[363];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v147 = v3;
    v156 = a1;
    v132 = v9;
    v139 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v132;
    v6 = v139;
    v64 = v63;
    v3 = v147;
    a1 = v156;
    if (v64)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v163 = 86;
      v65 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v65)
        v66 = v65;
      else
        v66 = v163;
      v67 = &v162[v66];
      v68 = v163 - v66;
      if (v163 - v66 >= 0x12)
        v69 = 18;
      else
        v69 = v163 - v66;
      v70 = v68 - v69;
      if (v70 >= v70 - 1)
        v71 = v70 - 1;
      else
        v71 = v70;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v132;
      v6 = v139;
      v3 = v147;
      a1 = v156;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v148 = v3;
    v157 = a1;
    v133 = v9;
    v140 = v6;
    v127 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v127;
    v9 = v133;
    v6 = v140;
    v73 = v72;
    v3 = v148;
    a1 = v157;
    if (v73)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v163 = 90;
      v74 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v74)
        v75 = v74;
      else
        v75 = v163;
      v76 = &v162[v75];
      v77 = v163 - v75;
      if (v163 - v75 >= 0x12)
        v78 = 18;
      else
        v78 = v163 - v75;
      v79 = v77 - v78;
      if (v79 >= v79 - 1)
        v80 = v79 - 1;
      else
        v80 = v79;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v127;
      v9 = v133;
      v6 = v140;
      v3 = v148;
      a1 = v157;
    }
  }
  v15 = v14[208];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v149 = v3;
    v158 = a1;
    v134 = v9;
    v141 = v6;
    v123 = v15;
    v128 = v12;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v123;
    v12 = v128;
    v9 = v134;
    v6 = v141;
    v82 = v81;
    v3 = v149;
    a1 = v158;
    if (v82)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v163 = 84;
      v83 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v83)
        v84 = v83;
      else
        v84 = v163;
      v85 = &v162[v84];
      v86 = v163 - v84;
      if (v163 - v84 >= 0x12)
        v87 = 18;
      else
        v87 = v163 - v84;
      v88 = v86 - v87;
      if (v88 >= v88 - 1)
        v89 = v88 - 1;
      else
        v89 = v88;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v123;
      v12 = v128;
      v9 = v134;
      v6 = v141;
      v3 = v149;
      a1 = v158;
    }
  }
  v18 = v17[192];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v150 = v3;
    v159 = a1;
    v135 = v9;
    v142 = v6;
    v124 = v15;
    v129 = v12;
    v120 = v18;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v120;
    v15 = v124;
    v12 = v129;
    v9 = v135;
    v6 = v142;
    v91 = v90;
    v3 = v150;
    a1 = v159;
    if (v91)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v163 = 95;
      v92 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v92)
        v93 = v92;
      else
        v93 = v163;
      v94 = &v162[v93];
      v95 = v163 - v93;
      if (v163 - v93 >= 0x12)
        v96 = 18;
      else
        v96 = v163 - v93;
      v97 = v95 - v96;
      if (v97 >= v97 - 1)
        v98 = v97 - 1;
      else
        v98 = v97;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v120;
      v15 = v124;
      v12 = v129;
      v9 = v135;
      v6 = v142;
      v3 = v150;
      a1 = v159;
    }
  }
  v21 = p_vtable[486];
  v23 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v22 & 1) == 0)
  {
    v151 = v3;
    v160 = a1;
    v136 = v9;
    v143 = v6;
    v125 = v15;
    v130 = v12;
    v118 = v21;
    v121 = v18;
    v23 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v21 = v118;
    v18 = v121;
    v15 = v125;
    v12 = v130;
    v9 = v136;
    v6 = v143;
    v100 = v99;
    v3 = v151;
    a1 = v160;
    if (v100)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v163 = 99;
      v101 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v101)
        v102 = v101;
      else
        v102 = v163;
      v103 = &v162[v102];
      v104 = v163 - v102;
      if (v163 - v102 >= 0x12)
        v105 = 18;
      else
        v105 = v163 - v102;
      v106 = v104 - v105;
      if (v106 >= v106 - 1)
        v107 = v106 - 1;
      else
        v107 = v106;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      v23 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v21 = v118;
      v18 = v121;
      v15 = v125;
      v12 = v130;
      v9 = v136;
      v6 = v143;
      v3 = v151;
      a1 = v160;
    }
  }
  v24 = v23[504];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v152 = v3;
    v161 = a1;
    v137 = v9;
    v144 = v6;
    v126 = v15;
    v131 = v12;
    v119 = v21;
    v122 = v18;
    v117 = v24;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v117;
    v21 = v119;
    v18 = v122;
    v15 = v126;
    v12 = v131;
    v9 = v137;
    v6 = v144;
    v109 = v108;
    v3 = v152;
    a1 = v161;
    if (v109)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v163 = 93;
      v110 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v110)
        v111 = v110;
      else
        v111 = v163;
      v112 = &v162[v111];
      v113 = v163 - v111;
      if (v163 - v111 >= 0x12)
        v114 = 18;
      else
        v114 = v163 - v111;
      v115 = v113 - v114;
      if (v115 >= v115 - 1)
        v116 = v115 - 1;
      else
        v116 = v115;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v112[v114], v116);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v117;
      v21 = v119;
      v18 = v122;
      v15 = v126;
      v12 = v131;
      v9 = v137;
      v6 = v144;
      v3 = v152;
      a1 = v161;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == (_QWORD)a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == a1
      || v26[158] == (_QWORD)a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::AddIOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
  {
    return 0;
  }
  v6 = a1;
  return mlir::complex::CreateOp::verifyInvariantsImpl((uint64_t **)&v6) != 0;
}

uint64_t mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::DivOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.div", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::DivOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E46380;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::foldHook()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::DivOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::DivOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::DivOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::DivOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::DivOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::DivOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.div";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::EqualOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.eq", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::EqualOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E46F38;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::EqualOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::EqualOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::EqualOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::EqualOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::EqualOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::EqualOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::EqualOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::complex::EqualOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.eq";
  v16[1] = 10;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  __guard *v8;
  __guard v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **p_vtable;
  void *v21;
  unsigned __int8 v22;
  void **v23;
  void *v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  __guard *v29;
  __guard v30;
  unsigned __int8 v31;
  uint64_t *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  __guard v143;
  uint64_t v144;
  uint64_t v145;
  void *v146;
  void *v147;
  void *v148;
  void *v149;
  void *v150;
  void *v151;
  void *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  __guard v171;
  __guard v172;
  __guard v173;
  __guard v174;
  __guard v175;
  __guard v176;
  __guard v177;
  __guard v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  void *v198;
  void *v199;
  void *v200;
  void *v201;
  void *v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  const char *v209;
  unint64_t v210;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v198;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[211];
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<Empty>]";
      v210 = 111;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = v8[379];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v210 = 90;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[208];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[192];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v210 = 95;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = p_vtable[486];
  v23 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v210 = 99;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[504];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[158];
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Elementwise<Empty>]";
      v210 = 83;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Elementwise<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Elementwise>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[220];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == (_QWORD)a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == a1
      || v27 == (_QWORD)a1
      || v30 == (_QWORD)a1
      || v32[152] == (_QWORD)a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::MulSIExtendedOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::EqualOp>,mlir::OpTrait::OneResult<mlir::complex::EqualOp>,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::EqualOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::OpInvariants<mlir::complex::EqualOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::EqualOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::EqualOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::EqualOp>,mlir::OpTrait::Elementwise<mlir::complex::EqualOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::EqualOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::EqualOp>,mlir::OpTrait::OneResult<mlir::complex::EqualOp>,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::EqualOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::OpInvariants<mlir::complex::EqualOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::EqualOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::EqualOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::EqualOp>,mlir::OpTrait::Elementwise<mlir::complex::EqualOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::EqualOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (v7 = a1, mlir::complex::EqualOp::verifyInvariantsImpl((uint64_t **)&v7)))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v5) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ExpOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.exp", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ExpOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E46448;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::ExpOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ExpOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ExpOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ExpOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ExpOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ExpOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.exp";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  mlir::complex::detail::ExpOpGenericAdaptorBase::ExpOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::ExpOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Expm1Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.expm1", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::Expm1Op,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E47000;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::Expm1Op::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Expm1Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Expm1Op>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Expm1Op>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Expm1Op>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Expm1Op>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.expm1";
  v16[1] = 13;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ImOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.im", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ImOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E45F98;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::complex::ImOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::ImOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ImOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ImOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ImOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ImOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ImOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.im";
  v16[1] = 10;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  mlir::complex::detail::ImOpGenericAdaptorBase::ImOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::ImOp::fold((uint64_t)&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v8 = a1, mlir::complex::AbsOp::verifyInvariantsImpl((uint64_t **)&v8)))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Log1pOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.log1p", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::Log1pOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E470C8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::foldHook()
{
  unsigned int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::Log1pOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Log1pOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Log1pOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Log1pOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Log1pOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Log1pOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.log1p";
  v16[1] = 13;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::LogOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.log", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::LogOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E46510;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::LogOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::LogOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::LogOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::LogOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::LogOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::LogOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.log";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  mlir::complex::detail::LogOpGenericAdaptorBase::LogOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::LogOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::MulOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.mul", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::MulOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E465D8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::MulOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::MulOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::MulOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::MulOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::MulOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::MulOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.mul";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  mlir::complex::detail::MulOpGenericAdaptorBase::MulOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::MulOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NegOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.neg", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NegOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E466A0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::NegOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NegOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NegOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NegOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::NegOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::NegOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.neg";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  mlir::complex::detail::NegOpGenericAdaptorBase::NegOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::NegOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NotEqualOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.neq", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NotEqualOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E45ED0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::foldHook()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::NotEqualOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NotEqualOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NotEqualOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NotEqualOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::EqualOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::NotEqualOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::NotEqualOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::complex::EqualOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.neq";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::MulSIExtendedOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::EqualOp>,mlir::OpTrait::OneResult<mlir::complex::EqualOp>,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::EqualOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::OpInvariants<mlir::complex::EqualOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::EqualOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::EqualOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::EqualOp>,mlir::OpTrait::Elementwise<mlir::complex::EqualOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::EqualOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::PowOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.pow", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::PowOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E46768;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::foldHook()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::PowOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::PowOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::PowOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::PowOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::PowOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::PowOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.pow";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ReOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.re", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ReOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E46060;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::complex::ReOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::ReOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ReOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ReOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ReOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ReOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ReOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.re";
  v16[1] = 10;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  mlir::complex::detail::ReOpGenericAdaptorBase::ReOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::ReOp::fold((uint64_t)&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v8 = a1, mlir::complex::AbsOp::verifyInvariantsImpl((uint64_t **)&v8)))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::RsqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.rsqrt", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::RsqrtOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E47190;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::foldHook()
{
  unsigned int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::RsqrtOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::RsqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::RsqrtOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::RsqrtOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::RsqrtOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::RsqrtOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.rsqrt";
  v16[1] = 13;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SignOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.sign", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::SignOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E46B50;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::SignOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SignOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SignOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SignOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SignOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SignOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.sign";
  v16[1] = 12;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.sin", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::SinOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E46830;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::SinOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SinOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SinOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SinOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SinOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SinOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.sin";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.sqrt", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::SqrtOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E46C18;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::SqrtOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SqrtOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SqrtOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SqrtOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SqrtOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.sqrt";
  v16[1] = 12;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SubOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.sub", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::SubOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E468F8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::SubOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SubOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SubOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SubOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SubOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SubOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.sub";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = a2;
  mlir::complex::detail::SubOpGenericAdaptorBase::SubOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::SubOp::fold(&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.tan", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::TanOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E469C0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::TanOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::TanOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::TanOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.tan";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanhOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.tanh", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::TanhOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E46CE0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::TanhOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanhOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanhOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanhOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getFastMathAttrName;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[495], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::TanhOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::TanhOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x1E0C80C00];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.tanh";
  v16[1] = 12;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t *mlir::Dialect::addAttribute<mlir::complex::NumberAttr>(uint64_t a1)
{
  char v2;
  llvm **v3;
  uint64_t *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  uint64_t *AttributeUniquer;
  _BYTE v10[8];
  void *v11;
  unsigned int v12;
  uint64_t v13;
  llvm *v14[2];
  unint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  mlir::AbstractAttribute::get<mlir::complex::NumberAttr>(a1, (uint64_t)v10);
  mlir::Dialect::addAttribute(a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id, (uint64_t)v10);
  v2 = v15;
  if (v15 >= 8)
  {
    if ((v15 & 4) != 0)
    {
      if ((v15 & 2) != 0)
        v3 = v14;
      else
        v3 = (llvm **)v14[0];
      (*(void (**)(llvm **))((v15 & 0xFFFFFFFFFFFFFFF8) + 16))(v3);
    }
    if ((v2 & 2) == 0)
      llvm::deallocate_buffer(v14[0], v14[1]);
  }
  v4 = (uint64_t *)v11;
  if (v12)
  {
    v5 = 16 * v12;
    v6 = (void **)((char *)v11 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = (uint64_t *)v11;
  }
  if (v4 != &v13)
    free(v4);
  AttributeUniquer = (uint64_t *)mlir::MLIRContext::getAttributeUniquer(*(mlir::MLIRContext **)(a1 + 32));
  return mlir::StorageUniquer::registerParametricStorageTypeImpl(AttributeUniquer, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id, (uint64_t)llvm::function_ref<void ()(mlir::StorageUniquer::BaseStorage *)>::callback_fn<void mlir::StorageUniquer::registerParametricStorageType<mlir::complex::detail::NumberAttrStorage>(mlir::TypeID)::{lambda(mlir::StorageUniquer::BaseStorage *)#1}>, (uint64_t)v10);
}

void mlir::AbstractAttribute::get<mlir::complex::NumberAttr>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  char v8;
  char v9;
  __int128 v10;
  void *v11;
  uint64_t v12;
  _QWORD v13[7];

  v13[6] = *MEMORY[0x1E0C80C00];
  v11 = v13;
  v12 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::TypedAttrInterfaceTraits::Model<mlir::complex::NumberAttr>>((uint64_t)&v11);
  *(_QWORD *)a2 = a1;
  *(_QWORD *)(a2 + 8) = a2 + 24;
  *(_QWORD *)(a2 + 16) = 0x300000000;
  if ((_DWORD)v12)
    llvm::SmallVectorImpl<std::pair<mlir::TypeID,void *>>::operator=(a2 + 8, (uint64_t)&v11);
  *(_QWORD *)(a2 + 96) = (char *)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<BOOL (*)(mlir::TypeID),BOOL (* const)(mlir::TypeID),void>::Callbacks
                       + 2;
  if ((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<BOOL (*)(mlir::TypeID),BOOL (* const)(mlir::TypeID),void>::Callbacks
     + 2 >= 8)
  {
    *(_QWORD *)(a2 + 72) = mlir::detail::StorageUserBase<mlir::complex::NumberAttr,mlir::Attribute,mlir::complex::detail::NumberAttrStorage,mlir::detail::AttributeUniquer,mlir::TypedAttr::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke;
    *(_OWORD *)(a2 + 80) = v10;
  }
  *(_QWORD *)(a2 + 104) = _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_7complex10NumberAttrES2_NSD_6detail17NumberAttrStorageENSB_16AttributeUniquerEJNS1_9TypedAttr5TraitEEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_;
  *(_QWORD *)(a2 + 112) = &v9;
  *(_QWORD *)(a2 + 120) = _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_7complex10NumberAttrES2_NSC_6detail17NumberAttrStorageENSA_16AttributeUniquerEJNS1_9TypedAttr5TraitEEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_;
  *(_QWORD *)(a2 + 128) = &v8;
  *(_QWORD *)(a2 + 136) = &mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id;
  v4 = v11;
  if ((_DWORD)v12)
  {
    v5 = 16 * v12;
    v6 = (void **)((char *)v11 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v11;
  }
  if (v4 != v13)
    free(v4);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::TypedAttrInterfaceTraits::Model<mlir::complex::NumberAttr>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::TypedAttrInterfaceTraits::Model<mlir::complex::NumberAttr>::getType;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::TypedAttr]";
      v15 = 65;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::TypedAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[212], v2);
}

uint64_t mlir::detail::TypedAttrInterfaceTraits::Model<mlir::complex::NumberAttr>::getType(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 72);
}

BOOL mlir::detail::StorageUserBase<mlir::complex::NumberAttr,mlir::Attribute,mlir::complex::detail::NumberAttrStorage,mlir::detail::AttributeUniquer,mlir::TypedAttr::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke(uint64_t a1)
{
  unsigned __int8 v1;
  __guard *v2;
  int v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  if ((v1 & 1) == 0)
  {
    v13 = a1;
    v5 = v4;
    a1 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::TypedAttr::Trait<Empty>]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::TypedAttr::Trait<mlir::TypeID mlir::TypeID::get<mlir::TypedAttr::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      a1 = v13;
    }
  }
  return v2[413] == a1;
}

void _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_7complex10NumberAttrES2_NSD_6detail17NumberAttrStorageENSB_16AttributeUniquerEJNS1_9TypedAttr5TraitEEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  mlir::detail::walkImmediateSubElementsImpl<mlir::complex::NumberAttr>(a2, a3, a4, a5, a6);
}

void mlir::detail::walkImmediateSubElementsImpl<mlir::complex::NumberAttr>(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const llvm::detail::DoubleAPFloat *v10;
  void *v11;
  void *v12;
  const llvm::detail::DoubleAPFloat *v13;
  _QWORD v14[4];
  _QWORD v15[4];
  _QWORD v16[3];
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v10 = (const llvm::detail::DoubleAPFloat *)(a1 + 2);
  v11 = (void *)a1[2];
  v12 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
  if (v12 == v11)
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v15, v10);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v15, v10);
  v13 = (const llvm::detail::DoubleAPFloat *)(a1 + 6);
  if (v12 == (void *)a1[6])
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v16, v13);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v16, v13);
  v17 = a1[9];
  v14[0] = a2;
  v14[1] = a3;
  v14[2] = a4;
  v14[3] = a5;
  mlir::AttrTypeImmediateSubElementWalker::walk((uint64_t)v14, v17);
  if (v12 == (void *)v16[0])
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v16);
    if (v12 != (void *)v15[0])
      goto LABEL_9;
LABEL_12:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v15);
    return;
  }
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v16);
  if (v12 == (void *)v15[0])
    goto LABEL_12;
LABEL_9:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v15);
}

uint64_t _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_7complex10NumberAttrES2_NSC_6detail17NumberAttrStorageENSA_16AttributeUniquerEJNS1_9TypedAttr5TraitEEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t *v7[2];
  _QWORD v8[2];

  v8[0] = a3;
  v8[1] = a4;
  v7[0] = a5;
  v7[1] = a6;
  return mlir::detail::replaceImmediateSubElementsImpl<mlir::complex::NumberAttr>(a2, (uint64_t)v8, v7);
}

uint64_t mlir::detail::replaceImmediateSubElementsImpl<mlir::complex::NumberAttr>(_QWORD *a1, uint64_t a2, uint64_t **a3)
{
  const llvm::detail::DoubleAPFloat *v5;
  void *v6;
  void *v7;
  const llvm::detail::DoubleAPFloat *v8;
  uint64_t v9;
  mlir::MLIRContext *Context;
  llvm::APFloatBase *AttributeUniquer;
  uint64_t v12;
  uint64_t v14;
  _QWORD *v15;
  _QWORD v16[2];
  _BYTE v17[8];
  _QWORD v18[3];
  uint64_t v19;
  _QWORD v20[3];
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v15 = a1;
  v5 = (const llvm::detail::DoubleAPFloat *)(a1 + 2);
  v6 = (void *)a1[2];
  v7 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
  if (v7 == v6)
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v18, v5);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v18, v5);
  v8 = (const llvm::detail::DoubleAPFloat *)(a1 + 6);
  if (v7 == (void *)a1[6])
  {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v20, v8);
    v21 = a1[9];
    if (v21)
      goto LABEL_6;
  }
  else
  {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v20, v8);
    v21 = a1[9];
    if (v21)
    {
LABEL_6:
      v9 = **a3;
      goto LABEL_9;
    }
  }
  v9 = 0;
LABEL_9:
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
  v14 = v9;
  AttributeUniquer = (llvm::APFloatBase *)mlir::MLIRContext::getAttributeUniquer(Context);
  v16[0] = &mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id;
  v16[1] = Context;
  v12 = mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir7complex6detail17NumberAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_10NumberAttrEJRKNS_7APFloatESF_RNS1_4TypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESK_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSM_E_EEvlS5_, (uint64_t)v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id, (uint64_t)v17, (uint64_t)&v19, &v14);
  if (v7 == (void *)v20[0])
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v20);
    if (v7 != (void *)v18[0])
      goto LABEL_11;
LABEL_14:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v18);
    return v12;
  }
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v20);
  if (v7 == (void *)v18[0])
    goto LABEL_14;
LABEL_11:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v18);
  return v12;
}

uint64_t mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  const llvm::detail::DoubleAPFloat *v11;
  void *v12;
  void *v13;
  const llvm::detail::DoubleAPFloat *v14;
  unsigned int v15;
  uint64_t ParametricStorageTypeImpl;
  _QWORD v18[2];
  _BYTE *v19;
  _QWORD v20[2];
  _BYTE v21[8];
  _QWORD v22[3];
  uint64_t v23;
  _QWORD v24[3];
  _QWORD v25[2];

  v25[1] = *MEMORY[0x1E0C80C00];
  v20[0] = a2;
  v20[1] = a3;
  v11 = (const llvm::detail::DoubleAPFloat *)(a5 + 8);
  v12 = *(void **)(a5 + 8);
  v13 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v13 == v12)
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v22, v11);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v22, v11);
  v14 = (const llvm::detail::DoubleAPFloat *)(a6 + 8);
  if (v13 == *(void **)(a6 + 8))
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v24, v14);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v24, v14);
  v25[0] = *a7;
  v15 = llvm::hash_combine<llvm::APFloat,llvm::APFloat,mlir::Type>((llvm *)v21, (const llvm::APFloat *)&v23, v25);
  v18[0] = v21;
  v18[1] = v20;
  v19 = v21;
  ParametricStorageTypeImpl = mlir::StorageUniquer::getParametricStorageTypeImpl((unsigned __int8 **)a1, a4, v15, (uint64_t (*)(uint64_t))llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, (uint64_t)&v19, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, (uint64_t)v18);
  if (v13 == (void *)v24[0])
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v24);
    if (v13 != (void *)v22[0])
      goto LABEL_9;
LABEL_12:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v22);
    return ParametricStorageTypeImpl;
  }
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v24);
  if (v13 == (void *)v22[0])
    goto LABEL_12;
LABEL_9:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v22);
  return ParametricStorageTypeImpl;
}

unint64_t llvm::hash_combine<llvm::APFloat,llvm::APFloat,mlir::Type>(llvm *a1, const llvm::APFloat *a2, _DWORD *a3)
{
  unsigned __int8 v5;
  const llvm::APFloat *v6;
  unint64_t v7;
  char *v8;
  char *v9;
  llvm *v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _OWORD v16[4];
  _OWORD v17[3];
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v18 = 0;
  memset(v17, 0, sizeof(v17));
  memset(v16, 0, sizeof(v16));
  if ((v5 & 1) == 0)
  {
    v11 = a1;
    a1 = v11;
    if (v12)
    {
      v13 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v13 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v13;
      a1 = v11;
    }
  }
  v19 = llvm::hashing::detail::get_execution_seed(void)::seed;
  *(_QWORD *)&v16[0] = llvm::hash_value(a1, a2);
  v14 = 0;
  v7 = llvm::hash_value(a2, v6);
  v8 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v16, (uint64_t *)&v14, (_QWORD *)v16 + 1, (unint64_t)v17, v7);
  v15 = v14;
  v9 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v16, (uint64_t *)&v15, v8, (unint64_t)v17, (*a3 >> 4) ^ (*a3 >> 9));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine((llvm::hashing::detail::hash_combine_recursive_helper *)v16, v15, v9, (char *)v17);
}

uint64_t llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>(llvm::APFloatBase *a1, _QWORD *a2)
{
  uint64_t v2;
  llvm::detail::DoubleAPFloat *v3;
  void *v4;
  const llvm::detail::DoubleAPFloat *v5;
  uint64_t result;
  void *v8;
  llvm::detail::IEEEFloat *v9;
  void *v10;
  const llvm::detail::IEEEFloat *v11;

  v2 = *(_QWORD *)a1;
  v3 = (llvm::detail::DoubleAPFloat *)(a2 + 2);
  v4 = (void *)a2[2];
  v5 = (const llvm::detail::DoubleAPFloat *)(*(_QWORD *)a1 + 8);
  if (v4 != *(void **)v5)
    return 0;
  v8 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v8 == v4)
  {
    result = llvm::detail::DoubleAPFloat::bitwiseIsEqual(v3, v5);
    if (!(_DWORD)result)
      return result;
  }
  else if (!llvm::detail::IEEEFloat::bitwiseIsEqual(v3, v5))
  {
    return 0;
  }
  v9 = (llvm::detail::IEEEFloat *)(a2 + 6);
  v10 = (void *)a2[6];
  v11 = (const llvm::detail::IEEEFloat *)(v2 + 40);
  if (v10 != *(void **)(v2 + 40))
    return 0;
  if (v8 != v10)
  {
    if (!llvm::detail::IEEEFloat::bitwiseIsEqual(v9, v11))
      return 0;
    return a2[9] == *(_QWORD *)(v2 + 64);
  }
  result = llvm::detail::DoubleAPFloat::bitwiseIsEqual(v9, v11);
  if ((_DWORD)result)
    return a2[9] == *(_QWORD *)(v2 + 64);
  return result;
}

_QWORD *llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t a1, uint64_t *a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = mlir::complex::detail::NumberAttrStorage::construct(a2, *(_QWORD **)a1);
  v4 = *(_QWORD *)(a1 + 8);
  if (*(_QWORD *)v4)
    (*(void (**)(_QWORD, _QWORD *))v4)(*(_QWORD *)(v4 + 8), v3);
  return v3;
}

_QWORD *mlir::complex::detail::NumberAttrStorage::construct(uint64_t *a1, _QWORD *a2)
{
  _QWORD *v4;
  void *v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unsigned int v11;
  uint64_t v12;
  char *buffer;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD v18[3];
  _QWORD v19[3];
  _QWORD v20[3];
  _QWORD v21[4];

  v21[3] = *MEMORY[0x1E0C80C00];
  v4 = a2 + 1;
  v5 = (void *)a2[1];
  v6 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
  if (v6 == v5)
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v21, v4);
  else
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v21, (uint64_t)v4);
  v7 = a2 + 5;
  if (v6 == (void *)a2[5])
  {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v20, v7);
    v8 = a2[8];
    a1[10] += 80;
    v9 = *a1;
    if (!*a1)
      goto LABEL_10;
  }
  else
  {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v20, (uint64_t)v7);
    v8 = a2[8];
    a1[10] += 80;
    v9 = *a1;
    if (!*a1)
      goto LABEL_10;
  }
  if (((v9 + 7) & 0xFFFFFFFFFFFFFFF8) - v9 + 80 <= a1[1] - v9)
  {
    v10 = (_QWORD *)((v9 + 7) & 0xFFFFFFFFFFFFFFF8);
    goto LABEL_15;
  }
LABEL_10:
  v11 = *((_DWORD *)a1 + 6) >> 7;
  if (v11 >= 0x1E)
    LOBYTE(v11) = 30;
  v12 = 4096 << v11;
  buffer = (char *)llvm::allocate_buffer(4096 << v11, (std::align_val_t)8uLL);
  v14 = *((unsigned int *)a1 + 6);
  if (v14 >= *((_DWORD *)a1 + 7))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(a1 + 2), a1 + 4, v14 + 1, 8);
    LODWORD(v14) = *((_DWORD *)a1 + 6);
  }
  *(_QWORD *)(a1[2] + 8 * v14) = buffer;
  ++*((_DWORD *)a1 + 6);
  a1[1] = (uint64_t)&buffer[v12];
  v10 = (_QWORD *)((unint64_t)(buffer + 7) & 0xFFFFFFFFFFFFFFF8);
LABEL_15:
  *a1 = (uint64_t)(v10 + 10);
  if (v6 == (void *)v21[0])
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v19, v21);
  else
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v19, (uint64_t)v21);
  if (v6 == (void *)v20[0])
  {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v18, v20);
    *v10 = 0;
    v15 = v10 + 2;
    if (v6 != (void *)v19[0])
    {
LABEL_20:
      llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v15, (uint64_t)v19);
      v16 = v10 + 6;
      if (v6 != (void *)v18[0])
        goto LABEL_21;
      goto LABEL_29;
    }
  }
  else
  {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v18, (uint64_t)v20);
    *v10 = 0;
    v15 = v10 + 2;
    if (v6 != (void *)v19[0])
      goto LABEL_20;
  }
  llvm::detail::DoubleAPFloat::DoubleAPFloat(v15, v19);
  v16 = v10 + 6;
  if (v6 != (void *)v18[0])
  {
LABEL_21:
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v16, (uint64_t)v18);
    v10[9] = v8;
    if (v6 != (void *)v18[0])
      goto LABEL_22;
    goto LABEL_30;
  }
LABEL_29:
  llvm::detail::DoubleAPFloat::DoubleAPFloat(v16, v18);
  v10[9] = v8;
  if (v6 != (void *)v18[0])
  {
LABEL_22:
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v18);
    if (v6 != (void *)v19[0])
      goto LABEL_23;
    goto LABEL_31;
  }
LABEL_30:
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v18);
  if (v6 != (void *)v19[0])
  {
LABEL_23:
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v19);
    if (v6 != (void *)v20[0])
      goto LABEL_24;
LABEL_32:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v20);
    if (v6 != (void *)v21[0])
      goto LABEL_25;
LABEL_33:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v21);
    return v10;
  }
LABEL_31:
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v19);
  if (v6 == (void *)v20[0])
    goto LABEL_32;
LABEL_24:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v20);
  if (v6 == (void *)v21[0])
    goto LABEL_33;
LABEL_25:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v21);
  return v10;
}

_QWORD *_ZN4llvm12function_refIFvPN4mlir7complex6detail17NumberAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_10NumberAttrEJRKNS_7APFloatESF_RNS1_4TypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESK_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSM_E_EEvlS5_(uint64_t *a1, _QWORD *a2)
{
  return mlir::detail::AttributeUniquer::initializeAttributeStorage(a2, a1[1], *a1);
}

void llvm::function_ref<void ()(mlir::StorageUniquer::BaseStorage *)>::callback_fn<void mlir::StorageUniquer::registerParametricStorageType<mlir::complex::detail::NumberAttrStorage>(mlir::TypeID)::{lambda(mlir::StorageUniquer::BaseStorage *)#1}>(llvm::APFloatBase *a1, uint64_t a2)
{
  llvm::detail::DoubleAPFloat *v3;
  void *v4;
  void *v5;
  llvm::detail::IEEEFloat *v6;

  v3 = (llvm::detail::DoubleAPFloat *)(a2 + 48);
  v4 = *(void **)(a2 + 48);
  v5 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v5 == v4)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat(v3);
    v6 = (llvm::detail::IEEEFloat *)(a2 + 16);
    if (v5 != *(void **)(a2 + 16))
      goto LABEL_3;
  }
  else
  {
    llvm::detail::IEEEFloat::~IEEEFloat(v3);
    v6 = (llvm::detail::IEEEFloat *)(a2 + 16);
    if (v5 != *(void **)(a2 + 16))
    {
LABEL_3:
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      return;
    }
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
}

uint64_t mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  const llvm::detail::DoubleAPFloat *v11;
  void *v12;
  void *v13;
  const llvm::detail::DoubleAPFloat *v14;
  unsigned int v15;
  uint64_t ParametricStorageTypeImpl;
  _QWORD v18[2];
  _BYTE *v19;
  _QWORD v20[2];
  _BYTE v21[8];
  _QWORD v22[3];
  uint64_t v23;
  _QWORD v24[3];
  _QWORD v25[2];

  v25[1] = *MEMORY[0x1E0C80C00];
  v20[0] = a2;
  v20[1] = a3;
  v11 = (const llvm::detail::DoubleAPFloat *)(a5 + 8);
  v12 = *(void **)(a5 + 8);
  v13 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v13 == v12)
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v22, v11);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v22, v11);
  v14 = (const llvm::detail::DoubleAPFloat *)(a6 + 8);
  if (v13 == *(void **)(a6 + 8))
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v24, v14);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v24, v14);
  v25[0] = *a7;
  v15 = llvm::hash_combine<llvm::APFloat,llvm::APFloat,mlir::Type>((llvm *)v21, (const llvm::APFloat *)&v23, v25);
  v18[0] = v21;
  v18[1] = v20;
  v19 = v21;
  ParametricStorageTypeImpl = mlir::StorageUniquer::getParametricStorageTypeImpl((unsigned __int8 **)a1, a4, v15, (uint64_t (*)(uint64_t))llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, (uint64_t)&v19, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, (uint64_t)v18);
  if (v13 == (void *)v24[0])
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v24);
    if (v13 != (void *)v22[0])
      goto LABEL_9;
LABEL_12:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v22);
    return ParametricStorageTypeImpl;
  }
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v24);
  if (v13 == (void *)v22[0])
    goto LABEL_12;
LABEL_9:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v22);
  return ParametricStorageTypeImpl;
}

uint64_t llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>(llvm::APFloatBase *a1, _QWORD *a2)
{
  uint64_t v2;
  llvm::detail::DoubleAPFloat *v3;
  void *v4;
  const llvm::detail::DoubleAPFloat *v5;
  uint64_t result;
  void *v8;
  llvm::detail::IEEEFloat *v9;
  void *v10;
  const llvm::detail::IEEEFloat *v11;

  v2 = *(_QWORD *)a1;
  v3 = (llvm::detail::DoubleAPFloat *)(a2 + 2);
  v4 = (void *)a2[2];
  v5 = (const llvm::detail::DoubleAPFloat *)(*(_QWORD *)a1 + 8);
  if (v4 != *(void **)v5)
    return 0;
  v8 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v8 == v4)
  {
    result = llvm::detail::DoubleAPFloat::bitwiseIsEqual(v3, v5);
    if (!(_DWORD)result)
      return result;
  }
  else if (!llvm::detail::IEEEFloat::bitwiseIsEqual(v3, v5))
  {
    return 0;
  }
  v9 = (llvm::detail::IEEEFloat *)(a2 + 6);
  v10 = (void *)a2[6];
  v11 = (const llvm::detail::IEEEFloat *)(v2 + 40);
  if (v10 != *(void **)(v2 + 40))
    return 0;
  if (v8 != v10)
  {
    if (!llvm::detail::IEEEFloat::bitwiseIsEqual(v9, v11))
      return 0;
    return a2[9] == *(_QWORD *)(v2 + 64);
  }
  result = llvm::detail::DoubleAPFloat::bitwiseIsEqual(v9, v11);
  if ((_DWORD)result)
    return a2[9] == *(_QWORD *)(v2 + 64);
  return result;
}

_QWORD *llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t a1, uint64_t *a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = mlir::complex::detail::NumberAttrStorage::construct(a2, *(_QWORD **)a1);
  v4 = *(_QWORD *)(a1 + 8);
  if (*(_QWORD *)v4)
    (*(void (**)(_QWORD, _QWORD *))v4)(*(_QWORD *)(v4 + 8), v3);
  return v3;
}

_QWORD *_ZN4llvm12function_refIFvPN4mlir7complex6detail17NumberAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_10NumberAttrEJRNS_7APFloatESE_RNS1_11ComplexTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESJ_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSL_E_EEvlS5_(uint64_t *a1, _QWORD *a2)
{
  return mlir::detail::AttributeUniquer::initializeAttributeStorage(a2, a1[1], *a1);
}

const char *mlir::cf::ControlFlowDialect::initialize(mlir::cf::ControlFlowDialect *this)
{
  char *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  const char *result;
  int v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  unint64_t v18;

  mlir::Dialect::addOperations<mlir::cf::AssertOp,mlir::cf::BranchOp,mlir::cf::CondBranchOp,mlir::cf::SwitchOp>((uint64_t)this);
  v2 = (char *)operator new(0x18uLL);
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v16 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v8 = v7;
    v2 = v16;
    if (v8)
    {
      v17 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DialectInlinerInterface]";
      v18 = 79;
      v9 = llvm::StringRef::find((uint64_t *)&v17, "DesiredTypeName = ", 0x12uLL, 0);
      if (v18 >= v9)
        v10 = v9;
      else
        v10 = v18;
      v11 = &v17[v10];
      v12 = v18 - v10;
      if (v18 - v10 >= 0x12)
        v13 = 18;
      else
        v13 = v18 - v10;
      v14 = v12 - v13;
      if (v14 >= v14 - 1)
        v15 = v14 - 1;
      else
        v15 = v14;
      mlir::detail::TypeIDResolver<mlir::DialectInlinerInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v11[v13], v15);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v16;
    }
  }
  v5 = v4[157];
  *((_QWORD *)v2 + 1) = this;
  *((_QWORD *)v2 + 2) = v5;
  *(_QWORD *)v2 = off_1E0E19A78;
  v17 = v2;
  mlir::Dialect::addInterface((uint64_t)this, (uint64_t *)&v17);
  result = v17;
  v17 = 0;
  if (result)
    return (const char *)(*(uint64_t (**)(const char *))(*(_QWORD *)result + 8))(result);
  return result;
}

mlir::cf::ControlFlowDialect *mlir::cf::ControlFlowDialect::ControlFlowDialect(mlir::cf::ControlFlowDialect *this, mlir::MLIRContext *a2)
{
  _QWORD *v3;
  uint64_t *v4;
  uint64_t *v6;

  v3 = (_QWORD *)mlir::Dialect::Dialect((uint64_t)this, (uint64_t)"cf", 2, (uint64_t)a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::cf::ControlFlowDialect,void>::id);
  *v3 = off_1E0E47E30;
  v4 = (uint64_t *)v3[4];
  if (!mlir::MLIRContext::isDialectLoading(v4, (uint64_t)"arith", 5))
  {
    v6 = v4;
    mlir::MLIRContext::getOrLoadDialect(v4, (uint64_t)"arith", 5, (uint64_t)&mlir::detail::TypeIDResolver<mlir::arith::ArithDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::arith::ArithDialect * mlir::MLIRContext::getOrLoadDialect<mlir::arith::ArithDialect>(void)::{lambda(void)#1}>, (uint64_t)&v6);
  }
  mlir::cf::ControlFlowDialect::initialize(this);
  return this;
}

void mlir::cf::ControlFlowDialect::~ControlFlowDialect(llvm **this)
{
  mlir::Dialect::~Dialect(this);
}

void sub_18036C770(void *__p)
{
  operator delete(__p);
}

uint64_t mlir::Dialect::addOperations<mlir::cf::AssertOp,mlir::cf::BranchOp,mlir::cf::CondBranchOp,mlir::cf::SwitchOp>(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t result;
  _QWORD *v8;

  mlir::RegisteredOperationName::insert<mlir::cf::AssertOp>(a1);
  v2 = operator new(0x70uLL);
  v8 = mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::Model(v2, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  v3 = (uint64_t)v8;
  v8 = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = operator new(0x70uLL);
  v8 = mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::Model(v4, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, (uint64_t)&mlir::cf::CondBranchOp::getAttributeNames(void)::attrNames, 1);
  v5 = (uint64_t)v8;
  v8 = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = operator new(0x70uLL);
  v8 = mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::Model(v6, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, (uint64_t)&mlir::cf::SwitchOp::getAttributeNames(void)::attrNames, 3);
  result = (uint64_t)v8;
  v8 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t mlir::cf::AssertOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  BOOL (*v6)(llvm::APInt *);
  uint64_t v7;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 24);
  v6 = mlir::m_One(void)::{lambda(llvm::APInt const&)#1}::__invoke;
  v7 = v4;
  result = mlir::Value::getDefiningOp((mlir::Value *)&v7);
  if (result)
  {
    result = mlir::detail::constant_int_predicate_matcher::match((uint64_t (**)(void **))&v6, (mlir::Operation *)result);
    if ((_DWORD)result)
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, a1);
      return 1;
    }
  }
  return result;
}

uint64_t mlir::cf::BranchOp::canonicalize(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v10;
  void *v11;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  uint64_t v17;
  const double *v18;
  unsigned __int128 *v19;
  unint64_t v20;
  const double *v21;
  unsigned __int128 v22;
  unsigned __int128 v23;
  unint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  _BYTE v31[48];
  uint64_t v32[3];

  v32[2] = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned int *)(a1 + 44);
  v5 = *(_QWORD **)(((a1 + 16 * ((v4 >> 23) & 1) + ((v4 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 24);
  v6 = *(_QWORD *)(a1 + 16);
  if (v5 != (_QWORD *)v6 && *v5 && !*(_QWORD *)*v5)
  {
    if ((v4 & 0x800000) != 0)
    {
      v13 = *(_QWORD *)(a1 + 72);
      v14 = *(unsigned int *)(a1 + 68);
      v29 = v31;
      v30 = 0x600000000;
      if (v14 >= 7)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v29, v31, v14, 8);
        v15 = (char *)v29 + 8 * v30;
        if (v14 >= 0xD
          && ((unint64_t)v15 >= v13 + 32 * v14
           || v13 + 24 >= (unint64_t)v29 + 8 * v30 + 8 * v14))
        {
          v17 = v14 & 3;
          if ((v14 & 3) == 0)
            v17 = 4;
          v16 = v14 - v17;
          v15 += 8 * v16;
          v18 = (const double *)(v13 + 88);
          v19 = (unsigned __int128 *)((char *)v29 + 8 * v30 + 16);
          v20 = v16;
          do
          {
            v21 = v18 - 8;
            v22 = (unsigned __int128)vld4q_f64(v21);
            v23 = (unsigned __int128)vld4q_f64(v18);
            *(v19 - 1) = v22;
            *v19 = v23;
            v18 += 16;
            v19 += 2;
            v20 -= 4;
          }
          while (v20);
          goto LABEL_26;
        }
LABEL_21:
        v16 = 0;
LABEL_26:
        v24 = v14 - v16;
        v25 = (uint64_t *)(v13 + 32 * v16 + 24);
        do
        {
          v26 = *v25;
          v25 += 4;
          *(_QWORD *)v15 = v26;
          v15 += 8;
          --v24;
        }
        while (v24);
        v27 = v30;
        goto LABEL_29;
      }
      if ((_DWORD)v14)
      {
        v15 = v31;
        goto LABEL_21;
      }
      v27 = 0;
    }
    else
    {
      LODWORD(v14) = 0;
      v27 = 0;
      v29 = v31;
      HIDWORD(v30) = 6;
    }
LABEL_29:
    LODWORD(v30) = v27 + v14;
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 40))(a2, a1);
    mlir::ValueRange::ValueRange((unint64_t *)v32, (uint64_t)v29, v30);
    mlir::RewriterBase::mergeBlocks(a2, (uint64_t)v5, v6, v32[0], v32[1]);
    if (v29 != v31)
      free(v29);
    return 1;
  }
  v28 = *(_QWORD *)(((a1 + 16 * ((v4 >> 23) & 1) + ((v4 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 24);
  if ((v4 & 0x800000) != 0)
  {
    v7 = *(_QWORD *)(a1 + 72);
    v8 = *(unsigned int *)(a1 + 68);
  }
  else
  {
    v7 = 0;
    v8 = 0;
  }
  mlir::ValueRange::ValueRange((unint64_t *)v32, v7, v8);
  v29 = v31;
  v30 = 0x400000000;
  if (v5 != *(_QWORD **)(a1 + 16) && collapseBranch(&v28, v32, (uint64_t)&v29))
  {
    v9 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *&,mlir::ValueRange &>((mlir::OpBuilder *)(a2 + 8), *(_QWORD *)(a1 + 24), &v28, v32);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a2 + 32))(a2, a1, v9);
    v10 = 1;
    v11 = v29;
    if (v29 == v31)
      return v10;
    goto LABEL_11;
  }
  v10 = 0;
  v11 = v29;
  if (v29 != v31)
LABEL_11:
    free(v11);
  return v10;
}

void mlir::cf::CondBranchOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  unsigned int *v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int *v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  const char *v45;
  unint64_t v46;
  uint64_t v47;
  const char *v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  char *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  unsigned int *v72;
  unint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  const char *v82;
  unint64_t v83;
  char *v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  char *v90;
  char *v91;
  char *v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  unsigned int *v106;
  unint64_t v107;
  unint64_t v108;
  char *v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  const char *v113;
  unint64_t v114;
  uint64_t v115;
  const char *v116;
  unint64_t v117;
  char *v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  char *v123;
  char *v124;
  char *v125;
  char *v126;
  unint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  char *v131;
  char *v132;
  uint64_t v133;
  __int128 v134;
  __int128 v135;
  uint64_t v136;
  char *v137;
  uint64_t v138;
  uint64_t v139;
  unsigned int *v140;
  unint64_t v141;
  unint64_t v142;
  char *v143;
  uint64_t v144;
  unint64_t v145;
  unint64_t v146;
  const char *v147;
  unint64_t v148;
  uint64_t v149;
  const char *v150;
  unint64_t v151;
  char *v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  unint64_t v156;
  char *v157;
  char *v158;
  char *v159;
  char *v160;
  unint64_t v161;
  uint64_t v162;
  uint64_t v163;
  char *v164;
  char *v165;
  char *v166;
  uint64_t v167;
  __int128 v168;
  __int128 v169;
  uint64_t v170;
  char *v171;
  uint64_t v172;
  uint64_t v173;
  const char *v174;
  unint64_t v175;

  v4 = (unsigned int *)operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v174, 1);
  mlir::Pattern::Pattern((uint64_t)(v4 + 2), (uint64_t)"cf.cond_br", 10, (__int16)v174, a2, 0, 0);
  *(_QWORD *)v4 = off_1E0E19D88;
  if (*((_QWORD *)v4 + 9))
  {
    v5 = v4[22];
    if (v5 <= v4[23])
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v4 + 20), v4 + 24, v5, 16);
    v4[22] = v4[22];
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v174 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::SimplifyConstCondBranchPred]";
  v175 = 100;
  v9 = llvm::StringRef::find((uint64_t *)&v174, "DesiredTypeName = ", 0x12uLL, 0);
  if (v175 >= v9)
    v10 = v9;
  else
    v10 = v175;
  v11 = &v174[v10];
  v12 = v175 - v10;
  if (v175 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v175 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *((_QWORD *)v4 + 8) = v14;
  *((_QWORD *)v4 + 9) = v15;
  v5 = v4[22];
  if (v5 > v4[23])
    goto LABEL_14;
LABEL_3:
  v4[22] = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    goto LABEL_192;
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      goto LABEL_193;
    v21 = (char *)operator new(8 * v20);
    v22 = &v21[8 * v17];
    v23 = &v21[8 * v20];
    *(_QWORD *)v22 = v4;
    v8 = (uint64_t)(v22 + 8);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (char *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v22 && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_196;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 -= v27;
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_196:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *((_QWORD *)v22 - 1) = v34;
          v22 -= 8;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
  v38 = (unsigned int *)operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v174, 1);
  mlir::Pattern::Pattern((uint64_t)(v38 + 2), (uint64_t)"cf.cond_br", 10, (__int16)v174, a2, 0, 0);
  *(_QWORD *)v38 = off_1E0E19F18;
  if (*((_QWORD *)v38 + 9))
  {
    v39 = v38[22];
    if (v39 <= v38[23])
      goto LABEL_41;
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v38 + 20), v38 + 24, v39, 16);
    v38[22] = v38[22];
    v41 = (char *)a1[2];
    v40 = a1[3];
    if ((unint64_t)v41 < v40)
      goto LABEL_42;
    goto LABEL_53;
  }
  v174 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::SimplifyPassThroughCondBranch]";
  v175 = 102;
  v43 = llvm::StringRef::find((uint64_t *)&v174, "DesiredTypeName = ", 0x12uLL, 0);
  if (v175 >= v43)
    v44 = v43;
  else
    v44 = v175;
  v45 = &v174[v44];
  v46 = v175 - v44;
  if (v175 - v44 >= 0x12)
    v47 = 18;
  else
    v47 = v175 - v44;
  v48 = &v45[v47];
  v49 = v46 - v47;
  if (v49 >= v49 - 1)
    --v49;
  *((_QWORD *)v38 + 8) = v48;
  *((_QWORD *)v38 + 9) = v49;
  v39 = v38[22];
  if (v39 > v38[23])
    goto LABEL_52;
LABEL_41:
  v38[22] = v39;
  v41 = (char *)a1[2];
  v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(_QWORD *)v41 = v38;
    v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  v50 = (char *)a1[1];
  v51 = (v41 - v50) >> 3;
  v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61)
    goto LABEL_192;
  v53 = v40 - (_QWORD)v50;
  if (v53 >> 2 > v52)
    v52 = v53 >> 2;
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8)
    v54 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v54 = v52;
  if (v54)
  {
    if (v54 >> 61)
      goto LABEL_193;
    v55 = (char *)operator new(8 * v54);
    v56 = &v55[8 * v51];
    v57 = &v55[8 * v54];
    *(_QWORD *)v56 = v38;
    v42 = (uint64_t)(v56 + 8);
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
      goto LABEL_62;
  }
  else
  {
    v55 = 0;
    v56 = (char *)(8 * v51);
    v57 = 0;
    *(_QWORD *)(8 * v51) = v38;
    v42 = 8 * v51 + 8;
    v58 = (char *)(v41 - v50);
    if (v41 != v50)
    {
LABEL_62:
      v59 = (unint64_t)(v58 - 8);
      if (v59 < 0x78
        || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v56 && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
      {
        goto LABEL_197;
      }
      v60 = (v59 >> 3) + 1;
      v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      v62 = &v41[-v61];
      v56 -= v61;
      v63 = &v55[8 * v51 - 16];
      v64 = v41 - 16;
      v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v67 = *((_OWORD *)v64 - 1);
        v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      v41 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_197:
        do
        {
          v68 = *((_QWORD *)v41 - 1);
          v41 -= 8;
          *(_QWORD *)v41 = 0;
          *((_QWORD *)v56 - 1) = v68;
          v56 -= 8;
        }
        while (v41 != v50);
      }
      v41 = (char *)a1[1];
      v69 = (char *)a1[2];
      a1[1] = v56;
      a1[2] = v42;
      a1[3] = v57;
      while (v69 != v41)
      {
        v71 = *((_QWORD *)v69 - 1);
        v69 -= 8;
        v70 = v71;
        *(_QWORD *)v69 = 0;
        if (v71)
          (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
      }
      goto LABEL_75;
    }
  }
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41)
    operator delete(v41);
LABEL_77:
  a1[2] = v42;
  v72 = (unsigned int *)operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v174, 1);
  mlir::Pattern::Pattern((uint64_t)(v72 + 2), (uint64_t)"cf.cond_br", 10, (__int16)v174, a2, 0, 0);
  *(_QWORD *)v72 = off_1E0E1A360;
  if (*((_QWORD *)v72 + 9))
  {
    v73 = v72[22];
    if (v73 <= v72[23])
      goto LABEL_79;
LABEL_90:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v72 + 20), v72 + 24, v73, 16);
    v72[22] = v72[22];
    v75 = (char *)a1[2];
    v74 = a1[3];
    if ((unint64_t)v75 < v74)
      goto LABEL_80;
    goto LABEL_91;
  }
  v174 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors]";
  v175 = 110;
  v77 = llvm::StringRef::find((uint64_t *)&v174, "DesiredTypeName = ", 0x12uLL, 0);
  if (v175 >= v77)
    v78 = v77;
  else
    v78 = v175;
  v79 = &v174[v78];
  v80 = v175 - v78;
  if (v175 - v78 >= 0x12)
    v81 = 18;
  else
    v81 = v175 - v78;
  v82 = &v79[v81];
  v83 = v80 - v81;
  if (v83 >= v83 - 1)
    --v83;
  *((_QWORD *)v72 + 8) = v82;
  *((_QWORD *)v72 + 9) = v83;
  v73 = v72[22];
  if (v73 > v72[23])
    goto LABEL_90;
LABEL_79:
  v72[22] = v73;
  v75 = (char *)a1[2];
  v74 = a1[3];
  if ((unint64_t)v75 < v74)
  {
LABEL_80:
    *(_QWORD *)v75 = v72;
    v76 = (uint64_t)(v75 + 8);
    goto LABEL_115;
  }
LABEL_91:
  v84 = (char *)a1[1];
  v85 = (v75 - v84) >> 3;
  v86 = v85 + 1;
  if ((unint64_t)(v85 + 1) >> 61)
    goto LABEL_192;
  v87 = v74 - (_QWORD)v84;
  if (v87 >> 2 > v86)
    v86 = v87 >> 2;
  if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
    v88 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v88 = v86;
  if (v88)
  {
    if (v88 >> 61)
      goto LABEL_193;
    v89 = (char *)operator new(8 * v88);
    v90 = &v89[8 * v85];
    v91 = &v89[8 * v88];
    *(_QWORD *)v90 = v72;
    v76 = (uint64_t)(v90 + 8);
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
      goto LABEL_100;
  }
  else
  {
    v89 = 0;
    v90 = (char *)(8 * v85);
    v91 = 0;
    *(_QWORD *)(8 * v85) = v72;
    v76 = 8 * v85 + 8;
    v92 = (char *)(v75 - v84);
    if (v75 != v84)
    {
LABEL_100:
      v93 = (unint64_t)(v92 - 8);
      if (v93 < 0x78
        || &v75[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v90 && &v89[v75 - v84 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v75)
      {
        goto LABEL_198;
      }
      v94 = (v93 >> 3) + 1;
      v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
      v96 = &v75[-v95];
      v90 -= v95;
      v97 = &v89[8 * v85 - 16];
      v98 = v75 - 16;
      v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v101 = *((_OWORD *)v98 - 1);
        v100 = *(_OWORD *)v98;
        *((_OWORD *)v98 - 1) = 0uLL;
        *(_OWORD *)v98 = 0uLL;
        *((_OWORD *)v97 - 1) = v101;
        *(_OWORD *)v97 = v100;
        v97 -= 32;
        v98 -= 32;
        v99 -= 4;
      }
      while (v99);
      v75 = v96;
      if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_198:
        do
        {
          v102 = *((_QWORD *)v75 - 1);
          v75 -= 8;
          *(_QWORD *)v75 = 0;
          *((_QWORD *)v90 - 1) = v102;
          v90 -= 8;
        }
        while (v75 != v84);
      }
      v75 = (char *)a1[1];
      v103 = (char *)a1[2];
      a1[1] = v90;
      a1[2] = v76;
      a1[3] = v91;
      while (v103 != v75)
      {
        v105 = *((_QWORD *)v103 - 1);
        v103 -= 8;
        v104 = v105;
        *(_QWORD *)v103 = 0;
        if (v105)
          (*(void (**)(uint64_t))(*(_QWORD *)v104 + 8))(v104);
      }
      goto LABEL_113;
    }
  }
  a1[1] = v90;
  a1[2] = v76;
  a1[3] = v91;
LABEL_113:
  if (v75)
    operator delete(v75);
LABEL_115:
  a1[2] = v76;
  v106 = (unsigned int *)operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v174, 1);
  mlir::Pattern::Pattern((uint64_t)(v106 + 2), (uint64_t)"cf.cond_br", 10, (__int16)v174, a2, 0, 0);
  *(_QWORD *)v106 = off_1E0E1A5D8;
  if (*((_QWORD *)v106 + 9))
  {
    v107 = v106[22];
    if (v107 <= v106[23])
      goto LABEL_117;
LABEL_128:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v106 + 20), v106 + 24, v107, 16);
    v106[22] = v106[22];
    v109 = (char *)a1[2];
    v108 = a1[3];
    if ((unint64_t)v109 < v108)
      goto LABEL_118;
    goto LABEL_129;
  }
  v174 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition]";
  v175 = 120;
  v111 = llvm::StringRef::find((uint64_t *)&v174, "DesiredTypeName = ", 0x12uLL, 0);
  if (v175 >= v111)
    v112 = v111;
  else
    v112 = v175;
  v113 = &v174[v112];
  v114 = v175 - v112;
  if (v175 - v112 >= 0x12)
    v115 = 18;
  else
    v115 = v175 - v112;
  v116 = &v113[v115];
  v117 = v114 - v115;
  if (v117 >= v117 - 1)
    --v117;
  *((_QWORD *)v106 + 8) = v116;
  *((_QWORD *)v106 + 9) = v117;
  v107 = v106[22];
  if (v107 > v106[23])
    goto LABEL_128;
LABEL_117:
  v106[22] = v107;
  v109 = (char *)a1[2];
  v108 = a1[3];
  if ((unint64_t)v109 < v108)
  {
LABEL_118:
    *(_QWORD *)v109 = v106;
    v110 = (uint64_t)(v109 + 8);
    goto LABEL_153;
  }
LABEL_129:
  v118 = (char *)a1[1];
  v119 = (v109 - v118) >> 3;
  v120 = v119 + 1;
  if ((unint64_t)(v119 + 1) >> 61)
    goto LABEL_192;
  v121 = v108 - (_QWORD)v118;
  if (v121 >> 2 > v120)
    v120 = v121 >> 2;
  if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFF8)
    v122 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v122 = v120;
  if (v122)
  {
    if (v122 >> 61)
      goto LABEL_193;
    v123 = (char *)operator new(8 * v122);
    v124 = &v123[8 * v119];
    v125 = &v123[8 * v122];
    *(_QWORD *)v124 = v106;
    v110 = (uint64_t)(v124 + 8);
    v126 = (char *)(v109 - v118);
    if (v109 != v118)
      goto LABEL_138;
  }
  else
  {
    v123 = 0;
    v124 = (char *)(8 * v119);
    v125 = 0;
    *(_QWORD *)(8 * v119) = v106;
    v110 = 8 * v119 + 8;
    v126 = (char *)(v109 - v118);
    if (v109 != v118)
    {
LABEL_138:
      v127 = (unint64_t)(v126 - 8);
      if (v127 < 0x78
        || &v109[-(v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v124
        && &v123[v109 - v118 - (v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v109)
      {
        goto LABEL_199;
      }
      v128 = (v127 >> 3) + 1;
      v129 = 8 * (v128 & 0x3FFFFFFFFFFFFFFCLL);
      v130 = &v109[-v129];
      v124 -= v129;
      v131 = &v123[8 * v119 - 16];
      v132 = v109 - 16;
      v133 = v128 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v135 = *((_OWORD *)v132 - 1);
        v134 = *(_OWORD *)v132;
        *((_OWORD *)v132 - 1) = 0uLL;
        *(_OWORD *)v132 = 0uLL;
        *((_OWORD *)v131 - 1) = v135;
        *(_OWORD *)v131 = v134;
        v131 -= 32;
        v132 -= 32;
        v133 -= 4;
      }
      while (v133);
      v109 = v130;
      if (v128 != (v128 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_199:
        do
        {
          v136 = *((_QWORD *)v109 - 1);
          v109 -= 8;
          *(_QWORD *)v109 = 0;
          *((_QWORD *)v124 - 1) = v136;
          v124 -= 8;
        }
        while (v109 != v118);
      }
      v109 = (char *)a1[1];
      v137 = (char *)a1[2];
      a1[1] = v124;
      a1[2] = v110;
      a1[3] = v125;
      while (v137 != v109)
      {
        v139 = *((_QWORD *)v137 - 1);
        v137 -= 8;
        v138 = v139;
        *(_QWORD *)v137 = 0;
        if (v139)
          (*(void (**)(uint64_t))(*(_QWORD *)v138 + 8))(v138);
      }
      goto LABEL_151;
    }
  }
  a1[1] = v124;
  a1[2] = v110;
  a1[3] = v125;
LABEL_151:
  if (v109)
    operator delete(v109);
LABEL_153:
  a1[2] = v110;
  v140 = (unsigned int *)operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v174, 1);
  mlir::Pattern::Pattern((uint64_t)(v140 + 2), (uint64_t)"cf.cond_br", 10, (__int16)v174, a2, 0, 0);
  *(_QWORD *)v140 = off_1E0E196F0;
  if (*((_QWORD *)v140 + 9))
  {
    v141 = v140[22];
    if (v141 <= v140[23])
      goto LABEL_155;
LABEL_166:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v140 + 20), v140 + 24, v141, 16);
    v140[22] = v140[22];
    v143 = (char *)a1[2];
    v142 = a1[3];
    if ((unint64_t)v143 < v142)
      goto LABEL_156;
    goto LABEL_167;
  }
  v174 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::CondBranchTruthPropagation]";
  v175 = 99;
  v145 = llvm::StringRef::find((uint64_t *)&v174, "DesiredTypeName = ", 0x12uLL, 0);
  if (v175 >= v145)
    v146 = v145;
  else
    v146 = v175;
  v147 = &v174[v146];
  v148 = v175 - v146;
  if (v175 - v146 >= 0x12)
    v149 = 18;
  else
    v149 = v175 - v146;
  v150 = &v147[v149];
  v151 = v148 - v149;
  if (v151 >= v151 - 1)
    --v151;
  *((_QWORD *)v140 + 8) = v150;
  *((_QWORD *)v140 + 9) = v151;
  v141 = v140[22];
  if (v141 > v140[23])
    goto LABEL_166;
LABEL_155:
  v140[22] = v141;
  v143 = (char *)a1[2];
  v142 = a1[3];
  if ((unint64_t)v143 < v142)
  {
LABEL_156:
    *(_QWORD *)v143 = v140;
    v144 = (uint64_t)(v143 + 8);
    goto LABEL_191;
  }
LABEL_167:
  v152 = (char *)a1[1];
  v153 = (v143 - v152) >> 3;
  v154 = v153 + 1;
  if ((unint64_t)(v153 + 1) >> 61)
LABEL_192:
    abort();
  v155 = v142 - (_QWORD)v152;
  if (v155 >> 2 > v154)
    v154 = v155 >> 2;
  if ((unint64_t)v155 >= 0x7FFFFFFFFFFFFFF8)
    v156 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v156 = v154;
  if (!v156)
  {
    v157 = 0;
    v158 = (char *)(8 * v153);
    v159 = 0;
    *(_QWORD *)(8 * v153) = v140;
    v144 = 8 * v153 + 8;
    v160 = (char *)(v143 - v152);
    if (v143 != v152)
      goto LABEL_176;
    goto LABEL_188;
  }
  if (v156 >> 61)
LABEL_193:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v157 = (char *)operator new(8 * v156);
  v158 = &v157[8 * v153];
  v159 = &v157[8 * v156];
  *(_QWORD *)v158 = v140;
  v144 = (uint64_t)(v158 + 8);
  v160 = (char *)(v143 - v152);
  if (v143 != v152)
  {
LABEL_176:
    v161 = (unint64_t)(v160 - 8);
    if (v161 < 0x78
      || &v143[-(v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v158
      && &v157[v143 - v152 - (v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v143)
    {
      goto LABEL_200;
    }
    v162 = (v161 >> 3) + 1;
    v163 = 8 * (v162 & 0x3FFFFFFFFFFFFFFCLL);
    v164 = &v143[-v163];
    v158 -= v163;
    v165 = &v157[8 * v153 - 16];
    v166 = v143 - 16;
    v167 = v162 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v169 = *((_OWORD *)v166 - 1);
      v168 = *(_OWORD *)v166;
      *((_OWORD *)v166 - 1) = 0uLL;
      *(_OWORD *)v166 = 0uLL;
      *((_OWORD *)v165 - 1) = v169;
      *(_OWORD *)v165 = v168;
      v165 -= 32;
      v166 -= 32;
      v167 -= 4;
    }
    while (v167);
    v143 = v164;
    if (v162 != (v162 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_200:
      do
      {
        v170 = *((_QWORD *)v143 - 1);
        v143 -= 8;
        *(_QWORD *)v143 = 0;
        *((_QWORD *)v158 - 1) = v170;
        v158 -= 8;
      }
      while (v143 != v152);
    }
    v143 = (char *)a1[1];
    v171 = (char *)a1[2];
    a1[1] = v158;
    a1[2] = v144;
    a1[3] = v159;
    while (v171 != v143)
    {
      v173 = *((_QWORD *)v171 - 1);
      v171 -= 8;
      v172 = v173;
      *(_QWORD *)v171 = 0;
      if (v173)
        (*(void (**)(uint64_t))(*(_QWORD *)v172 + 8))(v172);
    }
    goto LABEL_189;
  }
LABEL_188:
  a1[1] = v158;
  a1[2] = v144;
  a1[3] = v159;
LABEL_189:
  if (v143)
    operator delete(v143);
LABEL_191:
  a1[2] = v144;
}

void mlir::cf::CondBranchOp::getSuccessorOperands(mlir::cf::CondBranchOp *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  int *v6;
  int v7;
  int v8;
  uint64_t v9;
  mlir::MLIRContext *Context;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  mlir::MLIRContext *v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  int v18;
  __int128 v19;
  uint64_t v20[2];
  void *v21;
  _QWORD v22[4];

  v22[3] = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)this;
  if (HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v6 = (int *)(*(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  v7 = *v6;
  v8 = v6[1];
  if (a2)
  {
    v7 += v8;
    v8 = v6[2];
    v9 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 96) + 8 * *(_QWORD *)(*(_QWORD *)(v5 + 48) + 104) - 8);
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v5 + 24));
    if (HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
      v11 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
    else
      v11 = 0;
    v12 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v11, 3);
    mlir::NamedAttribute::NamedAttribute(&v17, v9, v12);
    v18 = 2;
  }
  else
  {
    v13 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 96) + 8 * *(_QWORD *)(*(_QWORD *)(v5 + 48) + 104) - 8);
    v14 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v5 + 24));
    if (HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
      v15 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
    else
      v15 = 0;
    v16 = mlir::detail::DenseArrayAttrImpl<int>::get(v14, v15, 3);
    mlir::NamedAttribute::NamedAttribute(&v17, v13, v16);
    v18 = 1;
  }
  v19 = v17;
  mlir::MutableOperandRange::MutableOperandRange((uint64_t)v20, v5, v7, v8, &v18, 1);
  mlir::SuccessorOperands::SuccessorOperands(a3, v20);
  if (v21 != v22)
    free(v21);
}

void mlir::cf::SwitchOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  int v25;
  int v26;
  _QWORD *v27;
  uint64_t DenseI32ArrayAttr;
  unint64_t v29;
  int v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  const double *v35;
  int32x4_t v36;
  int32x4_t v37;
  const double *v38;
  unsigned __int128 v39;
  const double *v40;
  unsigned __int128 v41;
  const double *v42;
  const double *v43;
  unsigned __int128 v44;
  unsigned __int128 v45;
  _DWORD *v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  _QWORD v52[7];

  v52[6] = *MEMORY[0x1E0C80C00];
  v49 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v49, 1);
  mlir::OperationState::addOperands(a2, a4, a5);
  v18 = (uint64_t *)(a6 + 16 * a7);
  if (a7)
  {
    v48 = a5;
    a5 = a8;
    v19 = (uint64_t *)a6;
    do
    {
      v20 = *v19;
      v21 = v19[1];
      v19 += 2;
      mlir::OperationState::addOperands(a2, v20, v21);
    }
    while (v19 != v18);
    LODWORD(v22) = 0;
    v50 = v52;
    v51 = 0xC00000000;
    v23 = 16 * a7;
    v24 = (int *)(a6 + 8);
    do
    {
      v26 = *v24;
      v24 += 4;
      v25 = v26;
      if (v22 >= HIDWORD(v51))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v52, v22 + 1, 4);
        LODWORD(v22) = v51;
      }
      *((_DWORD *)v50 + v22) = v25;
      v22 = (v51 + 1);
      LODWORD(v51) = v51 + 1;
      v23 -= 16;
    }
    while (v23);
    v27 = v50;
    a8 = a5;
    LODWORD(a5) = v48;
  }
  else
  {
    v22 = 0;
    v50 = v52;
    v51 = 0xC00000000;
    v27 = v52;
  }
  DenseI32ArrayAttr = mlir::Builder::getDenseI32ArrayAttr(a1, (uint64_t)v27, v22);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>((_QWORD *)a2) = DenseI32ArrayAttr;
  if (v50 != v52)
    free(v50);
  if (a7)
  {
    v29 = (a7 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if (v29 >= 8)
    {
      v32 = v29 + 1;
      v33 = v32 & 7;
      if ((v32 & 7) == 0)
        v33 = 8;
      v34 = v32 - v33;
      v31 = a6 + 16 * v34;
      v35 = (const double *)(a6 + 72);
      v36 = 0uLL;
      v37 = 0uLL;
      do
      {
        v38 = v35 - 8;
        v39 = (unsigned __int128)vld2q_f64(v38);
        v40 = v35 - 4;
        v41 = (unsigned __int128)vld2q_f64(v40);
        v42 = v35 + 16;
        v44 = (unsigned __int128)vld2q_f64(v35);
        v43 = v35 + 4;
        v45 = (unsigned __int128)vld2q_f64(v43);
        v36 = vaddq_s32(v36, vuzp1q_s32((int32x4_t)v39, (int32x4_t)v41));
        v37 = vaddq_s32(v37, vuzp1q_s32((int32x4_t)v44, (int32x4_t)v45));
        v35 = v42;
        v34 -= 8;
      }
      while (v34);
      v30 = vaddvq_s32(vaddq_s32(v37, v36));
    }
    else
    {
      v30 = 0;
      v31 = a6;
    }
    do
    {
      v30 += *(_DWORD *)(v31 + 8);
      v31 += 16;
    }
    while ((uint64_t *)v31 != v18);
  }
  else
  {
    v30 = 0;
  }
  v46 = (_DWORD *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>((_QWORD *)a2);
  v46[4] = 1;
  v46[5] = a5;
  v46[6] = v30;
  if (a8)
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>((_QWORD *)a2)
              + 8) = a8;
  v47 = *(unsigned int *)(a2 + 208);
  if (v47 >= *(_DWORD *)(a2 + 212))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 200, (void *)(a2 + 216), v47 + 1, 8);
    LODWORD(v47) = *(_DWORD *)(a2 + 208);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 200) + 8 * v47) = a9;
  ++*(_DWORD *)(a2 + 208);
  mlir::OperationState::addSuccessors((unsigned int *)a2, a10, a11);
}

uint64_t mlir::cf::SwitchOp::verify(Operation **this)
{
  Operation *v2;
  unint64_t v3;
  const char *v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t OperandRange;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  int *v23;
  char *v24;
  char *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  uint64_t v32;
  _QWORD **v33;
  _QWORD **v34;
  void *v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  void *v39;
  void *v40;
  int *v42;
  char *v43;
  char *v44;
  __int128 v45;
  uint64_t NumElements;
  int *v47;
  char *v48;
  char *v49;
  __int128 v50;
  uint64_t v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  uint64_t v56;
  int *v57;
  char *v58;
  char *v59;
  __int128 v60;
  uint64_t v61;
  int *v62;
  char *v63;
  char *v64;
  __int128 v65;
  _QWORD **v66;
  _QWORD **v67;
  void *v68;
  _QWORD *v69;
  void *v70;
  void *v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  BOOL v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  BOOL v80;
  unint64_t v81;
  BOOL v82;
  unint64_t v83;
  BOOL v84;
  unint64_t v85;
  BOOL v86;
  int64_t v87;
  int64_t v88;
  int64_t v89;
  int64_t v90;
  int64_t v91;
  int64_t v92;
  int64_t v93;
  int64_t v94;
  int64_t v95;
  int64_t v96;
  const void **v97[4];
  __int16 v98;
  uint64_t v99;
  _BOOL8 v100;
  int v101;
  const char *v102;
  uint64_t v103;
  uint64_t Value;
  uint64_t v105;
  void *v106;
  unsigned int v107;
  unsigned int v108;
  _BYTE v109[96];
  void *v110;
  _QWORD *v111;
  void *__p;
  _QWORD **v113;
  char v114;
  uint64_t v115;

  v115 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
  else
    v3 = 0;
  v99 = *(_QWORD *)(v3 + 8);
  v100 = v99 != 0;
  mlir::SuccessorRange::SuccessorRange((unint64_t *)&Value, v2);
  mlir::SuccessorRange::SuccessorRange((unint64_t *)&Value, *this);
  v4 = (const char *)(v105 - 1);
  if (v99)
    v5 = 0;
  else
    v5 = v105 == 1;
  if (v5)
    return 1;
  v6 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)*this + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v99);
  v105 = v7;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value);
  if (OperandRange != v6)
  {
    v9 = OperandRange;
    v98 = 257;
    mlir::OpState::emitOpError((uint64_t **)this, v97, (uint64_t)&Value);
    if (Value)
    {
      v101 = 3;
      v102 = "'flag' type (";
      v103 = 13;
      v10 = &v101;
      v11 = (char *)v106;
      if (v107 >= v108)
      {
        v72 = v107 + 1;
        if (v106 <= &v101 && (char *)v106 + 24 * v107 > (char *)&v101)
        {
          v87 = (char *)&v101 - (_BYTE *)v106;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v72, 24);
          v11 = (char *)v106;
          v10 = (int *)((char *)v106 + v87);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v72, 24);
          v10 = &v101;
          v11 = (char *)v106;
        }
      }
      v12 = &v11[24 * v107];
      v13 = *(_OWORD *)v10;
      *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
      *(_OWORD *)v12 = v13;
      ++v107;
      if (Value)
      {
        v14 = &v101;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v101, v6);
        v15 = (char *)v106;
        if (v107 >= v108)
        {
          v73 = v107 + 1;
          if (v106 <= &v101 && (char *)v106 + 24 * v107 > (char *)&v101)
          {
            v88 = (char *)&v101 - (_BYTE *)v106;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v73, 24);
            v15 = (char *)v106;
            v14 = (int *)((char *)v106 + v88);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v73, 24);
            v14 = &v101;
            v15 = (char *)v106;
          }
        }
        v16 = &v15[24 * v107];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
        *(_OWORD *)v16 = v17;
        v18 = ++v107;
        if (Value)
        {
          v101 = 3;
          v102 = ") should match case value type (";
          v103 = 32;
          v19 = &v101;
          v20 = (char *)v106;
          if (v18 >= v108)
          {
            v74 = v18 + 1;
            v75 = (char *)v106 + 24 * v18 > (char *)&v101;
            if (v106 <= &v101 && v75)
            {
              v89 = (char *)&v101 - (_BYTE *)v106;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v74, 24);
              v20 = (char *)v106;
              v19 = (int *)((char *)v106 + v89);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v74, 24);
              v19 = &v101;
              v20 = (char *)v106;
            }
          }
          v21 = &v20[24 * v107];
          v22 = *(_OWORD *)v19;
          *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
          *(_OWORD *)v21 = v22;
          ++v107;
          if (Value)
          {
            v23 = &v101;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v101, v9);
            v24 = (char *)v106;
            if (v107 >= v108)
            {
              v76 = v107 + 1;
              if (v106 <= &v101 && (char *)v106 + 24 * v107 > (char *)&v101)
              {
                v90 = (char *)&v101 - (_BYTE *)v106;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v76, 24);
                v24 = (char *)v106;
                v23 = (int *)((char *)v106 + v90);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v76, 24);
                v23 = &v101;
                v24 = (char *)v106;
              }
            }
            v25 = &v24[24 * v107];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v107;
            if (Value)
            {
              v101 = 3;
              v102 = ")";
              v103 = 1;
              v28 = &v101;
              v29 = (char *)v106;
              if (v27 >= v108)
              {
                v79 = v27 + 1;
                v80 = (char *)v106 + 24 * v27 > (char *)&v101;
                if (v106 <= &v101 && v80)
                {
                  v93 = (char *)&v101 - (_BYTE *)v106;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v79, 24);
                  v29 = (char *)v106;
                  v28 = (int *)((char *)v106 + v93);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v79, 24);
                  v28 = &v101;
                  v29 = (char *)v106;
                }
              }
              v30 = &v29[24 * v107];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              ++v107;
            }
          }
        }
      }
    }
    v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    if (v114)
    {
      v33 = (_QWORD **)__p;
      if (__p)
      {
        v34 = v113;
        v35 = __p;
        if (v113 != __p)
        {
          do
            v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
          while (v34 != v33);
          v35 = __p;
        }
        v113 = v33;
        operator delete(v35);
      }
      v36 = v110;
      if (!v110)
        goto LABEL_66;
      v37 = v111;
      v38 = v110;
      if (v111 == v110)
      {
LABEL_65:
        v111 = v36;
        operator delete(v38);
LABEL_66:
        if (v106 != v109)
          free(v106);
        return v32;
      }
      do
      {
        v40 = (void *)*--v37;
        v39 = v40;
        *v37 = 0;
        if (v40)
          operator delete[](v39);
      }
      while (v37 != v36);
LABEL_64:
      v38 = v110;
      goto LABEL_65;
    }
    return v32;
  }
  if (!v100 || (const char *)mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v99) == v4)
    return 1;
  v98 = 257;
  mlir::OpState::emitOpError((uint64_t **)this, v97, (uint64_t)&Value);
  if (Value)
  {
    v101 = 3;
    v102 = "number of case values (";
    v103 = 23;
    v42 = &v101;
    v43 = (char *)v106;
    if (v107 >= v108)
    {
      v77 = v107 + 1;
      if (v106 <= &v101 && (char *)v106 + 24 * v107 > (char *)&v101)
      {
        v91 = (char *)&v101 - (_BYTE *)v106;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v77, 24);
        v43 = (char *)v106;
        v42 = (int *)((char *)v106 + v91);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v77, 24);
        v42 = &v101;
        v43 = (char *)v106;
      }
    }
    v44 = &v43[24 * v107];
    v45 = *(_OWORD *)v42;
    *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
    *(_OWORD *)v44 = v45;
    ++v107;
  }
  NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v99);
  if (Value)
  {
    v101 = 2;
    v102 = (const char *)NumElements;
    v47 = &v101;
    v48 = (char *)v106;
    if (v107 >= v108)
    {
      v78 = v107 + 1;
      if (v106 <= &v101 && (char *)v106 + 24 * v107 > (char *)&v101)
      {
        v92 = (char *)&v101 - (_BYTE *)v106;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v78, 24);
        v48 = (char *)v106;
        v47 = (int *)((char *)v106 + v92);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v78, 24);
        v47 = &v101;
        v48 = (char *)v106;
      }
    }
    v49 = &v48[24 * v107];
    v50 = *(_OWORD *)v47;
    *((_QWORD *)v49 + 2) = *((_QWORD *)v47 + 2);
    *(_OWORD *)v49 = v50;
    v51 = ++v107;
    if (Value)
    {
      v101 = 3;
      v102 = ") should match number of case destinations (";
      v103 = 44;
      v52 = &v101;
      v53 = (char *)v106;
      if (v51 >= v108)
      {
        v81 = v51 + 1;
        v82 = (char *)v106 + 24 * v51 > (char *)&v101;
        if (v106 <= &v101 && v82)
        {
          v94 = (char *)&v101 - (_BYTE *)v106;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v81, 24);
          v53 = (char *)v106;
          v52 = (int *)((char *)v106 + v94);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v81, 24);
          v52 = &v101;
          v53 = (char *)v106;
        }
      }
      v54 = &v53[24 * v107];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
      *(_OWORD *)v54 = v55;
      v56 = ++v107;
      if (Value)
      {
        v101 = 5;
        v102 = v4;
        v57 = &v101;
        v58 = (char *)v106;
        if (v56 >= v108)
        {
          v83 = v56 + 1;
          v84 = (char *)v106 + 24 * v56 > (char *)&v101;
          if (v106 <= &v101 && v84)
          {
            v95 = (char *)&v101 - (_BYTE *)v106;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v83, 24);
            v58 = (char *)v106;
            v57 = (int *)((char *)v106 + v95);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v83, 24);
            v57 = &v101;
            v58 = (char *)v106;
          }
        }
        v59 = &v58[24 * v107];
        v60 = *(_OWORD *)v57;
        *((_QWORD *)v59 + 2) = *((_QWORD *)v57 + 2);
        *(_OWORD *)v59 = v60;
        v61 = ++v107;
        if (Value)
        {
          v101 = 3;
          v102 = ")";
          v103 = 1;
          v62 = &v101;
          v63 = (char *)v106;
          if (v61 >= v108)
          {
            v85 = v61 + 1;
            v86 = (char *)v106 + 24 * v61 > (char *)&v101;
            if (v106 <= &v101 && v86)
            {
              v96 = (char *)&v101 - (_BYTE *)v106;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v85, 24);
              v63 = (char *)v106;
              v62 = (int *)((char *)v106 + v96);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v85, 24);
              v62 = &v101;
              v63 = (char *)v106;
            }
          }
          v64 = &v63[24 * v107];
          v65 = *(_OWORD *)v62;
          *((_QWORD *)v64 + 2) = *((_QWORD *)v62 + 2);
          *(_OWORD *)v64 = v65;
          ++v107;
        }
      }
    }
  }
  v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  if (v114)
  {
    v66 = (_QWORD **)__p;
    if (__p)
    {
      v67 = v113;
      v68 = __p;
      if (v113 != __p)
      {
        do
          v67 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v67 - 1);
        while (v67 != v66);
        v68 = __p;
      }
      v113 = v66;
      operator delete(v68);
    }
    v36 = v110;
    if (!v110)
      goto LABEL_66;
    v69 = v111;
    v38 = v110;
    if (v111 == v110)
      goto LABEL_65;
    do
    {
      v71 = (void *)*--v69;
      v70 = v71;
      *v69 = 0;
      if (v71)
        operator delete[](v70);
    }
    while (v69 != v36);
    goto LABEL_64;
  }
  return v32;
}

void mlir::cf::SwitchOp::getSuccessorOperands(mlir::Operation **this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  void *v6;
  mlir::Operation *v7;
  unint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  mlir::MLIRContext *Context;
  unint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16[2];
  void *v17;
  _BYTE v18[24];
  int v19;
  __int128 v20;
  _QWORD v21[8];

  v21[7] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v5 = (a2 - 1);
    mlir::cf::SwitchOp::getCaseOperandsMutable(this, (uint64_t)&v19);
    mlir::MutableOperandRangeRange::dereference((uint64_t)&v19, v21[5] + v5, (uint64_t)v16);
    if (*((_QWORD **)&v20 + 1) != v21)
      free(*((void **)&v20 + 1));
    mlir::SuccessorOperands::SuccessorOperands(a3, v16);
    v6 = v17;
    if (v17 != v18)
LABEL_5:
      free(v6);
  }
  else
  {
    v7 = *this;
    if (HIBYTE(*((_DWORD *)*this + 11)))
      v8 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
    else
      v8 = 0;
    v9 = *(_DWORD *)(v8 + 16);
    v10 = *(_DWORD *)(v8 + 20);
    v11 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)v7 + 6) + 96) + 8 * *(_QWORD *)(*((_QWORD *)v7 + 6) + 104) - 8);
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Operation *)((char *)v7 + 24));
    v13 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
    if (!HIBYTE(*((_DWORD *)*this + 11)))
      v13 = 0;
    v14 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v13 + 16, 3);
    mlir::NamedAttribute::NamedAttribute(&v15, v11, v14);
    v19 = 1;
    v20 = v15;
    mlir::MutableOperandRange::MutableOperandRange((uint64_t)v16, (uint64_t)v7, v9, v10, &v19, 1);
    mlir::SuccessorOperands::SuccessorOperands(a3, v16);
    v6 = v17;
    if (v17 != v18)
      goto LABEL_5;
  }
}

void **mlir::cf::SwitchOp::getSuccessorForOperands(Operation **a1, uint64_t *a2)
{
  Operation *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  void *v10;
  void **v11;
  uint64_t v12;
  void *v13;
  int v14;
  uint64_t v15;
  void *v16;
  _BOOL4 v17;
  uint64_t v18;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  void *__p[2];
  __int128 v24;
  void *v25;
  unsigned __int8 v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD v29[2];
  void *v30;
  unsigned int v31;

  v3 = *a1;
  v4 = *((unsigned int *)*a1 + 11);
  v5 = (uint64_t)*a1 + 16 * ((v4 >> 23) & 1) + 64;
  if (HIBYTE(*((_DWORD *)*a1 + 11)))
    v6 = (uint64_t)*a1 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v6 = 0;
  v29[0] = *(_QWORD *)(v6 + 8);
  v29[1] = v29[0] != 0;
  if (!v29[0])
  {
    v12 = v5 + ((v4 >> 21) & 0x7F8) + 7;
    return *(void ***)((v12 & 0xFFFFFFFFFFFFFFF8) + 24);
  }
  mlir::SuccessorRange::SuccessorRange((unint64_t *)__p, v3);
  v8 = __p[0];
  mlir::SuccessorRange::SuccessorRange((unint64_t *)__p, *a1);
  v9 = *a2;
  if (*a2)
  {
    v10 = *(void **)(*(_QWORD *)v9 + 136);
    if (v10 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      v9 = 0;
    v28 = v9;
    if (v10 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      v11 = __p;
      mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)v29, (uint64_t)__p);
      v21 = *(_OWORD *)__p;
      v22 = v24;
      v13 = v25;
      v14 = v26;
      v15 = v27;
      v20 = 0;
      if (__p[0] != v25 || BYTE8(v21) != v26 || (_QWORD)v22 != v27)
      {
        v16 = 0;
        do
        {
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v21, (llvm::APInt *)&v30);
          LODWORD(v24) = v31;
          __p[0] = v16;
          __p[1] = v30;
          mlir::IntegerAttr::getValue(&v28, (llvm::APInt *)&v30);
          if (v24 > 0x40)
          {
            v17 = llvm::APInt::equalSlowCase((const void **)&__p[1], (const void **)&v30);
            if (v31 < 0x41)
              goto LABEL_21;
          }
          else
          {
            v17 = __p[1] == v30;
            if (v31 < 0x41)
              goto LABEL_21;
          }
          if (v30)
            operator delete[](v30);
LABEL_21:
          if (v17)
            v11 = (void **)v8[4 * (uint64_t)__p[0] + 7];
          if (v24 >= 0x41 && __p[1])
            operator delete[](__p[1]);
          if (v17)
            return v11;
          v16 = (void *)(v20 + 1);
          v18 = v22 + 1;
          ++v20;
          *(_QWORD *)&v22 = v22 + 1;
        }
        while ((void *)v21 != v13 || BYTE8(v21) != v14 || v18 != v15);
      }
      v12 = (uint64_t)*a1
          + 16 * (((unint64_t)*((unsigned int *)*a1 + 11) >> 23) & 1)
          + (((unint64_t)*((unsigned int *)*a1 + 11) >> 21) & 0x7F8)
          + 71;
      return *(void ***)((v12 & 0xFFFFFFFFFFFFFFF8) + 24);
    }
  }
  return 0;
}

uint64_t mlir::cf::SwitchOp::getCanonicalizationPatterns(uint64_t *a1)
{
  __int16 v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t result;
  _QWORD *v36;
  _QWORD *v37;
  __int16 v38;
  __int16 v39;
  __int16 v40;
  __int16 v41;
  __int16 v42;
  __int16 v43;
  _QWORD *v44;

  mlir::PatternBenefit::PatternBenefit(&v43, 1);
  v2 = v43;
  v3 = *a1;
  v4 = operator new(0x68uLL);
  mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"cf.switch", 9, v2, v3, 0, 0);
  *v4 = &off_1E0E52630;
  v4[12] = simplifySwitchWithOnlyDefault;
  v44 = v4;
  v5 = (_QWORD *)a1[2];
  if ((unint64_t)v5 >= a1[3])
  {
    v6 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v44);
    v7 = (uint64_t)v44;
    a1[2] = (uint64_t)v6;
    v44 = 0;
    if (v7)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  }
  else
  {
    *v5 = v4;
    a1[2] = (uint64_t)(v5 + 1);
  }
  mlir::PatternBenefit::PatternBenefit(&v42, 1);
  v8 = v42;
  v9 = *a1;
  v10 = operator new(0x68uLL);
  mlir::Pattern::Pattern((uint64_t)(v10 + 1), (uint64_t)"cf.switch", 9, v8, v9, 0, 0);
  *v10 = &off_1E0E52630;
  v10[12] = dropSwitchCasesThatMatchDefault;
  v44 = v10;
  v11 = (_QWORD *)a1[2];
  if ((unint64_t)v11 >= a1[3])
  {
    v12 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v44);
    v13 = (uint64_t)v44;
    a1[2] = (uint64_t)v12;
    v44 = 0;
    if (v13)
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  }
  else
  {
    *v11 = v10;
    a1[2] = (uint64_t)(v11 + 1);
  }
  mlir::PatternBenefit::PatternBenefit(&v41, 1);
  v14 = v41;
  v15 = *a1;
  v16 = operator new(0x68uLL);
  mlir::Pattern::Pattern((uint64_t)(v16 + 1), (uint64_t)"cf.switch", 9, v14, v15, 0, 0);
  *v16 = &off_1E0E52630;
  v16[12] = simplifyConstSwitchValue;
  v44 = v16;
  v17 = (_QWORD *)a1[2];
  if ((unint64_t)v17 >= a1[3])
  {
    v18 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v44);
    v19 = (uint64_t)v44;
    a1[2] = (uint64_t)v18;
    v44 = 0;
    if (v19)
      (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
  }
  else
  {
    *v17 = v16;
    a1[2] = (uint64_t)(v17 + 1);
  }
  mlir::PatternBenefit::PatternBenefit(&v40, 1);
  v20 = v40;
  v21 = *a1;
  v22 = operator new(0x68uLL);
  mlir::Pattern::Pattern((uint64_t)(v22 + 1), (uint64_t)"cf.switch", 9, v20, v21, 0, 0);
  *v22 = &off_1E0E52630;
  v22[12] = simplifyPassThroughSwitch;
  v44 = v22;
  v23 = (_QWORD *)a1[2];
  if ((unint64_t)v23 >= a1[3])
  {
    v24 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v44);
    v25 = (uint64_t)v44;
    a1[2] = (uint64_t)v24;
    v44 = 0;
    if (v25)
      (*(void (**)(uint64_t))(*(_QWORD *)v25 + 8))(v25);
  }
  else
  {
    *v23 = v22;
    a1[2] = (uint64_t)(v23 + 1);
  }
  mlir::PatternBenefit::PatternBenefit(&v39, 1);
  v26 = v39;
  v27 = *a1;
  v28 = operator new(0x68uLL);
  mlir::Pattern::Pattern((uint64_t)(v28 + 1), (uint64_t)"cf.switch", 9, v26, v27, 0, 0);
  *v28 = &off_1E0E52630;
  v28[12] = simplifySwitchFromSwitchOnSameCondition;
  v44 = v28;
  v29 = (_QWORD *)a1[2];
  if ((unint64_t)v29 >= a1[3])
  {
    v30 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v44);
    v31 = (uint64_t)v44;
    a1[2] = (uint64_t)v30;
    v44 = 0;
    if (v31)
      (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
  }
  else
  {
    *v29 = v28;
    a1[2] = (uint64_t)(v29 + 1);
  }
  mlir::PatternBenefit::PatternBenefit(&v38, 1);
  v32 = v38;
  v33 = *a1;
  v34 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v34 + 1), (uint64_t)"cf.switch", 9, v32, v33, 0, 0);
  *v34 = &off_1E0E52630;
  v34[12] = simplifySwitchFromDefaultSwitchOnSameCondition;
  v44 = v34;
  v36 = (_QWORD *)a1[2];
  if ((unint64_t)v36 >= a1[3])
  {
    v37 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v44);
    result = (uint64_t)v44;
    a1[2] = (uint64_t)v37;
    v44 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v36 = v34;
    a1[2] = (uint64_t)(v36 + 1);
  }
  return result;
}

uint64_t simplifySwitchWithOnlyDefault(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  mlir::GenericProgramPoint *v9;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;

  mlir::SuccessorRange::SuccessorRange(&v12, (Operation *)a1);
  mlir::SuccessorRange::SuccessorRange(&v12, (Operation *)a1);
  if (v13 != 1)
    return 0;
  v4 = *(unsigned int *)(a1 + 44);
  v11 = *(_QWORD *)(((a1 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 24);
  if (BYTE3(v4))
    v5 = a1 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = *(unsigned int *)(v5 + 16);
  v7 = *(_DWORD *)(v5 + 20);
  if ((v4 & 0x800000) != 0)
    v8 = *(_QWORD *)(a1 + 72);
  else
    v8 = 0;
  v12 = v8 + 32 * v6;
  v13 = (v7 + v6) - v6;
  v9 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>((mlir::OpBuilder *)(a2 + 8), *(_QWORD *)(a1 + 24), &v11, (uint64_t)&v12);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a2 + 32))(a2, a1, v9);
  return 1;
}

uint64_t dropSwitchCasesThatMatchDefault(uint64_t a1, mlir::MLIRContext **a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v19;
  uint64_t *v20;
  _DWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t *v36;
  _DWORD *v37;
  int v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  __int128 v45;
  uint64_t v46;
  char *Address;
  llvm::APInt *v48;
  unsigned int v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  mlir::GenericProgramPoint *v55;
  uint64_t v56;
  void *v57;
  __int128 v59;
  mlir::MLIRContext **v60;
  uint64_t v61;
  void *__p;
  unsigned int v63;
  uint64_t v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69;
  unsigned __int8 v70;
  uint64_t v71;
  _QWORD v72[2];
  uint64_t v73;
  uint64_t v74;
  __int128 v75;
  void *v76;
  uint64_t v77;
  _BYTE v78[48];
  _OWORD *v79;
  uint64_t v80;
  _BYTE v81[48];
  _QWORD *v82;
  uint64_t v83;
  _QWORD v84[8];

  v84[6] = *MEMORY[0x1E0C80C00];
  v82 = v84;
  v83 = 0x600000000;
  v79 = v81;
  v80 = 0x300000000;
  v76 = v78;
  v77 = 0x300000000;
  v4 = a1 + 64;
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v5 = a1 + 64 + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1);
  else
    v5 = 0;
  v72[0] = *(_QWORD *)(v5 + 8);
  v72[1] = v72[0] != 0;
  mlir::SuccessorRange::SuccessorRange((unint64_t *)&v67, (Operation *)a1);
  v6 = v67;
  mlir::SuccessorRange::SuccessorRange((unint64_t *)&v67, (Operation *)a1);
  mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)v72, (uint64_t)&v67);
  v65 = v67;
  v66 = v68;
  v7 = v69;
  v8 = v70;
  v9 = v71;
  v64 = 0;
  if ((_QWORD)v67 == v69 && BYTE8(v65) == v70 && (_QWORD)v66 == v71)
  {
    v10 = 0;
    v11 = (char *)v76;
    v12 = v77;
    if (!(_DWORD)v77)
      goto LABEL_65;
    goto LABEL_59;
  }
  v60 = a2;
  v13 = 0;
  v14 = 0;
  v15 = v6 + 32;
  do
  {
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v65, (llvm::APInt *)&v67);
    v63 = DWORD2(v67);
    v61 = v13;
    __p = (void *)v67;
    v19 = *(unsigned int *)(a1 + 44);
    v20 = (uint64_t *)(v4 + 16 * ((v19 >> 23) & 1));
    if (*(_QWORD *)(v15 + 32 * v13 + 24) != *(_QWORD *)((((unint64_t)v20 + ((v19 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                                                       + 24))
      goto LABEL_36;
    if (BYTE3(v19))
      v21 = (_DWORD *)(v4 + 16 * ((v19 >> 23) & 1));
    else
      v21 = 0;
    if ((v19 & 0x800000) != 0)
      v22 = *(_QWORD *)(a1 + 72);
    else
      v22 = 0;
    v23 = (v21[5] + v21[4]);
    v24 = (v21[6] + v23) - v23;
    v73 = v22 + 32 * v23;
    v74 = v24;
    mlir::OperandRange::split(&v73, *v20, &v67);
    v25 = mlir::OperandRangeRange::dereference(&v67, v68 + v13);
    v27 = *(unsigned int *)(a1 + 44);
    if (HIBYTE(*(_DWORD *)(a1 + 44)))
      v28 = v4 + 16 * ((v27 >> 23) & 1);
    else
      v28 = 0;
    if ((v27 & 0x800000) != 0)
    {
      v29 = *(_QWORD *)(a1 + 72);
      v30 = *(unsigned int *)(v28 + 16);
      if (v26 != (*(_DWORD *)(v28 + 20) + v30) - v30)
        goto LABEL_36;
    }
    else
    {
      v29 = 0;
      v30 = *(unsigned int *)(v28 + 16);
      if (v26 != (*(_DWORD *)(v28 + 20) + v30) - v30)
        goto LABEL_36;
    }
    if (!v26)
    {
LABEL_32:
      v14 = 1;
      if (v63 < 0x41)
        goto LABEL_10;
      goto LABEL_49;
    }
    v31 = (_QWORD *)(v29 + 32 * v30 + 24);
    v32 = (_QWORD *)(v25 + 24);
    while (*v32 == *v31)
    {
      v31 += 4;
      v32 += 4;
      if (!--v26)
        goto LABEL_32;
    }
LABEL_36:
    v33 = *(_QWORD *)(v15 + 32 * v61 + 24);
    v34 = v83;
    if (v83 >= (unint64_t)HIDWORD(v83))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v82, v84, v83 + 1, 8);
      v34 = v83;
    }
    v82[v34] = v33;
    LODWORD(v83) = v83 + 1;
    v35 = *(unsigned int *)(a1 + 44);
    v36 = (uint64_t *)(v4 + 16 * ((v35 >> 23) & 1));
    if (HIBYTE(*(_DWORD *)(a1 + 44)))
      v37 = (_DWORD *)(v4 + 16 * ((v35 >> 23) & 1));
    else
      v37 = 0;
    v38 = v37[4];
    v39 = v37[5];
    v40 = v37[6];
    if ((v35 & 0x800000) != 0)
      v41 = *(_QWORD *)(a1 + 72);
    else
      v41 = 0;
    v42 = (v39 + v38);
    v73 = v41 + 32 * v42;
    v74 = (v40 + v42) - v42;
    mlir::OperandRange::split(&v73, *v36, &v67);
    v43 = mlir::OperandRangeRange::dereference(&v67, v68 + v61);
    mlir::ValueRange::ValueRange((unint64_t *)&v75, v43, v44);
    v45 = v75;
    v46 = v80;
    if (v80 >= (unint64_t)HIDWORD(v80))
    {
      v59 = v75;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v79, v81, v80 + 1, 16);
      v45 = v59;
      v46 = v80;
    }
    v79[v46] = v45;
    LODWORD(v80) = v80 + 1;
    Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v76, (unint64_t)&__p, 1);
    v48 = (llvm::APInt *)((char *)v76 + 16 * v77);
    v49 = *((_DWORD *)Address + 2);
    *((_DWORD *)v48 + 2) = v49;
    if (v49 > 0x40)
    {
      llvm::APInt::initSlowCase(v48, (const void **)Address);
      LODWORD(v77) = v77 + 1;
      if (v63 < 0x41)
        goto LABEL_10;
    }
    else
    {
      *(_QWORD *)v48 = *(_QWORD *)Address;
      LODWORD(v77) = v77 + 1;
      if (v63 < 0x41)
        goto LABEL_10;
    }
LABEL_49:
    if (__p)
      operator delete[](__p);
LABEL_10:
    v13 = v64 + 1;
    v16 = v66 + 1;
    ++v64;
    *(_QWORD *)&v66 = v66 + 1;
  }
  while ((_QWORD)v65 != v7 || BYTE8(v65) != v8 || v16 != v9);
  if ((v14 & 1) != 0)
  {
    v50 = *(unsigned int *)(a1 + 44);
    v51 = *(_QWORD *)(a1 + 72);
    v64 = *(_QWORD *)(v51 + 24);
    v61 = *(_QWORD *)(((a1 + 80 + ((v50 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 24);
    if (BYTE3(v50))
      v52 = a1 + 80;
    else
      v52 = 0;
    v53 = *(unsigned int *)(v52 + 16);
    v54 = (*(_DWORD *)(v52 + 20) + v53) - v53;
    *(_QWORD *)&v67 = v51 + 32 * v53;
    *((_QWORD *)&v67 + 1) = v54;
    v55 = mlir::OpBuilder::create<mlir::cf::SwitchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *,mlir::OperandRange,llvm::SmallVector<llvm::APInt,3u> &,llvm::SmallVector<mlir::Block *,6u> &,llvm::SmallVector<mlir::ValueRange,3u> &>(v60 + 1, *(_QWORD *)(a1 + 24), &v64, &v61, (uint64_t)&v67, (uint64_t)&v76, (uint64_t)&v82, (uint64_t)&v79);
    (*((void (**)(mlir::MLIRContext **, uint64_t, mlir::GenericProgramPoint *))*v60 + 4))(v60, a1, v55);
    v10 = 1;
    v11 = (char *)v76;
    v12 = v77;
    if (!(_DWORD)v77)
      goto LABEL_65;
  }
  else
  {
    v10 = 0;
    v11 = (char *)v76;
    v12 = v77;
    if (!(_DWORD)v77)
      goto LABEL_65;
  }
LABEL_59:
  v56 = 16 * v12;
  do
  {
    if (*(_DWORD *)&v11[v56 - 8] >= 0x41u)
    {
      v57 = *(void **)&v11[v56 - 16];
      if (v57)
        operator delete[](v57);
    }
    v56 -= 16;
  }
  while (v56);
  v11 = (char *)v76;
LABEL_65:
  if (v11 != v78)
    free(v11);
  if (v79 != (_OWORD *)v81)
    free(v79);
  if (v82 != v84)
    free(v82);
  return v10;
}

uint64_t simplifyConstSwitchValue(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t DefiningOp;
  uint64_t v6;
  unint64_t v7;
  void *v8;
  BOOL v9;
  BOOL v10;
  BOOL v11;
  uint64_t v12;
  void **p_p;
  void *__p;
  unsigned int v16;
  uint64_t v17;
  void *v18[2];
  _QWORD v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  v16 = 1;
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 24);
  p_p = &__p;
  __p = 0;
  v17 = v4;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v17);
  if (!DefiningOp)
    goto LABEL_20;
  v6 = DefiningOp;
  if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
    goto LABEL_20;
  v18[0] = v19;
  v18[1] = (void *)0x100000000;
  mlir::Operation::fold(v6, 0, 0, (uint64_t)v18);
  v7 = *(_QWORD *)v18[0] & 0xFFFFFFFFFFFFFFF8;
  if (v18[0] != v19)
    free(v18[0]);
  if (v7
    && ((v8 = *(void **)(*(_QWORD *)(*(_QWORD *)(v6 - 8) & 0xFFFFFFFFFFFFFFF8) + 136),
         v8 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      ? (v9 = v8 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
      : (v9 = 1),
        !v9 ? (v10 = v8 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id) : (v10 = 1),
        !v10 ? (v11 = v8 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) : (v11 = 1),
        v11 && mlir::detail::constant_int_value_binder::match((uint64_t *)&p_p, v7)))
  {
    foldSwitch(a1, a2, (const void **)&__p);
    v12 = 1;
    if (v16 < 0x41)
      return v12;
  }
  else
  {
LABEL_20:
    v12 = 0;
    if (v16 < 0x41)
      return v12;
  }
  if (__p)
    operator delete[](__p);
  return v12;
}

uint64_t simplifyPassThroughSwitch(uint64_t a1, mlir::MLIRContext **a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  uint64_t v7;
  uint64_t NumElements;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t *v12;
  unint64_t v13;
  uint64_t *v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  _QWORD *v21;
  unsigned int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  _QWORD *v33;
  unsigned int v34;
  mlir::GenericProgramPoint *v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  __int128 v42;
  _BYTE *v44;
  uint64_t v45;
  uint64_t v46[2];
  uint64_t v47[2];
  void *v48;
  uint64_t v49;
  _BYTE v50[64];
  void *v51;
  uint64_t v52;
  _BYTE v53[48];
  _BYTE *v54;
  uint64_t v55;
  _BYTE v56[48];
  __int128 v57;
  uint64_t v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v44 = v56;
  v54 = v56;
  v55 = 0x600000000;
  v51 = v53;
  v52 = 0x300000000;
  v48 = v50;
  v49 = 0x100000000;
  v3 = a1 + 64;
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v4 = a1 + 64 + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1);
  else
    v4 = 0;
  v46[0] = *(_QWORD *)(v4 + 8);
  v46[1] = v46[0] != 0;
  v5 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v46) + 1;
  if (v5 > HIDWORD(v49))
    llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Value,6u>,false>::grow((uint64_t)&v48, v5);
  v6 = mlir::SuccessorRange::SuccessorRange((unint64_t *)&v57, (Operation *)a1);
  v7 = v57;
  mlir::SuccessorRange::SuccessorRange(v6, (Operation *)a1);
  NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v46);
  if (NumElements < 1)
  {
    v10 = 0;
  }
  else
  {
    v9 = NumElements;
    v10 = 0;
    v11 = 0;
    v12 = (uint64_t *)(v7 + 56);
    do
    {
      v45 = *v12;
      v13 = *(unsigned int *)(a1 + 44);
      v14 = (uint64_t *)(v3 + 16 * ((v13 >> 23) & 1));
      if (HIBYTE(*(_DWORD *)(a1 + 44)))
        v15 = (_DWORD *)(v3 + 16 * ((v13 >> 23) & 1));
      else
        v15 = 0;
      if ((v13 & 0x800000) != 0)
        v16 = *(_QWORD *)(a1 + 72);
      else
        v16 = 0;
      v17 = (v15[5] + v15[4]);
      v18 = (v15[6] + v17) - v17;
      v47[0] = v16 + 32 * v17;
      v47[1] = v18;
      mlir::OperandRange::split(v47, *v14, &v57);
      v19 = mlir::OperandRangeRange::dereference(&v57, v58 + v11);
      mlir::ValueRange::ValueRange((unint64_t *)&v57, v19, v20);
      if (v49 >= HIDWORD(v49))
      {
        llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Value,6u>,false>::growAndEmplaceBack<>((uint64_t)&v48);
        v22 = v49;
      }
      else
      {
        v21 = (char *)v48 + 64 * (unint64_t)v49;
        *v21 = v21 + 2;
        v21[1] = 0x600000000;
        v22 = v49 + 1;
        LODWORD(v49) = v49 + 1;
      }
      v23 = collapseBranch(&v45, &v57, (uint64_t)((uint64_t)v48 + 64 * (unint64_t)v22) - 64) != 0;
      v24 = v45;
      v25 = v55;
      if (v55 >= (unint64_t)HIDWORD(v55))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v44, v55 + 1, 8);
        v25 = v55;
      }
      *(_QWORD *)&v54[8 * v25] = v24;
      LODWORD(v55) = v55 + 1;
      v26 = v57;
      v27 = v52;
      if (v52 >= (unint64_t)HIDWORD(v52))
      {
        v42 = v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
        v26 = v42;
        v27 = v52;
      }
      v10 |= v23;
      *((_OWORD *)v51 + v27) = v26;
      LODWORD(v52) = v52 + 1;
      ++v11;
      v12 += 4;
    }
    while (v9 != v11);
  }
  v28 = *(unsigned int *)(a1 + 44);
  v47[0] = *(_QWORD *)(((v3 + 16 * ((v28 >> 23) & 1) + ((v28 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 24);
  if (BYTE3(v28))
    v29 = v3 + 16 * ((v28 >> 23) & 1);
  else
    v29 = 0;
  v30 = *(unsigned int *)(v29 + 16);
  v31 = *(_DWORD *)(v29 + 20);
  if ((v28 & 0x800000) != 0)
    v32 = *(_QWORD *)(a1 + 72);
  else
    v32 = 0;
  mlir::ValueRange::ValueRange((unint64_t *)&v57, v32 + 32 * v30, (v31 + v30) - v30);
  if (v49 >= HIDWORD(v49))
  {
    llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Value,6u>,false>::growAndEmplaceBack<>((uint64_t)&v48);
    v34 = v49;
  }
  else
  {
    v33 = (char *)v48 + 64 * (unint64_t)v49;
    *v33 = v33 + 2;
    v33[1] = 0x600000000;
    v34 = v49 + 1;
    LODWORD(v49) = v49 + 1;
  }
  if ((collapseBranch(v47, &v57, (uint64_t)((uint64_t)v48 + 64 * (unint64_t)v34) - 64) != 0) | v10 & 1)
  {
    v45 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 24);
    v35 = mlir::OpBuilder::create<mlir::cf::SwitchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *&,mlir::ValueRange &,mlir::DenseIntElementsAttr &,llvm::SmallVector<mlir::Block *,6u> &,llvm::SmallVector<mlir::ValueRange,3u> &>(a2 + 1, *(_QWORD *)(a1 + 24), &v45, v47, (uint64_t *)&v57, v46, (uint64_t)&v54, (uint64_t)&v51);
    (*((void (**)(mlir::MLIRContext **, uint64_t, mlir::GenericProgramPoint *))*a2 + 4))(a2, a1, v35);
    v36 = 1;
    v37 = (char *)v48;
    v38 = v49;
    if (!(_DWORD)v49)
      goto LABEL_40;
  }
  else
  {
    v36 = 0;
    v37 = (char *)v48;
    v38 = v49;
    if (!(_DWORD)v49)
      goto LABEL_40;
  }
  v39 = v38 << 6;
  do
  {
    v40 = *(char **)&v37[v39 - 64];
    if (&v37[v39 - 48] != v40)
      free(v40);
    v39 -= 64;
  }
  while (v39);
  v37 = (char *)v48;
LABEL_40:
  if (v37 != v50)
    free(v37);
  if (v51 != v53)
    free(v51);
  if (v54 != v44)
    free(v54);
  return v36;
}

uint64_t simplifySwitchFromSwitchOnSameCondition(uint64_t a1, uint64_t a2)
{
  mlir::Block *v4;
  uint64_t result;
  uint64_t v6;
  BOOL v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  mlir::Block **v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  mlir::GenericProgramPoint *v18;
  unint64_t v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  void *__p;
  unsigned int v24;
  _QWORD v25[2];
  __int128 v26;
  uint64_t v27;
  uint64_t v28;

  v4 = *(mlir::Block **)(a1 + 16);
  result = mlir::Block::getSinglePredecessor(v4);
  if (result)
  {
    mlir::Block::getTerminator((mlir::GenericProgramPoint **)result);
    if (v6)
      v7 = *(_QWORD *)(*(_QWORD *)(v6 + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::cf::SwitchOp,void>::id;
    else
      v7 = 0;
    if (v7
      && (v8 = (unsigned int *)v6, *(_QWORD *)(*(_QWORD *)(a1 + 72) + 24) == *(_QWORD *)(*(_QWORD *)(v6 + 72) + 24))
      && *(mlir::Block **)(((v6 + 64 + (((unint64_t)*(unsigned int *)(v6 + 44) >> 21) & 0x7F8) + 23) & 0xFFFFFFFFFFFFFFF8)
                         + 24) != v4)
    {
      mlir::SuccessorRange::SuccessorRange((unint64_t *)&v20, (Operation *)v6);
      v9 = v20;
      mlir::SuccessorRange::SuccessorRange((unint64_t *)&v20, (Operation *)v8);
      v10 = 0;
      v11 = *((_QWORD *)&v20 + 1) - 1;
      if (*((_QWORD *)&v20 + 1) != 1)
      {
        v12 = (mlir::Block **)(v9 + 56);
        while (*v12 != v4)
        {
          ++v10;
          v12 += 4;
          if (v11 == v10)
            goto LABEL_17;
        }
      }
      if (v10 == v11)
      {
LABEL_17:
        v13 = *(unsigned int *)(a1 + 44);
        *(_QWORD *)&v26 = *(_QWORD *)(((a1 + 16 * ((v13 >> 23) & 1) + 64 + ((v13 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                                    + 24);
        if (BYTE3(v13))
          v14 = a1 + 16 * ((v13 >> 23) & 1) + 64;
        else
          v14 = 0;
        v15 = *(unsigned int *)(v14 + 16);
        v16 = *(_DWORD *)(v14 + 20);
        if ((v13 & 0x800000) != 0)
          v17 = *(_QWORD *)(a1 + 72);
        else
          v17 = 0;
        *(_QWORD *)&v20 = v17 + 32 * v15;
        *((_QWORD *)&v20 + 1) = (v16 + v15) - v15;
        v18 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>((mlir::OpBuilder *)(a2 + 8), *(_QWORD *)(a1 + 24), (uint64_t *)&v26, (uint64_t)&v20);
        (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a2 + 32))(a2, a1, v18);
      }
      else
      {
        if (HIBYTE(v8[11]))
          v19 = (unint64_t)&v8[4 * (((unint64_t)v8[11] >> 23) & 1) + 16];
        else
          v19 = 0;
        v25[0] = *(_QWORD *)(v19 + 8);
        v25[1] = v25[0] != 0;
        mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)v25, (uint64_t)&v20);
        v26 = v20;
        v27 = v21 + v10;
        v28 = v22;
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v26, (llvm::APInt *)&__p);
        foldSwitch(a1, a2, (const void **)&__p);
        if (v24 >= 0x41 && __p)
          operator delete[](__p);
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t simplifySwitchFromDefaultSwitchOnSameCondition(uint64_t a1, mlir::MLIRContext **a2)
{
  mlir::Block *v4;
  mlir::GenericProgramPoint **SinglePredecessor;
  uint64_t v6;
  unsigned int *v8;
  uint64_t v10;
  unint64_t v11;
  uint64_t NumElements;
  uint64_t v13;
  uint64_t v14;
  mlir::Block **v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t *v29;
  _DWORD *v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  __int128 v38;
  uint64_t v39;
  char *Address;
  llvm::APInt *v41;
  unsigned int v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  mlir::GenericProgramPoint *v49;
  char *v50;
  uint64_t v51;
  void *v52;
  llvm *v53;
  _DWORD *v54;
  uint64_t v55;
  void *v56;
  void *v57;
  __int128 v58;
  uint64_t v59;
  void *__p;
  unsigned int v61;
  uint64_t v62;
  __int128 v63;
  __int128 v64;
  _QWORD v65[2];
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  unsigned __int8 v69;
  uint64_t v70;
  _QWORD v71[2];
  llvm *v72[2];
  unsigned int v73;
  uint64_t v74[2];
  __int128 v75;
  void *v76;
  uint64_t v77;
  _BYTE v78[48];
  _BYTE *v79;
  uint64_t v80;
  _BYTE v81[48];
  __int128 v82;
  _QWORD v83[10];

  v83[7] = *MEMORY[0x1E0C80C00];
  v4 = *(mlir::Block **)(a1 + 16);
  SinglePredecessor = (mlir::GenericProgramPoint **)mlir::Block::getSinglePredecessor(v4);
  if (SinglePredecessor)
  {
    mlir::Block::getTerminator(SinglePredecessor);
    if (v6
      && *(_QWORD *)(*(_QWORD *)(v6 + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::cf::SwitchOp,void>::id)
    {
      v8 = (unsigned int *)v6;
      if (*(_QWORD *)(*(_QWORD *)(a1 + 72) + 24) == *(_QWORD *)(*(_QWORD *)(v6 + 72) + 24)
        && *(mlir::Block **)(((v6 + (((unint64_t)*(unsigned int *)(v6 + 44) >> 21) & 0x7F8) + 87) & 0xFFFFFFFFFFFFFFF8)
                           + 24) == v4)
      {
        v72[0] = 0;
        v72[1] = 0;
        v73 = 0;
        mlir::SuccessorRange::SuccessorRange((unint64_t *)&v66, (Operation *)v6);
        v10 = v66;
        mlir::SuccessorRange::SuccessorRange((unint64_t *)&v66, (Operation *)v8);
        if (HIBYTE(v8[11]))
          v11 = (unint64_t)&v8[4 * (((unint64_t)v8[11] >> 23) & 1) + 16];
        else
          v11 = 0;
        v71[0] = *(_QWORD *)(v11 + 8);
        v71[1] = v71[0] != 0;
        NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v71);
        if (NumElements >= 1)
        {
          v13 = NumElements;
          v14 = 0;
          v15 = (mlir::Block **)(v10 + 56);
          do
          {
            if (v4 != *v15)
            {
              mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)v71, (uint64_t)&v66);
              v82 = v66;
              v83[0] = v14 + v67;
              v83[1] = *((_QWORD *)&v67 + 1);
              mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v82, (llvm::APInt *)&v79);
              *(_QWORD *)&v82 = 0;
              if ((llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::LookupBucketFor<llvm::APInt>((uint64_t *)v72, (llvm *)&v79, (uint64_t *)&v82) & 1) != 0)
              {
                if (v80 >= 0x41 && v79)
                  operator delete[](v79);
              }
              else
              {
                v16 = llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::InsertIntoBucketImpl<llvm::APInt>((uint64_t)v72, (uint64_t)&v79, (llvm *)&v79, v82);
                v17 = v16;
                if (*(_DWORD *)(v16 + 8) >= 0x41u)
                {
                  v18 = *(void **)v16;
                  if (*(_QWORD *)v17)
                    operator delete[](v18);
                }
                *(_QWORD *)v17 = v79;
                *(_DWORD *)(v17 + 8) = v80;
              }
            }
            ++v14;
            v15 += 4;
          }
          while (v13 != v14);
        }
        *(_QWORD *)&v82 = v83;
        *((_QWORD *)&v82 + 1) = 0x600000000;
        v79 = v81;
        v80 = 0x300000000;
        v76 = v78;
        v77 = 0x300000000;
        if (HIBYTE(*(_DWORD *)(a1 + 44)))
          v19 = a1 + 64 + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1);
        else
          v19 = 0;
        v65[0] = *(_QWORD *)(v19 + 8);
        v65[1] = v65[0] != 0;
        mlir::SuccessorRange::SuccessorRange((unint64_t *)&v66, (Operation *)a1);
        v20 = v66;
        mlir::SuccessorRange::SuccessorRange((unint64_t *)&v66, (Operation *)a1);
        mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)v65, (uint64_t)&v66);
        v63 = v66;
        v64 = v67;
        v21 = v68;
        v22 = v69;
        v23 = v70;
        v62 = 0;
        if ((_QWORD)v66 == v68 && BYTE8(v63) == v69 && (_QWORD)v64 == v70)
        {
LABEL_61:
          v50 = (char *)v76;
          if ((_DWORD)v77)
          {
            v51 = 16 * v77;
            do
            {
              if (*(_DWORD *)&v50[v51 - 8] >= 0x41u)
              {
                v52 = *(void **)&v50[v51 - 16];
                if (v52)
                  operator delete[](v52);
              }
              v51 -= 16;
            }
            while (v51);
            v50 = (char *)v76;
          }
          if (v50 != v78)
            free(v50);
          if (v79 != v81)
            free(v79);
          if ((_QWORD *)v82 != v83)
            free((void *)v82);
          v53 = v72[0];
          if (v73)
          {
            v54 = (_DWORD *)((char *)v72[0] + 8);
            v55 = 16 * v73;
            do
            {
              if (*v54 >= 0x41u)
              {
                v56 = (void *)*((_QWORD *)v54 - 1);
                if (v56)
                  operator delete[](v56);
              }
              v54 += 4;
              v55 -= 16;
            }
            while (v55);
            v53 = v72[0];
            v57 = (void *)(16 * v73);
          }
          else
          {
            v57 = 0;
          }
          llvm::deallocate_buffer(v53, v57);
        }
        v24 = 0;
        v25 = 0;
        while (1)
        {
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v63, (llvm::APInt *)&v66);
          v61 = DWORD2(v66);
          v59 = v24;
          __p = (void *)v66;
          *(_QWORD *)&v66 = 0;
          if (!llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::LookupBucketFor<llvm::APInt>((uint64_t *)v72, (llvm *)&__p, (uint64_t *)&v66)|| (llvm *)v66 == (llvm *)((char *)v72[0] + 16 * v73))
          {
            v26 = *(_QWORD *)(v20 + 32 + 32 * v59 + 24);
            v27 = DWORD2(v82);
            if (DWORD2(v82) >= (unint64_t)HIDWORD(v82))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v82, v83, DWORD2(v82) + 1, 8);
              v27 = DWORD2(v82);
            }
            *(_QWORD *)(v82 + 8 * v27) = v26;
            ++DWORD2(v82);
            v28 = *(unsigned int *)(a1 + 44);
            v29 = (uint64_t *)(a1 + 64 + 16 * ((v28 >> 23) & 1));
            if (HIBYTE(*(_DWORD *)(a1 + 44)))
              v30 = (_DWORD *)(a1 + 64 + 16 * ((v28 >> 23) & 1));
            else
              v30 = 0;
            v31 = v30[4];
            v32 = v30[5];
            v33 = v30[6];
            if ((v28 & 0x800000) != 0)
              v34 = *(_QWORD *)(a1 + 72);
            else
              v34 = 0;
            v35 = (v32 + v31);
            v74[0] = v34 + 32 * v35;
            v74[1] = (v33 + v35) - v35;
            mlir::OperandRange::split(v74, *v29, &v66);
            v36 = mlir::OperandRangeRange::dereference(&v66, v67 + v59);
            mlir::ValueRange::ValueRange((unint64_t *)&v75, v36, v37);
            v38 = v75;
            v39 = v80;
            if (v80 >= (unint64_t)HIDWORD(v80))
            {
              v58 = v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v79, v81, v80 + 1, 16);
              v38 = v58;
              v39 = v80;
            }
            *(_OWORD *)&v79[16 * v39] = v38;
            LODWORD(v80) = v80 + 1;
            Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v76, (unint64_t)&__p, 1);
            v41 = (llvm::APInt *)((char *)v76 + 16 * v77);
            v42 = *((_DWORD *)Address + 2);
            *((_DWORD *)v41 + 2) = v42;
            if (v42 > 0x40)
            {
              llvm::APInt::initSlowCase(v41, (const void **)Address);
              LODWORD(v77) = v77 + 1;
              if (v61 >= 0x41)
              {
LABEL_49:
                if (__p)
                  operator delete[](__p);
              }
            }
            else
            {
              *(_QWORD *)v41 = *(_QWORD *)Address;
              LODWORD(v77) = v77 + 1;
              if (v61 >= 0x41)
                goto LABEL_49;
            }
          }
          else
          {
            v25 = 1;
            if (v61 >= 0x41)
              goto LABEL_49;
          }
          v24 = v62 + 1;
          v43 = v64 + 1;
          ++v62;
          *(_QWORD *)&v64 = v64 + 1;
          if ((_QWORD)v63 == v21 && BYTE8(v63) == v22 && v43 == v23)
          {
            if ((v25 & 1) != 0)
            {
              v44 = *(unsigned int *)(a1 + 44);
              v45 = *(_QWORD *)(a1 + 72);
              v62 = *(_QWORD *)(v45 + 24);
              v59 = *(_QWORD *)(((a1 + 80 + ((v44 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 24);
              if (BYTE3(v44))
                v46 = a1 + 80;
              else
                v46 = 0;
              v47 = *(unsigned int *)(v46 + 16);
              v48 = (*(_DWORD *)(v46 + 20) + v47) - v47;
              *(_QWORD *)&v66 = v45 + 32 * v47;
              *((_QWORD *)&v66 + 1) = v48;
              v49 = mlir::OpBuilder::create<mlir::cf::SwitchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *,mlir::OperandRange,llvm::SmallVector<llvm::APInt,3u> &,llvm::SmallVector<mlir::Block *,6u> &,llvm::SmallVector<mlir::ValueRange,3u> &>(a2 + 1, *(_QWORD *)(a1 + 24), &v62, &v59, (uint64_t)&v66, (uint64_t)&v76, (uint64_t)&v82, (uint64_t)&v79);
              (*((void (**)(mlir::MLIRContext **, uint64_t, mlir::GenericProgramPoint *))*a2 + 4))(a2, a1, v49);
            }
            goto LABEL_61;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t mlir::cf::AssertOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  int *v36;
  char *v37;
  char *v38;
  __int128 v39;
  _QWORD **v40;
  _QWORD **v41;
  void *v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  uint64_t v55;
  int v56;
  const char *v57;
  uint64_t v58;
  _QWORD v59[3];
  void *v60;
  unsigned int v61;
  unsigned int v62;
  _BYTE v63[96];
  void *v64;
  _QWORD *v65;
  void *__p;
  _QWORD **v67;
  char v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v55 = v6;
  if (!v6)
  {
    a3(v59, a4);
    if (v59[0])
    {
      v56 = 3;
      v57 = "expected DictionaryAttr to set properties";
      v58 = 41;
      v26 = &v56;
      v27 = (char *)v60;
      if (v61 >= v62)
      {
        v47 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v51 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          v27 = (char *)v60;
          v26 = (int *)((char *)v60 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          v26 = &v56;
          v27 = (char *)v60;
        }
      }
      v28 = &v27[24 * v61];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v68)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v67;
      v32 = __p;
      if (v67 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v67 = v30;
      operator delete(v32);
    }
    v21 = v64;
    if (!v64)
      goto LABEL_59;
    v33 = v65;
    v23 = v64;
    if (v65 == v64)
      goto LABEL_58;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_57;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v55, "msg", 3uLL);
  if (!v8)
  {
    a3(v59, a4);
    if (v59[0])
    {
      v56 = 3;
      v57 = "expected key entry for msg in DictionaryAttr to set Properties.";
      v58 = 63;
      v36 = &v56;
      v37 = (char *)v60;
      if (v61 >= v62)
      {
        v49 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v53 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          v37 = (char *)v60;
          v36 = (int *)((char *)v60 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          v36 = &v56;
          v37 = (char *)v60;
        }
      }
      v38 = &v37[24 * v61];
      v39 = *(_OWORD *)v36;
      *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
      *(_OWORD *)v38 = v39;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v68)
      return 0;
    v40 = (_QWORD **)__p;
    if (__p)
    {
      v41 = v67;
      v42 = __p;
      if (v67 != __p)
      {
        do
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        v42 = __p;
      }
      v67 = v40;
      operator delete(v42);
    }
    v21 = v64;
    if (!v64)
      goto LABEL_59;
    v43 = v65;
    v23 = v64;
    if (v65 == v64)
      goto LABEL_58;
    do
    {
      v45 = (void *)*--v43;
      v44 = v45;
      *v43 = 0;
      if (v45)
        operator delete[](v44);
    }
    while (v43 != v21);
    goto LABEL_57;
  }
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v59, a4);
  if (v59[0])
  {
    v56 = 3;
    v58 = 48;
    v10 = &v56;
    v11 = (char *)v60;
    if (v61 >= v62)
    {
      v48 = v61 + 1;
      if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
      {
        v52 = (char *)&v56 - (_BYTE *)v60;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        v11 = (char *)v60;
        v10 = (int *)((char *)v60 + v52);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        v10 = &v56;
        v11 = (char *)v60;
      }
    }
    v12 = &v11[24 * v61];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    ++v61;
    if (v59[0])
    {
      v14 = &v56;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v56, v9);
      v15 = (char *)v60;
      if (v61 >= v62)
      {
        v50 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v54 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          v15 = (char *)v60;
          v14 = (int *)((char *)v60 + v54);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          v14 = &v56;
          v15 = (char *)v60;
        }
      }
      v16 = &v15[24 * v61];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
  }
  if (v68)
  {
    v18 = (_QWORD **)__p;
    if (__p)
    {
      v19 = v67;
      v20 = __p;
      if (v67 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v67 = v18;
      operator delete(v20);
    }
    v21 = v64;
    if (!v64)
      goto LABEL_59;
    v22 = v65;
    v23 = v64;
    if (v65 == v64)
    {
LABEL_58:
      v65 = v21;
      operator delete(v23);
LABEL_59:
      if (v60 != v63)
        free(v60);
      return 0;
    }
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
LABEL_57:
    v23 = v64;
    goto LABEL_58;
  }
  return 0;
}

uint64_t mlir::cf::AssertOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x1E0C80C00];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"msg", 3, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1 || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    return 1;
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: string attribute";
        v31 = 48;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  __guard *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    if ((v4 & 1) == 0)
    {
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::cf::detail::AssertOpGenericAdaptorBase::Properties]";
        v15 = 106;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
      }
    }
    a1[33] = v5[435];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::StringAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::StringAttr]";
  v41 = 66;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

BOOL mlir::cf::AssertOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD **v5;
  _QWORD **v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  void *v11;
  void *v12;
  const void **v14;
  __int16 v15;
  _QWORD v16[3];
  void *v17;
  uint64_t v18;
  void *v19;
  _QWORD *v20;
  void *__p;
  _QWORD **v22;
  char v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v16[0] = v2;
    return mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(v3, (const void **)"msg", (const char *)3, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v16)&& mlir::complex::__mlir_ods_local_type_constraint_ComplexOps3(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0) != 0;
  }
  else
  {
    v14 = (const void **)"requires attribute 'msg'";
    v15 = 259;
    mlir::OpState::emitOpError(this, &v14, (uint64_t)v16);
    v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v16);
    if (v16[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v16);
    if (v23)
    {
      v5 = (_QWORD **)__p;
      if (__p)
      {
        v6 = v22;
        v7 = __p;
        if (v22 != __p)
        {
          do
            v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
          while (v6 != v5);
          v7 = __p;
        }
        v22 = v5;
        operator delete(v7);
      }
      v8 = v19;
      if (v19)
      {
        v9 = v20;
        v10 = v19;
        if (v20 != v19)
        {
          do
          {
            v12 = (void *)*--v9;
            v11 = v12;
            *v9 = 0;
            if (v12)
              operator delete[](v11);
          }
          while (v9 != v8);
          v10 = v19;
        }
        v20 = v8;
        operator delete(v10);
      }
      if (v17 != &v18)
        free(v17);
    }
  }
  return v4;
}

BOOL mlir::cf::AssertOp::parse(uint64_t a1, _QWORD *a2)
{
  mlir::NoneType **v4;
  mlir::MLIRContext *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  mlir::Builder *v10;
  uint64_t IntegerType;
  _QWORD v13[3];
  uint64_t v14;
  uint64_t v15;
  _QWORD v16[5];

  v16[4] = *MEMORY[0x1E0C80C00];
  memset(v16, 0, 24);
  v15 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v16, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1))
    return 0;
  v4 = (mlir::NoneType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  v6 = mlir::NoneType::get(*v4, v5);
  if (!mlir::AsmParser::parseAttribute<mlir::StringAttr>(a1, &v15, v6))
    return 0;
  if (v15)
  {
    v7 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties>(a2);
    *v7 = v15;
  }
  v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
    return 0;
  v8 = a2[1];
  v13[0] = a1;
  v13[1] = &v14;
  v13[2] = a2;
  v9 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(_QWORD **)(v8 + 96));
  if (v9)
  {
    if (!mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(v9, (const void **)"msg", (const char *)3, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::AssertOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v13))return 0;
  }
  v10 = (mlir::Builder *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  IntegerType = mlir::Builder::getIntegerType(v10, 1u);
  return (*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 696))(a1, v16, IntegerType, a2 + 2) != 0;
}

void mlir::cf::AssertOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  llvm::raw_ostream *v6;
  _BYTE *v7;
  llvm::raw_ostream *v8;
  _BYTE *v9;
  mlir::Operation *v10;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v13;
  unint64_t AttrDictionary;
  void *v15;
  uint64_t v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x1E0C80C00];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 24));
  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v7 = (_BYTE *)*((_QWORD *)v6 + 4);
  if (*((_BYTE **)v6 + 3) == v7)
  {
    llvm::raw_ostream::write(v6, ",", 1uLL);
  }
  else
  {
    *v7 = 44;
    ++*((_QWORD *)v6 + 4);
  }
  v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v9 = (_BYTE *)*((_QWORD *)v8 + 4);
  if ((unint64_t)v9 >= *((_QWORD *)v8 + 3))
  {
    llvm::raw_ostream::write(v8, 32);
  }
  else
  {
    *((_QWORD *)v8 + 4) = v9 + 1;
    *v9 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 48))(a2, *((_QWORD *)*this + 2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8));
  v15 = v17;
  v17[0] = "msg";
  v17[1] = 3;
  v16 = 0x200000001;
  v10 = *this;
  if (*((_BYTE *)*this + 47))
  {
    AttrDictionary = mlir::Operation::getAttrDictionary(v10);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::Operation *)((char *)v10 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v13, v15, v16);
  if (v15 != v17)
    free(v15);
}

void mlir::cf::BranchOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;

  v9 = *(unsigned int *)(a2 + 208);
  if (v9 >= *(_DWORD *)(a2 + 212))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 200, (void *)(a2 + 216), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 208);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 200) + 8 * v9) = a3;
  ++*(_DWORD *)(a2 + 208);
  mlir::OperationState::addOperands(a2, a4, a5);
}

void mlir::OperationState::addSuccessors(mlir::OperationState *this, mlir::Block *a2)
{
  uint64_t v4;

  v4 = *((unsigned int *)this + 52);
  if (v4 >= *((_DWORD *)this + 53))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)this + 200, (char *)this + 216, v4 + 1, 8);
    LODWORD(v4) = *((_DWORD *)this + 52);
  }
  *(_QWORD *)(*((_QWORD *)this + 25) + 8 * v4) = a2;
  ++*((_DWORD *)this + 52);
}

BOOL mlir::cf::BranchOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 v7;
  void *v8;
  uint64_t v10;
  uint64_t v11;
  void *v12[2];
  uint64_t v13;
  void *v14[2];
  _QWORD v15[17];

  v15[16] = *MEMORY[0x1E0C80C00];
  v14[0] = v15;
  v14[1] = (void *)0x400000000;
  v11 = 0;
  v12[0] = &v13;
  v12[1] = (void *)0x100000000;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 768))(a1, &v11))
  {
LABEL_14:
    v7 = 0;
    v8 = v12[0];
    if (v12[0] == &v13)
      goto LABEL_16;
    goto LABEL_15;
  }
  if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1))
  {
    v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    if (!(*(unsigned __int8 (**)(uint64_t, void **, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, v14, 0, 1, 0xFFFFFFFFLL)|| !(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1)|| !mlir::AsmParser::parseTypeList(a1, (uint64_t)v12)|| !(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 280))(a1))
    {
      goto LABEL_14;
    }
  }
  else
  {
    v4 = 0;
  }
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    goto LABEL_14;
  v5 = v11;
  v6 = *(unsigned int *)(a2 + 208);
  if (v6 >= *(_DWORD *)(a2 + 212))
  {
    v10 = v11;
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 200, (void *)(a2 + 216), v6 + 1, 8);
    v5 = v10;
    LODWORD(v6) = *(_DWORD *)(a2 + 208);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 200) + 8 * v6) = v5;
  ++*(_DWORD *)(a2 + 208);
  v7 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>(a1, (uint64_t *)v14, (uint64_t)v12, v4, a2 + 16) != 0;
  v8 = v12[0];
  if (v12[0] != &v13)
LABEL_15:
    free(v8);
LABEL_16:
  if (v14[0] != v15)
    free(v14[0]);
  return v7;
}

void mlir::cf::BranchOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  llvm::raw_ostream *v6;
  _BYTE *v7;
  mlir::Operation *v8;
  uint64_t v9;
  uint64_t v10;
  llvm::raw_ostream *v11;
  llvm::raw_ostream *v12;
  _BYTE *v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  llvm::raw_ostream *v16;
  _BYTE *v17;
  mlir::Operation *v18;
  uint64_t v19;
  uint64_t v20;
  llvm::raw_ostream *v21;
  _BYTE *v22;
  mlir::Operation *v23;
  mlir::ArrayAttr *v24;
  uint64_t Value;
  uint64_t v26;
  uint64_t v27[2];
  _QWORD v28[2];
  void *v29;
  uint64_t v30;
  uint64_t v31[5];

  v31[4] = *MEMORY[0x1E0C80C00];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 176))(a2, *(_QWORD *)((((unint64_t)*this+ 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)+ (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 24));
  if ((*((_BYTE *)*this + 46) & 0x80) == 0 || !*((_DWORD *)*this + 17))
    goto LABEL_25;
  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v7 = (_BYTE *)*((_QWORD *)v6 + 4);
  if (*((_BYTE **)v6 + 3) == v7)
  {
    llvm::raw_ostream::write(v6, "(", 1uLL);
    v8 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
      goto LABEL_8;
LABEL_15:
    v10 = 0;
    v9 = 0;
    goto LABEL_9;
  }
  *v7 = 40;
  ++*((_QWORD *)v6 + 4);
  v8 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) == 0)
    goto LABEL_15;
LABEL_8:
  v9 = *((unsigned int *)v8 + 17);
  v10 = *((_QWORD *)v8 + 9);
LABEL_9:
  v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v29 = ", ";
  v30 = 2;
  llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v10, 0, v10, v9, (uint64_t)a2, v11, (uint64_t)&v29);
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)v12 + 4);
  if ((unint64_t)v13 >= *((_QWORD *)v12 + 3))
  {
    llvm::raw_ostream::write(v12, 32);
  }
  else
  {
    *((_QWORD *)v12 + 4) = v13 + 1;
    *v13 = 32;
  }
  v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)v14 + 4);
  if (*((_BYTE **)v14 + 3) == v15)
  {
    llvm::raw_ostream::write(v14, ":", 1uLL);
  }
  else
  {
    *v15 = 58;
    ++*((_QWORD *)v14 + 4);
  }
  v16 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v17 = (_BYTE *)*((_QWORD *)v16 + 4);
  if ((unint64_t)v17 >= *((_QWORD *)v16 + 3))
  {
    llvm::raw_ostream::write(v16, 32);
  }
  else
  {
    *((_QWORD *)v16 + 4) = v17 + 1;
    *v17 = 32;
  }
  v18 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    v19 = *((unsigned int *)v18 + 17);
    v20 = *((_QWORD *)v18 + 9);
  }
  else
  {
    v20 = 0;
    v19 = 0;
  }
  v27[0] = v20;
  v27[1] = v19;
  mlir::OperandRange::getTypes(v27, (uint64_t *)&v29);
  v28[0] = ", ";
  v28[1] = 2;
  llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::OperandRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &,mlir::OpAsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>((uint64_t)v29, v30, v31[0], v31[1], (uint64_t)a2, (uint64_t)a2, (uint64_t)v28);
  v21 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v22 = (_BYTE *)*((_QWORD *)v21 + 4);
  if (*((_BYTE **)v21 + 3) == v22)
  {
    llvm::raw_ostream::write(v21, ")", 1uLL);
  }
  else
  {
    *v22 = 41;
    ++*((_QWORD *)v21 + 4);
  }
LABEL_25:
  v29 = v31;
  v30 = 0x200000000;
  v23 = *this;
  if (*((_BYTE *)*this + 47))
  {
    v28[0] = mlir::Operation::getAttrDictionary(v23);
    v24 = (mlir::ArrayAttr *)v28;
  }
  else
  {
    v24 = (mlir::Operation *)((char *)v23 + 56);
  }
  Value = mlir::ArrayAttr::getValue(v24);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v26, v29, v30);
  if (v29 != v31)
    free(v29);
}

BOOL mlir::cf::CondBranchOp::setPropertiesFromAttr(void *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  _QWORD *v8;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  _QWORD **v14;
  _QWORD **v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  void *v20;
  void *v21;
  int *v22;
  char *v23;
  char *v24;
  __int128 v25;
  _QWORD **v26;
  _QWORD **v27;
  void *v28;
  _QWORD *v29;
  void *v30;
  void *v31;
  unint64_t v32;
  unint64_t v33;
  int64_t v34;
  int64_t v35;
  uint64_t v36;
  int v37;
  const char *v38;
  uint64_t v39;
  _QWORD v40[3];
  void *v41;
  unsigned int v42;
  unsigned int v43;
  _BYTE v44[96];
  void *v45;
  _QWORD *v46;
  void *__p;
  _QWORD **v48;
  char v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v36 = v6;
  if (!v6)
  {
    a3(v40, a4);
    if (v40[0])
    {
      v37 = 3;
      v38 = "expected DictionaryAttr to set properties";
      v39 = 41;
      v10 = &v37;
      v11 = (char *)v41;
      if (v42 >= v43)
      {
        v32 = v42 + 1;
        if (v41 <= &v37 && (char *)v41 + 24 * v42 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v41;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
          v11 = (char *)v41;
          v10 = (int *)((char *)v41 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
          v10 = &v37;
          v11 = (char *)v41;
        }
      }
      v12 = &v11[24 * v42];
      v13 = *(_OWORD *)v10;
      *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
      *(_OWORD *)v12 = v13;
      ++v42;
      if (v40[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v40);
    }
    if (!v49)
      return 0;
    v14 = (_QWORD **)__p;
    if (__p)
    {
      v15 = v48;
      v16 = __p;
      if (v48 != __p)
      {
        do
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
        while (v15 != v14);
        v16 = __p;
      }
      v48 = v14;
      operator delete(v16);
    }
    v17 = v45;
    if (!v45)
      goto LABEL_43;
    v18 = v46;
    v19 = v45;
    if (v46 == v45)
    {
LABEL_42:
      v46 = v17;
      operator delete(v19);
LABEL_43:
      if (v41 != v44)
        free(v41);
      return 0;
    }
    do
    {
      v21 = (void *)*--v18;
      v20 = v21;
      *v18 = 0;
      if (v21)
        operator delete[](v20);
    }
    while (v18 != v17);
LABEL_41:
    v19 = v45;
    goto LABEL_42;
  }
  v8 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v36, "operandSegmentSizes", 0x13uLL);
  if (!v8)
  {
    v8 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v36, "operand_segment_sizes", 0x15uLL);
    if (!v8)
    {
      a3(v40, a4);
      if (v40[0])
      {
        v37 = 3;
        v38 = "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.";
        v39 = 79;
        v22 = &v37;
        v23 = (char *)v41;
        if (v42 >= v43)
        {
          v33 = v42 + 1;
          if (v41 <= &v37 && (char *)v41 + 24 * v42 > (char *)&v37)
          {
            v35 = (char *)&v37 - (_BYTE *)v41;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v33, 24);
            v23 = (char *)v41;
            v22 = (int *)((char *)v41 + v35);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v33, 24);
            v22 = &v37;
            v23 = (char *)v41;
          }
        }
        v24 = &v23[24 * v42];
        v25 = *(_OWORD *)v22;
        *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
        *(_OWORD *)v24 = v25;
        ++v42;
        if (v40[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v40);
      }
      if (!v49)
        return 0;
      v26 = (_QWORD **)__p;
      if (__p)
      {
        v27 = v48;
        v28 = __p;
        if (v48 != __p)
        {
          do
            v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
          while (v27 != v26);
          v28 = __p;
        }
        v48 = v26;
        operator delete(v28);
      }
      v17 = v45;
      if (!v45)
        goto LABEL_43;
      v29 = v46;
      v19 = v45;
      if (v46 == v45)
        goto LABEL_42;
      do
      {
        v31 = (void *)*--v29;
        v30 = v31;
        *v29 = 0;
        if (v31)
          operator delete[](v30);
      }
      while (v29 != v17);
      goto LABEL_41;
    }
  }
  return mlir::convertFromAttribute(a1, (const char *)3, v8, a3, a4) != 0;
}

uint64_t mlir::cf::CondBranchOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  void *v11;
  mlir::DictionaryAttr *v13;
  void *v14;
  uint64_t v15;
  _QWORD v16[7];

  v16[6] = *MEMORY[0x1E0C80C00];
  v13 = a1;
  v14 = v16;
  v15 = 0x300000000;
  v2 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, a2, 3);
  NamedAttr = mlir::Builder::getNamedAttr(&v13, (uint64_t)"operandSegmentSizes", 19, v2);
  v5 = v4;
  v6 = v15;
  if (v15 >= HIDWORD(v15))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v14, v16, v15 + 1, 16);
    v6 = v15;
  }
  v7 = (uint64_t *)((char *)v14 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = __CFADD__((_DWORD)v15, 1);
  v9 = (v15 + 1);
  LODWORD(v15) = v15 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    v11 = v14;
    if (v14 == v16)
      return DictionaryAttr;
    goto LABEL_8;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v13, (mlir::MLIRContext *)v14, v9);
  v11 = v14;
  if (v14 != v16)
LABEL_8:
    free(v11);
  return DictionaryAttr;
}

unint64_t mlir::cf::CondBranchOp::computePropertiesHash(_QWORD *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v12;
  int v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v19 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v13 = v12;
    a1 = v19;
    if (v13)
    {
      v14 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v14 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v14;
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v19;
    }
  }
  v3 = v2[19];
  v4 = *a1;
  v5 = *(_QWORD *)((char *)a1 + 4);
  if ((v6 & 1) == 0)
  {
    v17 = *(_QWORD *)((char *)a1 + 4);
    v20 = v2[19];
    v18 = *a1;
    v5 = v17;
    v4 = v18;
    v3 = v20;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    if (v15)
    {
      v16 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v16 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v16;
      v5 = v17;
      v4 = v18;
      v3 = v20;
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v7 = __ROR8__(v5 + 12, 12);
  v8 = (0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v7 ^ ((0x9DDFEA08EB382D69 * (v4 ^ v3 ^ v7)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ v3 ^ v7)))) ^ ((0x9DDFEA08EB382D69 * (v7 ^ ((0x9DDFEA08EB382D69 * (v4 ^ v3 ^ v7)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ v3 ^ v7)))) >> 47))) ^ v5;
  v9 = 8 * v8 + 8;
  v10 = v2[19] ^ HIDWORD(v8);
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69
         * (v10 ^ ((0x9DDFEA08EB382D69 * (v10 ^ v9)) >> 47) ^ (0x9DDFEA08EB382D69 * (v10 ^ v9)))) ^ ((0x9DDFEA08EB382D69 * (v10 ^ ((0x9DDFEA08EB382D69 * (v10 ^ v9)) >> 47) ^ (0x9DDFEA08EB382D69 * (v10 ^ v9)))) >> 47));
}

uint64_t mlir::cf::CondBranchOp::setInherentAttr(uint64_t result, char *__s1, uint64_t a3, _QWORD *a4)
{
  void *v5;
  BOOL v6;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;

  v5 = (void *)result;
  if (a3 == 19)
  {
    result = memcmp(__s1, "operandSegmentSizes", 0x13uLL);
    if ((_DWORD)result)
      return result;
  }
  else
  {
    if (a3 != 21)
      return result;
    v6 = *(_QWORD *)__s1 == 0x5F646E617265706FLL && *((_QWORD *)__s1 + 1) == 0x5F746E656D676573;
    if (!v6 || *(_QWORD *)(__s1 + 13) != 0x73657A69735F746ELL)
      return result;
  }
  if (a4)
  {
    result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
    if ((_DWORD)result)
      v8 = a4;
    else
      v8 = 0;
    v10 = v8;
    if ((_DWORD)result)
    {
      result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v10);
      if (result == 3)
      {
        result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v10);
        if (v9)
          return (uint64_t)memmove(v5, (const void *)result, 4 * v9);
      }
    }
  }
  return result;
}

BOOL mlir::cf::CondBranchOp::readProperties(uint64_t a1, _QWORD *a2)
{
  _DWORD *v3;
  _QWORD **v4;
  _QWORD **v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  void *v10;
  void *v11;
  const void *v12;
  uint64_t v13;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD **v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = (_DWORD *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>(a2);
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) <= 5)
  {
    v17 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v17))
      return 0;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v17) >= 4)
    {
      v15 = "size mismatch for operand/result_segment_size";
      v16 = 259;
      (*(void (**)(_QWORD *__return_ptr, uint64_t, const char **))(*(_QWORD *)a1 + 16))(v18, a1, &v15);
      if (v18[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
      if (v25)
      {
        v4 = (_QWORD **)__p;
        if (__p)
        {
          v5 = v24;
          v6 = __p;
          if (v24 != __p)
          {
            do
              v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
            while (v5 != v4);
            v6 = __p;
          }
          v24 = v4;
          operator delete(v6);
        }
        v7 = v21;
        if (v21)
        {
          v8 = v22;
          v9 = v21;
          if (v22 != v21)
          {
            do
            {
              v11 = (void *)*--v8;
              v10 = v11;
              *v8 = 0;
              if (v11)
                operator delete[](v10);
            }
            while (v8 != v7);
            v9 = v21;
          }
          v22 = v7;
          operator delete(v9);
        }
        if (v19 != &v20)
          free(v19);
      }
      return 0;
    }
    v12 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v17);
    if (v13)
      memmove(v3, v12, 4 * v13);
  }
  return (unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) < 6
      || mlir::DialectBytecodeReader::readSparseArray<int>(a1, v3, (const char *)3);
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _DWORD *v3;
  unsigned __int8 v4;
  __guard *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0xCuLL);
    *(_QWORD *)v3 = 0;
    v3[2] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    if ((v4 & 1) == 0)
    {
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties]";
        v15 = 110;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
      }
    }
    a1[33] = v5[437];
    return a1[32];
  }
  return result;
}

void mlir::cf::CondBranchOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _DWORD *v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;

  v19 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  mlir::OperationState::addOperands(a2, a4, a5);
  mlir::OperationState::addOperands(a2, a6, a7);
  v15 = (_DWORD *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>((_QWORD *)a2);
  *v15 = 1;
  v15[1] = a5;
  v15[2] = a7;
  v16 = *(unsigned int *)(a2 + 208);
  if (v16 >= *(_DWORD *)(a2 + 212))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 200, (void *)(a2 + 216), v16 + 1, 8);
    LODWORD(v16) = *(_DWORD *)(a2 + 208);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 200) + 8 * v16) = a8;
  v17 = *(_DWORD *)(a2 + 212);
  v18 = (*(_DWORD *)(a2 + 208) + 1);
  *(_DWORD *)(a2 + 208) = v18;
  if (v18 >= v17)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 200, (void *)(a2 + 216), v18 + 1, 8);
    LODWORD(v18) = *(_DWORD *)(a2 + 208);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 200) + 8 * v18) = a9;
  ++*(_DWORD *)(a2 + 208);
}

BOOL mlir::cf::CondBranchOp::parse(uint64_t a1, mlir::OperationState *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  _DWORD *v8;
  mlir::Builder *v9;
  uint64_t IntegerType;
  uint64_t v11;
  _BOOL8 v12;
  mlir::Block *v14;
  mlir::Block *v15;
  void *v16[2];
  uint64_t v17;
  void *v18;
  uint64_t v19;
  _BYTE v20[128];
  void *v21[2];
  uint64_t v22;
  void *v23;
  uint64_t v24;
  _BYTE v25[128];
  _QWORD v26[6];

  v26[4] = *MEMORY[0x1E0C80C00];
  memset(v26, 0, 24);
  v14 = 0;
  v15 = 0;
  v23 = v25;
  v24 = 0x400000000;
  v21[0] = &v22;
  v21[1] = (void *)0x100000000;
  v18 = v20;
  v19 = 0x400000000;
  v16[0] = &v17;
  v16[1] = (void *)0x100000000;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v26, 1)
    || !(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1)
    || !(*(unsigned __int8 (**)(uint64_t, mlir::Block **))(*(_QWORD *)a1 + 768))(a1, &v15))
  {
    goto LABEL_24;
  }
  if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1))
  {
    v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    if (!(*(unsigned __int8 (**)(uint64_t, void **, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, &v23, 0, 1, 0xFFFFFFFFLL)|| !(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1)|| !mlir::AsmParser::parseTypeList(a1, (uint64_t)v21)|| !(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 280))(a1))
    {
      goto LABEL_24;
    }
  }
  else
  {
    v4 = 0;
  }
  if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1)
    && (*(unsigned __int8 (**)(uint64_t, mlir::Block **))(*(_QWORD *)a1 + 768))(a1, &v14))
  {
    if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 272))(a1))
    {
      v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
      if (!(*(unsigned __int8 (**)(uint64_t, void **, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, &v18, 0, 1, 0xFFFFFFFFLL)|| !(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1)|| !mlir::AsmParser::parseTypeList(a1, (uint64_t)v16)|| !(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 280))(a1))
      {
        goto LABEL_24;
      }
    }
    else
    {
      v5 = 0;
    }
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    if ((*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, (uint64_t)a2 + 112))
    {
      mlir::OperationState::addSuccessors(a2, v15);
      mlir::OperationState::addSuccessors(a2, v14);
      v6 = v24;
      v7 = v19;
      v8 = (_DWORD *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>(a2);
      *v8 = 1;
      v8[1] = v6;
      v8[2] = v7;
      v9 = (mlir::Builder *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
      IntegerType = mlir::Builder::getIntegerType(v9, 1u);
      v11 = (uint64_t)a2 + 16;
      if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v26, IntegerType, v11))
      {
        if (mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>(a1, (uint64_t *)&v23, (uint64_t)v21, v4, v11))
        {
          v12 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>(a1, (uint64_t *)&v18, (uint64_t)v16, v5, v11) != 0;
          goto LABEL_25;
        }
      }
    }
  }
LABEL_24:
  v12 = 0;
LABEL_25:
  if (v16[0] != &v17)
    free(v16[0]);
  if (v18 != v20)
    free(v18);
  if (v21[0] != &v22)
    free(v21[0]);
  if (v23 != v25)
    free(v23);
  return v12;
}

void mlir::cf::CondBranchOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  llvm::raw_ostream *v6;
  _BYTE *v7;
  llvm::raw_ostream *v8;
  _BYTE *v9;
  unint64_t v10;
  llvm::raw_ostream *v11;
  _BYTE *v12;
  unint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  llvm::raw_ostream *v20;
  llvm::raw_ostream *v21;
  _BYTE *v22;
  llvm::raw_ostream *v23;
  _BYTE *v24;
  llvm::raw_ostream *v25;
  _BYTE *v26;
  unint64_t v27;
  unsigned int *v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  llvm::raw_ostream *v32;
  _BYTE *v33;
  llvm::raw_ostream *v34;
  _BYTE *v35;
  llvm::raw_ostream *v36;
  _BYTE *v37;
  unint64_t v38;
  llvm::raw_ostream *v39;
  _BYTE *v40;
  unint64_t v41;
  int *v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  llvm::raw_ostream *v50;
  llvm::raw_ostream *v51;
  _BYTE *v52;
  llvm::raw_ostream *v53;
  _BYTE *v54;
  llvm::raw_ostream *v55;
  _BYTE *v56;
  unint64_t v57;
  int *v58;
  int v59;
  int v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  llvm::raw_ostream *v64;
  _BYTE *v65;
  mlir::Operation *v66;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  const char *AttrDictionary;
  uint64_t v73;
  void *v74;
  uint64_t v75;
  const char *v76;
  uint64_t v77;
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 24));
  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v7 = (_BYTE *)*((_QWORD *)v6 + 4);
  if (*((_BYTE **)v6 + 3) == v7)
  {
    llvm::raw_ostream::write(v6, ",", 1uLL);
  }
  else
  {
    *v7 = 44;
    ++*((_QWORD *)v6 + 4);
  }
  v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v9 = (_BYTE *)*((_QWORD *)v8 + 4);
  if ((unint64_t)v9 >= *((_QWORD *)v8 + 3))
  {
    llvm::raw_ostream::write(v8, 32);
  }
  else
  {
    *((_QWORD *)v8 + 4) = v9 + 1;
    *v9 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 176))(a2, *(_QWORD *)((((unint64_t)*this+ 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)+ (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 24));
  v10 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v10 = 0;
  if (*(_DWORD *)(v10 + 4))
  {
    v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v12 = (_BYTE *)*((_QWORD *)v11 + 4);
    if (*((_BYTE **)v11 + 3) == v12)
    {
      llvm::raw_ostream::write(v11, "(", 1uLL);
    }
    else
    {
      *v12 = 40;
      ++*((_QWORD *)v11 + 4);
    }
    v13 = *((unsigned int *)*this + 11);
    if (HIBYTE(*((_DWORD *)*this + 11)))
      v14 = (unsigned int *)((char *)*this + 16 * ((v13 >> 23) & 1) + 64);
    else
      v14 = 0;
    v15 = *v14;
    v16 = v14[1];
    if ((v13 & 0x800000) != 0)
      v17 = *((_QWORD *)*this + 9);
    else
      v17 = 0;
    v18 = v17 + 32 * v15;
    v19 = v16 + v15 - v15;
    v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v74 = ", ";
    v75 = 2;
    llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v18, 0, v18, v19, (uint64_t)a2, v20, (uint64_t)&v74);
    v21 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v22 = (_BYTE *)*((_QWORD *)v21 + 4);
    if ((unint64_t)v22 >= *((_QWORD *)v21 + 3))
    {
      llvm::raw_ostream::write(v21, 32);
    }
    else
    {
      *((_QWORD *)v21 + 4) = v22 + 1;
      *v22 = 32;
    }
    v23 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v24 = (_BYTE *)*((_QWORD *)v23 + 4);
    if (*((_BYTE **)v23 + 3) == v24)
    {
      llvm::raw_ostream::write(v23, ":", 1uLL);
    }
    else
    {
      *v24 = 58;
      ++*((_QWORD *)v23 + 4);
    }
    v25 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v26 = (_BYTE *)*((_QWORD *)v25 + 4);
    if ((unint64_t)v26 >= *((_QWORD *)v25 + 3))
    {
      llvm::raw_ostream::write(v25, 32);
    }
    else
    {
      *((_QWORD *)v25 + 4) = v26 + 1;
      *v26 = 32;
    }
    v27 = *((unsigned int *)*this + 11);
    if (HIBYTE(*((_DWORD *)*this + 11)))
      v28 = (unsigned int *)((char *)*this + 16 * ((v27 >> 23) & 1) + 64);
    else
      v28 = 0;
    v29 = *v28;
    v30 = v28[1];
    if ((v27 & 0x800000) != 0)
      v31 = *((_QWORD *)*this + 9);
    else
      v31 = 0;
    v70 = v31 + 32 * v29;
    v71 = v30 + v29 - v29;
    mlir::OperandRange::getTypes(&v70, (uint64_t *)&v74);
    AttrDictionary = ", ";
    v73 = 2;
    llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::OperandRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &,mlir::OpAsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>((uint64_t)v74, v75, (uint64_t)v76, v77, (uint64_t)a2, (uint64_t)a2, (uint64_t)&AttrDictionary);
    v32 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v33 = (_BYTE *)*((_QWORD *)v32 + 4);
    if (*((_BYTE **)v32 + 3) == v33)
    {
      llvm::raw_ostream::write(v32, ")", 1uLL);
    }
    else
    {
      *v33 = 41;
      ++*((_QWORD *)v32 + 4);
    }
  }
  v34 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v35 = (_BYTE *)*((_QWORD *)v34 + 4);
  if (*((_BYTE **)v34 + 3) == v35)
  {
    llvm::raw_ostream::write(v34, ",", 1uLL);
  }
  else
  {
    *v35 = 44;
    ++*((_QWORD *)v34 + 4);
  }
  v36 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v37 = (_BYTE *)*((_QWORD *)v36 + 4);
  if ((unint64_t)v37 >= *((_QWORD *)v36 + 3))
  {
    llvm::raw_ostream::write(v36, 32);
  }
  else
  {
    *((_QWORD *)v36 + 4) = v37 + 1;
    *v37 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 176))(a2, *(_QWORD *)((((unint64_t)*this+ 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)+ (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 56));
  v38 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v38 = 0;
  if (*(_DWORD *)(v38 + 8))
  {
    v39 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v40 = (_BYTE *)*((_QWORD *)v39 + 4);
    if (*((_BYTE **)v39 + 3) == v40)
    {
      llvm::raw_ostream::write(v39, "(", 1uLL);
    }
    else
    {
      *v40 = 40;
      ++*((_QWORD *)v39 + 4);
    }
    v41 = *((unsigned int *)*this + 11);
    if (HIBYTE(*((_DWORD *)*this + 11)))
      v42 = (int *)((char *)*this + 16 * ((v41 >> 23) & 1) + 64);
    else
      v42 = 0;
    v43 = *v42;
    v44 = v42[1];
    v45 = v42[2];
    if ((v41 & 0x800000) != 0)
      v46 = *((_QWORD *)*this + 9);
    else
      v46 = 0;
    v47 = (v44 + v43);
    v48 = v46 + 32 * v47;
    v49 = (v45 + v47) - v47;
    v50 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v74 = ", ";
    v75 = 2;
    llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v48, 0, v48, v49, (uint64_t)a2, v50, (uint64_t)&v74);
    v51 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v52 = (_BYTE *)*((_QWORD *)v51 + 4);
    if ((unint64_t)v52 >= *((_QWORD *)v51 + 3))
    {
      llvm::raw_ostream::write(v51, 32);
    }
    else
    {
      *((_QWORD *)v51 + 4) = v52 + 1;
      *v52 = 32;
    }
    v53 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v54 = (_BYTE *)*((_QWORD *)v53 + 4);
    if (*((_BYTE **)v53 + 3) == v54)
    {
      llvm::raw_ostream::write(v53, ":", 1uLL);
    }
    else
    {
      *v54 = 58;
      ++*((_QWORD *)v53 + 4);
    }
    v55 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v56 = (_BYTE *)*((_QWORD *)v55 + 4);
    if ((unint64_t)v56 >= *((_QWORD *)v55 + 3))
    {
      llvm::raw_ostream::write(v55, 32);
    }
    else
    {
      *((_QWORD *)v55 + 4) = v56 + 1;
      *v56 = 32;
    }
    v57 = *((unsigned int *)*this + 11);
    if (HIBYTE(*((_DWORD *)*this + 11)))
      v58 = (int *)((char *)*this + 16 * ((v57 >> 23) & 1) + 64);
    else
      v58 = 0;
    v59 = *v58;
    v60 = v58[1];
    v61 = v58[2];
    if ((v57 & 0x800000) != 0)
      v62 = *((_QWORD *)*this + 9);
    else
      v62 = 0;
    v63 = (v60 + v59);
    v70 = v62 + 32 * v63;
    v71 = (v61 + v63) - v63;
    mlir::OperandRange::getTypes(&v70, (uint64_t *)&v74);
    AttrDictionary = ", ";
    v73 = 2;
    llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::OperandRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &,mlir::OpAsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>((uint64_t)v74, v75, (uint64_t)v76, v77, (uint64_t)a2, (uint64_t)a2, (uint64_t)&AttrDictionary);
    v64 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v65 = (_BYTE *)*((_QWORD *)v64 + 4);
    if (*((_BYTE **)v64 + 3) == v65)
    {
      llvm::raw_ostream::write(v64, ")", 1uLL);
    }
    else
    {
      *v65 = 41;
      ++*((_QWORD *)v64 + 4);
    }
  }
  v74 = &v76;
  v76 = "operandSegmentSizes";
  v77 = 19;
  v75 = 0x200000001;
  v66 = *this;
  if (*((_BYTE *)*this + 47))
  {
    AttrDictionary = (const char *)mlir::Operation::getAttrDictionary(v66);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::Operation *)((char *)v66 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v69, v74, v75);
  if (v74 != &v76)
    free(v74);
}

void mlir::cf::SwitchOp::getCaseOperandsMutable(mlir::Operation **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  _DWORD *v5;
  int v6;
  int v7;
  uint64_t v8;
  mlir::MLIRContext *Context;
  unint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  _BYTE v15[16];
  void *v16;
  _QWORD v17[4];

  v17[3] = *MEMORY[0x1E0C80C00];
  v4 = (uint64_t)*this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v5 = (_DWORD *)((char *)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64);
  else
    v5 = 0;
  v6 = v5[5] + v5[4];
  v7 = v5[6];
  v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 96) + 8 * *(_QWORD *)(*(_QWORD *)(v4 + 48) + 104) - 8);
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v4 + 24));
  v10 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v10 = 0;
  v11 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v10 + 16, 3);
  mlir::NamedAttribute::NamedAttribute(&v12, v8, v11);
  LODWORD(v13) = 2;
  v14 = v12;
  mlir::MutableOperandRange::MutableOperandRange((uint64_t)v15, v4, v6, v7, &v13, 1);
  *(_QWORD *)&v12 = mlir::Operation::getAttrDictionary(*this);
  mlir::DictionaryAttr::getNamed((uint64_t)&v12, **(_QWORD **)(*((_QWORD *)*this + 6) + 96), (uint64_t)&v13);
  mlir::MutableOperandRange::split((uint64_t)v15, v13, v14, a2);
  if (v16 != v17)
    free(v16);
}

BOOL mlir::cf::SwitchOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  int *v36;
  char *v37;
  char *v38;
  __int128 v39;
  int *v40;
  char *v41;
  char *v42;
  __int128 v43;
  _QWORD **v44;
  _QWORD **v45;
  void *v46;
  _QWORD *v47;
  void *v48;
  void *v49;
  int *v50;
  char *v51;
  char *v52;
  __int128 v53;
  int *v54;
  char *v55;
  char *v56;
  __int128 v57;
  _QWORD **v58;
  _QWORD **v59;
  void *v60;
  _QWORD *v61;
  void *v62;
  void *v63;
  int *v64;
  char *v65;
  char *v66;
  __int128 v67;
  _QWORD **v68;
  _QWORD **v69;
  void *v70;
  _QWORD *v71;
  void *v72;
  void *v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  int64_t v85;
  int64_t v86;
  int64_t v87;
  uint64_t v88;
  int v89;
  const char *v90;
  uint64_t v91;
  _QWORD v92[3];
  void *v93;
  unsigned int v94;
  unsigned int v95;
  _BYTE v96[96];
  void *v97;
  _QWORD *v98;
  void *__p;
  _QWORD **v100;
  char v101;
  uint64_t v102;

  v102 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v88 = v6;
  if (!v6)
  {
    a3(v92, a4);
    if (v92[0])
    {
      v89 = 3;
      v90 = "expected DictionaryAttr to set properties";
      v91 = 41;
      v14 = &v89;
      v15 = (char *)v93;
      if (v94 >= v95)
      {
        v74 = v94 + 1;
        if (v93 <= &v89 && (char *)v93 + 24 * v94 > (char *)&v89)
        {
          v81 = (char *)&v89 - (_BYTE *)v93;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v74, 24);
          v15 = (char *)v93;
          v14 = (int *)((char *)v93 + v81);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v74, 24);
          v14 = &v89;
          v15 = (char *)v93;
        }
      }
      v16 = &v15[24 * v94];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v94;
      if (v92[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v92);
    }
    if (!v101)
      return 0;
    v18 = (_QWORD **)__p;
    if (__p)
    {
      v19 = v100;
      v20 = __p;
      if (v100 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v100 = v18;
      operator delete(v20);
    }
    v21 = v97;
    if (!v97)
      goto LABEL_100;
    v22 = v98;
    v23 = v97;
    if (v98 == v97)
    {
LABEL_99:
      v98 = v21;
      operator delete(v23);
LABEL_100:
      if (v93 != v96)
        free(v93);
      return 0;
    }
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
    goto LABEL_98;
  }
  v8 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v88, "case_operand_segments", 0x15uLL);
  if (!v8)
  {
    a3(v92, a4);
    if (v92[0])
    {
      v89 = 3;
      v90 = "expected key entry for case_operand_segments in DictionaryAttr to set Properties.";
      v91 = 81;
      v26 = &v89;
      v27 = (char *)v93;
      if (v94 >= v95)
      {
        v75 = v94 + 1;
        if (v93 <= &v89 && (char *)v93 + 24 * v94 > (char *)&v89)
        {
          v82 = (char *)&v89 - (_BYTE *)v93;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v75, 24);
          v27 = (char *)v93;
          v26 = (int *)((char *)v93 + v82);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v75, 24);
          v26 = &v89;
          v27 = (char *)v93;
        }
      }
      v28 = &v27[24 * v94];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v94;
      if (v92[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v92);
    }
    if (!v101)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v100;
      v32 = __p;
      if (v100 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v100 = v30;
      operator delete(v32);
    }
    v21 = v97;
    if (!v97)
      goto LABEL_100;
    v33 = v98;
    v23 = v97;
    if (v98 == v97)
      goto LABEL_99;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_98;
  }
  v9 = (uint64_t)v8;
  if (!mlir::detail::DenseArrayAttrImpl<int>::classof(v8))
  {
    a3(v92, a4);
    if (v92[0])
    {
      v89 = 3;
      v91 = 66;
      v36 = &v89;
      v37 = (char *)v93;
      if (v94 >= v95)
      {
        v76 = v94 + 1;
        if (v93 <= &v89 && (char *)v93 + 24 * v94 > (char *)&v89)
        {
          v83 = (char *)&v89 - (_BYTE *)v93;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v76, 24);
          v37 = (char *)v93;
          v36 = (int *)((char *)v93 + v83);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v76, 24);
          v36 = &v89;
          v37 = (char *)v93;
        }
      }
      v38 = &v37[24 * v94];
      v39 = *(_OWORD *)v36;
      *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
      *(_OWORD *)v38 = v39;
      ++v94;
      if (v92[0])
      {
        v40 = &v89;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v89, v9);
        v41 = (char *)v93;
        if (v94 >= v95)
        {
          v77 = v94 + 1;
          if (v93 <= &v89 && (char *)v93 + 24 * v94 > (char *)&v89)
          {
            v84 = (char *)&v89 - (_BYTE *)v93;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v77, 24);
            v41 = (char *)v93;
            v40 = (int *)((char *)v93 + v84);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v77, 24);
            v40 = &v89;
            v41 = (char *)v93;
          }
        }
        v42 = &v41[24 * v94];
        v43 = *(_OWORD *)v40;
        *((_QWORD *)v42 + 2) = *((_QWORD *)v40 + 2);
        *(_OWORD *)v42 = v43;
        ++v94;
        if (v92[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v92);
      }
    }
    if (!v101)
      return 0;
    v44 = (_QWORD **)__p;
    if (__p)
    {
      v45 = v100;
      v46 = __p;
      if (v100 != __p)
      {
        do
          v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
        while (v45 != v44);
        v46 = __p;
      }
      v100 = v44;
      operator delete(v46);
    }
    v21 = v97;
    if (!v97)
      goto LABEL_100;
    v47 = v98;
    v23 = v97;
    if (v98 == v97)
      goto LABEL_99;
    do
    {
      v49 = (void *)*--v47;
      v48 = v49;
      *v47 = 0;
      if (v49)
        operator delete[](v48);
    }
    while (v47 != v21);
    goto LABEL_98;
  }
  *a1 = v9;
  v10 = mlir::DictionaryAttr::get((uint64_t)&v88, "case_values", 0xBuLL);
  if (v10)
  {
    v11 = v10;
    if (mlir::DenseIntElementsAttr::classof(v10))
    {
      a1[1] = v11;
      goto LABEL_10;
    }
    a3(v92, a4);
    if (v92[0])
    {
      v89 = 3;
      v91 = 56;
      v50 = &v89;
      v51 = (char *)v93;
      if (v94 >= v95)
      {
        v78 = v94 + 1;
        if (v93 <= &v89 && (char *)v93 + 24 * v94 > (char *)&v89)
        {
          v85 = (char *)&v89 - (_BYTE *)v93;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v78, 24);
          v51 = (char *)v93;
          v50 = (int *)((char *)v93 + v85);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v78, 24);
          v50 = &v89;
          v51 = (char *)v93;
        }
      }
      v52 = &v51[24 * v94];
      v53 = *(_OWORD *)v50;
      *((_QWORD *)v52 + 2) = *((_QWORD *)v50 + 2);
      *(_OWORD *)v52 = v53;
      ++v94;
      if (v92[0])
      {
        v54 = &v89;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v89, v11);
        v55 = (char *)v93;
        if (v94 >= v95)
        {
          v79 = v94 + 1;
          if (v93 <= &v89 && (char *)v93 + 24 * v94 > (char *)&v89)
          {
            v86 = (char *)&v89 - (_BYTE *)v93;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v79, 24);
            v55 = (char *)v93;
            v54 = (int *)((char *)v93 + v86);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v79, 24);
            v54 = &v89;
            v55 = (char *)v93;
          }
        }
        v56 = &v55[24 * v94];
        v57 = *(_OWORD *)v54;
        *((_QWORD *)v56 + 2) = *((_QWORD *)v54 + 2);
        *(_OWORD *)v56 = v57;
        ++v94;
        if (v92[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v92);
      }
    }
    if (!v101)
      return 0;
    v58 = (_QWORD **)__p;
    if (__p)
    {
      v59 = v100;
      v60 = __p;
      if (v100 != __p)
      {
        do
          v59 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v59 - 1);
        while (v59 != v58);
        v60 = __p;
      }
      v100 = v58;
      operator delete(v60);
    }
    v21 = v97;
    if (!v97)
      goto LABEL_100;
    v61 = v98;
    v23 = v97;
    if (v98 == v97)
      goto LABEL_99;
    do
    {
      v63 = (void *)*--v61;
      v62 = v63;
      *v61 = 0;
      if (v63)
        operator delete[](v62);
    }
    while (v61 != v21);
LABEL_98:
    v23 = v97;
    goto LABEL_99;
  }
LABEL_10:
  v12 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v88, "operandSegmentSizes", 0x13uLL);
  if (!v12)
  {
    v12 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v88, "operand_segment_sizes", 0x15uLL);
    if (!v12)
    {
      a3(v92, a4);
      if (v92[0])
      {
        v89 = 3;
        v90 = "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.";
        v91 = 79;
        v64 = &v89;
        v65 = (char *)v93;
        if (v94 >= v95)
        {
          v80 = v94 + 1;
          if (v93 <= &v89 && (char *)v93 + 24 * v94 > (char *)&v89)
          {
            v87 = (char *)&v89 - (_BYTE *)v93;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v80, 24);
            v65 = (char *)v93;
            v64 = (int *)((char *)v93 + v87);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v80, 24);
            v64 = &v89;
            v65 = (char *)v93;
          }
        }
        v66 = &v65[24 * v94];
        v67 = *(_OWORD *)v64;
        *((_QWORD *)v66 + 2) = *((_QWORD *)v64 + 2);
        *(_OWORD *)v66 = v67;
        ++v94;
        if (v92[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v92);
      }
      if (!v101)
        return 0;
      v68 = (_QWORD **)__p;
      if (__p)
      {
        v69 = v100;
        v70 = __p;
        if (v100 != __p)
        {
          do
            v69 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v69 - 1);
          while (v69 != v68);
          v70 = __p;
        }
        v100 = v68;
        operator delete(v70);
      }
      v21 = v97;
      if (!v97)
        goto LABEL_100;
      v71 = v98;
      v23 = v97;
      if (v98 == v97)
        goto LABEL_99;
      do
      {
        v73 = (void *)*--v71;
        v72 = v73;
        *v71 = 0;
        if (v73)
          operator delete[](v72);
      }
      while (v71 != v21);
      goto LABEL_98;
    }
  }
  return mlir::convertFromAttribute(a1 + 2, (const char *)3, v12, a3, a4) != 0;
}

uint64_t mlir::cf::SwitchOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t DictionaryAttr;
  void *v24;
  mlir::DictionaryAttr *v26;
  void *v27;
  uint64_t v28;
  _QWORD v29[7];

  v29[6] = *MEMORY[0x1E0C80C00];
  v26 = a1;
  v27 = v29;
  v28 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v26, (uint64_t)"case_operand_segments", 21, *a2);
    v6 = v5;
    v7 = v28;
    if (v28 >= HIDWORD(v28))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v27, v29, v28 + 1, 16);
      v7 = v28;
    }
    v8 = (uint64_t *)((char *)v27 + 16 * v7);
    *v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v28) = v28 + 1;
  }
  v9 = a2[1];
  if (v9)
  {
    v10 = mlir::Builder::getNamedAttr(&v26, (uint64_t)"case_values", 11, v9);
    v12 = v11;
    v13 = v28;
    if (v28 >= HIDWORD(v28))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v27, v29, v28 + 1, 16);
      v13 = v28;
    }
    v14 = (uint64_t *)((char *)v27 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    LODWORD(v28) = v28 + 1;
  }
  v15 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 2), 3);
  v16 = mlir::Builder::getNamedAttr(&v26, (uint64_t)"operandSegmentSizes", 19, v15);
  v18 = v17;
  v19 = v28;
  if (v28 >= HIDWORD(v28))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v27, v29, v28 + 1, 16);
    v19 = v28;
  }
  v20 = (uint64_t *)((char *)v27 + 16 * v19);
  *v20 = v16;
  v20[1] = v18;
  v21 = __CFADD__((_DWORD)v28, 1);
  v22 = (v28 + 1);
  LODWORD(v28) = v28 + 1;
  if (v21)
  {
    DictionaryAttr = 0;
    v24 = v27;
    if (v27 == v29)
      return DictionaryAttr;
    goto LABEL_16;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v26, (mlir::MLIRContext *)v27, v22);
  v24 = v27;
  if (v27 != v29)
LABEL_16:
    free(v24);
  return DictionaryAttr;
}

unint64_t mlir::cf::SwitchOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1;
  unsigned __int8 v2;
  uint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v13;
  int v14;
  unint64_t v15;
  int v16;
  int v17;
  unint64_t v18;
  int v19;
  int v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;

  v1 = *a1;
  v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v2 & 1) == 0)
  {
    v22 = *a1;
    v24 = a1;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v14 = v13;
    v1 = v22;
    a1 = v24;
    if (v14)
    {
      v15 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v15 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v15;
      v1 = v22;
      a1 = v24;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v4 = HIDWORD(v1);
  v5 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v1) ^ HIDWORD(v1));
  v29 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
  v6 = a1[1];
  if ((v4 & 1) == 0)
  {
    v23 = a1[1];
    v25 = a1;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v17 = v16;
    v6 = v23;
    a1 = v25;
    if (v17)
    {
      v18 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v18 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v18;
      v6 = v23;
      a1 = v25;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v7 = HIDWORD(v6);
  v8 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v6) ^ HIDWORD(v6));
  v28 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) >> 47));
  if ((v7 & 1) == 0)
  {
    v26 = a1;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v20 = v19;
    a1 = v26;
    if (v20)
    {
      v21 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v21 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v21;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v26;
    }
  }
  v9 = *(unint64_t *)((char *)a1 + 20);
  v10 = __ROR8__(v9 + 12, 12);
  v11 = 0x9DDFEA08EB382D69 * (a1[2] ^ v3[19] ^ v10);
  v27 = (0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) ^ ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) >> 47))) ^ v9;
  return llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code>(&v29, (uint64_t *)&v28, (uint64_t *)&v27);
}

uint64_t mlir::cf::SwitchOp::getInherentAttr(mlir::MLIRContext *a1, _QWORD *a2, char *__s1, size_t __n)
{
  if (__n == 11)
  {
    if (!memcmp(__s1, "case_values", 0xBuLL))
      return a2[1];
    return 0;
  }
  if (__n == 19)
  {
    if (!memcmp(__s1, "operandSegmentSizes", 0x13uLL))
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 2), 3);
    return 0;
  }
  if (__n != 21)
    return 0;
  if (*(_QWORD *)__s1 != 0x65706F5F65736163
    || *((_QWORD *)__s1 + 1) != 0x6765735F646E6172
    || *(_QWORD *)(__s1 + 13) != 0x73746E656D676573)
  {
    if (!memcmp(__s1, "operand_segment_sizes", 0x15uLL))
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 2), 3);
    return 0;
  }
  return *a2;
}

uint64_t mlir::cf::SwitchOp::setInherentAttr(uint64_t result, char *__s1, uint64_t a3, _QWORD *a4)
{
  _QWORD *v5;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;

  v5 = (_QWORD *)result;
  if (a3 == 11)
  {
    result = memcmp(__s1, "case_values", 0xBuLL);
    if (!(_DWORD)result)
    {
      if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof((uint64_t)a4);
        if ((_DWORD)result)
          v8 = a4;
        else
          v8 = 0;
        v5[1] = v8;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else
  {
    if (a3 == 19)
    {
      result = memcmp(__s1, "operandSegmentSizes", 0x13uLL);
      if ((_DWORD)result)
        return result;
    }
    else
    {
      if (a3 != 21)
        return result;
      if (*(_QWORD *)__s1 == 0x65706F5F65736163
        && *((_QWORD *)__s1 + 1) == 0x6765735F646E6172
        && *(_QWORD *)(__s1 + 13) == 0x73746E656D676573)
      {
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          if ((_DWORD)result)
            v11 = a4;
          else
            v11 = 0;
          *v5 = v11;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
        return result;
      }
      result = memcmp(__s1, "operand_segment_sizes", 0x15uLL);
      if ((_DWORD)result)
        return result;
    }
    if (a4)
    {
      result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
      if ((_DWORD)result)
        v9 = a4;
      else
        v9 = 0;
      v12 = v9;
      if ((_DWORD)result)
      {
        result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v12);
        if (result == 3)
        {
          result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v12);
          if (v10)
            return (uint64_t)memmove(v5 + 2, (const void *)result, 4 * v10);
        }
      }
    }
  }
  return result;
}

BOOL mlir::cf::SwitchOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  _BOOL8 result;

  v8 = (_QWORD *)mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps2(v8, (const void **)"case_operand_segments", (const char *)0x15, a3, a4))
  {
    v9 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps1(v9, (const void **)"case_values", (const char *)0xB, a3, a4))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps2(_QWORD *a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  const void ***v15;
  char *v16;
  char *v17;
  __int128 v18;
  _QWORD **v19;
  _QWORD **v20;
  void *v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  void *v25;
  void *v26;
  unint64_t v27;
  unint64_t v28;
  int64_t v29;
  int64_t v30;
  const void **v31;
  const char *v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  unsigned int v38;
  unsigned int v39;
  _BYTE v40[96];
  void *v41;
  _QWORD *v42;
  void *__p;
  _QWORD **v44;
  char v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (!a1 || mlir::detail::DenseArrayAttrImpl<int>::classof(a1))
    return 1;
  a4(&v35, a5);
  if (v35)
  {
    LODWORD(v31) = 3;
    v32 = "attribute '";
    v33 = 11;
    v11 = &v31;
    v12 = (char *)v37;
    if (v38 >= v39)
    {
      v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        v29 = (char *)&v31 - (_BYTE *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v12 = (char *)v37;
        v11 = (const void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v11 = &v31;
        v12 = (char *)v37;
      }
    }
    v13 = &v12[24 * v38];
    v14 = *(_OWORD *)v11;
    *((_QWORD *)v13 + 2) = v11[2];
    *(_OWORD *)v13 = v14;
    ++v38;
    if (v35)
    {
      v34 = 261;
      v31 = a2;
      v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (v35)
      {
        LODWORD(v31) = 3;
        v32 = "' failed to satisfy constraint: i32 dense array attribute";
        v33 = 57;
        v15 = &v31;
        v16 = (char *)v37;
        if (v38 >= v39)
        {
          v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            v30 = (char *)&v31 - (_BYTE *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v16 = (char *)v37;
            v15 = (const void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v15 = &v31;
            v16 = (char *)v37;
          }
        }
        v17 = &v16[24 * v38];
        v18 = *(_OWORD *)v15;
        *((_QWORD *)v17 + 2) = v15[2];
        *(_OWORD *)v17 = v18;
        ++v38;
      }
    }
  }
  v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v35);
  if (v35)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v35);
  if (v45)
  {
    v19 = (_QWORD **)__p;
    if (__p)
    {
      v20 = v44;
      v21 = __p;
      if (v44 != __p)
      {
        do
          v20 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v20 - 1);
        while (v20 != v19);
        v21 = __p;
      }
      v44 = v19;
      operator delete(v21);
    }
    v22 = v41;
    if (v41)
    {
      v23 = v42;
      v24 = v41;
      if (v42 != v41)
      {
        do
        {
          v26 = (void *)*--v23;
          v25 = v26;
          *v23 = 0;
          if (v26)
            operator delete[](v25);
        }
        while (v23 != v22);
        v24 = v41;
      }
      v42 = v22;
      operator delete(v24);
    }
    if (v37 != v40)
      free(v37);
  }
  return v9;
}

uint64_t mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps1(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  const void ***v15;
  char *v16;
  char *v17;
  __int128 v18;
  _QWORD **v19;
  _QWORD **v20;
  void *v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  void *v25;
  void *v26;
  unint64_t v27;
  unint64_t v28;
  int64_t v29;
  int64_t v30;
  const void **v31;
  const char *v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  unsigned int v38;
  unsigned int v39;
  _BYTE v40[96];
  void *v41;
  _QWORD *v42;
  void *__p;
  _QWORD **v44;
  char v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (!a1 || (mlir::DenseIntElementsAttr::classof(a1) & 1) != 0)
    return 1;
  a4(&v35, a5);
  if (v35)
  {
    LODWORD(v31) = 3;
    v32 = "attribute '";
    v33 = 11;
    v11 = &v31;
    v12 = (char *)v37;
    if (v38 >= v39)
    {
      v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        v29 = (char *)&v31 - (_BYTE *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v12 = (char *)v37;
        v11 = (const void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v11 = &v31;
        v12 = (char *)v37;
      }
    }
    v13 = &v12[24 * v38];
    v14 = *(_OWORD *)v11;
    *((_QWORD *)v13 + 2) = v11[2];
    *(_OWORD *)v13 = v14;
    ++v38;
    if (v35)
    {
      v34 = 261;
      v31 = a2;
      v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (v35)
      {
        LODWORD(v31) = 3;
        v32 = "' failed to satisfy constraint: integer elements attribute";
        v33 = 58;
        v15 = &v31;
        v16 = (char *)v37;
        if (v38 >= v39)
        {
          v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            v30 = (char *)&v31 - (_BYTE *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v16 = (char *)v37;
            v15 = (const void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v15 = &v31;
            v16 = (char *)v37;
          }
        }
        v17 = &v16[24 * v38];
        v18 = *(_OWORD *)v15;
        *((_QWORD *)v17 + 2) = v15[2];
        *(_OWORD *)v17 = v18;
        ++v38;
      }
    }
  }
  v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v35);
  if (v35)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v35);
  if (v45)
  {
    v19 = (_QWORD **)__p;
    if (__p)
    {
      v20 = v44;
      v21 = __p;
      if (v44 != __p)
      {
        do
          v20 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v20 - 1);
        while (v20 != v19);
        v21 = __p;
      }
      v44 = v19;
      operator delete(v21);
    }
    v22 = v41;
    if (v41)
    {
      v23 = v42;
      v24 = v41;
      if (v42 != v41)
      {
        do
        {
          v26 = (void *)*--v23;
          v25 = v26;
          *v23 = 0;
          if (v26)
            operator delete[](v25);
        }
        while (v23 != v22);
        v24 = v41;
      }
      v42 = v22;
      operator delete(v24);
    }
    if (v37 != v40)
      free(v37);
  }
  return v9;
}

BOOL mlir::cf::SwitchOp::readProperties(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD **v4;
  _QWORD **v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  void *v10;
  void *v11;
  const void *v12;
  uint64_t v13;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD **v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(a2);
  if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, v3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1))
  {
    return 0;
  }
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) <= 5)
  {
    v17 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v17))
      return 0;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v17) >= 4)
    {
      v15 = "size mismatch for operand/result_segment_size";
      v16 = 259;
      (*(void (**)(_QWORD *__return_ptr, uint64_t, const char **))(*(_QWORD *)a1 + 16))(v18, a1, &v15);
      if (v18[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
      if (v25)
      {
        v4 = (_QWORD **)__p;
        if (__p)
        {
          v5 = v24;
          v6 = __p;
          if (v24 != __p)
          {
            do
              v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
            while (v5 != v4);
            v6 = __p;
          }
          v24 = v4;
          operator delete(v6);
        }
        v7 = v21;
        if (v21)
        {
          v8 = v22;
          v9 = v21;
          if (v22 != v21)
          {
            do
            {
              v11 = (void *)*--v8;
              v10 = v11;
              *v8 = 0;
              if (v11)
                operator delete[](v10);
            }
            while (v8 != v7);
            v9 = v21;
          }
          v22 = v7;
          operator delete(v9);
        }
        if (v19 != &v20)
          free(v19);
      }
      return 0;
    }
    v12 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v17);
    if (v13)
      memmove(v3 + 2, v12, 4 * v13);
  }
  return (unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) < 6
      || mlir::DialectBytecodeReader::readSparseArray<int>(a1, (_DWORD *)v3 + 4, (const char *)3);
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  __guard *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x20uLL);
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    *((_DWORD *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    if ((v5 & 1) == 0)
    {
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties]";
        v15 = 106;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
      }
    }
    a1[33] = v4[439];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  const void ***v9;
  char *v10;
  char *v11;
  __int128 v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  const void ***v17;
  char *v18;
  char *v19;
  __int128 v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  _QWORD **v25;
  _QWORD **v26;
  void *v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  void *v31;
  void *v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  int64_t v36;
  int64_t v37;
  int64_t v38;
  _WORD v39[20];
  uint64_t v40;
  const void **v41;
  unint64_t v42;
  uint64_t v43;
  __int16 v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  unsigned int v48;
  unsigned int v49;
  _BYTE v50[96];
  void *v51;
  _QWORD *v52;
  void *__p;
  _QWORD **v54;
  char v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v40 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v40))
    return 0;
  v4 = v40;
  if (!v40)
    return 1;
  v5 = mlir::DenseIntElementsAttr::classof(v40);
  v6 = v5 ? v4 : 0;
  *a2 = v6;
  if ((v5 & 1) != 0)
    return 1;
  v39[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v45, a1, v39);
  if (v45)
  {
    LODWORD(v41) = 3;
    v42 = (unint64_t)"expected ";
    v43 = 9;
    v9 = &v41;
    v10 = (char *)v47;
    if (v48 >= v49)
    {
      v33 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        v36 = (char *)&v41 - (_BYTE *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v33, 24);
        v10 = (char *)v47;
        v9 = (const void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v33, 24);
        v9 = &v41;
        v10 = (char *)v47;
      }
    }
    v11 = &v10[24 * v48];
    v12 = *(_OWORD *)v9;
    *((_QWORD *)v11 + 2) = v9[2];
    *(_OWORD *)v11 = v12;
    ++v48;
  }
  v41 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::DenseIntElementsAttr]";
  v42 = 76;
  v13 = llvm::StringRef::find((uint64_t *)&v41, "DesiredTypeName = ", 0x12uLL, 0);
  if (v45)
  {
    if (v42 >= v13)
      v14 = v13;
    else
      v14 = v42;
    v15 = 18;
    if (v42 - v14 < 0x12)
      v15 = v42 - v14;
    v16 = v42 - v14 - v15;
    if (v16 >= v16 - 1)
      --v16;
    v44 = 261;
    v41 = (const void **)((char *)v41 + v14 + v15);
    v42 = v16;
    mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
    if (v45)
    {
      LODWORD(v41) = 3;
      v42 = (unint64_t)", but got: ";
      v43 = 11;
      v17 = &v41;
      v18 = (char *)v47;
      if (v48 >= v49)
      {
        v34 = v48 + 1;
        if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
        {
          v37 = (char *)&v41 - (_BYTE *)v47;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
          v18 = (char *)v47;
          v17 = (const void ***)((char *)v47 + v37);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
          v17 = &v41;
          v18 = (char *)v47;
        }
      }
      v19 = &v18[24 * v48];
      v20 = *(_OWORD *)v17;
      *((_QWORD *)v19 + 2) = v17[2];
      *(_OWORD *)v19 = v20;
      ++v48;
      if (v45)
      {
        v21 = &v41;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v41, v40);
        v22 = (char *)v47;
        if (v48 >= v49)
        {
          v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            v38 = (char *)&v41 - (_BYTE *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            v22 = (char *)v47;
            v21 = (const void ***)((char *)v47 + v38);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            v21 = &v41;
            v22 = (char *)v47;
          }
        }
        v23 = &v22[24 * v48];
        v24 = *(_OWORD *)v21;
        *((_QWORD *)v23 + 2) = v21[2];
        *(_OWORD *)v23 = v24;
        ++v48;
      }
    }
  }
  v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  if (v55)
  {
    v25 = (_QWORD **)__p;
    if (__p)
    {
      v26 = v54;
      v27 = __p;
      if (v54 != __p)
      {
        do
          v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        v27 = __p;
      }
      v54 = v25;
      operator delete(v27);
    }
    v28 = v51;
    if (v51)
    {
      v29 = v52;
      v30 = v51;
      if (v52 != v51)
      {
        do
        {
          v32 = (void *)*--v29;
          v31 = v32;
          *v29 = 0;
          if (v32)
            operator delete[](v31);
        }
        while (v29 != v28);
        v30 = v51;
      }
      v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50)
      free(v47);
  }
  return v7;
}

uint64_t mlir::cf::SwitchOp::writeProperties(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  mlir::MLIRContext *Context;
  uint64_t v6;
  uint64_t result;

  if (HIBYTE(*(_DWORD *)(*(_QWORD *)a1 + 44)))
    v4 = *(_QWORD *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1) + 64;
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 16))(a2, *(_QWORD *)v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 8));
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2) <= 5)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)a1 + 24));
    v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 16, 3);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, v6);
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2);
  if (result >= 6)
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 16), 3);
  return result;
}

BOOL mlir::cf::SwitchOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t v9;
  const char *v10;
  unint64_t v11;
  uint64_t *v12;
  char *v13;
  int *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  char *v18;
  int *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  char *v23;
  int *v24;
  char *v25;
  __int128 v26;
  int *v27;
  char *v28;
  char *v29;
  __int128 v30;
  char v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  void *v39;
  unint64_t v40;
  unint64_t v41;
  BOOL v42;
  unint64_t v43;
  BOOL v44;
  unint64_t v45;
  int64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  uint64_t v50;
  _QWORD **v51;
  _QWORD **v52;
  void *v53;
  _QWORD *v54;
  _QWORD *v55;
  void *v56;
  void *v57;
  void *v58;
  uint64_t *v59;
  uint64_t v60;
  const void **v62[4];
  __int16 v63;
  int v64;
  const char *v65;
  uint64_t v66;
  _QWORD v67[3];
  void *v68;
  unsigned int v69;
  unsigned int v70;
  _BYTE v71[96];
  void *v72;
  _QWORD *v73;
  void *__p;
  _QWORD **v75;
  char v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_QWORD **)v3;
  if (*(_QWORD *)v3)
  {
    v5 = *(_QWORD *)(v3 + 8);
    v67[0] = v2;
    if (!mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps1(v5, (const void **)"case_values", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0;
    v67[0] = *this;
    if (!mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps2(v4, (const void **)"case_operand_segments", (const char *)0x15, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0;
    v6 = *((unsigned int *)*this + 11);
    v7 = (uint64_t)&(*this)[2 * ((v6 >> 23) & 1) + 8];
    if (!HIBYTE(*((_DWORD *)*this + 11)))
      v7 = 0;
    v8 = (const char *)*(unsigned int *)(v7 + 16);
    if ((v6 & 0x800000) != 0)
    {
      v9 = (*this)[9];
      if ((_DWORD)v8)
        goto LABEL_11;
    }
    else
    {
      v9 = 0;
      if ((_DWORD)v8)
      {
LABEL_11:
        v10 = 0;
        do
        {
          v11 = *(_QWORD *)(*(_QWORD *)(v9 + 32 * (_QWORD)v10 + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
          if (*(_UNKNOWN **)(*(_QWORD *)v11 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
          {
            v12 = *this;
            v63 = 261;
            v62[0] = (const void **)"operand";
            v62[1] = (const void **)7;
            mlir::Operation::emitOpError(v12, v62, (uint64_t)v67);
            if (v67[0])
            {
              v64 = 3;
              v65 = " #";
              v66 = 2;
              v13 = (char *)v68;
              if (v69 >= v70)
              {
                v40 = v69 + 1;
                if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
                {
                  v46 = (char *)&v64 - (_BYTE *)v68;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v40, 24);
                  v13 = (char *)v68;
                  v14 = (int *)((char *)v68 + v46);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v40, 24);
                  v14 = &v64;
                  v13 = (char *)v68;
                }
              }
              else
              {
                v14 = &v64;
              }
              v15 = &v13[24 * v69];
              v16 = *(_OWORD *)v14;
              *((_QWORD *)v15 + 2) = *((_QWORD *)v14 + 2);
              *(_OWORD *)v15 = v16;
              v17 = ++v69;
              if (v67[0])
              {
                v64 = 5;
                v65 = v10;
                v18 = (char *)v68;
                if (v17 >= v70)
                {
                  v41 = v17 + 1;
                  v42 = (char *)v68 + 24 * v17 > (char *)&v64;
                  if (v68 <= &v64 && v42)
                  {
                    v47 = (char *)&v64 - (_BYTE *)v68;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v41, 24);
                    v18 = (char *)v68;
                    v19 = (int *)((char *)v68 + v47);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v41, 24);
                    v19 = &v64;
                    v18 = (char *)v68;
                  }
                }
                else
                {
                  v19 = &v64;
                }
                v20 = &v18[24 * v69];
                v21 = *(_OWORD *)v19;
                *((_QWORD *)v20 + 2) = *((_QWORD *)v19 + 2);
                *(_OWORD *)v20 = v21;
                v22 = ++v69;
                if (v67[0])
                {
                  v64 = 3;
                  v65 = " must be integer, but got ";
                  v66 = 26;
                  v23 = (char *)v68;
                  if (v22 >= v70)
                  {
                    v43 = v22 + 1;
                    v44 = (char *)v68 + 24 * v22 > (char *)&v64;
                    if (v68 <= &v64 && v44)
                    {
                      v48 = (char *)&v64 - (_BYTE *)v68;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v43, 24);
                      v23 = (char *)v68;
                      v24 = (int *)((char *)v68 + v48);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v43, 24);
                      v24 = &v64;
                      v23 = (char *)v68;
                    }
                  }
                  else
                  {
                    v24 = &v64;
                  }
                  v25 = &v23[24 * v69];
                  v26 = *(_OWORD *)v24;
                  *((_QWORD *)v25 + 2) = *((_QWORD *)v24 + 2);
                  *(_OWORD *)v25 = v26;
                  ++v69;
                  if (v67[0])
                  {
                    v27 = &v64;
                    mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v64, v11);
                    v28 = (char *)v68;
                    if (v69 >= v70)
                    {
                      v45 = v69 + 1;
                      if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
                      {
                        v49 = (char *)&v64 - (_BYTE *)v68;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v45, 24);
                        v28 = (char *)v68;
                        v27 = (int *)((char *)v68 + v49);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v45, 24);
                        v27 = &v64;
                        v28 = (char *)v68;
                      }
                    }
                    v29 = &v28[24 * v69];
                    v30 = *(_OWORD *)v27;
                    *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
                    *(_OWORD *)v29 = v30;
                    ++v69;
                  }
                }
              }
            }
            v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v67);
            if (v67[0])
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
            if (v76)
            {
              v32 = (_QWORD **)__p;
              if (__p)
              {
                v33 = v75;
                v34 = __p;
                if (v75 != __p)
                {
                  do
                    v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
                  while (v33 != v32);
                  v34 = __p;
                }
                v75 = v32;
                operator delete(v34);
              }
              v35 = v72;
              if (v72)
              {
                v36 = v73;
                v37 = v72;
                if (v73 != v72)
                {
                  do
                  {
                    v39 = (void *)*--v36;
                    v38 = v39;
                    *v36 = 0;
                    if (v39)
                      operator delete[](v38);
                  }
                  while (v36 != v35);
                  v37 = v72;
                }
                v73 = v35;
                operator delete(v37);
              }
              if (v68 != v71)
                free(v68);
            }
            if (!v31)
              return 0;
          }
        }
        while (++v10 != v8);
      }
    }
    if (HIBYTE(*((_DWORD *)*this + 11)))
      v59 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
    else
      v59 = 0;
    v60 = (*((_DWORD *)v59 + 5) + *((_DWORD *)v59 + 4));
    return mlir::OpTrait::impl::verifyValueSizeAttr((uint64_t)*this, "case_operand_segments", 0x15uLL, (const void **)"caseOperands", (const char *)0xC, (const char *)((*((_DWORD *)v59 + 6) + v60) - v60)) != 0;
  }
  else
  {
    v62[0] = (const void **)"requires attribute 'case_operand_segments'";
    v63 = 259;
    mlir::OpState::emitOpError(this, v62, (uint64_t)v67);
    v50 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v67);
    if (v67[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
    if (v76)
    {
      v51 = (_QWORD **)__p;
      if (__p)
      {
        v52 = v75;
        v53 = __p;
        if (v75 != __p)
        {
          do
            v52 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v52 - 1);
          while (v52 != v51);
          v53 = __p;
        }
        v75 = v51;
        operator delete(v53);
      }
      v54 = v72;
      if (v72)
      {
        v55 = v73;
        v56 = v72;
        if (v73 != v72)
        {
          do
          {
            v58 = (void *)*--v55;
            v57 = v58;
            *v55 = 0;
            if (v58)
              operator delete[](v57);
          }
          while (v55 != v54);
          v56 = v72;
        }
        v73 = v54;
        operator delete(v56);
      }
      if (v68 != v71)
        free(v68);
    }
  }
  return v50;
}

BOOL mlir::cf::SwitchOp::parse(void *a1, mlir::OperationState *a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int IntOrFloatBitWidth;
  unint64_t v7;
  char *Address;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  void *v13;
  int v14;
  size_t v15;
  char v16;
  void *v17;
  uint64_t v18;
  void **v19;
  void *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  llvm::APInt *v28;
  uint64_t v29;
  void *v30;
  char *v31;
  const void *v32;
  uint64_t v33;
  unsigned int v34;
  unint64_t v35;
  unsigned int v36;
  uint64_t v37;
  char v38;
  uint64_t v39;
  const void **v40;
  uint64_t v41;
  char *v42;
  char *v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  int v47;
  int v48;
  _DWORD *v49;
  mlir::MLIRContext **v50;
  uint64_t DenseI32ArrayAttr;
  _BOOL8 v52;
  unsigned int v54;
  const void *v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  mlir::OperationState *v62;
  uint64_t v63;
  char *v64;
  const void **v65;
  mlir::Block *v66;
  _QWORD v67[2];
  uint64_t v68[2];
  uint64_t v69;
  unint64_t v70;
  uint64_t v71[2];
  void *v72;
  uint64_t v73;
  _QWORD v74[8];
  void *v75;
  uint64_t v76;
  _BYTE v77[48];
  void *v78;
  uint64_t v79;
  uint64_t v80;
  void *v81;
  uint64_t v82;
  _BYTE v83[48];
  void *v84;
  uint64_t v85;
  _BYTE v86[128];
  void *v87;
  uint64_t v88;
  _BYTE v89[16];
  void *v90[2];
  uint64_t v91;
  void *v92;
  uint64_t v93;
  _BYTE v94[128];
  void *v95;
  void *v96[4];
  void *__p;
  uint64_t v98;
  _BYTE v99[48];
  _BYTE *v100;
  uint64_t v101;
  _BYTE v102[32];
  llvm::APInt *v103;
  uint64_t v104;
  _WORD v105[24];
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  memset(v96, 0, 24);
  v68[0] = (uint64_t)v96;
  v68[1] = 1;
  v95 = 0;
  v67[0] = &v95;
  v67[1] = 1;
  v66 = 0;
  v92 = v94;
  v93 = 0x400000000;
  v90[0] = &v91;
  v90[1] = (void *)0x100000000;
  v87 = v89;
  v88 = 0x200000000;
  v84 = v86;
  v85 = 0x400000000;
  v81 = v83;
  v82 = 0xC00000000;
  v78 = &v80;
  v79 = 0x100000000;
  v4 = (*(uint64_t (**)(void *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(void *, void **, uint64_t))(*(_QWORD *)a1 + 672))(a1, v96, 1))
    goto LABEL_112;
  if (!(*(unsigned __int8 (**)(void *))(*(_QWORD *)a1 + 104))(a1))
    goto LABEL_112;
  v72 = 0;
  if (!mlir::AsmParser::parseType<mlir::IntegerType>((uint64_t)a1, &v72))
    goto LABEL_112;
  v95 = v72;
  if (!(*(unsigned __int8 (**)(void *))(*(_QWORD *)a1 + 120))(a1)
    || !(*(unsigned __int8 (**)(void *))(*(_QWORD *)a1 + 296))(a1))
  {
    goto LABEL_112;
  }
  v60 = (*(uint64_t (**)(void *))(*(_QWORD *)a1 + 40))(a1);
  v5 = (*(uint64_t (**)(void *))(*(_QWORD *)a1 + 40))(a1);
  v75 = v77;
  v76 = 0x100000000;
  v72 = v74;
  v73 = 0x100000000;
  v105[8] = 257;
  v61 = v4;
  v62 = a2;
  v59 = v5;
  if (!(*(unsigned __int8 (**)(void *, const char *, uint64_t, llvm::APInt **))(*(_QWORD *)a1 + 368))(a1, "default", 7, &v103)|| !(*(unsigned __int8 (**)(void *))(*(_QWORD *)a1 + 104))(a1)|| !(*(unsigned __int8 (**)(void *, mlir::Block **))(*(_QWORD *)a1 + 768))(a1, &v66)|| (*(unsigned __int8 (**)(void *))(*(_QWORD *)a1 + 272))(a1)&& (!(*(unsigned __int8 (**)(void *, void **, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a1 + 688))(a1, &v92, 0, 0, 0xFFFFFFFFLL)|| !(*(unsigned __int8 (**)(void *, void **))(*(_QWORD *)a1 + 552))(a1, v90)|| !(*(unsigned __int8 (**)(void *))(*(_QWORD *)a1 + 280))(a1)))
  {
    goto LABEL_89;
  }
  v103 = (llvm::APInt *)v105;
  v104 = 0x300000000;
  IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v95);
  v7 = 0xFFFFFFFFFFFFFFFFLL >> -(char)IntOrFloatBitWidth;
  if (!IntOrFloatBitWidth)
    v7 = 0;
  v58 = v7;
  while ((*(unsigned __int8 (**)(void *))(*(_QWORD *)a1 + 128))(a1))
  {
    v70 = 0;
    if (!mlir::AsmParser::parseInteger<long long>((uint64_t)a1, (uint64_t *)&v70))
      goto LABEL_60;
    LODWORD(v98) = IntOrFloatBitWidth;
    if (IntOrFloatBitWidth > 0x40)
      llvm::APInt::initSlowCase((llvm::APInt *)&__p, v70, 0);
    else
      __p = (void *)(v70 & v58);
    Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v103, (unint64_t)&__p, 1);
    v9 = (char *)v103 + 16 * v104;
    *((_DWORD *)v9 + 2) = *((_DWORD *)Address + 2);
    *(_QWORD *)v9 = *(_QWORD *)Address;
    *((_DWORD *)Address + 2) = 0;
    LODWORD(v104) = v104 + 1;
    if (v98 >= 0x41 && __p)
      operator delete[](__p);
    v69 = 0;
    v100 = v102;
    v101 = 0x100000000;
    __p = v99;
    v98 = 0x600000000;
    if ((*(unsigned __int8 (**)(void *))(*(_QWORD *)a1 + 104))(a1)
      && (*(unsigned __int8 (**)(void *, uint64_t *))(*(_QWORD *)a1 + 768))(a1, &v69)
      && (!(*(unsigned __int8 (**)(void *))(*(_QWORD *)a1 + 272))(a1)
       || (*(unsigned __int8 (**)(void *, _BYTE **, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a1 + 688))(a1, &v100, 0, 0, 0xFFFFFFFFLL)&& (*(unsigned __int8 (**)(void *, void **))(*(_QWORD *)a1 + 552))(a1, &__p)&& (*(unsigned __int8 (**)(void *))(*(_QWORD *)a1 + 280))(a1)))
    {
      v10 = v69;
      v11 = v88;
      if (v88 >= (unint64_t)HIDWORD(v88))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v89, v88 + 1, 8);
        v11 = v88;
      }
      *((_QWORD *)v87 + v11) = v10;
      LODWORD(v88) = v88 + 1;
      if (v76 >= HIDWORD(v76))
      {
        llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,1u>,false>::growAndEmplaceBack<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,1u>&>((uint64_t)&v75, (uint64_t)&v100);
        v18 = v73;
        if (v73 < HIDWORD(v73))
          goto LABEL_47;
      }
      else
      {
        v12 = (char *)v75 + 48 * v76;
        v13 = v12 + 16;
        *(_QWORD *)v12 = v12 + 16;
        *((_QWORD *)v12 + 1) = 0x100000000;
        if (v12 != (char *)&v100)
        {
          v14 = v101;
          if ((_DWORD)v101)
          {
            if (v101 < 2)
            {
              v15 = 32;
LABEL_44:
              memcpy(v13, v100, v15);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v12, v12 + 16, v101, 32);
              if ((_DWORD)v101)
              {
                v13 = *(void **)v12;
                v15 = 32 * v101;
                goto LABEL_44;
              }
            }
            *((_DWORD *)v12 + 2) = v14;
          }
        }
        LODWORD(v76) = v76 + 1;
        v18 = v73;
        if (v73 < HIDWORD(v73))
        {
LABEL_47:
          v19 = (void **)((char *)v72 + 64 * v18);
          v20 = v19 + 2;
          *v19 = v19 + 2;
          v19[1] = (void *)0x600000000;
          if (v19 != &__p)
          {
            v21 = v98;
            if ((_DWORD)v98)
            {
              if (v98 < 7uLL)
              {
                v22 = v98;
LABEL_53:
                memcpy(v20, __p, 8 * v22);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v19, v19 + 2, v98, 8);
                v22 = v98;
                if ((_DWORD)v98)
                {
                  v20 = *v19;
                  goto LABEL_53;
                }
              }
              *((_DWORD *)v19 + 2) = v21;
            }
          }
          LODWORD(v73) = v73 + 1;
          v16 = 1;
          v17 = __p;
          if (__p == v99)
            goto LABEL_41;
LABEL_40:
          free(v17);
          goto LABEL_41;
        }
      }
      llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Type,6u>,false>::growAndEmplaceBack<llvm::SmallVector<mlir::Type,6u>&>((uint64_t)&v72, (uint64_t)&__p);
      v16 = 1;
      v17 = __p;
      if (__p == v99)
        goto LABEL_41;
      goto LABEL_40;
    }
    v16 = 0;
    v17 = __p;
    if (__p != v99)
      goto LABEL_40;
LABEL_41:
    if (v100 != v102)
      free(v100);
    if ((v16 & 1) == 0)
    {
LABEL_60:
      v23 = 0;
      v24 = 0;
      goto LABEL_67;
    }
  }
  if (!(_DWORD)v104)
  {
    v23 = 0;
    v24 = 1;
    v28 = v103;
    goto LABEL_74;
  }
  __p = (void *)v104;
  v25 = (_QWORD *)mlir::VectorType::get((uint64_t)&__p, 1uLL, (uint64_t)v95, 0, 0);
  v26 = (uint64_t)v25;
  v27 = v25 ? mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v25 + 8) : 0;
  v23 = mlir::DenseElementsAttr::get(v26, v27, v103, v104);
  v24 = 1;
LABEL_67:
  v28 = v103;
  if ((_DWORD)v104)
  {
    v63 = v23;
    v29 = 16 * v104;
    do
    {
      if (*(_DWORD *)((char *)v28 + v29 - 8) >= 0x41u)
      {
        v30 = *(void **)((char *)v28 + v29 - 16);
        if (v30)
          operator delete[](v30);
      }
      v29 -= 16;
    }
    while (v29);
    v28 = v103;
    v23 = v63;
  }
LABEL_74:
  if (v28 != (llvm::APInt *)v105)
    free(v28);
  if (!v24)
  {
LABEL_89:
    v38 = 1;
    v39 = v73;
    v40 = (const void **)v72;
    if (!(_DWORD)v73)
      goto LABEL_95;
    goto LABEL_90;
  }
  if (v23)
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(v62)
              + 8) = v23;
  if ((_DWORD)v76)
  {
    v31 = (char *)v75;
    v64 = (char *)v75 + 48 * v76;
    do
    {
      v32 = *(const void **)v31;
      v33 = *((unsigned int *)v31 + 2);
      v34 = v85;
      v35 = v85 + v33;
      if (v35 > HIDWORD(v85))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v86, v35, 32);
        v34 = v85;
      }
      if ((_DWORD)v33)
      {
        memcpy((char *)v84 + 32 * v34, v32, 32 * v33);
        v34 = v85;
      }
      LODWORD(v85) = v34 + v33;
      v36 = *((_DWORD *)v31 + 2);
      v37 = v82;
      if (v82 >= (unint64_t)HIDWORD(v82))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v83, v82 + 1, 4);
        v37 = v82;
      }
      *((_DWORD *)v81 + v37) = v36;
      LODWORD(v82) = v82 + 1;
      v31 += 48;
    }
    while (v31 != v64);
  }
  v40 = (const void **)v72;
  if ((_DWORD)v73)
  {
    v65 = (const void **)((char *)v72 + 64 * (unint64_t)v73);
    v54 = v79;
    do
    {
      v55 = *v40;
      v56 = *((unsigned int *)v40 + 2);
      v57 = v56 + v54;
      if (v57 > HIDWORD(v79))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, &v80, v57, 8);
        v54 = v79;
      }
      if ((_DWORD)v56)
      {
        memcpy((char *)v78 + 8 * v54, v55, 8 * v56);
        v54 = v79;
      }
      v54 += v56;
      LODWORD(v79) = v54;
      v40 += 8;
    }
    while (v40 != v65);
    v38 = 0;
    v39 = v73;
    v40 = (const void **)v72;
    if (!(_DWORD)v73)
    {
LABEL_95:
      if (v40 != v74)
        goto LABEL_96;
      goto LABEL_97;
    }
LABEL_90:
    v41 = v39 << 6;
    do
    {
      v42 = *(char **)((char *)v40 + v41 - 64);
      if ((char *)v40 + v41 - 48 != v42)
        free(v42);
      v41 -= 64;
    }
    while (v41);
    v40 = (const void **)v72;
    goto LABEL_95;
  }
  v38 = 0;
  if (v72 != v74)
LABEL_96:
    free(v40);
LABEL_97:
  v43 = (char *)v75;
  if ((_DWORD)v76)
  {
    v44 = 48 * v76;
    do
    {
      v45 = *(char **)&v43[v44 - 48];
      if (&v43[v44 - 32] != v45)
        free(v45);
      v44 -= 48;
    }
    while (v44);
    v43 = (char *)v75;
  }
  if (v43 != v77)
    free(v43);
  if ((v38 & 1) == 0)
  {
    if ((*(unsigned __int8 (**)(void *))(*(_QWORD *)a1 + 312))(a1))
    {
      v103 = (llvm::APInt *)(*(uint64_t (**)(void *))(*(_QWORD *)a1 + 40))(a1);
      if ((*(unsigned __int8 (**)(void *, _QWORD *))(*(_QWORD *)a1 + 456))(a1, (_QWORD *)v62 + 14))
      {
        v46 = *((_QWORD *)v62 + 1);
        v72 = a1;
        v73 = (uint64_t)&v103;
        v74[0] = v62;
        if (mlir::cf::SwitchOp::verifyInherentAttrs(v46, (uint64_t)v62 + 112, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::SwitchOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v72))
        {
          mlir::OperationState::addSuccessors(v62, v66);
          mlir::BlockRange::BlockRange(v71, (uint64_t)v87, v88);
          mlir::OperationState::addSuccessors((unsigned int *)v62, v71[0], v71[1]);
          v47 = v93;
          v48 = v85;
          v49 = (_DWORD *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(v62);
          v49[4] = 1;
          v49[5] = v47;
          v49[6] = v48;
          v50 = (mlir::MLIRContext **)(*(uint64_t (**)(void *))(*(_QWORD *)a1 + 32))(a1);
          DenseI32ArrayAttr = mlir::Builder::getDenseI32ArrayAttr(v50, (uint64_t)v81, v82);
          *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(v62) = DenseI32ArrayAttr;
          if (mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>((uint64_t)a1, v68, v67, v61, (uint64_t)v62 + 16))
          {
            if (mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>((uint64_t)a1, (uint64_t *)&v92, (uint64_t)v90, v60, (uint64_t)v62 + 16))
            {
              v52 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>((uint64_t)a1, (uint64_t *)&v84, (uint64_t)&v78, v59, (uint64_t)v62 + 16) != 0;
              goto LABEL_113;
            }
          }
        }
      }
    }
  }
LABEL_112:
  v52 = 0;
LABEL_113:
  if (v78 != &v80)
    free(v78);
  if (v81 != v83)
    free(v81);
  if (v84 != v86)
    free(v84);
  if (v87 != v89)
    free(v87);
  if (v90[0] != &v91)
    free(v90[0]);
  if (v92 != v94)
    free(v92);
  return v52;
}

void mlir::cf::SwitchOp::print(Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  llvm::raw_ostream *v6;
  _BYTE *v7;
  llvm::raw_ostream *v8;
  _BYTE *v9;
  llvm::raw_ostream *v10;
  _BYTE *v11;
  llvm::raw_ostream *v12;
  _BYTE *v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  llvm::raw_ostream *v16;
  _BYTE *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t *v25;
  char *v26;
  uint64_t *v27;
  unint64_t v28;
  uint64_t *v29;
  _DWORD *v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t *v37;
  _DWORD *v38;
  int v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  __n128 Types;
  llvm::raw_ostream *v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  llvm::raw_ostream *v52;
  _BYTE *v53;
  llvm::raw_ostream *v54;
  _WORD *v55;
  int v56;
  unint64_t *v57;
  unint64_t v58;
  llvm::raw_ostream *v59;
  llvm::raw_ostream *v60;
  _WORD *v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  unint64_t *v68;
  uint64_t v69;
  llvm::raw_ostream *v70;
  _BYTE *v71;
  char *v72;
  mlir::Operation *v73;
  mlir::ArrayAttr *v74;
  uint64_t Value;
  uint64_t v76;
  mlir::cf::SwitchOp *v77;
  _QWORD v78[4];
  _QWORD v79[4];
  uint64_t v80[2];
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  uint64_t v89;
  unsigned __int8 v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  char *v95;
  unint64_t v96;
  _QWORD v97[2];
  unint64_t *v98;
  uint64_t v99;
  _BYTE v100[24];
  _BYTE *v101;
  char v102;
  unint64_t v103;
  unint64_t v104[2];
  unint64_t v105[4];

  v105[2] = *MEMORY[0x1E0C80C00];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 24));
  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v7 = (_BYTE *)*((_QWORD *)v6 + 4);
  if ((unint64_t)v7 >= *((_QWORD *)v6 + 3))
  {
    llvm::raw_ostream::write(v6, 32);
  }
  else
  {
    *((_QWORD *)v6 + 4) = v7 + 1;
    *v7 = 32;
  }
  v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v9 = (_BYTE *)*((_QWORD *)v8 + 4);
  if (*((_BYTE **)v8 + 3) == v9)
  {
    llvm::raw_ostream::write(v8, ":", 1uLL);
  }
  else
  {
    *v9 = 58;
    ++*((_QWORD *)v8 + 4);
  }
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (_BYTE *)*((_QWORD *)v10 + 4);
  if ((unint64_t)v11 >= *((_QWORD *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }
  else
  {
    *((_QWORD *)v10 + 4) = v11 + 1;
    *v11 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(*(_QWORD *)(*((_QWORD *)*this + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)v12 + 4);
  if (*((_BYTE **)v12 + 3) == v13)
  {
    llvm::raw_ostream::write(v12, ",", 1uLL);
  }
  else
  {
    *v13 = 44;
    ++*((_QWORD *)v12 + 4);
  }
  v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)v14 + 4);
  if ((unint64_t)v15 >= *((_QWORD *)v14 + 3))
  {
    llvm::raw_ostream::write(v14, 32);
  }
  else
  {
    *((_QWORD *)v14 + 4) = v15 + 1;
    *v15 = 32;
  }
  v16 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v17 = (_BYTE *)*((_QWORD *)v16 + 4);
  if (*((_BYTE **)v16 + 3) == v17)
  {
    llvm::raw_ostream::write(v16, "[", 1uLL);
  }
  else
  {
    *v17 = 91;
    ++*((_QWORD *)v16 + 4);
  }
  (*(void (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 128))(a2);
  v18 = (uint64_t)*this + 80;
  v19 = *(_QWORD *)(((v18 + (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 24);
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v18 = 0;
  v20 = *(unsigned int *)(v18 + 16);
  v21 = *((_QWORD *)*this + 9) + 32 * v20;
  v22 = (*(_DWORD *)(v18 + 20) + v20) - v20;
  v80[0] = v21;
  v80[1] = v22;
  mlir::OperandRange::getTypes(v80, &v81);
  mlir::ValueRange::ValueRange((unint64_t *)&v95, v81 + 32 * v82, v83 - v82);
  mlir::TypeRange::TypeRange(&v103, (uint64_t)v95, v96);
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v23 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
  else
    v23 = 0;
  v24 = *(_QWORD *)(v23 + 8);
  v25 = mlir::SuccessorRange::SuccessorRange((unint64_t *)&v95, *this);
  v26 = v95;
  v27 = (uint64_t *)mlir::SuccessorRange::SuccessorRange(v25, *this);
  v28 = *((unsigned int *)*this + 11);
  v29 = (uint64_t *)((char *)*this + 16 * ((v28 >> 23) & 1) + 64);
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v30 = (_DWORD *)((char *)*this + 16 * ((v28 >> 23) & 1) + 64);
  else
    v30 = 0;
  v31 = v30[4];
  v32 = v30[5];
  v33 = v30[6];
  if ((v28 & 0x800000) != 0)
    v34 = *((_QWORD *)*this + 9);
  else
    v34 = 0;
  v35 = (v32 + v31);
  v95 = (char *)(v34 + 32 * v35);
  v96 = (v33 + v35) - v35;
  mlir::OperandRange::split(v27, *v29, v79);
  v36 = *((unsigned int *)*this + 11);
  v37 = (uint64_t *)((char *)*this + 16 * ((v36 >> 23) & 1) + 64);
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v38 = (_DWORD *)((char *)*this + 16 * ((v36 >> 23) & 1) + 64);
  else
    v38 = 0;
  v39 = v38[4];
  v40 = v38[5];
  v41 = v38[6];
  if ((v36 & 0x800000) != 0)
    v42 = *((_QWORD *)*this + 9);
  else
    v42 = 0;
  v43 = (v40 + v39);
  v95 = (char *)(v42 + 32 * v43);
  v96 = (v41 + v43) - v43;
  mlir::OperandRange::split((uint64_t *)&v95, *v37, v78);
  Types = mlir::OperandRangeRange::getTypes((mlir::OperandRangeRange *)v78, (uint64_t)&v95);
  v92 = v24;
  v45 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *, __n128))(*(_QWORD *)a2 + 16))(a2, Types);
  v46 = *((_QWORD *)v45 + 4);
  if ((unint64_t)(*((_QWORD *)v45 + 3) - v46) > 0xA)
  {
    *(_DWORD *)(v46 + 7) = 540701804;
    *(_QWORD *)v46 = *(_QWORD *)"  default: ";
    *((_QWORD *)v45 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v45, "  default: ", 0xBuLL);
  }
  mlir::ValueRange::ValueRange(v105, v21, v22);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, unint64_t, unint64_t))(*(_QWORD *)a2 + 184))(a2, v19, v105[0], v105[1]);
  if (v24)
  {
    v77 = (mlir::cf::SwitchOp *)this;
    mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v92, (uint64_t)&v87);
    v85 = v87;
    v86 = v88;
    v47 = v89;
    v48 = v90;
    v49 = v91;
    v84 = 0;
    if ((_QWORD)v87 != v89 || BYTE8(v85) != v90 || (_QWORD)v86 != v91)
    {
      v50 = 0;
      v51 = v26 + 32;
      do
      {
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v85, (llvm::APInt *)&v93);
        LODWORD(v88) = v94;
        *(_QWORD *)&v87 = v50;
        *((_QWORD *)&v87 + 1) = v93;
        v52 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
        v53 = (_BYTE *)*((_QWORD *)v52 + 4);
        if ((unint64_t)v53 >= *((_QWORD *)v52 + 3))
        {
          llvm::raw_ostream::write(v52, 44);
        }
        else
        {
          *((_QWORD *)v52 + 4) = v53 + 1;
          *v53 = 44;
        }
        (*(void (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 128))(a2);
        v54 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
        v55 = (_WORD *)*((_QWORD *)v54 + 4);
        if (*((_QWORD *)v54 + 3) - (_QWORD)v55 > 1uLL)
        {
          *v55 = 8224;
          *((_QWORD *)v54 + 4) += 2;
          v56 = v88;
          v57 = (unint64_t *)&v87 + 1;
          if (v88 < 0x41)
            goto LABEL_55;
        }
        else
        {
          llvm::raw_ostream::write(v54, "  ", 2uLL);
          v56 = v88;
          v57 = (unint64_t *)&v87 + 1;
          if (v88 < 0x41)
            goto LABEL_55;
        }
        if (v56 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)((char *)&v87 + 8)) <= 0x40)
        {
          v57 = (unint64_t *)*((_QWORD *)&v87 + 1);
LABEL_55:
          v58 = *v57;
          goto LABEL_56;
        }
        v58 = -1;
LABEL_56:
        v59 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
        llvm::raw_ostream::operator<<(v59, v58);
        v60 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
        v61 = (_WORD *)*((_QWORD *)v60 + 4);
        if (*((_QWORD *)v60 + 3) - (_QWORD)v61 > 1uLL)
        {
          *v61 = 8250;
          *((_QWORD *)v60 + 4) += 2;
        }
        else
        {
          llvm::raw_ostream::write(v60, ": ", 2uLL);
        }
        v62 = *(_QWORD *)&v51[32 * v87 + 24];
        v63 = mlir::OperandRangeRange::dereference(v79, v79[2] + v87);
        mlir::ValueRange::ValueRange(v104, v63, v64);
        (*(void (**)(mlir::OpAsmPrinter *, uint64_t, unint64_t, unint64_t))(*(_QWORD *)a2 + 184))(a2, v62, v104[0], v104[1]);
        if (v88 >= 0x41 && *((_QWORD *)&v87 + 1))
          operator delete[](*((void **)&v87 + 1));
        v50 = v84 + 1;
        v65 = v86 + 1;
        ++v84;
        *(_QWORD *)&v86 = v86 + 1;
      }
      while ((_QWORD)v85 != v47 || BYTE8(v85) != v48 || v65 != v49);
    }
    (*(void (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 128))(a2);
    this = (Operation **)v77;
  }
  if (v102)
  {
    v66 = v101;
    if (v101 == v100)
    {
      v67 = 4;
      v66 = v100;
    }
    else
    {
      if (!v101)
        goto LABEL_72;
      v67 = 5;
    }
    (*(void (**)(void))(*v66 + 8 * v67))();
  }
LABEL_72:
  if (!(_BYTE)v99)
    goto LABEL_78;
  v68 = v98;
  if (v98 == &v96)
  {
    v69 = 4;
    v68 = &v96;
  }
  else
  {
    if (!v98)
      goto LABEL_78;
    v69 = 5;
  }
  (*(void (**)(void))(*v68 + 8 * v69))();
LABEL_78:
  v70 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v71 = (_BYTE *)*((_QWORD *)v70 + 4);
  if (*((_BYTE **)v70 + 3) == v71)
  {
    llvm::raw_ostream::write(v70, "]", 1uLL);
  }
  else
  {
    *v71 = 93;
    ++*((_QWORD *)v70 + 4);
  }
  v95 = (char *)v97;
  v97[0] = "operandSegmentSizes";
  v97[1] = 19;
  v98 = (unint64_t *)"case_operand_segments";
  v99 = 21;
  v96 = 0x200000002;
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v95, v97, 3uLL, 16);
  v72 = &v95[16 * v96];
  *(_QWORD *)v72 = "case_values";
  *((_QWORD *)v72 + 1) = 11;
  LODWORD(v96) = v96 + 1;
  v73 = *this;
  if (*((_BYTE *)*this + 47))
  {
    *(_QWORD *)&v87 = mlir::Operation::getAttrDictionary(v73);
    v74 = (mlir::ArrayAttr *)&v87;
  }
  else
  {
    v74 = (mlir::Operation *)((char *)v73 + 56);
  }
  Value = mlir::ArrayAttr::getValue(v74);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, char *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v76, v95, v96);
  if (v95 != (char *)v97)
    free(v95);
}

uint64_t mlir::Dialect::materializeConstant()
{
  return 0;
}

uint64_t collapseBranch(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v7;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unsigned int v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (*(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) != v4 + 32)
    return 0;
  mlir::Block::getTerminator((mlir::GenericProgramPoint **)v4);
  if (!v7
    || *(_QWORD *)(*(_QWORD *)(v7 + 48) + 16) != (_QWORD)&mlir::detail::TypeIDResolver<mlir::cf::BranchOp,void>::id)
  {
    return 0;
  }
  v10 = *(_QWORD **)(*a1 + 48);
  v11 = *(_QWORD **)(*a1 + 56);
  if (v11 != v10)
  {
    v12 = *(_QWORD **)(*a1 + 48);
    do
    {
      v13 = (_QWORD *)*v12;
      while (1)
      {
        v13 = (_QWORD *)*v13;
        if (!v13)
          break;
        if (v13[2] != v7)
          return 0;
      }
      ++v12;
    }
    while (v12 != v11);
  }
  v14 = *(unsigned int *)(v7 + 44);
  v15 = *(_QWORD *)(((v7 + 16 * ((v14 >> 23) & 1) + ((v14 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 24);
  if (v15 == *a1)
    return 0;
  if ((v14 & 0x800000) == 0)
  {
    if (v11 != v10)
      goto LABEL_30;
    v17 = 0;
    v16 = 0;
LABEL_33:
    *a1 = v15;
    mlir::ValueRange::ValueRange((unint64_t *)&v23, v16, v17);
    goto LABEL_34;
  }
  v16 = *(_QWORD *)(v7 + 72);
  v17 = *(unsigned int *)(v7 + 68);
  if (v11 == v10)
    goto LABEL_33;
  if ((_DWORD)v17)
  {
    v18 = (uint64_t *)(v16 + 24);
    do
    {
      v19 = *v18;
      if ((~*(_DWORD *)(*v18 + 8) & 7) != 0)
        v20 = 0;
      else
        v20 = *v18;
      if (v20 && *(_QWORD *)(v20 + 16) == *a1)
        v19 = mlir::ValueRange::dereference_iterator(a2, *(unsigned int *)(v20 + 24));
      v21 = *(unsigned int *)(a3 + 8);
      if (v21 >= *(unsigned int *)(a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v21 + 1, 8);
        v21 = *(unsigned int *)(a3 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a3 + 8 * v21) = v19;
      v22 = *(_DWORD *)(a3 + 8) + 1;
      *(_DWORD *)(a3 + 8) = v22;
      v18 += 4;
      --v17;
    }
    while (v17);
    goto LABEL_31;
  }
LABEL_30:
  v22 = *(_DWORD *)(a3 + 8);
LABEL_31:
  *a1 = v15;
  mlir::ValueRange::ValueRange((unint64_t *)&v23, *(_QWORD *)a3, v22);
LABEL_34:
  *(_OWORD *)a2 = v23;
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *&,mlir::ValueRange &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[25];
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  _QWORD v27[12];

  v27[11] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"cf.br", (const unsigned __int8 *)5, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"cf.br";
    v21[3] = 5;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  v11 = *a3;
  v12 = *a4;
  v13 = a4[1];
  v14 = v25;
  if (v25 >= v26)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v24, v27, v25 + 1, 8);
    v14 = v25;
  }
  *(_QWORD *)(v24 + 8 * v14) = v11;
  ++v25;
  mlir::OperationState::addOperands((uint64_t)v23, v12, v13);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::cf::BranchOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  unint64_t v23[2];
  _QWORD v24[25];
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  _QWORD v28[12];

  v28[11] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"cf.br", (const unsigned __int8 *)5, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"cf.br";
    v21[3] = 5;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v24);
    llvm::report_fatal_error((llvm::Twine *)v24, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  v11 = *a3;
  mlir::ValueRange::ValueRange(v23, *(_QWORD *)a4, *(_QWORD *)(a4 + 8));
  v12 = v23[0];
  v13 = v23[1];
  v14 = v26;
  if (v26 >= v27)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v26 + 1, 8);
    v14 = v26;
  }
  *(_QWORD *)(v25 + 8 * v14) = v11;
  ++v26;
  mlir::OperationState::addOperands((uint64_t)v24, v12, v13);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::cf::BranchOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::cf::SwitchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *,mlir::OperandRange,llvm::SmallVector<llvm::APInt,3u> &,llvm::SmallVector<mlir::Block *,6u> &,llvm::SmallVector<mlir::ValueRange,3u> &>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *Context;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  llvm::APInt *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  mlir::GenericProgramPoint *v33;
  mlir::GenericProgramPoint *v34;
  uint64_t v36;
  mlir::MLIRContext **v37;
  uint64_t v38;
  const char *v39;
  __int16 v40;
  uint64_t v41[4];
  __int16 v42;
  uint64_t v43[2];
  unint64_t v44[2];
  _QWORD v45[40];

  v45[38] = *MEMORY[0x1E0C80C00];
  v38 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v38);
  v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"cf.switch", (const unsigned __int8 *)9, Context);
  if (!v18)
  {
    v42 = 1283;
    v41[2] = (uint64_t)"cf.switch";
    v41[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v40 = 259;
    llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)v45);
    llvm::report_fatal_error((llvm::Twine *)v45, 1);
  }
  v37 = a1;
  mlir::OperationState::OperationState(v45, a2, v17);
  v19 = *a3;
  v20 = *a4;
  mlir::ValueRange::ValueRange(v44, *(_QWORD *)a5, *(_QWORD *)(a5 + 8));
  v21 = *(llvm::APInt **)a6;
  v22 = *(unsigned int *)(a6 + 8);
  mlir::BlockRange::BlockRange(v43, *(_QWORD *)a7, *(unsigned int *)(a7 + 8));
  v23 = *(_QWORD *)a8;
  v24 = *(unsigned int *)(a8 + 8);
  v25 = v44[0];
  v26 = v44[1];
  v28 = v43[0];
  v27 = v43[1];
  if ((_DWORD)v22)
  {
    v36 = v20;
    v41[0] = v22;
    v29 = (_QWORD *)mlir::VectorType::get((uint64_t)v41, 1uLL, *(_QWORD *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8, 0, 0);
    v30 = (uint64_t)v29;
    if (v29)
      v31 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v29 + 8);
    else
      v31 = 0;
    v32 = mlir::DenseElementsAttr::get(v30, v31, v21, v22);
    v20 = v36;
  }
  else
  {
    v32 = 0;
  }
  mlir::cf::SwitchOp::build(v37, (uint64_t)v45, v19, v25, v26, v23, v24, v32, v20, v28, v27);
  v33 = mlir::OpBuilder::create((mlir::OpBuilder *)v37, (const mlir::OperationState *)v45);
  if (*(_UNKNOWN **)(*((_QWORD *)v33 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::cf::SwitchOp,void>::id)
    v34 = v33;
  else
    v34 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v45);
  return v34;
}

void foldSwitch(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  mlir::GenericProgramPoint *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t *v21;
  _DWORD *v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  mlir::GenericProgramPoint *v29;
  uint64_t v31;
  uint64_t v32;
  void *__p;
  unsigned int v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  unsigned __int8 v41;
  uint64_t v42;
  _QWORD v43[2];
  uint64_t v44[3];

  v5 = a1 + 64;
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v6 = a1 + 64 + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1);
  else
    v6 = 0;
  v43[0] = *(_QWORD *)(v6 + 8);
  v43[1] = v43[0] != 0;
  mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)v43, (uint64_t)&v38);
  v36 = v38;
  v37 = v39;
  v7 = v40;
  v8 = v41;
  v9 = v42;
  v35 = 0;
  if ((_QWORD)v38 != v40 || BYTE8(v36) != v41 || (_QWORD)v37 != v42)
  {
    v10 = 0;
    do
    {
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v36, (llvm::APInt *)&v38);
      v34 = DWORD2(v38);
      v11 = (void *)v38;
      v32 = v10;
      __p = (void *)v38;
      if (DWORD2(v38) > 0x40)
      {
        if (llvm::APInt::equalSlowCase((const void **)&__p, a3))
        {
LABEL_24:
          mlir::SuccessorRange::SuccessorRange((unint64_t *)&v38, (Operation *)a1);
          v19 = v38;
          mlir::SuccessorRange::SuccessorRange((unint64_t *)&v38, (Operation *)a1);
          v31 = *(_QWORD *)(v19 + 32 * v32 + 56);
          v20 = *(unsigned int *)(a1 + 44);
          v21 = (uint64_t *)(v5 + 16 * ((v20 >> 23) & 1));
          if (HIBYTE(*(_DWORD *)(a1 + 44)))
            v22 = (_DWORD *)(v5 + 16 * ((v20 >> 23) & 1));
          else
            v22 = 0;
          v23 = v22[4];
          v24 = v22[5];
          v25 = v22[6];
          if ((v20 & 0x800000) != 0)
            v26 = *(_QWORD *)(a1 + 72);
          else
            v26 = 0;
          v27 = (v24 + v23);
          v44[0] = v26 + 32 * v27;
          v44[1] = (v25 + v27) - v27;
          mlir::OperandRange::split(v44, *v21, &v38);
          *(_QWORD *)&v38 = mlir::OperandRangeRange::dereference(&v38, v39 + v32);
          *((_QWORD *)&v38 + 1) = v28;
          v29 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>((mlir::OpBuilder *)(a2 + 8), *(_QWORD *)(a1 + 24), &v31, (uint64_t)&v38);
          (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a2 + 32))(a2, a1, v29);
          if (v34 >= 0x41)
          {
            if (__p)
              operator delete[](__p);
          }
          return;
        }
        if (v11)
          operator delete[](v11);
      }
      else if ((const void *)v38 == *a3)
      {
        goto LABEL_24;
      }
      v10 = v35 + 1;
      v12 = v37 + 1;
      ++v35;
      *(_QWORD *)&v37 = v37 + 1;
    }
    while ((_QWORD)v36 != v7 || BYTE8(v36) != v8 || v12 != v9);
  }
  v13 = *(unsigned int *)(a1 + 44);
  v35 = *(_QWORD *)(((v5 + 16 * ((v13 >> 23) & 1) + ((v13 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 24);
  if (BYTE3(v13))
    v14 = v5 + 16 * ((v13 >> 23) & 1);
  else
    v14 = 0;
  v15 = *(unsigned int *)(v14 + 16);
  v16 = *(_DWORD *)(v14 + 20);
  if ((v13 & 0x800000) != 0)
    v17 = *(_QWORD *)(a1 + 72);
  else
    v17 = 0;
  *(_QWORD *)&v38 = v17 + 32 * v15;
  *((_QWORD *)&v38 + 1) = (v16 + v15) - v15;
  v18 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>((mlir::OpBuilder *)(a2 + 8), *(_QWORD *)(a1 + 24), &v35, (uint64_t)&v38);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a2 + 32))(a2, a1, v18);
}

void llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Value,6u>,false>::grow(uint64_t a1, unint64_t a2)
{
  _DWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  int v13;
  unint64_t v14;

  v14 = 0;
  v3 = (_DWORD *)(a1 + 16);
  v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 64, &v14);
  v5 = v4;
  v6 = *(_DWORD **)a1;
  v7 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v7)
  {
    v8 = v7 << 6;
    v9 = v4;
    do
    {
      *v9 = v9 + 2;
      v9[1] = 0x600000000;
      if (v6[2])
        llvm::SmallVectorImpl<mlir::Value>::operator=((uint64_t)v9, (uint64_t)v6);
      v9 += 8;
      v6 += 16;
      v8 -= 64;
    }
    while (v8);
    v6 = *(_DWORD **)a1;
    v10 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v10)
    {
      v11 = v10 << 6;
      do
      {
        v12 = *(char **)((char *)v6 + v11 - 64);
        if ((char *)v6 + v11 - 48 != v12)
          free(v12);
        v11 -= 64;
      }
      while (v11);
      v6 = *(_DWORD **)a1;
    }
  }
  v13 = v14;
  if (v6 != v3)
    free(v6);
  *(_QWORD *)a1 = v5;
  *(_DWORD *)(a1 + 12) = v13;
}

uint64_t llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Value,6u>,false>::growAndEmplaceBack<>(uint64_t a1)
{
  _DWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  int v13;
  uint64_t v14;
  unint64_t v16;

  v16 = 0;
  v2 = (_DWORD *)(a1 + 16);
  v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 64, &v16);
  v4 = v3;
  v5 = &v3[8 * (unint64_t)*(unsigned int *)(a1 + 8)];
  *v5 = v5 + 2;
  v5[1] = 0x600000000;
  v6 = *(_DWORD **)a1;
  v7 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v7)
  {
    v8 = v7 << 6;
    v9 = v3;
    do
    {
      *v9 = v9 + 2;
      v9[1] = 0x600000000;
      if (v6[2])
        llvm::SmallVectorImpl<mlir::Value>::operator=((uint64_t)v9, (uint64_t)v6);
      v9 += 8;
      v6 += 16;
      v8 -= 64;
    }
    while (v8);
    v6 = *(_DWORD **)a1;
    v10 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v10)
    {
      v11 = v10 << 6;
      do
      {
        v12 = *(char **)((char *)v6 + v11 - 64);
        if ((char *)v6 + v11 - 48 != v12)
          free(v12);
        v11 -= 64;
      }
      while (v11);
      v6 = *(_DWORD **)a1;
    }
  }
  v13 = v16;
  if (v6 != v2)
    free(v6);
  *(_QWORD *)a1 = v4;
  v14 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v14;
  *(_DWORD *)(a1 + 12) = v13;
  return (uint64_t)&v4[8 * v14 - 8];
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::cf::SwitchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *&,mlir::ValueRange &,mlir::DenseIntElementsAttr &,llvm::SmallVector<mlir::Block *,6u> &,llvm::SmallVector<mlir::ValueRange,3u> &>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  uint64_t *Context;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  mlir::GenericProgramPoint *v24;
  mlir::GenericProgramPoint *v25;
  uint64_t v27;
  const char *v28;
  __int16 v29;
  uint64_t v30[4];
  __int16 v31;
  uint64_t v32[2];
  _QWORD v33[39];

  v33[38] = *MEMORY[0x1E0C80C00];
  v27 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v27);
  v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"cf.switch", (const unsigned __int8 *)9, Context);
  if (!v18)
  {
    v31 = 1283;
    v30[2] = (uint64_t)"cf.switch";
    v30[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v29 = 259;
    llvm::operator+(v30, (uint64_t *)&v28, (uint64_t)v33);
    llvm::report_fatal_error((llvm::Twine *)v33, 1);
  }
  mlir::OperationState::OperationState(v33, a2, v17);
  v19 = *a3;
  v20 = *a4;
  v22 = *a5;
  v21 = a5[1];
  v23 = *a6;
  mlir::BlockRange::BlockRange(v32, *(_QWORD *)a7, *(unsigned int *)(a7 + 8));
  mlir::cf::SwitchOp::build(a1, (uint64_t)v33, v19, v22, v21, *(_QWORD *)a8, *(unsigned int *)(a8 + 8), v23, v20, v32[0], v32[1]);
  v24 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v33);
  if (*(_UNKNOWN **)(*((_QWORD *)v24 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::cf::SwitchOp,void>::id)
    v25 = v24;
  else
    v25 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v33);
  return v25;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::LookupBucketFor<llvm::APInt>(uint64_t *a1, llvm *a2, uint64_t *a3)
{
  int v4;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  void *__p;
  unsigned int v17;
  void *v18;
  unsigned int v19;

  v4 = *((_DWORD *)a1 + 4);
  if (!v4)
  {
    v14 = 0;
    *a3 = 0;
    return v14;
  }
  v6 = *a1;
  v19 = 0;
  v18 = (void *)-1;
  v17 = 0;
  __p = (void *)-2;
  v7 = 0;
  v8 = v4 - 1;
  v9 = 1;
  v10 = llvm::DenseMapInfo<llvm::APInt,void>::getHashValue(a2, a2) & (v4 - 1);
  v11 = v6 + 16 * v10;
  v12 = *((_DWORD *)a2 + 2);
  if (v12 != *(_DWORD *)(v11 + 8))
    goto LABEL_7;
LABEL_3:
  if (v12 > 0x40)
  {
    if (!llvm::APInt::equalSlowCase((const void **)a2, (const void **)v11))
      goto LABEL_7;
  }
  else if (*(_QWORD *)a2 != *(_QWORD *)v11)
  {
LABEL_7:
    while (!llvm::DenseMapInfo<llvm::APInt,void>::isEqual(v11, (uint64_t)&v18))
    {
      if (llvm::DenseMapInfo<llvm::APInt,void>::isEqual(v11, (uint64_t)&__p) && v7 == 0)
        v7 = v11;
      v13 = v10 + v9++;
      v10 = v13 & v8;
      v11 = v6 + 16 * (v13 & v8);
      v12 = *((_DWORD *)a2 + 2);
      if (v12 == *(_DWORD *)(v11 + 8))
        goto LABEL_3;
    }
    v14 = 0;
    if (v7)
      v11 = v7;
    *a3 = v11;
    if (v17 < 0x41)
      goto LABEL_15;
    goto LABEL_13;
  }
  v14 = 1;
  *a3 = v11;
  if (v17 >= 0x41)
  {
LABEL_13:
    if (__p)
      operator delete[](__p);
  }
LABEL_15:
  if (v19 >= 0x41 && v18)
    operator delete[](v18);
  return v14;
}

BOOL llvm::DenseMapInfo<llvm::APInt,void>::isEqual(uint64_t a1, uint64_t a2)
{
  unsigned int v2;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 != *(_DWORD *)(a2 + 8))
    return 0;
  if (v2 > 0x40)
    return llvm::APInt::equalSlowCase((const void **)a1, (const void **)a2);
  return *(_QWORD *)a1 == *(_QWORD *)a2;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::InsertIntoBucketImpl<llvm::APInt>(uint64_t a1, uint64_t a2, llvm *a3, uint64_t a4)
{
  int v6;
  unsigned int v7;
  uint64_t v9;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
LABEL_8:
    llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::grow(a1, v7);
    v9 = 0;
    llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::LookupBucketFor<llvm::APInt>((uint64_t *)a1, a3, &v9);
    a4 = v9;
    ++*(_DWORD *)(a1 + 8);
    if (*(_DWORD *)(a4 + 8))
      goto LABEL_5;
    goto LABEL_4;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
    goto LABEL_8;
  ++*(_DWORD *)(a1 + 8);
  if (*(_DWORD *)(a4 + 8))
  {
LABEL_5:
    --*(_DWORD *)(a1 + 12);
    return a4;
  }
LABEL_4:
  if (*(_QWORD *)a4 != -1)
    goto LABEL_5;
  return a4;
}

char *llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  llvm::APInt *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  char *result;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(llvm::APInt **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = (char *)llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = result;
  if (v4)
  {
    v10 = (char *)(16 * v3);
    llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::moveFromOldBuckets(a1, v4, (llvm::APInt *)&v10[(_QWORD)v4]);
    llvm::deallocate_buffer(v4, v10);
  }
  *(_QWORD *)(a1 + 8) = 0;
  v11 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v11)
  {
    v12 = 16 * v11;
    v13 = result + 8;
    do
    {
      *v13 = 0;
      *((_QWORD *)v13 - 1) = -1;
      v13 += 4;
      v12 -= 16;
    }
    while (v12);
  }
  return result;
}

void llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::moveFromOldBuckets(uint64_t a1, llvm::APInt *this, llvm::APInt *a3)
{
  uint64_t v6;
  llvm::APInt *v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  void *v12;
  unsigned int v13;
  void *__p;
  unsigned int v15;
  uint64_t v16;

  *(_QWORD *)(a1 + 8) = 0;
  v15 = 0;
  __p = (void *)-1;
  v6 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v6)
  {
    v7 = *(llvm::APInt **)a1;
    v8 = 16 * v6;
    do
    {
      while (1)
      {
        v9 = v15;
        *((_DWORD *)v7 + 2) = v15;
        if (v9 <= 0x40)
          break;
        llvm::APInt::initSlowCase(v7, (const void **)&__p);
        v7 = (llvm::APInt *)((char *)v7 + 16);
        v8 -= 16;
        if (!v8)
          goto LABEL_6;
      }
      *(_QWORD *)v7 = __p;
      v7 = (llvm::APInt *)((char *)v7 + 16);
      v8 -= 16;
    }
    while (v8);
LABEL_6:
    if (v15 >= 0x41 && __p)
      operator delete[](__p);
  }
  v15 = 0;
  __p = (void *)-1;
  v13 = 0;
  v12 = (void *)-2;
  if (this == a3)
    goto LABEL_31;
  do
  {
    v10 = *((_DWORD *)this + 2);
    if (v10 == v15)
    {
      if (v10 > 0x40)
      {
        if (llvm::APInt::equalSlowCase((const void **)this, (const void **)&__p))
          goto LABEL_23;
      }
      else if (*(void **)this == __p)
      {
        goto LABEL_12;
      }
    }
    if (v10 != v13)
      goto LABEL_25;
    if (v10 <= 0x40)
    {
      if (*(void **)this == v12)
        goto LABEL_12;
LABEL_25:
      v16 = 0;
      llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::LookupBucketFor<llvm::APInt>((uint64_t *)a1, this, &v16);
      v11 = v16;
      if (*(_DWORD *)(v16 + 8) >= 0x41u && *(_QWORD *)v16)
        operator delete[](*(void **)v16);
      *(_QWORD *)v11 = *(_QWORD *)this;
      *(_DWORD *)(v11 + 8) = *((_DWORD *)this + 2);
      *((_DWORD *)this + 2) = 0;
      ++*(_DWORD *)(a1 + 8);
      goto LABEL_12;
    }
    if (!llvm::APInt::equalSlowCase((const void **)this, (const void **)&v12))
      goto LABEL_25;
LABEL_23:
    if (*(_QWORD *)this)
      operator delete[](*(void **)this);
LABEL_12:
    this = (llvm::APInt *)((char *)this + 16);
  }
  while (this != a3);
  if (v13 >= 0x41 && v12)
    operator delete[](v12);
LABEL_31:
  if (v15 >= 0x41)
  {
    if (__p)
      operator delete[](__p);
  }
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

uint64_t mlir::AsmParser::parseInteger<long long>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD **v6;
  _QWORD **v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  void *v12;
  void *v13;
  const char *v15;
  __int16 v16;
  _QWORD v17[3];
  void *v18;
  uint64_t v19;
  void *v20;
  _QWORD *v21;
  void *__p;
  _QWORD **v23;
  char v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v5 = mlir::AsmParser::parseOptionalInteger<long long>(a1, a2);
  if ((unsigned __int16)v5 <= 0xFFu)
  {
    v15 = "expected integer value";
    v16 = 259;
    (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v17, a1, v4, &v15);
    v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v17);
    if (v17[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v17);
    if (v24)
    {
      v6 = (_QWORD **)__p;
      if (__p)
      {
        v7 = v23;
        v8 = __p;
        if (v23 != __p)
        {
          do
            v7 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v7 - 1);
          while (v7 != v6);
          v8 = __p;
        }
        v23 = v6;
        operator delete(v8);
      }
      v9 = v20;
      if (v20)
      {
        v10 = v21;
        v11 = v20;
        if (v21 != v20)
        {
          do
          {
            v13 = (void *)*--v10;
            v12 = v13;
            *v10 = 0;
            if (v13)
              operator delete[](v12);
          }
          while (v10 != v9);
          v11 = v20;
        }
        v21 = v9;
        operator delete(v11);
      }
      if (v18 != &v19)
        free(v18);
    }
  }
  return v5;
}

uint64_t llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,1u>,false>::growAndEmplaceBack<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,1u>&>(uint64_t a1, uint64_t a2)
{
  _DWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  unsigned int v8;
  uint64_t v10;
  size_t v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  int v19;
  unsigned int v20;
  unint64_t v22;

  v22 = 0;
  v4 = (_DWORD *)(a1 + 16);
  v5 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 48, &v22);
  v6 = &v5[6 * *(unsigned int *)(a1 + 8)];
  v7 = v6 + 2;
  *v6 = v6 + 2;
  v6[1] = 0x100000000;
  v8 = *(_DWORD *)(a2 + 8);
  if (v6 != (_QWORD *)a2 && v8 != 0)
  {
    if (v8 < 2)
    {
      v11 = 32;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v6, v6 + 2, *(unsigned int *)(a2 + 8), 32);
      v10 = *(unsigned int *)(a2 + 8);
      if (!(_DWORD)v10)
      {
LABEL_10:
        *((_DWORD *)v6 + 2) = v8;
        goto LABEL_11;
      }
      v7 = (void *)*v6;
      v11 = 32 * v10;
    }
    memcpy(v7, *(const void **)a2, v11);
    goto LABEL_10;
  }
LABEL_11:
  v12 = *(_DWORD **)a1;
  v13 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v13)
  {
    v14 = 48 * v13;
    v15 = v5;
    do
    {
      *v15 = v15 + 2;
      v15[1] = 0x100000000;
      if (v12[2])
        llvm::SmallVectorImpl<mlir::OpAsmParser::UnresolvedOperand>::operator=((uint64_t)v15, (uint64_t)v12);
      v15 += 6;
      v12 += 12;
      v14 -= 48;
    }
    while (v14);
    v12 = *(_DWORD **)a1;
    v16 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v16)
    {
      v17 = 12 * v16;
      do
      {
        v18 = *(_DWORD **)&v12[v17 - 12];
        if (&v12[v17 - 8] != v18)
          free(v18);
        v17 -= 12;
      }
      while (v17 * 4);
      v12 = *(_DWORD **)a1;
    }
  }
  v19 = v22;
  if (v12 != v4)
    free(v12);
  *(_QWORD *)a1 = v5;
  v20 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v20;
  *(_DWORD *)(a1 + 12) = v19;
  return (uint64_t)&v5[6 * v20 - 6];
}

uint64_t llvm::SmallVectorImpl<mlir::OpAsmParser::UnresolvedOperand>::operator=(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  void *v6;
  _DWORD *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a1 != a2)
  {
    v5 = (const void *)(a2 + 16);
    v4 = *(const void **)a2;
    if (v4 != v5)
    {
      v6 = *(void **)a1;
      if (*(_QWORD *)a1 != a1 + 16)
      {
        free(v6);
        v4 = *(const void **)a2;
      }
      *(_QWORD *)a1 = v4;
      v7 = (_DWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
      goto LABEL_16;
    }
    v7 = (_DWORD *)(a2 + 8);
    v8 = *(unsigned int *)(a2 + 8);
    v9 = *(unsigned int *)(a1 + 8);
    if (v9 >= v8)
    {
      if ((_DWORD)v8)
        memmove(*(void **)a1, v4, 32 * v8 - 4);
      goto LABEL_15;
    }
    if (*(_DWORD *)(a1 + 12) >= v8)
    {
      if ((_DWORD)v9)
      {
        memmove(*(void **)a1, v4, 32 * v9 - 4);
        v10 = *v7;
        if (v9 == v10)
        {
LABEL_15:
          *(_DWORD *)(a1 + 8) = v8;
LABEL_16:
          *v7 = 0;
          return a1;
        }
      }
      else
      {
        v9 = 0;
        v10 = *v7;
        if (!*v7)
          goto LABEL_15;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v8, 32);
      v9 = 0;
      v10 = *v7;
      if (!*v7)
        goto LABEL_15;
    }
    memcpy((void *)(*(_QWORD *)a1 + 32 * v9), (const void *)(*(_QWORD *)a2 + 32 * v9), *(_QWORD *)a2 + 32 * v10 - (*(_QWORD *)a2 + 32 * v9));
    goto LABEL_15;
  }
  return a1;
}

uint64_t llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Type,6u>,false>::growAndEmplaceBack<llvm::SmallVector<mlir::Type,6u>&>(uint64_t a1, uint64_t a2)
{
  _DWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  unsigned int v8;
  unsigned int v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  int v18;
  uint64_t v19;
  unint64_t v21;

  v21 = 0;
  v4 = (_DWORD *)(a1 + 16);
  v5 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 64, &v21);
  v6 = &v5[8 * (unint64_t)*(unsigned int *)(a1 + 8)];
  v7 = v6 + 2;
  *v6 = v6 + 2;
  v6[1] = 0x600000000;
  v8 = *(_DWORD *)(a2 + 8);
  if (v6 != (_QWORD *)a2 && v8 != 0)
  {
    if (v8 < 7)
    {
      v10 = *(_DWORD *)(a2 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v6, v6 + 2, *(unsigned int *)(a2 + 8), 8);
      v10 = *(_DWORD *)(a2 + 8);
      if (!v10)
      {
LABEL_10:
        *((_DWORD *)v6 + 2) = v8;
        goto LABEL_11;
      }
      v7 = (void *)*v6;
    }
    memcpy(v7, *(const void **)a2, 8 * v10);
    goto LABEL_10;
  }
LABEL_11:
  v11 = *(_DWORD **)a1;
  v12 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v12)
  {
    v13 = v12 << 6;
    v14 = v5;
    do
    {
      *v14 = v14 + 2;
      v14[1] = 0x600000000;
      if (v11[2])
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v14, (uint64_t)v11);
      v14 += 8;
      v11 += 16;
      v13 -= 64;
    }
    while (v13);
    v11 = *(_DWORD **)a1;
    v15 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v15)
    {
      v16 = v15 << 6;
      do
      {
        v17 = *(char **)((char *)v11 + v16 - 64);
        if ((char *)v11 + v16 - 48 != v17)
          free(v17);
        v16 -= 64;
      }
      while (v16);
      v11 = *(_DWORD **)a1;
    }
  }
  v18 = v21;
  if (v11 != v4)
    free(v11);
  *(_QWORD *)a1 = v5;
  v19 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v19;
  *(_DWORD *)(a1 + 12) = v18;
  return (uint64_t)&v5[8 * v19 - 8];
}

uint64_t mlir::RegisteredOperationName::insert<mlir::cf::AssertOp>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t result;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v2 = operator new(0x70uLL);
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::AssertOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"cf.assert", 9, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::cf::AssertOp,void>::id, (uint64_t)&v9);
  v3 = v9;
  if ((_DWORD)v10)
  {
    v4 = 16 * v10;
    v5 = (void **)((char *)v9 + 8);
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v3 = v9;
  }
  if (v3 != v11)
    free(v3);
  *v2 = &unk_1E0E2DE70;
  v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, (uint64_t)&mlir::cf::AssertOp::getAttributeNames(void)::attrNames, 1);
  result = (uint64_t)v8;
  v8 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"cf.assert", 9, v3, v4, 0, 0);
  *v5 = &off_1E0E52580;
  v5[12] = mlir::cf::AssertOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::cf::AssertOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                           + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 3 && (*(_WORD *)a3 == 29549 ? (v7 = *(_BYTE *)(a3 + 2) == 103) : (v7 = 0), v7))
    return *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;

  v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 3 && *(_WORD *)result == 29549 && *(_BYTE *)(result + 2) == 103)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
        v9 = a4;
      else
        v9 = 0;
      *v5 = v9;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v5 = *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"msg", 3, v5);
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;

  v7 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  return !v7
      || mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(v7, (const void **)"msg", (const char *)3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::cf::AssertOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::cf::AssertOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::AssertOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::AssertOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::AssertOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::AssertOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::StringAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::AssertOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  uint64_t *v8;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  void **p_vtable;
  int v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  const char *v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  unint64_t v35;
  unint64_t v36;
  const char *v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  unint64_t v44;
  unint64_t v45;
  const char *v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  unint64_t v53;
  unint64_t v54;
  const char *v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  int v60;
  int v61;
  unint64_t v62;
  unint64_t v63;
  const char *v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  unint64_t v71;
  unint64_t v72;
  const char *v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  void *v93;
  void *v94;
  void *v95;
  void *v96;
  void *v97;
  void *v98;
  const char *v99;
  unint64_t v100;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v93 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v25 = v24;
    a1 = v93;
    if (v25)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v100 = 83;
      v26 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v26)
        v27 = v26;
      else
        v27 = v100;
      v28 = &v99[v27];
      v29 = v100 - v27;
      if (v100 - v27 >= 0x12)
        v30 = 18;
      else
        v30 = v100 - v27;
      v31 = v29 - v30;
      if (v31 >= v31 - 1)
        v32 = v31 - 1;
      else
        v32 = v31;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v28[v30], v32);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v93;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v88 = v3;
    v94 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v34 = v33;
    v3 = v88;
    a1 = v94;
    if (v34)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      v100 = 83;
      v35 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v35)
        v36 = v35;
      else
        v36 = v100;
      v37 = &v99[v36];
      v38 = v100 - v36;
      if (v100 - v36 >= 0x12)
        v39 = 18;
      else
        v39 = v100 - v36;
      v40 = v38 - v39;
      if (v40 >= v40 - 1)
        v41 = v40 - 1;
      else
        v41 = v40;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v37[v39], v41);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v88;
      a1 = v94;
    }
  }
  v6 = v5[188];
  v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v7 & 1) == 0)
  {
    v89 = v3;
    v95 = a1;
    v84 = v6;
    v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v6 = v84;
    v3 = v89;
    v43 = v42;
    a1 = v95;
    if (v43)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v100 = 86;
      v44 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v44)
        v45 = v44;
      else
        v45 = v100;
      v46 = &v99[v45];
      v47 = v100 - v45;
      if (v100 - v45 >= 0x12)
        v48 = 18;
      else
        v48 = v100 - v45;
      v49 = v47 - v48;
      if (v49 >= v49 - 1)
        v50 = v49 - 1;
      else
        v50 = v49;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v6 = v84;
      v3 = v89;
      a1 = v95;
    }
  }
  v9 = v8[196];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v90 = v3;
    v96 = a1;
    v81 = v9;
    v85 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v81;
    v6 = v85;
    v52 = v51;
    v3 = v90;
    a1 = v96;
    if (v52)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v100 = 82;
      v53 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v53)
        v54 = v53;
      else
        v54 = v100;
      v55 = &v99[v54];
      v56 = v100 - v54;
      if (v100 - v54 >= 0x12)
        v57 = 18;
      else
        v57 = v100 - v54;
      v58 = v56 - v57;
      if (v58 >= v58 - 1)
        v59 = v58 - 1;
      else
        v59 = v58;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v81;
      v6 = v85;
      v3 = v90;
      a1 = v96;
    }
  }
  v12 = v11[181];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v91 = v3;
    v97 = a1;
    v82 = v9;
    v86 = v6;
    v79 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v79;
    v9 = v82;
    v6 = v86;
    v3 = v91;
    v61 = v60;
    a1 = v97;
    if (v61)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v100 = 84;
      v62 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v62)
        v63 = v62;
      else
        v63 = v100;
      v64 = &v99[v63];
      v65 = v100 - v63;
      if (v100 - v63 >= 0x12)
        v66 = 18;
      else
        v66 = v100 - v63;
      v67 = v65 - v66;
      if (v67 >= v67 - 1)
        v68 = v67 - 1;
      else
        v68 = v67;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v79;
      v9 = v82;
      v6 = v86;
      v3 = v91;
      a1 = v97;
    }
  }
  v15 = v14[192];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v16 & 1) == 0)
  {
    v92 = v3;
    v98 = a1;
    v83 = v9;
    v87 = v6;
    v78 = v15;
    v80 = v12;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v15 = v78;
    v12 = v80;
    v9 = v83;
    v6 = v87;
    v70 = v69;
    v3 = v92;
    a1 = v98;
    if (v70)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v100 = 89;
      v71 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v71)
        v72 = v71;
      else
        v72 = v100;
      v73 = &v99[v72];
      v74 = v100 - v72;
      if (v100 - v72 >= 0x12)
        v75 = 18;
      else
        v75 = v100 - v72;
      v76 = v74 - v75;
      if (v76 >= v76 - 1)
        v77 = v76 - 1;
      else
        v77 = v76;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v15 = v78;
      v12 = v80;
      v9 = v83;
      v6 = v87;
      v3 = v92;
      a1 = v98;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == (_QWORD)a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || p_vtable[481] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::cf::AssertOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyZeroResults(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyOneOperand(a1, v5))
  {
    return 0;
  }
  v7 = a1;
  return mlir::cf::AssertOp::verifyInvariantsImpl((uint64_t **)&v7);
}

uint64_t mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::BranchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"cf.br", 5, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::cf::BranchOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E2DF38;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::foldHook()
{
  unsigned int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"cf.br", 5, v3, v4, 0, 0);
  *v5 = &off_1E0E525D8;
  v5[12] = mlir::cf::BranchOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::cf::BranchOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x20uLL);
  *v2 = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::getSuccessorOperands;
  v2[1] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::getSuccessorBlockArgument;
  v2[2] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::getSuccessorForOperands;
  v2[3] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::areTypesCompatible;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface]";
      v15 = 73;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[140], v2);
}

void mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::getSuccessorOperands(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  int v3;
  uint64_t v4[2];
  void *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 46) & 0x80) != 0)
    v3 = *(_DWORD *)(a1 + 68);
  else
    v3 = 0;
  mlir::MutableOperandRange::MutableOperandRange((uint64_t)v4, a1, 0, v3, 0, 0);
  mlir::SuccessorOperands::SuccessorOperands(a2, v4);
  if (v5 != v6)
    free(v5);
}

unint64_t mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::getSuccessorBlockArgument(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t BranchSuccessorArgument;
  char v11;
  char v12;
  unint64_t v13;
  unsigned __int8 v14;
  _DWORD v16[6];
  void *v17;
  uint64_t v18;
  uint64_t v19[2];
  void *v20;
  _QWORD v21[4];

  v21[3] = *MEMORY[0x1E0C80C00];
  v3 = *(unsigned int *)(a2 + 40);
  if ((_DWORD)v3)
  {
    v6 = 0;
    v7 = a2 + 64;
    v8 = 32 * v3;
    while (1)
    {
      if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
        v9 = *(_DWORD *)(a2 + 68);
      else
        v9 = 0;
      mlir::MutableOperandRange::MutableOperandRange((uint64_t)v19, a2, 0, v9, 0, 0);
      mlir::SuccessorOperands::SuccessorOperands((uint64_t)v16, v19);
      if (v20 != v21)
        free(v20);
      BranchSuccessorArgument = mlir::detail::getBranchSuccessorArgument(v16, a3, *(_QWORD *)(((v7+ 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ v6+ 24));
      v12 = v11;
      if (v17 != &v18)
        free(v17);
      if (v12)
        break;
      v6 += 32;
      if (v8 == v6)
      {
        v14 = 0;
        goto LABEL_15;
      }
    }
    v14 = BranchSuccessorArgument;
LABEL_15:
    v13 = BranchSuccessorArgument & 0xFFFFFFFFFFFFFF00;
  }
  else
  {
    v14 = 0;
    v13 = 0;
  }
  return v13 | v14;
}

uint64_t mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::getSuccessorForOperands(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(((a2
                     + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                     + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                     + 71) & 0xFFFFFFFFFFFFFFF8)
                   + 24);
}

BOOL mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::areTypesCompatible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a3 == a4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::BranchOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::BranchOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::BranchOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  __guard *v8;
  __guard v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  __guard *v17;
  __guard v18;
  unsigned __int8 v19;
  void **p_vtable;
  void *v21;
  unsigned __int8 v22;
  void **v23;
  void *v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  int v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  const char *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  const char *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  const char *v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  const char *v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  const char *v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  const char *v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  const char *v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  const char *v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  void *v131;
  void *v132;
  void *v133;
  void *v134;
  void *v135;
  __guard v136;
  __guard v137;
  __guard v138;
  __guard v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  __guard v151;
  __guard v152;
  __guard v153;
  __guard v154;
  __guard v155;
  __guard v156;
  __guard v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  void *v179;
  void *v180;
  void *v181;
  void *v182;
  void *v183;
  void *v184;
  const char *v185;
  unint64_t v186;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v175 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v41 = v40;
    a1 = v175;
    if (v41)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v186 = 83;
      v42 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v42)
        v43 = v42;
      else
        v43 = v186;
      v44 = &v185[v43];
      v45 = v186 - v43;
      if (v186 - v43 >= 0x12)
        v46 = 18;
      else
        v46 = v186 - v43;
      v47 = v45 - v46;
      if (v47 >= v47 - 1)
        v48 = v47 - 1;
      else
        v48 = v47;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v44[v46], v48);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v175;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v166 = v3;
    v176 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v50 = v49;
    v3 = v166;
    a1 = v176;
    if (v50)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      v186 = 83;
      v51 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v51)
        v52 = v51;
      else
        v52 = v186;
      v53 = &v185[v52];
      v54 = v186 - v52;
      if (v186 - v52 >= 0x12)
        v55 = 18;
      else
        v55 = v186 - v52;
      v56 = v54 - v55;
      if (v56 >= v56 - 1)
        v57 = v56 - 1;
      else
        v57 = v56;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v53[v55], v57);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v166;
      a1 = v176;
    }
  }
  v6 = v5[188];
  if ((v7 & 1) == 0)
  {
    v167 = v3;
    v177 = a1;
    v158 = v6;
    v6 = v158;
    v59 = v58;
    v3 = v167;
    a1 = v177;
    if (v59)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneSuccessor<Empty>]";
      v186 = 84;
      v60 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v60)
        v61 = v60;
      else
        v61 = v186;
      v62 = &v185[v61];
      v63 = v186 - v61;
      if (v186 - v61 >= 0x12)
        v64 = 18;
      else
        v64 = v186 - v61;
      v65 = v63 - v64;
      if (v65 >= v65 - 1)
        v66 = v65 - 1;
      else
        v66 = v65;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneSuccessor<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneSuccessor>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v62[v64], v66);
      v6 = v158;
      v3 = v167;
      a1 = v177;
    }
  }
  v9 = v8[417];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v168 = v3;
    v178 = a1;
    v151 = v9;
    v159 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v151;
    v6 = v159;
    v68 = v67;
    v3 = v168;
    a1 = v178;
    if (v68)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicOperands<Empty>]";
      v186 = 88;
      v69 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v69)
        v70 = v69;
      else
        v70 = v186;
      v71 = &v185[v70];
      v72 = v186 - v70;
      if (v186 - v70 >= 0x12)
        v73 = 18;
      else
        v73 = v186 - v70;
      v74 = v72 - v73;
      if (v74 >= v74 - 1)
        v75 = v74 - 1;
      else
        v75 = v74;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v71[v73], v75);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v151;
      v6 = v159;
      v3 = v168;
      a1 = v178;
    }
  }
  v12 = v11[198];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v169 = v3;
    v179 = a1;
    v152 = v9;
    v160 = v6;
    v145 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v145;
    v9 = v152;
    v6 = v160;
    v77 = v76;
    v3 = v169;
    a1 = v179;
    if (v77)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v186 = 84;
      v78 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v78)
        v79 = v78;
      else
        v79 = v186;
      v80 = &v185[v79];
      v81 = v186 - v79;
      if (v186 - v79 >= 0x12)
        v82 = 18;
      else
        v82 = v186 - v79;
      v83 = v81 - v82;
      if (v83 >= v83 - 1)
        v84 = v83 - 1;
      else
        v84 = v83;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v80[v82], v84);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v145;
      v9 = v152;
      v6 = v160;
      v3 = v169;
      a1 = v179;
    }
  }
  v15 = v14[192];
  if ((v16 & 1) == 0)
  {
    v170 = v3;
    v180 = a1;
    v153 = v9;
    v161 = v6;
    v140 = v15;
    v146 = v12;
    v15 = v140;
    v12 = v146;
    v9 = v153;
    v6 = v161;
    v86 = v85;
    v3 = v170;
    a1 = v180;
    if (v86)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface::Trait<Empty>]";
      v186 = 87;
      v87 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v87)
        v88 = v87;
      else
        v88 = v186;
      v89 = &v185[v88];
      v90 = v186 - v88;
      if (v186 - v88 >= 0x12)
        v91 = 18;
      else
        v91 = v186 - v88;
      v92 = v90 - v91;
      if (v92 >= v92 - 1)
        v93 = v92 - 1;
      else
        v93 = v92;
      mlir::detail::TypeIDResolver<mlir::BranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BranchOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v89[v91], v93);
      v15 = v140;
      v12 = v146;
      v9 = v153;
      v6 = v161;
      v3 = v170;
      a1 = v180;
    }
  }
  v18 = v17[419];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v171 = v3;
    v181 = a1;
    v154 = v9;
    v162 = v6;
    v141 = v15;
    v147 = v12;
    v136 = v18;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v136;
    v15 = v141;
    v12 = v147;
    v9 = v154;
    v6 = v162;
    v95 = v94;
    v3 = v171;
    a1 = v181;
    if (v95)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v186 = 95;
      v96 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v96)
        v97 = v96;
      else
        v97 = v186;
      v98 = &v185[v97];
      v99 = v186 - v97;
      if (v186 - v97 >= 0x12)
        v100 = 18;
      else
        v100 = v186 - v97;
      v101 = v99 - v100;
      if (v101 >= v101 - 1)
        v102 = v101 - 1;
      else
        v102 = v101;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v98[v100], v102);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v136;
      v15 = v141;
      v12 = v147;
      v9 = v154;
      v6 = v162;
      v3 = v171;
      a1 = v181;
    }
  }
  v21 = p_vtable[486];
  v23 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v22 & 1) == 0)
  {
    v172 = v3;
    v182 = a1;
    v155 = v9;
    v163 = v6;
    v142 = v15;
    v148 = v12;
    v133 = v21;
    v137 = v18;
    v23 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v21 = v133;
    v18 = v137;
    v15 = v142;
    v12 = v148;
    v9 = v155;
    v6 = v163;
    v104 = v103;
    v3 = v172;
    a1 = v182;
    if (v104)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v186 = 99;
      v105 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v105)
        v106 = v105;
      else
        v106 = v186;
      v107 = &v185[v106];
      v108 = v186 - v106;
      if (v186 - v106 >= 0x12)
        v109 = 18;
      else
        v109 = v186 - v106;
      v110 = v108 - v109;
      if (v110 >= v110 - 1)
        v111 = v110 - 1;
      else
        v111 = v110;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v107[v109], v111);
      v23 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v21 = v133;
      v18 = v137;
      v15 = v142;
      v12 = v148;
      v9 = v155;
      v6 = v163;
      v3 = v172;
      a1 = v182;
    }
  }
  v24 = v23[504];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v173 = v3;
    v183 = a1;
    v156 = v9;
    v164 = v6;
    v143 = v15;
    v149 = v12;
    v134 = v21;
    v138 = v18;
    v131 = v24;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v131;
    v21 = v134;
    v18 = v138;
    v15 = v143;
    v12 = v149;
    v9 = v156;
    v6 = v164;
    v113 = v112;
    v3 = v173;
    a1 = v183;
    if (v113)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v186 = 93;
      v114 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v114)
        v115 = v114;
      else
        v115 = v186;
      v116 = &v185[v115];
      v117 = v186 - v115;
      if (v186 - v115 >= 0x12)
        v118 = 18;
      else
        v118 = v186 - v115;
      v119 = v117 - v118;
      if (v119 >= v119 - 1)
        v120 = v119 - 1;
      else
        v120 = v119;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v116[v118], v120);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v131;
      v21 = v134;
      v18 = v138;
      v15 = v143;
      v12 = v149;
      v9 = v156;
      v6 = v164;
      v3 = v173;
      a1 = v183;
    }
  }
  v27 = v26[158];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v174 = v3;
    v184 = a1;
    v157 = v9;
    v165 = v6;
    v144 = v15;
    v150 = v12;
    v135 = v21;
    v139 = v18;
    v130 = v27;
    v132 = v24;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v130;
    v24 = v132;
    v21 = v135;
    v18 = v139;
    v15 = v144;
    v12 = v150;
    v9 = v157;
    v6 = v165;
    v122 = v121;
    v3 = v174;
    a1 = v184;
    if (v122)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsTerminator<Empty>]";
      v186 = 84;
      v123 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v123)
        v124 = v123;
      else
        v124 = v186;
      v125 = &v185[v124];
      v126 = v186 - v124;
      if (v186 - v124 >= 0x12)
        v127 = 18;
      else
        v127 = v186 - v124;
      v128 = v126 - v127;
      if (v128 >= v128 - 1)
        v129 = v128 - 1;
      else
        v129 = v128;
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v125[v127], v129);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v130;
      v24 = v132;
      v21 = v135;
      v18 = v139;
      v15 = v144;
      v12 = v150;
      v9 = v157;
      v6 = v165;
      v3 = v174;
      a1 = v184;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == (_QWORD)a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == a1
      || v27 == (_QWORD)a1
      || v29[190] == (_QWORD)a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::cf::BranchOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;

  return mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
      && mlir::OpTrait::impl::verifyZeroResults(a1, v3)
      && mlir::OpTrait::impl::verifyOneSuccessor(a1, v4)
      && mlir::detail::BranchOpInterfaceTrait<mlir::cf::BranchOp>::verifyTrait((uint64_t)a1)
      && mlir::OpTrait::impl::verifyIsTerminator(a1, v5) != 0;
}

uint64_t mlir::detail::BranchOpInterfaceTrait<mlir::cf::BranchOp>::verifyTrait(uint64_t a1)
{
  int v1;
  unsigned int v3;
  int v4;
  char v5;
  unsigned int v7[6];
  void *v8;
  uint64_t v9;
  uint64_t v10[2];
  void *v11;
  _QWORD v12[4];

  v12[3] = *MEMORY[0x1E0C80C00];
  v1 = *(_DWORD *)(a1 + 40);
  if (!v1)
    return 1;
  v3 = 0;
  while (1)
  {
    if ((*(_BYTE *)(a1 + 46) & 0x80) != 0)
      v4 = *(_DWORD *)(a1 + 68);
    else
      v4 = 0;
    mlir::MutableOperandRange::MutableOperandRange((uint64_t)v10, a1, 0, v4, 0, 0);
    mlir::SuccessorOperands::SuccessorOperands((uint64_t)v7, v10);
    if (v11 != v12)
      free(v11);
    v5 = mlir::detail::verifyBranchSuccessorOperands(a1, v3, v7);
    if (v8 != &v9)
      free(v8);
    if (!v5)
      break;
    if (v1 == ++v3)
      return 1;
  }
  return 0;
}

uint64_t mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::CondBranchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"cf.cond_br", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::cf::CondBranchOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E2DDA8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

void mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::cf::CondBranchOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, mlir::OperationState *a2)@<X8>)
{
  *a1 = mlir::cf::CondBranchOp::parse;
  a1[3] = (BOOL (*)(uint64_t, mlir::OperationState *))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                               + 2);
}

void mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  unint64_t v8;
  BOOL v9;
  uint64_t v14;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v8 = *(unsigned int *)(a2 + 44);
  if (a4 == 19)
  {
    if (*a3 != 0x53646E617265706FLL
      || a3[1] != 0x6953746E656D6765
      || *(_QWORD *)((char *)a3 + 11) != 0x73657A6953746E65)
    {
      return 0;
    }
  }
  else
  {
    if (a4 != 21)
      return 0;
    v9 = *a3 == 0x5F646E617265706FLL && a3[1] == 0x5F746E656D676573;
    if (!v9 || *(_QWORD *)((char *)a3 + 13) != 0x73657A69735F746ELL)
      return 0;
  }
  if (BYTE3(v8))
    v14 = a2 + 16 * ((v8 >> 23) & 1) + 64;
  else
    v14 = 0;
  return mlir::detail::DenseArrayAttrImpl<int>::get(Context, v14, 3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  char *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::cf::CondBranchOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::MLIRContext *Context;
  uint64_t v6;
  uint64_t v7;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v6 = 0;
  v7 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v6, 3);
  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v7);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::getOpPropertyByteSize()
{
  return 12;
}

void mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;

  if (a4)
  {
    v4 = *a4;
    *(_DWORD *)(a3 + 8) = *((_DWORD *)a4 + 2);
    *(_QWORD *)a3 = v4;
  }
  else
  {
    *(_DWORD *)(a3 + 8) = 0;
    *(_QWORD *)a3 = 0;
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::cf::CondBranchOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v4 = 0;
  return mlir::cf::CondBranchOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;

  v3 = *a3;
  *(_DWORD *)(a2 + 8) = *((_DWORD *)a3 + 2);
  *(_QWORD *)a2 = v3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::compareProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(_QWORD *)a3 == *(_QWORD *)a2 && *(_DWORD *)(a3 + 8) == (unint64_t)*(unsigned int *)(a2 + 8);
}

unint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::hashProperties(uint64_t a1, _QWORD *a2)
{
  return mlir::cf::CondBranchOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int *v5;
  mlir::MLIRContext *Context;
  uint64_t v7;
  uint64_t result;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (int *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 104))(a3) <= 5)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    v7 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, (uint64_t)v5, 3);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 16))(a3, v7);
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 104))(a3);
  if (result >= 6)
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a3, v5, 3);
  return result;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x20uLL);
  *v2 = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::getSuccessorOperands;
  v2[1] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::getSuccessorBlockArgument;
  v2[2] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::getSuccessorForOperands;
  v2[3] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::areTypesCompatible;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface]";
      v15 = 73;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[140], v2);
}

void mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::getSuccessorOperands(uint64_t a1@<X1>, int a2@<W2>, uint64_t a3@<X8>)
{
  uint64_t v3;

  v3 = a1;
  mlir::cf::CondBranchOp::getSuccessorOperands((mlir::cf::CondBranchOp *)&v3, a2, a3);
}

unint64_t mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::getSuccessorBlockArgument(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t BranchSuccessorArgument;
  char v10;
  char v11;
  unsigned __int8 v12;
  unint64_t v13;
  uint64_t v15;
  _DWORD v16[6];
  void *v17;
  _QWORD v18[4];

  v18[3] = *MEMORY[0x1E0C80C00];
  v3 = *(unsigned int *)(a2 + 40);
  if ((_DWORD)v3)
  {
    v6 = 0;
    v7 = a2 + 64;
    v8 = 24;
    while (1)
    {
      v15 = a2;
      mlir::cf::CondBranchOp::getSuccessorOperands((mlir::cf::CondBranchOp *)&v15, v6, (uint64_t)v16);
      BranchSuccessorArgument = mlir::detail::getBranchSuccessorArgument(v16, a3, *(_QWORD *)(((v7+ 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ v8));
      v11 = v10;
      if (v17 != v18)
        free(v17);
      if (v11)
        break;
      ++v6;
      v8 += 32;
      if (v3 == v6)
      {
        v12 = 0;
        goto LABEL_10;
      }
    }
    v12 = BranchSuccessorArgument;
LABEL_10:
    v13 = BranchSuccessorArgument & 0xFFFFFFFFFFFFFF00;
  }
  else
  {
    v12 = 0;
    v13 = 0;
  }
  return v13 | v12;
}

uint64_t mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::getSuccessorForOperands(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  unsigned int v8;
  uint64_t v9;
  void *__p;
  unsigned int v11;
  uint64_t v12;

  v3 = *a3;
  if (!*a3)
    return 0;
  v4 = *(void **)(*(_QWORD *)v3 + 136);
  if (v4 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    v3 = 0;
  v12 = v3;
  if (v4 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    return 0;
  mlir::IntegerAttr::getValue(&v12, (llvm::APInt *)&__p);
  v8 = v11;
  if (v11 > 0x40)
  {
    if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) == v8 - 1)
      goto LABEL_9;
LABEL_11:
    v9 = 1;
    goto LABEL_12;
  }
  if (__p != (void *)1)
    goto LABEL_11;
LABEL_9:
  v9 = 0;
LABEL_12:
  v5 = *(_QWORD *)(((a2
                   + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * v9
                 + 24);
  if (v8 < 0x41 || !__p)
    return v5;
  operator delete[](__p);
  return v5;
}

BOOL mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::areTypesCompatible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a3 == a4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::CondBranchOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::CondBranchOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::CondBranchOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  __guard *v8;
  __guard v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  __guard *v14;
  __guard v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **p_vtable;
  void *v21;
  unsigned __int8 v22;
  __guard *v23;
  __guard v24;
  unsigned __int8 v25;
  void **v26;
  void *v27;
  unsigned __int8 v28;
  void **v29;
  void *v30;
  unsigned __int8 v31;
  uint64_t *v32;
  uint64_t v33;
  unsigned __int8 v34;
  uint64_t *v35;
  int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  const char *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  const char *v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  unint64_t v86;
  unint64_t v87;
  const char *v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  const char *v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  unint64_t v104;
  unint64_t v105;
  const char *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unint64_t v113;
  unint64_t v114;
  const char *v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  unint64_t v122;
  unint64_t v123;
  const char *v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  int v129;
  int v130;
  unint64_t v131;
  unint64_t v132;
  const char *v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  unint64_t v140;
  unint64_t v141;
  const char *v142;
  unint64_t v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  int v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  const char *v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  uint64_t v156;
  void *v157;
  void *v158;
  void *v159;
  void *v160;
  void *v161;
  __guard v162;
  __guard v163;
  __guard v164;
  __guard v165;
  void *v166;
  void *v167;
  void *v168;
  void *v169;
  void *v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  __guard v177;
  __guard v178;
  __guard v179;
  __guard v180;
  __guard v181;
  __guard v182;
  __guard v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  __guard v192;
  __guard v193;
  __guard v194;
  __guard v195;
  __guard v196;
  __guard v197;
  __guard v198;
  __guard v199;
  __guard v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  void *v222;
  void *v223;
  void *v224;
  void *v225;
  void *v226;
  void *v227;
  void *v228;
  void *v229;
  void *v230;
  void *v231;
  void *v232;
  void *v233;
  const char *v234;
  unint64_t v235;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v222 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v49 = v48;
    a1 = v222;
    if (v49)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v235 = 83;
      v50 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v50)
        v51 = v50;
      else
        v51 = v235;
      v52 = &v234[v51];
      v53 = v235 - v51;
      if (v235 - v51 >= 0x12)
        v54 = 18;
      else
        v54 = v235 - v51;
      v55 = v53 - v54;
      if (v55 >= v55 - 1)
        v56 = v55 - 1;
      else
        v56 = v55;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v222;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v211 = v3;
    v223 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v58 = v57;
    v3 = v211;
    a1 = v223;
    if (v58)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      v235 = 83;
      v59 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v59)
        v60 = v59;
      else
        v60 = v235;
      v61 = &v234[v60];
      v62 = v235 - v60;
      if (v235 - v60 >= 0x12)
        v63 = 18;
      else
        v63 = v235 - v60;
      v64 = v62 - v63;
      if (v64 >= v64 - 1)
        v65 = v64 - 1;
      else
        v65 = v64;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v211;
      a1 = v223;
    }
  }
  v6 = v5[188];
  if ((v7 & 1) == 0)
  {
    v212 = v3;
    v224 = a1;
    v201 = v6;
    v6 = v201;
    v3 = v212;
    v67 = v66;
    a1 = v224;
    if (v67)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NSuccessors<2>::Impl<Empty>]";
      v235 = 92;
      v68 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v68)
        v69 = v68;
      else
        v69 = v235;
      v70 = &v234[v69];
      v71 = v235 - v69;
      if (v235 - v69 >= 0x12)
        v72 = 18;
      else
        v72 = v235 - v69;
      v73 = v71 - v72;
      if (v73 >= v73 - 1)
        v74 = v73 - 1;
      else
        v74 = v73;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NSuccessors<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NSuccessors<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      v6 = v201;
      v3 = v212;
      a1 = v224;
    }
  }
  v9 = v8[421];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v213 = v3;
    v225 = a1;
    v202 = v6;
    v192 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v192;
    v6 = v202;
    v3 = v213;
    v76 = v75;
    a1 = v225;
    if (v76)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>]";
      v235 = 97;
      v77 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v77)
        v78 = v77;
      else
        v78 = v235;
      v79 = &v234[v78];
      v80 = v235 - v78;
      if (v235 - v78 >= 0x12)
        v81 = 18;
      else
        v81 = v235 - v78;
      v82 = v80 - v81;
      if (v82 >= v82 - 1)
        v83 = v82 - 1;
      else
        v83 = v82;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v192;
      v6 = v202;
      v3 = v213;
      a1 = v225;
    }
  }
  v12 = v11[197];
  if ((v13 & 1) == 0)
  {
    v214 = v3;
    v226 = a1;
    v203 = v6;
    v184 = v12;
    v193 = v9;
    v12 = v184;
    v9 = v193;
    v6 = v203;
    v3 = v214;
    v85 = v84;
    a1 = v226;
    if (v85)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      v235 = 96;
      v86 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v86)
        v87 = v86;
      else
        v87 = v235;
      v88 = &v234[v87];
      v89 = v235 - v87;
      if (v235 - v87 >= 0x12)
        v90 = 18;
      else
        v90 = v235 - v87;
      v91 = v89 - v90;
      if (v91 >= v91 - 1)
        v92 = v91 - 1;
      else
        v92 = v91;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      v12 = v184;
      v9 = v193;
      v6 = v203;
      v3 = v214;
      a1 = v226;
    }
  }
  v15 = v14[423];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v215 = v3;
    v227 = a1;
    v204 = v6;
    v185 = v12;
    v194 = v9;
    v177 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v177;
    v12 = v185;
    v9 = v194;
    v6 = v204;
    v3 = v215;
    v94 = v93;
    a1 = v227;
    if (v94)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v235 = 84;
      v95 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v95)
        v96 = v95;
      else
        v96 = v235;
      v97 = &v234[v96];
      v98 = v235 - v96;
      if (v235 - v96 >= 0x12)
        v99 = 18;
      else
        v99 = v235 - v96;
      v100 = v98 - v99;
      if (v100 >= v100 - 1)
        v101 = v100 - 1;
      else
        v101 = v100;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v177;
      v12 = v185;
      v9 = v194;
      v6 = v204;
      v3 = v215;
      a1 = v227;
    }
  }
  v18 = v17[192];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v216 = v3;
    v228 = a1;
    v205 = v6;
    v186 = v12;
    v195 = v9;
    v171 = v18;
    v178 = v15;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v171;
    v15 = v178;
    v12 = v186;
    v9 = v195;
    v6 = v205;
    v3 = v216;
    v103 = v102;
    a1 = v228;
    if (v103)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v235 = 89;
      v104 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v104)
        v105 = v104;
      else
        v105 = v235;
      v106 = &v234[v105];
      v107 = v235 - v105;
      if (v235 - v105 >= 0x12)
        v108 = 18;
      else
        v108 = v235 - v105;
      v109 = v107 - v108;
      if (v109 >= v109 - 1)
        v110 = v109 - 1;
      else
        v110 = v109;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v171;
      v15 = v178;
      v12 = v186;
      v9 = v195;
      v6 = v205;
      v3 = v216;
      a1 = v228;
    }
  }
  v21 = p_vtable[481];
  if ((v22 & 1) == 0)
  {
    v217 = v3;
    v229 = a1;
    v206 = v6;
    v187 = v12;
    v196 = v9;
    v172 = v18;
    v179 = v15;
    v166 = v21;
    v21 = v166;
    v18 = v172;
    v15 = v179;
    v12 = v187;
    v9 = v196;
    v6 = v206;
    v3 = v217;
    v112 = v111;
    a1 = v229;
    if (v112)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface::Trait<Empty>]";
      v235 = 87;
      v113 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v113)
        v114 = v113;
      else
        v114 = v235;
      v115 = &v234[v114];
      v116 = v235 - v114;
      if (v235 - v114 >= 0x12)
        v117 = 18;
      else
        v117 = v235 - v114;
      v118 = v116 - v117;
      if (v118 >= v118 - 1)
        v119 = v118 - 1;
      else
        v119 = v118;
      mlir::detail::TypeIDResolver<mlir::BranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BranchOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      v21 = v166;
      v18 = v172;
      v15 = v179;
      v12 = v187;
      v9 = v196;
      v6 = v206;
      v3 = v217;
      a1 = v229;
    }
  }
  v24 = v23[419];
  v26 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v25 & 1) == 0)
  {
    v218 = v3;
    v230 = a1;
    v207 = v6;
    v188 = v12;
    v197 = v9;
    v173 = v18;
    v180 = v15;
    v162 = v24;
    v167 = v21;
    v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v24 = v162;
    v21 = v167;
    v18 = v173;
    v15 = v180;
    v12 = v188;
    v9 = v197;
    v6 = v207;
    v3 = v218;
    v121 = v120;
    a1 = v230;
    if (v121)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v235 = 95;
      v122 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v122)
        v123 = v122;
      else
        v123 = v235;
      v124 = &v234[v123];
      v125 = v235 - v123;
      if (v235 - v123 >= 0x12)
        v126 = 18;
      else
        v126 = v235 - v123;
      v127 = v125 - v126;
      if (v127 >= v127 - 1)
        v128 = v127 - 1;
      else
        v128 = v127;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v24 = v162;
      v21 = v167;
      v18 = v173;
      v15 = v180;
      v12 = v188;
      v9 = v197;
      v6 = v207;
      v3 = v218;
      a1 = v230;
    }
  }
  v27 = v26[486];
  v29 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v28 & 1) == 0)
  {
    v219 = v3;
    v231 = a1;
    v208 = v6;
    v189 = v12;
    v198 = v9;
    v174 = v18;
    v181 = v15;
    v163 = v24;
    v168 = v21;
    v159 = v27;
    v29 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v27 = v159;
    v24 = v163;
    v21 = v168;
    v18 = v174;
    v15 = v181;
    v12 = v189;
    v9 = v198;
    v6 = v208;
    v3 = v219;
    v130 = v129;
    a1 = v231;
    if (v130)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v235 = 99;
      v131 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v131)
        v132 = v131;
      else
        v132 = v235;
      v133 = &v234[v132];
      v134 = v235 - v132;
      if (v235 - v132 >= 0x12)
        v135 = 18;
      else
        v135 = v235 - v132;
      v136 = v134 - v135;
      if (v136 >= v136 - 1)
        v137 = v136 - 1;
      else
        v137 = v136;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      v29 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v27 = v159;
      v24 = v163;
      v21 = v168;
      v18 = v174;
      v15 = v181;
      v12 = v189;
      v9 = v198;
      v6 = v208;
      v3 = v219;
      a1 = v231;
    }
  }
  v30 = v29[504];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v220 = v3;
    v232 = a1;
    v209 = v6;
    v190 = v12;
    v199 = v9;
    v175 = v18;
    v182 = v15;
    v164 = v24;
    v169 = v21;
    v157 = v30;
    v160 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v157;
    v27 = v160;
    v24 = v164;
    v21 = v169;
    v18 = v175;
    v15 = v182;
    v12 = v190;
    v9 = v199;
    v6 = v209;
    v3 = v220;
    v139 = v138;
    a1 = v232;
    if (v139)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v235 = 93;
      v140 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v140)
        v141 = v140;
      else
        v141 = v235;
      v142 = &v234[v141];
      v143 = v235 - v141;
      if (v235 - v141 >= 0x12)
        v144 = 18;
      else
        v144 = v235 - v141;
      v145 = v143 - v144;
      if (v145 >= v145 - 1)
        v146 = v145 - 1;
      else
        v146 = v145;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v157;
      v27 = v160;
      v24 = v164;
      v21 = v169;
      v18 = v175;
      v15 = v182;
      v12 = v190;
      v9 = v199;
      v6 = v209;
      v3 = v220;
      a1 = v232;
    }
  }
  v33 = v32[158];
  v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v34 & 1) == 0)
  {
    v221 = v3;
    v233 = a1;
    v210 = v6;
    v191 = v12;
    v200 = v9;
    v176 = v18;
    v183 = v15;
    v165 = v24;
    v170 = v21;
    v158 = v30;
    v161 = v27;
    v156 = v33;
    v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v33 = v156;
    v30 = v158;
    v27 = v161;
    v24 = v165;
    v21 = v170;
    v18 = v176;
    v15 = v183;
    v12 = v191;
    v9 = v200;
    v6 = v210;
    v3 = v221;
    v148 = v147;
    a1 = v233;
    if (v148)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsTerminator<Empty>]";
      v235 = 84;
      v149 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v149)
        v150 = v149;
      else
        v150 = v235;
      v151 = &v234[v150];
      v152 = v235 - v150;
      if (v235 - v150 >= 0x12)
        v153 = 18;
      else
        v153 = v235 - v150;
      v154 = v152 - v153;
      if (v154 >= v154 - 1)
        v155 = v154 - 1;
      else
        v155 = v154;
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v33 = v156;
      v30 = v158;
      v27 = v161;
      v24 = v165;
      v21 = v170;
      v18 = v176;
      v15 = v183;
      v12 = v191;
      v9 = v200;
      v6 = v210;
      v3 = v221;
      a1 = v233;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == (_QWORD)a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == a1
      || v30 == a1
      || v33 == (_QWORD)a1
      || v35[190] == (_QWORD)a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::cf::CondBranchOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::cf::CondBranchOp>,mlir::OpTrait::ZeroResults<mlir::cf::CondBranchOp>,mlir::OpTrait::NSuccessors<2u>::Impl<mlir::cf::CondBranchOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::cf::CondBranchOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::cf::CondBranchOp>,mlir::OpTrait::OpInvariants<mlir::cf::CondBranchOp>,mlir::BytecodeOpInterface::Trait<mlir::cf::CondBranchOp>,mlir::BranchOpInterface::Trait<mlir::cf::CondBranchOp>,mlir::ConditionallySpeculatable::Trait<mlir::cf::CondBranchOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::cf::CondBranchOp>,mlir::MemoryEffectOpInterface::Trait<mlir::cf::CondBranchOp>,mlir::OpTrait::IsTerminator<mlir::cf::CondBranchOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::cf::CondBranchOp>,mlir::OpTrait::ZeroResults<mlir::cf::CondBranchOp>,mlir::OpTrait::NSuccessors<2u>::Impl<mlir::cf::CondBranchOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::cf::CondBranchOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::cf::CondBranchOp>,mlir::OpTrait::OpInvariants<mlir::cf::CondBranchOp>,mlir::BytecodeOpInterface::Trait<mlir::cf::CondBranchOp>,mlir::BranchOpInterface::Trait<mlir::cf::CondBranchOp>,mlir::ConditionallySpeculatable::Trait<mlir::cf::CondBranchOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::cf::CondBranchOp>,mlir::MemoryEffectOpInterface::Trait<mlir::cf::CondBranchOp>,mlir::OpTrait::IsTerminator<mlir::cf::CondBranchOp>>(uint64_t a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  mlir::Operation *v9;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyZeroResults((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyNSuccessors((mlir::OpTrait::impl *)a1, (mlir::Operation *)2)
    && mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)1)
    && mlir::OpTrait::impl::verifyOperandSizeAttr(a1, "operandSegmentSizes", 0x13uLL))
  {
    v4 = *(unsigned int *)(a1 + 44);
    v5 = *(unsigned int *)(a1 + 16 * ((v4 >> 23) & 1) + 64);
    if ((v4 & 0x800000) != 0)
    {
      v6 = *(_QWORD *)(a1 + 72);
      if ((_DWORD)v5)
        goto LABEL_8;
    }
    else
    {
      v6 = 0;
      if ((_DWORD)v5)
      {
LABEL_8:
        v7 = 0;
        v8 = v6 + 24;
        while (mlir::complex::__mlir_ods_local_type_constraint_ComplexOps3((uint64_t *)a1, *(_QWORD *)(*(_QWORD *)v8 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v7))
        {
          ++v7;
          v8 += 32;
          if (v5 == v7)
            goto LABEL_11;
        }
        return 0;
      }
    }
LABEL_11:
    if (mlir::op_definition_impl::verifyTrait<mlir::BranchOpInterface::Trait<mlir::cf::CondBranchOp>>(a1))
      return mlir::OpTrait::impl::verifyIsTerminator((mlir::OpTrait::impl *)a1, v9) != 0;
  }
  return 0;
}

uint64_t mlir::op_definition_impl::verifyTrait<mlir::BranchOpInterface::Trait<mlir::cf::CondBranchOp>>(uint64_t a1)
{
  int v1;
  unsigned int v3;
  char v4;
  uint64_t v6;
  unsigned int v7[6];
  void *v8;
  _QWORD v9[4];

  v9[3] = *MEMORY[0x1E0C80C00];
  v6 = a1;
  v1 = *(_DWORD *)(a1 + 40);
  if (!v1)
    return 1;
  v3 = 0;
  while (1)
  {
    mlir::cf::CondBranchOp::getSuccessorOperands((mlir::cf::CondBranchOp *)&v6, v3, (uint64_t)v7);
    v4 = mlir::detail::verifyBranchSuccessorOperands(a1, v3, v7);
    if (v8 != v9)
      free(v8);
    if (!v4)
      break;
    if (v1 == ++v3)
      return 1;
  }
  return 0;
}

uint64_t mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::SwitchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"cf.switch", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::cf::SwitchOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E2E000;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::foldHook()
{
  mlir::Operation *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  return mlir::cf::SwitchOp::getCanonicalizationPatterns(a2);
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::getParseAssemblyFn(BOOL (**a1)(void *a1, mlir::OperationState *a2)@<X8>)
{
  *a1 = mlir::cf::SwitchOp::parse;
  a1[3] = (BOOL (*)(void *, mlir::OperationState *))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                              + 2);
}

void mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::printAssembly(uint64_t a1, Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                        + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  mlir::MLIRContext *Context;
  _QWORD *v8;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::cf::SwitchOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  char *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::cf::SwitchOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::MLIRContext *Context;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  if (*v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"case_operand_segments", 21, *v6);
  v7 = v6[1];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"case_values", 11, v7);
  v8 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, (uint64_t)(v6 + 2), 3);
  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  _QWORD *v9;
  uint64_t v10;
  _BOOL8 result;

  v9 = (_QWORD *)mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  result = 0;
  if (!v9
    || mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps2(v9, (const void **)"case_operand_segments", (const char *)0x15, a4, a5))
  {
    v10 = mlir::NamedAttrList::get(a3, *(_QWORD *)(*(_QWORD *)(a2 + 96) + 8));
    if (!v10
      || mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps1(v10, (const void **)"case_values", (const char *)0xB, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::getOpPropertyByteSize()
{
  return 32;
}

double mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::initProperties(uint64_t a1, uint64_t a2, __int128 *a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[1];
    *a3 = *a4;
    a3[1] = v5;
  }
  else
  {
    *(_QWORD *)&v4 = 0;
    *a3 = 0u;
    a3[1] = 0u;
  }
  return *(double *)&v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::cf::SwitchOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::cf::SwitchOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;

  result = *(__n128 *)a3;
  *(_OWORD *)(a2 + 12) = *(_OWORD *)(a3 + 12);
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::compareProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_QWORD *)a3 != *(_QWORD *)a2)
    return 0;
  if (*(_QWORD *)(a3 + 8) != *(_QWORD *)(a2 + 8))
    return 0;
  return *(_QWORD *)(a3 + 16) == *(_QWORD *)(a2 + 16)
      && *(_DWORD *)(a3 + 24) == (unint64_t)*(unsigned int *)(a2 + 24);
}

unint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::cf::SwitchOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::cf::SwitchOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x20uLL);
  *v2 = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::getSuccessorOperands;
  v2[1] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::getSuccessorBlockArgument;
  v2[2] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::getSuccessorForOperands;
  v2[3] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::areTypesCompatible;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface]";
      v15 = 73;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[140], v2);
}

void mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::getSuccessorOperands(mlir::Operation *a1@<X1>, int a2@<W2>, uint64_t a3@<X8>)
{
  mlir::Operation *v3;

  v3 = a1;
  mlir::cf::SwitchOp::getSuccessorOperands(&v3, a2, a3);
}

unint64_t mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::getSuccessorBlockArgument(uint64_t a1, unsigned int *a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t BranchSuccessorArgument;
  char v10;
  char v11;
  unsigned __int8 v12;
  unint64_t v13;
  mlir::Operation *v15;
  _DWORD v16[6];
  void *v17;
  _QWORD v18[4];

  v18[3] = *MEMORY[0x1E0C80C00];
  v3 = a2[10];
  if ((_DWORD)v3)
  {
    v6 = 0;
    v7 = a2 + 16;
    v8 = 24;
    while (1)
    {
      v15 = (mlir::Operation *)a2;
      mlir::cf::SwitchOp::getSuccessorOperands(&v15, v6, (uint64_t)v16);
      BranchSuccessorArgument = mlir::detail::getBranchSuccessorArgument(v16, a3, *(_QWORD *)((((unint64_t)&v7[4 * (((unint64_t)a2[11] >> 23) & 1) + 1]+ (((unint64_t)a2[11] >> 21) & 0x7F8)+ 3) & 0xFFFFFFFFFFFFFFF8)+ v8));
      v11 = v10;
      if (v17 != v18)
        free(v17);
      if (v11)
        break;
      ++v6;
      v8 += 32;
      if (v3 == v6)
      {
        v12 = 0;
        goto LABEL_10;
      }
    }
    v12 = BranchSuccessorArgument;
LABEL_10:
    v13 = BranchSuccessorArgument & 0xFFFFFFFFFFFFFF00;
  }
  else
  {
    v12 = 0;
    v13 = 0;
  }
  return v13 | v12;
}

void **mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::getSuccessorForOperands(uint64_t a1, Operation *a2, uint64_t *a3)
{
  Operation *v4;

  v4 = a2;
  return mlir::cf::SwitchOp::getSuccessorForOperands(&v4, a3);
}

BOOL mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::areTypesCompatible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a3 == a4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::SwitchOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::SwitchOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::SwitchOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  __guard *v8;
  __guard v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  __guard *v14;
  __guard v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **p_vtable;
  void *v21;
  unsigned __int8 v22;
  __guard *v23;
  __guard v24;
  unsigned __int8 v25;
  void **v26;
  void *v27;
  unsigned __int8 v28;
  void **v29;
  void *v30;
  unsigned __int8 v31;
  uint64_t *v32;
  uint64_t v33;
  unsigned __int8 v34;
  uint64_t *v35;
  int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  const char *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  const char *v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  unint64_t v86;
  unint64_t v87;
  const char *v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  const char *v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  unint64_t v104;
  unint64_t v105;
  const char *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unint64_t v113;
  unint64_t v114;
  const char *v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  unint64_t v122;
  unint64_t v123;
  const char *v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  int v129;
  int v130;
  unint64_t v131;
  unint64_t v132;
  const char *v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  unint64_t v140;
  unint64_t v141;
  const char *v142;
  unint64_t v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  int v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  const char *v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  uint64_t v156;
  void *v157;
  void *v158;
  void *v159;
  void *v160;
  void *v161;
  __guard v162;
  __guard v163;
  __guard v164;
  __guard v165;
  void *v166;
  void *v167;
  void *v168;
  void *v169;
  void *v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  __guard v177;
  __guard v178;
  __guard v179;
  __guard v180;
  __guard v181;
  __guard v182;
  __guard v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  __guard v192;
  __guard v193;
  __guard v194;
  __guard v195;
  __guard v196;
  __guard v197;
  __guard v198;
  __guard v199;
  __guard v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  void *v222;
  void *v223;
  void *v224;
  void *v225;
  void *v226;
  void *v227;
  void *v228;
  void *v229;
  void *v230;
  void *v231;
  void *v232;
  void *v233;
  const char *v234;
  unint64_t v235;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v222 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v49 = v48;
    a1 = v222;
    if (v49)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v235 = 83;
      v50 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v50)
        v51 = v50;
      else
        v51 = v235;
      v52 = &v234[v51];
      v53 = v235 - v51;
      if (v235 - v51 >= 0x12)
        v54 = 18;
      else
        v54 = v235 - v51;
      v55 = v53 - v54;
      if (v55 >= v55 - 1)
        v56 = v55 - 1;
      else
        v56 = v55;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v222;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v211 = v3;
    v223 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v58 = v57;
    v3 = v211;
    a1 = v223;
    if (v58)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      v235 = 83;
      v59 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v59)
        v60 = v59;
      else
        v60 = v235;
      v61 = &v234[v60];
      v62 = v235 - v60;
      if (v235 - v60 >= 0x12)
        v63 = 18;
      else
        v63 = v235 - v60;
      v64 = v62 - v63;
      if (v64 >= v64 - 1)
        v65 = v64 - 1;
      else
        v65 = v64;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v211;
      a1 = v223;
    }
  }
  v6 = v5[188];
  if ((v7 & 1) == 0)
  {
    v212 = v3;
    v224 = a1;
    v201 = v6;
    v6 = v201;
    v3 = v212;
    v67 = v66;
    a1 = v224;
    if (v67)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNSuccessors<1>::Impl<Empty>]";
      v235 = 99;
      v68 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v68)
        v69 = v68;
      else
        v69 = v235;
      v70 = &v234[v69];
      v71 = v235 - v69;
      if (v235 - v69 >= 0x12)
        v72 = 18;
      else
        v72 = v235 - v69;
      v73 = v71 - v72;
      if (v73 >= v73 - 1)
        v74 = v73 - 1;
      else
        v74 = v73;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNSuccessors<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNSuccessors<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      v6 = v201;
      v3 = v212;
      a1 = v224;
    }
  }
  v9 = v8[427];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v213 = v3;
    v225 = a1;
    v202 = v6;
    v192 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v192;
    v6 = v202;
    v3 = v213;
    v76 = v75;
    a1 = v225;
    if (v76)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>]";
      v235 = 97;
      v77 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v77)
        v78 = v77;
      else
        v78 = v235;
      v79 = &v234[v78];
      v80 = v235 - v78;
      if (v235 - v78 >= 0x12)
        v81 = 18;
      else
        v81 = v235 - v78;
      v82 = v80 - v81;
      if (v82 >= v82 - 1)
        v83 = v82 - 1;
      else
        v83 = v82;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v192;
      v6 = v202;
      v3 = v213;
      a1 = v225;
    }
  }
  v12 = v11[197];
  if ((v13 & 1) == 0)
  {
    v214 = v3;
    v226 = a1;
    v203 = v6;
    v184 = v12;
    v193 = v9;
    v12 = v184;
    v9 = v193;
    v6 = v203;
    v3 = v214;
    v85 = v84;
    a1 = v226;
    if (v85)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      v235 = 96;
      v86 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v86)
        v87 = v86;
      else
        v87 = v235;
      v88 = &v234[v87];
      v89 = v235 - v87;
      if (v235 - v87 >= 0x12)
        v90 = 18;
      else
        v90 = v235 - v87;
      v91 = v89 - v90;
      if (v91 >= v91 - 1)
        v92 = v91 - 1;
      else
        v92 = v91;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      v12 = v184;
      v9 = v193;
      v6 = v203;
      v3 = v214;
      a1 = v226;
    }
  }
  v15 = v14[423];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v215 = v3;
    v227 = a1;
    v204 = v6;
    v185 = v12;
    v194 = v9;
    v177 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v177;
    v12 = v185;
    v9 = v194;
    v6 = v204;
    v3 = v215;
    v94 = v93;
    a1 = v227;
    if (v94)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v235 = 84;
      v95 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v95)
        v96 = v95;
      else
        v96 = v235;
      v97 = &v234[v96];
      v98 = v235 - v96;
      if (v235 - v96 >= 0x12)
        v99 = 18;
      else
        v99 = v235 - v96;
      v100 = v98 - v99;
      if (v100 >= v100 - 1)
        v101 = v100 - 1;
      else
        v101 = v100;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v177;
      v12 = v185;
      v9 = v194;
      v6 = v204;
      v3 = v215;
      a1 = v227;
    }
  }
  v18 = v17[192];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v216 = v3;
    v228 = a1;
    v205 = v6;
    v186 = v12;
    v195 = v9;
    v171 = v18;
    v178 = v15;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v171;
    v15 = v178;
    v12 = v186;
    v9 = v195;
    v6 = v205;
    v3 = v216;
    v103 = v102;
    a1 = v228;
    if (v103)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v235 = 89;
      v104 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v104)
        v105 = v104;
      else
        v105 = v235;
      v106 = &v234[v105];
      v107 = v235 - v105;
      if (v235 - v105 >= 0x12)
        v108 = 18;
      else
        v108 = v235 - v105;
      v109 = v107 - v108;
      if (v109 >= v109 - 1)
        v110 = v109 - 1;
      else
        v110 = v109;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v171;
      v15 = v178;
      v12 = v186;
      v9 = v195;
      v6 = v205;
      v3 = v216;
      a1 = v228;
    }
  }
  v21 = p_vtable[481];
  if ((v22 & 1) == 0)
  {
    v217 = v3;
    v229 = a1;
    v206 = v6;
    v187 = v12;
    v196 = v9;
    v172 = v18;
    v179 = v15;
    v166 = v21;
    v21 = v166;
    v18 = v172;
    v15 = v179;
    v12 = v187;
    v9 = v196;
    v6 = v206;
    v3 = v217;
    v112 = v111;
    a1 = v229;
    if (v112)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface::Trait<Empty>]";
      v235 = 87;
      v113 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v113)
        v114 = v113;
      else
        v114 = v235;
      v115 = &v234[v114];
      v116 = v235 - v114;
      if (v235 - v114 >= 0x12)
        v117 = 18;
      else
        v117 = v235 - v114;
      v118 = v116 - v117;
      if (v118 >= v118 - 1)
        v119 = v118 - 1;
      else
        v119 = v118;
      mlir::detail::TypeIDResolver<mlir::BranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BranchOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      v21 = v166;
      v18 = v172;
      v15 = v179;
      v12 = v187;
      v9 = v196;
      v6 = v206;
      v3 = v217;
      a1 = v229;
    }
  }
  v24 = v23[419];
  v26 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v25 & 1) == 0)
  {
    v218 = v3;
    v230 = a1;
    v207 = v6;
    v188 = v12;
    v197 = v9;
    v173 = v18;
    v180 = v15;
    v162 = v24;
    v167 = v21;
    v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v24 = v162;
    v21 = v167;
    v18 = v173;
    v15 = v180;
    v12 = v188;
    v9 = v197;
    v6 = v207;
    v3 = v218;
    v121 = v120;
    a1 = v230;
    if (v121)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v235 = 95;
      v122 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v122)
        v123 = v122;
      else
        v123 = v235;
      v124 = &v234[v123];
      v125 = v235 - v123;
      if (v235 - v123 >= 0x12)
        v126 = 18;
      else
        v126 = v235 - v123;
      v127 = v125 - v126;
      if (v127 >= v127 - 1)
        v128 = v127 - 1;
      else
        v128 = v127;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v24 = v162;
      v21 = v167;
      v18 = v173;
      v15 = v180;
      v12 = v188;
      v9 = v197;
      v6 = v207;
      v3 = v218;
      a1 = v230;
    }
  }
  v27 = v26[486];
  v29 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v28 & 1) == 0)
  {
    v219 = v3;
    v231 = a1;
    v208 = v6;
    v189 = v12;
    v198 = v9;
    v174 = v18;
    v181 = v15;
    v163 = v24;
    v168 = v21;
    v159 = v27;
    v29 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v27 = v159;
    v24 = v163;
    v21 = v168;
    v18 = v174;
    v15 = v181;
    v12 = v189;
    v9 = v198;
    v6 = v208;
    v3 = v219;
    v130 = v129;
    a1 = v231;
    if (v130)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v235 = 99;
      v131 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v131)
        v132 = v131;
      else
        v132 = v235;
      v133 = &v234[v132];
      v134 = v235 - v132;
      if (v235 - v132 >= 0x12)
        v135 = 18;
      else
        v135 = v235 - v132;
      v136 = v134 - v135;
      if (v136 >= v136 - 1)
        v137 = v136 - 1;
      else
        v137 = v136;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      v29 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v27 = v159;
      v24 = v163;
      v21 = v168;
      v18 = v174;
      v15 = v181;
      v12 = v189;
      v9 = v198;
      v6 = v208;
      v3 = v219;
      a1 = v231;
    }
  }
  v30 = v29[504];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v220 = v3;
    v232 = a1;
    v209 = v6;
    v190 = v12;
    v199 = v9;
    v175 = v18;
    v182 = v15;
    v164 = v24;
    v169 = v21;
    v157 = v30;
    v160 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v157;
    v27 = v160;
    v24 = v164;
    v21 = v169;
    v18 = v175;
    v15 = v182;
    v12 = v190;
    v9 = v199;
    v6 = v209;
    v3 = v220;
    v139 = v138;
    a1 = v232;
    if (v139)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v235 = 93;
      v140 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v140)
        v141 = v140;
      else
        v141 = v235;
      v142 = &v234[v141];
      v143 = v235 - v141;
      if (v235 - v141 >= 0x12)
        v144 = 18;
      else
        v144 = v235 - v141;
      v145 = v143 - v144;
      if (v145 >= v145 - 1)
        v146 = v145 - 1;
      else
        v146 = v145;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v157;
      v27 = v160;
      v24 = v164;
      v21 = v169;
      v18 = v175;
      v15 = v182;
      v12 = v190;
      v9 = v199;
      v6 = v209;
      v3 = v220;
      a1 = v232;
    }
  }
  v33 = v32[158];
  v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v34 & 1) == 0)
  {
    v221 = v3;
    v233 = a1;
    v210 = v6;
    v191 = v12;
    v200 = v9;
    v176 = v18;
    v183 = v15;
    v165 = v24;
    v170 = v21;
    v158 = v30;
    v161 = v27;
    v156 = v33;
    v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v33 = v156;
    v30 = v158;
    v27 = v161;
    v24 = v165;
    v21 = v170;
    v18 = v176;
    v15 = v183;
    v12 = v191;
    v9 = v200;
    v6 = v210;
    v3 = v221;
    v148 = v147;
    a1 = v233;
    if (v148)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsTerminator<Empty>]";
      v235 = 84;
      v149 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v149)
        v150 = v149;
      else
        v150 = v235;
      v151 = &v234[v150];
      v152 = v235 - v150;
      if (v235 - v150 >= 0x12)
        v153 = 18;
      else
        v153 = v235 - v150;
      v154 = v152 - v153;
      if (v154 >= v154 - 1)
        v155 = v154 - 1;
      else
        v155 = v154;
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v33 = v156;
      v30 = v158;
      v27 = v161;
      v24 = v165;
      v21 = v170;
      v18 = v176;
      v15 = v183;
      v12 = v191;
      v9 = v200;
      v6 = v210;
      v3 = v221;
      a1 = v233;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == (_QWORD)a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == a1
      || v30 == a1
      || v33 == (_QWORD)a1
      || v35[190] == (_QWORD)a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::cf::SwitchOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  Operation *v4;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::cf::SwitchOp>,mlir::OpTrait::ZeroResults<mlir::cf::SwitchOp>,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl<mlir::cf::SwitchOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::cf::SwitchOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::cf::SwitchOp>,mlir::OpTrait::OpInvariants<mlir::cf::SwitchOp>,mlir::BytecodeOpInterface::Trait<mlir::cf::SwitchOp>,mlir::BranchOpInterface::Trait<mlir::cf::SwitchOp>,mlir::ConditionallySpeculatable::Trait<mlir::cf::SwitchOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::cf::SwitchOp>,mlir::MemoryEffectOpInterface::Trait<mlir::cf::SwitchOp>,mlir::OpTrait::IsTerminator<mlir::cf::SwitchOp>>(a1, a2))return 0;
  v4 = a1;
  return mlir::cf::SwitchOp::verify(&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::cf::SwitchOp>,mlir::OpTrait::ZeroResults<mlir::cf::SwitchOp>,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl<mlir::cf::SwitchOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::cf::SwitchOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::cf::SwitchOp>,mlir::OpTrait::OpInvariants<mlir::cf::SwitchOp>,mlir::BytecodeOpInterface::Trait<mlir::cf::SwitchOp>,mlir::BranchOpInterface::Trait<mlir::cf::SwitchOp>,mlir::ConditionallySpeculatable::Trait<mlir::cf::SwitchOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::cf::SwitchOp>,mlir::MemoryEffectOpInterface::Trait<mlir::cf::SwitchOp>,mlir::OpTrait::IsTerminator<mlir::cf::SwitchOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyZeroResults(a1, v3)
    && mlir::OpTrait::impl::verifyAtLeastNSuccessors(a1, (mlir::Operation *)1)
    && mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)1)
    && mlir::OpTrait::impl::verifyOperandSizeAttr((uint64_t)a1, "operandSegmentSizes", 0x13uLL)
    && (v6 = a1, mlir::cf::SwitchOp::verifyInvariantsImpl((uint64_t **)&v6))
    && mlir::op_definition_impl::verifyTrait<mlir::BranchOpInterface::Trait<mlir::cf::SwitchOp>>(a1))
  {
    return mlir::OpTrait::impl::verifyIsTerminator(a1, v4) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::op_definition_impl::verifyTrait<mlir::BranchOpInterface::Trait<mlir::cf::SwitchOp>>(mlir::Operation *a1)
{
  int v1;
  unsigned int v3;
  char v4;
  mlir::Operation *v6;
  unsigned int v7[6];
  void *v8;
  _QWORD v9[4];

  v9[3] = *MEMORY[0x1E0C80C00];
  v6 = a1;
  v1 = *((_DWORD *)a1 + 10);
  if (!v1)
    return 1;
  v3 = 0;
  while (1)
  {
    mlir::cf::SwitchOp::getSuccessorOperands(&v6, v3, (uint64_t)v7);
    v4 = mlir::detail::verifyBranchSuccessorOperands((uint64_t)a1, v3, v7);
    if (v8 != v9)
      free(v8);
    if (!v4)
      break;
    if (v1 == ++v3)
      return 1;
  }
  return 0;
}

uint64_t mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyRegionInvariants()
{
  return 1;
}

void `anonymous namespace'::ControlFlowInlinerInterface::~ControlFlowInlinerInterface(_anonymous_namespace_::ControlFlowInlinerInterface *this)
{
  void *v1;

  mlir::GenericProgramPoint::~GenericProgramPoint(this);
  operator delete(v1);
}

uint64_t `anonymous namespace'::ControlFlowInlinerInterface::isLegalToInline(_anonymous_namespace_::ControlFlowInlinerInterface *this, Operation *a2, Operation *a3)
{
  return 1;
}

uint64_t `anonymous namespace'::ControlFlowInlinerInterface::isLegalToInline()
{
  return 1;
}

void `anonymous namespace'::SimplifyConstCondBranchPred::~SimplifyConstCondBranchPred(_anonymous_namespace_::SimplifyConstCondBranchPred *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::CondBranchOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::CondBranchOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::CondBranchOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t `anonymous namespace'::SimplifyConstCondBranchPred::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  mlir::Operation *DefiningOp;
  unint64_t v7;
  unsigned int *v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  unint64_t v16;
  int *v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  mlir::GenericProgramPoint *v22;
  _QWORD v23[2];
  BOOL (*v24)(llvm::APInt *);

  v5 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  v24 = mlir::m_NonZero(void)::{lambda(llvm::APInt const&)#1}::__invoke;
  v23[0] = v5;
  DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)v23);
  if (DefiningOp
    && mlir::detail::constant_int_predicate_matcher::match((uint64_t (**)(void **))&v24, DefiningOp))
  {
    v7 = *(unsigned int *)(a2 + 44);
    v24 = *(BOOL (**)(llvm::APInt *))(((a2 + 16 * ((v7 >> 23) & 1) + 64 + ((v7 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                                               + 24);
    if (BYTE3(v7))
      v8 = (unsigned int *)(a2 + 16 * ((v7 >> 23) & 1) + 64);
    else
      v8 = 0;
    v9 = *v8;
    v10 = v8[1];
    if ((v7 & 0x800000) != 0)
      v11 = *(_QWORD *)(a2 + 72);
    else
      v11 = 0;
    v12 = v10 + v9;
    v13 = v11 + 32 * v9;
LABEL_17:
    v23[0] = v13;
    v23[1] = v12 - v9;
    v22 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v24, (uint64_t)v23);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, a2, v22);
    return 1;
  }
  v14 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  v24 = mlir::m_Zero(void)::{lambda(llvm::APInt const&)#1}::__invoke;
  v23[0] = v14;
  result = mlir::Value::getDefiningOp((mlir::Value *)v23);
  if (result)
  {
    result = mlir::detail::constant_int_predicate_matcher::match((uint64_t (**)(void **))&v24, (mlir::Operation *)result);
    if ((_DWORD)result)
    {
      v16 = *(unsigned int *)(a2 + 44);
      v24 = *(BOOL (**)(llvm::APInt *))(((a2 + 16 * ((v16 >> 23) & 1) + 64 + ((v16 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                                                 + 56);
      if (BYTE3(v16))
        v17 = (int *)(a2 + 16 * ((v16 >> 23) & 1) + 64);
      else
        v17 = 0;
      v18 = *v17;
      v19 = v17[1];
      v20 = v17[2];
      if ((v16 & 0x800000) != 0)
        v21 = *(_QWORD *)(a2 + 72);
      else
        v21 = 0;
      v9 = (v19 + v18);
      v12 = (v20 + v9);
      v13 = v21 + 32 * v9;
      goto LABEL_17;
    }
  }
  return result;
}

void `anonymous namespace'::SimplifyPassThroughCondBranch::~SimplifyPassThroughCondBranch(_anonymous_namespace_::SimplifyPassThroughCondBranch *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t `anonymous namespace'::SimplifyPassThroughCondBranch::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  int *v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t v20;
  void *v21;
  mlir::GenericProgramPoint *v22;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27[2];
  _BYTE v28[32];
  void *v29[2];
  _BYTE v30[32];
  uint64_t v31[2];
  uint64_t v32[3];

  v32[2] = *MEMORY[0x1E0C80C00];
  v5 = a2 + 64;
  v6 = *(unsigned int *)(a2 + 44);
  v7 = (a2 + 64 + 16 * ((v6 >> 23) & 1) + ((v6 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8;
  v8 = *(_QWORD *)(v7 + 24);
  v25 = *(_QWORD *)(v7 + 56);
  v26 = v8;
  if (BYTE3(v6))
    v9 = (unsigned int *)(a2 + 64 + 16 * ((v6 >> 23) & 1));
  else
    v9 = 0;
  v10 = *v9;
  v11 = v9[1];
  if ((v6 & 0x800000) != 0)
    v12 = *(_QWORD *)(a2 + 72);
  else
    v12 = 0;
  mlir::ValueRange::ValueRange((unint64_t *)v32, v12 + 32 * v10, v11 + v10 - v10);
  v13 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v14 = (int *)(v5 + 16 * ((v13 >> 23) & 1));
  else
    v14 = 0;
  v15 = *v14;
  v16 = v14[1];
  v17 = v14[2];
  if ((v13 & 0x800000) != 0)
    v18 = *(_QWORD *)(a2 + 72);
  else
    v18 = 0;
  mlir::ValueRange::ValueRange((unint64_t *)v31, v18 + 32 * (v16 + v15), (v17 + v16 + v15) - (unint64_t)(v16 + v15));
  v29[0] = v30;
  v29[1] = (void *)0x400000000;
  v27[0] = v28;
  v27[1] = (void *)0x400000000;
  v19 = collapseBranch(&v26, v32, (uint64_t)v29);
  if (v19 | collapseBranch(&v25, v31, (uint64_t)v27))
  {
    v24 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
    v22 = mlir::OpBuilder::create<mlir::cf::CondBranchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *&,mlir::ValueRange &,mlir::Block *&,mlir::ValueRange &>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), &v24, &v26, v32, &v25, v31);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, a2, v22);
    v20 = 1;
    v21 = v27[0];
    if (v27[0] == v28)
      goto LABEL_16;
    goto LABEL_15;
  }
  v20 = 0;
  v21 = v27[0];
  if (v27[0] != v28)
LABEL_15:
    free(v21);
LABEL_16:
  if (v29[0] != v30)
    free(v29[0]);
  return v20;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::cf::CondBranchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *&,mlir::ValueRange &,mlir::Block *&,mlir::ValueRange &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t *Context;
  uint64_t v15;
  char v16;
  uint64_t v17;
  mlir::GenericProgramPoint *v18;
  mlir::GenericProgramPoint *v19;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  uint64_t v24[4];
  __int16 v25;
  _QWORD v26[39];

  v26[38] = *MEMORY[0x1E0C80C00];
  v21 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"cf.cond_br", (const unsigned __int8 *)0xA, Context);
  if (!v16)
  {
    v25 = 1283;
    v24[2] = (uint64_t)"cf.cond_br";
    v24[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v23 = 259;
    llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v15);
  mlir::cf::CondBranchOp::build(v17, (uint64_t)v26, *a3, *a5, a5[1], *a7, a7[1], *a4, *a6);
  v18 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v26);
  if (*(_UNKNOWN **)(*((_QWORD *)v18 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::cf::CondBranchOp,void>::id)
    v19 = v18;
  else
    v19 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v19;
}

void `anonymous namespace'::SimplifyCondBranchIdenticalSuccessors::~SimplifyCondBranchIdenticalSuccessors(_anonymous_namespace_::SimplifyCondBranchIdenticalSuccessors *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t `anonymous namespace'::SimplifyCondBranchIdenticalSuccessors::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unsigned int *v4;
  unint64_t v5;
  mlir::Block *v6;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  mlir::GenericProgramPoint *v21;
  char **v22;
  uint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  char v30;
  mlir::GenericProgramPoint *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD v35[2];
  mlir::Block *v36;
  void *v37;
  uint64_t v38;
  _QWORD v39[9];

  v39[8] = *MEMORY[0x1E0C80C00];
  v3 = *(unsigned int *)(a2 + 44);
  v4 = (unsigned int *)(a2 + 16 * ((v3 >> 23) & 1) + 64);
  v5 = ((unint64_t)v4 + ((v3 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8;
  v6 = *(mlir::Block **)(v5 + 24);
  v36 = v6;
  if (v6 != *(mlir::Block **)(v5 + 56))
    return 0;
  if (!BYTE3(v3))
    v4 = 0;
  v10 = *v4;
  v11 = v4[1];
  if ((v3 & 0x800000) != 0)
  {
    v12 = *(_QWORD *)(a2 + 72);
    v13 = v11 + v10;
    v14 = v12 + 32 * v10;
  }
  else
  {
    v12 = 0;
    v13 = v11 + v10;
    v14 = 32 * v10;
  }
  v15 = v13 - v10;
  v35[0] = v14;
  v35[1] = v13 - v10;
  v16 = v4[2];
  v17 = v16 + v13;
  if (v13 - v10 == v17 - v13)
  {
    if (!v11)
    {
LABEL_12:
      v21 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v36, (uint64_t)v35);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, a2, v21);
      return 1;
    }
    v18 = (_QWORD *)(v12 + 32 * v13 + 24);
    v19 = (_QWORD *)(v14 + 24);
    v20 = v13 - v10;
    while (*v19 == *v18)
    {
      v18 += 4;
      v19 += 4;
      if (!--v20)
        goto LABEL_12;
    }
  }
  if (mlir::Block::getUniquePredecessor(v6) != *(_QWORD *)(a2 + 16))
    return 0;
  v37 = v39;
  v38 = 0x800000000;
  if (v15 >= 9)
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v15, 8);
  v34 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  if (v11 && v16)
  {
    v22 = (char **)(v14 + 24);
    v23 = (uint64_t *)(v12 + 32 * v13 + 24);
    v24 = v15 - 1;
    v25 = ~v13 + v17;
    do
    {
      v26 = *v22;
      v27 = *v23;
      v32 = v26;
      v33 = v27;
      if (v26 != (char *)v27)
        v26 = (char *)mlir::OpBuilder::create<mlir::arith::SelectOp,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), &v34, (uint64_t *)&v32, &v33)- 16;
      v28 = v38;
      if (v38 >= (unint64_t)HIDWORD(v38))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 8);
        v28 = v38;
      }
      *((_QWORD *)v37 + v28) = v26;
      LODWORD(v38) = v38 + 1;
      v29 = v25-- != 0;
      v30 = v29;
      v29 = v24-- != 0;
      if (!v29)
        break;
      v22 += 4;
      v23 += 4;
    }
    while ((v30 & 1) != 0);
  }
  v31 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *&,llvm::SmallVector<mlir::Value,8u> &>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v36, (uint64_t)&v37);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, a2, v31);
  if (v37 != v39)
    free(v37);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *&,llvm::SmallVector<mlir::Value,8u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  unint64_t v23[2];
  _QWORD v24[25];
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  _QWORD v28[12];

  v28[11] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"cf.br", (const unsigned __int8 *)5, Context);
  if (!v10)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"cf.br";
    v21[3] = 5;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v24);
    llvm::report_fatal_error((llvm::Twine *)v24, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  v11 = *a3;
  mlir::ValueRange::ValueRange(v23, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  v12 = v23[0];
  v13 = v23[1];
  v14 = v26;
  if (v26 >= v27)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v26 + 1, 8);
    v14 = v26;
  }
  *(_QWORD *)(v25 + 8 * v14) = v11;
  ++v26;
  mlir::OperationState::addOperands((uint64_t)v24, v12, v13);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::cf::BranchOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v16;
}

void `anonymous namespace'::SimplifyCondBranchFromCondBranchOnSameCondition::~SimplifyCondBranchFromCondBranchOnSameCondition(_anonymous_namespace_::SimplifyCondBranchFromCondBranchOnSameCondition *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t `anonymous namespace'::SimplifyCondBranchFromCondBranchOnSameCondition::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Block *v5;
  uint64_t result;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int *v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  mlir::GenericProgramPoint *v16;
  _QWORD v17[2];
  uint64_t v18;

  v5 = *(mlir::Block **)(a2 + 16);
  result = mlir::Block::getSinglePredecessor(v5);
  if (result)
  {
    mlir::Block::getTerminator((mlir::GenericProgramPoint **)result);
    if (v7)
      v8 = *(_QWORD *)(*(_QWORD *)(v7 + 48) + 16) == (_QWORD)&mlir::detail::TypeIDResolver<mlir::cf::CondBranchOp,void>::id;
    else
      v8 = 0;
    if (v8)
    {
      v9 = *(_QWORD *)(a2 + 72);
      if (*(_QWORD *)(v9 + 24) == *(_QWORD *)(*(_QWORD *)(v7 + 72) + 24))
      {
        v10 = (a2 + 80 + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8;
        if (HIBYTE(*(_DWORD *)(a2 + 44)))
          v11 = (unsigned int *)(a2 + 80);
        else
          v11 = 0;
        if (v5 == *(mlir::Block **)(((v7 + (((unint64_t)*(unsigned int *)(v7 + 44) >> 21) & 0x7F8) + 87) & 0xFFFFFFFFFFFFFFF8)
                                   + 24))
        {
          v18 = *(_QWORD *)(v10 + 24);
          v15 = *v11;
          v14 = v11[1];
        }
        else
        {
          v18 = *(_QWORD *)(v10 + 56);
          v12 = *v11;
          v13 = v11[1];
          v14 = v11[2];
          v15 = v13 + v12;
        }
        v17[0] = v9 + 32 * v15;
        v17[1] = v14 + v15 - v15;
        v16 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), &v18, (uint64_t)v17);
        (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, a2, v16);
        return 1;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void `anonymous namespace'::CondBranchTruthPropagation::~CondBranchTruthPropagation(_anonymous_namespace_::CondBranchTruthPropagation *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t `anonymous namespace'::CondBranchTruthPropagation::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::BoolAttr **a3)
{
  mlir::BoolAttr **v5;
  uint64_t v6;
  uint64_t SinglePredecessor;
  unsigned int v8;
  uint64_t *v9;
  char v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  _QWORD *BoolAttr;
  uint64_t I1Type;

  v5 = a3 + 1;
  I1Type = mlir::Builder::getI1Type((mlir::Builder *)(a3 + 1));
  v6 = a2 + 64;
  SinglePredecessor = mlir::Block::getSinglePredecessor(*(mlir::Block **)(((a2
                                                                          + 64
                                                                          + 16
                                                                          * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                                                                          + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                                                                          + 7) & 0xFFFFFFFFFFFFFFF8)
                                                                        + 24));
  v8 = *(_DWORD *)(a2 + 44);
  if (SinglePredecessor)
  {
    v9 = **(uint64_t ***)(*(_QWORD *)(a2 + 72) + 24);
    if (v9)
    {
      v10 = 0;
      v11 = 0;
      do
      {
        v12 = (uint64_t *)*v9;
        v13 = v9[2];
        if (*(_QWORD *)(v13 + 16) == *(_QWORD *)(((v6
                                                  + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                                                  + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                                                  + 7) & 0xFFFFFFFFFFFFFFF8)
                                                + 24))
        {
          if (!v11)
          {
            v14 = *(_QWORD *)(a2 + 24);
            BoolAttr = (_QWORD *)mlir::Builder::getBoolAttr(v5, (mlir::MLIRContext *)1);
            v11 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::Type &,mlir::BoolAttr>((mlir::OpBuilder *)v5, v14, &I1Type, &BoolAttr)- 16);
            v13 = v9[2];
          }
          (*((void (**)(mlir::BoolAttr **, uint64_t))*a3 + 9))(a3, v13);
          v15 = (uint64_t *)v9[1];
          if (v15)
          {
            *v15 = *v9;
            if (*v9)
              *(_QWORD *)(*v9 + 8) = v9[1];
          }
          v9[3] = (uint64_t)v11;
          v9[1] = (uint64_t)v11;
          v16 = *v11;
          *v9 = *v11;
          if (v16)
            *(_QWORD *)(v16 + 8) = v9;
          *v11 = (uint64_t)v9;
          (*((void (**)(mlir::BoolAttr **, uint64_t))*a3 + 10))(a3, v13);
          v10 = 1;
        }
        v9 = v12;
      }
      while (v12);
      v8 = *(_DWORD *)(a2 + 44);
    }
    else
    {
      v10 = 0;
    }
    v17 = v10;
  }
  else
  {
    v17 = 0;
  }
  if (mlir::Block::getSinglePredecessor(*(mlir::Block **)(((v6 + 16 * ((v8 >> 23) & 1) + ((v8 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                                                         + 56)))
  {
    v18 = **(uint64_t ***)(*(_QWORD *)(a2 + 72) + 24);
    if (v18)
    {
      v19 = 0;
      do
      {
        v20 = (uint64_t *)*v18;
        v21 = v18[2];
        if (*(_QWORD *)(v21 + 16) == *(_QWORD *)(((v6
                                                  + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                                                  + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                                                  + 7) & 0xFFFFFFFFFFFFFFF8)
                                                + 56))
        {
          if (!v19)
          {
            v22 = *(_QWORD *)(a2 + 24);
            BoolAttr = (_QWORD *)mlir::Builder::getBoolAttr(v5, 0);
            v19 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::Type &,mlir::BoolAttr>((mlir::OpBuilder *)v5, v22, &I1Type, &BoolAttr)- 16);
            v21 = v18[2];
          }
          (*((void (**)(mlir::BoolAttr **, uint64_t))*a3 + 9))(a3, v21);
          v23 = (uint64_t *)v18[1];
          if (v23)
          {
            *v23 = *v18;
            if (*v18)
              *(_QWORD *)(*v18 + 8) = v18[1];
          }
          v18[3] = (uint64_t)v19;
          v18[1] = (uint64_t)v19;
          v24 = *v19;
          *v18 = *v19;
          if (v24)
            *(_QWORD *)(v24 + 8) = v18;
          *v19 = (uint64_t)v18;
          (*((void (**)(mlir::BoolAttr **, uint64_t))*a3 + 10))(a3, v21);
          v17 = 1;
        }
        v18 = v20;
      }
      while (v20);
    }
  }
  return v17 & 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::Type &,mlir::BoolAttr>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, _QWORD **a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  mlir::GenericProgramPoint *v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  uint64_t v20[4];
  __int16 v21;
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v17 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"arith.constant", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    v21 = 1283;
    v20[2] = (uint64_t)"arith.constant";
    v20[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v19 = 259;
    llvm::operator+(v20, (uint64_t *)&v18, (uint64_t)v22);
    llvm::report_fatal_error((llvm::Twine *)v22, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v9);
  v11 = *a3;
  v12 = *a4;
  if (v12)
    v13 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*v12 + 8);
  else
    v13 = 0;
  mlir::arith::ConstantOp::build((uint64_t)a1, (uint64_t)v22, v11, (uint64_t)v12, v13);
  v14 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (*(_UNKNOWN **)(*((_QWORD *)v14 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::ConstantOp,void>::id)
    v15 = v14;
  else
    v15 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v15;
}

_QWORD *mlir::RewritePatternSet::add<mlir::cf::SwitchOp>(mlir::LogicalResult (*)(mlir::cf::SwitchOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::RewritePatternSet::add<mlir::cf::SwitchOp>(mlir::LogicalResult (*)(mlir::cf::SwitchOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::SwitchOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::SwitchOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::SwitchOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::RewritePatternSet::add<mlir::cf::SwitchOp>(mlir::LogicalResult (*)(mlir::cf::SwitchOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

_QWORD *mlir::RewritePatternSet::add<mlir::cf::AssertOp>(mlir::LogicalResult (*)(mlir::cf::AssertOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::RewritePatternSet::add<mlir::cf::AssertOp>(mlir::LogicalResult (*)(mlir::cf::AssertOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::AssertOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::AssertOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::AssertOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::RewritePatternSet::add<mlir::cf::AssertOp>(mlir::LogicalResult (*)(mlir::cf::AssertOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

uint64_t mlir::AsmParser::parseAttribute<mlir::StringAttr>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  const char *v18;
  __int16 v19;
  uint64_t v20;
  _QWORD v21[3];
  void *v22;
  uint64_t v23;
  void *v24;
  _QWORD *v25;
  void *__p;
  _QWORD **v27;
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v20 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *, uint64_t))(*(_QWORD *)a1 + 408))(a1, &v20, a3))
    return 0;
  v7 = v20;
  if (*(_UNKNOWN **)(*(_QWORD *)v20 + 136) != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    v7 = 0;
  *a2 = v7;
  if (v7)
    return 1;
  v18 = "invalid kind of attribute specified";
  v19 = 259;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v21, a1, v6, &v18);
  v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v21);
  if (v21[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v21);
  if (v28)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v27;
      v12 = __p;
      if (v27 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v27 = v10;
      operator delete(v12);
    }
    v13 = v24;
    if (v24)
    {
      v14 = v25;
      v15 = v24;
      if (v25 != v24)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v24;
      }
      v25 = v13;
      operator delete(v15);
    }
    if (v22 != &v23)
      free(v22);
  }
  return v8;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::AssertOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = (_QWORD **)__p[0];
    if (__p[0])
    {
      v24 = (_QWORD **)__p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

_QWORD *mlir::RewritePatternSet::add<mlir::cf::BranchOp>(mlir::LogicalResult (*)(mlir::cf::BranchOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::RewritePatternSet::add<mlir::cf::BranchOp>(mlir::LogicalResult (*)(mlir::cf::BranchOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::BranchOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::BranchOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::BranchOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::RewritePatternSet::add<mlir::cf::BranchOp>(mlir::LogicalResult (*)(mlir::cf::BranchOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;

  v3 = *a3;
  *(_DWORD *)(a2 + 8) = *((_DWORD *)a3 + 2);
  *(_QWORD *)a2 = v3;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;

  result = *(__n128 *)a3;
  *(_OWORD *)(a2 + 12) = *(_OWORD *)(a3 + 12);
  *(__n128 *)a2 = result;
  return result;
}

uint64_t mlir::AsmParser::parseType<mlir::IntegerType>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD **v8;
  _QWORD **v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  void *v14;
  void *v15;
  const char *v16;
  __int16 v17;
  uint64_t v18;
  _QWORD v19[3];
  void *v20;
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  void *__p;
  _QWORD **v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v18 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 504))(a1, &v18))
    return 0;
  v5 = v18;
  if (*(_UNKNOWN **)(*(_QWORD *)v18 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
    v5 = 0;
  *a2 = v5;
  if (v5)
    return 1;
  v16 = "invalid kind of type specified";
  v17 = 259;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v19, a1, v4, &v16);
  v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
  if (v19[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
  if (v26)
  {
    v8 = (_QWORD **)__p;
    if (__p)
    {
      v9 = v25;
      v10 = __p;
      if (v25 != __p)
      {
        do
          v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
        while (v9 != v8);
        v10 = __p;
      }
      v25 = v8;
      operator delete(v10);
    }
    v11 = v22;
    if (v22)
    {
      v12 = v23;
      v13 = v22;
      if (v23 != v22)
      {
        do
        {
          v15 = (void *)*--v12;
          v14 = v15;
          *v12 = 0;
          if (v15)
            operator delete[](v14);
        }
        while (v12 != v11);
        v13 = v22;
      }
      v23 = v11;
      operator delete(v13);
    }
    if (v20 != &v21)
      free(v20);
  }
  return v6;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::SwitchOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = (_QWORD **)__p[0];
    if (__p[0])
    {
      v24 = (_QWORD **)__p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

uint64_t mlir::BranchOpInterface::getSuccessorOperands(mlir::BranchOpInterface *this, uint64_t a2)
{
  return (**((uint64_t (***)(_QWORD, _QWORD, uint64_t))this + 1))(*((_QWORD *)this + 1), *(_QWORD *)this, a2);
}

uint64_t mlir::BranchOpInterface::getSuccessorBlockArgument(mlir::BranchOpInterface *this, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*((_QWORD *)this + 1) + 8))(*((_QWORD *)this + 1), *(_QWORD *)this, a2);
}

uint64_t mlir::BranchOpInterface::getSuccessorForOperands(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t))(a1[1] + 16))(a1[1], *a1, a2, a3);
}

uint64_t mlir::RegionBranchOpInterface::getEntrySuccessorRegions(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(a1[1] + 8))(a1[1], *a1, a2, a3, a4);
}

uint64_t mlir::SuccessorOperands::SuccessorOperands(uint64_t a1, uint64_t *a2)
{
  __int128 v3;
  uint64_t v4;

  *(_DWORD *)a1 = 0;
  v3 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 24) = a1 + 40;
  v4 = a1 + 24;
  *(_OWORD *)(v4 - 16) = v3;
  *(_QWORD *)(v4 + 8) = 0x100000000;
  if (*((_DWORD *)a2 + 6))
    llvm::SmallVectorImpl<std::pair<unsigned int,mlir::NamedAttribute>>::operator=(v4, a2 + 2);
  return a1;
}

uint64_t mlir::detail::getBranchSuccessorArgument(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6;
  unsigned int BeginOperandIndex;
  uint64_t v9;
  uint64_t v10;

  v9 = mlir::MutableOperandRange::operator mlir::OperandRange(a1 + 2);
  v10 = v6;
  if (v6
    && (BeginOperandIndex = mlir::OperandRange::getBeginOperandIndex((mlir::OperandRange *)&v9), a2 >= BeginOperandIndex)
    && v10 + (unint64_t)BeginOperandIndex > a2)
  {
    return *(_QWORD *)(*(_QWORD *)(a3 + 48) + 8 * (a2 - BeginOperandIndex + *a1));
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::detail::verifyBranchSuccessorOperands(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  unsigned int v4;
  unsigned int v5;
  const char *v6;
  uint64_t v7;
  _DWORD *v9;
  uint64_t InterfaceFor;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  char *v24;
  char *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  char *v34;
  char *v35;
  __int128 v36;
  unint64_t v37;
  int *v38;
  char *v39;
  char *v40;
  __int128 v41;
  _QWORD **v42;
  _QWORD **v43;
  void *v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  void *v48;
  void *v49;
  int *v50;
  char *v51;
  char *v52;
  __int128 v53;
  uint64_t v54;
  int *v55;
  char *v56;
  char *v57;
  __int128 v58;
  uint64_t v59;
  int *v60;
  char *v61;
  char *v62;
  __int128 v63;
  uint64_t v64;
  int *v65;
  char *v66;
  char *v67;
  __int128 v68;
  _QWORD **v69;
  _QWORD **v70;
  void *v71;
  _QWORD *v72;
  void *v73;
  void *v74;
  unint64_t v76;
  unint64_t v77;
  BOOL v78;
  unint64_t v79;
  BOOL v80;
  unint64_t v81;
  unint64_t v82;
  BOOL v83;
  unint64_t v84;
  BOOL v85;
  unint64_t v86;
  BOOL v87;
  unint64_t v88;
  BOOL v89;
  unint64_t v90;
  unint64_t v91;
  BOOL v92;
  int64_t v93;
  int64_t v94;
  int64_t v95;
  int64_t v96;
  int64_t v97;
  int64_t v98;
  int64_t v99;
  int64_t v100;
  int64_t v101;
  int64_t v102;
  _BYTE v103[32];
  __int16 v104;
  int v105;
  const char *v106;
  uint64_t v107;
  _QWORD v108[3];
  void *v109;
  unsigned int v110;
  unsigned int v111;
  _BYTE v112[96];
  void *v113;
  _QWORD *v114;
  void *__p;
  _QWORD **v116;
  char v117;
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  v4 = *a3;
  v5 = a3[5];
  v6 = (const char *)a2;
  v7 = *(_QWORD *)(((a1
                   + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a1 + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * a2
                 + 24);
  if (v5 + *a3 == ((*(_QWORD *)(v7 + 56) - *(_QWORD *)(v7 + 48)) >> 3))
  {
    if (!v5)
      return 1;
    v9 = a3 + 2;
    while (1)
    {
      InterfaceFor = mlir::OpInterface<mlir::BranchOpInterface,mlir::detail::BranchOpInterfaceInterfaceTraits>::getInterfaceFor(a1);
      v11 = mlir::MutableOperandRange::operator[](v9, v4 - *a3);
      if (((*(uint64_t (**)(uint64_t, uint64_t, unint64_t, unint64_t))(InterfaceFor + 24))(InterfaceFor, a1, *(_QWORD *)(*(_QWORD *)(v11 + 24) + 8) & 0xFFFFFFFFFFFFFFF8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 48) + 8 * v4) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) == 0)break;
      ++v4;
      if (!--v5)
        return 1;
    }
    v104 = 257;
    mlir::Operation::emitError((uint64_t *)a1, (uint64_t)v103, (uint64_t)v108);
    if (v108[0])
    {
      v105 = 3;
      v106 = "type mismatch for bb argument #";
      v107 = 31;
      v50 = &v105;
      v51 = (char *)v109;
      if (v110 >= v111)
      {
        v81 = v110 + 1;
        if (v109 <= &v105 && (char *)v109 + 24 * v110 > (char *)&v105)
        {
          v96 = (char *)&v105 - (_BYTE *)v109;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v81, 24);
          v51 = (char *)v109;
          v50 = (int *)((char *)v109 + v96);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v81, 24);
          v50 = &v105;
          v51 = (char *)v109;
        }
      }
      v52 = &v51[24 * v110];
      v53 = *(_OWORD *)v50;
      *((_QWORD *)v52 + 2) = *((_QWORD *)v50 + 2);
      *(_OWORD *)v52 = v53;
      v54 = ++v110;
      if (v108[0])
      {
        v105 = 5;
        v106 = (const char *)v4;
        v55 = &v105;
        v56 = (char *)v109;
        if (v54 >= v111)
        {
          v84 = v54 + 1;
          v85 = (char *)v109 + 24 * v54 > (char *)&v105;
          if (v109 <= &v105 && v85)
          {
            v98 = (char *)&v105 - (_BYTE *)v109;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v84, 24);
            v56 = (char *)v109;
            v55 = (int *)((char *)v109 + v98);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v84, 24);
            v55 = &v105;
            v56 = (char *)v109;
          }
        }
        v57 = &v56[24 * v110];
        v58 = *(_OWORD *)v55;
        *((_QWORD *)v57 + 2) = *((_QWORD *)v55 + 2);
        *(_OWORD *)v57 = v58;
        v59 = ++v110;
        if (v108[0])
        {
          v105 = 3;
          v106 = " of successor #";
          v107 = 15;
          v60 = &v105;
          v61 = (char *)v109;
          if (v59 >= v111)
          {
            v88 = v59 + 1;
            v89 = (char *)v109 + 24 * v59 > (char *)&v105;
            if (v109 <= &v105 && v89)
            {
              v100 = (char *)&v105 - (_BYTE *)v109;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v88, 24);
              v61 = (char *)v109;
              v60 = (int *)((char *)v109 + v100);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v88, 24);
              v60 = &v105;
              v61 = (char *)v109;
            }
          }
          v62 = &v61[24 * v110];
          v63 = *(_OWORD *)v60;
          *((_QWORD *)v62 + 2) = *((_QWORD *)v60 + 2);
          *(_OWORD *)v62 = v63;
          v64 = ++v110;
          if (v108[0])
          {
            v105 = 5;
            v106 = v6;
            v65 = &v105;
            v66 = (char *)v109;
            if (v64 >= v111)
            {
              v91 = v64 + 1;
              v92 = (char *)v109 + 24 * v64 > (char *)&v105;
              if (v109 <= &v105 && v92)
              {
                v102 = (char *)&v105 - (_BYTE *)v109;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v91, 24);
                v66 = (char *)v109;
                v65 = (int *)((char *)v109 + v102);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v91, 24);
                v65 = &v105;
                v66 = (char *)v109;
              }
            }
            v67 = &v66[24 * v110];
            v68 = *(_OWORD *)v65;
            *((_QWORD *)v67 + 2) = *((_QWORD *)v65 + 2);
            *(_OWORD *)v67 = v68;
            ++v110;
          }
        }
      }
    }
    v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v108);
    if (v108[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v108);
    if (v117)
    {
      v69 = (_QWORD **)__p;
      if (__p)
      {
        v70 = v116;
        v71 = __p;
        if (v116 != __p)
        {
          do
            v70 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v70 - 1);
          while (v70 != v69);
          v71 = __p;
        }
        v116 = v69;
        operator delete(v71);
      }
      v45 = v113;
      if (!v113)
        goto LABEL_59;
      v72 = v114;
      v47 = v113;
      if (v114 == v113)
      {
LABEL_58:
        v114 = v45;
        operator delete(v47);
LABEL_59:
        if (v109 != v112)
          free(v109);
        return v12;
      }
      do
      {
        v74 = (void *)*--v72;
        v73 = v74;
        *v72 = 0;
        if (v74)
          operator delete[](v73);
      }
      while (v72 != v45);
LABEL_57:
      v47 = v113;
      goto LABEL_58;
    }
  }
  else
  {
    v104 = 257;
    mlir::Operation::emitError((uint64_t *)a1, (uint64_t)v103, (uint64_t)v108);
    if (v108[0])
    {
      v105 = 3;
      v106 = "branch has ";
      v107 = 11;
      v13 = &v105;
      v14 = (char *)v109;
      if (v110 >= v111)
      {
        v76 = v110 + 1;
        if (v109 <= &v105 && (char *)v109 + 24 * v110 > (char *)&v105)
        {
          v93 = (char *)&v105 - (_BYTE *)v109;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v76, 24);
          v14 = (char *)v109;
          v13 = (int *)((char *)v109 + v93);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v76, 24);
          v13 = &v105;
          v14 = (char *)v109;
        }
      }
      v15 = &v14[24 * v110];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
      *(_OWORD *)v15 = v16;
      v17 = ++v110;
      if (v108[0])
      {
        v105 = 5;
        v106 = (const char *)(v5 + v4);
        v18 = &v105;
        v19 = (char *)v109;
        if (v17 >= v111)
        {
          v77 = v17 + 1;
          v78 = (char *)v109 + 24 * v17 > (char *)&v105;
          if (v109 <= &v105 && v78)
          {
            v94 = (char *)&v105 - (_BYTE *)v109;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v77, 24);
            v19 = (char *)v109;
            v18 = (int *)((char *)v109 + v94);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v77, 24);
            v18 = &v105;
            v19 = (char *)v109;
          }
        }
        v20 = &v19[24 * v110];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
        *(_OWORD *)v20 = v21;
        v22 = ++v110;
        if (v108[0])
        {
          v105 = 3;
          v106 = " operands for successor #";
          v107 = 25;
          v23 = &v105;
          v24 = (char *)v109;
          if (v22 >= v111)
          {
            v79 = v22 + 1;
            v80 = (char *)v109 + 24 * v22 > (char *)&v105;
            if (v109 <= &v105 && v80)
            {
              v95 = (char *)&v105 - (_BYTE *)v109;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v79, 24);
              v24 = (char *)v109;
              v23 = (int *)((char *)v109 + v95);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v79, 24);
              v23 = &v105;
              v24 = (char *)v109;
            }
          }
          v25 = &v24[24 * v110];
          v26 = *(_OWORD *)v23;
          *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
          *(_OWORD *)v25 = v26;
          v27 = ++v110;
          if (v108[0])
          {
            v105 = 5;
            v106 = v6;
            v28 = &v105;
            v29 = (char *)v109;
            if (v27 >= v111)
            {
              v82 = v27 + 1;
              v83 = (char *)v109 + 24 * v27 > (char *)&v105;
              if (v109 <= &v105 && v83)
              {
                v97 = (char *)&v105 - (_BYTE *)v109;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v82, 24);
                v29 = (char *)v109;
                v28 = (int *)((char *)v109 + v97);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v82, 24);
                v28 = &v105;
                v29 = (char *)v109;
              }
            }
            v30 = &v29[24 * v110];
            v31 = *(_OWORD *)v28;
            *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
            *(_OWORD *)v30 = v31;
            v32 = ++v110;
            if (v108[0])
            {
              v105 = 3;
              v106 = ", but target block has ";
              v107 = 23;
              v33 = &v105;
              v34 = (char *)v109;
              if (v32 >= v111)
              {
                v86 = v32 + 1;
                v87 = (char *)v109 + 24 * v32 > (char *)&v105;
                if (v109 <= &v105 && v87)
                {
                  v99 = (char *)&v105 - (_BYTE *)v109;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v86, 24);
                  v34 = (char *)v109;
                  v33 = (int *)((char *)v109 + v99);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v86, 24);
                  v33 = &v105;
                  v34 = (char *)v109;
                }
              }
              v35 = &v34[24 * v110];
              v36 = *(_OWORD *)v33;
              *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
              *(_OWORD *)v35 = v36;
              ++v110;
              if (v108[0])
              {
                v37 = *(_QWORD *)(v7 + 56) - *(_QWORD *)(v7 + 48);
                v105 = 5;
                v106 = (const char *)(v37 >> 3);
                v38 = &v105;
                v39 = (char *)v109;
                if (v110 >= v111)
                {
                  v90 = v110 + 1;
                  if (v109 <= &v105 && (char *)v109 + 24 * v110 > (char *)&v105)
                  {
                    v101 = (char *)&v105 - (_BYTE *)v109;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v90, 24);
                    v39 = (char *)v109;
                    v38 = (int *)((char *)v109 + v101);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v109, v112, v90, 24);
                    v38 = &v105;
                    v39 = (char *)v109;
                  }
                }
                v40 = &v39[24 * v110];
                v41 = *(_OWORD *)v38;
                *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                *(_OWORD *)v40 = v41;
                ++v110;
              }
            }
          }
        }
      }
    }
    v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v108);
    if (v108[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v108);
    if (v117)
    {
      v42 = (_QWORD **)__p;
      if (__p)
      {
        v43 = v116;
        v44 = __p;
        if (v116 != __p)
        {
          do
            v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
          while (v43 != v42);
          v44 = __p;
        }
        v116 = v42;
        operator delete(v44);
      }
      v45 = v113;
      if (!v113)
        goto LABEL_59;
      v46 = v114;
      v47 = v113;
      if (v114 == v113)
        goto LABEL_58;
      do
      {
        v49 = (void *)*--v46;
        v48 = v49;
        *v46 = 0;
        if (v49)
          operator delete[](v48);
      }
      while (v46 != v45);
      goto LABEL_57;
    }
  }
  return v12;
}

uint64_t mlir::detail::verifyTypesAlongControlFlowEdges(mlir::detail *this, mlir::Operation *a2)
{
  mlir::detail *v2;
  unint64_t v3;
  mlir::Region *v4;
  mlir::Region *v5;
  mlir::Region *v6;
  uint64_t v7;
  uint64_t *v8;
  mlir::GenericProgramPoint **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t InterfaceFor;
  int v13;
  void *v14;
  _QWORD v16[4];
  _QWORD *v17;
  _QWORD *v18;
  _QWORD v19[2];
  uint64_t *v20;
  void *v21;
  uint64_t v22;
  _QWORD v23[8];

  v2 = this;
  v23[6] = *MEMORY[0x1E0C80C00];
  v20 = (uint64_t *)this;
  if (this)
    this = (mlir::detail *)mlir::OpInterface<mlir::RegionBranchOpInterface,mlir::detail::RegionBranchOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v19[0] = v2;
  v19[1] = this;
  v18 = v19;
  if (!verifyTypesAlongAllEdges((uint64_t *)v2, 0, (void (*)(_QWORD *__return_ptr, _QWORD, _QWORD))llvm::function_ref<mlir::FailureOr<mlir::TypeRange> ()(mlir::RegionBranchPoint)>::callback_fn<mlir::detail::verifyTypesAlongControlFlowEdges(mlir::Operation *)::$_0>, (uint64_t)&v18))return 0;
  v17 = v19;
  v3 = *((unsigned int *)v2 + 11);
  if ((v3 & 0x7FFFFF) != 0)
  {
    v4 = (mlir::Region *)((((unint64_t)v2 + 16 * ((v3 >> 23) & 1) + ((v3 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                        + 32 * *((unsigned int *)v2 + 10));
    v5 = (mlir::Region *)((char *)v4 + 24 * (v3 & 0x7FFFFF));
    while (1)
    {
      v21 = v23;
      v22 = 0x300000000;
      v6 = (mlir::Region *)*((_QWORD *)v4 + 1);
      if (v6 != v4)
      {
        do
        {
          if (v6)
            v9 = (mlir::GenericProgramPoint **)((char *)v6 - 8);
          else
            v9 = 0;
          mlir::Block::getTerminator(v9);
          v11 = v10;
          if (mlir::OpInterface<mlir::RegionBranchTerminatorOpInterface,mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits>::getInterfaceFor(v10)
            && v11)
          {
            InterfaceFor = mlir::OpInterface<mlir::RegionBranchTerminatorOpInterface,mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits>::getInterfaceFor(v11);
            v7 = v22;
            if (v22 >= (unint64_t)HIDWORD(v22))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v21, v23, v22 + 1, 16);
              v7 = v22;
            }
            v8 = (uint64_t *)((char *)v21 + 16 * v7);
            *v8 = v11;
            v8[1] = InterfaceFor;
            LODWORD(v22) = v22 + 1;
          }
          v6 = (mlir::Region *)*((_QWORD *)v6 + 1);
        }
        while (v6 != v4);
        if ((_DWORD)v22)
          break;
      }
      v13 = 3;
      v14 = v21;
      if (v21 != v23)
        goto LABEL_24;
LABEL_25:
      if (v13 != 3 && v13)
        return 0;
      v4 = (mlir::Region *)((char *)v4 + 24);
      if (v4 == v5)
        return 1;
    }
    v16[0] = &v21;
    v16[1] = &v17;
    v16[2] = &v20;
    v16[3] = v4;
    v13 = verifyTypesAlongAllEdges(v20, v4, (void (*)(_QWORD *__return_ptr, _QWORD, _QWORD))llvm::function_ref<mlir::FailureOr<mlir::TypeRange> ()(mlir::RegionBranchPoint)>::callback_fn<mlir::detail::verifyTypesAlongControlFlowEdges(mlir::Operation *)::$_2>, (uint64_t)v16) == 0;
    v14 = v21;
    if (v21 == v23)
      goto LABEL_25;
LABEL_24:
    free(v14);
    goto LABEL_25;
  }
  return 1;
}

uint64_t verifyTypesAlongAllEdges(uint64_t *a1, mlir::Region *a2, void (*a3)(_QWORD *__return_ptr, _QWORD, _QWORD), uint64_t a4)
{
  uint64_t InterfaceFor;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  __n128 *v18;
  char *v19;
  char *v20;
  __n128 v21;
  uint64_t v22;
  __n128 *v23;
  char *v24;
  char *v25;
  __n128 v26;
  uint64_t v27;
  __n128 *v28;
  char *v29;
  char *v30;
  __n128 v31;
  __n128 *v32;
  char *v33;
  char *v34;
  __n128 v35;
  uint64_t v36;
  __n128 *v37;
  char *v38;
  char *v39;
  __n128 v40;
  uint64_t v41;
  __n128 *v42;
  char *v43;
  char *v44;
  __n128 v45;
  uint64_t v46;
  __n128 *v47;
  char *v48;
  char *v49;
  __n128 v50;
  __n128 *v51;
  char *v52;
  char *v53;
  __n128 v54;
  uint64_t v55;
  _QWORD **v56;
  _QWORD **v57;
  void *v58;
  _QWORD *v59;
  _QWORD *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  __n128 *v65;
  char *v66;
  char *v67;
  __n128 v68;
  uint64_t v69;
  __n128 *v70;
  char *v71;
  char *v72;
  __n128 v73;
  uint64_t v74;
  __n128 *v75;
  char *v76;
  char *v77;
  __n128 v78;
  uint64_t v79;
  __n128 *v80;
  char *v81;
  char *v82;
  __n128 v83;
  _QWORD **v84;
  _QWORD **v85;
  void *v86;
  _QWORD *v87;
  _QWORD *v88;
  void *v89;
  void *v90;
  void *v91;
  unint64_t v93;
  unint64_t v94;
  BOOL v95;
  unint64_t v96;
  BOOL v97;
  unint64_t v98;
  unint64_t v99;
  BOOL v100;
  unint64_t v101;
  unint64_t v102;
  BOOL v103;
  unint64_t v104;
  BOOL v105;
  unint64_t v106;
  BOOL v107;
  unint64_t v108;
  BOOL v109;
  unint64_t v110;
  unint64_t v111;
  BOOL v112;
  int64_t v113;
  int64_t v114;
  int64_t v115;
  int64_t v116;
  int64_t v117;
  int64_t v118;
  int64_t v119;
  int64_t v120;
  int64_t v121;
  int64_t v122;
  int64_t v123;
  int64_t v124;
  unint64_t *v125;
  void (*v126)(_QWORD *__return_ptr, _QWORD, _QWORD);
  __n128 v128;
  uint64_t v129;
  __int16 v130;
  __n128 v131;
  void *v132;
  unsigned int v133;
  unsigned int v134;
  _BYTE v135[96];
  void *v136;
  _QWORD *v137;
  void *__p;
  _QWORD **v139;
  char v140;
  __n128 v141;
  uint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  unint64_t v146;
  char v147;
  unint64_t *v148;
  uint64_t v149;
  _QWORD v150[8];

  v150[6] = *MEMORY[0x1E0C80C00];
  if (a1)
    InterfaceFor = mlir::OpInterface<mlir::RegionBranchOpInterface,mlir::detail::RegionBranchOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a1);
  else
    InterfaceFor = 0;
  v148 = v150;
  v149 = 0x200000000;
  (*(void (**)(uint64_t, uint64_t *, mlir::Region *, unint64_t **))(InterfaceFor + 16))(InterfaceFor, a1, a2, &v148);
  if (!(_DWORD)v149)
  {
    v55 = 1;
    goto LABEL_77;
  }
  v8 = v148;
  v125 = &v148[3 * v149];
  v126 = a3;
  while (1)
  {
    a3(&v145, a4, *v8);
    if (!v147)
    {
      v55 = 0;
      goto LABEL_77;
    }
    v128 = *(__n128 *)(v8 + 1);
    mlir::ValueRange::getTypes(&v128, &v141);
    v10 = v141.n128_u64[1];
    v9 = v141.n128_u64[0];
    v11 = v142;
    v131 = v141;
    if (v141.n128_u64[1])
    {
      v9 = mlir::ValueRange::offset_base(&v131, v141.n128_i64[1]);
      v10 = v131.n128_u64[1];
    }
    mlir::TypeRange::TypeRange((unint64_t *)&v143, v9, v11 - v10);
    v12 = v146;
    if (v146 != v144)
      break;
    if (v146)
    {
      v13 = 0;
      v14 = v145;
      v15 = v143;
      while (1)
      {
        v16 = mlir::TypeRange::dereference_iterator(v14, v13);
        v17 = mlir::TypeRange::dereference_iterator(v15, v13);
        if (((*(uint64_t (**)(uint64_t, uint64_t *, unint64_t, unint64_t))(InterfaceFor + 32))(InterfaceFor, a1, v16, v17) & 1) == 0)break;
        if (v12 == ++v13)
          goto LABEL_6;
      }
      v128.n128_u64[0] = (unint64_t)" along control flow edge ";
      v130 = 259;
      mlir::Operation::emitOpError(a1, (const void ***)&v128, (uint64_t)&v131);
      printRegionEdgeName((uint64_t *)&v131, a2, *v8);
      if (v131.n128_u64[0])
      {
        v128.n128_u32[0] = 3;
        v128.n128_u64[1] = (unint64_t)": source type #";
        v129 = 15;
        v18 = &v128;
        v19 = (char *)v132;
        if (v133 >= v134)
        {
          v93 = v133 + 1;
          if (v132 <= &v128 && (char *)v132 + 24 * v133 > (char *)&v128)
          {
            v113 = (char *)&v128 - (_BYTE *)v132;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v93, 24);
            v19 = (char *)v132;
            v18 = (__n128 *)((char *)v132 + v113);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v93, 24);
            v18 = &v128;
            v19 = (char *)v132;
          }
        }
        v20 = &v19[24 * v133];
        v21 = *v18;
        *((_QWORD *)v20 + 2) = v18[1].n128_u64[0];
        *(__n128 *)v20 = v21;
        v22 = ++v133;
        if (v131.n128_u64[0])
        {
          v128.n128_u32[0] = 5;
          v128.n128_u64[1] = v13;
          v23 = &v128;
          v24 = (char *)v132;
          if (v22 >= v134)
          {
            v94 = v22 + 1;
            v95 = (char *)v132 + 24 * v22 > (char *)&v128;
            if (v132 <= &v128 && v95)
            {
              v114 = (char *)&v128 - (_BYTE *)v132;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v94, 24);
              v24 = (char *)v132;
              v23 = (__n128 *)((char *)v132 + v114);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v94, 24);
              v23 = &v128;
              v24 = (char *)v132;
            }
          }
          v25 = &v24[24 * v133];
          v26 = *v23;
          *((_QWORD *)v25 + 2) = v23[1].n128_u64[0];
          *(__n128 *)v25 = v26;
          v27 = ++v133;
          if (v131.n128_u64[0])
          {
            v128.n128_u32[0] = 3;
            v128.n128_u64[1] = (unint64_t)" ";
            v129 = 1;
            v28 = &v128;
            v29 = (char *)v132;
            if (v27 >= v134)
            {
              v96 = v27 + 1;
              v97 = (char *)v132 + 24 * v27 > (char *)&v128;
              if (v132 <= &v128 && v97)
              {
                v115 = (char *)&v128 - (_BYTE *)v132;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v96, 24);
                v29 = (char *)v132;
                v28 = (__n128 *)((char *)v132 + v115);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v96, 24);
                v28 = &v128;
                v29 = (char *)v132;
              }
            }
            v30 = &v29[24 * v133];
            v31 = *v28;
            *((_QWORD *)v30 + 2) = v28[1].n128_u64[0];
            *(__n128 *)v30 = v31;
            ++v133;
            if (v131.n128_u64[0])
            {
              v32 = &v128;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v128, v16);
              v33 = (char *)v132;
              if (v133 >= v134)
              {
                v98 = v133 + 1;
                if (v132 <= &v128 && (char *)v132 + 24 * v133 > (char *)&v128)
                {
                  v116 = (char *)&v128 - (_BYTE *)v132;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v98, 24);
                  v33 = (char *)v132;
                  v32 = (__n128 *)((char *)v132 + v116);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v98, 24);
                  v32 = &v128;
                  v33 = (char *)v132;
                }
              }
              v34 = &v33[24 * v133];
              v35 = *v32;
              *((_QWORD *)v34 + 2) = v32[1].n128_u64[0];
              *(__n128 *)v34 = v35;
              v36 = ++v133;
              if (v131.n128_u64[0])
              {
                v128.n128_u32[0] = 3;
                v128.n128_u64[1] = (unint64_t)" should match input type #";
                v129 = 26;
                v37 = &v128;
                v38 = (char *)v132;
                if (v36 >= v134)
                {
                  v99 = v36 + 1;
                  v100 = (char *)v132 + 24 * v36 > (char *)&v128;
                  if (v132 <= &v128 && v100)
                  {
                    v117 = (char *)&v128 - (_BYTE *)v132;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v99, 24);
                    v38 = (char *)v132;
                    v37 = (__n128 *)((char *)v132 + v117);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v99, 24);
                    v37 = &v128;
                    v38 = (char *)v132;
                  }
                }
                v39 = &v38[24 * v133];
                v40 = *v37;
                *((_QWORD *)v39 + 2) = v37[1].n128_u64[0];
                *(__n128 *)v39 = v40;
                v41 = ++v133;
                if (v131.n128_u64[0])
                {
                  v128.n128_u32[0] = 5;
                  v128.n128_u64[1] = v13;
                  v42 = &v128;
                  v43 = (char *)v132;
                  if (v41 >= v134)
                  {
                    v102 = v41 + 1;
                    v103 = (char *)v132 + 24 * v41 > (char *)&v128;
                    if (v132 <= &v128 && v103)
                    {
                      v119 = (char *)&v128 - (_BYTE *)v132;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v102, 24);
                      v43 = (char *)v132;
                      v42 = (__n128 *)((char *)v132 + v119);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v102, 24);
                      v42 = &v128;
                      v43 = (char *)v132;
                    }
                  }
                  v44 = &v43[24 * v133];
                  v45 = *v42;
                  *((_QWORD *)v44 + 2) = v42[1].n128_u64[0];
                  *(__n128 *)v44 = v45;
                  v46 = ++v133;
                  if (v131.n128_u64[0])
                  {
                    v128.n128_u32[0] = 3;
                    v128.n128_u64[1] = (unint64_t)" ";
                    v129 = 1;
                    v47 = &v128;
                    v48 = (char *)v132;
                    if (v46 >= v134)
                    {
                      v106 = v46 + 1;
                      v107 = (char *)v132 + 24 * v46 > (char *)&v128;
                      if (v132 <= &v128 && v107)
                      {
                        v121 = (char *)&v128 - (_BYTE *)v132;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v106, 24);
                        v48 = (char *)v132;
                        v47 = (__n128 *)((char *)v132 + v121);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v106, 24);
                        v47 = &v128;
                        v48 = (char *)v132;
                      }
                    }
                    v49 = &v48[24 * v133];
                    v50 = *v47;
                    *((_QWORD *)v49 + 2) = v47[1].n128_u64[0];
                    *(__n128 *)v49 = v50;
                    ++v133;
                    if (v131.n128_u64[0])
                    {
                      v51 = &v128;
                      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v128, v17);
                      v52 = (char *)v132;
                      if (v133 >= v134)
                      {
                        v110 = v133 + 1;
                        if (v132 <= &v128 && (char *)v132 + 24 * v133 > (char *)&v128)
                        {
                          v123 = (char *)&v128 - (_BYTE *)v132;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v110, 24);
                          v52 = (char *)v132;
                          v51 = (__n128 *)((char *)v132 + v123);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v110, 24);
                          v51 = &v128;
                          v52 = (char *)v132;
                        }
                      }
                      v53 = &v52[24 * v133];
                      v54 = *v51;
                      *((_QWORD *)v53 + 2) = v51[1].n128_u64[0];
                      *(__n128 *)v53 = v54;
                      ++v133;
                    }
                  }
                }
              }
            }
          }
        }
      }
      v55 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v131);
      if (v131.n128_u64[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v131);
      if (v140)
      {
        v56 = (_QWORD **)__p;
        if (__p)
        {
          v57 = v139;
          v58 = __p;
          if (v139 != __p)
          {
            do
              v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
            while (v57 != v56);
            v58 = __p;
          }
          v139 = v56;
          operator delete(v58);
        }
        v59 = v136;
        if (v136)
        {
          v60 = v137;
          v61 = v136;
          if (v137 != v136)
          {
            do
            {
              v63 = (void *)*--v60;
              v62 = v63;
              *v60 = 0;
              if (v63)
                operator delete[](v62);
            }
            while (v60 != v59);
            v61 = v136;
          }
          v137 = v59;
          operator delete(v61);
        }
        v64 = v132;
        if (v132 != v135)
          goto LABEL_51;
      }
      goto LABEL_77;
    }
LABEL_6:
    v8 += 3;
    a3 = v126;
    if (v8 == v125)
    {
      v55 = 1;
      goto LABEL_77;
    }
  }
  v128.n128_u64[0] = (unint64_t)" region control flow edge ";
  v130 = 259;
  mlir::Operation::emitOpError(a1, (const void ***)&v128, (uint64_t)&v131);
  printRegionEdgeName((uint64_t *)&v131, a2, *v8);
  if (v131.n128_u64[0])
  {
    v128.n128_u32[0] = 3;
    v128.n128_u64[1] = (unint64_t)": source has ";
    v129 = 13;
    v65 = &v128;
    v66 = (char *)v132;
    if (v133 >= v134)
    {
      v101 = v133 + 1;
      if (v132 <= &v128 && (char *)v132 + 24 * v133 > (char *)&v128)
      {
        v118 = (char *)&v128 - (_BYTE *)v132;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v101, 24);
        v66 = (char *)v132;
        v65 = (__n128 *)((char *)v132 + v118);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v101, 24);
        v65 = &v128;
        v66 = (char *)v132;
      }
    }
    v67 = &v66[24 * v133];
    v68 = *v65;
    *((_QWORD *)v67 + 2) = v65[1].n128_u64[0];
    *(__n128 *)v67 = v68;
    v69 = ++v133;
    if (v131.n128_u64[0])
    {
      v128.n128_u32[0] = 5;
      v128.n128_u64[1] = v146;
      v70 = &v128;
      v71 = (char *)v132;
      if (v69 >= v134)
      {
        v104 = v69 + 1;
        v105 = (char *)v132 + 24 * v69 > (char *)&v128;
        if (v132 <= &v128 && v105)
        {
          v120 = (char *)&v128 - (_BYTE *)v132;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v104, 24);
          v71 = (char *)v132;
          v70 = (__n128 *)((char *)v132 + v120);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v104, 24);
          v70 = &v128;
          v71 = (char *)v132;
        }
      }
      v72 = &v71[24 * v133];
      v73 = *v70;
      *((_QWORD *)v72 + 2) = v70[1].n128_u64[0];
      *(__n128 *)v72 = v73;
      v74 = ++v133;
      if (v131.n128_u64[0])
      {
        v128.n128_u32[0] = 3;
        v128.n128_u64[1] = (unint64_t)" operands, but target successor needs ";
        v129 = 38;
        v75 = &v128;
        v76 = (char *)v132;
        if (v74 >= v134)
        {
          v108 = v74 + 1;
          v109 = (char *)v132 + 24 * v74 > (char *)&v128;
          if (v132 <= &v128 && v109)
          {
            v122 = (char *)&v128 - (_BYTE *)v132;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v108, 24);
            v76 = (char *)v132;
            v75 = (__n128 *)((char *)v132 + v122);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v108, 24);
            v75 = &v128;
            v76 = (char *)v132;
          }
        }
        v77 = &v76[24 * v133];
        v78 = *v75;
        *((_QWORD *)v77 + 2) = v75[1].n128_u64[0];
        *(__n128 *)v77 = v78;
        v79 = ++v133;
        if (v131.n128_u64[0])
        {
          v128.n128_u32[0] = 5;
          v128.n128_u64[1] = v144;
          v80 = &v128;
          v81 = (char *)v132;
          if (v79 >= v134)
          {
            v111 = v79 + 1;
            v112 = (char *)v132 + 24 * v79 > (char *)&v128;
            if (v132 <= &v128 && v112)
            {
              v124 = (char *)&v128 - (_BYTE *)v132;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v111, 24);
              v81 = (char *)v132;
              v80 = (__n128 *)((char *)v132 + v124);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v111, 24);
              v80 = &v128;
              v81 = (char *)v132;
            }
          }
          v82 = &v81[24 * v133];
          v83 = *v80;
          *((_QWORD *)v82 + 2) = v80[1].n128_u64[0];
          *(__n128 *)v82 = v83;
          ++v133;
        }
      }
    }
  }
  v55 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v131);
  if (v131.n128_u64[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v131);
  if (v140)
  {
    v84 = (_QWORD **)__p;
    if (__p)
    {
      v85 = v139;
      v86 = __p;
      if (v139 != __p)
      {
        do
          v85 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v85 - 1);
        while (v85 != v84);
        v86 = __p;
      }
      v139 = v84;
      operator delete(v86);
    }
    v87 = v136;
    if (v136)
    {
      v88 = v137;
      v89 = v136;
      if (v137 != v136)
      {
        do
        {
          v91 = (void *)*--v88;
          v90 = v91;
          *v88 = 0;
          if (v91)
            operator delete[](v90);
        }
        while (v88 != v87);
        v89 = v136;
      }
      v137 = v87;
      operator delete(v89);
    }
    v64 = v132;
    if (v132 != v135)
LABEL_51:
      free(v64);
  }
LABEL_77:
  if (v148 != v150)
    free(v148);
  return v55;
}

uint64_t llvm::SmallVectorImpl<std::pair<unsigned int,mlir::NamedAttribute>>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t *v5;
  char *v6;
  _DWORD *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;

  if ((uint64_t *)a1 != a2)
  {
    v5 = a2 + 2;
    v4 = *a2;
    if ((uint64_t *)*a2 != a2 + 2)
    {
      v6 = *(char **)a1;
      if (*(_QWORD *)a1 != a1 + 16)
      {
        free(v6);
        v4 = *a2;
      }
      *(_QWORD *)a1 = v4;
      v7 = a2 + 1;
      *(_QWORD *)(a1 + 8) = a2[1];
      *a2 = (uint64_t)v5;
      *((_DWORD *)a2 + 3) = 0;
      goto LABEL_20;
    }
    v7 = a2 + 1;
    v8 = *((unsigned int *)a2 + 2);
    v9 = *(unsigned int *)(a1 + 8);
    if (v9 >= v8)
    {
      if ((_DWORD)v8)
      {
        v11 = *(char **)a1;
        v12 = v4 + 24 * v8;
        do
        {
          *(_DWORD *)v11 = *(_DWORD *)v4;
          *(_OWORD *)(v11 + 8) = *(_OWORD *)(v4 + 8);
          v4 += 24;
          v11 += 24;
        }
        while (v4 != v12);
      }
      goto LABEL_19;
    }
    if (*(_DWORD *)(a1 + 12) >= v8)
    {
      if ((_DWORD)v9)
      {
        v13 = v4 + 24 * v9;
        v14 = *(char **)a1;
        do
        {
          *(_DWORD *)v14 = *(_DWORD *)v4;
          *(_OWORD *)(v14 + 8) = *(_OWORD *)(v4 + 8);
          v4 += 24;
          v14 += 24;
        }
        while (v4 != v13);
        v10 = *v7;
        if (v9 == v10)
          goto LABEL_19;
      }
      else
      {
        v9 = 0;
        LODWORD(v10) = *v7;
        if (!*v7)
          goto LABEL_19;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v8, 24);
      v9 = 0;
      LODWORD(v10) = *v7;
      if (!*v7)
        goto LABEL_19;
    }
    memcpy((void *)(*(_QWORD *)a1 + 24 * v9), (const void *)(*a2 + 24 * v9), *a2 + 24 * v10 - (*a2 + 24 * v9));
LABEL_19:
    *(_DWORD *)(a1 + 8) = v8;
LABEL_20:
    *v7 = 0;
  }
  return a1;
}

uint64_t *printRegionEdgeName(uint64_t *a1, mlir::Region *this, unint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int *v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  __int128 v18;
  unsigned int RegionNumber;
  unsigned int v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  __int128 v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  int *v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  unint64_t v35;
  int *v36;
  uint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  int *v43;
  uint64_t v44;
  __int128 v45;
  unsigned int v46;
  unsigned int v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  int *v51;
  uint64_t v52;
  __int128 v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int *v57;
  uint64_t v58;
  __int128 v59;
  unint64_t v61;
  BOOL v62;
  unint64_t v63;
  BOOL v64;
  unint64_t v65;
  BOOL v66;
  unint64_t v67;
  BOOL v68;
  unint64_t v69;
  BOOL v70;
  unint64_t v71;
  BOOL v72;
  unint64_t v73;
  BOOL v74;
  unint64_t v75;
  BOOL v76;
  char *v77;
  char *v78;
  char *v79;
  char *v80;
  char *v81;
  char *v82;
  char *v83;
  char *v84;
  int v85;
  const char *v86;
  uint64_t v87;

  if (*a1)
  {
    v6 = (uint64_t)(a1 + 3);
    v7 = a1[3];
    v85 = 3;
    v86 = "from ";
    v87 = 5;
    v8 = *((unsigned int *)a1 + 8);
    v9 = &v85;
    if (v8 >= *((_DWORD *)a1 + 9))
    {
      v61 = v8 + 1;
      v62 = v7 + 24 * v8 > (unint64_t)&v85;
      if (v7 <= (unint64_t)&v85 && v62)
      {
        v77 = (char *)&v85 - v7;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v6, a1 + 5, v61, 24);
        v7 = a1[3];
        v9 = (int *)&v77[v7];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v6, a1 + 5, v61, 24);
        v7 = a1[3];
        v9 = &v85;
      }
    }
    v10 = v7 + 24 * *((unsigned int *)a1 + 8);
    v11 = *(_OWORD *)v9;
    *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
    *(_OWORD *)v10 = v11;
    ++*((_DWORD *)a1 + 8);
  }
  v12 = *a1;
  if (this)
  {
    if (v12)
    {
      v13 = (uint64_t)(a1 + 3);
      v14 = a1[3];
      v85 = 3;
      v86 = "Region #";
      v87 = 8;
      v15 = *((unsigned int *)a1 + 8);
      v16 = &v85;
      if (v15 >= *((_DWORD *)a1 + 9))
      {
        v63 = v15 + 1;
        v64 = v14 + 24 * v15 > (unint64_t)&v85;
        if (v14 <= (unint64_t)&v85 && v64)
        {
          v78 = (char *)&v85 - v14;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v13, a1 + 5, v63, 24);
          v14 = a1[3];
          v16 = (int *)&v78[v14];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v13, a1 + 5, v63, 24);
          v14 = a1[3];
          v16 = &v85;
        }
      }
      v17 = v14 + 24 * *((unsigned int *)a1 + 8);
      v18 = *(_OWORD *)v16;
      *(_QWORD *)(v17 + 16) = *((_QWORD *)v16 + 2);
      *(_OWORD *)v17 = v18;
      ++*((_DWORD *)a1 + 8);
    }
    RegionNumber = mlir::Region::getRegionNumber((unint64_t)this);
    if (!*a1)
      goto LABEL_17;
    v20 = RegionNumber;
    v21 = (uint64_t)(a1 + 3);
    v22 = a1[3];
    v85 = 5;
    v86 = (const char *)v20;
    v23 = *((unsigned int *)a1 + 8);
    v24 = &v85;
    if (v23 >= *((_DWORD *)a1 + 9))
    {
      v65 = v23 + 1;
      v66 = v22 + 24 * v23 > (unint64_t)&v85;
      if (v22 <= (unint64_t)&v85 && v66)
      {
        v79 = (char *)&v85 - v22;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v21, a1 + 5, v65, 24);
        v22 = a1[3];
        v24 = (int *)&v79[v22];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v21, a1 + 5, v65, 24);
        v22 = a1[3];
        v24 = &v85;
      }
    }
    v25 = v22 + 24 * *((unsigned int *)a1 + 8);
    v26 = *(_OWORD *)v24;
    *(_QWORD *)(v25 + 16) = *((_QWORD *)v24 + 2);
    *(_OWORD *)v25 = v26;
    v27 = *((_DWORD *)a1 + 8) + 1;
    *((_DWORD *)a1 + 8) = v27;
    if (!*a1)
      goto LABEL_17;
LABEL_15:
    v34 = (uint64_t)(a1 + 3);
    v35 = a1[3];
    v85 = 3;
    v86 = " to ";
    v87 = 4;
    v36 = &v85;
    if (v27 >= *((_DWORD *)a1 + 9))
    {
      v67 = v27 + 1;
      v68 = v35 + 24 * v27 > (unint64_t)&v85;
      if (v35 <= (unint64_t)&v85 && v68)
      {
        v80 = (char *)&v85 - v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v34, a1 + 5, v67, 24);
        v35 = a1[3];
        v36 = (int *)&v80[v35];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v34, a1 + 5, v67, 24);
        v35 = a1[3];
        v36 = &v85;
      }
    }
    v37 = v35 + 24 * *((unsigned int *)a1 + 8);
    v38 = *(_OWORD *)v36;
    *(_QWORD *)(v37 + 16) = *((_QWORD *)v36 + 2);
    *(_OWORD *)v37 = v38;
    ++*((_DWORD *)a1 + 8);
    goto LABEL_17;
  }
  if (v12)
  {
    v28 = (uint64_t)(a1 + 3);
    v29 = a1[3];
    v85 = 3;
    v86 = "parent operands";
    v87 = 15;
    v30 = *((unsigned int *)a1 + 8);
    v31 = &v85;
    if (v30 >= *((_DWORD *)a1 + 9))
    {
      v73 = v30 + 1;
      v74 = v29 + 24 * v30 > (unint64_t)&v85;
      if (v29 <= (unint64_t)&v85 && v74)
      {
        v83 = (char *)&v85 - v29;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v28, a1 + 5, v73, 24);
        v29 = a1[3];
        v31 = (int *)&v83[v29];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v28, a1 + 5, v73, 24);
        v29 = a1[3];
        v31 = &v85;
      }
    }
    v32 = v29 + 24 * *((unsigned int *)a1 + 8);
    v33 = *(_OWORD *)v31;
    *(_QWORD *)(v32 + 16) = *((_QWORD *)v31 + 2);
    *(_OWORD *)v32 = v33;
    v27 = *((_DWORD *)a1 + 8) + 1;
    *((_DWORD *)a1 + 8) = v27;
    if (*a1)
      goto LABEL_15;
  }
LABEL_17:
  v39 = *a1;
  if (a3)
  {
    if (v39)
    {
      v40 = (uint64_t)(a1 + 3);
      v41 = a1[3];
      v85 = 3;
      v86 = "Region #";
      v87 = 8;
      v42 = *((unsigned int *)a1 + 8);
      v43 = &v85;
      if (v42 >= *((_DWORD *)a1 + 9))
      {
        v69 = v42 + 1;
        v70 = v41 + 24 * v42 > (unint64_t)&v85;
        if (v41 <= (unint64_t)&v85 && v70)
        {
          v81 = (char *)&v85 - v41;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v40, a1 + 5, v69, 24);
          v41 = a1[3];
          v43 = (int *)&v81[v41];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v40, a1 + 5, v69, 24);
          v41 = a1[3];
          v43 = &v85;
        }
      }
      v44 = v41 + 24 * *((unsigned int *)a1 + 8);
      v45 = *(_OWORD *)v43;
      *(_QWORD *)(v44 + 16) = *((_QWORD *)v43 + 2);
      *(_OWORD *)v44 = v45;
      ++*((_DWORD *)a1 + 8);
    }
    v46 = mlir::Region::getRegionNumber(a3);
    if (*a1)
    {
      v47 = v46;
      v48 = (uint64_t)(a1 + 3);
      v49 = a1[3];
      v85 = 5;
      v86 = (const char *)v47;
      v50 = *((unsigned int *)a1 + 8);
      v51 = &v85;
      if (v50 >= *((_DWORD *)a1 + 9))
      {
        v71 = v50 + 1;
        v72 = v49 + 24 * v50 > (unint64_t)&v85;
        if (v49 <= (unint64_t)&v85 && v72)
        {
          v82 = (char *)&v85 - v49;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v48, a1 + 5, v71, 24);
          v49 = a1[3];
          v51 = (int *)&v82[v49];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v48, a1 + 5, v71, 24);
          v49 = a1[3];
          v51 = &v85;
        }
      }
      v52 = v49 + 24 * *((unsigned int *)a1 + 8);
      v53 = *(_OWORD *)v51;
      *(_QWORD *)(v52 + 16) = *((_QWORD *)v51 + 2);
      *(_OWORD *)v52 = v53;
LABEL_27:
      ++*((_DWORD *)a1 + 8);
    }
  }
  else if (v39)
  {
    v54 = (uint64_t)(a1 + 3);
    v55 = a1[3];
    v85 = 3;
    v86 = "parent results";
    v87 = 14;
    v56 = *((unsigned int *)a1 + 8);
    v57 = &v85;
    if (v56 >= *((_DWORD *)a1 + 9))
    {
      v75 = v56 + 1;
      v76 = v55 + 24 * v56 > (unint64_t)&v85;
      if (v55 <= (unint64_t)&v85 && v76)
      {
        v84 = (char *)&v85 - v55;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v54, a1 + 5, v75, 24);
        v55 = a1[3];
        v57 = (int *)&v84[v55];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v54, a1 + 5, v75, 24);
        v55 = a1[3];
        v57 = &v85;
      }
    }
    v58 = v55 + 24 * *((unsigned int *)a1 + 8);
    v59 = *(_OWORD *)v57;
    *(_QWORD *)(v58 + 16) = *((_QWORD *)v57 + 2);
    *(_OWORD *)v58 = v59;
    goto LABEL_27;
  }
  return a1;
}

double llvm::function_ref<mlir::FailureOr<mlir::TypeRange> ()(mlir::RegionBranchPoint)>::callback_fn<mlir::detail::verifyTypesAlongControlFlowEdges(mlir::Operation *)::$_0>@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  double result;
  uint64_t v5[2];
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9[3];
  unint64_t v10[3];

  v10[2] = *MEMORY[0x1E0C80C00];
  v5[0] = (**(uint64_t (***)(void))(*(_QWORD *)a1 + 8))();
  v5[1] = v3;
  mlir::OperandRange::getTypes(v5, &v6);
  mlir::ValueRange::ValueRange(v10, v6 + 32 * v7, v8 - v7);
  mlir::TypeRange::TypeRange(v9, v10[0], v10[1]);
  result = *(double *)v9;
  *(_OWORD *)a2 = *(_OWORD *)v9;
  *(_BYTE *)(a2 + 16) = 1;
  return result;
}

void llvm::function_ref<mlir::FailureOr<mlir::TypeRange> ()(mlir::RegionBranchPoint)>::callback_fn<mlir::detail::verifyTypesAlongControlFlowEdges(mlir::Operation *)::$_2>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  const void ***v17;
  char *v18;
  char *v19;
  __int128 v20;
  uint64_t v21;
  _QWORD **v22;
  _QWORD **v23;
  void *v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  void *v28;
  void *v29;
  unint64_t v30;
  int64_t v31;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v40;
  __int128 v41;
  char v42;
  const void **v43;
  const char *v44;
  uint64_t v45;
  __int16 v46;
  uint64_t v47;
  unint64_t v48;
  void *v49;
  void *v50;
  _DWORD v51[2];
  _BYTE v52[96];
  void *v53;
  _QWORD *v54;
  void *__p;
  _QWORD **v56;
  char v57;
  unint64_t v58[2];
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  LOBYTE(v41) = 0;
  v42 = 0;
  v3 = *(uint64_t **)a1;
  v4 = *(unsigned int *)(*(_QWORD *)a1 + 8);
  if (!(_DWORD)v4)
  {
LABEL_20:
    mlir::OperandRange::getTypes((uint64_t *)&v41, &v47);
    mlir::ValueRange::ValueRange((unint64_t *)&v43, v47 + 32 * v48, (unint64_t)v50 - v48);
    *((_BYTE *)mlir::TypeRange::TypeRange((unint64_t *)a3, (uint64_t)v43, (unint64_t)v44) + 16) = 1;
    return;
  }
  v7 = *v3;
  v33 = *v3 + 16 * v4;
  while (1)
  {
    (**(void (***)(uint64_t *__return_ptr))(v7 + 8))(&v47);
    v8 = mlir::MutableOperandRange::operator mlir::OperandRange((unsigned int *)&v47);
    v10 = v9;
    if (v49 != v51)
      free(v49);
    *(_QWORD *)&v40 = v8;
    *((_QWORD *)&v40 + 1) = v10;
    if (!v42)
    {
      v41 = v40;
      v42 = 1;
      goto LABEL_4;
    }
    v11 = *(_QWORD *)(a1 + 8);
    mlir::OperandRange::getTypes((uint64_t *)&v41, &v37);
    mlir::ValueRange::ValueRange((unint64_t *)&v47, v37 + 32 * v38, v39 - v38);
    mlir::TypeRange::TypeRange((unint64_t *)&v59, v47, v48);
    mlir::OperandRange::getTypes((uint64_t *)&v40, &v34);
    mlir::ValueRange::ValueRange((unint64_t *)&v47, v34 + 32 * v35, v36 - v35);
    mlir::TypeRange::TypeRange(v58, v47, v48);
    v12 = v60;
    if (v60 != v58[1])
      goto LABEL_14;
    if (v60)
      break;
LABEL_4:
    v7 += 16;
    if (v7 == v33)
      goto LABEL_20;
  }
  v13 = 0;
  v14 = v59;
  v15 = v58[0];
  while (1)
  {
    mlir::TypeRange::dereference_iterator(v14, v13);
    mlir::TypeRange::dereference_iterator(v15, v13);
    if (!(*(unsigned int (**)(void))(*(_QWORD *)(*(_QWORD *)v11 + 8) + 32))())
      break;
    if (v12 == ++v13)
      goto LABEL_4;
  }
LABEL_14:
  v16 = **(uint64_t ***)(a1 + 16);
  v43 = (const void **)" along control flow edge";
  v46 = 259;
  mlir::Operation::emitOpError(v16, &v43, (uint64_t)&v47);
  printRegionEdgeName(&v47, *(mlir::Region **)(a1 + 24), a2);
  if (!v47)
  {
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 16) = 0;
    if (!v57)
      return;
    goto LABEL_22;
  }
  LODWORD(v43) = 3;
  v44 = " operands mismatch between return-like terminators";
  v45 = 50;
  v17 = &v43;
  v18 = (char *)v50;
  if (v51[0] >= v51[1])
  {
    v30 = v51[0] + 1;
    if (v50 <= &v43 && (char *)v50 + 24 * v51[0] > (char *)&v43)
    {
      v31 = (char *)&v43 - (_BYTE *)v50;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v52, v30, 24);
      v18 = (char *)v50;
      v17 = (const void ***)((char *)v50 + v31);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v52, v30, 24);
      v17 = &v43;
      v18 = (char *)v50;
    }
  }
  v19 = &v18[24 * v51[0]];
  v20 = *(_OWORD *)v17;
  *((_QWORD *)v19 + 2) = v17[2];
  *(_OWORD *)v19 = v20;
  ++v51[0];
  v21 = v47;
  *(_BYTE *)a3 = 0;
  *(_BYTE *)(a3 + 16) = 0;
  if (v21)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v47);
  if (v57)
  {
LABEL_22:
    v22 = (_QWORD **)__p;
    if (__p)
    {
      v23 = v56;
      v24 = __p;
      if (v56 != __p)
      {
        do
          v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        v24 = __p;
      }
      v56 = v22;
      operator delete(v24);
    }
    v25 = v53;
    if (v53)
    {
      v26 = v54;
      v27 = v53;
      if (v54 != v53)
      {
        do
        {
          v29 = (void *)*--v26;
          v28 = v29;
          *v26 = 0;
          if (v29)
            operator delete[](v28);
        }
        while (v26 != v25);
        v27 = v53;
      }
      v54 = v25;
      operator delete(v27);
    }
    if (v50 != v52)
      free(v50);
  }
}

uint64_t mlir::OpTrait::util::staticallyKnownBroadcastable(const void *a1, uint64_t a2, char *a3, uint64_t a4)
{
  unint64_t v4;
  size_t v9;
  int v10;
  uint64_t v11;
  _QWORD *v12;
  int64_t v13;
  unsigned int v14;
  unsigned int *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int8x16_t v22;
  unsigned int *v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  unint64_t v28;
  uint64_t v29;
  unsigned int *v30;
  unint64_t v31;
  unsigned int v32;
  unint64_t v33;
  char v34;
  uint64_t v35;
  unint64_t v36;
  unsigned int *v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  BOOL v41;
  char *v42;
  char *v44;
  const void *v45;
  void *v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  _QWORD v50[15];

  v50[14] = *MEMORY[0x1E0C80C00];
  v46 = &v48;
  v47 = 0x200000000;
  v9 = 8 * a2;
  v48 = v50;
  v49 = 0x600000000;
  if ((unint64_t)(8 * a2) < 0x31)
  {
    v10 = 0;
    if (!a2)
      goto LABEL_6;
    goto LABEL_5;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v50, (8 * a2) >> 3, 8);
  v10 = v49;
  if (a2)
  {
LABEL_5:
    memcpy(&v48[v10], a1, v9);
    v10 = v49;
  }
LABEL_6:
  v11 = (v47 + 1);
  LODWORD(v49) = v10 + (v9 >> 3);
  LODWORD(v47) = v11;
  v44 = &a3[8 * a4];
  v45 = a3;
  if (v11 < HIDWORD(v47))
  {
    v12 = (char *)v46 + 64 * v11;
    *v12 = v12 + 2;
    v12[1] = 0x600000000;
    v13 = 8 * a4;
    if ((unint64_t)(8 * a4) < 0x31)
    {
      v14 = 0;
      if (!a4)
        goto LABEL_12;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v12, v12 + 2, v13 >> 3, 8);
      v14 = *((_DWORD *)v12 + 2);
      if (!a4)
      {
LABEL_12:
        *((_DWORD *)v12 + 2) = v14 + a4;
        LODWORD(v47) = v47 + 1;
        v15 = (unsigned int *)v46;
        v16 = v47;
        v17 = *((unsigned int *)v46 + 2);
        v18 = (unint64_t)v47 << 6;
        if ((_DWORD)v47 == 1)
          goto LABEL_13;
LABEL_16:
        v20 = v16 - 1;
        if ((unint64_t)(v16 - 1) >= 4)
        {
          v21 = v20 & 0xFFFFFFFFFFFFFFFCLL | 1;
          v22 = (int8x16_t)vdupq_n_s64(v17);
          v23 = v15 + 66;
          v4 = v20 & 0xFFFFFFFFFFFFFFFCLL;
          v24 = v22;
          do
          {
            v25.i64[0] = *(v23 - 48);
            v25.i64[1] = *(v23 - 32);
            v26 = v25;
            v25.i64[0] = *(v23 - 16);
            v25.i64[1] = *v23;
            v22 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v22, (uint64x2_t)v26), v22, v26);
            v24 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v24, (uint64x2_t)v25), v24, v25);
            v23 += 64;
            v4 -= 4;
          }
          while (v4);
          v27 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v22, (uint64x2_t)v24), v22, v24);
          v28 = vextq_s8(v27, v27, 8uLL).u64[0];
          v17 = (unint64_t)vbsl_s8((int8x8_t)vcgtd_u64(v27.u64[0], v28), *(int8x8_t *)v27.i8, (int8x8_t)v28);
          if (v20 == (v20 & 0xFFFFFFFFFFFFFFFCLL))
            goto LABEL_25;
        }
        else
        {
          v21 = 1;
        }
        v29 = v16 - v21;
        v30 = &v15[16 * v21 + 2];
        do
        {
          v32 = *v30;
          v30 += 16;
          v31 = v32;
          if (v17 <= v32)
            v17 = v31;
          --v29;
        }
        while (v29);
LABEL_25:
        if (!v17)
        {
LABEL_43:
          v19 = 1;
          if ((_DWORD)v16)
            goto LABEL_46;
          goto LABEL_49;
        }
        if (!(_DWORD)v16)
        {
          v19 = 1;
          if (v15 != (unsigned int *)&v48)
            goto LABEL_50;
          return v19;
        }
        goto LABEL_27;
      }
    }
    memcpy((void *)(*v12 + 8 * v14), a3, v13);
    v14 = *((_DWORD *)v12 + 2);
    goto LABEL_12;
  }
  llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,6u>,false>::growAndEmplaceBack<long long const*,long long const*>((uint64_t)&v46, &v45, (const void **)&v44);
  v15 = (unsigned int *)v46;
  v16 = v47;
  v17 = *((unsigned int *)v46 + 2);
  v18 = (unint64_t)v47 << 6;
  if ((_DWORD)v47 != 1)
    goto LABEL_16;
LABEL_13:
  if (!(_DWORD)v17)
  {
    v19 = 1;
    goto LABEL_46;
  }
LABEL_27:
  v33 = 0;
LABEL_29:
  v34 = 0;
  v35 = 0;
  v4 &= 0xFFFFFFFFFFFFFF00;
  v36 = v18;
  v37 = v15 + 2;
  while (1)
  {
    v39 = *v37;
    if (v33 >= v39 || (v40 = *(_QWORD *)(*((_QWORD *)v37 - 1) + 8 * (v39 + ~v33)), v40 == 1))
    {
      v38 = v35;
      goto LABEL_31;
    }
    if (v40 == 0x8000000000000000)
    {
      if (v34 & 1 | ((_DWORD)v35 != 0))
        break;
      v38 = 1;
      v4 = 0x8000000000000000;
      v34 = 1;
      goto LABEL_31;
    }
    v38 = 1;
    if (!(_DWORD)v35)
    {
      v4 = v40;
      goto LABEL_31;
    }
    v41 = v40 == v4;
    v4 = v40;
    if (!v41)
      break;
LABEL_31:
    v37 += 16;
    v35 = v38;
    v36 -= 64;
    if (!v36)
    {
      if (++v33 == v17)
        goto LABEL_43;
      goto LABEL_29;
    }
  }
  v19 = 0;
  if (!(_DWORD)v16)
    goto LABEL_49;
  do
  {
LABEL_46:
    v42 = *(char **)((char *)v15 + v18 - 64);
    if ((char *)v15 + v18 - 48 != v42)
      free(v42);
    v18 -= 64;
  }
  while (v18);
  v15 = (unsigned int *)v46;
LABEL_49:
  if (v15 != (unsigned int *)&v48)
LABEL_50:
    free(v15);
  return v19;
}

uint64_t mlir::OpTrait::util::getBroadcastedShape(uint64_t *a1, unint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  unsigned int v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t result;
  uint64_t v18;
  unint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  BOOL v24;
  uint64_t v25;

  *(_DWORD *)(a5 + 8) = 0;
  if (a2 <= a4)
  {
    if (!a4)
      return 1;
    v10 = 0;
    v14 = 8 * a4;
    v15 = a3;
    do
    {
      v16 = *v15;
      if (v10 >= *(_DWORD *)(a5 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v10 + 1, 8);
        v10 = *(_DWORD *)(a5 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a5 + 8 * v10) = v16;
      v10 = *(_DWORD *)(a5 + 8) + 1;
      *(_DWORD *)(a5 + 8) = v10;
      ++v15;
      v14 -= 8;
    }
    while (v14);
  }
  else
  {
    v10 = 0;
    v11 = 8 * a2;
    v12 = a1;
    do
    {
      v13 = *v12;
      if (v10 >= *(_DWORD *)(a5 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v10 + 1, 8);
        v10 = *(_DWORD *)(a5 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a5 + 8 * v10) = v13;
      v10 = *(_DWORD *)(a5 + 8) + 1;
      *(_DWORD *)(a5 + 8) = v10;
      ++v12;
      v11 -= 8;
    }
    while (v11);
  }
  result = 1;
  if (a2 && a4)
  {
    v18 = 8 * a2 - 8;
    v19 = (unint64_t *)(*(_QWORD *)a5 + 8 * v10 - 8);
    v20 = 8 * a4 - 8;
    while (1)
    {
      v21 = *(uint64_t *)((char *)a1 + v18);
      v22 = *(uint64_t *)((char *)a3 + v20);
      if (v21 == 0x8000000000000000)
        break;
      if (v22 == 0x8000000000000000)
      {
        v23 = *(uint64_t *)((char *)a1 + v18);
        if (v21 > 1)
          goto LABEL_27;
        goto LABEL_21;
      }
      v24 = v21 == v22 || v22 == 1;
      v23 = *(uint64_t *)((char *)a1 + v18);
      if (!v24)
      {
        v23 = *(uint64_t *)((char *)a3 + v20);
        if (v21 != 1)
        {
          result = 0;
          *(_DWORD *)(a5 + 8) = 0;
          return result;
        }
      }
LABEL_27:
      *v19-- = v23;
      if (v18)
      {
        v18 -= 8;
        v25 = v20;
        v20 -= 8;
        if (v25)
          continue;
      }
      return result;
    }
    v23 = *(uint64_t *)((char *)a3 + v20);
    if (v22 > 1)
      goto LABEL_27;
    v23 = *(uint64_t *)((char *)a1 + v18);
    if (v22 == 1)
      goto LABEL_27;
LABEL_21:
    v23 = 0x8000000000000000;
    goto LABEL_27;
  }
  return result;
}

uint64_t mlir::OpTrait::util::getBroadcastedType(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t ElementTypeOrSelf;
  unint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;
  _BOOL4 v10;
  uint64_t v12;
  uint64_t v14;
  uint64_t *ArgAttrsAttr;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  unint64_t v20;
  void *v21;
  _QWORD *v23;
  uint64_t v24;
  void *v25;
  size_t v26;
  _QWORD v27[5];

  ElementTypeOrSelf = a3;
  v5 = (unint64_t)a1;
  v27[4] = *MEMORY[0x1E0C80C00];
  if (!a3)
  {
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
    if (ElementTypeOrSelf != mlir::getElementTypeOrSelf(a2))
      return 0;
  }
  v6 = *(_QWORD *)v5;
  v7 = *(void **)(*(_QWORD *)v5 + 136);
  v8 = *(void **)(*a2 + 136);
  if (v7 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    if (v8 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
      return 0;
    return mlir::UnrankedTensorType::get(ElementTypeOrSelf);
  }
  if (v8 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    if (v7 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
      return 0;
    return mlir::UnrankedTensorType::get(ElementTypeOrSelf);
  }
  v10 = v8 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id
     || v8 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id;
  if (v7 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id
    || v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v12 = 0;
    if (!v10)
      v8 = 0;
    if (v7 != v8 && v10)
      return v12;
    v10 = 1;
  }
  else if (v10)
  {
    v7 = *(void **)(*a2 + 136);
  }
  else
  {
    v7 = 0;
  }
  v25 = v27;
  v26 = 0x400000000;
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v6 + 8))
  {
    v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v5 + 8);
    v23 = (_QWORD *)v5;
    v24 = v14;
    if (v5)
    {
      ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v23);
      v5 = v16;
      v17 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a2 + 8);
      if (v17)
        goto LABEL_34;
LABEL_42:
      v23 = 0;
      v24 = v17;
      goto LABEL_43;
    }
  }
  else
  {
    v5 = 0;
    v23 = 0;
    v24 = 0;
  }
  ArgAttrsAttr = 0;
  v17 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a2 + 8);
  if (!v17)
    goto LABEL_42;
LABEL_34:
  v18 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a2 + 8);
  v23 = a2;
  v24 = v18;
  if (a2)
  {
    v19 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v23);
    if (mlir::OpTrait::util::getBroadcastedShape(ArgAttrsAttr, v5, v19, v20, (uint64_t)&v25))
      goto LABEL_36;
LABEL_44:
    v12 = 0;
    v21 = v25;
    if (v25 == v27)
      return v12;
    goto LABEL_51;
  }
LABEL_43:
  if (!mlir::OpTrait::util::getBroadcastedShape(ArgAttrsAttr, v5, 0, 0, (uint64_t)&v25))
    goto LABEL_44;
LABEL_36:
  if (v10 && v7 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
  {
    v12 = mlir::VectorType::get((uint64_t)v25, v26, ElementTypeOrSelf, 0, 0);
    v21 = v25;
    if (v25 == v27)
      return v12;
    goto LABEL_51;
  }
  if (v10 && v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v12 = mlir::RankedTensorType::get((uint64_t)v25, v26, ElementTypeOrSelf, 0);
    v21 = v25;
    if (v25 == v27)
      return v12;
    goto LABEL_51;
  }
  v12 = ElementTypeOrSelf;
  v21 = v25;
  if (v25 != v27)
LABEL_51:
    free(v21);
  return v12;
}

uint64_t mlir::OpTrait::impl::verifyCompatibleOperandBroadcast(mlir::OpTrait::impl *this, mlir::Operation *a2)
{
  uint64_t v3;
  uint64_t v4;
  _BOOL4 v5;
  _BOOL4 v6;
  void *v7;
  BOOL v9;
  uint64_t *v10;
  uint64_t v11;
  void *v12;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  BOOL v30;
  void *v31;
  BOOL v33;
  uint64_t v34;
  void *v35;
  uint64_t v37;
  void *v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  BOOL v43;
  _BOOL4 v44;
  void *v45;
  uint64_t v46;
  uint64_t NextResultAtOffset;
  uint64_t v48;
  uint64_t v49;
  BOOL v50;
  uint64_t v51;
  _QWORD **v52;
  _QWORD **v53;
  void *v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  BOOL v65;
  _QWORD *v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  uint64_t v71;
  uint64_t *ArgAttrsAttr;
  unint64_t v73;
  char *v74;
  char *v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t *v81;
  _QWORD *v82;
  uint64_t v83;
  _QWORD *v84;
  uint64_t v85;
  uint64_t *v86;
  unint64_t v87;
  char BroadcastedShape;
  _QWORD **v89;
  _QWORD **v90;
  void *v91;
  _QWORD *v92;
  _QWORD *v93;
  void *v94;
  void *v95;
  void *v96;
  const char *v97;
  char *v98;
  uint64_t v99;
  char *v100;
  char *v101;
  BOOL v102;
  uint64_t v103;
  _QWORD *v104;
  char *v105;
  BOOL v106;
  BOOL v107;
  char *v108;
  _QWORD *v109;
  uint64_t v110;
  _QWORD *v111;
  unint64_t v112;
  uint64_t v113;
  _QWORD *v114;
  uint64_t v115;
  uint64_t v116;
  void *v118;
  void **p_dst;
  char *v121;
  char *v122;
  __int128 v123;
  uint64_t v124;
  unint64_t *v125;
  uint64_t v126;
  uint64_t v127;
  void **v128;
  char *v129;
  char *v130;
  __int128 v131;
  unsigned int v132;
  _QWORD **v133;
  _QWORD **v134;
  void *v135;
  _QWORD *v136;
  _QWORD *v137;
  void *v138;
  void *v139;
  void *v140;
  unint64_t v141;
  unint64_t v142;
  int64_t v143;
  int64_t v144;
  unsigned int v145;
  std::string v146;
  std::string v147;
  const void **v148[4];
  __int16 v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  void *__dst;
  uint64_t v159;
  _QWORD v160[2];
  __int16 v161;
  void *__src;
  uint64_t v163;
  _WORD v164[16];
  _QWORD *v165;
  uint64_t v166;
  _QWORD *v167;
  void *v168;
  unsigned int v169;
  unsigned int v170;
  _BYTE v171[96];
  void *v172;
  _QWORD *v173;
  void *__p;
  _QWORD **v175;
  char v176;
  uint64_t v177;

  v177 = *MEMORY[0x1E0C80C00];
  if ((*((_BYTE *)this + 46) & 0x80) != 0)
  {
    v3 = *((_QWORD *)this + 9);
    v4 = *((unsigned int *)this + 17);
  }
  else
  {
    v3 = 0;
    v4 = 0;
  }
  v165 = (_QWORD *)v3;
  v166 = v4;
  mlir::OperandRange::getTypes((uint64_t *)&v165, &v154);
  if (v154 == v156 && v157 == v155)
  {
    v5 = 0;
    v6 = 1;
    goto LABEL_42;
  }
  v7 = *(void **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v154 + 32 * v155 + 24) + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
  v9 = v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v7 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
  if (v154 == v156)
  {
    if (v9)
    {
      v5 = 1;
      goto LABEL_37;
    }
    v14 = (uint64_t *)(v154 + 32 * v155 + 56);
    v15 = v157 - v155;
    while (1)
    {
      v5 = --v15 != 0;
      if (!v15)
        break;
      v16 = *v14;
      v14 += 4;
      v17 = *(void **)(*(_QWORD *)(*(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
      if (v17 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
        || v17 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
      {
        goto LABEL_31;
      }
    }
  }
  else
  {
    if (v9)
    {
      v5 = 1;
      goto LABEL_33;
    }
    v10 = (uint64_t *)(v154 + 32 * v155 + 56);
    do
    {
      v11 = *v10;
      v10 += 4;
      v12 = *(void **)(*(_QWORD *)(*(_QWORD *)(v11 + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
    }
    while (v12 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
         && v12 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id);
LABEL_31:
    v5 = 1;
  }
  if (v154 != v156)
  {
LABEL_33:
    if (v7 != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
    {
      v19 = (uint64_t *)(v154 + 32 * v155 + 56);
      do
      {
        v20 = *v19;
        v19 += 4;
      }
      while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id);
    }
    goto LABEL_41;
  }
LABEL_37:
  if (v7 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
  {
LABEL_41:
    v6 = 0;
    goto LABEL_42;
  }
  v21 = (uint64_t *)(v154 + 32 * v155 + 56);
  v22 = v157 - v155;
  while (1)
  {
    v6 = --v22 == 0;
    if (!v22)
      break;
    v23 = *v21;
    v21 += 4;
    if (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v23 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
      goto LABEL_41;
  }
LABEL_42:
  v24 = *((unsigned int *)this + 9);
  v25 = (char *)this - 16;
  if (!(_DWORD)v24)
    v25 = 0;
  v165 = v25;
  v166 = v24;
  mlir::OperandRange::getTypes((uint64_t *)&v165, &v150);
  v26 = v150;
  v27 = v151;
  v28 = v153;
  v29 = v150 != v152;
  if (v150 == v152 && v151 == v153)
  {
    v30 = 1;
    goto LABEL_71;
  }
  v31 = *(void **)(*(_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v150, v151) + 8) & 0xFFFFFFFFFFFFFFF8)
                 + 136);
  v33 = v31 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
     || v31 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
  if (v29)
  {
    if (!v33)
    {
      v34 = v27 + 1;
      do
        v35 = *(void **)(*(_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v26, v34++) + 8) & 0xFFFFFFFFFFFFFFF8)
                       + 136);
      while (v35 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
           && v35 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id);
    }
    goto LABEL_70;
  }
  if (v33)
  {
LABEL_70:
    v30 = 0;
    goto LABEL_71;
  }
  v37 = v27 + 1;
  while (1)
  {
    v30 = v28 == v37;
    if (v28 == v37)
      break;
    v38 = *(void **)(*(_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v26, v37++) + 8) & 0xFFFFFFFFFFFFFFF8)
                   + 136);
    if (v38 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      || v38 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_70;
    }
  }
LABEL_71:
  v40 = v150;
  v41 = v151;
  v42 = v153;
  v43 = v150 != v152;
  if (v150 == v152 && v151 == v153)
  {
    v44 = 1;
    goto LABEL_84;
  }
  v45 = *(void **)(*(_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v150, v151) + 8) & 0xFFFFFFFFFFFFFFF8)
                 + 136);
  if (v43)
  {
    if (v45 != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
    {
      v46 = v41 + 1;
      do
        NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v40, v46++);
      while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id);
    }
    goto LABEL_83;
  }
  if (v45 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
  {
LABEL_83:
    v44 = 0;
    goto LABEL_84;
  }
  v48 = v41 + 1;
  while (1)
  {
    v44 = v42 == v48;
    if (v42 == v48)
      break;
    v49 = mlir::detail::OpResultImpl::getNextResultAtOffset(v40, v48++);
    if (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v49 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
      goto LABEL_83;
  }
LABEL_84:
  v50 = !v5 && v30;
  if (v50 || v6 && v44)
  {
    if ((*((_BYTE *)this + 46) & 0x80) != 0)
    {
      v60 = (void *)*((_QWORD *)this + 9);
      v61 = *((unsigned int *)this + 17);
    }
    else
    {
      v60 = 0;
      v61 = 0;
    }
    __src = v60;
    v163 = v61;
    mlir::OperandRange::getTypes((uint64_t *)&__src, (uint64_t *)&v165);
    v63 = (uint64_t)v165;
    v62 = v166;
    v64 = (char *)v168;
    v65 = v165 != v167;
    if (v165 != v167 || (void *)v166 != v168)
    {
      if (v165 == v167)
      {
        v69 = (uint64_t)&v165[4 * v166 + 3];
        while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v69 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
        {
          ++v62;
          v69 += 32;
          if (v168 == (void *)v62)
          {
            v62 = (uint64_t)v168;
            break;
          }
        }
      }
      else
      {
        v66 = &v165[4 * v166];
        if (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v66[3] + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
        {
          v67 = v66 + 7;
          do
          {
            v68 = *v67;
            v67 += 4;
            ++v62;
          }
          while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v68 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id);
        }
      }
    }
    if (v165 == v167 && (void *)v62 == v168)
      return 1;
    __src = v164;
    v163 = 0x400000000;
    v70 = (_QWORD *)(*(_QWORD *)(v165[4 * v62 + 3] + 8) & 0xFFFFFFFFFFFFFFF8);
    if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v70 + 8))
    {
      v71 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v70 + 8);
      v165 = v70;
      v166 = v71;
      if (v70)
      {
        ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v165);
LABEL_128:
        mlir::OpTrait::util::getBroadcastedShape(ArgAttrsAttr, v73, 0, 0, (uint64_t)&__src);
        while (1)
        {
          if (!v65 && v62 == (_QWORD)v64)
          {
            v97 = (const char *)*((unsigned int *)this + 9);
            v98 = (char *)this - 16;
            if (!(_DWORD)v97)
              v98 = 0;
            __dst = v98;
            v159 = (uint64_t)v97;
            mlir::OperandRange::getTypes((uint64_t *)&__dst, (uint64_t *)&v165);
            v99 = (uint64_t)v165;
            v100 = (char *)v166;
            v101 = (char *)v168;
            v102 = v165 != v167;
            if (v165 != v167 || (void *)v166 != v168)
            {
              if (v165 == v167)
              {
                do
                {
                  if (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v99, (uint64_t)v100)+ 8) & 0xFFFFFFFFFFFFFFF8)+ 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)goto LABEL_184;
                  ++v100;
                }
                while (v101 != v100);
                v100 = v101;
              }
              else
              {
                do
                  v103 = mlir::detail::OpResultImpl::getNextResultAtOffset(v99, (uint64_t)v100++);
                while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v103 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id);
                --v100;
              }
            }
LABEL_184:
            v104 = v167;
            v105 = (char *)v168;
            v106 = (_QWORD *)v99 == v167 && v100 == v168;
            if (v106 || ((_QWORD *)v99 == v167 ? (v107 = v100 == v168) : (v107 = 0), v107))
            {
              v145 = 1;
LABEL_220:
              v118 = __src;
              if (__src == v164)
                return v145;
              goto LABEL_221;
            }
            while (2)
            {
              v108 = v100;
              v109 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v99, (uint64_t)v100) + 8) & 0xFFFFFFFFFFFFFFF8);
              if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v109 + 8))
              {
                v110 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v109 + 8);
                v165 = v109;
                v166 = v110;
                if (v109)
                {
                  v111 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v165);
                  v113 = v163;
                  if (v112 > v163)
                  {
                    v111 += v112 - v163;
LABEL_199:
                    if (v113)
                    {
                      v114 = __src;
                      v115 = 8 * v113 - 8;
                      while (1)
                      {
                        v116 = v115;
                        if (*v111 != 0x8000000000000000 && *v114 != 0x8000000000000000 && *v114 != *v111)
                          break;
                        ++v114;
                        ++v111;
                        v115 -= 8;
                        if (!v116)
                          goto LABEL_208;
                      }
LABEL_224:
                      v149 = 257;
                      mlir::Operation::emitOpError((uint64_t *)this, v148, (uint64_t)&v165);
                      if (v165)
                      {
                        LODWORD(__dst) = 3;
                        v159 = (uint64_t)"result type ";
                        v160[0] = 12;
                        p_dst = &__dst;
                        v121 = (char *)v168;
                        if (v169 >= v170)
                        {
                          v141 = v169 + 1;
                          if (v168 <= &__dst && (char *)v168 + 24 * v169 > (char *)&__dst)
                          {
                            v143 = (char *)&__dst - (_BYTE *)v168;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v168, v171, v141, 24);
                            v121 = (char *)v168;
                            p_dst = (void **)((char *)v168 + v143);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v168, v171, v141, 24);
                            p_dst = &__dst;
                            v121 = (char *)v168;
                          }
                        }
                        v122 = &v121[24 * v169];
                        v123 = *(_OWORD *)p_dst;
                        *((_QWORD *)v122 + 2) = p_dst[2];
                        *(_OWORD *)v122 = v123;
                        ++v169;
                      }
                      v124 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v109 + 8);
                      if (v124)
                        v124 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v109 + 8);
                      else
                        v109 = 0;
                      __dst = v109;
                      v159 = v124;
                      if (v109)
                      {
                        v125 = (unint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__dst);
                        v127 = v126;
                      }
                      else
                      {
                        v127 = 0;
                        v125 = 0;
                      }
                      getShapeString(&v147, v125, v127);
                      if (v165)
                      {
                        v161 = 260;
                        __dst = &v147;
                        mlir::Diagnostic::operator<<((uint64_t)&v166, (const void ***)&__dst);
                        if (v165)
                        {
                          LODWORD(__dst) = 3;
                          v159 = (uint64_t)" not broadcast compatible with broadcasted operands's shapes ";
                          v160[0] = 61;
                          v128 = &__dst;
                          v129 = (char *)v168;
                          if (v169 >= v170)
                          {
                            v142 = v169 + 1;
                            if (v168 <= &__dst && (char *)v168 + 24 * v169 > (char *)&__dst)
                            {
                              v144 = (char *)&__dst - (_BYTE *)v168;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v168, v171, v142, 24);
                              v129 = (char *)v168;
                              v128 = (void **)((char *)v168 + v144);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v168, v171, v142, 24);
                              v128 = &__dst;
                              v129 = (char *)v168;
                            }
                          }
                          v130 = &v129[24 * v169];
                          v131 = *(_OWORD *)v128;
                          *((_QWORD *)v130 + 2) = v128[2];
                          *(_OWORD *)v130 = v131;
                          ++v169;
                        }
                      }
                      getShapeString(&v146, (unint64_t *)__src, v163);
                      if (v165)
                      {
                        v161 = 260;
                        __dst = &v146;
                        mlir::Diagnostic::operator<<((uint64_t)&v166, (const void ***)&__dst);
                      }
                      v132 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v165);
                      if ((SHIBYTE(v146.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                      {
                        if ((SHIBYTE(v147.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                          goto LABEL_241;
LABEL_256:
                        operator delete(v147.__r_.__value_.__l.__data_);
                        if (!v165)
                          goto LABEL_243;
LABEL_242:
                        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v165);
                        goto LABEL_243;
                      }
                      operator delete(v146.__r_.__value_.__l.__data_);
                      if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0)
                        goto LABEL_256;
LABEL_241:
                      if (v165)
                        goto LABEL_242;
LABEL_243:
                      if (v176)
                      {
                        v133 = (_QWORD **)__p;
                        if (__p)
                        {
                          v134 = v175;
                          v135 = __p;
                          if (v175 != __p)
                          {
                            do
                              v134 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v134 - 1);
                            while (v134 != v133);
                            v135 = __p;
                          }
                          v175 = v133;
                          operator delete(v135);
                        }
                        v136 = v172;
                        if (v172)
                        {
                          v137 = v173;
                          v138 = v172;
                          if (v173 != v172)
                          {
                            do
                            {
                              v140 = (void *)*--v137;
                              v139 = v140;
                              *v137 = 0;
                              if (v140)
                                operator delete[](v139);
                            }
                            while (v137 != v136);
                            v138 = v172;
                          }
                          v173 = v136;
                          operator delete(v138);
                        }
                        if (v168 != v171)
                          free(v168);
                      }
                      v145 = v132;
                      v118 = __src;
                      if (__src == v164)
                        return v145;
LABEL_221:
                      free(v118);
                      return v145;
                    }
LABEL_208:
                    v100 = v101;
                    if (v102 || v108 + 1 != v101)
                    {
                      v100 = v108 + 1;
                      if (v102)
                      {
                        v100 = v108;
                        do
                          ++v100;
                        while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v99, (uint64_t)v100)+ 8) & 0xFFFFFFFFFFFFFFF8)+ 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id);
                      }
                      else
                      {
                        while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v99, (uint64_t)v100)+ 8) & 0xFFFFFFFFFFFFFFF8)+ 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
                        {
                          if (v101 == ++v100)
                          {
                            v100 = v101;
                            break;
                          }
                        }
                      }
                    }
                    if ((_QWORD *)v99 == v104)
                    {
                      v145 = 1;
                      if (v100 == v105)
                        goto LABEL_220;
                    }
                    continue;
                  }
LABEL_198:
                  if (v113 != v112)
                    goto LABEL_224;
                  goto LABEL_199;
                }
              }
              else
              {
                v165 = 0;
                v166 = 0;
              }
              break;
            }
            v111 = 0;
            v112 = 0;
            v113 = v163;
            goto LABEL_198;
          }
          v74 = (char *)(v62 + 1);
          v75 = v64;
          if (v65 || v62 + 1 != (_QWORD)v64)
          {
            if (!v65)
            {
              v78 = v63 + 56 + 32 * v62;
              while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v78 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
              {
                ++v74;
                v78 += 32;
                if (v64 == v74)
                {
                  v75 = v64;
                  goto LABEL_142;
                }
              }
LABEL_141:
              v75 = v74;
              goto LABEL_142;
            }
            if (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v63 + 32 * (_QWORD)v74 + 24) + 8) & 0xFFFFFFFFFFFFFFF8)
                              + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
              goto LABEL_141;
            v76 = (uint64_t *)(v63 + 88 + 32 * v62);
            v75 = (char *)(v62 + 1);
            do
            {
              v77 = *v76;
              v76 += 4;
              ++v75;
            }
            while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v77 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id);
          }
LABEL_142:
          v79 = *(_QWORD *)(*(_QWORD *)(v63 + 32 * v62 + 24) + 8);
          __dst = v160;
          v159 = 0x400000000;
          v80 = v163;
          v81 = v160;
          if (!(_DWORD)v163)
            goto LABEL_148;
          v82 = v160;
          v83 = v163;
          if (v163 < 5uLL)
            goto LABEL_146;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v160, v163, 8);
          v83 = v163;
          if ((_DWORD)v163)
          {
            v82 = __dst;
LABEL_146:
            memcpy(v82, __src, 8 * v83);
          }
          LODWORD(v159) = v80;
          v81 = (uint64_t *)__dst;
LABEL_148:
          v84 = (_QWORD *)(v79 & 0xFFFFFFFFFFFFFFF8);
          if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v84 + 8))
          {
            v85 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v84 + 8);
            v165 = v84;
            v166 = v85;
            if (v84)
            {
              v86 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v165);
              BroadcastedShape = mlir::OpTrait::util::getBroadcastedShape(v81, v80, v86, v87, (uint64_t)&__src);
              if ((BroadcastedShape & 1) == 0)
                goto LABEL_154;
              goto LABEL_172;
            }
          }
          else
          {
            v165 = 0;
            v166 = 0;
          }
          BroadcastedShape = mlir::OpTrait::util::getBroadcastedShape(v81, v80, 0, 0, (uint64_t)&__src);
          if ((BroadcastedShape & 1) == 0)
          {
LABEL_154:
            v148[0] = (const void **)"operands don't have broadcast-compatible shapes";
            v149 = 259;
            mlir::Operation::emitOpError((uint64_t *)this, v148, (uint64_t)&v165);
            v145 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v165);
            if (v165)
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v165);
            if (v176)
            {
              v89 = (_QWORD **)__p;
              if (__p)
              {
                v90 = v175;
                v91 = __p;
                if (v175 != __p)
                {
                  do
                    v90 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v90 - 1);
                  while (v90 != v89);
                  v91 = __p;
                }
                v175 = v89;
                operator delete(v91);
              }
              v92 = v172;
              if (v172)
              {
                v93 = v173;
                v94 = v172;
                if (v173 != v172)
                {
                  do
                  {
                    v96 = (void *)*--v93;
                    v95 = v96;
                    *v93 = 0;
                    if (v96)
                      operator delete[](v95);
                  }
                  while (v93 != v92);
                  v94 = v172;
                }
                v173 = v92;
                operator delete(v94);
              }
              if (v168 != v171)
                free(v168);
            }
          }
LABEL_172:
          if (__dst != v160)
            free(__dst);
          v62 = (uint64_t)v75;
          if ((BroadcastedShape & 1) == 0)
            goto LABEL_220;
        }
      }
    }
    else
    {
      v165 = 0;
      v166 = 0;
    }
    v73 = 0;
    ArgAttrsAttr = 0;
    goto LABEL_128;
  }
  __src = "cannot broadcast vector with tensor";
  v164[8] = 259;
  mlir::Operation::emitError((uint64_t *)this, (uint64_t)&__src, (uint64_t)&v165);
  v51 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v165);
  if (v165)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v165);
  if (v176)
  {
    v52 = (_QWORD **)__p;
    if (__p)
    {
      v53 = v175;
      v54 = __p;
      if (v175 != __p)
      {
        do
          v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
        while (v53 != v52);
        v54 = __p;
      }
      v175 = v52;
      operator delete(v54);
    }
    v55 = v172;
    if (v172)
    {
      v56 = v173;
      v57 = v172;
      if (v173 != v172)
      {
        do
        {
          v59 = (void *)*--v56;
          v58 = v59;
          *v56 = 0;
          if (v59)
            operator delete[](v58);
        }
        while (v56 != v55);
        v57 = v172;
      }
      v173 = v55;
      operator delete(v57);
    }
    if (v168 != v171)
      free(v168);
  }
  return v51;
}

void getShapeString(std::string *a1, unint64_t *a2, uint64_t a3)
{
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  void **v9;
  __int128 v10;
  unint64_t *v11;
  uint64_t i;
  unint64_t v13;
  _BYTE *v14;
  void *v15;
  int v16;
  uint64_t v17;
  _BYTE *v18;
  _BYTE *v19;
  char v20;
  uint64_t v21;
  int v22;
  void **v23;
  void *__p[2];
  uint64_t v25;

  __p[0] = 0;
  __p[1] = 0;
  v25 = 0;
  v16 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 1;
  v18 = 0;
  v19 = 0;
  v17 = 0;
  v15 = &unk_1E0E22B10;
  v23 = __p;
  llvm::raw_ostream::SetBufferAndMode((uint64_t)&v15, 0, 0, 0);
  v6 = v19;
  if (v19 >= v18)
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v15, 39);
    if (!a3)
      goto LABEL_12;
    goto LABEL_5;
  }
  ++v19;
  *v6 = 39;
  if (a3)
  {
LABEL_5:
    if (*a2 == 0x8000000000000000)
    {
      v7 = v19;
      if (v19 >= v18)
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v15, 63);
        if (a3 == 1)
          goto LABEL_12;
      }
      else
      {
        ++v19;
        *v7 = 63;
        if (a3 == 1)
          goto LABEL_12;
      }
    }
    else
    {
      llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v15, *a2);
      if (a3 == 1)
        goto LABEL_12;
    }
    v11 = a2 + 1;
    for (i = 8 * a3 - 8; i; i -= 8)
    {
      if (v18 == v19)
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v15, "x", 1uLL);
        v13 = *v11;
        if (*v11 == 0x8000000000000000)
        {
LABEL_27:
          v14 = v19;
          if (v19 >= v18)
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v15, 63);
          }
          else
          {
            ++v19;
            *v14 = 63;
          }
          goto LABEL_22;
        }
      }
      else
      {
        *v19++ = 120;
        v13 = *v11;
        if (*v11 == 0x8000000000000000)
          goto LABEL_27;
      }
      llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v15, v13);
LABEL_22:
      ++v11;
    }
  }
LABEL_12:
  v8 = v19;
  if (v19 >= v18)
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v15, 39);
    v9 = v23;
    if ((*((char *)v23 + 23) & 0x80000000) == 0)
    {
LABEL_14:
      v10 = *(_OWORD *)v9;
      a1->__r_.__value_.__r.__words[2] = (std::string::size_type)v9[2];
      *(_OWORD *)&a1->__r_.__value_.__l.__data_ = v10;
      llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v15);
      if ((SHIBYTE(v25) & 0x80000000) == 0)
        return;
      goto LABEL_15;
    }
  }
  else
  {
    ++v19;
    *v8 = 39;
    v9 = v23;
    if ((*((char *)v23 + 23) & 0x80000000) == 0)
      goto LABEL_14;
  }
  std::string::__init_copy_ctor_external(a1, (const std::string::value_type *)*v9, (std::string::size_type)v9[1]);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v15);
  if (SHIBYTE(v25) < 0)
LABEL_15:
    operator delete(__p[0]);
}

uint64_t llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,6u>,false>::growAndEmplaceBack<long long const*,long long const*>(uint64_t a1, const void **a2, const void **a3)
{
  _DWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _BYTE *v9;
  _BYTE *v10;
  uint64_t v11;
  unsigned int v12;
  _DWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int v20;
  uint64_t v21;
  unint64_t v23;

  v23 = 0;
  v6 = (_DWORD *)(a1 + 16);
  v7 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 64, &v23);
  v8 = &v7[8 * (unint64_t)*(unsigned int *)(a1 + 8)];
  v9 = *a2;
  v10 = *a3;
  *v8 = v8 + 2;
  v8[1] = 0x600000000;
  v11 = v10 - v9;
  if ((unint64_t)(v10 - v9) < 0x31)
  {
    v12 = 0;
    if (v9 == v10)
      goto LABEL_6;
    goto LABEL_5;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v8, v8 + 2, v11 >> 3, 8);
  v12 = *((_DWORD *)v8 + 2);
  if (v9 != v10)
  {
LABEL_5:
    memcpy((void *)(*v8 + 8 * v12), v9, v10 - v9);
    v12 = *((_DWORD *)v8 + 2);
  }
LABEL_6:
  *((_DWORD *)v8 + 2) = v12 + ((unint64_t)v11 >> 3);
  v13 = *(_DWORD **)a1;
  v14 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v14)
  {
    v15 = v14 << 6;
    v16 = v7;
    do
    {
      *v16 = v16 + 2;
      v16[1] = 0x600000000;
      if (v13[2])
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v16, (uint64_t)v13);
      v16 += 8;
      v13 += 16;
      v15 -= 64;
    }
    while (v15);
    v13 = *(_DWORD **)a1;
    v17 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v17)
    {
      v18 = v17 << 6;
      do
      {
        v19 = *(char **)((char *)v13 + v18 - 64);
        if ((char *)v13 + v18 - 48 != v19)
          free(v19);
        v18 -= 64;
      }
      while (v18);
      v13 = *(_DWORD **)a1;
    }
  }
  v20 = v23;
  if (v13 != v6)
    free(v13);
  *(_QWORD *)a1 = v7;
  v21 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v21;
  *(_DWORD *)(a1 + 12) = v20;
  return (uint64_t)&v7[8 * v21 - 8];
}

void mlir::applyPermutationToVector<long long,6u>(uint64_t a1, uint64_t *a2)
{
  _QWORD *v4;
  unint64_t v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  _QWORD v17[7];

  v17[6] = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD **)a1;
  v5 = *(unsigned int *)(a1 + 8);
  v15 = v17;
  v16 = 0x600000000;
  if (v5 < 7)
  {
    v6 = 0;
    v7 = v17;
    if (!(_DWORD)v5)
      goto LABEL_6;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v15, v17, v5, 8);
    v6 = v16;
    v7 = v15;
  }
  v8 = v6;
  v9 = v5;
  do
  {
    v10 = *a2++;
    v7[v8++] = v4[v10];
    --v9;
  }
  while (v9);
LABEL_6:
  v11 = v6 + v5;
  LODWORD(v16) = v11;
  if (&v15 == (void **)a1)
    goto LABEL_22;
  if (v7 != v17)
  {
    if (*(_QWORD *)a1 != a1 + 16)
    {
      free(*(void **)a1);
      v7 = v15;
      LODWORD(v11) = v16;
    }
    *(_QWORD *)a1 = v7;
    v12 = HIDWORD(v16);
    *(_DWORD *)(a1 + 8) = v11;
    *(_DWORD *)(a1 + 12) = v12;
    v15 = v17;
    HIDWORD(v16) = 0;
    goto LABEL_21;
  }
  v13 = *(unsigned int *)(a1 + 8);
  if (v13 >= v11)
  {
    if ((_DWORD)v11)
      memmove(*(void **)a1, v17, 8 * v11);
    goto LABEL_20;
  }
  if (*(_DWORD *)(a1 + 12) < v11)
  {
    *(_DWORD *)(a1 + 8) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v11, 8);
    v13 = 0;
    v14 = v16;
    if (!(_DWORD)v16)
      goto LABEL_20;
    goto LABEL_19;
  }
  if (!(_DWORD)v13)
  {
    v13 = 0;
    v14 = v16;
    if (!(_DWORD)v16)
      goto LABEL_20;
    goto LABEL_19;
  }
  memmove(*(void **)a1, v17, 8 * v13);
  v14 = v16;
  if (v13 != v16)
LABEL_19:
    memcpy((void *)(*(_QWORD *)a1 + 8 * v13), (char *)v15 + 8 * v13, 8 * v14 - 8 * v13);
LABEL_20:
  *(_DWORD *)(a1 + 8) = v11;
LABEL_21:
  LODWORD(v16) = 0;
  v7 = v15;
LABEL_22:
  if (v7 != v17)
    free(v7);
}

_QWORD *llvm::DenseMapBase<llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::InsertIntoBucket<long long const&,llvm::detail::DenseSetEmpty&>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  uint64_t v11;
  int v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  BOOL v18;
  unsigned int v19;

  v6 = *(_DWORD *)a1;
  v7 = *(_DWORD *)a1 >> 1;
  if ((*(_DWORD *)a1 & 1) != 0)
    v8 = 4;
  else
    v8 = *(_DWORD *)(a1 + 16);
  if (4 * v7 + 4 >= 3 * v8)
  {
    v8 *= 2;
  }
  else if (v8 + ~v7 - *(_DWORD *)(a1 + 4) > v8 >> 3)
  {
    v9 = *(_DWORD *)a1 & 1;
    goto LABEL_7;
  }
  llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::grow(a1, v8);
  v11 = a1 + 8;
  v6 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 1) != 0)
  {
    v12 = 4;
  }
  else
  {
    v12 = *(_DWORD *)(a1 + 16);
    if (!v12)
    {
      v9 = 0;
      a2 = 0;
      goto LABEL_7;
    }
    v11 = *(_QWORD *)(a1 + 8);
  }
  v9 = *(_DWORD *)a1 & 1;
  v13 = v12 - 1;
  v14 = (37 * *a3) & (v12 - 1);
  a2 = (_QWORD *)(v11 + 8 * v14);
  v15 = *a2;
  if (*a3 != *a2)
  {
    v16 = 0;
    v17 = 1;
    while (v15 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if (v16)
        v18 = 0;
      else
        v18 = v15 == 0x8000000000000000;
      if (v18)
        v16 = a2;
      v19 = v14 + v17++;
      v14 = v19 & v13;
      a2 = (_QWORD *)(v11 + 8 * (v19 & v13));
      v15 = *a2;
      if (*a3 == *a2)
        goto LABEL_7;
    }
    if (v16)
      a2 = v16;
  }
LABEL_7:
  *(_DWORD *)a1 = (v6 & 0xFFFFFFFE | v9) + 2;
  if (*a2 != 0x7FFFFFFFFFFFFFFFLL)
    --*(_DWORD *)(a1 + 4);
  *a2 = *a3;
  return a2;
}

void llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::grow(uint64_t a1, unsigned int a2)
{
  unint64_t v3;
  unint64_t v4;
  int v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  _QWORD v16[4];

  v16[3] = *MEMORY[0x1E0C80C00];
  if (a2 >= 5)
  {
    v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40)
      a2 = v5 + 1;
    else
      a2 = 64;
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    v6 = *(uint64_t **)(a1 + 8);
    v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      v13 = a2;
      *(_QWORD *)(a1 + 8) = llvm::allocate_buffer(8 * a2, (std::align_val_t)8uLL);
      *(_QWORD *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    v14 = (char *)(8 * v7);
    llvm::DenseMapBase<llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::moveFromOldBuckets((_DWORD *)a1, v6, (uint64_t *)&v14[(_QWORD)v6]);
    llvm::deallocate_buffer((llvm *)v6, v14);
  }
  v8 = &v15;
  if ((unint64_t)(*(_QWORD *)(a1 + 8) - 0x7FFFFFFFFFFFFFFFLL) >= 2)
  {
    v15 = *(_QWORD *)(a1 + 8);
    v8 = v16;
    v9 = *(_QWORD *)(a1 + 16);
    if ((unint64_t)(v9 - 0x7FFFFFFFFFFFFFFFLL) < 2)
    {
LABEL_10:
      v10 = *(_QWORD *)(a1 + 24);
      if ((unint64_t)(v10 - 0x7FFFFFFFFFFFFFFFLL) < 2)
        goto LABEL_11;
      goto LABEL_19;
    }
  }
  else
  {
    v9 = *(_QWORD *)(a1 + 16);
    if ((unint64_t)(v9 - 0x7FFFFFFFFFFFFFFFLL) < 2)
      goto LABEL_10;
  }
  *v8++ = v9;
  v10 = *(_QWORD *)(a1 + 24);
  if ((unint64_t)(v10 - 0x7FFFFFFFFFFFFFFFLL) < 2)
  {
LABEL_11:
    v11 = *(_QWORD *)(a1 + 32);
    if ((unint64_t)(v11 - 0x7FFFFFFFFFFFFFFFLL) < 2)
      goto LABEL_12;
LABEL_20:
    *v8++ = v11;
    if (a2 < 5)
      goto LABEL_14;
    goto LABEL_13;
  }
LABEL_19:
  *v8++ = v10;
  v11 = *(_QWORD *)(a1 + 32);
  if ((unint64_t)(v11 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
    goto LABEL_20;
LABEL_12:
  if (a2 >= 5)
  {
LABEL_13:
    *(_DWORD *)a1 &= ~1u;
    v12 = a2;
    *(_QWORD *)(a1 + 8) = llvm::allocate_buffer(8 * a2, (std::align_val_t)8uLL);
    *(_QWORD *)(a1 + 16) = v12;
  }
LABEL_14:
  llvm::DenseMapBase<llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::moveFromOldBuckets((_DWORD *)a1, &v15, v8);
}

void llvm::DenseMapBase<llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::moveFromOldBuckets(_DWORD *a1, uint64_t *a2, uint64_t *a3)
{
  int v6;
  _DWORD *v7;
  uint64_t v8;
  void *v9;
  _DWORD *v10;
  int v11;
  int v12;
  unsigned int v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  int v18;
  BOOL v19;
  unsigned int v20;

  v6 = *a1;
  *(_QWORD *)a1 = *a1 & 1;
  v7 = a1 + 2;
  if ((v6 & 1) != 0)
  {
    v8 = 4;
    v9 = a1 + 2;
  }
  else
  {
    v8 = a1[4];
    if (!(_DWORD)v8)
      goto LABEL_6;
    v9 = (void *)*((_QWORD *)a1 + 1);
  }
  memset_pattern16(v9, &unk_1812362E0, 8 * v8);
LABEL_6:
  while (a2 != a3)
  {
    v16 = *a2;
    if ((unint64_t)(*a2 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
    {
      if ((*(_BYTE *)a1 & 1) != 0)
      {
        v11 = 4;
        v10 = v7;
      }
      else
      {
        v10 = (_DWORD *)*((_QWORD *)a1 + 1);
        v11 = a1[4];
      }
      v12 = v11 - 1;
      v13 = (v11 - 1) & (37 * v16);
      v14 = &v10[2 * v13];
      v15 = *v14;
      if (v16 != *v14)
      {
        v17 = 0;
        v18 = 1;
        while (v15 != 0x7FFFFFFFFFFFFFFFLL)
        {
          if (v17)
            v19 = 0;
          else
            v19 = v15 == 0x8000000000000000;
          if (v19)
            v17 = v14;
          v20 = v13 + v18++;
          v13 = v20 & v12;
          v14 = &v10[2 * (v20 & v12)];
          v15 = *v14;
          if (v16 == *v14)
            goto LABEL_10;
        }
        if (v17)
          v14 = v17;
      }
LABEL_10:
      *v14 = v16;
      *a1 += 2;
    }
    ++a2;
  }
}

void llvm::DenseMapBase<llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::try_emplace<llvm::detail::DenseSetEmpty&>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t *v14;
  int v15;
  BOOL v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t *v22;
  int v23;
  BOOL v24;
  unsigned int v25;

  v6 = *(_QWORD *)a1;
  v7 = *(_DWORD *)(a1 + 16);
  if (!v7)
    goto LABEL_23;
  v8 = v7 - 1;
  v9 = (37 * *a2) & (v7 - 1);
  v10 = (uint64_t *)(v6 + 8 * v9);
  v11 = *v10;
  if (*a2 == *v10)
  {
LABEL_3:
    v12 = 0;
    goto LABEL_10;
  }
  v14 = 0;
  v15 = 1;
  while (v11 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (v14)
      v16 = 0;
    else
      v16 = v11 == 0x8000000000000000;
    if (v16)
      v14 = v10;
    v17 = v9 + v15++;
    v9 = v17 & v8;
    v10 = (uint64_t *)(v6 + 8 * (v17 & v8));
    v11 = *v10;
    if (*a2 == *v10)
      goto LABEL_3;
  }
  if (v14)
    v10 = v14;
  v18 = *(_DWORD *)(a1 + 8);
  if (4 * v18 + 4 < 3 * v7)
  {
    if (v7 + ~v18 - *(_DWORD *)(a1 + 12) > v7 >> 3)
      goto LABEL_6;
  }
  else
  {
LABEL_23:
    v7 *= 2;
  }
  llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::grow(a1, v7);
  v6 = *(_QWORD *)a1;
  v7 = *(_DWORD *)(a1 + 16);
  v13 = *a2;
  v19 = v7 - 1;
  v20 = (37 * *a2) & (v7 - 1);
  v10 = (uint64_t *)(*(_QWORD *)a1 + 8 * v20);
  v21 = *v10;
  if (*a2 == *v10)
    goto LABEL_7;
  v22 = 0;
  v23 = 1;
  while (v21 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (v22)
      v24 = 0;
    else
      v24 = v21 == 0x8000000000000000;
    if (v24)
      v22 = v10;
    v25 = v20 + v23++;
    v20 = v25 & v19;
    v10 = (uint64_t *)(v6 + 8 * (v25 & v19));
    v21 = *v10;
    if (v13 == *v10)
      goto LABEL_7;
  }
  if (v22)
    v10 = v22;
LABEL_6:
  v13 = *v10;
LABEL_7:
  ++*(_DWORD *)(a1 + 8);
  if (v13 != 0x7FFFFFFFFFFFFFFFLL)
    --*(_DWORD *)(a1 + 12);
  *v10 = *a2;
  v12 = 1;
LABEL_10:
  *(_QWORD *)a3 = v10;
  *(_QWORD *)(a3 + 8) = v6 + 8 * v7;
  *(_BYTE *)(a3 + 16) = v12;
}

void llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  llvm *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  char *buffer;
  char *v10;
  uint64_t v11;
  int v12;
  int v13;
  llvm *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  char *v20;
  int v21;
  BOOL v22;
  unsigned int v23;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(llvm **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  buffer = (char *)llvm::allocate_buffer(8 * v8, (std::align_val_t)8uLL);
  v10 = buffer;
  *(_QWORD *)a1 = buffer;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v11 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v11)
      memset_pattern16(buffer, &unk_1812362E0, 8 * v11);
    if ((_DWORD)v3)
    {
      v12 = 0;
      v13 = v11 - 1;
      v14 = v4;
      do
      {
        v17 = *(_QWORD *)v14;
        if ((unint64_t)(*(_QWORD *)v14 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
        {
          v18 = (37 * v17) & v13;
          v16 = &v10[8 * v18];
          v19 = *(_QWORD *)v16;
          if (v17 != *(_QWORD *)v16)
          {
            v20 = 0;
            v21 = 1;
            while (v19 != 0x7FFFFFFFFFFFFFFFLL)
            {
              if (v20)
                v22 = 0;
              else
                v22 = v19 == 0x8000000000000000;
              if (v22)
                v20 = v16;
              v23 = v18 + v21++;
              v18 = v23 & v13;
              v16 = &v10[8 * (v23 & v13)];
              v19 = *(_QWORD *)v16;
              if (v17 == *(_QWORD *)v16)
                goto LABEL_14;
            }
            if (v20)
              v16 = v20;
          }
LABEL_14:
          *(_QWORD *)v16 = v17;
          *(_DWORD *)(a1 + 8) = ++v12;
        }
        v14 = (llvm *)((char *)v14 + 8);
      }
      while (v14 != (llvm *)((char *)v4 + 8 * v3));
    }
    llvm::deallocate_buffer(v4, (void *)(8 * v3));
  }
  *(_QWORD *)(a1 + 8) = 0;
  v15 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v15)
    memset_pattern16(buffer, &unk_1812362E0, 8 * v15);
}

void mlir::getReassociationIndicesForCollapse(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void **v20;
  int v21;
  uint64_t v22;
  void *v23;
  unint64_t v24;
  unsigned int v25;
  uint64_t v26;
  char *v28;
  unint64_t v29;
  void *v30;
  char *v31;
  uint64_t v32;
  char *v33;
  void *__src;
  uint64_t v36;
  _BYTE v37[16];
  void *v38;
  uint64_t v39;
  _BYTE v40[16];
  void *v41;
  uint64_t v42;
  _QWORD v43[6];

  v43[4] = *MEMORY[0x1E0C80C00];
  if (a2 <= a4)
  {
    *(_BYTE *)a5 = 0;
    *(_BYTE *)(a5 + 48) = 0;
    return;
  }
  v41 = v43;
  v42 = 0x100000000;
  if (a4 >= 2)
    llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow((uint64_t)&v41, a4);
  LODWORD(v9) = 0;
  v38 = v40;
  v39 = 0x200000000;
  while (1)
  {
    v10 = v42;
    if (a4 == v42)
      break;
    v11 = *(_QWORD *)(a3 + 8 * v42);
    v12 = v9;
    if (a2 <= v9)
    {
      v15 = 1;
LABEL_19:
      v18 = *(_QWORD *)(a1 + 8 * v12);
      if (v18 != 0x8000000000000000)
      {
LABEL_24:
        if (v11 == 0x8000000000000000)
          goto LABEL_57;
        goto LABEL_25;
      }
    }
    else
    {
      v13 = 1;
      while (1)
      {
        v14 = *(_QWORD *)(a1 + 8 * v12);
        v15 = v14 * v13;
        if (v14 == 0x8000000000000000 || v15 >= v11)
          break;
        v17 = v39;
        if (v39 >= (unint64_t)HIDWORD(v39))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v40, v39 + 1, 8);
          v17 = v39;
        }
        v9 = (v9 + 1);
        *((_QWORD *)v38 + v17) = v12;
        LODWORD(v39) = v39 + 1;
        v12 = v9;
        v13 = v15;
        if (a2 <= v9)
          goto LABEL_19;
      }
      v15 = v13;
      v18 = *(_QWORD *)(a1 + 8 * v12);
      if (v18 != 0x8000000000000000)
        goto LABEL_24;
    }
    if (v11 != 0x8000000000000000 || v15 != 1)
      goto LABEL_57;
LABEL_25:
    if (v18 * v15 != v11)
      goto LABEL_57;
    v19 = v39;
    if (v39 >= (unint64_t)HIDWORD(v39))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v40, v39 + 1, 8);
      v19 = v39;
    }
    *((_QWORD *)v38 + v19) = v12;
    LODWORD(v39) = v39 + 1;
    __src = v37;
    v36 = 0x200000000;
    if (v42 >= HIDWORD(v42))
    {
      llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::growAndEmplaceBack<llvm::SmallVector<long long,2u>>((uint64_t)&v41, (uint64_t)&__src);
      v23 = __src;
      if (__src == v37)
        goto LABEL_5;
    }
    else
    {
      v20 = (void **)((char *)v41 + 32 * v42);
      *v20 = v20 + 2;
      v20[1] = (void *)0x200000000;
      if (v20 != &__src)
      {
        v21 = v36;
        if ((_DWORD)v36)
        {
          if (__src == v37)
          {
            v22 = v36;
            if (v36 < 3uLL
              || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v20, v20 + 2, v36, 8),
                  v22 = v36,
                  (_DWORD)v36))
            {
              memcpy(*v20, __src, 8 * v22);
            }
            *((_DWORD *)v20 + 2) = v21;
          }
          else
          {
            *v20 = __src;
            *((_DWORD *)v20 + 2) = v21;
            *((_DWORD *)v20 + 3) = HIDWORD(v36);
            __src = v37;
            HIDWORD(v36) = 0;
          }
          LODWORD(v36) = 0;
        }
      }
      LODWORD(v42) = v42 + 1;
      v23 = __src;
      if (__src == v37)
        goto LABEL_5;
    }
    free(v23);
LABEL_5:
    LODWORD(v9) = v9 + 1;
    llvm::SmallVectorImpl<long long>::swap((uint64_t)v41 + 32 * v42 - 32, (uint64_t)&v38);
    if (a2 <= v9)
    {
      v10 = v42;
      break;
    }
  }
  if (a4 != v10)
  {
LABEL_57:
    *(_BYTE *)a5 = 0;
    *(_BYTE *)(a5 + 48) = 0;
    v30 = v38;
    if (v38 == v40)
      goto LABEL_59;
    goto LABEL_58;
  }
  v24 = v9;
  if (a2 > v9)
  {
    v25 = v9 + 1;
    while (1)
    {
      v26 = *(_QWORD *)(a1 + 8 * v24);
      if (v26 != 0x8000000000000000 && v26 != 1)
        goto LABEL_57;
      if ((_DWORD)v42)
      {
        v28 = (char *)v41 + 32 * v42;
        v29 = *((unsigned int *)v28 - 6);
        if (v29 >= *((unsigned int *)v28 - 5))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v28 - 32), v28 - 16, v29 + 1, 8);
          v29 = *((unsigned int *)v28 - 6);
        }
        *(_QWORD *)(*((_QWORD *)v28 - 4) + 8 * v29) = v24;
        ++*((_DWORD *)v28 - 6);
      }
      v24 = v25++;
      if (a2 <= v24)
      {
        LODWORD(v10) = v42;
        break;
      }
    }
  }
  *(_QWORD *)a5 = a5 + 16;
  *(_QWORD *)(a5 + 8) = 0x100000000;
  if ((_DWORD)v10)
    llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=(a5, (uint64_t)&v41);
  *(_BYTE *)(a5 + 48) = 1;
  v30 = v38;
  if (v38 != v40)
LABEL_58:
    free(v30);
LABEL_59:
  v31 = (char *)v41;
  if ((_DWORD)v42)
  {
    v32 = 32 * v42;
    do
    {
      v33 = *(char **)&v31[v32 - 32];
      if (&v31[v32 - 16] != v33)
        free(v33);
      v32 -= 32;
    }
    while (v32);
    v31 = (char *)v41;
  }
  if (v31 != (char *)v43)
    free(v31);
}

void mlir::composeReassociationIndices(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned __int32 v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  int32x2_t v16;
  int32x2_t *v17;
  int32x2_t v18;
  int32x2_t v19;
  int32x2_t v20;
  int32x2_t v21;
  int32x2_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  const void *v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  void **v33;
  char *v34;
  unint64_t v35;
  int64_t v36;
  int v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  char *v41;
  void *v42;
  uint64_t v43;
  _BYTE v44[16];
  void *v45;
  uint64_t v46;
  _QWORD v47[5];

  v47[4] = *MEMORY[0x1E0C80C00];
  v45 = v47;
  v46 = 0x100000000;
  if (a2 == a4)
    goto LABEL_45;
  if (a2 < a4)
    v6 = a2;
  else
    v6 = a4;
  if (a2 < a4)
    v7 = a1;
  else
    v7 = a3;
  if (a2 < a4)
    v8 = a3;
  else
    v8 = a1;
  if (a2 < a4)
    v9 = a4;
  else
    v9 = a2;
  if (!v6)
  {
    *(_QWORD *)a5 = a5 + 16;
    *(_QWORD *)(a5 + 8) = 0x100000000;
    *(_BYTE *)(a5 + 48) = 1;
    return;
  }
  v10 = (v6 - 1) & 0x7FFFFFFFFFFFFFFLL;
  if (v10 >= 4)
  {
    v13 = v10 + 1;
    v14 = v13 & 3;
    if ((v13 & 3) == 0)
      v14 = 4;
    v15 = v13 - v14;
    v12 = v7 + 32 * v15;
    v16 = 0;
    v17 = (int32x2_t *)(v7 + 72);
    v18 = 0;
    do
    {
      v19 = vzip1_s32(v17[-8], v17[-4]);
      v20 = v17[4];
      v21 = *v17;
      v17 += 16;
      v16 = vadd_s32(v19, v16);
      v18 = vadd_s32(vzip1_s32(v21, v20), v18);
      v15 -= 4;
    }
    while (v15);
    v22 = vadd_s32(v18, v16);
    v11 = vpadd_s32(v22, v22).u32[0];
  }
  else
  {
    v11 = 0;
    v12 = v7;
  }
  v23 = v7 + 32 * v6;
  do
  {
    v11 += *(_DWORD *)(v12 + 8);
    v12 += 32;
  }
  while (v12 != v23);
  if (v9 != v11)
  {
LABEL_45:
    *(_BYTE *)a5 = 0;
    *(_BYTE *)(a5 + 48) = 0;
    return;
  }
  do
  {
    v24 = *(_QWORD **)v7;
    v25 = *(unsigned int *)(v7 + 8);
    v42 = v44;
    v43 = 0x200000000;
    if ((_DWORD)v25)
    {
      v26 = 0;
      v27 = 8 * v25;
      do
      {
        v28 = v8 + 32 * *v24;
        v29 = *(const void **)v28;
        v30 = *(unsigned int *)(v28 + 8);
        v31 = v30 + v26;
        if (v31 > HIDWORD(v43))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v42, v44, v31, 8);
          v26 = v43;
        }
        if ((_DWORD)v30)
        {
          memcpy((char *)v42 + 8 * v26, v29, 8 * v30);
          v26 = v43;
        }
        v26 += v30;
        LODWORD(v43) = v26;
        ++v24;
        v27 -= 8;
      }
      while (v27);
    }
    v32 = (char *)v45;
    if (v46 >= HIDWORD(v46))
    {
      v35 = v46 + 1;
      if (v45 <= &v42 && (char *)v45 + 32 * v46 > (char *)&v42)
      {
        v36 = (char *)&v42 - (_BYTE *)v45;
        llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow((uint64_t)&v45, v35);
        v32 = (char *)v45;
        v33 = (void **)((char *)v45 + v36);
      }
      else
      {
        llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow((uint64_t)&v45, v35);
        v33 = &v42;
        v32 = (char *)v45;
      }
    }
    else
    {
      v33 = &v42;
    }
    v34 = &v32[32 * v46];
    *(_QWORD *)v34 = v34 + 16;
    *((_QWORD *)v34 + 1) = 0x200000000;
    if (*((_DWORD *)v33 + 2))
      llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v34, (uint64_t)v33);
    LODWORD(v46) = v46 + 1;
    if (v42 != v44)
      free(v42);
    v7 += 32;
  }
  while (v7 != v23);
  v37 = v46;
  *(_QWORD *)a5 = a5 + 16;
  *(_QWORD *)(a5 + 8) = 0x100000000;
  if (v37)
  {
    llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=(a5, (uint64_t)&v45);
    v38 = v46;
    *(_BYTE *)(a5 + 48) = 1;
    v39 = (char *)v45;
    if (!(_DWORD)v38)
      goto LABEL_55;
    v40 = 32 * v38;
    do
    {
      v41 = *(char **)&v39[v40 - 32];
      if (&v39[v40 - 16] != v41)
        free(v41);
      v40 -= 32;
    }
    while (v40);
  }
  else
  {
    *(_BYTE *)(a5 + 48) = 1;
  }
  v39 = (char *)v45;
LABEL_55:
  if (v39 != (char *)v47)
    free(v39);
}

void mlir::convertReassociationIndicesToExprs(mlir::MLIRContext *a1@<X0>, unsigned int **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int **v5;
  unsigned int **v7;
  unint64_t v8;
  unsigned int *v9;
  uint64_t v10;
  uint64_t AffineDimExpr;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  void **v15;
  _QWORD *v16;
  unint64_t v17;
  BOOL v18;
  char *v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[3];

  v22[2] = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a4 = a4 + 16;
  *(_QWORD *)(a4 + 8) = 0x200000000;
  if (a3)
  {
    v5 = a2;
    v7 = &a2[4 * a3];
    do
    {
      v20 = v22;
      v21 = 0x200000000;
      v8 = *((unsigned int *)v5 + 2);
      if (v8 >= 3)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v20, v22, v8, 8);
        v8 = *((unsigned int *)v5 + 2);
      }
      if (v8)
      {
        v9 = *v5;
        v10 = 8 * v8;
        do
        {
          AffineDimExpr = mlir::getAffineDimExpr((mlir *)*v9, a1, (mlir::MLIRContext *)v8);
          v12 = v21;
          if (v21 >= (unint64_t)HIDWORD(v21))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v20, v22, v21 + 1, 8);
            v12 = v21;
          }
          *((_QWORD *)v20 + v12) = AffineDimExpr;
          LODWORD(v21) = v21 + 1;
          v9 += 2;
          v10 -= 8;
        }
        while (v10);
      }
      v13 = *(unsigned int *)(a4 + 8);
      v14 = *(_QWORD *)a4;
      if (v13 >= *(_DWORD *)(a4 + 12))
      {
        v17 = v13 + 1;
        v18 = v14 + 32 * v13 > (unint64_t)&v20;
        if (v14 <= (unint64_t)&v20 && v18)
        {
          v19 = (char *)&v20 - v14;
          llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(a4, v17);
          v14 = *(_QWORD *)a4;
          v15 = (void **)&v19[*(_QWORD *)a4];
          goto LABEL_13;
        }
        llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(a4, v17);
        v14 = *(_QWORD *)a4;
      }
      v15 = &v20;
LABEL_13:
      v16 = (_QWORD *)(v14 + 32 * *(unsigned int *)(a4 + 8));
      *v16 = v16 + 2;
      v16[1] = 0x200000000;
      if (*((_DWORD *)v15 + 2))
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v16, (uint64_t)v15);
      ++*(_DWORD *)(a4 + 8);
      if (v20 != v22)
        free(v20);
      v5 += 4;
    }
    while (v5 != v7);
  }
}

uint64_t mlir::getReassociationIndicesAttribute(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  int v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t ArrayAttr;
  void *v14;
  uint64_t v15;
  _QWORD v16[5];

  v16[4] = *MEMORY[0x1E0C80C00];
  v6 = 32 * a3;
  v14 = v16;
  v15 = 0x400000000;
  if ((unint64_t)(32 * a3) < 0x81)
  {
    v7 = 0;
    v9 = 0;
    v8 = v16;
    if (!a3)
      goto LABEL_8;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v14, v16, (32 * a3) >> 5, 8);
    v7 = v15;
    v8 = v14;
    v9 = v15;
    if (!a3)
      goto LABEL_8;
  }
  v10 = a2 + v6;
  v11 = &v8[v7];
  do
  {
    *v11++ = mlir::Builder::getI64ArrayAttr(a1, *(void ***)a2, *(unsigned int *)(a2 + 8));
    a2 += 32;
  }
  while (a2 != v10);
  v9 = v15;
  v8 = v14;
LABEL_8:
  LODWORD(v15) = v9 + (v6 >> 5);
  ArrayAttr = mlir::Builder::getArrayAttr((mlir::MLIRContext **)a1, (uint64_t)v8, v15);
  if (v14 != v16)
    free(v14);
  return ArrayAttr;
}

void llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::push_back(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  void *v7;
  unsigned int v8;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v14;

  v4 = *(unsigned int *)(a1 + 8);
  v5 = *(_QWORD *)a1;
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    v11 = v4 + 1;
    v12 = v5 + 32 * v4;
    if (v5 <= a2 && v12 > a2)
    {
      v14 = a2 - v5;
      llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(a1, v11);
      v5 = *(_QWORD *)a1;
      a2 = *(_QWORD *)a1 + v14;
    }
    else
    {
      llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(a1, v11);
      v5 = *(_QWORD *)a1;
    }
  }
  v6 = (_QWORD *)(v5 + 32 * *(unsigned int *)(a1 + 8));
  v7 = v6 + 2;
  *v6 = v6 + 2;
  v6[1] = 0x200000000;
  v8 = *(_DWORD *)(a2 + 8);
  if (v6 != (_QWORD *)a2 && v8 != 0)
  {
    if (v8 < 3)
    {
      v10 = *(_DWORD *)(a2 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v6, v6 + 2, *(unsigned int *)(a2 + 8), 8);
      v10 = *(_DWORD *)(a2 + 8);
      if (!v10)
      {
LABEL_11:
        *((_DWORD *)v6 + 2) = v8;
        goto LABEL_12;
      }
      v7 = (void *)*v6;
    }
    memcpy(v7, *(const void **)a2, 8 * v10);
    goto LABEL_11;
  }
LABEL_12:
  ++*(_DWORD *)(a1 + 8);
}

void mlir::getSymbolLessAffineMaps(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t i;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  mlir::BytecodeWriterConfig *v14;
  uint64_t v15;
  _QWORD *DesiredBytecodeVersion;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  _QWORD v21[3];
  _QWORD *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v20 = 0;
  if (!a2)
  {
    *(_QWORD *)a3 = a3 + 16;
    *(_QWORD *)(a3 + 8) = 0x400000000;
    return;
  }
  v5 = a1;
  v6 = a1 + 32 * a2;
  v7 = a1;
  do
  {
    v8 = *(unsigned int *)(v7 + 8);
    if ((_DWORD)v8)
    {
      v9 = *(uint64_t **)v7;
      for (i = 8 * v8; i; i -= 8)
      {
        v19 = *v9;
        v21[0] = &unk_1E0E501A0;
        v21[1] = &v20;
        v22 = v21;
        mlir::AffineExpr::walk(&v19, v21);
        v11 = v22;
        if (v22 == v21)
        {
          v11 = v21;
          v12 = 4;
        }
        else
        {
          if (!v22)
            goto LABEL_8;
          v12 = 5;
        }
        (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_8:
        ++v9;
      }
    }
    v7 += 32;
  }
  while (v7 != v6);
  v13 = v20 + 1;
  *(_QWORD *)a3 = a3 + 16;
  *(_QWORD *)(a3 + 8) = 0x400000000;
  if (a2 >= 5)
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), a2, 8);
  do
  {
    v14 = *(mlir::BytecodeWriterConfig **)v5;
    v15 = *(unsigned int *)(v5 + 8);
    DesiredBytecodeVersion = (_QWORD *)mlir::BytecodeWriterConfig::getDesiredBytecodeVersion(*(mlir::BytecodeWriterConfig **)v5);
    v17 = mlir::AffineMap::get(v13, 0, (uint64_t)v14, v15, DesiredBytecodeVersion);
    v18 = *(unsigned int *)(a3 + 8);
    if (v18 >= *(unsigned int *)(a3 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v18 + 1, 8);
      v18 = *(unsigned int *)(a3 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a3 + 8 * v18) = v17;
    ++*(_DWORD *)(a3 + 8);
    v5 += 32;
  }
  while (v5 != v6);
}

uint64_t mlir::isReassociationValid(mlir::AffineMap *a1, uint64_t a2, _DWORD *a3)
{
  mlir::AffineMap *v5;
  int NumDims;
  int v7;
  int v8;
  mlir::AffineMap *v9;
  uint64_t Results;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (!a2)
    return 1;
  v5 = a1;
  NumDims = mlir::AffineMap::getNumDims(a1);
  v7 = 0;
  v8 = 0;
  v9 = (mlir::AffineMap *)((char *)v5 + 8 * a2);
  do
  {
    v17 = *(_QWORD *)v5;
    if (mlir::AffineMap::getNumDims((mlir::AffineMap *)&v17) != NumDims
      || mlir::AffineMap::getNumSymbols((mlir::AffineMap *)&v17))
    {
      goto LABEL_15;
    }
    Results = mlir::AffineMap::getResults((mlir::AffineMap *)&v17);
    if (v11)
    {
      v12 = (uint64_t *)Results;
      v13 = 8 * v11;
      while (1)
      {
        v14 = *v12;
        v18 = *v12;
        if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v18) == 6)
        {
          mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v18, v14);
          v16 = v18;
          if (!v18)
            break;
        }
        else
        {
          mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v18, 0);
          v16 = v18;
          if (!v18)
            break;
        }
        if (v7 != mlir::AffineDimExpr::getPosition((mlir::AffineDimExpr *)&v16))
          break;
        ++v7;
        ++v12;
        v13 -= 8;
        if (!v13)
          goto LABEL_3;
      }
LABEL_15:
      if (a3)
        *a3 = v8;
      return 0;
    }
LABEL_3:
    ++v8;
    v5 = (mlir::AffineMap *)((char *)v5 + 8);
  }
  while (v5 != v9);
  if (v7 == NumDims)
    return 1;
  result = 0;
  if (a3)
    *a3 = a2 - 1;
  return result;
}

uint64_t mlir::reshapeLikeShapesAreCompatible(uint64_t (*a1)(uint64_t, _QWORD **), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  uint64_t v12;
  unsigned int v13;
  uint64_t i;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  _QWORD *v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD v34[4];
  __int16 v35;
  _QWORD v36[4];
  __int16 v37;
  _QWORD v38[4];
  __int16 v39;
  _QWORD v40[2];
  const char *v41;
  __int16 v42;
  _QWORD v43[2];
  const char *v44;
  __int16 v45;
  _QWORD *v46;
  const char *v47;
  __int16 v48;
  uint64_t v49;

  if (!a8)
    return 1;
  v12 = a7 + 32 * a8;
  if ((a9 & 1) != 0)
  {
    v13 = 0;
    for (i = 0; ; ++i)
    {
      v9 &= 0xFFFFFFFFFFFFFF00;
      v49 = 1;
      v15 = v13;
      v16 = *(unsigned int *)(a7 + 8);
      if ((_DWORD)v16)
      {
        v17 = 0;
        v18 = 0;
        v19 = 8 * v16;
        v20 = 1;
        v21 = a5 + 8 * v13;
        do
        {
          while (1)
          {
            v22 = *(_QWORD *)(v21 + 8 * v18);
            if (v22 == 0x8000000000000000)
              break;
            v20 *= v22;
            v49 = v20;
            ++v18;
            v19 -= 8;
            if (!v19)
              goto LABEL_10;
          }
          if (v17)
          {
            v33 = i;
            v34[0] = "invalid to have a single dimension (";
            v34[2] = &v33;
            v35 = 2819;
            v36[0] = v34;
            v36[2] = ") expanded into multiple dynamic dims (";
            v30 = 770;
            v37 = 770;
            v32 = v9 + v15;
            v38[0] = v36;
            v38[2] = &v32;
            v39 = 3586;
            v40[0] = v38;
            v41 = ",";
            v42 = 770;
            v31 = v15 + v18;
            v43[0] = v40;
            v44 = (const char *)&v31;
            v45 = 2818;
            v46 = v43;
            v47 = ")";
            goto LABEL_31;
          }
          v17 = 1;
          v9 = v18++;
          v19 -= 8;
        }
        while (v19);
LABEL_10:
        if (!v17)
          goto LABEL_14;
        if (*(_QWORD *)(a3 + 8 * i) != 0x8000000000000000)
          goto LABEL_28;
      }
      else
      {
        v20 = 1;
LABEL_14:
        if (*(_QWORD *)(a3 + 8 * i) != v20)
          goto LABEL_30;
      }
      v13 = v16 + v15;
      a7 += 32;
      if (a7 == v12)
        return 1;
    }
  }
  v24 = 0;
  for (i = 0; ; ++i)
  {
    v49 = 1;
    v25 = *(unsigned int *)(a7 + 8);
    v26 = 1;
    if (!(_DWORD)v25)
      break;
    v27 = 0;
    v28 = 8 * v25;
    v26 = 1;
    v29 = (_QWORD *)(a5 + 8 * v24);
    do
    {
      while (*v29 != 0x8000000000000000)
      {
        v26 *= *v29;
        v49 = v26;
        ++v29;
        v28 -= 8;
        if (!v28)
          goto LABEL_26;
      }
      v27 = 1;
      ++v29;
      v28 -= 8;
    }
    while (v28);
LABEL_26:
    if (!v27)
      break;
    if (*(_QWORD *)(a3 + 8 * i) != 0x8000000000000000)
    {
LABEL_28:
      v40[0] = i;
      v43[0] = "expected dimension ";
      v44 = (const char *)v40;
      v45 = 2819;
      v46 = v43;
      v47 = " of collapsed type to be dynamic since one or more of the corresponding dimensions in the expanded type is dynamic";
      v30 = 770;
      goto LABEL_31;
    }
LABEL_20:
    v24 += v25;
    a7 += 32;
    if (a7 == v12)
      return 1;
  }
  if (*(_QWORD *)(a3 + 8 * i) == v26)
    goto LABEL_20;
LABEL_30:
  v38[0] = i;
  v40[0] = "expected dimension ";
  v41 = (const char *)v38;
  v42 = 2819;
  v43[0] = v40;
  v44 = " of collapsed type to be static value of ";
  v45 = 770;
  v46 = v43;
  v47 = (const char *)&v49;
  v30 = 3586;
LABEL_31:
  v48 = v30;
  return a1(a2, &v46);
}

uint64_t mlir::hasNonIdentityLayout(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD v4[2];
  uint64_t v5;

  if (*(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
    v1 = a1;
  else
    v1 = 0;
  v5 = v1;
  if (!v1)
    return 0;
  v4[0] = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&v5);
  v4[1] = v2;
  return mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v4) ^ 1;
}

uint64_t llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  _DWORD *v10;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  char *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;

  if (a1 != a2)
  {
    v5 = a2 + 16;
    v4 = *(_QWORD *)a2;
    if (*(_QWORD *)a2 != a2 + 16)
    {
      v6 = *(char **)a1;
      v7 = *(unsigned int *)(a1 + 8);
      if ((_DWORD)v7)
      {
        v8 = 32 * v7;
        do
        {
          v9 = *(char **)&v6[v8 - 32];
          if (&v6[v8 - 16] != v9)
            free(v9);
          v8 -= 32;
        }
        while (v8);
        v6 = *(char **)a1;
      }
      if (v6 != (char *)(a1 + 16))
        free(v6);
      *(_QWORD *)a1 = *(_QWORD *)a2;
      v10 = (_DWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
LABEL_12:
      *v10 = 0;
      return a1;
    }
    v10 = (_DWORD *)(a2 + 8);
    v12 = *(unsigned int *)(a2 + 8);
    v13 = *(unsigned int *)(a1 + 8);
    if (v13 < v12)
    {
      if (*(_DWORD *)(a1 + 12) >= v12)
      {
        if (!(_DWORD)v13)
        {
          v13 = 0;
          v23 = *(_QWORD *)a2;
          v24 = *(unsigned int *)(a2 + 8);
          if (*(_DWORD *)(a2 + 8))
          {
LABEL_32:
            v25 = *(char **)a1;
            v26 = 32 * v13;
            v27 = 32 * v24;
            do
            {
              v28 = &v25[v26];
              *(_QWORD *)v28 = &v25[v26 + 16];
              *((_QWORD *)v28 + 1) = 0x200000000;
              if (*(_DWORD *)(v23 + v26 + 8))
                llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v28, v23 + v26);
              v25 += 32;
              v27 -= 32;
              v23 += 32;
            }
            while (v26 != v27);
            v23 = *(_QWORD *)a2;
          }
LABEL_37:
          *(_DWORD *)(a1 + 8) = v12;
          v29 = *v10;
          if ((_DWORD)v29)
          {
            v30 = 32 * v29;
            do
            {
              v31 = *(void **)(v23 + v30 - 32);
              if ((void *)(v23 + v30 - 16) != v31)
                free(v31);
              v30 -= 32;
            }
            while (v30);
          }
          goto LABEL_12;
        }
        v21 = *(_QWORD *)a1;
        v22 = 32 * v13;
        do
        {
          llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v21, v4);
          v4 += 32;
          v21 += 32;
          v22 -= 32;
        }
        while (v22);
      }
      else
      {
        if ((_DWORD)v13)
        {
          v14 = *(_QWORD *)a1;
          v15 = 32 * v13;
          do
          {
            v16 = *(void **)(v14 + v15 - 32);
            if ((void *)(v14 + v15 - 16) != v16)
              free(v16);
            v15 -= 32;
          }
          while (v15);
        }
        *(_DWORD *)(a1 + 8) = 0;
        llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(a1, v12);
        v13 = 0;
      }
      v23 = *(_QWORD *)a2;
      v24 = *(unsigned int *)(a2 + 8);
      if (v13 != v24)
        goto LABEL_32;
      goto LABEL_37;
    }
    v17 = *(_QWORD *)a1;
    if ((_DWORD)v12)
    {
      v18 = 0;
      do
      {
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v17 + v18, v4 + v18);
        v18 += 32;
      }
      while (32 * v12 != v18);
      v19 = v17 + v18;
      v20 = *(_QWORD *)a1 + 32 * *(unsigned int *)(a1 + 8);
      if (v20 == v17 + v18)
      {
LABEL_47:
        *(_DWORD *)(a1 + 8) = v12;
        v35 = *(unsigned int *)(a2 + 8);
        if ((_DWORD)v35)
        {
          v36 = *(_QWORD *)a2;
          v37 = 32 * v35;
          do
          {
            v38 = *(void **)(v36 + v37 - 32);
            if ((void *)(v36 + v37 - 16) != v38)
              free(v38);
            v37 -= 32;
          }
          while (v37);
        }
        goto LABEL_12;
      }
    }
    else
    {
      v19 = *(_QWORD *)a1;
      v20 = v17 + 32 * v13;
      if (v20 == v17)
        goto LABEL_47;
    }
    v32 = (char *)(v20 - 16);
    do
    {
      v34 = (char *)*((_QWORD *)v32 - 2);
      if (v32 != v34)
        free(v34);
      v33 = v32 - 16;
      v32 -= 32;
    }
    while (v33 != (char *)v19);
    goto LABEL_47;
  }
  return a1;
}

void llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(uint64_t a1, unint64_t a2)
{
  _DWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  int v13;
  unint64_t v14;

  v14 = 0;
  v3 = (_DWORD *)(a1 + 16);
  v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 32, &v14);
  v5 = v4;
  v6 = *(_DWORD **)a1;
  v7 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v7)
  {
    v8 = 32 * v7;
    v9 = v4;
    do
    {
      *v9 = v9 + 2;
      v9[1] = 0x200000000;
      if (v6[2])
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v9, (uint64_t)v6);
      v9 += 4;
      v6 += 8;
      v8 -= 32;
    }
    while (v8);
    v6 = *(_DWORD **)a1;
    v10 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v10)
    {
      v11 = 8 * v10;
      do
      {
        v12 = *(_DWORD **)&v6[v11 - 8];
        if (&v6[v11 - 4] != v12)
          free(v12);
        v11 -= 8;
      }
      while (v11 * 4);
      v6 = *(_DWORD **)a1;
    }
  }
  v13 = v14;
  if (v6 != v3)
    free(v6);
  *(_QWORD *)a1 = v5;
  *(_DWORD *)(a1 + 12) = v13;
}

uint64_t llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::growAndEmplaceBack<llvm::SmallVector<long long,2u>>(uint64_t a1, uint64_t a2)
{
  _DWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _DWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  int v14;
  uint64_t v15;
  unint64_t v17;

  v17 = 0;
  v4 = (_DWORD *)(a1 + 16);
  v5 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 32, &v17);
  v6 = &v5[4 * *(unsigned int *)(a1 + 8)];
  *v6 = v6 + 2;
  v6[1] = 0x200000000;
  if (*(_DWORD *)(a2 + 8))
    llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v6, a2);
  v7 = *(_DWORD **)a1;
  v8 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v8)
  {
    v9 = 32 * v8;
    v10 = v5;
    do
    {
      *v10 = v10 + 2;
      v10[1] = 0x200000000;
      if (v7[2])
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v10, (uint64_t)v7);
      v10 += 4;
      v7 += 8;
      v9 -= 32;
    }
    while (v9);
    v7 = *(_DWORD **)a1;
    v11 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v11)
    {
      v12 = 8 * v11;
      do
      {
        v13 = *(_DWORD **)&v7[v12 - 8];
        if (&v7[v12 - 4] != v13)
          free(v13);
        v12 -= 8;
      }
      while (v12 * 4);
      v7 = *(_DWORD **)a1;
    }
  }
  v14 = v17;
  if (v7 != v4)
    free(v7);
  *(_QWORD *)a1 = v5;
  v15 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v15;
  *(_DWORD *)(a1 + 12) = v14;
  return (uint64_t)&v5[4 * v15 - 4];
}

void llvm::SmallVectorImpl<long long>::swap(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  int v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;
  uint64_t v16;
  __int128 *v17;
  __int128 *v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  int v28;
  int v29;

  if (a1 != a2)
  {
    v4 = *(_QWORD *)a1;
    if (*(_QWORD *)a1 != a1 + 16 && *(_QWORD *)a2 != a2 + 16)
    {
      *(_QWORD *)a1 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v4;
      v5 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 8) = v5;
      v6 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 12) = v6;
      return;
    }
    v7 = *(unsigned int *)(a2 + 8);
    if (*(_DWORD *)(a1 + 12) >= v7)
    {
      v8 = *(unsigned int *)(a1 + 8);
      if (*(_DWORD *)(a2 + 12) >= v8)
      {
LABEL_7:
        v9 = v8;
        v10 = *(unsigned int *)(a2 + 8);
        if (v8 >= v10)
          v11 = v10;
        else
          v11 = v8;
        if (!(_DWORD)v11)
          goto LABEL_30;
LABEL_17:
        v13 = *(_QWORD *)a1;
        v14 = *(_QWORD *)a2;
        if (v11 >= 4 && (v13 < v14 + 8 * v11 ? (v15 = v14 >= v13 + 8 * v11) : (v15 = 1), v15))
        {
          v16 = v11 & 0xFFFFFFFC;
          v17 = (__int128 *)(v13 + 16);
          v18 = (__int128 *)(v14 + 16);
          v19 = v16;
          do
          {
            v20 = *(v17 - 1);
            v21 = *v17;
            v22 = *v18;
            *(v17 - 1) = *(v18 - 1);
            *v17 = v22;
            *(v18 - 1) = v20;
            *v18 = v21;
            v17 += 2;
            v18 += 2;
            v19 -= 4;
          }
          while (v19);
          if (v16 == v11)
            goto LABEL_30;
        }
        else
        {
          v16 = 0;
        }
        v23 = v11 - v16;
        v24 = 8 * v16;
        v25 = (uint64_t *)(v13 + v24);
        v26 = (uint64_t *)(v14 + v24);
        do
        {
          v27 = *v25;
          *v25++ = *v26;
          *v26++ = v27;
          --v23;
        }
        while (v23);
LABEL_30:
        if (v10 >= v9)
        {
          if (v10 > v9)
          {
            v29 = v10 - v9;
            memcpy((void *)(*(_QWORD *)a1 + 8 * v9), (const void *)(*(_QWORD *)a2 + 8 * v11), *(_QWORD *)a2 + 8 * v10 - (*(_QWORD *)a2 + 8 * v11));
            *(_DWORD *)(a1 + 8) += v29;
            *(_DWORD *)(a2 + 8) = v11;
          }
        }
        else
        {
          v28 = v9 - v10;
          memcpy((void *)(*(_QWORD *)a2 + 8 * v10), (const void *)(*(_QWORD *)a1 + 8 * v11), *(_QWORD *)a1 + 8 * v9 - (*(_QWORD *)a1 + 8 * v11));
          *(_DWORD *)(a2 + 8) += v28;
          *(_DWORD *)(a1 + 8) = v11;
        }
        return;
      }
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v7, 8);
      v8 = *(unsigned int *)(a1 + 8);
      if (*(_DWORD *)(a2 + 12) >= v8)
        goto LABEL_7;
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v8, 8);
    v12 = *(_DWORD *)(a1 + 8);
    v9 = v12;
    v10 = *(unsigned int *)(a2 + 8);
    if (v12 >= v10)
      v11 = v10;
    else
      v11 = v12;
    if (!(_DWORD)v11)
      goto LABEL_30;
    goto LABEL_17;
  }
}

_QWORD *std::__function::__func<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1},std::allocator<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &unk_1E0E501A0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1},std::allocator<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &unk_1E0E501A0;
  a2[1] = v2;
  return result;
}

_QWORD *std::__function::__func<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1},std::allocator<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  _QWORD *result;
  int *v5;
  int v6;
  uint64_t v7;

  v3 = *a2;
  v7 = *a2;
  if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v7) == 6)
  {
    result = mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v7, v3);
    if (!v7)
      return result;
  }
  else
  {
    result = mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v7, 0);
    if (!v7)
      return result;
  }
  v5 = *(int **)(a1 + 8);
  result = (_QWORD *)mlir::AffineDimExpr::getPosition((mlir::AffineDimExpr *)&v7);
  v6 = *v5;
  if (*v5 <= result)
    v6 = (int)result;
  **(_DWORD **)(a1 + 8) = v6;
  return result;
}

uint64_t std::__function::__func<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1},std::allocator<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::target(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3 == 0x8000000181236395)
    return a1 + 8;
  if (((v3 & 0x8000000181236395 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x8000000181236395))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x8000000181236395 & 0x7FFFFFFFFFFFFFFFLL)))
    return a1 + 8;
  return 0;
}

void *std::__function::__func<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1},std::allocator<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::target_type()
{
}

void mlir::clone(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  uint64_t v13;
  mlir::ArrayAttr *v14;
  uint64_t Value;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  mlir::Region *v20;
  uint64_t v21;
  mlir::Region *v22;
  _QWORD v23[2];
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  llvm *v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31[2];
  _QWORD v32[40];

  v32[38] = *MEMORY[0x1E0C80C00];
  v23[0] = 0;
  v23[1] = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v12 = *(_QWORD *)(a2 + 24);
  v13 = *(_QWORD *)(a2 + 48);
  if (*(_BYTE *)(a2 + 47))
  {
    v32[0] = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
    v14 = (mlir::ArrayAttr *)v32;
  }
  else
  {
    v14 = (mlir::ArrayAttr *)(a2 + 56);
  }
  Value = mlir::ArrayAttr::getValue(v14);
  v17 = v16;
  mlir::BlockRange::BlockRange(v31, 0, 0);
  mlir::OperationState::OperationState(v32, v12, v13, a5, a6, a3, a4, v18, Value, v17, v31[0], v31[1], 0, 0);
  v19 = *(unsigned int *)(a2 + 44);
  if ((v19 & 0x7FFFFF) != 0)
  {
    v20 = (mlir::Region *)(((a2 + 16 * ((v19 >> 23) & 1) + ((v19 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                         + 32 * *(unsigned int *)(a2 + 40));
    v21 = 24 * (v19 & 0x7FFFFF);
    do
    {
      v22 = (mlir::Region *)mlir::OperationState::addRegion((mlir::OperationState *)v32);
      mlir::Region::cloneInto(v20, v22, (mlir::IRMapping *)v23);
      v20 = (mlir::Region *)((char *)v20 + 24);
      v21 -= 24;
    }
    while (v21);
  }
  mlir::OpBuilder::create(a1, (const mlir::OperationState *)v32);
  mlir::OperationState::~OperationState((mlir::OperationState *)v32);
  llvm::deallocate_buffer(v28, (void *)(16 * v30));
}

void sub_1803872CC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, llvm *a19, uint64_t a20,unsigned int a21)
{
  llvm::deallocate_buffer(a19, (void *)(16 * a21));
}

void sub_1803872E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, llvm *a16, uint64_t a17, unsigned int a18)
{
  llvm::deallocate_buffer(a16, (void *)(16 * a18));
}

uint64_t sub_1803872F4()
{
  uint64_t v0;

  return v0;
}

void mlir::getPrunedAttributeList(_BYTE *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  int8x16_t *v8;
  const unsigned __int8 *v9;
  uint64_t v10;
  __int128 *Value;
  uint64_t v12;
  __int128 v13;
  unint64_t v14;
  int8x16_t *AttrData;
  const unsigned __int8 *v16;
  int Key;
  uint64_t v18;
  llvm *v19;
  __int128 v21;
  uint64_t CallableRegion;
  __int128 v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;

  v24 = 0;
  v25 = 0;
  v26 = 0x800000000;
  if (a3)
  {
    v6 = a2;
    v7 = a2 + 16 * a3;
    do
    {
      v8 = *(int8x16_t **)v6;
      v9 = *(const unsigned __int8 **)(v6 + 8);
      v6 += 16;
      llvm::StringMap<std::nullopt_t,llvm::MallocAllocator>::try_emplace<>((uint64_t)&v24, v8, v9);
    }
    while (v6 != v7);
  }
  *(_QWORD *)a4 = a4 + 16;
  *(_QWORD *)(a4 + 8) = 0x300000000;
  if (a1[47])
  {
    *(_QWORD *)&v23 = mlir::Operation::getAttrDictionary((mlir::Operation *)a1);
    Value = (__int128 *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v23);
    if (!v10)
      goto LABEL_16;
  }
  else
  {
    Value = (__int128 *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)(a1 + 56));
    if (!v10)
      goto LABEL_16;
  }
  v12 = 16 * v10;
  do
  {
    v23 = *Value;
    CallableRegion = mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)&v23);
    AttrData = (int8x16_t *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&CallableRegion);
    Key = llvm::StringMapImpl::FindKey((uint64_t *)&v24, AttrData, v16);
    if (Key == -1 || Key == (unint64_t)v25)
    {
      v13 = v23;
      v14 = *(unsigned int *)(a4 + 8);
      if (v14 >= *(unsigned int *)(a4 + 12))
      {
        v21 = v23;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v14 + 1, 16);
        v13 = v21;
        v14 = *(unsigned int *)(a4 + 8);
      }
      *(_OWORD *)(*(_QWORD *)a4 + 16 * v14) = v13;
      ++*(_DWORD *)(a4 + 8);
    }
    ++Value;
    v12 -= 16;
  }
  while (v12);
LABEL_16:
  if (HIDWORD(v25) && (_DWORD)v25)
  {
    v18 = 0;
    do
    {
      v19 = *(llvm **)((char *)v24 + v18);
      if (v19 != (llvm *)-8 && v19 != 0)
        llvm::deallocate_buffer(v19, (void *)(*(_QWORD *)v19 + 9));
      v18 += 8;
    }
    while (8 * v25 != v18);
  }
  free(v24);
}

void mlir::dispatchIndexOpFoldResult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  void *__p;
  unsigned int v12;

  v4 = a1 & 0xFFFFFFFFFFFFFFF8;
  if ((a1 & 4) != 0 && v4)
  {
    v6 = *(unsigned int *)(a2 + 8);
    if (v6 >= *(_DWORD *)(a2 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v6 + 1, 8);
      LODWORD(v6) = *(_DWORD *)(a2 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a2 + 8 * v6) = v4;
    ++*(_DWORD *)(a2 + 8);
    v7 = *(unsigned int *)(a3 + 8);
    if (v7 >= *(_DWORD *)(a3 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v7 + 1, 8);
      LODWORD(v7) = *(_DWORD *)(a3 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a3 + 8 * v7) = 0x8000000000000000;
    ++*(_DWORD *)(a3 + 8);
  }
  else
  {
    v10 = a1 & 0xFFFFFFFFFFFFFFF8;
    mlir::IntegerAttr::getValue(&v10, (llvm::APInt *)&__p);
    if (v12 > 0x40)
      v8 = *(_QWORD *)__p;
    else
      v8 = (uint64_t)((_QWORD)__p << -(uint64_t)v12) >> -(uint64_t)v12;
    v9 = *(unsigned int *)(a3 + 8);
    if (v9 >= *(_DWORD *)(a3 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v9 + 1, 8);
      LODWORD(v9) = *(_DWORD *)(a3 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a3 + 8 * v9) = v8;
    ++*(_DWORD *)(a3 + 8);
    if (v12 >= 0x41 && __p)
      operator delete[](__p);
  }
}

void mlir::dispatchIndexOpFoldResults(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;

  if (a2)
  {
    v7 = 8 * a2;
    do
    {
      v8 = *a1++;
      mlir::dispatchIndexOpFoldResult(v8, a3, a4);
      v7 -= 8;
    }
    while (v7);
  }
}

uint64_t mlir::getAsOpFoldResult(uint64_t a1)
{
  uint64_t DefiningOp;
  uint64_t v3;
  unint64_t v4;
  uint64_t v6;
  void *v7[2];
  _QWORD v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v6 = a1;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v6);
  if (!DefiningOp)
    return a1 | 4;
  v3 = DefiningOp;
  if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
    return a1 | 4;
  v7[0] = v8;
  v7[1] = (void *)0x100000000;
  mlir::Operation::fold(v3, 0, 0, (uint64_t)v7);
  v4 = *(_QWORD *)v7[0] & 0xFFFFFFFFFFFFFFF8;
  if (v7[0] != v8)
    free(v7[0]);
  if (!v4)
    return a1 | 4;
  return v4;
}

void mlir::getAsOpFoldResult(uint64_t a1@<X0>, unint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t DefiningOp;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  void *v20[2];
  _QWORD v21[2];

  v21[1] = *MEMORY[0x1E0C80C00];
  *a3 = a3 + 2;
  a3[1] = 0x600000000;
  if (a2 < 7)
  {
    v18 = a1;
    v19 = xmmword_181236410;
    if (!a2)
    {
      v16 = 0;
      goto LABEL_20;
    }
    v6 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a3, a3 + 2, a2, 8);
    v6 = *((unsigned int *)a3 + 2);
    v18 = a1;
    v19 = xmmword_181236410;
  }
  v7 = 0;
  v8 = (unint64_t *)(*a3 + 8 * v6);
  do
  {
    v11 = mlir::ValueRange::dereference_iterator(&v18, v7);
    if (v11)
    {
      v12 = v11;
      v17 = v11;
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v17);
      if (!DefiningOp)
        goto LABEL_6;
      v14 = DefiningOp;
      if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
        goto LABEL_6;
      v20[0] = v21;
      v20[1] = (void *)0x100000000;
      mlir::Operation::fold(v14, 0, 0, (uint64_t)v20);
      v15 = *(_QWORD *)v20[0];
      if (v20[0] != v21)
        free(v20[0]);
      v9 = v15 & 0xFFFFFFFFFFFFFFF8;
      if ((v15 & 0xFFFFFFFFFFFFFFF8) == 0)
LABEL_6:
        v9 = v12 | 4;
    }
    else
    {
      v9 = 0;
    }
    *v8++ = v9;
    v7 = v19 + 1;
    *(_QWORD *)&v19 = v19 + 1;
  }
  while (v18 != a1 || v7 != a2);
  v16 = *((_DWORD *)a3 + 2);
LABEL_20:
  *((_DWORD *)a3 + 2) = v16 + a2;
}

unint64_t mlir::getConstantIntValue(uint64_t a1)
{
  void *v1;
  uint64_t DefiningOp;
  uint64_t v3;
  unint64_t v4;
  void *v5;
  BOOL v6;
  BOOL v7;
  BOOL v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  void *v12;
  unint64_t v13;
  void **p_p;
  void *__p;
  unsigned int v17;
  char v18;
  unint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[2];

  v22[1] = *MEMORY[0x1E0C80C00];
  v1 = (void *)(a1 & 0xFFFFFFFFFFFFFFF8);
  if ((a1 & 4) != 0 && v1)
  {
    v17 = 1;
    v18 = 0;
    p_p = &__p;
    __p = 0;
    v19 = a1 & 0xFFFFFFFFFFFFFFF8;
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v19);
    if (!DefiningOp)
      goto LABEL_28;
    v3 = DefiningOp;
    if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
      goto LABEL_28;
    v20 = v22;
    v21 = 0x100000000;
    mlir::Operation::fold(v3, 0, 0, (uint64_t)&v20);
    v4 = *(_QWORD *)v20 & 0xFFFFFFFFFFFFFFF8;
    if (v20 != v22)
      free(v20);
    if (v4
      && ((v5 = *(void **)(*(_QWORD *)(*(_QWORD *)(v3 - 8) & 0xFFFFFFFFFFFFFFF8) + 136),
           v5 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
        ? (v6 = v5 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        : (v6 = 1),
          !v6 ? (v7 = v5 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id) : (v7 = 1),
          !v7 ? (v8 = v5 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) : (v8 = 1),
          v8))
    {
      v9 = mlir::detail::constant_int_value_binder::match((uint64_t *)&p_p, v4);
      v10 = v17;
      if (v9)
      {
        if (v17 > 0x40)
          v11 = *(_QWORD *)__p;
        else
          v11 = (uint64_t)((_QWORD)__p << -(char)v17) >> -(char)v17;
        v13 = v11 & 0xFFFFFFFFFFFFFF00;
      }
      else
      {
        LOBYTE(v11) = 0;
        v13 = 0;
      }
    }
    else
    {
LABEL_28:
      LOBYTE(v11) = 0;
      v13 = 0;
      v10 = v17;
    }
    if (v10 >= 0x41 && __p)
      operator delete[](__p);
  }
  else
  {
    if (!v1 || (a1 & 4) != 0)
      goto LABEL_27;
    v12 = *(void **)(*(_QWORD *)v1 + 136);
    if (v12 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      v1 = 0;
    __p = v1;
    if (v12 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      mlir::IntegerAttr::getValue(&__p, (llvm::APInt *)&v20);
      if (v21 > 0x40)
      {
        v11 = *(_QWORD *)v20;
        operator delete[](v20);
      }
      else
      {
        v11 = (uint64_t)((_QWORD)v20 << -(uint64_t)v21) >> -(uint64_t)v21;
      }
      v13 = v11 & 0xFFFFFFFFFFFFFF00;
    }
    else
    {
LABEL_27:
      LOBYTE(v11) = 0;
      v13 = 0;
    }
  }
  return v13 & 0xFFFFFFFFFFFFFF00 | v11;
}

BOOL mlir::isConstantIntValue(uint64_t a1, uint64_t a2)
{
  unint64_t ConstantIntValue;
  char v4;

  ConstantIntValue = mlir::getConstantIntValue(a1);
  return v4 && ConstantIntValue == a2;
}

uint64_t mlir::isEqualConstantIntOrValue(uint64_t a1, uint64_t a2)
{
  unint64_t ConstantIntValue;
  char v5;
  char v6;
  unint64_t v7;
  char v8;
  _BOOL4 v10;

  ConstantIntValue = mlir::getConstantIntValue(a1);
  v6 = v5;
  v7 = mlir::getConstantIntValue(a2);
  if (v6 && v8 && ConstantIntValue == v7)
    return 1;
  v10 = (a1 & 0xFFFFFFFFFFFFFFF8) != 0
     && (a1 & 0xFFFFFFFFFFFFFFF8) == (a2 & (a2 << 61 >> 63) & 0xFFFFFFFFFFFFFFF8);
  return (a1 & 4) != 0 && v10;
}

void mlir::getMixedValues(void **a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, mlir::Builder *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v7;
  void *v10;
  unsigned int v11;
  void *v12;
  void *v13;
  unint64_t v14;
  unint64_t v15;
  _QWORD v16[3];

  LODWORD(v7) = a2;
  v16[2] = *MEMORY[0x1E0C80C00];
  v16[0] = a3;
  v16[1] = a4;
  v10 = (void *)(a6 + 16);
  *(_QWORD *)a6 = a6 + 16;
  *(_QWORD *)(a6 + 8) = 0x600000000;
  if (a2 >= 7)
    llvm::SmallVectorBase<unsigned int>::grow_pod(a6, v10, a2, 8);
  v7 = v7;
  if ((_DWORD)v7)
  {
    v11 = 0;
    do
    {
      v13 = *a1++;
      v12 = v13;
      if (v13 == (void *)0x8000000000000000)
        v14 = mlir::ValueRange::dereference_iterator(v16, v11++) | 4;
      else
        v14 = mlir::Builder::getI64IntegerAttr(a5, v12) & 0xFFFFFFFFFFFFFFFBLL;
      v15 = *(unsigned int *)(a6 + 8);
      if (v15 >= *(unsigned int *)(a6 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a6, v10, v15 + 1, 8);
        v15 = *(unsigned int *)(a6 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a6 + 8 * v15) = v14;
      ++*(_DWORD *)(a6 + 8);
      --v7;
    }
    while (v7);
  }
}

uint64_t mlir::constantTripCount(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t ConstantIntValue;
  char v6;
  unint64_t v7;
  unint64_t v8;
  char v9;
  unint64_t v10;
  int64_t v11;
  char v12;
  int64_t v13;
  int64_t v14;

  if (a1 == a2)
    return 0;
  ConstantIntValue = mlir::getConstantIntValue(a1);
  if (!v6)
    return 0;
  v7 = ConstantIntValue;
  v8 = mlir::getConstantIntValue(a2);
  if (!v9)
    return 0;
  v10 = v8;
  v11 = mlir::getConstantIntValue(a3);
  if (!v12)
    return 0;
  v13 = v10 - v7;
  if (v10 == v7 || (uint64_t)(v10 - v7) < 1 == v11 > 0)
    return v13 / v11;
  if (v11 <= 0)
    v14 = v13 + 1;
  else
    v14 = v13 - 1;
  return v14 / v11 + 1;
}

uint64_t mlir::foldDynamicIndexList(uint64_t a1, char a2)
{
  uint64_t v2;
  unint64_t *v3;
  char v4;
  uint64_t v5;
  uint64_t DefiningOp;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v14;
  void *v15;
  uint64_t v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v2)
  {
    v3 = *(unint64_t **)a1;
    v4 = 0;
    v5 = 8 * v2;
    if ((a2 & 1) != 0)
    {
      do
      {
        if ((*v3 & 4) != 0)
        {
          v14 = *v3 & 0xFFFFFFFFFFFFFFF8;
          DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v14);
          if (DefiningOp)
          {
            v7 = DefiningOp;
            if ((mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)) & 1) != 0)
            {
              v15 = v17;
              v16 = 0x100000000;
              mlir::Operation::fold(v7, 0, 0, (uint64_t)&v15);
              v8 = *(_QWORD *)v15;
              if (v15 != v17)
                free(v15);
              v9 = v8 & 0xFFFFFFFFFFFFFFF8;
              if (v9 && (mlir::getConstantIntValue(v9) & 0x8000000000000000) == 0)
              {
                *v3 = v9;
                v4 = 1;
              }
            }
          }
        }
        ++v3;
        v5 -= 8;
      }
      while (v5);
    }
    else
    {
      do
      {
        if ((*v3 & 4) != 0)
        {
          v14 = *v3 & 0xFFFFFFFFFFFFFFF8;
          v10 = mlir::Value::getDefiningOp((mlir::Value *)&v14);
          if (v10)
          {
            v11 = v10;
            if (mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(v10 + 48)))
            {
              v15 = v17;
              v16 = 0x100000000;
              mlir::Operation::fold(v11, 0, 0, (uint64_t)&v15);
              v12 = *(_QWORD *)v15;
              if (v15 != v17)
                free(v15);
              if ((v12 & 0xFFFFFFFFFFFFFFF8) != 0)
              {
                *v3 = v12 & 0xFFFFFFFFFFFFFFF8;
                v4 = 1;
              }
            }
          }
        }
        ++v3;
        v5 -= 8;
      }
      while (v5);
    }
  }
  else
  {
    v4 = 0;
  }
  return v4 & 1;
}

mlir::func::FuncDialect *mlir::func::FuncDialect::FuncDialect(mlir::func::FuncDialect *this, mlir::MLIRContext *a2)
{
  _QWORD *v3;

  v3 = (_QWORD *)mlir::Dialect::Dialect((uint64_t)this, (uint64_t)"func", 4, (uint64_t)a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::FuncDialect,void>::id);
  *v3 = off_1E0E4D878;
  mlir::Dialect::addOperations<mlir::func::CallIndirectOp,mlir::func::CallOp,mlir::func::ConstantOp,mlir::func::FuncOp,mlir::func::ReturnOp>((uint64_t)v3);
  mlir::Dialect::declarePromisedInterface<mlir::func::FuncDialect,mlir::DialectInlinerInterface>((uint64_t)this);
  return this;
}

void mlir::func::FuncDialect::~FuncDialect(llvm **this)
{
  mlir::Dialect::~Dialect(this);
}

void sub_18038802C(void *__p)
{
  operator delete(__p);
}

uint64_t mlir::Dialect::addOperations<mlir::func::CallIndirectOp,mlir::func::CallOp,mlir::func::ConstantOp,mlir::func::FuncOp,mlir::func::ReturnOp>(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t result;
  _QWORD *v10;

  mlir::RegisteredOperationName::insert<mlir::func::CallIndirectOp>(a1);
  v2 = operator new(0x70uLL);
  v10 = mlir::RegisteredOperationName::Model<mlir::func::CallOp>::Model(v2, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v10, (uint64_t)&mlir::func::CallOp::getAttributeNames(void)::attrNames, 1);
  v3 = (uint64_t)v10;
  v10 = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = operator new(0x70uLL);
  v10 = mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::Model(v4, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v10, (uint64_t)&mlir::func::ConstantOp::getAttributeNames(void)::attrNames, 1);
  v5 = (uint64_t)v10;
  v10 = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = operator new(0x70uLL);
  v10 = mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::Model(v6, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v10, (uint64_t)&mlir::func::FuncOp::getAttributeNames(void)::attrNames, 5);
  v7 = (uint64_t)v10;
  v10 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  v8 = operator new(0x70uLL);
  v10 = mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::Model(v8, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v10, 0, 0);
  result = (uint64_t)v10;
  v10 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t mlir::Dialect::declarePromisedInterface<mlir::func::FuncDialect,mlir::DialectInlinerInterface>(uint64_t a1)
{
  uint64_t *v1;
  unsigned __int8 v2;
  uint64_t *v3;
  unint64_t v4;
  uint64_t result;
  int v6;
  unint64_t v7;
  unint64_t v8;
  char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  unint64_t v15;
  _QWORD *v16;

  v1 = (uint64_t *)(a1 + 72);
  v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v2 & 1) == 0)
  {
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    if (v6)
    {
      v14 = (uint64_t *)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::DialectInlinerInterface]";
      v15 = 79;
      v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v7)
        v8 = v7;
      else
        v8 = v15;
      v9 = (char *)v14 + v8;
      v10 = v15 - v8;
      if (v15 - v8 >= 0x12)
        v11 = 18;
      else
        v11 = v15 - v8;
      v12 = v10 - v11;
      if (v12 >= v12 - 1)
        v13 = v12 - 1;
      else
        v13 = v12;
      mlir::detail::TypeIDResolver<mlir::DialectInlinerInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v4 = v3[157];
  v14 = &mlir::detail::TypeIDResolver<mlir::func::FuncDialect,void>::id;
  v15 = v4;
  v16 = 0;
  result = llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>,std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::LookupBucketFor<std::pair<mlir::TypeID,mlir::TypeID>>(v1, (uint64_t *)&v14, &v16);
  if ((result & 1) == 0)
  {
    result = (uint64_t)llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>,std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::InsertIntoBucketImpl<std::pair<mlir::TypeID,mlir::TypeID>>((uint64_t)v1, (uint64_t)&v14, (uint64_t *)&v14, v16);
    *(_QWORD *)result = v14;
    *(_QWORD *)(result + 8) = v15;
  }
  return result;
}

mlir::GenericProgramPoint *mlir::func::FuncDialect::materializeConstant(uint64_t a1, mlir::OpBuilder *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;

  v12 = a4;
  if (*(_UNKNOWN **)(*(_QWORD *)a3 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
    v5 = a3;
  else
    v5 = 0;
  v13 = v5;
  if (!v5)
    return 0;
  mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v13);
  if (v10 || *(_UNKNOWN **)(*(_QWORD *)a4 + 136) != &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
    return 0;
  v13 = a3;
  return mlir::OpBuilder::create<mlir::func::ConstantOp,mlir::Type &,mlir::FlatSymbolRefAttr>(a2, a5, &v12, &v13);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::func::ConstantOp,mlir::Type &,mlir::FlatSymbolRefAttr>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  mlir::GenericProgramPoint *v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  uint64_t v20[4];
  __int16 v21;
  _QWORD v22[8];
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  _QWORD v26[29];

  v26[28] = *MEMORY[0x1E0C80C00];
  v17 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"func.constant", (const unsigned __int8 *)0xD, Context);
  if (!v10)
  {
    v21 = 1283;
    v20[2] = (uint64_t)"func.constant";
    v20[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v19 = 259;
    llvm::operator+(v20, (uint64_t *)&v18, (uint64_t)v22);
    llvm::report_fatal_error((llvm::Twine *)v22, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v9);
  v11 = *a3;
  v12 = *a4;
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(v22) = v12;
  v13 = v24;
  if (v24 >= v25)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v23, v26, v24 + 1, 8);
    v13 = v24;
  }
  *(_QWORD *)(v23 + 8 * v13) = v11;
  ++v24;
  v14 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (*(_UNKNOWN **)(*((_QWORD *)v14 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::func::ConstantOp,void>::id)
    v15 = v14;
  else
    v15 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v15;
}

uint64_t mlir::func::CallOp::verifySymbolUses(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t InherentAttr;
  char v6;
  uint64_t v7;
  void *v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD **v12;
  _QWORD **v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const void ***v23;
  const void ***v24;
  const void ***v25;
  __int128 v26;
  const void **AttrData;
  const char *v28;
  const void ***v29;
  const void ***v30;
  const void ***v31;
  __int128 v32;
  _QWORD **v33;
  _QWORD **v34;
  void *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  unint64_t v39;
  int Kind;
  int v41;
  const char *v42;
  int v43;
  uint64_t v44;
  unint64_t v45;
  int NumResults;
  int v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  const char *v52;
  const void **v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t *Results;
  uint64_t v57;
  _QWORD **v58;
  _QWORD **v59;
  void *v60;
  _QWORD *v61;
  void *v62;
  void *v63;
  uint64_t Inputs;
  const void ***v65;
  const void ***v66;
  const void ***v67;
  __int128 v68;
  uint64_t v69;
  const void ***v70;
  const void ***v71;
  const void ***v72;
  __int128 v73;
  unint64_t v74;
  const void ***v75;
  const void ***v76;
  const void ***v77;
  __int128 v78;
  uint64_t v79;
  const void ***v80;
  const void ***v81;
  const void ***v82;
  __int128 v83;
  uint64_t v84;
  const void ***v85;
  const void ***v86;
  const void ***v87;
  __int128 v88;
  _QWORD **v89;
  _QWORD **v90;
  void *v91;
  _QWORD *v92;
  void *v93;
  void *v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unsigned int v100;
  unsigned int v101;
  uint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  _QWORD **v106;
  _QWORD **v107;
  void *v108;
  _QWORD *v109;
  void *v110;
  void *v111;
  unint64_t v113;
  unint64_t v114;
  BOOL v115;
  unint64_t v116;
  unint64_t v117;
  BOOL v118;
  unint64_t v119;
  BOOL v120;
  int64_t v121;
  int64_t v122;
  int64_t v123;
  int64_t v124;
  int64_t v125;
  int64_t v126;
  int64_t v127;
  unsigned int v128;
  uint64_t Value;
  const void **v130;
  const char *v131;
  uint64_t v132;
  __int16 v133;
  uint64_t v134;
  const void **v135;
  const char *v136;
  uint64_t v137;
  __int16 v138;
  uint64_t v139;
  uint64_t v140[2];
  const void ***v141;
  unsigned int v142;
  unsigned int v143;
  _BYTE v144[96];
  _QWORD *v145;
  _QWORD *v146;
  _QWORD **v147;
  _QWORD **v148;
  char v149;
  uint64_t v150;

  v150 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (*(_BYTE *)(*a1 + 47) && (InherentAttr = mlir::Operation::getInherentAttr(*a1, (uint64_t)"callee", 6), v6))
  {
    v7 = InherentAttr;
    if (!InherentAttr)
      goto LABEL_10;
  }
  else
  {
    v7 = mlir::DictionaryAttr::get(v4 + 56, "callee", 6uLL);
    if (!v7)
    {
LABEL_10:
      v134 = 0;
      goto LABEL_11;
    }
  }
  v8 = *(void **)(*(_QWORD *)v7 + 136);
  v9 = v8 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id;
  if (v8 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
    v10 = v7;
  else
    v10 = 0;
  v139 = v10;
  if (!v9)
    goto LABEL_10;
  mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v139);
  if (v20)
    v21 = 0;
  else
    v21 = v7;
  v134 = v21;
  if (!v21)
  {
LABEL_11:
    v135 = (const void **)"requires a 'callee' symbol reference attribute";
    v138 = 259;
    mlir::OpState::emitOpError((uint64_t **)a1, &v135, (uint64_t)&v139);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
    if (v139)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
    if (v149)
    {
      v12 = v147;
      if (v147)
      {
        v13 = v148;
        v14 = v147;
        if (v148 != v147)
        {
          do
            v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          v14 = v147;
        }
        v148 = v12;
        operator delete(v14);
      }
      v15 = v145;
      if (!v145)
        goto LABEL_147;
      v16 = v146;
      v17 = v145;
      if (v146 == v145)
      {
LABEL_146:
        v146 = v15;
        operator delete(v17);
LABEL_147:
        if (v141 != (const void ***)v144)
          free(v141);
        return v11;
      }
      do
      {
        v19 = (void *)*--v16;
        v18 = v19;
        *v16 = 0;
        if (v19)
          operator delete[](v18);
      }
      while (v16 != v15);
LABEL_145:
      v17 = v145;
      goto LABEL_146;
    }
    return v11;
  }
  v22 = mlir::SymbolTableCollection::lookupNearestSymbolFrom(a2, (mlir::SymbolTable *)*a1, v21);
  if (v22 && *(_UNKNOWN **)(*(_QWORD *)(v22 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id)
  {
    if (HIBYTE(*(_DWORD *)(v22 + 44)))
      v39 = v22 + 16 * (((unint64_t)*(unsigned int *)(v22 + 44) >> 23) & 1) + 64;
    else
      v39 = 0;
    v139 = *(_QWORD *)(v39 + 8);
    Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v139);
    Kind = mlir::AffineExpr::getKind((mlir::AffineExpr *)&Value);
    if ((*(_BYTE *)(*a1 + 46) & 0x80) != 0)
    {
      if (Kind == *(_DWORD *)(*a1 + 68))
        goto LABEL_57;
    }
    else if (!Kind)
    {
LABEL_57:
      v41 = mlir::AffineExpr::getKind((mlir::AffineExpr *)&Value);
      if (v41)
      {
        v42 = 0;
        v43 = v41;
        v44 = 24;
        while (1)
        {
          v45 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a1 + 72) + v44) + 8) & 0xFFFFFFFFFFFFFFF8;
          if (*(_QWORD *)(mlir::FunctionType::getInputs((mlir::FunctionType *)&Value) + 8 * (_QWORD)v42) != v45)
            break;
          ++v42;
          v44 += 32;
          if (v43 == (_DWORD)v42)
            goto LABEL_61;
        }
        v135 = (const void **)"operand type mismatch: expected operand type ";
        v138 = 259;
        mlir::OpState::emitOpError((uint64_t **)a1, &v135, (uint64_t)&v139);
        Inputs = mlir::FunctionType::getInputs((mlir::FunctionType *)&Value);
        if (v139)
        {
          v65 = &v130;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v130, *(_QWORD *)(Inputs + 8 * (_QWORD)v42));
          v66 = v141;
          if (v142 >= v143)
          {
            v113 = v142 + 1;
            if (v141 <= &v130 && &v141[3 * v142] > &v130)
            {
              v123 = (char *)&v130 - (char *)v141;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v113, 24);
              v66 = v141;
              v65 = (const void ***)((char *)v141 + v123);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v113, 24);
              v65 = &v130;
              v66 = v141;
            }
          }
          v67 = &v66[3 * v142];
          v68 = *(_OWORD *)v65;
          v67[2] = v65[2];
          *(_OWORD *)v67 = v68;
          v69 = ++v142;
          if (v139)
          {
            LODWORD(v130) = 3;
            v131 = ", but provided ";
            v132 = 15;
            v70 = &v130;
            v71 = v141;
            if (v69 >= v143)
            {
              v114 = v69 + 1;
              v115 = &v141[3 * v69] > &v130;
              if (v141 <= &v130 && v115)
              {
                v124 = (char *)&v130 - (char *)v141;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v114, 24);
                v71 = v141;
                v70 = (const void ***)((char *)v141 + v124);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v114, 24);
                v70 = &v130;
                v71 = v141;
              }
            }
            v72 = &v71[3 * v142];
            v73 = *(_OWORD *)v70;
            v72[2] = v70[2];
            *(_OWORD *)v72 = v73;
            ++v142;
            if (v139)
            {
              v74 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a1 + 72) + v44) + 8) & 0xFFFFFFFFFFFFFFF8;
              v75 = &v130;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v130, v74);
              v76 = v141;
              if (v142 >= v143)
              {
                v116 = v142 + 1;
                if (v141 <= &v130 && &v141[3 * v142] > &v130)
                {
                  v125 = (char *)&v130 - (char *)v141;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v116, 24);
                  v76 = v141;
                  v75 = (const void ***)((char *)v141 + v125);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v116, 24);
                  v75 = &v130;
                  v76 = v141;
                }
              }
              v77 = &v76[3 * v142];
              v78 = *(_OWORD *)v75;
              v77[2] = v75[2];
              *(_OWORD *)v77 = v78;
              v79 = ++v142;
              if (v139)
              {
                LODWORD(v130) = 3;
                v131 = " for operand number ";
                v132 = 20;
                v80 = &v130;
                v81 = v141;
                if (v79 >= v143)
                {
                  v117 = v79 + 1;
                  v118 = &v141[3 * v79] > &v130;
                  if (v141 <= &v130 && v118)
                  {
                    v126 = (char *)&v130 - (char *)v141;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v117, 24);
                    v81 = v141;
                    v80 = (const void ***)((char *)v141 + v126);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v117, 24);
                    v80 = &v130;
                    v81 = v141;
                  }
                }
                v82 = &v81[3 * v142];
                v83 = *(_OWORD *)v80;
                v82[2] = v80[2];
                *(_OWORD *)v82 = v83;
                v84 = ++v142;
                if (v139)
                {
                  LODWORD(v130) = 5;
                  v131 = v42;
                  v85 = &v130;
                  v86 = v141;
                  if (v84 >= v143)
                  {
                    v119 = v84 + 1;
                    v120 = &v141[3 * v84] > &v130;
                    if (v141 <= &v130 && v120)
                    {
                      v127 = (char *)&v130 - (char *)v141;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v119, 24);
                      v86 = v141;
                      v85 = (const void ***)((char *)v141 + v127);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v119, 24);
                      v85 = &v130;
                      v86 = v141;
                    }
                  }
                  v87 = &v86[3 * v142];
                  v88 = *(_OWORD *)v85;
                  v87[2] = v85[2];
                  *(_OWORD *)v87 = v88;
                  ++v142;
                }
              }
            }
          }
        }
        v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
        if (v139)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
        if (v149)
        {
          v89 = v147;
          if (v147)
          {
            v90 = v148;
            v91 = v147;
            if (v148 != v147)
            {
              do
                v90 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v90 - 1);
              while (v90 != v89);
              v91 = v147;
            }
            v148 = v89;
            operator delete(v91);
          }
          v15 = v145;
          if (!v145)
            goto LABEL_147;
          v92 = v146;
          v17 = v145;
          if (v146 == v145)
            goto LABEL_146;
          do
          {
            v94 = (void *)*--v92;
            v93 = v94;
            *v92 = 0;
            if (v94)
              operator delete[](v93);
          }
          while (v92 != v15);
          goto LABEL_145;
        }
        return v11;
      }
LABEL_61:
      if (mlir::FunctionType::getNumResults((mlir::FunctionType *)&Value) != *(_DWORD *)(*a1 + 36))
      {
        v135 = (const void **)"incorrect number of results for callee";
        v138 = 259;
        mlir::OpState::emitOpError((uint64_t **)a1, &v135, (uint64_t)&v139);
        v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
        if (v139)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
        if (v149)
        {
          v58 = v147;
          if (v147)
          {
            v59 = v148;
            v60 = v147;
            if (v148 != v147)
            {
              do
                v59 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v59 - 1);
              while (v59 != v58);
              v60 = v147;
            }
            v148 = v58;
            operator delete(v60);
          }
          v15 = v145;
          if (!v145)
            goto LABEL_147;
          v61 = v146;
          v17 = v145;
          if (v146 == v145)
            goto LABEL_146;
          do
          {
            v63 = (void *)*--v61;
            v62 = v63;
            *v61 = 0;
            if (v63)
              operator delete[](v62);
          }
          while (v61 != v15);
          goto LABEL_145;
        }
        return v11;
      }
      v128 = 0;
      NumResults = mlir::FunctionType::getNumResults((mlir::FunctionType *)&Value);
      if (NumResults)
      {
        v47 = NumResults;
        v48 = *(_QWORD *)(*a1 - 8) & 0xFFFFFFFFFFFFFFF8;
        if (*(_QWORD *)mlir::FunctionType::getResults((mlir::FunctionType *)&Value) != v48)
        {
LABEL_64:
          v130 = (const void **)"result type mismatch at index ";
          v133 = 259;
          mlir::OpState::emitOpError((uint64_t **)a1, &v130, (uint64_t)&v135);
          v49 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)&v135, &v128);
          mlir::InFlightDiagnostic::InFlightDiagnostic((uint64_t)&v139, v49);
          mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v135);
          v50 = mlir::Diagnostic::attachNote(v140, 0, 0);
          v51 = mlir::Diagnostic::operator<<(v50, "      op result types: ");
          v52 = (const char *)*(unsigned int *)(*a1 + 36);
          v53 = (const void **)(*a1 - 16);
          if (!(_DWORD)v52)
            v53 = 0;
          v130 = v53;
          v131 = v52;
          mlir::OperandRange::getTypes((uint64_t *)&v130, (uint64_t *)&v135);
          mlir::Diagnostic::operator<<<mlir::ValueTypeRange<mlir::ResultRange>,mlir::Type>(v51, (uint64_t)&v135);
          v54 = mlir::Diagnostic::attachNote(v140, 0, 0);
          v55 = mlir::Diagnostic::operator<<(v54, "function result types: ");
          Results = (uint64_t *)mlir::FunctionType::getResults((mlir::FunctionType *)&Value);
          v135 = (const void **)", ";
          llvm::interleave<mlir::Type const*,mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<mlir::Type>>(llvm::ArrayRef<mlir::Type> const&,char const*)::{lambda(llvm::ArrayRef<mlir::Type> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<mlir::Type>>(llvm::ArrayRef<mlir::Type> const&,char const*)::{lambda(void)#1},void>(Results, &Results[v57], v55, v55, (const char **)&v135);
          v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
          mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v139);
          return v11;
        }
        v128 = 1;
        if (v47 != 1)
        {
          v95 = *(_QWORD *)(*a1 - 24) & 0xFFFFFFFFFFFFFFF8;
          if (*(_QWORD *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 8) != v95)
            goto LABEL_64;
          v128 = 2;
          if (v47 != 2)
          {
            v96 = *(_QWORD *)(*a1 - 40) & 0xFFFFFFFFFFFFFFF8;
            if (*(_QWORD *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 16) != v96)
              goto LABEL_64;
            v128 = 3;
            if (v47 != 3)
            {
              v97 = *(_QWORD *)(*a1 - 56) & 0xFFFFFFFFFFFFFFF8;
              if (*(_QWORD *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 24) != v97)
                goto LABEL_64;
              v128 = 4;
              if (v47 != 4)
              {
                v98 = *(_QWORD *)(*a1 - 72) & 0xFFFFFFFFFFFFFFF8;
                if (*(_QWORD *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 32) != v98)
                  goto LABEL_64;
                v128 = 5;
                if (v47 != 5)
                {
                  v99 = *(_QWORD *)(*a1 - 88) & 0xFFFFFFFFFFFFFFF8;
                  if (*(_QWORD *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 40) != v99)
                    goto LABEL_64;
                  v128 = 6;
                  if (v47 != 6)
                  {
                    v100 = 6;
                    while (1)
                    {
                      v101 = v100 + 1;
                      v102 = *a1 - 16 * (v100 + 1);
                      if (v100 > 5)
                        v102 = *a1 - 24 * (v100 - 5) - 96;
                      v103 = *(_QWORD *)(v102 + 8) & 0xFFFFFFFFFFFFFFF8;
                      if (*(_QWORD *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 8 * v100) != v103)
                        break;
                      v128 = ++v100;
                      if (v47 == v101)
                        return 1;
                    }
                    goto LABEL_64;
                  }
                }
              }
            }
          }
        }
      }
      return 1;
    }
    v135 = (const void **)"incorrect number of operands for callee";
    v138 = 259;
    mlir::OpState::emitOpError((uint64_t **)a1, &v135, (uint64_t)&v139);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
    if (v139)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
    if (v149)
    {
      v106 = v147;
      if (v147)
      {
        v107 = v148;
        v108 = v147;
        if (v148 != v147)
        {
          do
            v107 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v107 - 1);
          while (v107 != v106);
          v108 = v147;
        }
        v148 = v106;
        operator delete(v108);
      }
      v15 = v145;
      if (!v145)
        goto LABEL_147;
      v109 = v146;
      v17 = v145;
      if (v146 == v145)
        goto LABEL_146;
      do
      {
        v111 = (void *)*--v109;
        v110 = v111;
        *v109 = 0;
        if (v111)
          operator delete[](v110);
      }
      while (v109 != v15);
      goto LABEL_145;
    }
    return v11;
  }
  v133 = 257;
  mlir::OpState::emitOpError((uint64_t **)a1, &v130, (uint64_t)&v139);
  if (v139)
  {
    LODWORD(v135) = 3;
    v136 = "'";
    v137 = 1;
    v23 = &v135;
    v24 = v141;
    if (v142 >= v143)
    {
      v104 = v142 + 1;
      if (v141 <= &v135 && &v141[3 * v142] > &v135)
      {
        v121 = (char *)&v135 - (char *)v141;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v104, 24);
        v24 = v141;
        v23 = (const void ***)((char *)v141 + v121);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v104, 24);
        v23 = &v135;
        v24 = v141;
      }
    }
    v25 = &v24[3 * v142];
    v26 = *(_OWORD *)v23;
    v25[2] = v23[2];
    *(_OWORD *)v25 = v26;
    ++v142;
  }
  v135 = (const void **)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v134);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v135);
  if (v139)
  {
    v138 = 261;
    v135 = AttrData;
    v136 = v28;
    mlir::Diagnostic::operator<<((uint64_t)v140, &v135);
    if (v139)
    {
      LODWORD(v135) = 3;
      v136 = "' does not reference a valid function";
      v137 = 37;
      v29 = &v135;
      v30 = v141;
      if (v142 >= v143)
      {
        v105 = v142 + 1;
        if (v141 <= &v135 && &v141[3 * v142] > &v135)
        {
          v122 = (char *)&v135 - (char *)v141;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v105, 24);
          v30 = v141;
          v29 = (const void ***)((char *)v141 + v122);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v105, 24);
          v29 = &v135;
          v30 = v141;
        }
      }
      v31 = &v30[3 * v142];
      v32 = *(_OWORD *)v29;
      v31[2] = v29[2];
      *(_OWORD *)v31 = v32;
      ++v142;
    }
  }
  v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
  if (v139)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
  if (v149)
  {
    v33 = v147;
    if (v147)
    {
      v34 = v148;
      v35 = v147;
      if (v148 != v147)
      {
        do
          v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
        while (v34 != v33);
        v35 = v147;
      }
      v148 = v33;
      operator delete(v35);
    }
    v15 = v145;
    if (!v145)
      goto LABEL_147;
    v36 = v146;
    v17 = v145;
    if (v146 == v145)
      goto LABEL_146;
    do
    {
      v38 = (void *)*--v36;
      v37 = v38;
      *v36 = 0;
      if (v38)
        operator delete[](v37);
    }
    while (v36 != v15);
    goto LABEL_145;
  }
  return v11;
}

uint64_t mlir::func::FuncOp::getFunctionType(mlir::func::FuncOp *this)
{
  unint64_t v1;
  uint64_t v3;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  v3 = *(_QWORD *)(v1 + 8);
  return mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v3);
}

uint64_t mlir::Diagnostic::operator<<<mlir::ValueTypeRange<mlir::ResultRange>,mlir::Type>(uint64_t a1, uint64_t a2)
{
  const char *v4;

  v4 = ", ";
  llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,mlir::Diagnostic& mlir::Diagnostic::appendRange<mlir::ValueTypeRange<mlir::ResultRange>>(mlir::ValueTypeRange<mlir::ResultRange> const&,char const*)::{lambda(mlir::ValueTypeRange<mlir::ResultRange> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<mlir::ValueTypeRange<mlir::ResultRange>>(mlir::ValueTypeRange<mlir::ResultRange> const&,char const*)::{lambda(void)#1},void>(*(mlir::detail::OpResultImpl **)a2, *(_QWORD *)(a2 + 8), *(mlir::detail::OpResultImpl **)(a2 + 16), *(_QWORD *)(a2 + 24), a1, a1, &v4);
  return a1;
}

uint64_t mlir::func::CallIndirectOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t DefiningOp;
  uint64_t v6;
  BOOL v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  mlir::GenericProgramPoint *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17[2];
  _QWORD v18[3];

  v18[2] = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 24);
  v14 = 0;
  v15 = v4;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (!DefiningOp)
    return 0;
  v6 = DefiningOp;
  if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
    return 0;
  v17[0] = v18;
  v17[1] = (void *)0x100000000;
  mlir::Operation::fold(v6, 0, 0, (uint64_t)v17);
  v7 = (*(_QWORD *)v17[0] & 0xFFFFFFFFFFFFFFF8) == 0
    || *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v17[0] & 0xFFFFFFFFFFFFFFF8) + 136) != (_QWORD)&mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id;
  if (!v7)
    v14 = *(_QWORD *)v17[0] & 0xFFFFFFFFFFFFFFF8;
  if (v17[0] != v18)
    free(v17[0]);
  if (v7)
    return 0;
  v9 = *(unsigned int *)(a1 + 36);
  v10 = a1 - 16;
  if (!(_DWORD)v9)
    v10 = 0;
  v15 = v10;
  v16 = v9;
  mlir::OperandRange::getTypes(&v15, (uint64_t *)v17);
  if ((*(_BYTE *)(a1 + 46) & 0x80) != 0)
  {
    v11 = *(_QWORD *)(a1 + 72);
    v12 = *(unsigned int *)(a1 + 68) - 1;
  }
  else
  {
    v11 = 0;
    v12 = -1;
  }
  v15 = v11 + 32;
  v16 = v12;
  v13 = mlir::OpBuilder::create<mlir::func::CallOp,mlir::SymbolRefAttr &,mlir::ValueTypeRange<mlir::ResultRange>,mlir::OperandRange>((mlir::OpBuilder *)(a2 + 8), *(_QWORD *)(a1 + 24), (uint64_t *)&v14, (uint64_t *)v17, (uint64_t)&v15);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a2 + 32))(a2, a1, v13);
  return 1;
}

uint64_t mlir::func::ConstantOp::verify(uint64_t **this)
{
  const void **AttrData;
  const char *v3;
  const char *v4;
  uint64_t v5;
  unint64_t v6;
  mlir::Block *v7;
  uint64_t ParentOp;
  mlir::StringAttr *Context;
  uint64_t v10;
  uint64_t v11;
  const void ***v12;
  char *v13;
  char *v14;
  __int128 v15;
  const void ***v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  _QWORD **v21;
  _QWORD **v22;
  void *v23;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  void *v27;
  void *v28;
  unint64_t v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  unint64_t v37;
  unint64_t v38;
  int64_t v39;
  int64_t v40;
  const void **v41;
  __int16 v42;
  const void **v43;
  const char *v44;
  uint64_t v45;
  __int16 v46;
  uint64_t Value;
  const char *v48;
  void *v49;
  unsigned int v50;
  unsigned int v51;
  _BYTE v52[96];
  void *v53;
  _QWORD *v54;
  void *__p;
  _QWORD **v56;
  char v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v43 = (const void **)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v43);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&Value);
  v4 = v3;
  v5 = (uint64_t)*this;
  v6 = *(*this - 1) & 0xFFFFFFFFFFFFFFF8;
  while (1)
  {
    v7 = *(mlir::Block **)(v5 + 16);
    if (!v7)
      break;
    ParentOp = mlir::Block::getParentOp(v7);
    v5 = ParentOp;
    if (!ParentOp
      || *(_UNKNOWN **)(*(_QWORD *)(ParentOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ModuleOp,void>::id)
    {
      goto LABEL_7;
    }
  }
  v5 = 0;
LABEL_7:
  Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v5 + 24));
  LOWORD(v50) = 261;
  Value = (uint64_t)AttrData;
  v48 = v4;
  v10 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)&Value);
  v11 = mlir::SymbolTable::lookupSymbolIn((unsigned int *)v5, v10);
  if (v11 && *(_UNKNOWN **)(*(_QWORD *)(v11 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id)
  {
    if (HIBYTE(*(_DWORD *)(v11 + 44)))
      v29 = v11 + 16 * (((unint64_t)*(unsigned int *)(v11 + 44) >> 23) & 1) + 64;
    else
      v29 = 0;
    Value = *(_QWORD *)(v29 + 8);
    if (mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value) == v6)
      return 1;
    v43 = (const void **)"reference to function with mismatched type";
    v46 = 259;
    mlir::OpState::emitOpError(this, &v43, (uint64_t)&Value);
    v20 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    if (v57)
    {
      v30 = (_QWORD **)__p;
      if (__p)
      {
        v31 = v56;
        v32 = __p;
        if (v56 != __p)
        {
          do
            v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
          while (v31 != v30);
          v32 = __p;
        }
        v56 = v30;
        operator delete(v32);
      }
      v24 = v53;
      if (!v53)
        goto LABEL_49;
      v33 = v54;
      v26 = v53;
      if (v54 == v53)
        goto LABEL_48;
      do
      {
        v35 = (void *)*--v33;
        v34 = v35;
        *v33 = 0;
        if (v35)
          operator delete[](v34);
      }
      while (v33 != v24);
      goto LABEL_47;
    }
  }
  else
  {
    v42 = 257;
    mlir::OpState::emitOpError(this, &v41, (uint64_t)&Value);
    if (Value)
    {
      LODWORD(v43) = 3;
      v44 = "reference to undefined function '";
      v45 = 33;
      v12 = &v43;
      v13 = (char *)v49;
      if (v50 >= v51)
      {
        v37 = v50 + 1;
        if (v49 <= &v43 && (char *)v49 + 24 * v50 > (char *)&v43)
        {
          v39 = (char *)&v43 - (_BYTE *)v49;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v37, 24);
          v13 = (char *)v49;
          v12 = (const void ***)((char *)v49 + v39);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v37, 24);
          v12 = &v43;
          v13 = (char *)v49;
        }
      }
      v14 = &v13[24 * v50];
      v15 = *(_OWORD *)v12;
      *((_QWORD *)v14 + 2) = v12[2];
      *(_OWORD *)v14 = v15;
      ++v50;
      if (Value)
      {
        v46 = 261;
        v43 = AttrData;
        v44 = v4;
        mlir::Diagnostic::operator<<((uint64_t)&v48, &v43);
        if (Value)
        {
          LODWORD(v43) = 3;
          v44 = "'";
          v45 = 1;
          v16 = &v43;
          v17 = (char *)v49;
          if (v50 >= v51)
          {
            v38 = v50 + 1;
            if (v49 <= &v43 && (char *)v49 + 24 * v50 > (char *)&v43)
            {
              v40 = (char *)&v43 - (_BYTE *)v49;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v38, 24);
              v17 = (char *)v49;
              v16 = (const void ***)((char *)v49 + v40);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v38, 24);
              v16 = &v43;
              v17 = (char *)v49;
            }
          }
          v18 = &v17[24 * v50];
          v19 = *(_OWORD *)v16;
          *((_QWORD *)v18 + 2) = v16[2];
          *(_OWORD *)v18 = v19;
          ++v50;
        }
      }
    }
    v20 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    if (v57)
    {
      v21 = (_QWORD **)__p;
      if (__p)
      {
        v22 = v56;
        v23 = __p;
        if (v56 != __p)
        {
          do
            v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
          while (v22 != v21);
          v23 = __p;
        }
        v56 = v21;
        operator delete(v23);
      }
      v24 = v53;
      if (!v53)
        goto LABEL_49;
      v25 = v54;
      v26 = v53;
      if (v54 == v53)
      {
LABEL_48:
        v54 = v24;
        operator delete(v26);
LABEL_49:
        if (v49 != v52)
          free(v49);
        return v20;
      }
      do
      {
        v28 = (void *)*--v25;
        v27 = v28;
        *v25 = 0;
        if (v28)
          operator delete[](v27);
      }
      while (v25 != v24);
LABEL_47:
      v26 = v53;
      goto LABEL_48;
    }
  }
  return v20;
}

uint64_t mlir::func::FuncOp::create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6)
{
  uint64_t v11;
  const mlir::OperationState *v12;
  uint64_t v13;
  mlir::StringAttr *v15[4];
  uint64_t v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v16 = a1;
  v15[0] = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  memset(&v15[1], 0, 24);
  mlir::OperationState::OperationState(v17, v16, (uint64_t)"func.func", 9);
  mlir::func::FuncOp::build(v15, (uint64_t)v17, a2, a3, a4, a5, a6, v11, 0, 0);
  v13 = mlir::Operation::create((mlir::Operation *)v17, v12);
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v13;
}

void mlir::func::FuncOp::build(mlir::StringAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7, uint64_t a8, uint64_t *a9, uint64_t a10)
{
  uint64_t StringAttr;
  mlir::StringAttr *Context;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  _QWORD v22[4];
  __int16 v23;
  const char *v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27[2];

  v23 = 261;
  v22[0] = a3;
  v22[1] = a4;
  StringAttr = mlir::Builder::getStringAttr(a1, (mlir::MLIRContext *)v22);
  Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  v26 = 261;
  v24 = "sym_name";
  v25 = 8;
  v17 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)&v24);
  mlir::NamedAttribute::NamedAttribute(v27, v17, StringAttr);
  mlir::NamedAttrList::push_back(a2 + 112, v27[0], v27[1]);
  v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 96) + 8);
  v19 = mlir::TypeAttr::get(a5);
  mlir::NamedAttribute::NamedAttribute(&v24, v18, v19);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)v24, v25);
  *(_QWORD *)(a2 + 192) = 0;
  v20 = *(unsigned int *)(a2 + 120);
  v21 = v20 + ((16 * a7) >> 4);
  if (v21 > *(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), v21, 16);
    LODWORD(v20) = *(_DWORD *)(a2 + 120);
  }
  if (a7)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 112) + 16 * v20), a6, 16 * a7);
    LODWORD(v20) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v20 + a7;
  mlir::OperationState::addRegion((mlir::OperationState *)a2);
  if (a10)
    mlir::function_interface_impl::addArgAndResultAttrs(a1, a2, a9, a10, 0, 0, **(_QWORD **)(*(_QWORD *)(a2 + 8) + 96), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 96) + 16));
}

uint64_t mlir::func::FuncOp::parse(mlir::AsmParser *a1, uint64_t a2)
{
  char v3;

  return mlir::function_interface_impl::parseFunctionOp(a1, a2, 0, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 96) + 8), (uint64_t (*)(uint64_t, mlir::DictionaryAttr **, void *, _QWORD, void *, _QWORD, _QWORD, void **))llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::func::FuncOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v3, **(_QWORD **)(*(_QWORD *)(a2 + 8) + 96), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 96) + 16));
}

uint64_t mlir::func::ReturnOp::verify(uint64_t **this)
{
  mlir::Block *v2;
  unsigned int *ParentOp;
  unint64_t v4;
  uint64_t Results;
  const char *v6;
  uint64_t v7;
  const char *v8;
  uint64_t *v9;
  const char *v10;
  uint64_t v11;
  uint64_t i;
  uint64_t v13;
  mlir::Operation *v14;
  const void ***v15;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  const void ***v20;
  char *v21;
  char *v22;
  __int128 v23;
  uint64_t v24;
  const void ***v25;
  char *v26;
  char *v27;
  __int128 v28;
  unint64_t v29;
  const void ***v30;
  char *v31;
  char *v32;
  __int128 v33;
  uint64_t v34;
  const void ***v35;
  char *v36;
  char *v37;
  __int128 v38;
  uint64_t v39;
  const void ***v40;
  char *v41;
  char *v42;
  __int128 v43;
  uint64_t v44;
  const void ***v45;
  char *v46;
  char *v47;
  __int128 v48;
  uint64_t v49;
  const void ***v50;
  char *v51;
  char *v52;
  __int128 v53;
  const void **AttrData;
  const char *v55;
  _QWORD **v56;
  _QWORD **v57;
  void *v58;
  _QWORD *v59;
  _QWORD *v60;
  void *v61;
  void *v62;
  void *v63;
  mlir::Operation *v64;
  unsigned int v65;
  const void ***p_SymbolName;
  char *v67;
  char *v68;
  __int128 v69;
  uint64_t v70;
  const void ***v71;
  char *v72;
  char *v73;
  __int128 v74;
  const void **v75;
  const char *v76;
  const void ***v77;
  char *v78;
  char *v79;
  __int128 v80;
  uint64_t v81;
  const void ***v82;
  char *v83;
  char *v84;
  __int128 v85;
  _QWORD **v86;
  _QWORD **v87;
  void *v88;
  _QWORD *v89;
  void *v90;
  void *v91;
  unint64_t v93;
  unint64_t v94;
  BOOL v95;
  unint64_t v96;
  unint64_t v97;
  BOOL v98;
  unint64_t v99;
  unint64_t v100;
  BOOL v101;
  unint64_t v102;
  BOOL v103;
  unint64_t v104;
  unint64_t v105;
  BOOL v106;
  unint64_t v107;
  unint64_t v108;
  BOOL v109;
  unint64_t v110;
  BOOL v111;
  int64_t v112;
  int64_t v113;
  int64_t v114;
  int64_t v115;
  int64_t v116;
  int64_t v117;
  int64_t v118;
  int64_t v119;
  int64_t v120;
  int64_t v121;
  int64_t v122;
  int64_t v123;
  const void **v124[4];
  __int16 v125;
  const void **SymbolName;
  const char *v127;
  uint64_t v128;
  __int16 v129;
  uint64_t Value;
  _BYTE v131[16];
  void *v132;
  unsigned int v133;
  unsigned int v134;
  _BYTE v135[96];
  void *v136;
  _QWORD *v137;
  void *__p;
  _QWORD **v139;
  char v140;
  uint64_t v141;

  v141 = *MEMORY[0x1E0C80C00];
  v2 = (mlir::Block *)(*this)[2];
  if (v2)
    ParentOp = (unsigned int *)mlir::Block::getParentOp(v2);
  else
    ParentOp = 0;
  if (HIBYTE(ParentOp[11]))
    v4 = (unint64_t)&ParentOp[4 * (((unint64_t)ParentOp[11] >> 23) & 1) + 16];
  else
    v4 = 0;
  Value = *(_QWORD *)(v4 + 8);
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value);
  Results = mlir::FunctionType::getResults((mlir::FunctionType *)&Value);
  v7 = Results;
  v8 = v6;
  v9 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    if (v6 == (const char *)*((unsigned int *)v9 + 17))
      goto LABEL_9;
  }
  else if (!v6)
  {
LABEL_9:
    if (!(_DWORD)v6)
      return 1;
    v10 = 0;
    v11 = v9[9];
    for (i = 24;
          *(_QWORD *)(Results + 8 * (_QWORD)v10) == (*(_QWORD *)(*(_QWORD *)(v11 + i) + 8) & 0xFFFFFFFFFFFFFFF8);
          i += 32)
    {
      if ((_DWORD)v6 == (_DWORD)++v10)
        return 1;
    }
    v125 = 257;
    mlir::OpState::emitError(this, (uint64_t)v124, (uint64_t)&Value);
    if (Value)
    {
      LODWORD(SymbolName) = 3;
      v127 = "type of return operand ";
      v128 = 23;
      v15 = &SymbolName;
      v16 = (char *)v132;
      if (v133 >= v134)
      {
        v99 = v133 + 1;
        if (v132 <= &SymbolName && (char *)v132 + 24 * v133 > (char *)&SymbolName)
        {
          v116 = (char *)&SymbolName - (_BYTE *)v132;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v99, 24);
          v16 = (char *)v132;
          v15 = (const void ***)((char *)v132 + v116);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v99, 24);
          v15 = &SymbolName;
          v16 = (char *)v132;
        }
      }
      v17 = &v16[24 * v133];
      v18 = *(_OWORD *)v15;
      *((_QWORD *)v17 + 2) = v15[2];
      *(_OWORD *)v17 = v18;
      v19 = ++v133;
      if (Value)
      {
        LODWORD(SymbolName) = 5;
        v127 = v10;
        v20 = &SymbolName;
        v21 = (char *)v132;
        if (v19 >= v134)
        {
          v100 = v19 + 1;
          v101 = (char *)v132 + 24 * v19 > (char *)&SymbolName;
          if (v132 <= &SymbolName && v101)
          {
            v117 = (char *)&SymbolName - (_BYTE *)v132;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v100, 24);
            v21 = (char *)v132;
            v20 = (const void ***)((char *)v132 + v117);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v100, 24);
            v20 = &SymbolName;
            v21 = (char *)v132;
          }
        }
        v22 = &v21[24 * v133];
        v23 = *(_OWORD *)v20;
        *((_QWORD *)v22 + 2) = v20[2];
        *(_OWORD *)v22 = v23;
        v24 = ++v133;
        if (Value)
        {
          LODWORD(SymbolName) = 3;
          v127 = " (";
          v128 = 2;
          v25 = &SymbolName;
          v26 = (char *)v132;
          if (v24 >= v134)
          {
            v102 = v24 + 1;
            v103 = (char *)v132 + 24 * v24 > (char *)&SymbolName;
            if (v132 <= &SymbolName && v103)
            {
              v118 = (char *)&SymbolName - (_BYTE *)v132;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v102, 24);
              v26 = (char *)v132;
              v25 = (const void ***)((char *)v132 + v118);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v102, 24);
              v25 = &SymbolName;
              v26 = (char *)v132;
            }
          }
          v27 = &v26[24 * v133];
          v28 = *(_OWORD *)v25;
          *((_QWORD *)v27 + 2) = v25[2];
          *(_OWORD *)v27 = v28;
          ++v133;
          if (Value)
          {
            v29 = *(_QWORD *)(*(_QWORD *)((*this)[9] + i) + 8) & 0xFFFFFFFFFFFFFFF8;
            v30 = &SymbolName;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&SymbolName, v29);
            v31 = (char *)v132;
            if (v133 >= v134)
            {
              v104 = v133 + 1;
              if (v132 <= &SymbolName && (char *)v132 + 24 * v133 > (char *)&SymbolName)
              {
                v119 = (char *)&SymbolName - (_BYTE *)v132;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v104, 24);
                v31 = (char *)v132;
                v30 = (const void ***)((char *)v132 + v119);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v104, 24);
                v30 = &SymbolName;
                v31 = (char *)v132;
              }
            }
            v32 = &v31[24 * v133];
            v33 = *(_OWORD *)v30;
            *((_QWORD *)v32 + 2) = v30[2];
            *(_OWORD *)v32 = v33;
            v34 = ++v133;
            if (Value)
            {
              LODWORD(SymbolName) = 3;
              v127 = ") doesn't match function result type (";
              v128 = 38;
              v35 = &SymbolName;
              v36 = (char *)v132;
              if (v34 >= v134)
              {
                v105 = v34 + 1;
                v106 = (char *)v132 + 24 * v34 > (char *)&SymbolName;
                if (v132 <= &SymbolName && v106)
                {
                  v120 = (char *)&SymbolName - (_BYTE *)v132;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v105, 24);
                  v36 = (char *)v132;
                  v35 = (const void ***)((char *)v132 + v120);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v105, 24);
                  v35 = &SymbolName;
                  v36 = (char *)v132;
                }
              }
              v37 = &v36[24 * v133];
              v38 = *(_OWORD *)v35;
              *((_QWORD *)v37 + 2) = v35[2];
              *(_OWORD *)v37 = v38;
              ++v133;
              if (Value)
              {
                v39 = *(_QWORD *)(v7 + 8 * (_QWORD)v10);
                v40 = &SymbolName;
                mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&SymbolName, v39);
                v41 = (char *)v132;
                if (v133 >= v134)
                {
                  v107 = v133 + 1;
                  if (v132 <= &SymbolName && (char *)v132 + 24 * v133 > (char *)&SymbolName)
                  {
                    v121 = (char *)&SymbolName - (_BYTE *)v132;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v107, 24);
                    v41 = (char *)v132;
                    v40 = (const void ***)((char *)v132 + v121);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v107, 24);
                    v40 = &SymbolName;
                    v41 = (char *)v132;
                  }
                }
                v42 = &v41[24 * v133];
                v43 = *(_OWORD *)v40;
                *((_QWORD *)v42 + 2) = v40[2];
                *(_OWORD *)v42 = v43;
                v44 = ++v133;
                if (Value)
                {
                  LODWORD(SymbolName) = 3;
                  v127 = ")";
                  v128 = 1;
                  v45 = &SymbolName;
                  v46 = (char *)v132;
                  if (v44 >= v134)
                  {
                    v108 = v44 + 1;
                    v109 = (char *)v132 + 24 * v44 > (char *)&SymbolName;
                    if (v132 <= &SymbolName && v109)
                    {
                      v122 = (char *)&SymbolName - (_BYTE *)v132;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v108, 24);
                      v46 = (char *)v132;
                      v45 = (const void ***)((char *)v132 + v122);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v108, 24);
                      v45 = &SymbolName;
                      v46 = (char *)v132;
                    }
                  }
                  v47 = &v46[24 * v133];
                  v48 = *(_OWORD *)v45;
                  *((_QWORD *)v47 + 2) = v45[2];
                  *(_OWORD *)v47 = v48;
                  v49 = ++v133;
                  if (Value)
                  {
                    LODWORD(SymbolName) = 3;
                    v127 = " in function @";
                    v128 = 14;
                    v50 = &SymbolName;
                    v51 = (char *)v132;
                    if (v49 >= v134)
                    {
                      v110 = v49 + 1;
                      v111 = (char *)v132 + 24 * v49 > (char *)&SymbolName;
                      if (v132 <= &SymbolName && v111)
                      {
                        v123 = (char *)&SymbolName - (_BYTE *)v132;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v110, 24);
                        v51 = (char *)v132;
                        v50 = (const void ***)((char *)v132 + v123);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v110, 24);
                        v50 = &SymbolName;
                        v51 = (char *)v132;
                      }
                    }
                    v52 = &v51[24 * v133];
                    v53 = *(_OWORD *)v50;
                    *((_QWORD *)v52 + 2) = v50[2];
                    *(_OWORD *)v52 = v53;
                    ++v133;
                  }
                }
              }
            }
          }
        }
      }
    }
    SymbolName = (const void **)mlir::SymbolTable::getSymbolName((mlir::SymbolTable *)ParentOp, v14);
    AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&SymbolName);
    if (Value)
    {
      v129 = 261;
      SymbolName = AttrData;
      v127 = v55;
      mlir::Diagnostic::operator<<((uint64_t)v131, &SymbolName);
    }
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    if (v140)
    {
      v56 = (_QWORD **)__p;
      if (__p)
      {
        v57 = v139;
        v58 = __p;
        if (v139 != __p)
        {
          do
            v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
          while (v57 != v56);
          v58 = __p;
        }
        v139 = v56;
        operator delete(v58);
      }
      v59 = v136;
      if (!v136)
        goto LABEL_76;
      v60 = v137;
      v61 = v136;
      if (v137 == v136)
      {
LABEL_75:
        v137 = v59;
        operator delete(v61);
LABEL_76:
        if (v132 != v135)
          free(v132);
        return v13;
      }
      do
      {
        v63 = (void *)*--v60;
        v62 = v63;
        *v60 = 0;
        if (v63)
          operator delete[](v62);
      }
      while (v60 != v59);
LABEL_74:
      v61 = v136;
      goto LABEL_75;
    }
    return v13;
  }
  v124[0] = (const void **)"has ";
  v125 = 259;
  mlir::OpState::emitOpError(this, v124, (uint64_t)&Value);
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    v65 = *((_DWORD *)*this + 17);
    if (!Value)
      goto LABEL_54;
  }
  else
  {
    v65 = 0;
    if (!Value)
      goto LABEL_54;
  }
  LODWORD(SymbolName) = 5;
  v127 = (const char *)v65;
  p_SymbolName = &SymbolName;
  v67 = (char *)v132;
  if (v133 >= v134)
  {
    v93 = v133 + 1;
    if (v132 <= &SymbolName && (char *)v132 + 24 * v133 > (char *)&SymbolName)
    {
      v112 = (char *)&SymbolName - (_BYTE *)v132;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v93, 24);
      v67 = (char *)v132;
      p_SymbolName = (const void ***)((char *)v132 + v112);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v93, 24);
      p_SymbolName = &SymbolName;
      v67 = (char *)v132;
    }
  }
  v68 = &v67[24 * v133];
  v69 = *(_OWORD *)p_SymbolName;
  *((_QWORD *)v68 + 2) = p_SymbolName[2];
  *(_OWORD *)v68 = v69;
  v70 = ++v133;
  if (Value)
  {
    LODWORD(SymbolName) = 3;
    v127 = " operands, but enclosing function (@";
    v128 = 36;
    v71 = &SymbolName;
    v72 = (char *)v132;
    if (v70 >= v134)
    {
      v94 = v70 + 1;
      v95 = (char *)v132 + 24 * v70 > (char *)&SymbolName;
      if (v132 <= &SymbolName && v95)
      {
        v113 = (char *)&SymbolName - (_BYTE *)v132;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v94, 24);
        v72 = (char *)v132;
        v71 = (const void ***)((char *)v132 + v113);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v94, 24);
        v71 = &SymbolName;
        v72 = (char *)v132;
      }
    }
    v73 = &v72[24 * v133];
    v74 = *(_OWORD *)v71;
    *((_QWORD *)v73 + 2) = v71[2];
    *(_OWORD *)v73 = v74;
    ++v133;
  }
LABEL_54:
  SymbolName = (const void **)mlir::SymbolTable::getSymbolName((mlir::SymbolTable *)ParentOp, v64);
  v75 = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&SymbolName);
  if (Value)
  {
    v129 = 261;
    SymbolName = v75;
    v127 = v76;
    mlir::Diagnostic::operator<<((uint64_t)v131, &SymbolName);
    if (Value)
    {
      LODWORD(SymbolName) = 3;
      v127 = ") returns ";
      v128 = 10;
      v77 = &SymbolName;
      v78 = (char *)v132;
      if (v133 >= v134)
      {
        v96 = v133 + 1;
        if (v132 <= &SymbolName && (char *)v132 + 24 * v133 > (char *)&SymbolName)
        {
          v114 = (char *)&SymbolName - (_BYTE *)v132;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v96, 24);
          v78 = (char *)v132;
          v77 = (const void ***)((char *)v132 + v114);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v96, 24);
          v77 = &SymbolName;
          v78 = (char *)v132;
        }
      }
      v79 = &v78[24 * v133];
      v80 = *(_OWORD *)v77;
      *((_QWORD *)v79 + 2) = v77[2];
      *(_OWORD *)v79 = v80;
      v81 = ++v133;
      if (Value)
      {
        LODWORD(SymbolName) = 5;
        v127 = v8;
        v82 = &SymbolName;
        v83 = (char *)v132;
        if (v81 >= v134)
        {
          v97 = v81 + 1;
          v98 = (char *)v132 + 24 * v81 > (char *)&SymbolName;
          if (v132 <= &SymbolName && v98)
          {
            v115 = (char *)&SymbolName - (_BYTE *)v132;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v97, 24);
            v83 = (char *)v132;
            v82 = (const void ***)((char *)v132 + v115);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v97, 24);
            v82 = &SymbolName;
            v83 = (char *)v132;
          }
        }
        v84 = &v83[24 * v133];
        v85 = *(_OWORD *)v82;
        *((_QWORD *)v84 + 2) = v82[2];
        *(_OWORD *)v84 = v85;
        ++v133;
      }
    }
  }
  v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  if (v140)
  {
    v86 = (_QWORD **)__p;
    if (__p)
    {
      v87 = v139;
      v88 = __p;
      if (v139 != __p)
      {
        do
          v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
        while (v87 != v86);
        v88 = __p;
      }
      v139 = v86;
      operator delete(v88);
    }
    v59 = v136;
    if (!v136)
      goto LABEL_76;
    v89 = v137;
    v61 = v136;
    if (v137 == v136)
      goto LABEL_75;
    do
    {
      v91 = (void *)*--v89;
      v90 = v91;
      *v89 = 0;
      if (v91)
        operator delete[](v90);
    }
    while (v89 != v59);
    goto LABEL_74;
  }
  return v13;
}

uint64_t mlir::func::CallIndirectOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  unint64_t *v4;
  char *v5;
  char *v6;
  __int128 v7;
  uint64_t v8;
  unint64_t *v9;
  char *v10;
  char *v11;
  __int128 v12;
  uint64_t v13;
  unint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  unint64_t *v18;
  char *v19;
  char *v20;
  __int128 v21;
  char v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t i;
  _QWORD *Inputs;
  _BYTE *v36;
  _BYTE *v37;
  uint64_t *v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  _QWORD *Results;
  _BYTE *v44;
  _BYTE *v45;
  uint64_t v46;
  const void **v47;
  uint64_t v48;
  mlir::detail::OpResultImpl *v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD **v52;
  _QWORD **v53;
  void *v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  void *v58;
  void *v59;
  _QWORD **v60;
  _QWORD **v61;
  void *v62;
  _QWORD *v63;
  void *v64;
  void *v65;
  unint64_t v67;
  unint64_t v68;
  BOOL v69;
  unint64_t v70;
  BOOL v71;
  unint64_t v72;
  int64_t v73;
  int64_t v74;
  int64_t v75;
  int64_t v76;
  const void **v77;
  uint64_t v78;
  __int16 v79;
  unint64_t v80;
  const char *v81;
  uint64_t v82;
  mlir::detail::OpResultImpl *v83;
  uint64_t v84;
  void *v85;
  unsigned int v86;
  unsigned int v87;
  _BYTE v88[96];
  void *v89;
  _QWORD *v90;
  void *__p;
  _QWORD **v92;
  char v93;
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  v3 = *(_QWORD *)(*(_QWORD *)(v2[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(_QWORD *)v3 + 136) != &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
  {
    v79 = 261;
    v77 = (const void **)"operand";
    v78 = 7;
    mlir::Operation::emitOpError(v2, &v77, (uint64_t)&v83);
    if (v83)
    {
      LODWORD(v80) = 3;
      v81 = " #";
      v82 = 2;
      v4 = &v80;
      v5 = (char *)v85;
      if (v86 >= v87)
      {
        v67 = v86 + 1;
        if (v85 <= &v80 && (char *)v85 + 24 * v86 > (char *)&v80)
        {
          v73 = (char *)&v80 - (_BYTE *)v85;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v67, 24);
          v5 = (char *)v85;
          v4 = (unint64_t *)((char *)v85 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v67, 24);
          v4 = &v80;
          v5 = (char *)v85;
        }
      }
      v6 = &v5[24 * v86];
      v7 = *(_OWORD *)v4;
      *((_QWORD *)v6 + 2) = v4[2];
      *(_OWORD *)v6 = v7;
      v8 = ++v86;
      if (v83)
      {
        LODWORD(v80) = 5;
        v81 = 0;
        v9 = &v80;
        v10 = (char *)v85;
        if (v8 >= v87)
        {
          v68 = v8 + 1;
          v69 = (char *)v85 + 24 * v8 > (char *)&v80;
          if (v85 <= &v80 && v69)
          {
            v74 = (char *)&v80 - (_BYTE *)v85;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v68, 24);
            v10 = (char *)v85;
            v9 = (unint64_t *)((char *)v85 + v74);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v68, 24);
            v9 = &v80;
            v10 = (char *)v85;
          }
        }
        v11 = &v10[24 * v86];
        v12 = *(_OWORD *)v9;
        *((_QWORD *)v11 + 2) = v9[2];
        *(_OWORD *)v11 = v12;
        v13 = ++v86;
        if (v83)
        {
          LODWORD(v80) = 3;
          v81 = " must be function type, but got ";
          v82 = 32;
          v14 = &v80;
          v15 = (char *)v85;
          if (v13 >= v87)
          {
            v70 = v13 + 1;
            v71 = (char *)v85 + 24 * v13 > (char *)&v80;
            if (v85 <= &v80 && v71)
            {
              v75 = (char *)&v80 - (_BYTE *)v85;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v70, 24);
              v15 = (char *)v85;
              v14 = (unint64_t *)((char *)v85 + v75);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v70, 24);
              v14 = &v80;
              v15 = (char *)v85;
            }
          }
          v16 = &v15[24 * v86];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = v14[2];
          *(_OWORD *)v16 = v17;
          ++v86;
          if (v83)
          {
            v18 = &v80;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v80, v3);
            v19 = (char *)v85;
            if (v86 >= v87)
            {
              v72 = v86 + 1;
              if (v85 <= &v80 && (char *)v85 + 24 * v86 > (char *)&v80)
              {
                v76 = (char *)&v80 - (_BYTE *)v85;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v72, 24);
                v19 = (char *)v85;
                v18 = (unint64_t *)((char *)v85 + v76);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v72, 24);
                v18 = &v80;
                v19 = (char *)v85;
              }
            }
            v20 = &v19[24 * v86];
            v21 = *(_OWORD *)v18;
            *((_QWORD *)v20 + 2) = v18[2];
            *(_OWORD *)v20 = v21;
            ++v86;
          }
        }
      }
    }
    v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v83);
    if (v83)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v83);
    if (v93)
    {
      v23 = (_QWORD **)__p;
      if (__p)
      {
        v24 = v92;
        v25 = __p;
        if (v92 != __p)
        {
          do
            v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
          while (v24 != v23);
          v25 = __p;
        }
        v92 = v23;
        operator delete(v25);
      }
      v26 = v89;
      if (v89)
      {
        v27 = v90;
        v28 = v89;
        if (v90 != v89)
        {
          do
          {
            v30 = (void *)*--v27;
            v29 = v30;
            *v27 = 0;
            if (v30)
              operator delete[](v29);
          }
          while (v27 != v26);
          v28 = v89;
        }
        v90 = v26;
        operator delete(v28);
      }
      if (v85 != v88)
        free(v85);
    }
    if (!v22)
      return 0;
  }
  v31 = *this;
  v32 = *((unsigned int *)*this + 9);
  if (*((_DWORD *)*this + 9))
    v33 = (uint64_t)(*this - 2);
  else
    v33 = 0;
  if ((_DWORD)v32)
  {
    for (i = 0; i != v32; ++i)
      mlir::detail::OpResultImpl::getNextResultAtOffset(v33, i);
    v31 = *this;
  }
  v80 = *(_QWORD *)(*(_QWORD *)(v31[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  Inputs = (_QWORD *)mlir::FunctionType::getInputs((mlir::FunctionType *)&v80);
  v37 = v36;
  v38 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    v39 = *((_DWORD *)v38 + 17);
    v40 = v38[9];
  }
  else
  {
    v39 = 0;
    v40 = 0;
  }
  v77 = (const void **)(v40 + 32);
  v78 = v39 - 1;
  mlir::OperandRange::getTypes((uint64_t *)&v77, (uint64_t *)&v83);
  if (v37 != (char *)v85 - v84)
  {
LABEL_52:
    v77 = (const void **)"failed to verify that callee input types match argument types";
    v79 = 259;
    mlir::OpState::emitOpError(this, &v77, (uint64_t)&v83);
    v51 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v83);
    if (v83)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v83);
    if (v93)
    {
      v52 = (_QWORD **)__p;
      if (__p)
      {
        v53 = v92;
        v54 = __p;
        if (v92 != __p)
        {
          do
            v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
          while (v53 != v52);
          v54 = __p;
        }
        v92 = v52;
        operator delete(v54);
      }
      v55 = v89;
      if (!v89)
        goto LABEL_83;
      v56 = v90;
      v57 = v89;
      if (v90 == v89)
        goto LABEL_82;
      do
      {
        v59 = (void *)*--v56;
        v58 = v59;
        *v56 = 0;
        if (v59)
          operator delete[](v58);
      }
      while (v56 != v55);
      goto LABEL_81;
    }
    return v51;
  }
  if (v37)
  {
    v41 = 8 * (_QWORD)v37;
    v42 = (char *)v83 + 32 * v84 + 24;
    while (*Inputs == (*(_QWORD *)(*(_QWORD *)v42 + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      ++Inputs;
      v42 += 32;
      v41 -= 8;
      if (!v41)
        goto LABEL_44;
    }
    goto LABEL_52;
  }
LABEL_44:
  v80 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  Results = (_QWORD *)mlir::FunctionType::getResults((mlir::FunctionType *)&v80);
  v45 = v44;
  v46 = *((unsigned int *)*this + 9);
  v47 = (const void **)(*this - 2);
  if (!(_DWORD)v46)
    v47 = 0;
  v77 = v47;
  v78 = v46;
  mlir::OperandRange::getTypes((uint64_t *)&v77, (uint64_t *)&v83);
  v48 = v84;
  if (v45 == (char *)v85 - v84)
  {
    if (!v45)
      return 1;
    v49 = v83;
    v50 = 8 * (_QWORD)v45;
    while (*Results == (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v49, v48) + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      ++Results;
      ++v48;
      v50 -= 8;
      if (!v50)
        return 1;
    }
  }
  v77 = (const void **)"failed to verify that callee result types match result types";
  v79 = 259;
  mlir::OpState::emitOpError(this, &v77, (uint64_t)&v83);
  v51 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v83);
  if (v83)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v83);
  if (v93)
  {
    v60 = (_QWORD **)__p;
    if (__p)
    {
      v61 = v92;
      v62 = __p;
      if (v92 != __p)
      {
        do
          v61 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v61 - 1);
        while (v61 != v60);
        v62 = __p;
      }
      v92 = v60;
      operator delete(v62);
    }
    v55 = v89;
    if (!v89)
      goto LABEL_83;
    v63 = v90;
    v57 = v89;
    if (v90 == v89)
    {
LABEL_82:
      v90 = v55;
      operator delete(v57);
LABEL_83:
      if (v85 != v88)
        free(v85);
      return v51;
    }
    do
    {
      v65 = (void *)*--v63;
      v64 = v65;
      *v63 = 0;
      if (v65)
        operator delete[](v64);
    }
    while (v63 != v55);
LABEL_81:
    v57 = v89;
    goto LABEL_82;
  }
  return v51;
}

uint64_t mlir::func::CallIndirectOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *Results;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v15[4];
  __int16 v16;
  uint64_t v17;
  _QWORD v18[2];
  uint64_t v19[2];
  _QWORD v20[24];
  uint64_t v21;
  void *v22[2];
  _BYTE v23[128];
  _QWORD v24[5];

  v24[4] = *MEMORY[0x1E0C80C00];
  memset(v24, 0, 24);
  v19[0] = (uint64_t)v24;
  v19[1] = 1;
  v21 = 0;
  v22[0] = v23;
  v22[1] = (void *)0x400000000;
  v18[0] = &v21;
  v18[1] = 1;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v24, 1))
    goto LABEL_12;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 264))(a1))
    goto LABEL_12;
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void **, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, v22, 0, 1, 0xFFFFFFFFLL))goto LABEL_12;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 280))(a1))
    goto LABEL_12;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    goto LABEL_12;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    goto LABEL_12;
  v20[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::FunctionType>(a1, v20))
    goto LABEL_12;
  v21 = v20[0];
  v17 = v20[0];
  if (*(_UNKNOWN **)(*(_QWORD *)v20[0] + 136) != &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
  {
    v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v16 = 257;
    (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v20, a1, v6, v15);
    v7 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v20, "'callee' must be function type, but got ");
    v8 = mlir::InFlightDiagnostic::append<mlir::Type &>(v7, &v17);
    v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v8);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v20);
    goto LABEL_13;
  }
  Results = (void *)mlir::FunctionType::getResults((mlir::FunctionType *)v20);
  mlir::OperationState::addTypes(a2, Results, v11);
  v12 = a2 + 16;
  if (mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v19, v18, v4, v12))
  {
    v15[0] = *(_QWORD *)v18[0];
    v20[0] = mlir::FunctionType::getInputs((mlir::FunctionType *)v15);
    v20[1] = v13;
    v9 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,3u> &,llvm::ArrayRef<mlir::Type>>(a1, (uint64_t *)v22, v20, v5, v12) != 0;
  }
  else
  {
LABEL_12:
    v9 = 0;
  }
LABEL_13:
  if (v22[0] != v23)
    free(v22[0]);
  return v9;
}

void mlir::func::CallIndirectOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  llvm::raw_ostream *v6;
  _BYTE *v7;
  mlir::Operation *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  llvm::raw_ostream *v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  mlir::Operation *v16;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v19;
  llvm::raw_ostream *v20;
  _BYTE *v21;
  llvm::raw_ostream *v22;
  _BYTE *v23;
  llvm::raw_ostream *v24;
  _BYTE *v25;
  unint64_t AttrDictionary;
  void *v27;
  uint64_t v28;
  _QWORD v29[5];

  v29[4] = *MEMORY[0x1E0C80C00];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 24));
  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v7 = (_BYTE *)*((_QWORD *)v6 + 4);
  if (*((_BYTE **)v6 + 3) == v7)
  {
    llvm::raw_ostream::write(v6, "(", 1uLL);
    v8 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
      goto LABEL_6;
  }
  else
  {
    *v7 = 40;
    ++*((_QWORD *)v6 + 4);
    v8 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
    {
LABEL_6:
      v9 = *((unsigned int *)v8 + 17);
      v10 = *((_QWORD *)v8 + 9);
      v11 = v9 - 1;
      goto LABEL_7;
    }
  }
  v10 = 0;
  v11 = -1;
LABEL_7:
  v12 = v10 + 32;
  v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v27 = ", ";
  v28 = 2;
  llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v12, 0, v12, v11, (uint64_t)a2, v13, (uint64_t)&v27);
  v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)v14 + 4);
  if (*((_BYTE **)v14 + 3) == v15)
  {
    llvm::raw_ostream::write(v14, ")", 1uLL);
  }
  else
  {
    *v15 = 41;
    ++*((_QWORD *)v14 + 4);
  }
  v27 = v29;
  v28 = 0x200000000;
  v16 = *this;
  if (*((_BYTE *)*this + 47))
  {
    AttrDictionary = mlir::Operation::getAttrDictionary(v16);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::Operation *)((char *)v16 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v19, v27, v28);
  v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v21 = (_BYTE *)*((_QWORD *)v20 + 4);
  if ((unint64_t)v21 >= *((_QWORD *)v20 + 3))
  {
    llvm::raw_ostream::write(v20, 32);
  }
  else
  {
    *((_QWORD *)v20 + 4) = v21 + 1;
    *v21 = 32;
  }
  v22 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v23 = (_BYTE *)*((_QWORD *)v22 + 4);
  if (*((_BYTE **)v22 + 3) == v23)
  {
    llvm::raw_ostream::write(v22, ":", 1uLL);
  }
  else
  {
    *v23 = 58;
    ++*((_QWORD *)v22 + 4);
  }
  v24 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v25 = (_BYTE *)*((_QWORD *)v24 + 4);
  if ((unint64_t)v25 >= *((_QWORD *)v24 + 3))
  {
    llvm::raw_ostream::write(v24, 32);
  }
  else
  {
    *((_QWORD *)v24 + 4) = v25 + 1;
    *v25 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(*(_QWORD *)(*((_QWORD *)*this + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v27 != v29)
    free(v27);
}

uint64_t mlir::func::CallOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  _QWORD **v22;
  _QWORD **v23;
  void *v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  void *v28;
  void *v29;
  int *v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  void *v38;
  void *v39;
  int *v40;
  char *v41;
  char *v42;
  __int128 v43;
  _QWORD **v44;
  _QWORD **v45;
  void *v46;
  _QWORD *v47;
  void *v48;
  void *v49;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  int64_t v55;
  int64_t v56;
  int64_t v57;
  int64_t v58;
  uint64_t v59;
  int v60;
  const char *v61;
  uint64_t v62;
  _QWORD v63[3];
  void *v64;
  unsigned int v65;
  unsigned int v66;
  _BYTE v67[96];
  void *v68;
  _QWORD *v69;
  void *__p;
  _QWORD **v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v59 = v6;
  if (!v6)
  {
    a3(v63, a4);
    if (v63[0])
    {
      v60 = 3;
      v61 = "expected DictionaryAttr to set properties";
      v62 = 41;
      v30 = &v60;
      v31 = (char *)v64;
      if (v65 >= v66)
      {
        v51 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          v55 = (char *)&v60 - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
          v31 = (char *)v64;
          v30 = (int *)((char *)v64 + v55);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
          v30 = &v60;
          v31 = (char *)v64;
        }
      }
      v32 = &v31[24 * v65];
      v33 = *(_OWORD *)v30;
      *((_QWORD *)v32 + 2) = *((_QWORD *)v30 + 2);
      *(_OWORD *)v32 = v33;
      ++v65;
      if (v63[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
    }
    if (!v72)
      return 0;
    v34 = (_QWORD **)__p;
    if (__p)
    {
      v35 = v71;
      v36 = __p;
      if (v71 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v71 = v34;
      operator delete(v36);
    }
    v25 = v68;
    if (!v68)
      goto LABEL_64;
    v37 = v69;
    v27 = v68;
    if (v69 == v68)
      goto LABEL_63;
    do
    {
      v39 = (void *)*--v37;
      v38 = v39;
      *v37 = 0;
      if (v39)
        operator delete[](v38);
    }
    while (v37 != v25);
    goto LABEL_62;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v59, "callee", 6uLL);
  if (!v8)
  {
    a3(v63, a4);
    if (v63[0])
    {
      v60 = 3;
      v61 = "expected key entry for callee in DictionaryAttr to set Properties.";
      v62 = 66;
      v40 = &v60;
      v41 = (char *)v64;
      if (v65 >= v66)
      {
        v53 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          v57 = (char *)&v60 - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v53, 24);
          v41 = (char *)v64;
          v40 = (int *)((char *)v64 + v57);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v53, 24);
          v40 = &v60;
          v41 = (char *)v64;
        }
      }
      v42 = &v41[24 * v65];
      v43 = *(_OWORD *)v40;
      *((_QWORD *)v42 + 2) = *((_QWORD *)v40 + 2);
      *(_OWORD *)v42 = v43;
      ++v65;
      if (v63[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
    }
    if (!v72)
      return 0;
    v44 = (_QWORD **)__p;
    if (__p)
    {
      v45 = v71;
      v46 = __p;
      if (v71 != __p)
      {
        do
          v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
        while (v45 != v44);
        v46 = __p;
      }
      v71 = v44;
      operator delete(v46);
    }
    v25 = v68;
    if (!v68)
      goto LABEL_64;
    v47 = v69;
    v27 = v68;
    if (v69 == v68)
      goto LABEL_63;
    do
    {
      v49 = (void *)*--v47;
      v48 = v49;
      *v47 = 0;
      if (v49)
        operator delete[](v48);
    }
    while (v47 != v25);
    goto LABEL_62;
  }
  v9 = v8;
  v10 = *(void **)(*(_QWORD *)v8 + 136);
  v11 = v10 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id;
  if (v10 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
    v12 = v8;
  else
    v12 = 0;
  v63[0] = v12;
  if (v11)
  {
    mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v63);
    if (!v13)
    {
      *a1 = v9;
      return 1;
    }
  }
  a3(v63, a4);
  if (v63[0])
  {
    v60 = 3;
    v62 = 51;
    v14 = &v60;
    v15 = (char *)v64;
    if (v65 >= v66)
    {
      v52 = v65 + 1;
      if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
      {
        v56 = (char *)&v60 - (_BYTE *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v52, 24);
        v15 = (char *)v64;
        v14 = (int *)((char *)v64 + v56);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v52, 24);
        v14 = &v60;
        v15 = (char *)v64;
      }
    }
    v16 = &v15[24 * v65];
    v17 = *(_OWORD *)v14;
    *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
    *(_OWORD *)v16 = v17;
    ++v65;
    if (v63[0])
    {
      v18 = &v60;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v60, v9);
      v19 = (char *)v64;
      if (v65 >= v66)
      {
        v54 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          v58 = (char *)&v60 - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v54, 24);
          v19 = (char *)v64;
          v18 = (int *)((char *)v64 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v54, 24);
          v18 = &v60;
          v19 = (char *)v64;
        }
      }
      v20 = &v19[24 * v65];
      v21 = *(_OWORD *)v18;
      *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
      *(_OWORD *)v20 = v21;
      ++v65;
      if (v63[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
    }
  }
  if (v72)
  {
    v22 = (_QWORD **)__p;
    if (__p)
    {
      v23 = v71;
      v24 = __p;
      if (v71 != __p)
      {
        do
          v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        v24 = __p;
      }
      v71 = v22;
      operator delete(v24);
    }
    v25 = v68;
    if (!v68)
      goto LABEL_64;
    v26 = v69;
    v27 = v68;
    if (v69 == v68)
    {
LABEL_63:
      v69 = v25;
      operator delete(v27);
LABEL_64:
      if (v64 != v67)
        free(v64);
      return 0;
    }
    do
    {
      v29 = (void *)*--v26;
      v28 = v29;
      *v26 = 0;
      if (v29)
        operator delete[](v28);
    }
    while (v26 != v25);
LABEL_62:
    v27 = v68;
    goto LABEL_63;
  }
  return 0;
}

uint64_t mlir::func::CallOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x1E0C80C00];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"callee", 6, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  void *v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  const void ***v17;
  char *v18;
  char *v19;
  __int128 v20;
  uint64_t v21;
  _QWORD **v22;
  _QWORD **v23;
  void *v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  void *v28;
  void *v29;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  const void **v35;
  const char *v36;
  uint64_t v37;
  __int16 v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  unsigned int v42;
  unsigned int v43;
  _BYTE v44[96];
  void *v45;
  _QWORD *v46;
  void *__p;
  _QWORD **v48;
  char v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  v9 = *(void **)(*(_QWORD *)a1 + 136);
  v10 = v9 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id;
  v11 = v9 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id ? a1 : 0;
  v39 = v11;
  if (v10)
  {
    mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v39);
    if (!v12)
      return 1;
  }
  a4(&v39, a5);
  if (v39)
  {
    LODWORD(v35) = 3;
    v36 = "attribute '";
    v37 = 11;
    v13 = &v35;
    v14 = (char *)v41;
    if (v42 >= v43)
    {
      v31 = v42 + 1;
      if (v41 <= &v35 && (char *)v41 + 24 * v42 > (char *)&v35)
      {
        v33 = (char *)&v35 - (_BYTE *)v41;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v31, 24);
        v14 = (char *)v41;
        v13 = (const void ***)((char *)v41 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v31, 24);
        v13 = &v35;
        v14 = (char *)v41;
      }
    }
    v15 = &v14[24 * v42];
    v16 = *(_OWORD *)v13;
    *((_QWORD *)v15 + 2) = v13[2];
    *(_OWORD *)v15 = v16;
    ++v42;
    if (v39)
    {
      v38 = 261;
      v35 = a2;
      v36 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v40, &v35);
      if (v39)
      {
        LODWORD(v35) = 3;
        v36 = "' failed to satisfy constraint: flat symbol reference attribute";
        v37 = 63;
        v17 = &v35;
        v18 = (char *)v41;
        if (v42 >= v43)
        {
          v32 = v42 + 1;
          if (v41 <= &v35 && (char *)v41 + 24 * v42 > (char *)&v35)
          {
            v34 = (char *)&v35 - (_BYTE *)v41;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
            v18 = (char *)v41;
            v17 = (const void ***)((char *)v41 + v34);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
            v17 = &v35;
            v18 = (char *)v41;
          }
        }
        v19 = &v18[24 * v42];
        v20 = *(_OWORD *)v17;
        *((_QWORD *)v19 + 2) = v17[2];
        *(_OWORD *)v19 = v20;
        ++v42;
      }
    }
  }
  v21 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v39);
  if (v39)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v39);
  if (v49)
  {
    v22 = (_QWORD **)__p;
    if (__p)
    {
      v23 = v48;
      v24 = __p;
      if (v48 != __p)
      {
        do
          v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        v24 = __p;
      }
      v48 = v22;
      operator delete(v24);
    }
    v25 = v45;
    if (v45)
    {
      v26 = v46;
      v27 = v45;
      if (v46 != v45)
      {
        do
        {
          v29 = (void *)*--v26;
          v28 = v29;
          *v26 = 0;
          if (v29)
            operator delete[](v28);
        }
        while (v26 != v25);
        v27 = v45;
      }
      v46 = v25;
      operator delete(v27);
    }
    if (v41 != v44)
      free(v41);
  }
  return v21;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  __guard *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    if ((v4 & 1) == 0)
    {
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::func::detail::CallOpGenericAdaptorBase::Properties]";
        v15 = 106;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::func::detail::CallOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
      }
    }
    a1[33] = v5[461];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::FlatSymbolRefAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void ***v9;
  char *v10;
  char *v11;
  __int128 v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  const void ***v17;
  char *v18;
  char *v19;
  __int128 v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  _QWORD **v25;
  _QWORD **v26;
  void *v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  void *v31;
  void *v32;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  int64_t v37;
  int64_t v38;
  int64_t v39;
  _WORD v40[20];
  uint64_t v41;
  const void **v42;
  unint64_t v43;
  uint64_t v44;
  __int16 v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD **v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v41 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v41))
    return 0;
  v4 = v41;
  if (*(_UNKNOWN **)(*(_QWORD *)v41 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
    v5 = v41;
  else
    v5 = 0;
  v46 = v5;
  if (v5)
  {
    mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v46);
    if (v6)
      v7 = 0;
    else
      v7 = v4;
    *a2 = v7;
    if (!v6)
      return 1;
  }
  else
  {
    *a2 = 0;
  }
  v40[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v46, a1, v40);
  if (v46)
  {
    LODWORD(v42) = 3;
    v43 = (unint64_t)"expected ";
    v44 = 9;
    v9 = &v42;
    v10 = (char *)v48;
    if (v49 >= v50)
    {
      v34 = v49 + 1;
      if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
      {
        v37 = (char *)&v42 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v34, 24);
        v10 = (char *)v48;
        v9 = (const void ***)((char *)v48 + v37);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v34, 24);
        v9 = &v42;
        v10 = (char *)v48;
      }
    }
    v11 = &v10[24 * v49];
    v12 = *(_OWORD *)v9;
    *((_QWORD *)v11 + 2) = v9[2];
    *(_OWORD *)v11 = v12;
    ++v49;
  }
  v42 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::FlatSymbolRefAttr]";
  v43 = 73;
  v13 = llvm::StringRef::find((uint64_t *)&v42, "DesiredTypeName = ", 0x12uLL, 0);
  if (v46)
  {
    if (v43 >= v13)
      v14 = v13;
    else
      v14 = v43;
    v15 = 18;
    if (v43 - v14 < 0x12)
      v15 = v43 - v14;
    v16 = v43 - v14 - v15;
    if (v16 >= v16 - 1)
      --v16;
    v45 = 261;
    v42 = (const void **)((char *)v42 + v14 + v15);
    v43 = v16;
    mlir::Diagnostic::operator<<((uint64_t)&v47, &v42);
    if (v46)
    {
      LODWORD(v42) = 3;
      v43 = (unint64_t)", but got: ";
      v44 = 11;
      v17 = &v42;
      v18 = (char *)v48;
      if (v49 >= v50)
      {
        v35 = v49 + 1;
        if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
        {
          v38 = (char *)&v42 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
          v18 = (char *)v48;
          v17 = (const void ***)((char *)v48 + v38);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
          v17 = &v42;
          v18 = (char *)v48;
        }
      }
      v19 = &v18[24 * v49];
      v20 = *(_OWORD *)v17;
      *((_QWORD *)v19 + 2) = v17[2];
      *(_OWORD *)v19 = v20;
      ++v49;
      if (v46)
      {
        v21 = &v42;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v42, v41);
        v22 = (char *)v48;
        if (v49 >= v50)
        {
          v36 = v49 + 1;
          if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
          {
            v39 = (char *)&v42 - (_BYTE *)v48;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            v22 = (char *)v48;
            v21 = (const void ***)((char *)v48 + v39);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            v21 = &v42;
            v22 = (char *)v48;
          }
        }
        v23 = &v22[24 * v49];
        v24 = *(_OWORD *)v21;
        *((_QWORD *)v23 + 2) = v21[2];
        *(_OWORD *)v23 = v24;
        ++v49;
      }
    }
  }
  v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v46);
  if (v46)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v46);
  if (v56)
  {
    v25 = (_QWORD **)__p;
    if (__p)
    {
      v26 = v55;
      v27 = __p;
      if (v55 != __p)
      {
        do
          v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        v27 = __p;
      }
      v55 = v25;
      operator delete(v27);
    }
    v28 = v52;
    if (v52)
    {
      v29 = v53;
      v30 = v52;
      if (v53 != v52)
      {
        do
        {
          v32 = (void *)*--v29;
          v31 = v32;
          *v29 = 0;
          if (v32)
            operator delete[](v31);
        }
        while (v29 != v28);
        v30 = v52;
      }
      v53 = v28;
      operator delete(v30);
    }
    if (v48 != v51)
      free(v48);
  }
  return v8;
}

void mlir::func::CallOp::build(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;
  uint64_t v8;
  mlir::StringAttr *Context;
  uint64_t v10;
  unint64_t v11;
  const void *Results;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  unint64_t v17;
  _QWORD v18[4];
  __int16 v19;
  uint64_t v20[2];

  mlir::OperationState::addOperands(a2, a4, a5);
  v8 = mlir::SymbolRefAttr::get((mlir::SymbolRefAttr *)a3, v7);
  Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  v19 = 261;
  v18[0] = "callee";
  v18[1] = 6;
  v10 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)v18);
  mlir::NamedAttribute::NamedAttribute(v20, v10, v8);
  mlir::NamedAttrList::push_back(a2 + 112, v20[0], v20[1]);
  if (HIBYTE(a3[11]))
    v11 = (unint64_t)&a3[4 * (((unint64_t)a3[11] >> 23) & 1) + 16];
  else
    v11 = 0;
  v18[0] = *(_QWORD *)(v11 + 8);
  v18[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v18);
  Results = (const void *)mlir::FunctionType::getResults((mlir::FunctionType *)v18);
  v14 = v13;
  v15 = 8 * v13;
  v16 = *(unsigned int *)(a2 + 72);
  v17 = v16 + ((8 * v13) >> 3);
  if (v17 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v17, 8);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  if (v14)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v16), Results, v15);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v16 + (v15 >> 3);
}

void mlir::func::CallOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  mlir::StringAttr *Context;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v16[4];
  __int16 v17;
  uint64_t v18[2];

  mlir::OperationState::addOperands(a2, a6, a7);
  Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  v17 = 261;
  v16[0] = "callee";
  v16[1] = 6;
  v12 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)v16);
  mlir::NamedAttribute::NamedAttribute(v18, v12, a3);
  mlir::NamedAttrList::push_back(a2 + 112, v18[0], v18[1]);
  v13 = *(unsigned int *)(a2 + 72);
  if (a5 + v13 > (unint64_t)*(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), a5 + v13, 8);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  if (a5)
  {
    v14 = 0;
    v15 = *(_QWORD *)(a2 + 64) + 8 * v13;
    do
    {
      *(_QWORD *)(v15 + 8 * v14) = mlir::TypeRange::dereference_iterator(a4, v14);
      ++v14;
    }
    while (a5 != v14);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + a5;
}

uint64_t mlir::func::CallOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  _QWORD **v8;
  _QWORD **v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  void *v14;
  void *v15;
  const void **v17;
  __int16 v18;
  _QWORD v19[3];
  void *v20;
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  void *__p;
  _QWORD **v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v19[0] = v2;
    if (mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v3, (const void **)"callee", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v19))
    {
      v4 = *((unsigned int *)*this + 9);
      if (*((_DWORD *)*this + 9))
        v5 = (uint64_t)(*this - 2);
      else
        v5 = 0;
      if ((_DWORD)v4)
      {
        for (i = 0; i != v4; ++i)
          mlir::detail::OpResultImpl::getNextResultAtOffset(v5, i);
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v17 = (const void **)"requires attribute 'callee'";
    v18 = 259;
    mlir::OpState::emitOpError(this, &v17, (uint64_t)v19);
    v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
    if (v19[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
    if (v26)
    {
      v8 = (_QWORD **)__p;
      if (__p)
      {
        v9 = v25;
        v10 = __p;
        if (v25 != __p)
        {
          do
            v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
          while (v9 != v8);
          v10 = __p;
        }
        v25 = v8;
        operator delete(v10);
      }
      v11 = v22;
      if (v22)
      {
        v12 = v23;
        v13 = v22;
        if (v23 != v22)
        {
          do
          {
            v15 = (void *)*--v12;
            v14 = v15;
            *v12 = 0;
            if (v15)
              operator delete[](v14);
          }
          while (v12 != v11);
          v13 = v22;
        }
        v23 = v11;
        operator delete(v13);
      }
      if (v20 != &v21)
        free(v20);
    }
  }
  return v7;
}

BOOL mlir::func::CallOp::parse(uint64_t a1, _QWORD *a2)
{
  mlir::NoneType **v4;
  mlir::MLIRContext *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *Results;
  uint64_t v13;
  _BOOL8 v14;
  _QWORD v16[3];
  uint64_t v17;
  uint64_t Inputs;
  uint64_t v19;
  uint64_t v20;
  void *v21[2];
  _QWORD v22[17];

  v22[16] = *MEMORY[0x1E0C80C00];
  v20 = 0;
  v21[0] = v22;
  v21[1] = (void *)0x400000000;
  Inputs = 0;
  v19 = 0;
  v4 = (mlir::NoneType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  v6 = mlir::NoneType::get(*v4, v5);
  if (!mlir::AsmParser::parseAttribute<mlir::FlatSymbolRefAttr>(a1, &v20, v6))
    goto LABEL_13;
  if (v20)
  {
    v7 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(a2);
    *v7 = v20;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 264))(a1))
    goto LABEL_13;
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void **, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, v21, 0, 1, 0xFFFFFFFFLL))goto LABEL_13;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 280))(a1))
    goto LABEL_13;
  v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
    goto LABEL_13;
  v9 = a2[1];
  v16[0] = a1;
  v16[1] = &v17;
  v16[2] = a2;
  v10 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(_QWORD **)(v9 + 96));
  if (v10)
  {
    if (!mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v10, (const void **)"callee", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::CallOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v16))goto LABEL_13;
  }
  if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1)
    && (v16[0] = 0, mlir::AsmParser::parseType<mlir::FunctionType>(a1, v16)))
  {
    Inputs = mlir::FunctionType::getInputs((mlir::FunctionType *)v16);
    v19 = v11;
    Results = (void *)mlir::FunctionType::getResults((mlir::FunctionType *)v16);
    mlir::OperationState::addTypes((uint64_t)a2, Results, v13);
    v14 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,3u> &,llvm::ArrayRef<mlir::Type>>(a1, (uint64_t *)v21, &Inputs, v8, (uint64_t)(a2 + 2)) != 0;
  }
  else
  {
LABEL_13:
    v14 = 0;
  }
  if (v21[0] != v22)
    free(v21[0]);
  return v14;
}

void mlir::func::CallOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  llvm::raw_ostream *v6;
  _BYTE *v7;
  mlir::Operation *v8;
  uint64_t v9;
  uint64_t v10;
  llvm::raw_ostream *v11;
  llvm::raw_ostream *v12;
  _BYTE *v13;
  mlir::Operation *v14;
  mlir::ArrayAttr *v15;
  uint64_t Value;
  uint64_t v17;
  llvm::raw_ostream *v18;
  _BYTE *v19;
  llvm::raw_ostream *v20;
  _BYTE *v21;
  llvm::raw_ostream *v22;
  _BYTE *v23;
  mlir::Operation *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29[4];
  uint64_t v30[2];
  uint64_t v31[4];
  uint64_t v32[2];
  char *v33;
  uint64_t v34;
  _QWORD v35[5];

  v35[4] = *MEMORY[0x1E0C80C00];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 48))(a2, *((_QWORD *)*this + 2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8));
  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v7 = (_BYTE *)*((_QWORD *)v6 + 4);
  if (*((_BYTE **)v6 + 3) == v7)
  {
    llvm::raw_ostream::write(v6, "(", 1uLL);
    v8 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
      goto LABEL_6;
  }
  else
  {
    *v7 = 40;
    ++*((_QWORD *)v6 + 4);
    v8 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
    {
LABEL_6:
      v9 = *((unsigned int *)v8 + 17);
      v10 = *((_QWORD *)v8 + 9);
      goto LABEL_7;
    }
  }
  v10 = 0;
  v9 = 0;
LABEL_7:
  v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v33 = ", ";
  v34 = 2;
  llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v10, 0, v10, v9, (uint64_t)a2, v11, (uint64_t)&v33);
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)v12 + 4);
  if (*((_BYTE **)v12 + 3) == v13)
  {
    llvm::raw_ostream::write(v12, ")", 1uLL);
  }
  else
  {
    *v13 = 41;
    ++*((_QWORD *)v12 + 4);
  }
  v33 = (char *)v35;
  v35[0] = "callee";
  v35[1] = 6;
  v34 = 0x200000001;
  v14 = *this;
  if (*((_BYTE *)*this + 47))
  {
    v31[0] = mlir::Operation::getAttrDictionary(v14);
    v15 = (mlir::ArrayAttr *)v31;
  }
  else
  {
    v15 = (mlir::Operation *)((char *)v14 + 56);
  }
  Value = mlir::ArrayAttr::getValue(v15);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, char *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v17, v33, v34);
  v18 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v19 = (_BYTE *)*((_QWORD *)v18 + 4);
  if ((unint64_t)v19 >= *((_QWORD *)v18 + 3))
  {
    llvm::raw_ostream::write(v18, 32);
  }
  else
  {
    *((_QWORD *)v18 + 4) = v19 + 1;
    *v19 = 32;
  }
  v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v21 = (_BYTE *)*((_QWORD *)v20 + 4);
  if (*((_BYTE **)v20 + 3) == v21)
  {
    llvm::raw_ostream::write(v20, ":", 1uLL);
  }
  else
  {
    *v21 = 58;
    ++*((_QWORD *)v20 + 4);
  }
  v22 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v23 = (_BYTE *)*((_QWORD *)v22 + 4);
  if ((unint64_t)v23 >= *((_QWORD *)v22 + 3))
  {
    llvm::raw_ostream::write(v22, 32);
  }
  else
  {
    *((_QWORD *)v22 + 4) = v23 + 1;
    *v23 = 32;
  }
  v24 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    v25 = *((unsigned int *)v24 + 17);
    v26 = *((_QWORD *)v24 + 9);
  }
  else
  {
    v26 = 0;
    v25 = 0;
  }
  v30[0] = v26;
  v30[1] = v25;
  mlir::OperandRange::getTypes(v30, v31);
  v27 = *((unsigned int *)*this + 9);
  v28 = (uint64_t)*this - 16;
  if (!(_DWORD)v27)
    v28 = 0;
  v32[0] = v28;
  v32[1] = v27;
  mlir::OperandRange::getTypes(v32, v29);
  mlir::AsmPrinter::printFunctionalType<mlir::ValueTypeRange<mlir::OperandRange>,mlir::ValueTypeRange<mlir::ResultRange>>((uint64_t)a2, v31, v29);
  if (v33 != (char *)v35)
    free(v33);
}

uint64_t mlir::func::ConstantOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  _QWORD **v22;
  _QWORD **v23;
  void *v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  void *v28;
  void *v29;
  int *v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  void *v38;
  void *v39;
  int *v40;
  char *v41;
  char *v42;
  __int128 v43;
  _QWORD **v44;
  _QWORD **v45;
  void *v46;
  _QWORD *v47;
  void *v48;
  void *v49;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  int64_t v55;
  int64_t v56;
  int64_t v57;
  int64_t v58;
  uint64_t v59;
  int v60;
  const char *v61;
  uint64_t v62;
  _QWORD v63[3];
  void *v64;
  unsigned int v65;
  unsigned int v66;
  _BYTE v67[96];
  void *v68;
  _QWORD *v69;
  void *__p;
  _QWORD **v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v59 = v6;
  if (!v6)
  {
    a3(v63, a4);
    if (v63[0])
    {
      v60 = 3;
      v61 = "expected DictionaryAttr to set properties";
      v62 = 41;
      v30 = &v60;
      v31 = (char *)v64;
      if (v65 >= v66)
      {
        v51 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          v55 = (char *)&v60 - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
          v31 = (char *)v64;
          v30 = (int *)((char *)v64 + v55);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
          v30 = &v60;
          v31 = (char *)v64;
        }
      }
      v32 = &v31[24 * v65];
      v33 = *(_OWORD *)v30;
      *((_QWORD *)v32 + 2) = *((_QWORD *)v30 + 2);
      *(_OWORD *)v32 = v33;
      ++v65;
      if (v63[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
    }
    if (!v72)
      return 0;
    v34 = (_QWORD **)__p;
    if (__p)
    {
      v35 = v71;
      v36 = __p;
      if (v71 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v71 = v34;
      operator delete(v36);
    }
    v25 = v68;
    if (!v68)
      goto LABEL_64;
    v37 = v69;
    v27 = v68;
    if (v69 == v68)
      goto LABEL_63;
    do
    {
      v39 = (void *)*--v37;
      v38 = v39;
      *v37 = 0;
      if (v39)
        operator delete[](v38);
    }
    while (v37 != v25);
    goto LABEL_62;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v59, "value", 5uLL);
  if (!v8)
  {
    a3(v63, a4);
    if (v63[0])
    {
      v60 = 3;
      v61 = "expected key entry for value in DictionaryAttr to set Properties.";
      v62 = 65;
      v40 = &v60;
      v41 = (char *)v64;
      if (v65 >= v66)
      {
        v53 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          v57 = (char *)&v60 - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v53, 24);
          v41 = (char *)v64;
          v40 = (int *)((char *)v64 + v57);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v53, 24);
          v40 = &v60;
          v41 = (char *)v64;
        }
      }
      v42 = &v41[24 * v65];
      v43 = *(_OWORD *)v40;
      *((_QWORD *)v42 + 2) = *((_QWORD *)v40 + 2);
      *(_OWORD *)v42 = v43;
      ++v65;
      if (v63[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
    }
    if (!v72)
      return 0;
    v44 = (_QWORD **)__p;
    if (__p)
    {
      v45 = v71;
      v46 = __p;
      if (v71 != __p)
      {
        do
          v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
        while (v45 != v44);
        v46 = __p;
      }
      v71 = v44;
      operator delete(v46);
    }
    v25 = v68;
    if (!v68)
      goto LABEL_64;
    v47 = v69;
    v27 = v68;
    if (v69 == v68)
      goto LABEL_63;
    do
    {
      v49 = (void *)*--v47;
      v48 = v49;
      *v47 = 0;
      if (v49)
        operator delete[](v48);
    }
    while (v47 != v25);
    goto LABEL_62;
  }
  v9 = v8;
  v10 = *(void **)(*(_QWORD *)v8 + 136);
  v11 = v10 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id;
  if (v10 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
    v12 = v8;
  else
    v12 = 0;
  v63[0] = v12;
  if (v11)
  {
    mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v63);
    if (!v13)
    {
      *a1 = v9;
      return 1;
    }
  }
  a3(v63, a4);
  if (v63[0])
  {
    v60 = 3;
    v62 = 50;
    v14 = &v60;
    v15 = (char *)v64;
    if (v65 >= v66)
    {
      v52 = v65 + 1;
      if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
      {
        v56 = (char *)&v60 - (_BYTE *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v52, 24);
        v15 = (char *)v64;
        v14 = (int *)((char *)v64 + v56);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v52, 24);
        v14 = &v60;
        v15 = (char *)v64;
      }
    }
    v16 = &v15[24 * v65];
    v17 = *(_OWORD *)v14;
    *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
    *(_OWORD *)v16 = v17;
    ++v65;
    if (v63[0])
    {
      v18 = &v60;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v60, v9);
      v19 = (char *)v64;
      if (v65 >= v66)
      {
        v54 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          v58 = (char *)&v60 - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v54, 24);
          v19 = (char *)v64;
          v18 = (int *)((char *)v64 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v54, 24);
          v18 = &v60;
          v19 = (char *)v64;
        }
      }
      v20 = &v19[24 * v65];
      v21 = *(_OWORD *)v18;
      *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
      *(_OWORD *)v20 = v21;
      ++v65;
      if (v63[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
    }
  }
  if (v72)
  {
    v22 = (_QWORD **)__p;
    if (__p)
    {
      v23 = v71;
      v24 = __p;
      if (v71 != __p)
      {
        do
          v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        v24 = __p;
      }
      v71 = v22;
      operator delete(v24);
    }
    v25 = v68;
    if (!v68)
      goto LABEL_64;
    v26 = v69;
    v27 = v68;
    if (v69 == v68)
    {
LABEL_63:
      v69 = v25;
      operator delete(v27);
LABEL_64:
      if (v64 != v67)
        free(v64);
      return 0;
    }
    do
    {
      v29 = (void *)*--v26;
      v28 = v29;
      *v26 = 0;
      if (v29)
        operator delete[](v28);
    }
    while (v26 != v25);
LABEL_62:
    v27 = v68;
    goto LABEL_63;
  }
  return 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  __guard *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    if ((v4 & 1) == 0)
    {
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::func::detail::ConstantOpGenericAdaptorBase::Properties]";
        v15 = 110;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
      }
    }
    a1[33] = v5[463];
    return a1[32];
  }
  return result;
}

uint64_t mlir::func::ConstantOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD **v6;
  _QWORD **v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  void *v12;
  void *v13;
  const void **v15;
  __int16 v16;
  _QWORD v17[3];
  void *v18;
  uint64_t v19;
  void *v20;
  _QWORD *v21;
  void *__p;
  _QWORD **v23;
  char v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v17[0] = v2;
    if (mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v3, (const void **)"value", (const char *)5, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v17))
    {
      if (*((_DWORD *)*this + 9))
        v4 = (uint64_t)(*this - 2);
      else
        v4 = 0;
      mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v15 = (const void **)"requires attribute 'value'";
    v16 = 259;
    mlir::OpState::emitOpError(this, &v15, (uint64_t)v17);
    v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v17);
    if (v17[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v17);
    if (v24)
    {
      v6 = (_QWORD **)__p;
      if (__p)
      {
        v7 = v23;
        v8 = __p;
        if (v23 != __p)
        {
          do
            v7 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v7 - 1);
          while (v7 != v6);
          v8 = __p;
        }
        v23 = v6;
        operator delete(v8);
      }
      v9 = v20;
      if (v20)
      {
        v10 = v21;
        v11 = v20;
        if (v21 != v20)
        {
          do
          {
            v13 = (void *)*--v10;
            v12 = v13;
            *v10 = 0;
            if (v13)
              operator delete[](v12);
          }
          while (v10 != v9);
          v11 = v20;
        }
        v21 = v9;
        operator delete(v11);
      }
      if (v18 != &v19)
        free(v18);
    }
  }
  return v5;
}

uint64_t mlir::func::ConstantOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  mlir::NoneType **v6;
  mlir::MLIRContext *v7;
  uint64_t v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  void *v15;
  _QWORD v17[3];
  uint64_t v18;
  uint64_t v19;
  void *__src;
  uint64_t v21;
  _QWORD v22[2];

  v22[1] = *MEMORY[0x1E0C80C00];
  v19 = 0;
  __src = v22;
  v21 = 0x100000000;
  v18 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    goto LABEL_15;
  v4 = *(_QWORD *)(a2 + 8);
  v17[0] = a1;
  v17[1] = &v18;
  v17[2] = a2;
  v5 = mlir::NamedAttrList::get(a2 + 112, **(_QWORD **)(v4 + 96));
  if (v5)
  {
    if (!mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v5, (const void **)"value", (const char *)5, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::ConstantOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v17))goto LABEL_15;
  }
  v6 = (mlir::NoneType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  v8 = mlir::NoneType::get(*v6, v7);
  if (!mlir::AsmParser::parseAttribute<mlir::FlatSymbolRefAttr>(a1, &v19, v8))
    goto LABEL_15;
  if (v19)
  {
    v9 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v9 = v19;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1)
    || !mlir::AsmParser::parseTypeList(a1, (uint64_t)&__src))
  {
LABEL_15:
    v14 = 0;
    v15 = __src;
    if (__src == v22)
      return v14;
LABEL_16:
    free(v15);
    return v14;
  }
  v10 = __src;
  v11 = v21;
  v12 = *(unsigned int *)(a2 + 72);
  v13 = v12 + v21;
  if (v13 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v13, 8);
    LODWORD(v12) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v11)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v12), v10, 8 * v11);
    LODWORD(v12) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v12 + v11;
  v14 = 1;
  v15 = __src;
  if (__src != v22)
    goto LABEL_16;
  return v14;
}

void mlir::func::ConstantOp::print(mlir::func::ConstantOp *this, mlir::OpAsmPrinter *a2)
{
  _BYTE *v4;
  mlir::ArrayAttr *v5;
  uint64_t Value;
  uint64_t v7;
  llvm::raw_ostream *v8;
  _BYTE *v9;
  llvm::raw_ostream *v10;
  _BYTE *v11;
  llvm::raw_ostream *v12;
  _BYTE *v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18[4];
  const char *v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  _QWORD v23[5];

  v23[4] = *MEMORY[0x1E0C80C00];
  v21 = v23;
  v23[0] = "value";
  v23[1] = 5;
  v22 = 0x200000001;
  v4 = *(_BYTE **)this;
  if (v4[47])
  {
    v18[0] = mlir::Operation::getAttrDictionary((mlir::Operation *)v4);
    v5 = (mlir::ArrayAttr *)v18;
  }
  else
  {
    v5 = (mlir::ArrayAttr *)(v4 + 56);
  }
  Value = mlir::ArrayAttr::getValue(v5);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v7, v21, v22);
  v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v9 = (_BYTE *)*((_QWORD *)v8 + 4);
  if ((unint64_t)v9 >= *((_QWORD *)v8 + 3))
  {
    llvm::raw_ostream::write(v8, 32);
  }
  else
  {
    *((_QWORD *)v8 + 4) = v9 + 1;
    *v9 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 48))(a2, *(_QWORD *)(*(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64));
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (_BYTE *)*((_QWORD *)v10 + 4);
  if ((unint64_t)v11 >= *((_QWORD *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }
  else
  {
    *((_QWORD *)v10 + 4) = v11 + 1;
    *v11 = 32;
  }
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)v12 + 4);
  if (*((_BYTE **)v12 + 3) == v13)
  {
    llvm::raw_ostream::write(v12, ":", 1uLL);
  }
  else
  {
    *v13 = 58;
    ++*((_QWORD *)v12 + 4);
  }
  v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)v14 + 4);
  if ((unint64_t)v15 >= *((_QWORD *)v14 + 3))
  {
    llvm::raw_ostream::write(v14, 32);
  }
  else
  {
    *((_QWORD *)v14 + 4) = v15 + 1;
    *v15 = 32;
  }
  v16 = *(unsigned int *)(*(_QWORD *)this + 36);
  v17 = (const char *)(*(_QWORD *)this - 16);
  if (!(_DWORD)v16)
    v17 = 0;
  v19 = v17;
  v20 = v16;
  mlir::OperandRange::getTypes((uint64_t *)&v19, v18);
  v19 = ", ";
  v20 = 2;
  llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::ResultRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &,mlir::AsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>(v18[0], v18[1], v18[2], v18[3], (uint64_t)a2, (uint64_t)a2, (uint64_t)&v19);
  if (v21 != v23)
    free(v21);
}

uint64_t mlir::func::FuncOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  char *v39;
  char *v40;
  __int128 v41;
  uint64_t *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD **v46;
  _QWORD **v47;
  void *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  uint64_t *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD **v56;
  _QWORD **v57;
  void *v58;
  _QWORD *v59;
  void *v60;
  void *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t *v66;
  char *v67;
  char *v68;
  __int128 v69;
  _QWORD **v70;
  _QWORD **v71;
  void *v72;
  _QWORD *v73;
  void *v74;
  void *v75;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  int64_t v85;
  int64_t v86;
  int64_t v87;
  int64_t v88;
  int64_t v89;
  int64_t v90;
  int64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  const char *v95;
  uint64_t v96;
  _QWORD v97[3];
  void *v98;
  unsigned int v99;
  unsigned int v100;
  _BYTE v101[96];
  void *v102;
  _QWORD *v103;
  void *__p;
  _QWORD **v105;
  char v106;
  uint64_t v107;

  v107 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v93 = v6;
  if (!v6)
  {
    a3(v97, a4);
    if (v97[0])
    {
      LODWORD(v94) = 3;
      v95 = "expected DictionaryAttr to set properties";
      v96 = 41;
      v26 = &v94;
      v27 = (char *)v98;
      if (v99 >= v100)
      {
        v78 = v99 + 1;
        if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
        {
          v85 = (char *)&v94 - (_BYTE *)v98;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v78, 24);
          v27 = (char *)v98;
          v26 = (uint64_t *)((char *)v98 + v85);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v78, 24);
          v26 = &v94;
          v27 = (char *)v98;
        }
      }
      v28 = &v27[24 * v99];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = v26[2];
      *(_OWORD *)v28 = v29;
      ++v99;
      if (v97[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v97);
    }
    if (!v106)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v105;
      v32 = __p;
      if (v105 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v105 = v30;
      operator delete(v32);
    }
    v21 = v102;
    if (!v102)
      goto LABEL_104;
    v33 = v103;
    v23 = v102;
    if (v103 == v102)
    {
LABEL_103:
      v103 = v21;
      operator delete(v23);
LABEL_104:
      if (v98 != v101)
        free(v98);
      return 0;
    }
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_102;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v93, "arg_attrs", 9uLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
    {
      a3(v97, a4);
      if (v97[0])
      {
        LODWORD(v94) = 3;
        v96 = 54;
        v10 = &v94;
        v11 = (char *)v98;
        if (v99 >= v100)
        {
          v79 = v99 + 1;
          if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
          {
            v86 = (char *)&v94 - (_BYTE *)v98;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v79, 24);
            v11 = (char *)v98;
            v10 = (uint64_t *)((char *)v98 + v86);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v79, 24);
            v10 = &v94;
            v11 = (char *)v98;
          }
        }
        v12 = &v11[24 * v99];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = v10[2];
        *(_OWORD *)v12 = v13;
        ++v99;
        if (v97[0])
        {
          v14 = &v94;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v94, v9);
          v15 = (char *)v98;
          if (v99 >= v100)
          {
            v80 = v99 + 1;
            if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
            {
              v87 = (char *)&v94 - (_BYTE *)v98;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v80, 24);
              v15 = (char *)v98;
              v14 = (uint64_t *)((char *)v98 + v87);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v80, 24);
              v14 = &v94;
              v15 = (char *)v98;
            }
          }
          v16 = &v15[24 * v99];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = v14[2];
          *(_OWORD *)v16 = v17;
          ++v99;
          if (v97[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v97);
        }
      }
      if (!v106)
        return 0;
      v18 = (_QWORD **)__p;
      if (__p)
      {
        v19 = v105;
        v20 = __p;
        if (v105 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v105 = v18;
        operator delete(v20);
      }
      v21 = v102;
      if (!v102)
        goto LABEL_104;
      v22 = v103;
      v23 = v102;
      if (v103 == v102)
        goto LABEL_103;
      do
      {
        v25 = (void *)*--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          operator delete[](v24);
      }
      while (v22 != v21);
      goto LABEL_102;
    }
    *a1 = v8;
  }
  v36 = mlir::DictionaryAttr::get((uint64_t)&v93, "function_type", 0xDuLL);
  if (!v36)
  {
    a3(v97, a4);
    if (v97[0])
    {
      LODWORD(v94) = 3;
      v95 = "expected key entry for function_type in DictionaryAttr to set Properties.";
      v96 = 73;
      v52 = &v94;
      v53 = (char *)v98;
      if (v99 >= v100)
      {
        v82 = v99 + 1;
        if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
        {
          v89 = (char *)&v94 - (_BYTE *)v98;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v82, 24);
          v53 = (char *)v98;
          v52 = (uint64_t *)((char *)v98 + v89);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v82, 24);
          v52 = &v94;
          v53 = (char *)v98;
        }
      }
      v54 = &v53[24 * v99];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = v52[2];
      *(_OWORD *)v54 = v55;
      ++v99;
      if (v97[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v97);
    }
    if (!v106)
      return 0;
    v56 = (_QWORD **)__p;
    if (__p)
    {
      v57 = v105;
      v58 = __p;
      if (v105 != __p)
      {
        do
          v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        v58 = __p;
      }
      v105 = v56;
      operator delete(v58);
    }
    v21 = v102;
    if (!v102)
      goto LABEL_104;
    v59 = v103;
    v23 = v102;
    if (v103 == v102)
      goto LABEL_103;
    do
    {
      v61 = (void *)*--v59;
      v60 = v61;
      *v59 = 0;
      if (v61)
        operator delete[](v60);
    }
    while (v59 != v21);
    goto LABEL_102;
  }
  v37 = v36;
  if (*(_UNKNOWN **)(*(_QWORD *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    a3(v97, a4);
    if (v97[0])
    {
      LODWORD(v94) = 3;
      v96 = 58;
      v38 = &v94;
      v39 = (char *)v98;
      if (v99 >= v100)
      {
        v81 = v99 + 1;
        if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
        {
          v88 = (char *)&v94 - (_BYTE *)v98;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v81, 24);
          v39 = (char *)v98;
          v38 = (uint64_t *)((char *)v98 + v88);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v81, 24);
          v38 = &v94;
          v39 = (char *)v98;
        }
      }
      v40 = &v39[24 * v99];
      v41 = *(_OWORD *)v38;
      *((_QWORD *)v40 + 2) = v38[2];
      *(_OWORD *)v40 = v41;
      ++v99;
      if (v97[0])
      {
        v42 = &v94;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v94, v37);
        v43 = (char *)v98;
        if (v99 >= v100)
        {
          v83 = v99 + 1;
          if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
          {
            v90 = (char *)&v94 - (_BYTE *)v98;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v83, 24);
            v43 = (char *)v98;
            v42 = (uint64_t *)((char *)v98 + v90);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v83, 24);
            v42 = &v94;
            v43 = (char *)v98;
          }
        }
        v44 = &v43[24 * v99];
        v45 = *(_OWORD *)v42;
        *((_QWORD *)v44 + 2) = v42[2];
        *(_OWORD *)v44 = v45;
        ++v99;
        if (v97[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v97);
      }
    }
    if (!v106)
      return 0;
    v46 = (_QWORD **)__p;
    if (__p)
    {
      v47 = v105;
      v48 = __p;
      if (v105 != __p)
      {
        do
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        v48 = __p;
      }
      v105 = v46;
      operator delete(v48);
    }
    v21 = v102;
    if (!v102)
      goto LABEL_104;
    v49 = v103;
    v23 = v102;
    if (v103 == v102)
      goto LABEL_103;
    do
    {
      v51 = (void *)*--v49;
      v50 = v51;
      *v49 = 0;
      if (v51)
        operator delete[](v50);
    }
    while (v49 != v21);
    goto LABEL_102;
  }
  a1[1] = v36;
  v62 = mlir::DictionaryAttr::get((uint64_t)&v93, "res_attrs", 9uLL);
  v94 = v62;
  if (!v62)
  {
LABEL_83:
    v64 = mlir::DictionaryAttr::get((uint64_t)&v93, "sym_name", 8uLL);
    v92 = v64;
    if (v64)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v64 + 136) != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
      {
        a3(v97, a4);
        mlir::InFlightDiagnostic::append<mlir::Attribute>(v65, &v92);
        mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v97);
        return 0;
      }
      a1[3] = v64;
      v77 = mlir::DictionaryAttr::get((uint64_t)&v93, "sym_visibility", 0xEuLL);
      v94 = v77;
      if (v77)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)v77 + 136) != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
        {
          a3(v97, a4);
          goto LABEL_81;
        }
        a1[4] = v77;
      }
      return 1;
    }
    a3(v97, a4);
    if (v97[0])
    {
      LODWORD(v94) = 3;
      v95 = "expected key entry for sym_name in DictionaryAttr to set Properties.";
      v96 = 68;
      v66 = &v94;
      v67 = (char *)v98;
      if (v99 >= v100)
      {
        v84 = v99 + 1;
        if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
        {
          v91 = (char *)&v94 - (_BYTE *)v98;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v84, 24);
          v67 = (char *)v98;
          v66 = (uint64_t *)((char *)v98 + v91);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v84, 24);
          v66 = &v94;
          v67 = (char *)v98;
        }
      }
      v68 = &v67[24 * v99];
      v69 = *(_OWORD *)v66;
      *((_QWORD *)v68 + 2) = v66[2];
      *(_OWORD *)v68 = v69;
      ++v99;
      if (v97[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v97);
    }
    if (!v106)
      return 0;
    v70 = (_QWORD **)__p;
    if (__p)
    {
      v71 = v105;
      v72 = __p;
      if (v105 != __p)
      {
        do
          v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
        while (v71 != v70);
        v72 = __p;
      }
      v105 = v70;
      operator delete(v72);
    }
    v21 = v102;
    if (!v102)
      goto LABEL_104;
    v73 = v103;
    v23 = v102;
    if (v103 == v102)
      goto LABEL_103;
    do
    {
      v75 = (void *)*--v73;
      v74 = v75;
      *v73 = 0;
      if (v75)
        operator delete[](v74);
    }
    while (v73 != v21);
LABEL_102:
    v23 = v102;
    goto LABEL_103;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)v62 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
  {
    a1[2] = v62;
    goto LABEL_83;
  }
  a3(v97, a4);
LABEL_81:
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v63, &v94);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v97);
  return 0;
}

uint64_t mlir::func::FuncOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  void *v33;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v36;
  void *v37;
  uint64_t v38;
  _QWORD v39[7];

  v39[6] = *MEMORY[0x1E0C80C00];
  v36 = a1;
  v37 = v39;
  v38 = 0x300000000;
  if (!*a2)
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_10;
    goto LABEL_7;
  }
  NamedAttr = mlir::Builder::getNamedAttr(&v36, (uint64_t)"arg_attrs", 9, *a2);
  v5 = v4;
  v6 = v38;
  if (v38 >= HIDWORD(v38))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
    v6 = v38;
  }
  v7 = (uint64_t *)((char *)v37 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = v38 + 1;
  LODWORD(v38) = v38 + 1;
  v9 = a2[1];
  if (v9)
  {
LABEL_7:
    v10 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"function_type", 13, v9);
    v12 = v11;
    v13 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v13 = v38;
    }
    v14 = (uint64_t *)((char *)v37 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
LABEL_10:
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"res_attrs", 9, v15);
    v18 = v17;
    v19 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v19 = v38;
    }
    v20 = (uint64_t *)((char *)v37 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"sym_name", 8, v21);
    v24 = v23;
    v25 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v25 = v38;
    }
    v26 = (uint64_t *)((char *)v37 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  v27 = a2[4];
  if (v27)
  {
    v28 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"sym_visibility", 14, v27);
    v30 = v29;
    v31 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v31 = v38;
    }
    v32 = (uint64_t *)((char *)v37 + 16 * v31);
    *v32 = v28;
    v32[1] = v30;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  v33 = v37;
  if (!v8)
  {
    DictionaryAttr = 0;
    if (v37 == v39)
      return DictionaryAttr;
    goto LABEL_24;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v36, (mlir::MLIRContext *)v37, v8);
  v33 = v37;
  if (v37 != v39)
LABEL_24:
    free(v33);
  return DictionaryAttr;
}

unint64_t mlir::func::FuncOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1;
  unsigned __int8 v2;
  uint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unsigned __int8 v16;
  unint64_t v17;
  unint64_t v18;
  int v20;
  int v21;
  unint64_t v22;
  int v23;
  int v24;
  unint64_t v25;
  int v26;
  int v27;
  unint64_t v28;
  int v29;
  int v30;
  unint64_t v31;
  int v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t *v39;
  unint64_t *v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;

  v1 = *a1;
  v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v2 & 1) == 0)
  {
    v34 = *a1;
    v38 = a1;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v20;
    v1 = v34;
    a1 = v38;
    if (v21)
    {
      v22 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v22 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v22;
      v1 = v34;
      a1 = v38;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v4 = HIDWORD(v1);
  v5 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v1) ^ HIDWORD(v1));
  v47 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
  v6 = a1[1];
  if ((v4 & 1) == 0)
  {
    v35 = a1[1];
    v39 = a1;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v23;
    v6 = v35;
    a1 = v39;
    if (v24)
    {
      v25 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v25 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v25;
      v6 = v35;
      a1 = v39;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v7 = HIDWORD(v6);
  v8 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v6) ^ HIDWORD(v6));
  v46 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) >> 47));
  v9 = a1[2];
  if ((v7 & 1) == 0)
  {
    v36 = a1[2];
    v40 = a1;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v26;
    v9 = v36;
    a1 = v40;
    if (v27)
    {
      v28 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v28 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v28;
      v9 = v36;
      a1 = v40;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v10 = HIDWORD(v9);
  v11 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v9) ^ HIDWORD(v9));
  v45 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) ^ ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) >> 47));
  v12 = a1[3];
  if ((v10 & 1) == 0)
  {
    v37 = a1[3];
    v41 = a1;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v29;
    v12 = v37;
    a1 = v41;
    if (v30)
    {
      v31 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v31 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v31;
      v12 = v37;
      a1 = v41;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v13 = HIDWORD(v12);
  v14 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v12) ^ HIDWORD(v12));
  v44 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) ^ ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) >> 47));
  v15 = a1[4];
  if ((v16 & 1) == 0)
  {
    v42 = a1[4];
    v15 = v42;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    if (v32)
    {
      v33 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v33 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v33;
      v15 = v42;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v17 = HIDWORD(v15);
  v18 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v15) ^ HIDWORD(v15));
  v43 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) ^ ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) >> 47));
  return llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>(&v47, (uint64_t *)&v46, (uint64_t *)&v45, (uint64_t *)&v44, (uint64_t *)&v43);
}

unint64_t llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>(_QWORD *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  unsigned __int8 v8;
  uint64_t v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  int v15;
  unint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _OWORD v23[4];
  _OWORD v24[3];
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v25 = 0;
  memset(v24, 0, sizeof(v24));
  memset(v23, 0, sizeof(v23));
  if ((v8 & 1) == 0)
  {
    v17 = a2;
    v18 = a1;
    a2 = v17;
    a1 = v18;
    if (v15)
    {
      v16 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v16 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v16;
      a2 = v17;
      a1 = v18;
    }
  }
  v9 = *a1;
  v26 = llvm::hashing::detail::get_execution_seed(void)::seed;
  *(_QWORD *)&v23[0] = v9;
  v19 = 0;
  v10 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v23, (uint64_t *)&v19, (_QWORD *)v23 + 1, (unint64_t)v24, *a2);
  v20 = v19;
  v11 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v23, (uint64_t *)&v20, v10, (unint64_t)v24, *a3);
  v21 = v20;
  v12 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v23, (uint64_t *)&v21, v11, (unint64_t)v24, *a4);
  v22 = v21;
  v13 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v23, (uint64_t *)&v22, v12, (unint64_t)v24, *a5);
  return llvm::hashing::detail::hash_combine_recursive_helper::combine((llvm::hashing::detail::hash_combine_recursive_helper *)v23, v22, v13, (char *)v24);
}

uint64_t mlir::func::FuncOp::getInherentAttr(int a1, _QWORD *a2, _QWORD *__s1, size_t __n)
{
  switch(__n)
  {
    case 8uLL:
      if (memcmp(__s1, "sym_name", __n))
        return 0;
      return a2[3];
    case 9uLL:
      if (*__s1 == 0x727474615F677261 && *((_BYTE *)__s1 + 8) == 115)
        return *a2;
      if (memcmp(__s1, "res_attrs", __n))
        return 0;
      return a2[2];
    case 0xAuLL:
    case 0xBuLL:
    case 0xCuLL:
      return 0;
    case 0xDuLL:
      if (memcmp(__s1, "function_type", __n))
        return 0;
      return a2[1];
    case 0xEuLL:
      if (memcmp(__s1, "sym_visibility", __n))
        return 0;
      return a2[4];
    default:
      return 0;
  }
}

uint64_t mlir::func::FuncOp::setInherentAttr(uint64_t result, _QWORD *__s1, size_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (_QWORD *)result;
  switch(a3)
  {
    case 8uLL:
      result = memcmp(__s1, "sym_name", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          v5[3] = v10;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 9uLL:
      if (*__s1 == 0x727474615F677261 && *((_BYTE *)__s1 + 8) == 115)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          *(_QWORD *)result = v11;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      else
      {
        result = memcmp(__s1, "res_attrs", a3);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
              v7 = a4;
            else
              v7 = 0;
            v5[2] = v7;
          }
          else
          {
            v5[2] = 0;
          }
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "function_type", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
            v8 = a4;
          else
            v8 = 0;
          v5[1] = v8;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "sym_visibility", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
            v9 = a4;
          else
            v9 = 0;
          v5[4] = v9;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::func::FuncOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"arg_attrs", 9, *a2);
  v5 = a2[1];
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"function_type", 13, v5);
  v6 = a2[2];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"res_attrs", 9, v6);
  v7 = a2[3];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"sym_name", 8, v7);
  v8 = a2[4];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"sym_visibility", 14, v8);
}

BOOL mlir::func::FuncOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8;
  const void **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BOOL8 result;

  v8 = mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(v8, (const void **)"arg_attrs", (const char *)9, a3, a4))
  {
    v9 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::func::__mlir_ods_local_attr_constraint_FuncOps2(v9, (const void **)"function_type", (const char *)0xD, (void (*)(const void ***__return_ptr, uint64_t))a3, a4))
    {
      v10 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(v10, (const void **)"res_attrs", (const char *)9, a3, a4))
      {
        v11 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(v11, (const void **)"sym_name", (const char *)8, a3, a4))
        {
          v12 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(v12, (const void **)"sym_visibility", (const char *)0xE, a3, a4))
          {
            return 1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v9;
  char *v10;
  char *v11;
  __int128 v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t Value;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  const void **v35;
  const char *v36;
  uint64_t v37;
  __int16 v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  unsigned int v42;
  unsigned int v43;
  _BYTE v44[96];
  void *v45;
  _QWORD *v46;
  void *__p;
  _QWORD **v48;
  char v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  if (*(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
  {
    v39 = a1;
    Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
    v27 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
    v29 = v27 + 8 * v28;
    if (v29 != Value)
    {
      while (*(_QWORD *)Value
           && *(_UNKNOWN **)(**(_QWORD **)Value + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
      {
        Value += 8;
        if (Value == v29)
          return 1;
      }
      goto LABEL_3;
    }
    return 1;
  }
LABEL_3:
  a4(&v39, a5);
  if (v39)
  {
    LODWORD(v35) = 3;
    v36 = "attribute '";
    v37 = 11;
    v9 = &v35;
    v10 = (char *)v41;
    if (v42 >= v43)
    {
      v31 = v42 + 1;
      if (v41 <= &v35 && (char *)v41 + 24 * v42 > (char *)&v35)
      {
        v33 = (char *)&v35 - (_BYTE *)v41;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v31, 24);
        v10 = (char *)v41;
        v9 = (const void ***)((char *)v41 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v31, 24);
        v9 = &v35;
        v10 = (char *)v41;
      }
    }
    v11 = &v10[24 * v42];
    v12 = *(_OWORD *)v9;
    *((_QWORD *)v11 + 2) = v9[2];
    *(_OWORD *)v11 = v12;
    ++v42;
    if (v39)
    {
      v38 = 261;
      v35 = a2;
      v36 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v40, &v35);
      if (v39)
      {
        LODWORD(v35) = 3;
        v36 = "' failed to satisfy constraint: Array of dictionary attributes";
        v37 = 62;
        v13 = &v35;
        v14 = (char *)v41;
        if (v42 >= v43)
        {
          v32 = v42 + 1;
          if (v41 <= &v35 && (char *)v41 + 24 * v42 > (char *)&v35)
          {
            v34 = (char *)&v35 - (_BYTE *)v41;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
            v14 = (char *)v41;
            v13 = (const void ***)((char *)v41 + v34);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
            v13 = &v35;
            v14 = (char *)v41;
          }
        }
        v15 = &v14[24 * v42];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = v13[2];
        *(_OWORD *)v15 = v16;
        ++v42;
      }
    }
  }
  v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v39);
  if (v39)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v39);
  if (v49)
  {
    v18 = (_QWORD **)__p;
    if (__p)
    {
      v19 = v48;
      v20 = __p;
      if (v48 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v48 = v18;
      operator delete(v20);
    }
    v21 = v45;
    if (v45)
    {
      v22 = v46;
      v23 = v45;
      if (v46 != v45)
      {
        do
        {
          v25 = (void *)*--v22;
          v24 = v25;
          *v22 = 0;
          if (v25)
            operator delete[](v24);
        }
        while (v22 != v21);
        v23 = v45;
      }
      v46 = v21;
      operator delete(v23);
    }
    if (v41 != v44)
      free(v41);
  }
  return v17;
}

uint64_t mlir::func::__mlir_ods_local_attr_constraint_FuncOps2(const void **a1, const void **a2, const char *a3, void (*a4)(const void ***__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v10;
  char *v11;
  char *v12;
  __int128 v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  _QWORD **v19;
  _QWORD **v20;
  void *v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  void *v25;
  void *v26;
  unint64_t v28;
  unint64_t v29;
  int64_t v30;
  int64_t v31;
  const void **v32;
  const char *v33;
  uint64_t v34;
  __int16 v35;
  const void **v36;
  uint64_t v37;
  void *v38;
  unsigned int v39;
  unsigned int v40;
  _BYTE v41[96];
  void *v42;
  _QWORD *v43;
  void *__p;
  _QWORD **v45;
  char v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    v36 = a1;
    if (*(_UNKNOWN **)(*(_QWORD *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v36) + 136) == &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
    {
      v32 = a1;
      if (*(_UNKNOWN **)(*(_QWORD *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v32) + 136) == &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
        return 1;
    }
  }
  a4(&v36, a5);
  if (v36)
  {
    LODWORD(v32) = 3;
    v33 = "attribute '";
    v34 = 11;
    v10 = &v32;
    v11 = (char *)v38;
    if (v39 >= v40)
    {
      v28 = v39 + 1;
      if (v38 <= &v32 && (char *)v38 + 24 * v39 > (char *)&v32)
      {
        v30 = (char *)&v32 - (_BYTE *)v38;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v41, v28, 24);
        v11 = (char *)v38;
        v10 = (const void ***)((char *)v38 + v30);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v41, v28, 24);
        v10 = &v32;
        v11 = (char *)v38;
      }
    }
    v12 = &v11[24 * v39];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = v10[2];
    *(_OWORD *)v12 = v13;
    ++v39;
    if (v36)
    {
      v35 = 261;
      v32 = a2;
      v33 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v37, &v32);
      if (v36)
      {
        LODWORD(v32) = 3;
        v33 = "' failed to satisfy constraint: type attribute of function type";
        v34 = 63;
        v14 = &v32;
        v15 = (char *)v38;
        if (v39 >= v40)
        {
          v29 = v39 + 1;
          if (v38 <= &v32 && (char *)v38 + 24 * v39 > (char *)&v32)
          {
            v31 = (char *)&v32 - (_BYTE *)v38;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v41, v29, 24);
            v15 = (char *)v38;
            v14 = (const void ***)((char *)v38 + v31);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v41, v29, 24);
            v14 = &v32;
            v15 = (char *)v38;
          }
        }
        v16 = &v15[24 * v39];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = v14[2];
        *(_OWORD *)v16 = v17;
        ++v39;
      }
    }
  }
  v18 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v36);
  if (v36)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v36);
  if (v46)
  {
    v19 = (_QWORD **)__p;
    if (__p)
    {
      v20 = v45;
      v21 = __p;
      if (v45 != __p)
      {
        do
          v20 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v20 - 1);
        while (v20 != v19);
        v21 = __p;
      }
      v45 = v19;
      operator delete(v21);
    }
    v22 = v42;
    if (v42)
    {
      v23 = v43;
      v24 = v42;
      if (v43 != v42)
      {
        do
        {
          v26 = (void *)*--v23;
          v25 = v26;
          *v23 = 0;
          if (v26)
            operator delete[](v25);
        }
        while (v23 != v22);
        v24 = v42;
      }
      v43 = v22;
      operator delete(v24);
    }
    if (v38 != v41)
      free(v38);
  }
  return v18;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  __guard *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x28uLL);
    *v3 = 0u;
    v3[1] = 0u;
    *((_QWORD *)v3 + 4) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::FuncOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::FuncOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    if ((v5 & 1) == 0)
    {
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::func::detail::FuncOpGenericAdaptorBase::Properties]";
        v15 = 106;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::func::detail::FuncOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
      }
    }
    a1[33] = v4[465];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::ArrayAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::ArrayAttr]";
  v41 = 65;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::TypeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::TypeAttr]";
  v41 = 64;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::StringAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::StringAttr]";
  v41 = 66;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

BOOL mlir::func::FuncOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  const void **v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  const void **v28[4];
  __int16 v29;
  _QWORD v30[3];
  void *v31;
  _BYTE v32[96];
  void *v33;
  _QWORD *v34;
  void *__p;
  _QWORD **v36;
  char v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = (const void **)v3[1];
  if (v4)
  {
    v5 = v3[3];
    if (v5)
    {
      v6 = *v3;
      v7 = v3[2];
      v8 = v3[4];
      v30[0] = v2;
      if (!mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(v5, (const void **)"sym_name", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0;
      v30[0] = *this;
      if (!mlir::func::__mlir_ods_local_attr_constraint_FuncOps2(v4, (const void **)"function_type", (const char *)0xD, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0;
      v30[0] = *this;
      if (!mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(v8, (const void **)"sym_visibility", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0;
      v30[0] = *this;
      if (!mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(v6, (const void **)"arg_attrs", (const char *)9, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0;
      v30[0] = *this;
      return mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(v7, (const void **)"res_attrs", (const char *)9, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30) != 0;
    }
    v28[0] = (const void **)"requires attribute 'sym_name'";
    v29 = 259;
    mlir::OpState::emitOpError(this, v28, (uint64_t)v30);
    v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v30);
    if (v30[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v30);
    if (v37)
    {
      v18 = (_QWORD **)__p;
      if (__p)
      {
        v19 = v36;
        v20 = __p;
        if (v36 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v36 = v18;
        operator delete(v20);
      }
      v21 = v33;
      if (v33)
      {
        v22 = v34;
        v23 = v33;
        if (v34 != v33)
        {
          do
          {
            v25 = (void *)*--v22;
            v24 = v25;
            *v22 = 0;
            if (v25)
              operator delete[](v24);
          }
          while (v22 != v21);
          v23 = v33;
        }
        v34 = v21;
        operator delete(v23);
      }
      v26 = v31;
      if (v31 != v32)
LABEL_47:
        free(v26);
    }
  }
  else
  {
    v28[0] = (const void **)"requires attribute 'function_type'";
    v29 = 259;
    mlir::OpState::emitOpError(this, v28, (uint64_t)v30);
    v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v30);
    if (v30[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v30);
    if (v37)
    {
      v10 = (_QWORD **)__p;
      if (__p)
      {
        v11 = v36;
        v12 = __p;
        if (v36 != __p)
        {
          do
            v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
          while (v11 != v10);
          v12 = __p;
        }
        v36 = v10;
        operator delete(v12);
      }
      v13 = v33;
      if (v33)
      {
        v14 = v34;
        v15 = v33;
        if (v34 != v33)
        {
          do
          {
            v17 = (void *)*--v14;
            v16 = v17;
            *v14 = 0;
            if (v17)
              operator delete[](v16);
          }
          while (v14 != v13);
          v15 = v33;
        }
        v34 = v13;
        operator delete(v15);
      }
      v26 = v31;
      if (v31 != v32)
        goto LABEL_47;
    }
  }
  return v9;
}

void mlir::func::ReturnOp::build(mlir::func::ReturnOp *this, mlir::OpBuilder *a2, mlir::OperationState *a3)
{
  unint64_t v4[3];

  v4[2] = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v4, 0, 0);
  mlir::OperationState::addOperands((uint64_t)a2, v4[0], v4[1]);
}

BOOL mlir::func::ReturnOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 v5;
  void *v6;
  void *v8[2];
  uint64_t v9;
  void *v10;
  uint64_t v11;
  _QWORD v12[17];

  v12[16] = *MEMORY[0x1E0C80C00];
  v10 = v12;
  v11 = 0x400000000;
  v8[0] = &v9;
  v8[1] = (void *)0x100000000;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112)
    || (v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1),
        !(*(unsigned __int8 (**)(uint64_t, void **, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, &v10, 0, 1, 0xFFFFFFFFLL))|| (_DWORD)v11&& (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1)|| !mlir::AsmParser::parseTypeList(a1, (uint64_t)v8)))
  {
    v5 = 0;
    v6 = v8[0];
    if (v8[0] == &v9)
      goto LABEL_10;
    goto LABEL_9;
  }
  v5 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>(a1, (uint64_t *)&v10, (uint64_t)v8, v4, a2 + 16) != 0;
  v6 = v8[0];
  if (v8[0] != &v9)
LABEL_9:
    free(v6);
LABEL_10:
  if (v10 != v12)
    free(v10);
  return v5;
}

void mlir::func::ReturnOp::print(mlir::func::ReturnOp *this, mlir::OpAsmPrinter *a2)
{
  _BYTE *v4;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v7;
  llvm::raw_ostream *v8;
  _BYTE *v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  llvm::raw_ostream *v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  llvm::raw_ostream *v16;
  _BYTE *v17;
  llvm::raw_ostream *v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23[2];
  const char *AttrDictionary;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[2];
  void *v29;
  uint64_t v30;
  _QWORD v31[5];

  v31[4] = *MEMORY[0x1E0C80C00];
  v29 = v31;
  v30 = 0x200000000;
  v4 = *(_BYTE **)this;
  if (v4[47])
  {
    AttrDictionary = (const char *)mlir::Operation::getAttrDictionary((mlir::Operation *)v4);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::ArrayAttr *)(v4 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v7, v29, v30);
  if ((*(_BYTE *)(*(_QWORD *)this + 46) & 0x80) != 0 && *(_DWORD *)(*(_QWORD *)this + 68))
  {
    v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v9 = (_BYTE *)*((_QWORD *)v8 + 4);
    if ((unint64_t)v9 >= *((_QWORD *)v8 + 3))
    {
      llvm::raw_ostream::write(v8, 32);
    }
    else
    {
      *((_QWORD *)v8 + 4) = v9 + 1;
      *v9 = 32;
    }
    v10 = *(_BYTE **)this;
    if ((*(_BYTE *)(*(_QWORD *)this + 46) & 0x80) != 0)
    {
      v11 = *((unsigned int *)v10 + 17);
      v12 = *((_QWORD *)v10 + 9);
    }
    else
    {
      v12 = 0;
      v11 = 0;
    }
    v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    AttrDictionary = ", ";
    v25 = 2;
    llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v12, 0, v12, v11, (uint64_t)a2, v13, (uint64_t)&AttrDictionary);
    v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v15 = (_BYTE *)*((_QWORD *)v14 + 4);
    if ((unint64_t)v15 >= *((_QWORD *)v14 + 3))
    {
      llvm::raw_ostream::write(v14, 32);
    }
    else
    {
      *((_QWORD *)v14 + 4) = v15 + 1;
      *v15 = 32;
    }
    v16 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v17 = (_BYTE *)*((_QWORD *)v16 + 4);
    if (*((_BYTE **)v16 + 3) == v17)
    {
      llvm::raw_ostream::write(v16, ":", 1uLL);
    }
    else
    {
      *v17 = 58;
      ++*((_QWORD *)v16 + 4);
    }
    v18 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v19 = (_BYTE *)*((_QWORD *)v18 + 4);
    if ((unint64_t)v19 >= *((_QWORD *)v18 + 3))
    {
      llvm::raw_ostream::write(v18, 32);
    }
    else
    {
      *((_QWORD *)v18 + 4) = v19 + 1;
      *v19 = 32;
    }
    v20 = *(_QWORD *)this;
    if ((*(_BYTE *)(*(_QWORD *)this + 46) & 0x80) != 0)
    {
      v21 = *(unsigned int *)(v20 + 68);
      v22 = *(_QWORD *)(v20 + 72);
    }
    else
    {
      v22 = 0;
      v21 = 0;
    }
    v23[0] = v22;
    v23[1] = v21;
    mlir::OperandRange::getTypes(v23, (uint64_t *)&AttrDictionary);
    v28[0] = ", ";
    v28[1] = 2;
    llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::OperandRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &,mlir::OpAsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>((uint64_t)AttrDictionary, v25, v26, v27, (uint64_t)a2, (uint64_t)a2, (uint64_t)v28);
  }
  if (v29 != v31)
    free(v29);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

uint64_t mlir::RegisteredOperationName::insert<mlir::func::CallIndirectOp>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t result;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v2 = operator new(0x70uLL);
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"func.call_indirect", 18, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::CallIndirectOp,void>::id, (uint64_t)&v9);
  v3 = v9;
  if ((_DWORD)v10)
  {
    v4 = 16 * v10;
    v5 = (void **)((char *)v9 + 8);
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v3 = v9;
  }
  if (v3 != v11)
    free(v3);
  *v2 = &unk_1E0E3F238;
  v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  result = (uint64_t)v8;
  v8 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"func.call_indirect", 18, v3, v4, 0, 0);
  *v5 = &off_1E0E52C08;
  v5[12] = mlir::func::CallIndirectOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::func::CallIndirectOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x20uLL);
  *v2 = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getCallableForCallee;
  v2[1] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::setCalleeFromCallable;
  v2[2] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getArgOperands;
  v2[3] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getArgOperandsMutable;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallOpInterface]";
      v15 = 71;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CallOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[136], v2);
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getCallableForCallee(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24) | 4;
}

void mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::setCalleeFromCallable(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;

  v3 = (uint64_t *)(a3 & 0xFFFFFFFFFFFFFFF8);
  v4 = *(uint64_t **)(a2 + 72);
  v5 = (uint64_t *)v4[1];
  if (v5)
  {
    *v5 = *v4;
    if (*v4)
      *(_QWORD *)(*v4 + 8) = v4[1];
  }
  v4[3] = (uint64_t)v3;
  v6 = *v3;
  *v4 = *v3;
  v4[1] = (uint64_t)v3;
  if (v6)
    *(_QWORD *)(v6 + 8) = v4;
  *v3 = (uint64_t)v4;
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getArgOperands(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    return *(_QWORD *)(a2 + 72) + 32;
  else
    return 32;
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getArgOperandsMutable@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  int v2;

  if ((*(_BYTE *)(a1 + 46) & 0x80) != 0)
    v2 = *(_DWORD *)(a1 + 68) - 1;
  else
    v2 = -1;
  return mlir::MutableOperandRange::MutableOperandRange(a2, a1, 1, v2, 0, 0);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  __guard *v5;
  __guard v6;
  unsigned __int8 v7;
  uint64_t *v8;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  __guard *v17;
  int v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  const char *v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  unint64_t v35;
  unint64_t v36;
  const char *v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  unint64_t v44;
  unint64_t v45;
  const char *v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  unint64_t v53;
  unint64_t v54;
  const char *v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  int v60;
  int v61;
  unint64_t v62;
  unint64_t v63;
  const char *v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  unint64_t v71;
  unint64_t v72;
  const char *v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  __guard v84;
  __guard v85;
  __guard v86;
  __guard v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  const char *v99;
  unint64_t v100;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v93 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v25 = v24;
    a1 = v93;
    if (v25)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v100 = 83;
      v26 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v26)
        v27 = v26;
      else
        v27 = v100;
      v28 = &v99[v27];
      v29 = v100 - v27;
      if (v100 - v27 >= 0x12)
        v30 = 18;
      else
        v30 = v100 - v27;
      v31 = v29 - v30;
      if (v31 >= v31 - 1)
        v32 = v31 - 1;
      else
        v32 = v31;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v28[v30], v32);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v93;
    }
  }
  v3 = v2[187];
  if ((v4 & 1) == 0)
  {
    v88 = v3;
    v94 = a1;
    v34 = v33;
    v3 = v88;
    a1 = v94;
    if (v34)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicResults<Empty>]";
      v100 = 87;
      v35 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v35)
        v36 = v35;
      else
        v36 = v100;
      v37 = &v99[v36];
      v38 = v100 - v36;
      if (v100 - v36 >= 0x12)
        v39 = 18;
      else
        v39 = v100 - v36;
      v40 = v38 - v39;
      if (v40 >= v40 - 1)
        v41 = v40 - 1;
      else
        v41 = v40;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v37[v39], v41);
      v3 = v88;
      a1 = v94;
    }
  }
  v6 = v5[299];
  v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v7 & 1) == 0)
  {
    v89 = v3;
    v95 = a1;
    v84 = v6;
    v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v6 = v84;
    v3 = v89;
    v43 = v42;
    a1 = v95;
    if (v43)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v100 = 86;
      v44 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v44)
        v45 = v44;
      else
        v45 = v100;
      v46 = &v99[v45];
      v47 = v100 - v45;
      if (v100 - v45 >= 0x12)
        v48 = 18;
      else
        v48 = v100 - v45;
      v49 = v47 - v48;
      if (v49 >= v49 - 1)
        v50 = v49 - 1;
      else
        v50 = v49;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v6 = v84;
      v3 = v89;
      a1 = v95;
    }
  }
  v9 = v8[196];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v90 = v3;
    v96 = a1;
    v81 = v9;
    v85 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v81;
    v6 = v85;
    v52 = v51;
    v3 = v90;
    a1 = v96;
    if (v52)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>]";
      v100 = 97;
      v53 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v53)
        v54 = v53;
      else
        v54 = v100;
      v55 = &v99[v54];
      v56 = v100 - v54;
      if (v100 - v54 >= 0x12)
        v57 = 18;
      else
        v57 = v100 - v54;
      v58 = v56 - v57;
      if (v58 >= v58 - 1)
        v59 = v58 - 1;
      else
        v59 = v58;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v81;
      v6 = v85;
      v3 = v90;
      a1 = v96;
    }
  }
  v12 = v11[197];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v91 = v3;
    v97 = a1;
    v82 = v9;
    v86 = v6;
    v79 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v79;
    v9 = v82;
    v6 = v86;
    v3 = v91;
    v61 = v60;
    a1 = v97;
    if (v61)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v100 = 84;
      v62 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v62)
        v63 = v62;
      else
        v63 = v100;
      v64 = &v99[v63];
      v65 = v100 - v63;
      if (v100 - v63 >= 0x12)
        v66 = 18;
      else
        v66 = v100 - v63;
      v67 = v65 - v66;
      if (v67 >= v67 - 1)
        v68 = v67 - 1;
      else
        v68 = v67;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v79;
      v9 = v82;
      v6 = v86;
      v3 = v91;
      a1 = v97;
    }
  }
  v15 = v14[192];
  if ((v16 & 1) == 0)
  {
    v92 = v3;
    v98 = a1;
    v83 = v9;
    v87 = v6;
    v78 = v15;
    v80 = v12;
    v15 = v78;
    v12 = v80;
    v9 = v83;
    v6 = v87;
    v70 = v69;
    v3 = v92;
    a1 = v98;
    if (v70)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallOpInterface::Trait<Empty>]";
      v100 = 85;
      v71 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v71)
        v72 = v71;
      else
        v72 = v100;
      v73 = &v99[v72];
      v74 = v100 - v72;
      if (v100 - v72 >= 0x12)
        v75 = 18;
      else
        v75 = v100 - v72;
      v76 = v74 - v75;
      if (v76 >= v76 - 1)
        v77 = v76 - 1;
      else
        v77 = v76;
      mlir::detail::TypeIDResolver<mlir::CallOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      v15 = v78;
      v12 = v80;
      v9 = v83;
      v6 = v87;
      v3 = v92;
      a1 = v98;
    }
  }
  return v3 == a1 || v6 == a1 || v9 == a1 || v12 == a1 || v15 == a1 || v17[441] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::func::CallIndirectOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::OpTrait::impl *v5;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3)
    || !mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)1))
  {
    return 0;
  }
  v5 = a1;
  return mlir::func::CallIndirectOp::verifyInvariantsImpl((uint64_t **)&v5) != 0;
}

uint64_t mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::func::CallOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolUserOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"func.call", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::CallOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E3F300;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::CallOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::func::CallOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                       + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 6 && (*(_DWORD *)a3 == 1819042147 ? (v7 = *(unsigned __int16 *)(a3 + 4) == 25957) : (v7 = 0), v7))
    return *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v11 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v11);
  if (v7 == 6 && *(_DWORD *)result == 1819042147 && *(_WORD *)(result + 4) == 25957)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
        v9 = a4;
      else
        v9 = 0;
      v12 = v9;
      if (v9)
      {
        result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
        if (v10)
          v9 = 0;
        else
          v9 = a4;
      }
      *v5 = v9;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v5 = *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"callee", 6, v5);
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::CallOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;

  v7 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  return !v7
      || mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v7, (const void **)"callee", (const char *)6, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::func::CallOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::func::CallOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::CallOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::FlatSymbolRefAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x20uLL);
  *v2 = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getCallableForCallee;
  v2[1] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::setCalleeFromCallable;
  v2[2] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getArgOperands;
  v2[3] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getArgOperandsMutable;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallOpInterface]";
      v15 = 71;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CallOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[136], v2);
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getCallableForCallee(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  char v4;

  if (!*(_BYTE *)(a2 + 47) || (result = mlir::Operation::getInherentAttr(a2, (uint64_t)"callee", 6), !v4))
    result = mlir::DictionaryAttr::get(a2 + 56, "callee", 6uLL);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)result + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
      return result & 0xFFFFFFFFFFFFFFFBLL;
    else
      return 0;
  }
  return result;
}

void mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::setCalleeFromCallable(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  mlir::StringAttr *Context;
  uint64_t v6;
  _QWORD v7[4];
  __int16 v8;

  v4 = a3 & 0xFFFFFFFFFFFFFFF8;
  Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v8 = 261;
  v7[0] = "callee";
  v7[1] = 6;
  v6 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)v7);
  mlir::Operation::setAttr(a2, v6, v4);
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getArgOperands(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    return *(_QWORD *)(a2 + 72);
  else
    return 0;
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getArgOperandsMutable@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  int v2;

  if ((*(_BYTE *)(a1 + 46) & 0x80) != 0)
    v2 = *(_DWORD *)(a1 + 68);
  else
    v2 = 0;
  return mlir::MutableOperandRange::MutableOperandRange(a2, a1, 0, v2, 0, 0);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolUserOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::SymbolUserOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::verifySymbolUses;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SymbolUserOpInterface]";
      v15 = 77;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::SymbolUserOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[155], v2);
}

uint64_t mlir::detail::SymbolUserOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::verifySymbolUses(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::func::CallOp::verifySymbolUses(&v4, a3);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  __guard *v5;
  __guard v6;
  unsigned __int8 v7;
  uint64_t *v8;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  void **p_vtable;
  void *v18;
  unsigned __int8 v19;
  __guard *v20;
  __guard v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  __guard *v26;
  int v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  const char *v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  const char *v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  unint64_t v56;
  unint64_t v57;
  const char *v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  unint64_t v65;
  unint64_t v66;
  const char *v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  unint64_t v74;
  unint64_t v75;
  const char *v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  unint64_t v83;
  unint64_t v84;
  const char *v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  unint64_t v92;
  unint64_t v93;
  const char *v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  unint64_t v101;
  unint64_t v102;
  const char *v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  unint64_t v110;
  unint64_t v111;
  const char *v112;
  unint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  __guard v118;
  __guard v119;
  void *v120;
  void *v121;
  void *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  __guard v138;
  __guard v139;
  __guard v140;
  __guard v141;
  __guard v142;
  __guard v143;
  __guard v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  void *v153;
  void *v154;
  void *v155;
  void *v156;
  void *v157;
  void *v158;
  void *v159;
  void *v160;
  void *v161;
  const char *v162;
  unint64_t v163;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v153 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v37 = v36;
    a1 = v153;
    if (v37)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v163 = 83;
      v38 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v38)
        v39 = v38;
      else
        v39 = v163;
      v40 = &v162[v39];
      v41 = v163 - v39;
      if (v163 - v39 >= 0x12)
        v42 = 18;
      else
        v42 = v163 - v39;
      v43 = v41 - v42;
      if (v43 >= v43 - 1)
        v44 = v43 - 1;
      else
        v44 = v43;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v153;
    }
  }
  v3 = v2[187];
  if ((v4 & 1) == 0)
  {
    v145 = v3;
    v154 = a1;
    v46 = v45;
    v3 = v145;
    a1 = v154;
    if (v46)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicResults<Empty>]";
      v163 = 87;
      v47 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v47)
        v48 = v47;
      else
        v48 = v163;
      v49 = &v162[v48];
      v50 = v163 - v48;
      if (v163 - v48 >= 0x12)
        v51 = 18;
      else
        v51 = v163 - v48;
      v52 = v50 - v51;
      if (v52 >= v52 - 1)
        v53 = v52 - 1;
      else
        v53 = v52;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      v3 = v145;
      a1 = v154;
    }
  }
  v6 = v5[299];
  v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v7 & 1) == 0)
  {
    v146 = v3;
    v155 = a1;
    v138 = v6;
    v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v6 = v138;
    v55 = v54;
    v3 = v146;
    a1 = v155;
    if (v55)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v163 = 86;
      v56 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v56)
        v57 = v56;
      else
        v57 = v163;
      v58 = &v162[v57];
      v59 = v163 - v57;
      if (v163 - v57 >= 0x12)
        v60 = 18;
      else
        v60 = v163 - v57;
      v61 = v59 - v60;
      if (v61 >= v61 - 1)
        v62 = v61 - 1;
      else
        v62 = v61;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v6 = v138;
      v3 = v146;
      a1 = v155;
    }
  }
  v9 = v8[196];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v147 = v3;
    v156 = a1;
    v132 = v9;
    v139 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v132;
    v6 = v139;
    v64 = v63;
    v3 = v147;
    a1 = v156;
    if (v64)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicOperands<Empty>]";
      v163 = 88;
      v65 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v65)
        v66 = v65;
      else
        v66 = v163;
      v67 = &v162[v66];
      v68 = v163 - v66;
      if (v163 - v66 >= 0x12)
        v69 = 18;
      else
        v69 = v163 - v66;
      v70 = v68 - v69;
      if (v70 >= v70 - 1)
        v71 = v70 - 1;
      else
        v71 = v70;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v132;
      v6 = v139;
      v3 = v147;
      a1 = v156;
    }
  }
  v12 = v11[198];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v148 = v3;
    v157 = a1;
    v133 = v9;
    v140 = v6;
    v127 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v127;
    v9 = v133;
    v6 = v140;
    v73 = v72;
    v3 = v148;
    a1 = v157;
    if (v73)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v163 = 84;
      v74 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v74)
        v75 = v74;
      else
        v75 = v163;
      v76 = &v162[v75];
      v77 = v163 - v75;
      if (v163 - v75 >= 0x12)
        v78 = 18;
      else
        v78 = v163 - v75;
      v79 = v77 - v78;
      if (v79 >= v79 - 1)
        v80 = v79 - 1;
      else
        v80 = v79;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v127;
      v9 = v133;
      v6 = v140;
      v3 = v148;
      a1 = v157;
    }
  }
  v15 = v14[192];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v16 & 1) == 0)
  {
    v149 = v3;
    v158 = a1;
    v134 = v9;
    v141 = v6;
    v123 = v15;
    v128 = v12;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v15 = v123;
    v12 = v128;
    v9 = v134;
    v6 = v141;
    v82 = v81;
    v3 = v149;
    a1 = v158;
    if (v82)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v163 = 89;
      v83 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v83)
        v84 = v83;
      else
        v84 = v163;
      v85 = &v162[v84];
      v86 = v163 - v84;
      if (v163 - v84 >= 0x12)
        v87 = 18;
      else
        v87 = v163 - v84;
      v88 = v86 - v87;
      if (v88 >= v88 - 1)
        v89 = v88 - 1;
      else
        v89 = v88;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v15 = v123;
      v12 = v128;
      v9 = v134;
      v6 = v141;
      v3 = v149;
      a1 = v158;
    }
  }
  v18 = p_vtable[481];
  if ((v19 & 1) == 0)
  {
    v150 = v3;
    v159 = a1;
    v135 = v9;
    v142 = v6;
    v124 = v15;
    v129 = v12;
    v120 = v18;
    v18 = v120;
    v15 = v124;
    v12 = v129;
    v9 = v135;
    v6 = v142;
    v91 = v90;
    v3 = v150;
    a1 = v159;
    if (v91)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallOpInterface::Trait<Empty>]";
      v163 = 85;
      v92 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v92)
        v93 = v92;
      else
        v93 = v163;
      v94 = &v162[v93];
      v95 = v163 - v93;
      if (v163 - v93 >= 0x12)
        v96 = 18;
      else
        v96 = v163 - v93;
      v97 = v95 - v96;
      if (v97 >= v97 - 1)
        v98 = v97 - 1;
      else
        v98 = v97;
      mlir::detail::TypeIDResolver<mlir::CallOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      v18 = v120;
      v15 = v124;
      v12 = v129;
      v9 = v135;
      v6 = v142;
      v3 = v150;
      a1 = v159;
    }
  }
  v21 = v20[441];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v151 = v3;
    v160 = a1;
    v136 = v9;
    v143 = v6;
    v125 = v15;
    v130 = v12;
    v118 = v21;
    v121 = v18;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v118;
    v18 = v121;
    v15 = v125;
    v12 = v130;
    v9 = v136;
    v6 = v143;
    v100 = v99;
    v3 = v151;
    a1 = v160;
    if (v100)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::MemRefsNormalizable<Empty>]";
      v163 = 91;
      v101 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v101)
        v102 = v101;
      else
        v102 = v163;
      v103 = &v162[v102];
      v104 = v163 - v102;
      if (v163 - v102 >= 0x12)
        v105 = 18;
      else
        v105 = v163 - v102;
      v106 = v104 - v105;
      if (v106 >= v106 - 1)
        v107 = v106 - 1;
      else
        v107 = v106;
      mlir::detail::TypeIDResolver<mlir::OpTrait::MemRefsNormalizable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::MemRefsNormalizable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v118;
      v18 = v121;
      v15 = v125;
      v12 = v130;
      v9 = v136;
      v6 = v143;
      v3 = v151;
      a1 = v160;
    }
  }
  v24 = v23[202];
  if ((v25 & 1) == 0)
  {
    v152 = v3;
    v161 = a1;
    v137 = v9;
    v144 = v6;
    v126 = v15;
    v131 = v12;
    v119 = v21;
    v122 = v18;
    v117 = v24;
    v24 = v117;
    v21 = v119;
    v18 = v122;
    v15 = v126;
    v12 = v131;
    v9 = v137;
    v6 = v144;
    v109 = v108;
    v3 = v152;
    a1 = v161;
    if (v109)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SymbolUserOpInterface::Trait<Empty>]";
      v163 = 91;
      v110 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v110)
        v111 = v110;
      else
        v111 = v163;
      v112 = &v162[v111];
      v113 = v163 - v111;
      if (v163 - v111 >= 0x12)
        v114 = 18;
      else
        v114 = v163 - v111;
      v115 = v113 - v114;
      if (v115 >= v115 - 1)
        v116 = v115 - 1;
      else
        v116 = v115;
      mlir::detail::TypeIDResolver<mlir::SymbolUserOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SymbolUserOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v112[v114], v116);
      v24 = v117;
      v21 = v119;
      v18 = v122;
      v15 = v126;
      v12 = v131;
      v9 = v137;
      v6 = v144;
      v3 = v152;
      a1 = v161;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == (_QWORD)a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == a1
      || v21 == (_QWORD)a1
      || v24 == (_QWORD)a1
      || v26[443] == (_QWORD)a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::func::CallOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::OpTrait::impl *v5;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3))
  {
    return 0;
  }
  v5 = a1;
  return mlir::func::CallOp::verifyInvariantsImpl((uint64_t **)&v5) != 0;
}

uint64_t mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"func.constant", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::ConstantOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E3F170;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::func::ConstantOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                    + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 5 && (*(_DWORD *)a3 == 1970037110 ? (v7 = *(_BYTE *)(a3 + 4) == 101) : (v7 = 0), v7))
    return *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v11 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v11);
  if (v7 == 5 && *(_DWORD *)result == 1970037110 && *(_BYTE *)(result + 4) == 101)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
        v9 = a4;
      else
        v9 = 0;
      v12 = v9;
      if (v9)
      {
        result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
        if (v10)
          v9 = 0;
        else
          v9 = a4;
      }
      *v5 = v9;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v5 = *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"value", 5, v5);
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;

  v7 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  return !v7
      || mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v7, (const void **)"value", (const char *)5, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::func::ConstantOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::ConstantOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::FlatSymbolRefAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ConstantOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ConstantOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x20uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getDefaultDialect;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[139], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  return a3(a4, a2 - 16, "f", 1);
}

const char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getDefaultDialect()
{
  return "";
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldSingleResultHook<mlir::func::ConstantOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldSingleResultHook<mlir::func::ConstantOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t Context;
  unint64_t v15;
  uint64_t v16;
  uint64_t v18;
  _BYTE v19[8];
  char v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25[3];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  v10 = a1 + 64;
  v11 = (uint64_t *)(a1 + 64 + 16 * ((v9 >> 23) & 1));
  v12 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v13 = (((unint64_t)v11 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v13 = 0;
    v12 = 0;
  }
  mlir::ValueRange::ValueRange(v25, v13, v12);
  v18 = v8;
  v19[0] = 0;
  v20 = 0;
  v21 = *v11;
  v22 = *(_OWORD *)v25;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v18);
    if (v20)
      v20 = 0;
    mlir::OperationName::OperationName(v19, "func.constant", 13, Context);
    v20 = 1;
  }
  v23 = a2;
  v24 = a3;
  v15 = *(_QWORD *)(v10 + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1)) & 0xFFFFFFFFFFFFFFFBLL;
  if (v15 < 8)
    return 0;
  v16 = *(unsigned int *)(a4 + 8);
  if (v16 >= *(_DWORD *)(a4 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v16 + 1, 8);
    LODWORD(v16) = *(_DWORD *)(a4 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a4 + 8 * v16) = v15;
  ++*(_DWORD *)(a4 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **v20;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  void **v26;
  void *v27;
  unsigned __int8 v28;
  void **v29;
  void *v30;
  unsigned __int8 v31;
  uint64_t *v32;
  uint64_t v33;
  unsigned __int8 v34;
  uint64_t *v35;
  int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  const char *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  const char *v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  unint64_t v86;
  unint64_t v87;
  const char *v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  const char *v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  unint64_t v104;
  unint64_t v105;
  const char *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unint64_t v113;
  unint64_t v114;
  const char *v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  unint64_t v122;
  unint64_t v123;
  const char *v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  int v129;
  int v130;
  unint64_t v131;
  unint64_t v132;
  const char *v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  unint64_t v140;
  unint64_t v141;
  const char *v142;
  unint64_t v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  int v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  const char *v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  uint64_t v156;
  void *v157;
  void *v158;
  void *v159;
  void *v160;
  void *v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  void *v166;
  void *v167;
  void *v168;
  void *v169;
  void *v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  void *v192;
  void *v193;
  void *v194;
  void *v195;
  void *v196;
  void *v197;
  void *v198;
  void *v199;
  void *v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  void *v222;
  void *v223;
  void *v224;
  void *v225;
  void *v226;
  void *v227;
  void *v228;
  void *v229;
  void *v230;
  void *v231;
  void *v232;
  void *v233;
  const char *v234;
  unint64_t v235;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v222 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v49 = v48;
    a1 = v222;
    if (v49)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v235 = 83;
      v50 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v50)
        v51 = v50;
      else
        v51 = v235;
      v52 = &v234[v51];
      v53 = v235 - v51;
      if (v235 - v51 >= 0x12)
        v54 = 18;
      else
        v54 = v235 - v51;
      v55 = v53 - v54;
      if (v55 >= v55 - 1)
        v56 = v55 - 1;
      else
        v56 = v55;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v222;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v211 = v3;
    v223 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v58 = v57;
    v3 = v211;
    a1 = v223;
    if (v58)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v235 = 81;
      v59 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v59)
        v60 = v59;
      else
        v60 = v235;
      v61 = &v234[v60];
      v62 = v235 - v60;
      if (v235 - v60 >= 0x12)
        v63 = 18;
      else
        v63 = v235 - v60;
      v64 = v62 - v63;
      if (v64 >= v64 - 1)
        v65 = v64 - 1;
      else
        v65 = v64;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v211;
      a1 = v223;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v212 = v3;
    v224 = a1;
    v201 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v201;
    v3 = v212;
    v67 = v66;
    a1 = v224;
    if (v67)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v235 = 104;
      v68 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v68)
        v69 = v68;
      else
        v69 = v235;
      v70 = &v234[v69];
      v71 = v235 - v69;
      if (v235 - v69 >= 0x12)
        v72 = 18;
      else
        v72 = v235 - v69;
      v73 = v71 - v72;
      if (v73 >= v73 - 1)
        v74 = v73 - 1;
      else
        v74 = v73;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v201;
      v3 = v212;
      a1 = v224;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v213 = v3;
    v225 = a1;
    v202 = v6;
    v192 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v192;
    v6 = v202;
    v3 = v213;
    v76 = v75;
    a1 = v225;
    if (v76)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v235 = 86;
      v77 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v77)
        v78 = v77;
      else
        v78 = v235;
      v79 = &v234[v78];
      v80 = v235 - v78;
      if (v235 - v78 >= 0x12)
        v81 = 18;
      else
        v81 = v235 - v78;
      v82 = v80 - v81;
      if (v82 >= v82 - 1)
        v83 = v82 - 1;
      else
        v83 = v82;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v192;
      v6 = v202;
      v3 = v213;
      a1 = v225;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v214 = v3;
    v226 = a1;
    v203 = v6;
    v184 = v12;
    v193 = v9;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v184;
    v9 = v193;
    v6 = v203;
    v3 = v214;
    v85 = v84;
    a1 = v226;
    if (v85)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroOperands<Empty>]";
      v235 = 84;
      v86 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v86)
        v87 = v86;
      else
        v87 = v235;
      v88 = &v234[v87];
      v89 = v235 - v87;
      if (v235 - v87 >= 0x12)
        v90 = 18;
      else
        v90 = v235 - v87;
      v91 = v89 - v90;
      if (v91 >= v91 - 1)
        v92 = v91 - 1;
      else
        v92 = v91;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v184;
      v9 = v193;
      v6 = v203;
      v3 = v214;
      a1 = v226;
    }
  }
  v15 = v14[193];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v215 = v3;
    v227 = a1;
    v204 = v6;
    v185 = v12;
    v194 = v9;
    v177 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v177;
    v12 = v185;
    v9 = v194;
    v6 = v204;
    v3 = v215;
    v94 = v93;
    a1 = v227;
    if (v94)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v235 = 84;
      v95 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v95)
        v96 = v95;
      else
        v96 = v235;
      v97 = &v234[v96];
      v98 = v235 - v96;
      if (v235 - v96 >= 0x12)
        v99 = 18;
      else
        v99 = v235 - v96;
      v100 = v98 - v99;
      if (v100 >= v100 - 1)
        v101 = v100 - 1;
      else
        v101 = v100;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v177;
      v12 = v185;
      v9 = v194;
      v6 = v204;
      v3 = v215;
      a1 = v227;
    }
  }
  v18 = v17[192];
  v20 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v216 = v3;
    v228 = a1;
    v205 = v6;
    v186 = v12;
    v195 = v9;
    v171 = v18;
    v178 = v15;
    v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v171;
    v15 = v178;
    v12 = v186;
    v9 = v195;
    v6 = v205;
    v3 = v216;
    v103 = v102;
    a1 = v228;
    if (v103)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v235 = 89;
      v104 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v104)
        v105 = v104;
      else
        v105 = v235;
      v106 = &v234[v105];
      v107 = v235 - v105;
      if (v235 - v105 >= 0x12)
        v108 = 18;
      else
        v108 = v235 - v105;
      v109 = v107 - v108;
      if (v109 >= v109 - 1)
        v110 = v109 - 1;
      else
        v110 = v109;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v171;
      v15 = v178;
      v12 = v186;
      v9 = v195;
      v6 = v205;
      v3 = v216;
      a1 = v228;
    }
  }
  v21 = v20[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v217 = v3;
    v229 = a1;
    v206 = v6;
    v187 = v12;
    v196 = v9;
    v172 = v18;
    v179 = v15;
    v166 = v21;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v166;
    v18 = v172;
    v15 = v179;
    v12 = v187;
    v9 = v196;
    v6 = v206;
    v3 = v217;
    v112 = v111;
    a1 = v229;
    if (v112)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ConstantLike<Empty>]";
      v235 = 84;
      v113 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v113)
        v114 = v113;
      else
        v114 = v235;
      v115 = &v234[v114];
      v116 = v235 - v114;
      if (v235 - v114 >= 0x12)
        v117 = 18;
      else
        v117 = v235 - v114;
      v118 = v116 - v117;
      if (v118 >= v118 - 1)
        v119 = v118 - 1;
      else
        v119 = v118;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v166;
      v18 = v172;
      v15 = v179;
      v12 = v187;
      v9 = v196;
      v6 = v206;
      v3 = v217;
      a1 = v229;
    }
  }
  v24 = v23[189];
  v26 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v25 & 1) == 0)
  {
    v218 = v3;
    v230 = a1;
    v207 = v6;
    v188 = v12;
    v197 = v9;
    v173 = v18;
    v180 = v15;
    v162 = v24;
    v167 = v21;
    v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v24 = v162;
    v21 = v167;
    v18 = v173;
    v15 = v180;
    v12 = v188;
    v9 = v197;
    v6 = v207;
    v3 = v218;
    v121 = v120;
    a1 = v230;
    if (v121)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v235 = 95;
      v122 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v122)
        v123 = v122;
      else
        v123 = v235;
      v124 = &v234[v123];
      v125 = v235 - v123;
      if (v235 - v123 >= 0x12)
        v126 = 18;
      else
        v126 = v235 - v123;
      v127 = v125 - v126;
      if (v127 >= v127 - 1)
        v128 = v127 - 1;
      else
        v128 = v127;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v24 = v162;
      v21 = v167;
      v18 = v173;
      v15 = v180;
      v12 = v188;
      v9 = v197;
      v6 = v207;
      v3 = v218;
      a1 = v230;
    }
  }
  v27 = v26[486];
  v29 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v28 & 1) == 0)
  {
    v219 = v3;
    v231 = a1;
    v208 = v6;
    v189 = v12;
    v198 = v9;
    v174 = v18;
    v181 = v15;
    v163 = v24;
    v168 = v21;
    v159 = v27;
    v29 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v27 = v159;
    v24 = v163;
    v21 = v168;
    v18 = v174;
    v15 = v181;
    v12 = v189;
    v9 = v198;
    v6 = v208;
    v3 = v219;
    v130 = v129;
    a1 = v231;
    if (v130)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v235 = 99;
      v131 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v131)
        v132 = v131;
      else
        v132 = v235;
      v133 = &v234[v132];
      v134 = v235 - v132;
      if (v235 - v132 >= 0x12)
        v135 = 18;
      else
        v135 = v235 - v132;
      v136 = v134 - v135;
      if (v136 >= v136 - 1)
        v137 = v136 - 1;
      else
        v137 = v136;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      v29 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v27 = v159;
      v24 = v163;
      v21 = v168;
      v18 = v174;
      v15 = v181;
      v12 = v189;
      v9 = v198;
      v6 = v208;
      v3 = v219;
      a1 = v231;
    }
  }
  v30 = v29[504];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v220 = v3;
    v232 = a1;
    v209 = v6;
    v190 = v12;
    v199 = v9;
    v175 = v18;
    v182 = v15;
    v164 = v24;
    v169 = v21;
    v157 = v30;
    v160 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v157;
    v27 = v160;
    v24 = v164;
    v21 = v169;
    v18 = v175;
    v15 = v182;
    v12 = v190;
    v9 = v199;
    v6 = v209;
    v3 = v220;
    v139 = v138;
    a1 = v232;
    if (v139)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v235 = 93;
      v140 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v140)
        v141 = v140;
      else
        v141 = v235;
      v142 = &v234[v141];
      v143 = v235 - v141;
      if (v235 - v141 >= 0x12)
        v144 = 18;
      else
        v144 = v235 - v141;
      v145 = v143 - v144;
      if (v145 >= v145 - 1)
        v146 = v145 - 1;
      else
        v146 = v145;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v157;
      v27 = v160;
      v24 = v164;
      v21 = v169;
      v18 = v175;
      v15 = v182;
      v12 = v190;
      v9 = v199;
      v6 = v209;
      v3 = v220;
      a1 = v232;
    }
  }
  v33 = v32[158];
  v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v34 & 1) == 0)
  {
    v221 = v3;
    v233 = a1;
    v210 = v6;
    v191 = v12;
    v200 = v9;
    v176 = v18;
    v183 = v15;
    v165 = v24;
    v170 = v21;
    v158 = v30;
    v161 = v27;
    v156 = v33;
    v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v33 = v156;
    v30 = v158;
    v27 = v161;
    v24 = v165;
    v21 = v170;
    v18 = v176;
    v15 = v183;
    v12 = v191;
    v9 = v200;
    v6 = v210;
    v3 = v221;
    v148 = v147;
    a1 = v233;
    if (v148)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v235 = 86;
      v149 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v149)
        v150 = v149;
      else
        v150 = v235;
      v151 = &v234[v150];
      v152 = v235 - v150;
      if (v235 - v150 >= 0x12)
        v153 = 18;
      else
        v153 = v235 - v150;
      v154 = v152 - v153;
      if (v154 >= v154 - 1)
        v155 = v154 - 1;
      else
        v155 = v154;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v33 = v156;
      v30 = v158;
      v27 = v161;
      v24 = v165;
      v21 = v170;
      v18 = v176;
      v15 = v183;
      v12 = v191;
      v9 = v200;
      v6 = v210;
      v3 = v221;
      a1 = v233;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == a1
      || v30 == a1
      || v33 == (_QWORD)a1
      || v35[138] == (_QWORD)a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;

  mlir::OpState::printOpName(a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::func::ConstantOp::print((mlir::func::ConstantOp *)&v7, a3);
}

BOOL mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroOperands(a1, v5))
    return 0;
  v7 = a1;
  if (!mlir::func::ConstantOp::verifyInvariantsImpl((uint64_t **)&v7))
    return 0;
  v7 = a1;
  return mlir::func::ConstantOp::verify((uint64_t **)&v7) != 0;
}

uint64_t mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"func.func", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E3F3C8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::getParseAssemblyFn(uint64_t (**a1)(mlir::AsmParser *a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::func::FuncOp::parse;
  a1[3] = (uint64_t (*)(mlir::AsmParser *, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                             + 2);
}

void mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                       + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::func::FuncOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  _QWORD *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::func::FuncOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::func::FuncOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::func::FuncOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::getOpPropertyByteSize()
{
  return 40;
}

double mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[1];
    *(_QWORD *)(a3 + 32) = *((_QWORD *)a4 + 4);
    *(_OWORD *)a3 = v4;
    *(_OWORD *)(a3 + 16) = v5;
  }
  else
  {
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)&v4 = 0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::func::FuncOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::func::FuncOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] == a2[3])
    return a3[4] == a2[4];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::func::FuncOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::ArrayAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::TypeAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::ArrayAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::StringAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::StringAttr>(a1, v3 + 4) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[3]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[4]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x80uLL);
  *v2 = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getNameAttr;
  v2[1] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setName;
  v2[2] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getVisibility;
  v2[3] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isNested;
  v2[4] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isPrivate;
  v2[5] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isPublic;
  v2[6] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setVisibility;
  v2[7] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setNested;
  v2[8] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setPrivate;
  v2[9] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setPublic;
  v2[10] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getSymbolUses;
  v2[11] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::symbolKnownUseEmpty;
  v2[12] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::replaceAllSymbolUses;
  v2[13] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isOptionalSymbol;
  v2[14] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::canDiscardOnUseEmpty;
  v2[15] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isDeclaration;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SymbolOpInterface]";
      v15 = 73;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::SymbolOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[143], v2);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getNameAttr(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolName(this, this);
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setName(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::StringAttr *Context;
  uint64_t v6;
  _QWORD v7[4];
  __int16 v8;

  Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v8 = 261;
  v7[0] = "sym_name";
  v7[1] = 8;
  v6 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)v7);
  mlir::Operation::setAttr(a2, v6, a3);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getVisibility(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this);
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isNested(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this) == 2;
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isPrivate(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this) == 1;
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isPublic(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this) == 0;
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setVisibility(uint64_t a1, uint64_t a2, int a3)
{
  mlir::SymbolTable::setSymbolVisibility(a2, a3);
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setNested(uint64_t a1, uint64_t a2)
{
  mlir::SymbolTable::setSymbolVisibility(a2, 2);
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setPrivate(uint64_t a1, uint64_t a2)
{
  mlir::SymbolTable::setSymbolVisibility(a2, 1);
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setPublic(uint64_t a1, uint64_t a2)
{
  mlir::SymbolTable::setSymbolVisibility(a2, 0);
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getSymbolUses(mlir::SymbolTable *a1@<X1>, mlir::Operation *a2@<X2>, uint64_t a3@<X8>)
{
  mlir::SymbolTable::getSymbolUses(a1, a2, a3);
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::symbolKnownUseEmpty(uint64_t a1, mlir::SymbolTable *a2, mlir::Operation *a3)
{
  return mlir::SymbolTable::symbolKnownUseEmpty(a2, a3, a3);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::replaceAllSymbolUses(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4)
{
  return mlir::SymbolTable::replaceAllSymbolUses(a2, a3, a4);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isOptionalSymbol()
{
  return 0;
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::canDiscardOnUseEmpty(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this) != 0;
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isDeclaration(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  _QWORD *v3;

  v2 = *(unsigned int *)(a2 + 44);
  if ((v2 & 0x7FFFFF) == 0)
    return MEMORY[0] == 0;
  v3 = (_QWORD *)(((a2 + 16 * ((v2 >> 23) & 1) + ((v2 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                + 32 * *(unsigned int *)(a2 + 40));
  return *v3 == (_QWORD)v3;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x48uLL);
  *v2 = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getCallableRegion;
  v2[1] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getArgumentTypes;
  v2[2] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getResultTypes;
  v2[3] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getArgAttrsAttr;
  v2[4] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getResAttrsAttr;
  v2[5] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setArgAttrsAttr;
  v2[6] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setResAttrsAttr;
  v2[7] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::removeArgAttrsAttr;
  v2[8] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::removeResAttrsAttr;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallableOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CallableOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[145], v2);
}

_QWORD *mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getCallableRegion(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  _QWORD *v3;

  v2 = *(unsigned int *)(a2 + 44);
  if ((v2 & 0x7FFFFF) == 0)
    return 0;
  v3 = (_QWORD *)(((a2 + 16 * ((v2 >> 23) & 1) + ((v2 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                + 32 * *(unsigned int *)(a2 + 40));
  if ((_QWORD *)*v3 == v3)
    return 0;
  else
    return v3;
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getArgumentTypes(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t Value;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v2 = 0;
  Value = *(_QWORD *)(v2 + 8);
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value);
  return mlir::FunctionType::getInputs((mlir::FunctionType *)&Value);
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getResultTypes(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t Value;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v2 = 0;
  Value = *(_QWORD *)(v2 + 8);
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value);
  return mlir::FunctionType::getResults((mlir::FunctionType *)&Value);
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getArgAttrsAttr(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getResAttrsAttr(uint64_t a1, uint64_t a2)
{
  unint64_t v2;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v2 = 0;
  return *(_QWORD *)(v2 + 16);
}

void mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setArgAttrsAttr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Operation::setAttr(a2, **(_QWORD **)(*(_QWORD *)(a2 + 48) + 96), a3);
}

void mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setResAttrsAttr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Operation::setAttr(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 96) + 16), a3);
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::removeArgAttrsAttr(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v2 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v2 = 0;
  *v2 = 0;
  return 0;
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::removeResAttrsAttr(uint64_t a1, uint64_t a2)
{
  unint64_t v2;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v2 = 0;
  *(_QWORD *)(v2 + 16) = 0;
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  const char *v13;
  unint64_t v14;

  v2 = malloc(0x38uLL);
  *v2 = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getFunctionType;
  v2[1] = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setFunctionTypeAttr;
  v2[2] = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::cloneTypeWith;
  v2[3] = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::verifyBody;
  v2[4] = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::verifyType;
  v2[5] = mlir::detail::InterfaceMap::lookup<mlir::SymbolOpInterface>(a1);
  v2[6] = mlir::detail::InterfaceMap::lookup<mlir::CallableOpInterface>(a1);
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    if (v5)
    {
      v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::FunctionOpInterface]";
      v14 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v6)
        v7 = v6;
      else
        v7 = v14;
      v8 = &v13[v7];
      v9 = v14 - v7;
      if (v14 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v14 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::FunctionOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[147], v2);
}

uint64_t mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getFunctionType(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v2 = 0;
  v4 = *(_QWORD *)(v2 + 8);
  return mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v4);
}

void mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setFunctionTypeAttr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Operation::setAttr(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 96) + 8), a3);
}

uint64_t mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::cloneTypeWith(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v10;
  uint64_t Value;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v10 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v10 = 0;
  Value = *(_QWORD *)(v10 + 8);
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value);
  return mlir::FunctionType::clone((mlir::Attribute *)&Value, a3, a4, a5, a6);
}

uint64_t mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::verifyBody(uint64_t a1, uint64_t *a2)
{
  uint64_t *v3;

  v3 = a2;
  return mlir::detail::FunctionOpInterfaceTrait<mlir::func::FuncOp>::verifyBody(&v3);
}

uint64_t mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::verifyType()
{
  return 1;
}

uint64_t mlir::detail::FunctionOpInterfaceTrait<mlir::func::FuncOp>::verifyBody(uint64_t **a1)
{
  uint64_t *v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t Inputs;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  unint64_t v16;
  uint64_t v17;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  char *v24;
  char *v25;
  __int128 v26;
  _QWORD **v27;
  _QWORD **v28;
  void *v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  void *v33;
  void *v34;
  int *v35;
  char *v36;
  char *v37;
  __int128 v38;
  int *v39;
  char *v40;
  char *v41;
  __int128 v42;
  uint64_t v43;
  int *v44;
  char *v45;
  char *v46;
  __int128 v47;
  uint64_t v48;
  int *v49;
  char *v50;
  char *v51;
  __int128 v52;
  uint64_t v53;
  int *v54;
  char *v55;
  char *v56;
  __int128 v57;
  _QWORD **v58;
  _QWORD **v59;
  void *v60;
  _QWORD *v61;
  _QWORD *v62;
  void *v63;
  void *v64;
  void *v65;
  void *v66;
  unint64_t v68;
  unint64_t v69;
  BOOL v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  BOOL v74;
  unint64_t v75;
  BOOL v76;
  unint64_t v77;
  int64_t v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  const void **v85[4];
  __int16 v86;
  int v87;
  const char *v88;
  uint64_t v89;
  uint64_t Value;
  _BYTE v91[16];
  void *v92;
  unsigned int v93;
  unsigned int v94;
  _BYTE v95[96];
  void *v96;
  _QWORD *v97;
  void *__p;
  _QWORD **v99;
  char v100;
  uint64_t v101;

  v101 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v3 = *((unsigned int *)*a1 + 11);
  if ((v3 & 0x7FFFFF) != 0)
  {
    v4 = (_QWORD *)((((unint64_t)&v2[2 * ((v3 >> 23) & 1) + 8] + ((v3 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)v2 + 10));
    if ((_QWORD *)*v4 == v4)
      return 1;
  }
  else if (!MEMORY[0])
  {
    return 1;
  }
  v5 = (uint64_t)&v2[2 * ((v3 >> 23) & 1) + 8];
  if (HIBYTE(*((_DWORD *)*a1 + 11)))
    v6 = v5;
  else
    v6 = 0;
  Value = *(_QWORD *)(v6 + 8);
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value);
  Inputs = mlir::FunctionType::getInputs((mlir::FunctionType *)&Value);
  v9 = v8;
  v10 = *(_QWORD *)((((unint64_t)&(*a1)[2 * (((unint64_t)*((unsigned int *)*a1 + 11) >> 23) & 1) + 8]
                    + (((unint64_t)*((unsigned int *)*a1 + 11) >> 21) & 0x7F8)
                    + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)*a1 + 10)
                  + 8);
  if (v10)
    v11 = v10 - 8;
  else
    v11 = 0;
  v13 = v11 + 48;
  v12 = *(_QWORD *)(v11 + 48);
  if (((unint64_t)(*(_QWORD *)(v13 + 8) - v12) >> 3) != v8)
  {
    v85[0] = (const void **)"entry block must have ";
    v86 = 259;
    mlir::OpState::emitOpError(a1, v85, (uint64_t)&Value);
    if (Value)
    {
      v87 = 5;
      v88 = (const char *)v9;
      v18 = &v87;
      v19 = (char *)v92;
      if (v93 >= v94)
      {
        v68 = v93 + 1;
        if (v92 <= &v87 && (char *)v92 + 24 * v93 > (char *)&v87)
        {
          v78 = (char *)&v87 - (_BYTE *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v68, 24);
          v19 = (char *)v92;
          v18 = (int *)((char *)v92 + v78);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v68, 24);
          v18 = &v87;
          v19 = (char *)v92;
        }
      }
      v20 = &v19[24 * v93];
      v21 = *(_OWORD *)v18;
      *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
      *(_OWORD *)v20 = v21;
      v22 = ++v93;
      if (Value)
      {
        v87 = 3;
        v88 = " arguments to match function signature";
        v89 = 38;
        v23 = &v87;
        v24 = (char *)v92;
        if (v22 >= v94)
        {
          v69 = v22 + 1;
          v70 = (char *)v92 + 24 * v22 > (char *)&v87;
          if (v92 <= &v87 && v70)
          {
            v79 = (char *)&v87 - (_BYTE *)v92;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v69, 24);
            v24 = (char *)v92;
            v23 = (int *)((char *)v92 + v79);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v69, 24);
            v23 = &v87;
            v24 = (char *)v92;
          }
        }
        v25 = &v24[24 * v93];
        v26 = *(_OWORD *)v23;
        *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
        *(_OWORD *)v25 = v26;
        ++v93;
      }
    }
    v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    if (!v100)
      return v17;
    v27 = (_QWORD **)__p;
    if (__p)
    {
      v28 = v99;
      v29 = __p;
      if (v99 != __p)
      {
        do
          v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
        while (v28 != v27);
        v29 = __p;
      }
      v99 = v27;
      operator delete(v29);
    }
    v30 = v96;
    if (v96)
    {
      v31 = v97;
      v32 = v96;
      if (v97 != v96)
      {
        do
        {
          v34 = (void *)*--v31;
          v33 = v34;
          *v31 = 0;
          if (v34)
            operator delete[](v33);
        }
        while (v31 != v30);
        v32 = v96;
      }
      v97 = v30;
      operator delete(v32);
    }
    v66 = v92;
    if (v92 == v95)
      return v17;
LABEL_66:
    free(v66);
    return v17;
  }
  if (!v8)
    return 1;
  v14 = Inputs;
  v15 = 0;
  while (1)
  {
    v16 = *(_QWORD *)(*(_QWORD *)(v12 + 8 * (_QWORD)v15) + 8) & 0xFFFFFFFFFFFFFFF8;
    if (*(_QWORD *)(Inputs + 8 * (_QWORD)v15) != v16)
      break;
    if ((const char *)v8 == ++v15)
      return 1;
  }
  v85[0] = (const void **)"type of entry block argument #";
  v86 = 259;
  mlir::OpState::emitOpError(a1, v85, (uint64_t)&Value);
  if (Value)
  {
    v87 = 5;
    v88 = v15;
    v35 = &v87;
    v36 = (char *)v92;
    if (v93 >= v94)
    {
      v71 = v93 + 1;
      if (v92 <= &v87 && (char *)v92 + 24 * v93 > (char *)&v87)
      {
        v80 = (char *)&v87 - (_BYTE *)v92;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v71, 24);
        v36 = (char *)v92;
        v35 = (int *)((char *)v92 + v80);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v71, 24);
        v35 = &v87;
        v36 = (char *)v92;
      }
    }
    v37 = &v36[24 * v93];
    v38 = *(_OWORD *)v35;
    *((_QWORD *)v37 + 2) = *((_QWORD *)v35 + 2);
    *(_OWORD *)v37 = v38;
    ++v93;
    if (Value)
    {
      mlir::Diagnostic::operator<<((uint64_t)v91, 40);
      if (Value)
      {
        v39 = &v87;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v87, v16);
        v40 = (char *)v92;
        if (v93 >= v94)
        {
          v72 = v93 + 1;
          if (v92 <= &v87 && (char *)v92 + 24 * v93 > (char *)&v87)
          {
            v81 = (char *)&v87 - (_BYTE *)v92;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v72, 24);
            v40 = (char *)v92;
            v39 = (int *)((char *)v92 + v81);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v72, 24);
            v39 = &v87;
            v40 = (char *)v92;
          }
        }
        v41 = &v40[24 * v93];
        v42 = *(_OWORD *)v39;
        *((_QWORD *)v41 + 2) = *((_QWORD *)v39 + 2);
        *(_OWORD *)v41 = v42;
        v43 = ++v93;
        if (Value)
        {
          v87 = 3;
          v88 = ") must match the type of the corresponding argument in ";
          v89 = 55;
          v44 = &v87;
          v45 = (char *)v92;
          if (v43 >= v94)
          {
            v73 = v43 + 1;
            v74 = (char *)v92 + 24 * v43 > (char *)&v87;
            if (v92 <= &v87 && v74)
            {
              v82 = (char *)&v87 - (_BYTE *)v92;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v73, 24);
              v45 = (char *)v92;
              v44 = (int *)((char *)v92 + v82);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v73, 24);
              v44 = &v87;
              v45 = (char *)v92;
            }
          }
          v46 = &v45[24 * v93];
          v47 = *(_OWORD *)v44;
          *((_QWORD *)v46 + 2) = *((_QWORD *)v44 + 2);
          *(_OWORD *)v46 = v47;
          v48 = ++v93;
          if (Value)
          {
            v87 = 3;
            v88 = "function signature(";
            v89 = 19;
            v49 = &v87;
            v50 = (char *)v92;
            if (v48 >= v94)
            {
              v75 = v48 + 1;
              v76 = (char *)v92 + 24 * v48 > (char *)&v87;
              if (v92 <= &v87 && v76)
              {
                v83 = (char *)&v87 - (_BYTE *)v92;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v75, 24);
                v50 = (char *)v92;
                v49 = (int *)((char *)v92 + v83);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v75, 24);
                v49 = &v87;
                v50 = (char *)v92;
              }
            }
            v51 = &v50[24 * v93];
            v52 = *(_OWORD *)v49;
            *((_QWORD *)v51 + 2) = *((_QWORD *)v49 + 2);
            *(_OWORD *)v51 = v52;
            ++v93;
            if (Value)
            {
              v53 = *(_QWORD *)(v14 + 8 * (_QWORD)v15);
              v54 = &v87;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v87, v53);
              v55 = (char *)v92;
              if (v93 >= v94)
              {
                v77 = v93 + 1;
                if (v92 <= &v87 && (char *)v92 + 24 * v93 > (char *)&v87)
                {
                  v84 = (char *)&v87 - (_BYTE *)v92;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v77, 24);
                  v55 = (char *)v92;
                  v54 = (int *)((char *)v92 + v84);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v77, 24);
                  v54 = &v87;
                  v55 = (char *)v92;
                }
              }
              v56 = &v55[24 * v93];
              v57 = *(_OWORD *)v54;
              *((_QWORD *)v56 + 2) = *((_QWORD *)v54 + 2);
              *(_OWORD *)v56 = v57;
              ++v93;
              if (Value)
                mlir::Diagnostic::operator<<((uint64_t)v91, 41);
            }
          }
        }
      }
    }
  }
  v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  if (v100)
  {
    v58 = (_QWORD **)__p;
    if (__p)
    {
      v59 = v99;
      v60 = __p;
      if (v99 != __p)
      {
        do
          v59 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v59 - 1);
        while (v59 != v58);
        v60 = __p;
      }
      v99 = v58;
      operator delete(v60);
    }
    v61 = v96;
    if (v96)
    {
      v62 = v97;
      v63 = v96;
      if (v97 != v96)
      {
        do
        {
          v65 = (void *)*--v62;
          v64 = v65;
          *v62 = 0;
          if (v65)
            operator delete[](v64);
        }
        while (v62 != v61);
        v63 = v96;
      }
      v97 = v61;
      operator delete(v63);
    }
    v66 = v92;
    if (v92 != v95)
      goto LABEL_66;
  }
  return v17;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x20uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getDefaultDialect;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[139], v2);
}

const char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getDefaultDialect()
{
  return "func";
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  uint64_t *v8;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  void **p_vtable;
  void *v18;
  unsigned __int8 v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  uint64_t v33;
  unsigned __int8 v34;
  uint64_t *v35;
  uint64_t v36;
  unsigned __int8 v37;
  uint64_t *v38;
  int v52;
  int v53;
  unint64_t v54;
  unint64_t v55;
  const char *v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  unint64_t v63;
  unint64_t v64;
  const char *v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  int v70;
  int v71;
  unint64_t v72;
  unint64_t v73;
  const char *v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  unint64_t v81;
  unint64_t v82;
  const char *v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  int v88;
  int v89;
  unint64_t v90;
  unint64_t v91;
  const char *v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  unint64_t v99;
  unint64_t v100;
  const char *v101;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  int v106;
  int v107;
  unint64_t v108;
  unint64_t v109;
  const char *v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  int v115;
  int v116;
  unint64_t v117;
  unint64_t v118;
  const char *v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  int v124;
  int v125;
  unint64_t v126;
  unint64_t v127;
  const char *v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t v132;
  int v133;
  int v134;
  unint64_t v135;
  unint64_t v136;
  const char *v137;
  unint64_t v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  int v142;
  int v143;
  unint64_t v144;
  unint64_t v145;
  const char *v146;
  unint64_t v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  int v151;
  int v152;
  unint64_t v153;
  unint64_t v154;
  const char *v155;
  unint64_t v156;
  uint64_t v157;
  unint64_t v158;
  uint64_t v159;
  int v160;
  int v161;
  unint64_t v162;
  unint64_t v163;
  const char *v164;
  unint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  void *v190;
  void *v191;
  void *v192;
  void *v193;
  void *v194;
  void *v195;
  void *v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  void *v247;
  void *v248;
  void *v249;
  void *v250;
  void *v251;
  void *v252;
  void *v253;
  void *v254;
  void *v255;
  void *v256;
  void *v257;
  void *v258;
  void *v259;
  const char *v260;
  unint64_t v261;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v247 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v53 = v52;
    a1 = v247;
    if (v53)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneRegion<Empty>]";
      v261 = 81;
      v54 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v54)
        v55 = v54;
      else
        v55 = v261;
      v56 = &v260[v55];
      v57 = v261 - v55;
      if (v261 - v55 >= 0x12)
        v58 = 18;
      else
        v58 = v261 - v55;
      v59 = v57 - v58;
      if (v59 >= v59 - 1)
        v60 = v59 - 1;
      else
        v60 = v59;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v56[v58], v60);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v247;
    }
  }
  v3 = v2[210];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v235 = v3;
    v248 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v62 = v61;
    v3 = v235;
    a1 = v248;
    if (v62)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      v261 = 83;
      v63 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v63)
        v64 = v63;
      else
        v64 = v261;
      v65 = &v260[v64];
      v66 = v261 - v64;
      if (v261 - v64 >= 0x12)
        v67 = 18;
      else
        v67 = v261 - v64;
      v68 = v66 - v67;
      if (v68 >= v68 - 1)
        v69 = v68 - 1;
      else
        v69 = v68;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v65[v67], v69);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v235;
      a1 = v248;
    }
  }
  v6 = v5[188];
  v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v7 & 1) == 0)
  {
    v236 = v3;
    v249 = a1;
    v224 = v6;
    v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v6 = v224;
    v3 = v236;
    v71 = v70;
    a1 = v249;
    if (v71)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v261 = 86;
      v72 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v72)
        v73 = v72;
      else
        v73 = v261;
      v74 = &v260[v73];
      v75 = v261 - v73;
      if (v261 - v73 >= 0x12)
        v76 = 18;
      else
        v76 = v261 - v73;
      v77 = v75 - v76;
      if (v77 >= v77 - 1)
        v78 = v77 - 1;
      else
        v78 = v77;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v74[v76], v78);
      v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v6 = v224;
      v3 = v236;
      a1 = v249;
    }
  }
  v9 = v8[196];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v237 = v3;
    v250 = a1;
    v214 = v9;
    v225 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v214;
    v6 = v225;
    v80 = v79;
    v3 = v237;
    a1 = v250;
    if (v80)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroOperands<Empty>]";
      v261 = 84;
      v81 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v81)
        v82 = v81;
      else
        v82 = v261;
      v83 = &v260[v82];
      v84 = v261 - v82;
      if (v261 - v82 >= 0x12)
        v85 = 18;
      else
        v85 = v261 - v82;
      v86 = v84 - v85;
      if (v86 >= v86 - 1)
        v87 = v86 - 1;
      else
        v87 = v86;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v83[v85], v87);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v214;
      v6 = v225;
      v3 = v237;
      a1 = v250;
    }
  }
  v12 = v11[193];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v238 = v3;
    v251 = a1;
    v215 = v9;
    v226 = v6;
    v205 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v205;
    v9 = v215;
    v6 = v226;
    v89 = v88;
    v3 = v238;
    a1 = v251;
    if (v89)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v261 = 84;
      v90 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v90)
        v91 = v90;
      else
        v91 = v261;
      v92 = &v260[v91];
      v93 = v261 - v91;
      if (v261 - v91 >= 0x12)
        v94 = 18;
      else
        v94 = v261 - v91;
      v95 = v93 - v94;
      if (v95 >= v95 - 1)
        v96 = v95 - 1;
      else
        v96 = v95;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v92[v94], v96);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v205;
      v9 = v215;
      v6 = v226;
      v3 = v238;
      a1 = v251;
    }
  }
  v15 = v14[192];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v16 & 1) == 0)
  {
    v239 = v3;
    v252 = a1;
    v216 = v9;
    v227 = v6;
    v197 = v15;
    v206 = v12;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v15 = v197;
    v12 = v206;
    v9 = v216;
    v6 = v227;
    v98 = v97;
    v3 = v239;
    a1 = v252;
    if (v98)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v261 = 89;
      v99 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v99)
        v100 = v99;
      else
        v100 = v261;
      v101 = &v260[v100];
      v102 = v261 - v100;
      if (v261 - v100 >= 0x12)
        v103 = 18;
      else
        v103 = v261 - v100;
      v104 = v102 - v103;
      if (v104 >= v104 - 1)
        v105 = v104 - 1;
      else
        v105 = v104;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v101[v103], v105);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v15 = v197;
      v12 = v206;
      v9 = v216;
      v6 = v227;
      v3 = v239;
      a1 = v252;
    }
  }
  v18 = p_vtable[481];
  v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v19 & 1) == 0)
  {
    v240 = v3;
    v253 = a1;
    v217 = v9;
    v228 = v6;
    v198 = v15;
    v207 = v12;
    v190 = v18;
    v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v18 = v190;
    v15 = v198;
    v12 = v207;
    v9 = v217;
    v6 = v228;
    v107 = v106;
    v3 = v240;
    a1 = v253;
    if (v107)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AffineScope<Empty>]";
      v261 = 83;
      v108 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v108)
        v109 = v108;
      else
        v109 = v261;
      v110 = &v260[v109];
      v111 = v261 - v109;
      if (v261 - v109 >= 0x12)
        v112 = 18;
      else
        v112 = v261 - v109;
      v113 = v111 - v112;
      if (v113 >= v113 - 1)
        v114 = v113 - 1;
      else
        v114 = v113;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v110[v112], v114);
      v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v18 = v190;
      v15 = v198;
      v12 = v207;
      v9 = v217;
      v6 = v228;
      v3 = v240;
      a1 = v253;
    }
  }
  v21 = v20[183];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v241 = v3;
    v254 = a1;
    v218 = v9;
    v229 = v6;
    v199 = v15;
    v208 = v12;
    v184 = v21;
    v191 = v18;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v184;
    v18 = v191;
    v15 = v199;
    v12 = v208;
    v9 = v218;
    v6 = v229;
    v116 = v115;
    v3 = v241;
    a1 = v254;
    if (v116)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AutomaticAllocationScope<Empty>]";
      v261 = 96;
      v117 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v117)
        v118 = v117;
      else
        v118 = v261;
      v119 = &v260[v118];
      v120 = v261 - v118;
      if (v261 - v118 >= 0x12)
        v121 = 18;
      else
        v121 = v261 - v118;
      v122 = v120 - v121;
      if (v122 >= v122 - 1)
        v123 = v122 - 1;
      else
        v123 = v122;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AutomaticAllocationScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AutomaticAllocationScope>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v119[v121], v123);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v184;
      v18 = v191;
      v15 = v199;
      v12 = v208;
      v9 = v218;
      v6 = v229;
      v3 = v241;
      a1 = v254;
    }
  }
  v24 = v23[203];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v242 = v3;
    v255 = a1;
    v219 = v9;
    v230 = v6;
    v200 = v15;
    v209 = v12;
    v185 = v21;
    v192 = v18;
    v179 = v24;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v179;
    v21 = v185;
    v18 = v192;
    v15 = v200;
    v12 = v209;
    v9 = v219;
    v6 = v230;
    v125 = v124;
    v3 = v242;
    a1 = v255;
    if (v125)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SymbolOpInterface::Trait<Empty>]";
      v261 = 87;
      v126 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v126)
        v127 = v126;
      else
        v127 = v261;
      v128 = &v260[v127];
      v129 = v261 - v127;
      if (v261 - v127 >= 0x12)
        v130 = 18;
      else
        v130 = v261 - v127;
      v131 = v129 - v130;
      if (v131 >= v131 - 1)
        v132 = v131 - 1;
      else
        v132 = v131;
      mlir::detail::TypeIDResolver<mlir::SymbolOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SymbolOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v128[v130], v132);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v179;
      v21 = v185;
      v18 = v192;
      v15 = v200;
      v12 = v209;
      v9 = v219;
      v6 = v230;
      v3 = v242;
      a1 = v255;
    }
  }
  v27 = v26[142];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v243 = v3;
    v256 = a1;
    v220 = v9;
    v231 = v6;
    v201 = v15;
    v210 = v12;
    v186 = v21;
    v193 = v18;
    v175 = v27;
    v180 = v24;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v175;
    v24 = v180;
    v21 = v186;
    v18 = v193;
    v15 = v201;
    v12 = v210;
    v9 = v220;
    v6 = v231;
    v134 = v133;
    v3 = v243;
    a1 = v256;
    if (v134)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallableOpInterface::Trait<Empty>]";
      v261 = 89;
      v135 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v135)
        v136 = v135;
      else
        v136 = v261;
      v137 = &v260[v136];
      v138 = v261 - v136;
      if (v261 - v136 >= 0x12)
        v139 = 18;
      else
        v139 = v261 - v136;
      v140 = v138 - v139;
      if (v140 >= v140 - 1)
        v141 = v140 - 1;
      else
        v141 = v140;
      mlir::detail::TypeIDResolver<mlir::CallableOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallableOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v137[v139], v141);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v175;
      v24 = v180;
      v21 = v186;
      v18 = v193;
      v15 = v201;
      v12 = v210;
      v9 = v220;
      v6 = v231;
      v3 = v243;
      a1 = v256;
    }
  }
  v30 = v29[144];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v244 = v3;
    v257 = a1;
    v221 = v9;
    v232 = v6;
    v202 = v15;
    v211 = v12;
    v187 = v21;
    v194 = v18;
    v176 = v27;
    v181 = v24;
    v172 = v30;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v172;
    v27 = v176;
    v24 = v181;
    v21 = v187;
    v18 = v194;
    v15 = v202;
    v12 = v211;
    v9 = v221;
    v6 = v232;
    v143 = v142;
    v3 = v244;
    a1 = v257;
    if (v143)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::FunctionOpInterface::Trait<Empty>]";
      v261 = 89;
      v144 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v144)
        v145 = v144;
      else
        v145 = v261;
      v146 = &v260[v145];
      v147 = v261 - v145;
      if (v261 - v145 >= 0x12)
        v148 = 18;
      else
        v148 = v261 - v145;
      v149 = v147 - v148;
      if (v149 >= v149 - 1)
        v150 = v149 - 1;
      else
        v150 = v149;
      mlir::detail::TypeIDResolver<mlir::FunctionOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::FunctionOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v146[v148], v150);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v172;
      v27 = v176;
      v24 = v181;
      v21 = v187;
      v18 = v194;
      v15 = v202;
      v12 = v211;
      v9 = v221;
      v6 = v232;
      v3 = v244;
      a1 = v257;
    }
  }
  v33 = v32[146];
  v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v34 & 1) == 0)
  {
    v245 = v3;
    v258 = a1;
    v222 = v9;
    v233 = v6;
    v203 = v15;
    v212 = v12;
    v188 = v21;
    v195 = v18;
    v177 = v27;
    v182 = v24;
    v170 = v33;
    v173 = v30;
    v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v33 = v170;
    v30 = v173;
    v27 = v177;
    v24 = v182;
    v21 = v188;
    v18 = v195;
    v15 = v203;
    v12 = v212;
    v9 = v222;
    v6 = v233;
    v152 = v151;
    v3 = v245;
    a1 = v258;
    if (v152)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsIsolatedFromAbove<Empty>]";
      v261 = 91;
      v153 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v153)
        v154 = v153;
      else
        v154 = v261;
      v155 = &v260[v154];
      v156 = v261 - v154;
      if (v261 - v154 >= 0x12)
        v157 = 18;
      else
        v157 = v261 - v154;
      v158 = v156 - v157;
      if (v158 >= v158 - 1)
        v159 = v158 - 1;
      else
        v159 = v158;
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v155[v157], v159);
      v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v33 = v170;
      v30 = v173;
      v27 = v177;
      v24 = v182;
      v21 = v188;
      v18 = v195;
      v15 = v203;
      v12 = v212;
      v9 = v222;
      v6 = v233;
      v3 = v245;
      a1 = v258;
    }
  }
  v36 = v35[201];
  v38 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v37 & 1) == 0)
  {
    v246 = v3;
    v259 = a1;
    v223 = v9;
    v234 = v6;
    v204 = v15;
    v213 = v12;
    v189 = v21;
    v196 = v18;
    v178 = v27;
    v183 = v24;
    v171 = v33;
    v174 = v30;
    v169 = v36;
    v38 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v36 = v169;
    v33 = v171;
    v30 = v174;
    v27 = v178;
    v24 = v183;
    v21 = v189;
    v18 = v196;
    v15 = v204;
    v12 = v213;
    v9 = v223;
    v6 = v234;
    v161 = v160;
    v3 = v246;
    a1 = v259;
    if (v161)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v261 = 86;
      v162 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v162)
        v163 = v162;
      else
        v163 = v261;
      v164 = &v260[v163];
      v165 = v261 - v163;
      if (v261 - v163 >= 0x12)
        v166 = 18;
      else
        v166 = v261 - v163;
      v167 = v165 - v166;
      if (v167 >= v167 - 1)
        v168 = v167 - 1;
      else
        v168 = v167;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v164[v166], v168);
      v38 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v36 = v169;
      v33 = v171;
      v30 = v174;
      v27 = v178;
      v24 = v183;
      v21 = v189;
      v18 = v196;
      v15 = v204;
      v12 = v213;
      v9 = v223;
      v6 = v234;
      v3 = v246;
      a1 = v259;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == (_QWORD)a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == a1
      || v21 == (_QWORD)a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v30 == (_QWORD)a1
      || v33 == (_QWORD)a1
      || v36 == (_QWORD)a1
      || v38[138] == (_QWORD)a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t InterfaceFor;
  uint64_t AttrData;
  uint64_t v9;
  uint64_t v10;

  mlir::OpState::printOpName(a2, a3, a4, a5);
  InterfaceFor = mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
  v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 96) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  mlir::function_interface_impl::printFunctionOp(a3, a2, InterfaceFor, 0, AttrData, v9, **(_QWORD **)(*(_QWORD *)(a2 + 48) + 96), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 96) + 16));
}

BOOL mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::OneRegion<mlir::func::FuncOp>,mlir::OpTrait::ZeroResults<mlir::func::FuncOp>,mlir::OpTrait::ZeroSuccessors<mlir::func::FuncOp>,mlir::OpTrait::ZeroOperands<mlir::func::FuncOp>,mlir::OpTrait::OpInvariants<mlir::func::FuncOp>,mlir::BytecodeOpInterface::Trait<mlir::func::FuncOp>,mlir::OpTrait::AffineScope<mlir::func::FuncOp>,mlir::OpTrait::AutomaticAllocationScope<mlir::func::FuncOp>,mlir::SymbolOpInterface::Trait<mlir::func::FuncOp>,mlir::CallableOpInterface::Trait<mlir::func::FuncOp>,mlir::FunctionOpInterface::Trait<mlir::func::FuncOp>,mlir::OpTrait::IsIsolatedFromAbove<mlir::func::FuncOp>,mlir::OpAsmOpInterface::Trait<mlir::func::FuncOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::OneRegion<mlir::func::FuncOp>,mlir::OpTrait::ZeroResults<mlir::func::FuncOp>,mlir::OpTrait::ZeroSuccessors<mlir::func::FuncOp>,mlir::OpTrait::ZeroOperands<mlir::func::FuncOp>,mlir::OpTrait::OpInvariants<mlir::func::FuncOp>,mlir::BytecodeOpInterface::Trait<mlir::func::FuncOp>,mlir::OpTrait::AffineScope<mlir::func::FuncOp>,mlir::OpTrait::AutomaticAllocationScope<mlir::func::FuncOp>,mlir::SymbolOpInterface::Trait<mlir::func::FuncOp>,mlir::CallableOpInterface::Trait<mlir::func::FuncOp>,mlir::FunctionOpInterface::Trait<mlir::func::FuncOp>,mlir::OpTrait::IsIsolatedFromAbove<mlir::func::FuncOp>,mlir::OpAsmOpInterface::Trait<mlir::func::FuncOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (mlir::OpTrait::impl::verifyOneRegion(a1, a2)
    && mlir::OpTrait::impl::verifyZeroResults(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyZeroOperands(a1, v5)
    && (v8 = a1, mlir::func::FuncOp::verifyInvariantsImpl((uint64_t **)&v8))
    && mlir::detail::SymbolOpInterfaceTrait<mlir::func::FuncOp>::verifyTrait((uint64_t)a1, v6))
  {
    return mlir::function_interface_impl::verifyTrait<mlir::func::FuncOp>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::detail::SymbolOpInterfaceTrait<mlir::func::FuncOp>::verifyTrait(uint64_t a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD **v8;
  _QWORD **v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  void *v14;
  void *v15;
  const void **v16;
  __int16 v17;
  uint64_t *v18;
  _QWORD v19[3];
  void *v20;
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  void *__p;
  _QWORD **v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v18 = (uint64_t *)a1;
  if (!mlir::detail::verifySymbol((mlir::detail *)a1, a2))
    return 0;
  v4 = *(unsigned int *)(a1 + 44);
  if ((v4 & 0x7FFFFF) != 0)
  {
    v5 = (_QWORD *)(((a1 + 16 * ((v4 >> 23) & 1) + ((v4 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(a1 + 40));
    if ((_QWORD *)*v5 == v5)
      goto LABEL_7;
    return 1;
  }
  if (MEMORY[0])
    return 1;
LABEL_7:
  if (mlir::SymbolTable::getSymbolVisibility((mlir::SymbolTable *)a1, v3))
    return 1;
  v16 = (const void **)"symbol declaration cannot have public visibility";
  v17 = 259;
  mlir::OpState::emitOpError(&v18, &v16, (uint64_t)v19);
  v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
  if (v19[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
  if (v26)
  {
    v8 = (_QWORD **)__p;
    if (__p)
    {
      v9 = v25;
      v10 = __p;
      if (v25 != __p)
      {
        do
          v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
        while (v9 != v8);
        v10 = __p;
      }
      v25 = v8;
      operator delete(v10);
    }
    v11 = v22;
    if (v22)
    {
      v12 = v23;
      v13 = v22;
      if (v23 != v22)
      {
        do
        {
          v15 = (void *)*--v12;
          v14 = v15;
          *v12 = 0;
          if (v15)
            operator delete[](v14);
        }
        while (v12 != v11);
        v13 = v22;
      }
      v23 = v11;
      operator delete(v13);
    }
    if (v20 != &v21)
      free(v20);
  }
  return v6;
}

uint64_t mlir::function_interface_impl::verifyTrait<mlir::func::FuncOp>(uint64_t a1)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  __int128 *v12;
  uint64_t v13;
  __int128 *v14;
  _BYTE *AttrData;
  size_t v16;
  _BYTE *v17;
  char *v18;
  uint64_t NameDialect;
  uint64_t *v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  __int128 *v27;
  uint64_t v28;
  __int128 *v29;
  _BYTE *v30;
  size_t v31;
  _BYTE *v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  char *v37;
  char *v38;
  __int128 v39;
  uint64_t v40;
  char *v41;
  char *v42;
  char *v43;
  __int128 v44;
  uint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  __int128 v49;
  uint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  __int128 v54;
  _QWORD **v55;
  _QWORD **v56;
  void *v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60;
  void *v61;
  void *v62;
  char *v63;
  char *v64;
  char *v65;
  __int128 v66;
  uint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  __int128 v71;
  uint64_t v72;
  char *v73;
  char *v74;
  char *v75;
  __int128 v76;
  uint64_t v77;
  char *v78;
  char *v79;
  char *v80;
  __int128 v81;
  _QWORD **v82;
  _QWORD **v83;
  void *v84;
  _QWORD *v85;
  void *v86;
  void *v87;
  _QWORD **v88;
  _QWORD **v89;
  void *v90;
  _QWORD *v91;
  void *v92;
  void *v93;
  _QWORD **v94;
  _QWORD **v95;
  void *v96;
  _QWORD *v97;
  void *v98;
  void *v99;
  _QWORD **v100;
  _QWORD **v101;
  void *v102;
  _QWORD *v103;
  void *v104;
  void *v105;
  char *v106;
  char *v107;
  char *v108;
  __int128 v109;
  uint64_t Value;
  char *v111;
  char *v112;
  char *v113;
  __int128 v114;
  uint64_t v115;
  char *v116;
  char *v117;
  char *v118;
  __int128 v119;
  _QWORD **v120;
  _QWORD **v121;
  void *v122;
  _QWORD *v123;
  void *v124;
  void *v125;
  char *v126;
  char *v127;
  char *v128;
  __int128 v129;
  uint64_t v130;
  char *v131;
  char *v132;
  char *v133;
  __int128 v134;
  uint64_t v135;
  char *v136;
  char *v137;
  char *v138;
  __int128 v139;
  _QWORD **v140;
  _QWORD **v141;
  void *v142;
  _QWORD *v143;
  void *v144;
  void *v145;
  unint64_t v147;
  unint64_t v148;
  unint64_t v149;
  BOOL v150;
  unint64_t v151;
  unint64_t v152;
  unint64_t v153;
  BOOL v154;
  unint64_t v155;
  BOOL v156;
  unint64_t v157;
  BOOL v158;
  unint64_t v159;
  unint64_t v160;
  unint64_t v161;
  BOOL v162;
  unint64_t v163;
  unint64_t v164;
  unint64_t v165;
  BOOL v166;
  int64_t v167;
  int64_t v168;
  int64_t v169;
  int64_t v170;
  int64_t v171;
  int64_t v172;
  int64_t v173;
  int64_t v174;
  int64_t v175;
  int64_t v176;
  int64_t v177;
  int64_t v178;
  int64_t v179;
  int64_t v180;
  uint64_t v181;
  const void **v182[4];
  __int16 v183;
  uint64_t v184;
  uint64_t *v185;
  __int128 v186;
  uint64_t v187;
  _QWORD v188[3];
  void *v189;
  unsigned int v190;
  unsigned int v191;
  _BYTE v192[96];
  void *v193;
  _QWORD *v194;
  void *__p;
  _QWORD **v196;
  char v197;
  uint64_t v198;

  v198 = *MEMORY[0x1E0C80C00];
  v185 = (uint64_t *)a1;
  v1 = *(unsigned int *)(a1 + 44);
  v2 = a1 + 16 * ((v1 >> 23) & 1);
  v4 = *(_QWORD *)(v2 + 64);
  v3 = v2 + 64;
  v184 = v4;
  if (v4)
  {
    if (BYTE3(v1))
      v5 = v3;
    else
      v5 = 0;
    v188[0] = *(_QWORD *)(v5 + 8);
    v188[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v188);
    mlir::FunctionType::getInputs((mlir::FunctionType *)v188);
    v7 = v6;
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
    v8 = v7;
    if (v9 != v7)
    {
      v183 = 257;
      mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
      if (v188[0])
      {
        LODWORD(v186) = 3;
        *((_QWORD *)&v186 + 1) = "expects argument attribute array to have the same number of elements as the number of f"
                                 "unction arguments, got ";
        v187 = 110;
        v36 = (char *)&v186;
        v37 = (char *)v189;
        if (v190 >= v191)
        {
          v147 = v190 + 1;
          if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
          {
            v167 = (char *)&v186 - (_BYTE *)v189;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v147, 24);
            v37 = (char *)v189;
            v36 = (char *)v189 + v167;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v147, 24);
            v36 = (char *)&v186;
            v37 = (char *)v189;
          }
        }
        v38 = &v37[24 * v190];
        v39 = *(_OWORD *)v36;
        *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
        *(_OWORD *)v38 = v39;
        ++v190;
      }
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
      if (v188[0])
      {
        LODWORD(v186) = 5;
        *((_QWORD *)&v186 + 1) = v40;
        v41 = (char *)&v186;
        v42 = (char *)v189;
        if (v190 >= v191)
        {
          v148 = v190 + 1;
          if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
          {
            v168 = (char *)&v186 - (_BYTE *)v189;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v148, 24);
            v42 = (char *)v189;
            v41 = (char *)v189 + v168;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v148, 24);
            v41 = (char *)&v186;
            v42 = (char *)v189;
          }
        }
        v43 = &v42[24 * v190];
        v44 = *(_OWORD *)v41;
        *((_QWORD *)v43 + 2) = *((_QWORD *)v41 + 2);
        *(_OWORD *)v43 = v44;
        v45 = ++v190;
        if (v188[0])
        {
          LODWORD(v186) = 3;
          *((_QWORD *)&v186 + 1) = ", but expected ";
          v187 = 15;
          v46 = (char *)&v186;
          v47 = (char *)v189;
          if (v45 >= v191)
          {
            v149 = v45 + 1;
            v150 = (char *)v189 + 24 * v45 > (char *)&v186;
            if (v189 <= &v186 && v150)
            {
              v169 = (char *)&v186 - (_BYTE *)v189;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v149, 24);
              v47 = (char *)v189;
              v46 = (char *)v189 + v169;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v149, 24);
              v46 = (char *)&v186;
              v47 = (char *)v189;
            }
          }
          v48 = &v47[24 * v190];
          v49 = *(_OWORD *)v46;
          *((_QWORD *)v48 + 2) = *((_QWORD *)v46 + 2);
          *(_OWORD *)v48 = v49;
          v50 = ++v190;
          if (v188[0])
          {
            LODWORD(v186) = 5;
            *((_QWORD *)&v186 + 1) = v8;
            v51 = (char *)&v186;
            v52 = (char *)v189;
            if (v50 >= v191)
            {
              v153 = v50 + 1;
              v154 = (char *)v189 + 24 * v50 > (char *)&v186;
              if (v189 <= &v186 && v154)
              {
                v172 = (char *)&v186 - (_BYTE *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v153, 24);
                v52 = (char *)v189;
                v51 = (char *)v189 + v172;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v153, 24);
                v51 = (char *)&v186;
                v52 = (char *)v189;
              }
            }
            v53 = &v52[24 * v190];
            v54 = *(_OWORD *)v51;
            *((_QWORD *)v53 + 2) = *((_QWORD *)v51 + 2);
            *(_OWORD *)v53 = v54;
            ++v190;
          }
        }
      }
      v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
      if (v188[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
      if (v197)
      {
        v55 = (_QWORD **)__p;
        if (__p)
        {
          v56 = v196;
          v57 = __p;
          if (v196 != __p)
          {
            do
              v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            v57 = __p;
          }
          v196 = v55;
          operator delete(v57);
        }
        v58 = v193;
        if (!v193)
          goto LABEL_183;
        v59 = v194;
        v60 = v193;
        if (v194 == v193)
          goto LABEL_182;
        do
        {
          v62 = (void *)*--v59;
          v61 = v62;
          *v59 = 0;
          if (v62)
            operator delete[](v61);
        }
        while (v59 != v58);
        goto LABEL_181;
      }
      return v35;
    }
    if (v7)
    {
      v10 = 0;
      while (1)
      {
        v11 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184) + 8 * v10);
        if (!v11)
        {
          v181 = 0;
LABEL_136:
          v183 = 257;
          mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
          if (v188[0])
          {
            LODWORD(v186) = 3;
            v187 = 71;
            v106 = (char *)&v186;
            v107 = (char *)v189;
            if (v190 >= v191)
            {
              v159 = v190 + 1;
              if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
              {
                v175 = (char *)&v186 - (_BYTE *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v159, 24);
                v107 = (char *)v189;
                v106 = (char *)v189 + v175;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v159, 24);
                v106 = (char *)&v186;
                v107 = (char *)v189;
              }
            }
            v108 = &v107[24 * v190];
            v109 = *(_OWORD *)v106;
            *((_QWORD *)v108 + 2) = *((_QWORD *)v106 + 2);
            *(_OWORD *)v108 = v109;
            ++v190;
          }
          Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
          if (v188[0])
          {
            v111 = (char *)&v186;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v186, *(_QWORD *)(Value + 8 * v10));
            v112 = (char *)v189;
            if (v190 >= v191)
            {
              v160 = v190 + 1;
              if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
              {
                v176 = (char *)&v186 - (_BYTE *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v160, 24);
                v112 = (char *)v189;
                v111 = (char *)v189 + v176;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v160, 24);
                v111 = (char *)&v186;
                v112 = (char *)v189;
              }
            }
            v113 = &v112[24 * v190];
            v114 = *(_OWORD *)v111;
            *((_QWORD *)v113 + 2) = *((_QWORD *)v111 + 2);
            *(_OWORD *)v113 = v114;
            v115 = ++v190;
            if (v188[0])
            {
              LODWORD(v186) = 3;
              v187 = 1;
              v116 = (char *)&v186;
              v117 = (char *)v189;
              if (v115 >= v191)
              {
                v161 = v115 + 1;
                v162 = (char *)v189 + 24 * v115 > (char *)&v186;
                if (v189 <= &v186 && v162)
                {
                  v177 = (char *)&v186 - (_BYTE *)v189;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v161, 24);
                  v117 = (char *)v189;
                  v116 = (char *)v189 + v177;
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v161, 24);
                  v116 = (char *)&v186;
                  v117 = (char *)v189;
                }
              }
              v118 = &v117[24 * v190];
              v119 = *(_OWORD *)v116;
              *((_QWORD *)v118 + 2) = *((_QWORD *)v116 + 2);
              *(_OWORD *)v118 = v119;
              ++v190;
            }
          }
          v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
          if (v188[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
          if (!v197)
            return v35;
          v120 = (_QWORD **)__p;
          if (__p)
          {
            v121 = v196;
            v122 = __p;
            if (v196 != __p)
            {
              do
                v121 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v121 - 1);
              while (v121 != v120);
              v122 = __p;
            }
            v196 = v120;
            operator delete(v122);
          }
          v58 = v193;
          if (!v193)
            goto LABEL_183;
          v123 = v194;
          v60 = v193;
          if (v194 == v193)
            goto LABEL_182;
          do
          {
            v125 = (void *)*--v123;
            v124 = v125;
            *v123 = 0;
            if (v125)
              operator delete[](v124);
          }
          while (v123 != v58);
          goto LABEL_181;
        }
        if (*(_UNKNOWN **)(*(_QWORD *)v11 + 136) != &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
          v11 = 0;
        v181 = v11;
        if (!v11)
          goto LABEL_136;
        v12 = (__int128 *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v181);
        v13 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v181);
        if (v12 != (__int128 *)v13)
          break;
LABEL_21:
        if (++v10 == v7)
          goto LABEL_22;
      }
      v14 = (__int128 *)v13;
      while (1)
      {
        v186 = *v12;
        v188[0] = mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)&v186);
        AttrData = (_BYTE *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v188);
        if (!v16)
          break;
        v17 = AttrData;
        v18 = (char *)memchr(AttrData, 46, v16);
        if (!v18 || v18 - v17 == -1)
          break;
        NameDialect = mlir::NamedAttribute::getNameDialect((mlir::NamedAttribute *)&v186);
        if (NameDialect
          && !(*(unsigned __int8 (**)(uint64_t, uint64_t *, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)NameDialect + 80))(NameDialect, v185, 0, v10, v186, *((_QWORD *)&v186 + 1)))
        {
          return 0;
        }
        if (++v12 == v14)
          goto LABEL_21;
      }
      v182[0] = (const void **)"arguments may only have dialect attributes";
      v183 = 259;
      mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
      v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
      if (v188[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
      if (!v197)
        return v35;
      v88 = (_QWORD **)__p;
      if (__p)
      {
        v89 = v196;
        v90 = __p;
        if (v196 != __p)
        {
          do
            v89 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v89 - 1);
          while (v89 != v88);
          v90 = __p;
        }
        v196 = v88;
        operator delete(v90);
      }
      v58 = v193;
      if (!v193)
        goto LABEL_183;
      v91 = v194;
      v60 = v193;
      if (v194 == v193)
        goto LABEL_182;
      do
      {
        v93 = (void *)*--v91;
        v92 = v93;
        *v91 = 0;
        if (v93)
          operator delete[](v92);
      }
      while (v91 != v58);
      goto LABEL_181;
    }
  }
LABEL_22:
  v20 = &v185[2 * (((unint64_t)*((unsigned int *)v185 + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)v185 + 11)))
    v20 = 0;
  v184 = v20[2];
  if (v184)
  {
    v188[0] = v20[1];
    v188[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v188);
    mlir::FunctionType::getResults((mlir::FunctionType *)v188);
    v22 = v21;
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
    v23 = v22;
    if (v24 != v22)
    {
      v183 = 257;
      mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
      if (v188[0])
      {
        LODWORD(v186) = 3;
        *((_QWORD *)&v186 + 1) = "expects result attribute array to have the same number of elements as the number of fun"
                                 "ction results, got ";
        v187 = 106;
        v63 = (char *)&v186;
        v64 = (char *)v189;
        if (v190 >= v191)
        {
          v151 = v190 + 1;
          if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
          {
            v170 = (char *)&v186 - (_BYTE *)v189;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v151, 24);
            v64 = (char *)v189;
            v63 = (char *)v189 + v170;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v151, 24);
            v63 = (char *)&v186;
            v64 = (char *)v189;
          }
        }
        v65 = &v64[24 * v190];
        v66 = *(_OWORD *)v63;
        *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
        *(_OWORD *)v65 = v66;
        ++v190;
      }
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
      if (v188[0])
      {
        LODWORD(v186) = 5;
        *((_QWORD *)&v186 + 1) = v67;
        v68 = (char *)&v186;
        v69 = (char *)v189;
        if (v190 >= v191)
        {
          v152 = v190 + 1;
          if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
          {
            v171 = (char *)&v186 - (_BYTE *)v189;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v152, 24);
            v69 = (char *)v189;
            v68 = (char *)v189 + v171;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v152, 24);
            v68 = (char *)&v186;
            v69 = (char *)v189;
          }
        }
        v70 = &v69[24 * v190];
        v71 = *(_OWORD *)v68;
        *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
        *(_OWORD *)v70 = v71;
        v72 = ++v190;
        if (v188[0])
        {
          LODWORD(v186) = 3;
          *((_QWORD *)&v186 + 1) = ", but expected ";
          v187 = 15;
          v73 = (char *)&v186;
          v74 = (char *)v189;
          if (v72 >= v191)
          {
            v155 = v72 + 1;
            v156 = (char *)v189 + 24 * v72 > (char *)&v186;
            if (v189 <= &v186 && v156)
            {
              v173 = (char *)&v186 - (_BYTE *)v189;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v155, 24);
              v74 = (char *)v189;
              v73 = (char *)v189 + v173;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v155, 24);
              v73 = (char *)&v186;
              v74 = (char *)v189;
            }
          }
          v75 = &v74[24 * v190];
          v76 = *(_OWORD *)v73;
          *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
          *(_OWORD *)v75 = v76;
          v77 = ++v190;
          if (v188[0])
          {
            LODWORD(v186) = 5;
            *((_QWORD *)&v186 + 1) = v23;
            v78 = (char *)&v186;
            v79 = (char *)v189;
            if (v77 >= v191)
            {
              v157 = v77 + 1;
              v158 = (char *)v189 + 24 * v77 > (char *)&v186;
              if (v189 <= &v186 && v158)
              {
                v174 = (char *)&v186 - (_BYTE *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v157, 24);
                v79 = (char *)v189;
                v78 = (char *)v189 + v174;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v157, 24);
                v78 = (char *)&v186;
                v79 = (char *)v189;
              }
            }
            v80 = &v79[24 * v190];
            v81 = *(_OWORD *)v78;
            *((_QWORD *)v80 + 2) = *((_QWORD *)v78 + 2);
            *(_OWORD *)v80 = v81;
            ++v190;
          }
        }
      }
      v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
      if (v188[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
      if (v197)
      {
        v82 = (_QWORD **)__p;
        if (__p)
        {
          v83 = v196;
          v84 = __p;
          if (v196 != __p)
          {
            do
              v83 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v83 - 1);
            while (v83 != v82);
            v84 = __p;
          }
          v196 = v82;
          operator delete(v84);
        }
        v58 = v193;
        if (!v193)
          goto LABEL_183;
        v85 = v194;
        v60 = v193;
        if (v194 == v193)
          goto LABEL_182;
        do
        {
          v87 = (void *)*--v85;
          v86 = v87;
          *v85 = 0;
          if (v87)
            operator delete[](v86);
        }
        while (v85 != v58);
        goto LABEL_181;
      }
      return v35;
    }
    if (v22)
    {
      v25 = 0;
      while (1)
      {
        v26 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184) + 8 * v25);
        if (!v26)
        {
          v181 = 0;
LABEL_159:
          v183 = 257;
          mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
          if (v188[0])
          {
            LODWORD(v186) = 3;
            v187 = 69;
            v126 = (char *)&v186;
            v127 = (char *)v189;
            if (v190 >= v191)
            {
              v163 = v190 + 1;
              if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
              {
                v178 = (char *)&v186 - (_BYTE *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v163, 24);
                v127 = (char *)v189;
                v126 = (char *)v189 + v178;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v163, 24);
                v126 = (char *)&v186;
                v127 = (char *)v189;
              }
            }
            v128 = &v127[24 * v190];
            v129 = *(_OWORD *)v126;
            *((_QWORD *)v128 + 2) = *((_QWORD *)v126 + 2);
            *(_OWORD *)v128 = v129;
            ++v190;
          }
          v130 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
          if (v188[0])
          {
            v131 = (char *)&v186;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v186, *(_QWORD *)(v130 + 8 * v25));
            v132 = (char *)v189;
            if (v190 >= v191)
            {
              v164 = v190 + 1;
              if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
              {
                v179 = (char *)&v186 - (_BYTE *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v164, 24);
                v132 = (char *)v189;
                v131 = (char *)v189 + v179;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v164, 24);
                v131 = (char *)&v186;
                v132 = (char *)v189;
              }
            }
            v133 = &v132[24 * v190];
            v134 = *(_OWORD *)v131;
            *((_QWORD *)v133 + 2) = *((_QWORD *)v131 + 2);
            *(_OWORD *)v133 = v134;
            v135 = ++v190;
            if (v188[0])
            {
              LODWORD(v186) = 3;
              v187 = 1;
              v136 = (char *)&v186;
              v137 = (char *)v189;
              if (v135 >= v191)
              {
                v165 = v135 + 1;
                v166 = (char *)v189 + 24 * v135 > (char *)&v186;
                if (v189 <= &v186 && v166)
                {
                  v180 = (char *)&v186 - (_BYTE *)v189;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v165, 24);
                  v137 = (char *)v189;
                  v136 = (char *)v189 + v180;
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v165, 24);
                  v136 = (char *)&v186;
                  v137 = (char *)v189;
                }
              }
              v138 = &v137[24 * v190];
              v139 = *(_OWORD *)v136;
              *((_QWORD *)v138 + 2) = *((_QWORD *)v136 + 2);
              *(_OWORD *)v138 = v139;
              ++v190;
            }
          }
          v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
          if (v188[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
          if (!v197)
            return v35;
          v140 = (_QWORD **)__p;
          if (__p)
          {
            v141 = v196;
            v142 = __p;
            if (v196 != __p)
            {
              do
                v141 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v141 - 1);
              while (v141 != v140);
              v142 = __p;
            }
            v196 = v140;
            operator delete(v142);
          }
          v58 = v193;
          if (!v193)
            goto LABEL_183;
          v143 = v194;
          v60 = v193;
          if (v194 == v193)
            goto LABEL_182;
          do
          {
            v145 = (void *)*--v143;
            v144 = v145;
            *v143 = 0;
            if (v145)
              operator delete[](v144);
          }
          while (v143 != v58);
          goto LABEL_181;
        }
        if (*(_UNKNOWN **)(*(_QWORD *)v26 + 136) != &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
          v26 = 0;
        v181 = v26;
        if (!v26)
          goto LABEL_159;
        v27 = (__int128 *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v181);
        v28 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v181);
        if (v27 != (__int128 *)v28)
          break;
LABEL_41:
        if (++v25 == v22)
          goto LABEL_42;
      }
      v29 = (__int128 *)v28;
      while (1)
      {
        v186 = *v27;
        v188[0] = mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)&v186);
        v30 = (_BYTE *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v188);
        if (!v31)
          break;
        v32 = v30;
        v33 = (char *)memchr(v30, 46, v31);
        if (!v33 || v33 - v32 == -1)
          break;
        v34 = mlir::NamedAttribute::getNameDialect((mlir::NamedAttribute *)&v186);
        if (v34
          && !(*(unsigned __int8 (**)(uint64_t, uint64_t *, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v34 + 88))(v34, v185, 0, v25, v186, *((_QWORD *)&v186 + 1)))
        {
          return 0;
        }
        if (++v27 == v29)
          goto LABEL_41;
      }
      v182[0] = (const void **)"results may only have dialect attributes";
      v183 = 259;
      mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
      v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
      if (v188[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
      if (!v197)
        return v35;
      v100 = (_QWORD **)__p;
      if (__p)
      {
        v101 = v196;
        v102 = __p;
        if (v196 != __p)
        {
          do
            v101 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v101 - 1);
          while (v101 != v100);
          v102 = __p;
        }
        v196 = v100;
        operator delete(v102);
      }
      v58 = v193;
      if (!v193)
        goto LABEL_183;
      v103 = v194;
      v60 = v193;
      if (v194 == v193)
        goto LABEL_182;
      do
      {
        v105 = (void *)*--v103;
        v104 = v105;
        *v103 = 0;
        if (v105)
          operator delete[](v104);
      }
      while (v103 != v58);
      goto LABEL_181;
    }
  }
LABEL_42:
  if ((*((_DWORD *)v185 + 11) & 0x7FFFFF) == 1)
    return mlir::detail::FunctionOpInterfaceTrait<mlir::func::FuncOp>::verifyBody(&v185);
  v182[0] = (const void **)"expects one region";
  v183 = 259;
  mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
  v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
  if (v188[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
  if (v197)
  {
    v94 = (_QWORD **)__p;
    if (__p)
    {
      v95 = v196;
      v96 = __p;
      if (v196 != __p)
      {
        do
          v95 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v95 - 1);
        while (v95 != v94);
        v96 = __p;
      }
      v196 = v94;
      operator delete(v96);
    }
    v58 = v193;
    if (!v193)
      goto LABEL_183;
    v97 = v194;
    v60 = v193;
    if (v194 == v193)
    {
LABEL_182:
      v194 = v58;
      operator delete(v60);
LABEL_183:
      if (v189 != v192)
        free(v189);
      return v35;
    }
    do
    {
      v99 = (void *)*--v97;
      v98 = v99;
      *v97 = 0;
      if (v99)
        operator delete[](v98);
    }
    while (v97 != v58);
LABEL_181:
    v60 = v193;
    goto LABEL_182;
  }
  return v35;
}

BOOL mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::OpTrait::impl::verifyIsIsolatedFromAbove(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ReturnOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"func.return", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::ReturnOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E3F490;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::func::ReturnOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                    + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ReturnOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ReturnOp>::getSpeculatability;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[487], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ReturnOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>::getMutableSuccessorOperands;
  v2[1] = mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>::getSuccessorRegions;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchTerminatorOpInterface]";
      v15 = 89;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[173], v2);
}

double mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>::getMutableSuccessorOperands@<D0>(mlir::Operation *a1@<X1>, mlir::MutableOperandRange *a2@<X8>)
{
  return mlir::MutableOperandRange::MutableOperandRange(a2, a1);
}

uint64_t mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>::getSuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Block *v6;
  uint64_t ParentOp;
  uint64_t v9;
  mlir::Block *v10;
  unint64_t Parent;
  uint64_t v13;
  uint64_t v14;

  v6 = *(mlir::Block **)(a2 + 16);
  if (v6)
  {
    ParentOp = mlir::Block::getParentOp(v6);
    v9 = ParentOp;
    if (ParentOp)
      ParentOp = mlir::OpInterface<mlir::RegionBranchOpInterface,mlir::detail::RegionBranchOpInterfaceInterfaceTraits>::getInterfaceFor(ParentOp);
    v10 = *(mlir::Block **)(a2 + 16);
    v13 = v9;
    v14 = ParentOp;
    if (v10)
      Parent = mlir::Block::getParent(v10);
    else
      Parent = 0;
  }
  else
  {
    Parent = 0;
    v13 = 0;
    v14 = 0;
  }
  return mlir::BranchOpInterface::getSuccessorForOperands(&v13, Parent, a5);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  uint64_t *v8;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **p_vtable;
  void *v21;
  unsigned __int8 v22;
  void **v23;
  void *v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  __guard *v32;
  __guard v33;
  unsigned __int8 v34;
  uint64_t *v35;
  uint64_t v36;
  unsigned __int8 v37;
  uint64_t *v38;
  int v52;
  int v53;
  unint64_t v54;
  unint64_t v55;
  const char *v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  unint64_t v63;
  unint64_t v64;
  const char *v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  int v70;
  int v71;
  unint64_t v72;
  unint64_t v73;
  const char *v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  unint64_t v81;
  unint64_t v82;
  const char *v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  int v88;
  int v89;
  unint64_t v90;
  unint64_t v91;
  const char *v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  unint64_t v99;
  unint64_t v100;
  const char *v101;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  int v106;
  int v107;
  unint64_t v108;
  unint64_t v109;
  const char *v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  int v115;
  int v116;
  unint64_t v117;
  unint64_t v118;
  const char *v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  int v124;
  int v125;
  unint64_t v126;
  unint64_t v127;
  const char *v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t v132;
  int v133;
  int v134;
  unint64_t v135;
  unint64_t v136;
  const char *v137;
  unint64_t v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  int v142;
  int v143;
  unint64_t v144;
  unint64_t v145;
  const char *v146;
  unint64_t v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  int v151;
  int v152;
  unint64_t v153;
  unint64_t v154;
  const char *v155;
  unint64_t v156;
  uint64_t v157;
  unint64_t v158;
  uint64_t v159;
  int v160;
  int v161;
  unint64_t v162;
  unint64_t v163;
  const char *v164;
  unint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  __guard v170;
  __guard v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  void *v179;
  void *v180;
  void *v181;
  void *v182;
  void *v183;
  void *v184;
  void *v185;
  void *v186;
  void *v187;
  void *v188;
  void *v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  void *v247;
  void *v248;
  void *v249;
  void *v250;
  void *v251;
  void *v252;
  void *v253;
  void *v254;
  void *v255;
  void *v256;
  void *v257;
  void *v258;
  void *v259;
  const char *v260;
  unint64_t v261;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v247 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v53 = v52;
    a1 = v247;
    if (v53)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v261 = 83;
      v54 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v54)
        v55 = v54;
      else
        v55 = v261;
      v56 = &v260[v55];
      v57 = v261 - v55;
      if (v261 - v55 >= 0x12)
        v58 = 18;
      else
        v58 = v261 - v55;
      v59 = v57 - v58;
      if (v59 >= v59 - 1)
        v60 = v59 - 1;
      else
        v60 = v59;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v56[v58], v60);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v247;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v235 = v3;
    v248 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v62 = v61;
    v3 = v235;
    a1 = v248;
    if (v62)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      v261 = 83;
      v63 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v63)
        v64 = v63;
      else
        v64 = v261;
      v65 = &v260[v64];
      v66 = v261 - v64;
      if (v261 - v64 >= 0x12)
        v67 = 18;
      else
        v67 = v261 - v64;
      v68 = v66 - v67;
      if (v68 >= v68 - 1)
        v69 = v68 - 1;
      else
        v69 = v68;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v65[v67], v69);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v235;
      a1 = v248;
    }
  }
  v6 = v5[188];
  v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v7 & 1) == 0)
  {
    v236 = v3;
    v249 = a1;
    v224 = v6;
    v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v6 = v224;
    v3 = v236;
    v71 = v70;
    a1 = v249;
    if (v71)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v261 = 86;
      v72 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v72)
        v73 = v72;
      else
        v73 = v261;
      v74 = &v260[v73];
      v75 = v261 - v73;
      if (v261 - v73 >= 0x12)
        v76 = 18;
      else
        v76 = v261 - v73;
      v77 = v75 - v76;
      if (v77 >= v77 - 1)
        v78 = v77 - 1;
      else
        v78 = v77;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v74[v76], v78);
      v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v6 = v224;
      v3 = v236;
      a1 = v249;
    }
  }
  v9 = v8[196];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v237 = v3;
    v250 = a1;
    v214 = v9;
    v225 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v214;
    v6 = v225;
    v80 = v79;
    v3 = v237;
    a1 = v250;
    if (v80)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicOperands<Empty>]";
      v261 = 88;
      v81 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v81)
        v82 = v81;
      else
        v82 = v261;
      v83 = &v260[v82];
      v84 = v261 - v82;
      if (v261 - v82 >= 0x12)
        v85 = 18;
      else
        v85 = v261 - v82;
      v86 = v84 - v85;
      if (v86 >= v86 - 1)
        v87 = v86 - 1;
      else
        v87 = v86;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v83[v85], v87);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v214;
      v6 = v225;
      v3 = v237;
      a1 = v250;
    }
  }
  v12 = v11[198];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v238 = v3;
    v251 = a1;
    v215 = v9;
    v226 = v6;
    v205 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v205;
    v9 = v215;
    v6 = v226;
    v89 = v88;
    v3 = v238;
    a1 = v251;
    if (v89)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<Empty>]";
      v261 = 107;
      v90 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v90)
        v91 = v90;
      else
        v91 = v261;
      v92 = &v260[v91];
      v93 = v261 - v91;
      if (v261 - v91 >= 0x12)
        v94 = 18;
      else
        v94 = v261 - v91;
      v95 = v93 - v94;
      if (v95 >= v95 - 1)
        v96 = v95 - 1;
      else
        v96 = v95;
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v92[v94], v96);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v205;
      v9 = v215;
      v6 = v226;
      v3 = v238;
      a1 = v251;
    }
  }
  v15 = v14[207];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v239 = v3;
    v252 = a1;
    v216 = v9;
    v227 = v6;
    v197 = v15;
    v206 = v12;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v197;
    v12 = v206;
    v9 = v216;
    v6 = v227;
    v98 = v97;
    v3 = v239;
    a1 = v252;
    if (v98)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v261 = 84;
      v99 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v99)
        v100 = v99;
      else
        v100 = v261;
      v101 = &v260[v100];
      v102 = v261 - v100;
      if (v261 - v100 >= 0x12)
        v103 = 18;
      else
        v103 = v261 - v100;
      v104 = v102 - v103;
      if (v104 >= v104 - 1)
        v105 = v104 - 1;
      else
        v105 = v104;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v101[v103], v105);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v197;
      v12 = v206;
      v9 = v216;
      v6 = v227;
      v3 = v239;
      a1 = v252;
    }
  }
  v18 = v17[192];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v240 = v3;
    v253 = a1;
    v217 = v9;
    v228 = v6;
    v198 = v15;
    v207 = v12;
    v190 = v18;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v190;
    v15 = v198;
    v12 = v207;
    v9 = v217;
    v6 = v228;
    v107 = v106;
    v3 = v240;
    a1 = v253;
    if (v107)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v261 = 95;
      v108 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v108)
        v109 = v108;
      else
        v109 = v261;
      v110 = &v260[v109];
      v111 = v261 - v109;
      if (v261 - v109 >= 0x12)
        v112 = 18;
      else
        v112 = v261 - v109;
      v113 = v111 - v112;
      if (v113 >= v113 - 1)
        v114 = v113 - 1;
      else
        v114 = v113;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v110[v112], v114);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v190;
      v15 = v198;
      v12 = v207;
      v9 = v217;
      v6 = v228;
      v3 = v240;
      a1 = v253;
    }
  }
  v21 = p_vtable[486];
  v23 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v22 & 1) == 0)
  {
    v241 = v3;
    v254 = a1;
    v218 = v9;
    v229 = v6;
    v199 = v15;
    v208 = v12;
    v184 = v21;
    v191 = v18;
    v23 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v21 = v184;
    v18 = v191;
    v15 = v199;
    v12 = v208;
    v9 = v218;
    v6 = v229;
    v116 = v115;
    v3 = v241;
    a1 = v254;
    if (v116)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v261 = 99;
      v117 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v117)
        v118 = v117;
      else
        v118 = v261;
      v119 = &v260[v118];
      v120 = v261 - v118;
      if (v261 - v118 >= 0x12)
        v121 = 18;
      else
        v121 = v261 - v118;
      v122 = v120 - v121;
      if (v122 >= v122 - 1)
        v123 = v122 - 1;
      else
        v123 = v122;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v119[v121], v123);
      v23 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v21 = v184;
      v18 = v191;
      v15 = v199;
      v12 = v208;
      v9 = v218;
      v6 = v229;
      v3 = v241;
      a1 = v254;
    }
  }
  v24 = v23[504];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v242 = v3;
    v255 = a1;
    v219 = v9;
    v230 = v6;
    v200 = v15;
    v209 = v12;
    v185 = v21;
    v192 = v18;
    v179 = v24;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v179;
    v21 = v185;
    v18 = v192;
    v15 = v200;
    v12 = v209;
    v9 = v219;
    v6 = v230;
    v125 = v124;
    v3 = v242;
    a1 = v255;
    if (v125)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v261 = 93;
      v126 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v126)
        v127 = v126;
      else
        v127 = v261;
      v128 = &v260[v127];
      v129 = v261 - v127;
      if (v261 - v127 >= 0x12)
        v130 = 18;
      else
        v130 = v261 - v127;
      v131 = v129 - v130;
      if (v131 >= v131 - 1)
        v132 = v131 - 1;
      else
        v132 = v131;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v128[v130], v132);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v179;
      v21 = v185;
      v18 = v192;
      v15 = v200;
      v12 = v209;
      v9 = v219;
      v6 = v230;
      v3 = v242;
      a1 = v255;
    }
  }
  v27 = v26[158];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v243 = v3;
    v256 = a1;
    v220 = v9;
    v231 = v6;
    v201 = v15;
    v210 = v12;
    v186 = v21;
    v193 = v18;
    v175 = v27;
    v180 = v24;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v175;
    v24 = v180;
    v21 = v186;
    v18 = v193;
    v15 = v201;
    v12 = v210;
    v9 = v220;
    v6 = v231;
    v134 = v133;
    v3 = v243;
    a1 = v256;
    if (v134)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::MemRefsNormalizable<Empty>]";
      v261 = 91;
      v135 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v135)
        v136 = v135;
      else
        v136 = v261;
      v137 = &v260[v136];
      v138 = v261 - v136;
      if (v261 - v136 >= 0x12)
        v139 = 18;
      else
        v139 = v261 - v136;
      v140 = v138 - v139;
      if (v140 >= v140 - 1)
        v141 = v140 - 1;
      else
        v141 = v140;
      mlir::detail::TypeIDResolver<mlir::OpTrait::MemRefsNormalizable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::MemRefsNormalizable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v137[v139], v141);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v175;
      v24 = v180;
      v21 = v186;
      v18 = v193;
      v15 = v201;
      v12 = v210;
      v9 = v220;
      v6 = v231;
      v3 = v243;
      a1 = v256;
    }
  }
  v30 = v29[202];
  if ((v31 & 1) == 0)
  {
    v244 = v3;
    v257 = a1;
    v221 = v9;
    v232 = v6;
    v202 = v15;
    v211 = v12;
    v187 = v21;
    v194 = v18;
    v176 = v27;
    v181 = v24;
    v172 = v30;
    v30 = v172;
    v27 = v176;
    v24 = v181;
    v21 = v187;
    v18 = v194;
    v15 = v202;
    v12 = v211;
    v9 = v221;
    v6 = v232;
    v143 = v142;
    v3 = v244;
    a1 = v257;
    if (v143)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchTerminatorOpInterface::Trait<Empty>]";
      v261 = 103;
      v144 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v144)
        v145 = v144;
      else
        v145 = v261;
      v146 = &v260[v145];
      v147 = v261 - v145;
      if (v261 - v145 >= 0x12)
        v148 = 18;
      else
        v148 = v261 - v145;
      v149 = v147 - v148;
      if (v149 >= v149 - 1)
        v150 = v149 - 1;
      else
        v150 = v149;
      mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchTerminatorOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v146[v148], v150);
      v30 = v172;
      v27 = v176;
      v24 = v181;
      v21 = v187;
      v18 = v194;
      v15 = v202;
      v12 = v211;
      v9 = v221;
      v6 = v232;
      v3 = v244;
      a1 = v257;
    }
  }
  v33 = v32[459];
  v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v34 & 1) == 0)
  {
    v245 = v3;
    v258 = a1;
    v222 = v9;
    v233 = v6;
    v203 = v15;
    v212 = v12;
    v188 = v21;
    v195 = v18;
    v177 = v27;
    v182 = v24;
    v170 = v33;
    v173 = v30;
    v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v33 = v170;
    v30 = v173;
    v27 = v177;
    v24 = v182;
    v21 = v188;
    v18 = v195;
    v15 = v203;
    v12 = v212;
    v9 = v222;
    v6 = v233;
    v152 = v151;
    v3 = v245;
    a1 = v258;
    if (v152)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ReturnLike<Empty>]";
      v261 = 82;
      v153 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v153)
        v154 = v153;
      else
        v154 = v261;
      v155 = &v260[v154];
      v156 = v261 - v154;
      if (v261 - v154 >= 0x12)
        v157 = 18;
      else
        v157 = v261 - v154;
      v158 = v156 - v157;
      if (v158 >= v158 - 1)
        v159 = v158 - 1;
      else
        v159 = v158;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ReturnLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ReturnLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v155[v157], v159);
      v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v33 = v170;
      v30 = v173;
      v27 = v177;
      v24 = v182;
      v21 = v188;
      v18 = v195;
      v15 = v203;
      v12 = v212;
      v9 = v222;
      v6 = v233;
      v3 = v245;
      a1 = v258;
    }
  }
  v36 = v35[182];
  v38 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v37 & 1) == 0)
  {
    v246 = v3;
    v259 = a1;
    v223 = v9;
    v234 = v6;
    v204 = v15;
    v213 = v12;
    v189 = v21;
    v196 = v18;
    v178 = v27;
    v183 = v24;
    v171 = v33;
    v174 = v30;
    v169 = v36;
    v38 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v36 = v169;
    v33 = v171;
    v30 = v174;
    v27 = v178;
    v24 = v183;
    v21 = v189;
    v18 = v196;
    v15 = v204;
    v12 = v213;
    v9 = v223;
    v6 = v234;
    v161 = v160;
    v3 = v246;
    a1 = v259;
    if (v161)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsTerminator<Empty>]";
      v261 = 84;
      v162 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v162)
        v163 = v162;
      else
        v163 = v261;
      v164 = &v260[v163];
      v165 = v261 - v163;
      if (v261 - v163 >= 0x12)
        v166 = 18;
      else
        v166 = v261 - v163;
      v167 = v165 - v166;
      if (v167 >= v167 - 1)
        v168 = v167 - 1;
      else
        v168 = v167;
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v164[v166], v168);
      v38 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v36 = v169;
      v33 = v171;
      v30 = v174;
      v27 = v178;
      v24 = v183;
      v21 = v189;
      v18 = v196;
      v15 = v204;
      v12 = v213;
      v9 = v223;
      v6 = v234;
      v3 = v246;
      a1 = v259;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == (_QWORD)a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == a1
      || v27 == (_QWORD)a1
      || v30 == (_QWORD)a1
      || v33 == (_QWORD)a1
      || v36 == (_QWORD)a1
      || v38[190] == (_QWORD)a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;

  mlir::OpState::printOpName(a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::func::ReturnOp::print((mlir::func::ReturnOp *)&v7, a3);
}

BOOL mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyZeroResults(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<mlir::func::ReturnOp>::verifyTrait((uint64_t *)a1)
    || !mlir::OpTrait::impl::verifyIsTerminator(a1, v5))
  {
    return 0;
  }
  v7 = a1;
  return mlir::func::ReturnOp::verify((uint64_t **)&v7) != 0;
}

uint64_t mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<mlir::func::ReturnOp>::verifyTrait(uint64_t *a1)
{
  mlir::Block *v2;
  uint64_t ParentOp;
  const char **v4;
  char *v5;
  char *v6;
  __int128 v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  const char **v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  _QWORD **v17;
  _QWORD **v18;
  void *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  void *v23;
  void *v24;
  unint64_t v26;
  unint64_t v27;
  BOOL v28;
  int64_t v29;
  char *v30;
  const char *v31;
  const void **v32;
  __int16 v33;
  const char *v34;
  const char *v35;
  uint64_t v36;
  _QWORD v37[2];
  _QWORD v38[3];
  void *v39;
  unsigned int v40;
  unsigned int v41;
  _BYTE v42[96];
  void *v43;
  _QWORD *v44;
  void *__p;
  _QWORD **v46;
  char v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v2 = (mlir::Block *)a1[2];
  if (v2)
  {
    ParentOp = mlir::Block::getParentOp(v2);
    if (ParentOp)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)(ParentOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id)
        return 1;
    }
  }
  v33 = 257;
  mlir::Operation::emitOpError(a1, &v32, (uint64_t)v38);
  if (v38[0])
  {
    LODWORD(v34) = 3;
    v35 = "expects parent op ";
    v36 = 18;
    v4 = &v34;
    v5 = (char *)v39;
    if (v40 >= v41)
    {
      v26 = v40 + 1;
      if (v39 <= &v34 && (char *)v39 + 24 * v40 > (char *)&v34)
      {
        v29 = (char *)&v34 - (_BYTE *)v39;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v26, 24);
        v5 = (char *)v39;
        v4 = (const char **)((char *)v39 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v26, 24);
        v4 = &v34;
        v5 = (char *)v39;
      }
    }
    v6 = &v5[24 * v40];
    v7 = *(_OWORD *)v4;
    *((_QWORD *)v6 + 2) = v4[2];
    *(_OWORD *)v6 = v7;
    ++v40;
  }
  v31 = "'";
  v8 = (_QWORD *)mlir::InFlightDiagnostic::append<char const*&>((uint64_t)v38, &v31);
  v9 = (uint64_t)v8;
  v37[0] = "func.func";
  v37[1] = 9;
  if (*v8)
  {
    v34 = ", ";
    llvm::interleave<llvm::StringLiteral const*,mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(llvm::ArrayRef<llvm::StringLiteral> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(void)#1},void>((uint64_t)v37, (uint64_t)v38, (uint64_t)(v8 + 1), (uint64_t)(v8 + 1), &v34);
    if (*(_QWORD *)v9)
    {
      v10 = v9 + 24;
      v11 = *(_QWORD *)(v9 + 24);
      LODWORD(v34) = 3;
      v35 = "'";
      v36 = 1;
      v12 = *(unsigned int *)(v9 + 32);
      v13 = &v34;
      if (v12 >= *(_DWORD *)(v9 + 36))
      {
        v27 = v12 + 1;
        v28 = v11 + 24 * v12 > (unint64_t)&v34;
        if (v11 <= (unint64_t)&v34 && v28)
        {
          v30 = (char *)&v34 - v11;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v10, (void *)(v9 + 40), v27, 24);
          v11 = *(_QWORD *)(v9 + 24);
          v13 = (const char **)&v30[v11];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v10, (void *)(v9 + 40), v27, 24);
          v11 = *(_QWORD *)(v9 + 24);
          v13 = &v34;
        }
      }
      v14 = v11 + 24 * *(unsigned int *)(v9 + 32);
      v15 = *(_OWORD *)v13;
      *(_QWORD *)(v14 + 16) = v13[2];
      *(_OWORD *)v14 = v15;
      ++*(_DWORD *)(v9 + 32);
    }
  }
  v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v9);
  if (v38[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v38);
  if (v47)
  {
    v17 = (_QWORD **)__p;
    if (__p)
    {
      v18 = v46;
      v19 = __p;
      if (v46 != __p)
      {
        do
          v18 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v18 - 1);
        while (v18 != v17);
        v19 = __p;
      }
      v46 = v17;
      operator delete(v19);
    }
    v20 = v43;
    if (v43)
    {
      v21 = v44;
      v22 = v43;
      if (v44 != v43)
      {
        do
        {
          v24 = (void *)*--v21;
          v23 = v24;
          *v21 = 0;
          if (v24)
            operator delete[](v23);
        }
        while (v21 != v20);
        v22 = v43;
      }
      v44 = v20;
      operator delete(v22);
    }
    if (v39 != v42)
      free(v39);
  }
  return v16;
}

uint64_t llvm::interleave<llvm::StringLiteral const*,mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(llvm::ArrayRef<llvm::StringLiteral> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(void)#1},void>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, const char **a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  unint64_t *v14;
  const char *v15;
  size_t v16;
  uint64_t v17;
  unint64_t v18;
  const void ***v19;
  uint64_t v20;
  __int128 v21;
  const void **v22;
  const char *v23;
  unint64_t v24;
  BOOL v25;
  char *v26;
  void *v27;
  const void **v28;
  const char *v29;
  size_t v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;

  if (result != a2)
  {
    v32 = v5;
    v33 = v6;
    v11 = result;
    v31 = 262;
    v12 = *(const char **)(result + 8);
    v28 = *(const void ***)result;
    v29 = v12;
    result = mlir::Diagnostic::operator<<(a3, &v28);
    v13 = v11 + 16;
    if (v11 + 16 != a2)
    {
      v14 = (unint64_t *)(a4 + 16);
      v27 = (void *)(a4 + 32);
      do
      {
        v15 = *a5;
        if (*a5)
        {
          v16 = strlen(*a5);
          LODWORD(v28) = 3;
          v29 = v15;
          v30 = v16;
          v17 = *(unsigned int *)(a4 + 24);
          v18 = *(_QWORD *)(a4 + 16);
          if (v17 < *(_DWORD *)(a4 + 28))
            goto LABEL_8;
        }
        else
        {
          LODWORD(v28) = 3;
          v29 = 0;
          v30 = 0;
          v17 = *(unsigned int *)(a4 + 24);
          v18 = *(_QWORD *)(a4 + 16);
          if (v17 < *(_DWORD *)(a4 + 28))
            goto LABEL_8;
        }
        v24 = v17 + 1;
        v25 = v18 + 24 * v17 > (unint64_t)&v28;
        if (v18 <= (unint64_t)&v28 && v25)
        {
          v26 = (char *)&v28 - v18;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4 + 16, v27, v24, 24);
          v18 = *v14;
          v19 = (const void ***)&v26[*v14];
          goto LABEL_9;
        }
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4 + 16, v27, v24, 24);
        v18 = *v14;
LABEL_8:
        v19 = &v28;
LABEL_9:
        v20 = v18 + 24 * *(unsigned int *)(a4 + 24);
        v21 = *(_OWORD *)v19;
        *(_QWORD *)(v20 + 16) = v19[2];
        *(_OWORD *)v20 = v21;
        ++*(_DWORD *)(a4 + 24);
        v31 = 262;
        v22 = *(const void ***)v13;
        v23 = *(const char **)(v13 + 8);
        v13 += 16;
        v28 = v22;
        v29 = v23;
        result = mlir::Diagnostic::operator<<(a3, &v28);
      }
      while (v13 != a2);
    }
  }
  return result;
}

uint64_t mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyRegionInvariants()
{
  return 1;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>,std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::LookupBucketFor<std::pair<mlir::TypeID,mlir::TypeID>>(uint64_t *a1, uint64_t *a2, _QWORD *a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  int v11;
  unsigned int v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v17;
  int v18;
  uint64_t result;
  BOOL v20;
  unsigned int v22;

  v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    v4 = *a1;
    v5 = *a2;
    v6 = a2[1];
    v7 = ((v6 >> 4) ^ (v6 >> 9) | ((unint64_t)((*a2 >> 4) ^ (*a2 >> 9)) << 32))
       + ~((unint64_t)((v6 >> 4) ^ (v6 >> 9)) << 32);
    v8 = (v7 ^ (v7 >> 22)) + ~((v7 ^ (v7 >> 22)) << 13);
    v9 = (9 * (v8 ^ (v8 >> 8))) ^ ((9 * (v8 ^ (v8 >> 8))) >> 15);
    v10 = ((v9 + ~(v9 << 27)) >> 31) ^ (v9 + ~((_DWORD)v9 << 27));
    v11 = v3 - 1;
    v12 = (v3 - 1) & v10;
    v13 = (_QWORD *)(*a1 + 16 * v12);
    v14 = *v13;
    v15 = v13[1];
    if (*a2 == *v13 && v6 == v15)
    {
      result = 1;
      *a3 = v13;
    }
    else
    {
      v17 = 0;
      v18 = 1;
      result = 1;
      while (v14 != -4096 || v15 != -4096)
      {
        if (v17)
          v20 = 0;
        else
          v20 = v15 == -8192;
        if (v20 && v14 == -8192)
          v17 = v13;
        v22 = v12 + v18++;
        v12 = v22 & v11;
        v13 = (_QWORD *)(v4 + 16 * (v22 & v11));
        v14 = *v13;
        v15 = v13[1];
        if (v5 == *v13 && v6 == v15)
        {
          *a3 = v13;
          return result;
        }
      }
      result = 0;
      if (v17)
        v13 = v17;
      *a3 = v13;
    }
  }
  else
  {
    result = 0;
    *a3 = 0;
  }
  return result;
}

_QWORD *llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>,std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::InsertIntoBucketImpl<std::pair<mlir::TypeID,mlir::TypeID>>(uint64_t a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  int v6;
  unsigned int v7;
  _QWORD *v9;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    ++*(_DWORD *)(a1 + 8);
    if (*a4 != -4096)
      goto LABEL_8;
    goto LABEL_4;
  }
  llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::grow(a1, v7);
  v9 = 0;
  llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>,std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::LookupBucketFor<std::pair<mlir::TypeID,mlir::TypeID>>((uint64_t *)a1, a3, &v9);
  a4 = v9;
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096)
    goto LABEL_8;
LABEL_4:
  if (a4[1] == -4096)
    return a4;
LABEL_8:
  --*(_DWORD *)(a1 + 12);
  return a4;
}

void llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  llvm *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  void *buffer;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(llvm **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  buffer = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = buffer;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v10 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v10)
      memset_pattern16(buffer, &unk_181232E00, 16 * v10);
    v11 = (void *)(16 * v3);
    if ((_DWORD)v3)
    {
      v12 = 16 * v3;
      v13 = (uint64_t *)v4;
      do
      {
        v15 = v13[1];
        if ((*v13 != -4096 || v15 != -4096) && (*v13 != -8192 || v15 != -8192))
        {
          v17 = 0;
          llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>,std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::LookupBucketFor<std::pair<mlir::TypeID,mlir::TypeID>>((uint64_t *)a1, v13, &v17);
          v14 = v17;
          *v17 = *v13;
          v14[1] = v13[1];
          ++*(_DWORD *)(a1 + 8);
        }
        v13 += 2;
        v12 -= 16;
      }
      while (v12);
    }
    llvm::deallocate_buffer(v4, v11);
  }
  *(_QWORD *)(a1 + 8) = 0;
  v16 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v16)
    memset_pattern16(buffer, &unk_181232E00, 16 * v16);
}

__n128 llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,mlir::Diagnostic& mlir::Diagnostic::appendRange<mlir::ValueTypeRange<mlir::ResultRange>>(mlir::ValueTypeRange<mlir::ResultRange> const&,char const*)::{lambda(mlir::ValueTypeRange<mlir::ResultRange> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<mlir::ValueTypeRange<mlir::ResultRange>>(mlir::ValueTypeRange<mlir::ResultRange> const&,char const*)::{lambda(void)#1},void>(mlir::detail::OpResultImpl *this, uint64_t a2, mlir::detail::OpResultImpl *a3, uint64_t a4, uint64_t a5, uint64_t a6, const char **a7)
{
  uint64_t NextResultAtOffset;
  __n128 *v15;
  unint64_t v16;
  uint64_t v17;
  __n128 *v18;
  __n128 result;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  size_t v23;
  uint64_t v24;
  unint64_t v25;
  int *v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  __n128 *v30;
  uint64_t v31;
  unint64_t v32;
  __n128 *v33;
  unint64_t v34;
  BOOL v35;
  unint64_t v36;
  BOOL v37;
  unint64_t v38;
  BOOL v39;
  char *v40;
  char *v41;
  char *v42;
  void *v43;
  void *v44;
  unint64_t *v45;
  unint64_t *v46;
  int v47;
  const char *v48;
  size_t v49;

  if (this != a3 || a2 != a4)
  {
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, a2);
    v15 = (__n128 *)&v47;
    mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v47, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
    v16 = *(_QWORD *)(a5 + 16);
    v46 = (unint64_t *)(a5 + 16);
    v17 = *(unsigned int *)(a5 + 24);
    if (v17 >= *(_DWORD *)(a5 + 28))
    {
      v38 = v17 + 1;
      v39 = v16 + 24 * v17 > (unint64_t)&v47;
      if (v16 <= (unint64_t)&v47 && v39)
      {
        v40 = (char *)&v47 - v16;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v46, (void *)(a5 + 32), v38, 24);
        v16 = *(_QWORD *)(a5 + 16);
        v15 = (__n128 *)&v40[v16];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v46, (void *)(a5 + 32), v38, 24);
        v16 = *(_QWORD *)(a5 + 16);
        v15 = (__n128 *)&v47;
      }
    }
    v18 = (__n128 *)(v16 + 24 * *(unsigned int *)(a5 + 24));
    result = *v15;
    v18[1].n128_u64[0] = v15[1].n128_u64[0];
    *v18 = result;
    ++*(_DWORD *)(a5 + 24);
    if (this != a3 || a2 + 1 != a4)
    {
      v44 = (void *)(a6 + 32);
      v45 = (unint64_t *)(a6 + 16);
      v43 = (void *)(a5 + 32);
      v20 = a2 + 2;
      do
      {
        v21 = v20;
        v22 = *a7;
        if (*a7)
        {
          v23 = strlen(*a7);
          v47 = 3;
          v48 = v22;
          v49 = v23;
          v24 = *(unsigned int *)(a6 + 24);
          v25 = *(_QWORD *)(a6 + 16);
          if (v24 < *(_DWORD *)(a6 + 28))
            goto LABEL_12;
        }
        else
        {
          v47 = 3;
          v48 = 0;
          v49 = 0;
          v24 = *(unsigned int *)(a6 + 24);
          v25 = *(_QWORD *)(a6 + 16);
          if (v24 < *(_DWORD *)(a6 + 28))
            goto LABEL_12;
        }
        v34 = v24 + 1;
        v35 = v25 + 24 * v24 > (unint64_t)&v47;
        if (v25 <= (unint64_t)&v47 && v35)
        {
          v41 = (char *)&v47 - v25;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v45, v44, v34, 24);
          v25 = *v45;
          v26 = (int *)&v41[*v45];
          goto LABEL_13;
        }
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v45, v44, v34, 24);
        v25 = *v45;
LABEL_12:
        v26 = &v47;
LABEL_13:
        v27 = v25 + 24 * *(unsigned int *)(a6 + 24);
        v28 = *(_OWORD *)v26;
        *(_QWORD *)(v27 + 16) = *((_QWORD *)v26 + 2);
        *(_OWORD *)v27 = v28;
        ++*(_DWORD *)(a6 + 24);
        v29 = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, v21 - 1);
        v30 = (__n128 *)&v47;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v47, *(_QWORD *)(v29 + 8) & 0xFFFFFFFFFFFFFFF8);
        v31 = *(unsigned int *)(a5 + 24);
        v32 = *(_QWORD *)(a5 + 16);
        if (v31 >= *(_DWORD *)(a5 + 28))
        {
          v36 = v31 + 1;
          v37 = v32 + 24 * v31 > (unint64_t)&v47;
          if (v32 <= (unint64_t)&v47 && v37)
          {
            v42 = (char *)&v47 - v32;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v46, v43, v36, 24);
            v32 = *v46;
            v30 = (__n128 *)&v42[*v46];
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v46, v43, v36, 24);
            v32 = *v46;
            v30 = (__n128 *)&v47;
          }
        }
        v33 = (__n128 *)(v32 + 24 * *(unsigned int *)(a5 + 24));
        result = *v30;
        v33[1].n128_u64[0] = v30[1].n128_u64[0];
        *v33 = result;
        ++*(_DWORD *)(a5 + 24);
        v20 = v21 + 1;
      }
      while (this != a3 || a4 != v21);
    }
  }
  return result;
}

__n128 llvm::interleave<mlir::Type const*,mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<mlir::Type>>(llvm::ArrayRef<mlir::Type> const&,char const*)::{lambda(llvm::ArrayRef<mlir::Type> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<mlir::Type>>(llvm::ArrayRef<mlir::Type> const&,char const*)::{lambda(void)#1},void>(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, const char **a5)
{
  uint64_t v5;
  uint64_t v6;
  __n128 *v12;
  unint64_t v13;
  unint64_t *v14;
  uint64_t v15;
  __n128 *v16;
  __n128 result;
  uint64_t *v18;
  const char *v19;
  size_t v20;
  uint64_t v21;
  unint64_t v22;
  int *v23;
  uint64_t v24;
  __int128 v25;
  __n128 *v26;
  uint64_t v27;
  unint64_t v28;
  __n128 *v29;
  unint64_t v30;
  BOOL v31;
  unint64_t v32;
  BOOL v33;
  char *v34;
  unint64_t v35;
  BOOL v36;
  char *v37;
  char *v38;
  void *v39;
  unint64_t *v40;
  int v41;
  const char *v42;
  size_t v43;
  uint64_t v44;
  uint64_t v45;

  if (a1 != a2)
  {
    v44 = v5;
    v45 = v6;
    v12 = (__n128 *)&v41;
    mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v41, *a1);
    v14 = (unint64_t *)(a3 + 16);
    v13 = *(_QWORD *)(a3 + 16);
    v15 = *(unsigned int *)(a3 + 24);
    if (v15 >= *(_DWORD *)(a3 + 28))
    {
      v35 = v15 + 1;
      v36 = v13 + 24 * v15 > (unint64_t)&v41;
      if (v13 <= (unint64_t)&v41 && v36)
      {
        v37 = (char *)&v41 - v13;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3 + 16, (void *)(a3 + 32), v35, 24);
        v13 = *(_QWORD *)(a3 + 16);
        v12 = (__n128 *)&v37[v13];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3 + 16, (void *)(a3 + 32), v35, 24);
        v13 = *(_QWORD *)(a3 + 16);
        v12 = (__n128 *)&v41;
      }
    }
    v16 = (__n128 *)(v13 + 24 * *(unsigned int *)(a3 + 24));
    result = *v12;
    v16[1].n128_u64[0] = v12[1].n128_u64[0];
    *v16 = result;
    ++*(_DWORD *)(a3 + 24);
    v18 = a1 + 1;
    if (a1 + 1 != a2)
    {
      v39 = (void *)(a4 + 32);
      v40 = (unint64_t *)(a4 + 16);
      do
      {
        v19 = *a5;
        if (*a5)
        {
          v20 = strlen(*a5);
          v41 = 3;
          v42 = v19;
          v43 = v20;
          v21 = *(unsigned int *)(a4 + 24);
          v22 = *(_QWORD *)(a4 + 16);
          if (v21 < *(_DWORD *)(a4 + 28))
            goto LABEL_9;
        }
        else
        {
          v41 = 3;
          v42 = 0;
          v43 = 0;
          v21 = *(unsigned int *)(a4 + 24);
          v22 = *(_QWORD *)(a4 + 16);
          if (v21 < *(_DWORD *)(a4 + 28))
            goto LABEL_9;
        }
        v30 = v21 + 1;
        v31 = v22 + 24 * v21 > (unint64_t)&v41;
        if (v22 <= (unint64_t)&v41 && v31)
        {
          v38 = (char *)&v41 - v22;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v40, v39, v30, 24);
          v22 = *v40;
          v23 = (int *)&v38[*v40];
          goto LABEL_10;
        }
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v40, v39, v30, 24);
        v22 = *v40;
LABEL_9:
        v23 = &v41;
LABEL_10:
        v24 = v22 + 24 * *(unsigned int *)(a4 + 24);
        v25 = *(_OWORD *)v23;
        *(_QWORD *)(v24 + 16) = *((_QWORD *)v23 + 2);
        *(_OWORD *)v24 = v25;
        ++*(_DWORD *)(a4 + 24);
        v26 = (__n128 *)&v41;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v41, *v18);
        v27 = *(unsigned int *)(a3 + 24);
        v28 = *(_QWORD *)(a3 + 16);
        if (v27 >= *(_DWORD *)(a3 + 28))
        {
          v32 = v27 + 1;
          v33 = v28 + 24 * v27 > (unint64_t)&v41;
          if (v28 <= (unint64_t)&v41 && v33)
          {
            v34 = (char *)&v41 - v28;
            llvm::SmallVectorBase<unsigned int>::grow_pod(a3 + 16, (void *)(a3 + 32), v32, 24);
            v28 = *v14;
            v26 = (__n128 *)&v34[*v14];
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(a3 + 16, (void *)(a3 + 32), v32, 24);
            v28 = *v14;
            v26 = (__n128 *)&v41;
          }
        }
        v29 = (__n128 *)(v28 + 24 * *(unsigned int *)(a3 + 24));
        result = *v26;
        v29[1].n128_u64[0] = v26[1].n128_u64[0];
        *v29 = result;
        ++*(_DWORD *)(a3 + 24);
        ++v18;
      }
      while (v18 != a2);
    }
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::func::CallOp,mlir::SymbolRefAttr &,mlir::ValueTypeRange<mlir::ResultRange>,mlir::OperandRange>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t NextResultAtOffset;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  mlir::GenericProgramPoint *v18;
  mlir::GenericProgramPoint *v19;
  uint64_t v21;
  const char *v22;
  __int16 v23;
  unint64_t v24[2];
  unint64_t v25[2];
  _QWORD v26[38];
  uint64_t v27[4];
  __int16 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v21 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"func.call", (const unsigned __int8 *)9, Context);
  if (!v12)
  {
    v28 = 1283;
    v27[2] = (uint64_t)"func.call";
    v27[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v23 = 259;
    llvm::operator+(v27, (uint64_t *)&v22, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  v13 = *a3;
  NextResultAtOffset = *a4;
  v15 = a4[1];
  v16 = a4[3];
  if (v15)
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, v15);
  mlir::ValueRange::ValueRange((unint64_t *)v27, NextResultAtOffset, v16 - v15);
  mlir::TypeRange::TypeRange(v25, v27[0], v27[1]);
  v17 = mlir::ValueRange::ValueRange(v24, *(_QWORD *)a5, *(_QWORD *)(a5 + 8));
  mlir::func::CallOp::build((uint64_t)v17, (uint64_t)v26, v13, v25[0], v25[1], v24[0], v24[1]);
  v18 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v26);
  if (*(_UNKNOWN **)(*((_QWORD *)v18 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::func::CallOp,void>::id)
    v19 = v18;
  else
    v19 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v19;
}

uint64_t llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::func::FuncOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t a1, mlir::MLIRContext **a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  unint64_t v10[2];
  unint64_t v11[3];

  v11[2] = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  mlir::ValueRange::ValueRange(v10, a5, a6);
  return mlir::Builder::getFunctionType(a2, v11[0], v11[1], v10[0], v10[1]);
}

_QWORD *mlir::RewritePatternSet::add<mlir::func::CallIndirectOp>(mlir::LogicalResult (*)(mlir::func::CallIndirectOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::RewritePatternSet::add<mlir::func::CallIndirectOp>(mlir::LogicalResult (*)(mlir::func::CallIndirectOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::func::CallIndirectOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::func::CallIndirectOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::func::CallIndirectOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::RewritePatternSet::add<mlir::func::CallIndirectOp>(mlir::LogicalResult (*)(mlir::func::CallIndirectOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

uint64_t mlir::AsmParser::parseAttribute<mlir::FlatSymbolRefAttr>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD **v12;
  _QWORD **v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  void *v18;
  void *v19;
  const char *v21;
  __int16 v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  uint64_t v26;
  void *v27;
  _QWORD *v28;
  void *__p;
  _QWORD **v30;
  char v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v23 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *, uint64_t))(*(_QWORD *)a1 + 408))(a1, &v23, a3))
    return 0;
  v7 = v23;
  if (*(_UNKNOWN **)(*(_QWORD *)v23 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
    v8 = v23;
  else
    v8 = 0;
  v24[0] = v8;
  if (v8)
  {
    mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v24);
    if (v9)
      v10 = 0;
    else
      v10 = v7;
    *a2 = v10;
    if (!v9)
      return 1;
  }
  else
  {
    *a2 = 0;
  }
  v21 = "invalid kind of attribute specified";
  v22 = 259;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v24, a1, v6, &v21);
  v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v24);
  if (v24[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  if (v31)
  {
    v12 = (_QWORD **)__p;
    if (__p)
    {
      v13 = v30;
      v14 = __p;
      if (v30 != __p)
      {
        do
          v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
        while (v13 != v12);
        v14 = __p;
      }
      v30 = v12;
      operator delete(v14);
    }
    v15 = v27;
    if (v27)
    {
      v16 = v28;
      v17 = v27;
      if (v28 != v27)
      {
        do
        {
          v19 = (void *)*--v16;
          v18 = v19;
          *v16 = 0;
          if (v19)
            operator delete[](v18);
        }
        while (v16 != v15);
        v17 = v27;
      }
      v28 = v15;
      operator delete(v17);
    }
    if (v25 != &v26)
      free(v25);
  }
  return v11;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::CallOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = (_QWORD **)__p[0];
    if (__p[0])
    {
      v24 = (_QWORD **)__p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::ConstantOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = (_QWORD **)__p[0];
    if (__p[0])
    {
      v24 = (_QWORD **)__p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::FuncOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::FuncOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

_QWORD *mlir::func::registerInlinerExtension(mlir::func *this, mlir::DialectRegistry *a2)
{
  _QWORD *result;
  uint64_t v3;
  _QWORD v4[3];
  _QWORD *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4[0] = &unk_1E0E4FF48;
  v4[1] = mlir::func::registerInlinerExtension(mlir::DialectRegistry &)::$_0::__invoke;
  v5 = v4;
  mlir::DialectRegistry::addExtension<mlir::func::FuncDialect>(this, v4);
  result = v5;
  if (v5 == v4)
  {
    v3 = 4;
    result = v4;
  }
  else
  {
    if (!v5)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

mlir::Dialect *mlir::func::registerInlinerExtension(mlir::DialectRegistry &)::$_0::__invoke(char *a1, uint64_t a2)
{
  char *v4;
  unsigned __int8 v5;
  uint64_t *v6;
  uint64_t v7;
  const char *v8;
  int v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  const char *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  char *v19;
  const char *v20;
  unint64_t v21;

  v4 = (char *)operator new(0x18uLL);
  v6 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v5 & 1) == 0)
  {
    v19 = v4;
    v6 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v11 = v10;
    v4 = v19;
    if (v11)
    {
      v20 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DialectInlinerInterface]";
      v21 = 79;
      v12 = llvm::StringRef::find((uint64_t *)&v20, "DesiredTypeName = ", 0x12uLL, 0);
      if (v21 >= v12)
        v13 = v12;
      else
        v13 = v21;
      v14 = &v20[v13];
      v15 = v21 - v13;
      if (v21 - v13 >= 0x12)
        v16 = 18;
      else
        v16 = v21 - v13;
      v17 = v15 - v16;
      if (v17 >= v17 - 1)
        v18 = v17 - 1;
      else
        v18 = v17;
      mlir::detail::TypeIDResolver<mlir::DialectInlinerInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v14[v16], v18);
      v6 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v4 = v19;
    }
  }
  v7 = v6[157];
  *((_QWORD *)v4 + 1) = a2;
  *((_QWORD *)v4 + 2) = v7;
  *(_QWORD *)v4 = off_1E0E184F0;
  v20 = v4;
  mlir::Dialect::addInterface(a2, (uint64_t *)&v20);
  v8 = v20;
  v20 = 0;
  if (v8)
    (*(void (**)(const char *))(*(_QWORD *)v8 + 8))(v8);
  v20 = a1;
  return mlir::MLIRContext::getOrLoadDialect(a1, (uint64_t)"cf", 2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::cf::ControlFlowDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::cf::ControlFlowDialect * mlir::MLIRContext::getOrLoadDialect<mlir::cf::ControlFlowDialect>(void)::{lambda(void)#1}>, (uint64_t)&v20);
}

void `anonymous namespace'::FuncInlinerInterface::~FuncInlinerInterface(_anonymous_namespace_::FuncInlinerInterface *this)
{
  void *v1;

  mlir::GenericProgramPoint::~GenericProgramPoint(this);
  operator delete(v1);
}

uint64_t `anonymous namespace'::FuncInlinerInterface::isLegalToInline(_anonymous_namespace_::FuncInlinerInterface *this, Operation *a2, Operation *a3)
{
  return 1;
}

uint64_t `anonymous namespace'::FuncInlinerInterface::isLegalToInline()
{
  return 1;
}

{
  return 1;
}

void `anonymous namespace'::FuncInlinerInterface::handleTerminator(_anonymous_namespace_::FuncInlinerInterface *this, mlir::Operation *a2, mlir::Block *a3)
{
  mlir::Operation *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[2];
  _QWORD v10[4];
  mlir::Operation *v11;
  mlir::Block *v12;

  v12 = a3;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::func::ReturnOp,void>::id)
    v3 = a2;
  else
    v3 = 0;
  v11 = v3;
  if (v3)
  {
    v10[0] = mlir::Attribute::getContext((mlir::Operation *)((char *)a2 + 24));
    v10[1] = 0;
    v5 = *((_QWORD *)a2 + 2);
    mlir::GenericProgramPoint::~GenericProgramPoint(a2);
    v10[2] = v5;
    v10[3] = v6;
    v7 = *((_QWORD *)a2 + 3);
    v9[0] = mlir::anec::Concat::getInputs((mlir::anec::Concat *)&v11);
    v9[1] = v8;
    mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *&,mlir::OperandRange>((mlir::OpBuilder *)v10, v7, (uint64_t *)&v12, (uint64_t)v9);
    mlir::Operation::erase(a2);
  }
}

_QWORD **`anonymous namespace'::FuncInlinerInterface::handleTerminator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD **result;
  uint64_t v5;
  _QWORD **v6;
  uint64_t v7;
  uint64_t i;
  uint64_t *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a3;
  v14[1] = a4;
  v13 = a2;
  result = (_QWORD **)mlir::anec::Concat::getInputs((mlir::anec::Concat *)&v13);
  if (v5)
  {
    v6 = result;
    v7 = v5;
    for (i = 0; i != v7; ++i)
    {
      v9 = v6[4 * i + 3];
      result = (_QWORD **)mlir::ValueRange::dereference_iterator(v14, i);
      while (1)
      {
        v10 = *result;
        if (!*result)
          break;
        v11 = (_QWORD *)v10[1];
        if (v11)
        {
          *v11 = *v10;
          if (*v10)
            *(_QWORD *)(*v10 + 8) = v10[1];
        }
        v10[3] = v9;
        v10[1] = v9;
        v12 = *v9;
        *v10 = *v9;
        if (v12)
          *(_QWORD *)(v12 + 8) = v10;
        *v9 = (uint64_t)v10;
      }
    }
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *&,mlir::OperandRange>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  mlir::GenericProgramPoint *v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  uint64_t v18[4];
  __int16 v19;
  unint64_t v20[2];
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v15 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"cf.br", (const unsigned __int8 *)5, Context);
  if (!v10)
  {
    v19 = 1283;
    v18[2] = (uint64_t)"cf.br";
    v18[3] = 5;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v17 = 259;
    llvm::operator+(v18, (uint64_t *)&v16, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  v11 = *a3;
  mlir::ValueRange::ValueRange(v20, *(_QWORD *)a4, *(_QWORD *)(a4 + 8));
  mlir::cf::BranchOp::build((uint64_t)a1, (uint64_t)v21, v11, v20[0], v20[1]);
  v12 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v12 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::cf::BranchOp,void>::id)
    v13 = v12;
  else
    v13 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v13;
}

mlir::cf::ControlFlowDialect *llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::cf::ControlFlowDialect * mlir::MLIRContext::getOrLoadDialect<mlir::cf::ControlFlowDialect>(void)::{lambda(void)#1}>@<X0>(mlir::MLIRContext **a1@<X0>, mlir::cf::ControlFlowDialect **a2@<X8>)
{
  mlir::MLIRContext *v3;
  mlir::cf::ControlFlowDialect *v4;
  mlir::cf::ControlFlowDialect *result;

  v3 = *a1;
  v4 = (mlir::cf::ControlFlowDialect *)operator new(0x60uLL);
  result = mlir::cf::ControlFlowDialect::ControlFlowDialect(v4, v3);
  *a2 = result;
  return result;
}

_QWORD *mlir::DialectRegistry::addExtension<mlir::func::FuncDialect>(_QWORD *a1, _QWORD *a2)
{
  _QWORD *result;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD v11[3];
  _QWORD *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  result = operator new(0x68uLL);
  v5 = result;
  v6 = (_QWORD *)a2[3];
  if (v6)
  {
    if (v6 == a2)
    {
      v12 = v11;
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v11);
      v6 = v12;
    }
    else
    {
      v12 = (_QWORD *)a2[3];
      a2[3] = 0;
    }
  }
  else
  {
    v12 = 0;
  }
  v5[3] = "func";
  v5[4] = 4;
  v5[2] = 0x300000001;
  *v5 = off_1E0E52510;
  v5[1] = v5 + 3;
  if (!v6)
  {
    v5[12] = 0;
    goto LABEL_15;
  }
  if (v6 != v11)
  {
    v5[12] = v6;
    goto LABEL_15;
  }
  v5[12] = v5 + 9;
  (*(void (**)(_QWORD *))(v11[0] + 24))(v11);
  result = v12;
  if (v12 == v11)
  {
    v7 = 4;
    result = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_15;
    v7 = 5;
  }
  result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v7))();
LABEL_15:
  v10 = v5;
  v8 = (_QWORD *)a1[4];
  if ((unint64_t)v8 >= a1[5])
  {
    v9 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 3, (uint64_t *)&v10);
    result = v10;
    a1[4] = v9;
    v10 = 0;
    if (result)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
  }
  else
  {
    *v8 = v5;
    a1[4] = v8 + 1;
  }
  return result;
}

void mlir::DialectRegistry::addExtension<mlir::func::FuncDialect>(std::function<void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>)::Extension::~Extension(mlir::DialectExtensionBase *this)
{
  char *v2;
  char *v3;
  uint64_t v4;

  *(_QWORD *)this = off_1E0E52510;
  v2 = (char *)this + 72;
  v3 = (char *)*((_QWORD *)this + 12);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  mlir::DialectExtensionBase::~DialectExtensionBase(this);
}

{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;

  *(_QWORD *)this = off_1E0E52510;
  v2 = (char *)this + 72;
  v3 = (char *)*((_QWORD *)this + 12);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  mlir::DialectExtensionBase::~DialectExtensionBase(this);
  operator delete(v5);
}

uint64_t mlir::DialectExtension<void mlir::DialectRegistry::addExtension<mlir::func::FuncDialect>(std::function<void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>)::Extension,mlir::func::FuncDialect>::apply(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 32))(a1, a2, *a3);
}

uint64_t mlir::DialectExtension<void mlir::DialectRegistry::addExtension<mlir::func::FuncDialect>(std::function<void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>)::Extension,mlir::func::FuncDialect>::clone@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  void **v7;
  unsigned int v8;
  unsigned int v9;
  _QWORD *v10;
  uint64_t result;

  v4 = operator new(0x68uLL);
  v5 = v4;
  *v4 = off_1E0E2BD48;
  v6 = v4 + 3;
  v4[1] = v4 + 3;
  v7 = (void **)(v4 + 1);
  v4[2] = 0x300000000;
  if (v4 != (_QWORD *)a1)
  {
    v8 = *(_DWORD *)(a1 + 16);
    if (v8)
    {
      if (v8 < 4)
      {
        v9 = *(_DWORD *)(a1 + 16);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v4 + 1), v6, *(unsigned int *)(a1 + 16), 16);
        v9 = *(_DWORD *)(a1 + 16);
        if (!v9)
        {
LABEL_8:
          *((_DWORD *)v5 + 4) = v8;
          goto LABEL_9;
        }
        v6 = *v7;
      }
      memcpy(v6, *(const void **)(a1 + 8), 16 * v9);
      goto LABEL_8;
    }
  }
LABEL_9:
  *v5 = off_1E0E52510;
  v10 = v5 + 9;
  result = *(_QWORD *)(a1 + 96);
  if (result)
  {
    if (result == a1 + 72)
    {
      v5[12] = v10;
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
    }
    else
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)result + 16))(result, v10);
      v5[12] = result;
    }
    *a2 = v5;
  }
  else
  {
    v5[12] = 0;
    *a2 = v5;
  }
  return result;
}

uint64_t mlir::DialectRegistry::addExtension<mlir::func::FuncDialect>(std::function<void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>)::Extension::apply(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v5 = a3;
  v6 = a2;
  v3 = *(_QWORD *)(a1 + 96);
  if (!v3)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    JUMPOUT(0x18039CBE4);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v6, &v5);
}

_QWORD *std::__function::__func<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *)>,void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &unk_1E0E4FF48;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *)>,void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &unk_1E0E4FF48;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *)>,void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>::operator()(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 8))(*a2, *a3);
}

uint64_t std::__function::__func<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *)>,void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>::target(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3 == 0x800000018123688FLL)
    return a1 + 8;
  if (((v3 & 0x800000018123688FLL & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x800000018123688FLL))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x800000018123688FLL & 0x7FFFFFFFFFFFFFFFLL)))
    return a1 + 8;
  return 0;
}

void *std::__function::__func<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *)>,void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>::target_type()
{
}

uint64_t mlir::FunctionOpInterface::getArgumentTypes(mlir::FunctionOpInterface *this)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 1) + 48) + 8))();
}

uint64_t mlir::FunctionOpInterface::getResultTypes(mlir::FunctionOpInterface *this)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 1) + 48) + 16))();
}

uint64_t mlir::FunctionOpInterface::getArgAttrsAttr(mlir::FunctionOpInterface *this)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 1) + 48) + 24))();
}

uint64_t mlir::FunctionOpInterface::getResAttrsAttr(mlir::FunctionOpInterface *this)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)this + 1) + 48) + 32))();
}

void mlir::function_interface_impl::setFunctionType(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  mlir::DictionaryAttr *Context;
  unint64_t v16;
  uint64_t Value;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void **v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void **v26;
  _BYTE *v27;
  uint64_t v28;
  uint64_t v29;
  _BYTE *v30;
  uint64_t v31;
  unsigned int v32;
  _BYTE *v33;
  uint64_t v34;
  uint64_t v35;
  _BYTE *v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  char *v42;
  uint64_t *v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  char *v48;
  uint64_t *v49;
  void *v50;
  mlir::MLIRContext *v51;
  mlir::MLIRContext *v52;
  mlir::MLIRContext *v53;
  mlir::MLIRContext *v54;
  unint64_t v55;
  int64x2_t *v56;
  unint64_t *v57;
  unint64_t v58;
  int64x2_t v59;
  int64x2_t *v60;
  unint64_t v61;
  unint64_t v62;
  int64x2_t *v63;
  unint64_t *v64;
  unint64_t v65;
  int64x2_t v66;
  int64x2_t *v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  void *v71;
  uint64_t v72;
  _QWORD v73[7];

  v73[6] = *MEMORY[0x1E0C80C00];
  (*(void (**)(void))(*(_QWORD *)(a2 + 48) + 8))();
  v7 = v6;
  (*(void (**)(void))(*(_QWORD *)(a2 + 48) + 16))();
  v9 = v8;
  v10 = mlir::TypeAttr::get(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a2 + 8))(a2, a1, v10);
  (*(void (**)(void))(*(_QWORD *)(a2 + 48) + 8))();
  LODWORD(v12) = v11;
  (*(void (**)(void))(*(_QWORD *)(a2 + 48) + 16))();
  LODWORD(v14) = v13;
  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
  v16 = mlir::DictionaryAttr::get(Context, 0, 0);
  if (v7 == (_DWORD)v12)
    goto LABEL_13;
  if (!(_DWORD)v12)
    goto LABEL_12;
  v69 = (*(uint64_t (**)(void))(*(_QWORD *)(a2 + 48) + 24))();
  if (!v69)
    goto LABEL_13;
  if (v12 < v7)
  {
    Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69);
    if (v18 >= v12)
      v12 = v12;
    else
      v12 = v18;
    if (v12)
    {
      v19 = Value;
      v20 = 8 * v12;
      v21 = (void **)Value;
      while (1)
      {
        v71 = *v21;
        if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v71))
          break;
        ++v21;
        v20 -= 8;
        if (!v20)
          goto LABEL_12;
      }
      v53 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
      mlir::ArrayAttr::get(v53, v19, v12);
      (*(void (**)(void))(*(_QWORD *)(a2 + 48) + 40))();
      goto LABEL_13;
    }
LABEL_12:
    (*(void (**)(void))(*(_QWORD *)(a2 + 48) + 56))();
    goto LABEL_13;
  }
  v27 = (_BYTE *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69);
  v28 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69);
  v30 = (_BYTE *)(v28 + 8 * v29);
  v71 = v73;
  v72 = 0x600000000;
  v31 = v30 - v27;
  if ((unint64_t)(v30 - v27) < 0x31)
  {
    v32 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v73, v31 >> 3, 8);
    v32 = v72;
  }
  if (v30 != v27)
  {
    memcpy((char *)v71 + 8 * v32, v27, v30 - v27);
    v32 = v72;
  }
  v39 = v32 + ((unint64_t)v31 >> 3);
  LODWORD(v72) = v39;
  v40 = v12;
  if ((_DWORD)v39 == (_DWORD)v12)
  {
LABEL_36:
    v41 = v71;
    v42 = (char *)v71 + 8 * v40;
    v43 = (uint64_t *)v71;
    goto LABEL_37;
  }
  if (v39 > v12)
  {
    LODWORD(v72) = v12;
    goto LABEL_36;
  }
  v55 = v12 - v39;
  if (HIDWORD(v72) < v12)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v73, v12, 8);
    v39 = v72;
    if (!v55)
      goto LABEL_65;
  }
  else if (!v55)
  {
    goto LABEL_65;
  }
  v56 = (int64x2_t *)((char *)v71 + 8 * v39);
  v57 = (unint64_t *)v56;
  v58 = v55;
  if (v55 < 4)
    goto LABEL_82;
  v57 = (unint64_t *)v56 + (v55 & 0xFFFFFFFFFFFFFFFCLL);
  v58 = v55 & 3;
  v59 = vdupq_n_s64(v16);
  v60 = v56 + 1;
  v61 = v55 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v60[-1] = v59;
    *v60 = v59;
    v60 += 2;
    v61 -= 4;
  }
  while (v61);
  if (v55 != (v55 & 0xFFFFFFFFFFFFFFFCLL))
  {
LABEL_82:
    do
    {
      *v57++ = v16;
      --v58;
    }
    while (v58);
  }
LABEL_65:
  v40 = (v39 + v55);
  LODWORD(v72) = v39 + v55;
  if (!((_DWORD)v39 + (_DWORD)v55))
  {
LABEL_39:
    (*(void (**)(void))(*(_QWORD *)(a2 + 48) + 56))();
    v44 = v71;
    if (v71 == v73)
      goto LABEL_13;
LABEL_53:
    free(v44);
    goto LABEL_13;
  }
  v41 = v71;
  v42 = (char *)v71 + 8 * v40;
  v43 = (uint64_t *)v71;
LABEL_37:
  while (1)
  {
    v70 = *v43;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v70))
      break;
    if (++v43 == (uint64_t *)v42)
      goto LABEL_39;
  }
  v51 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
  mlir::ArrayAttr::get(v51, (uint64_t)v41, v40);
  (*(void (**)(void))(*(_QWORD *)(a2 + 48) + 40))();
  v44 = v71;
  if (v71 != v73)
    goto LABEL_53;
LABEL_13:
  if (v9 == (_DWORD)v14)
    return;
  if (!(_DWORD)v14)
    goto LABEL_24;
  v69 = (*(uint64_t (**)(void))(*(_QWORD *)(a2 + 48) + 32))();
  if (!v69)
    return;
  if (v14 < v9)
  {
    v22 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69);
    if (v23 >= v14)
      v14 = v14;
    else
      v14 = v23;
    if (v14)
    {
      v24 = v22;
      v25 = 8 * v14;
      v26 = (void **)v22;
      while (1)
      {
        v71 = *v26;
        if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v71))
          break;
        ++v26;
        v25 -= 8;
        if (!v25)
          goto LABEL_24;
      }
      v54 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
      mlir::ArrayAttr::get(v54, v24, v14);
      (*(void (**)(void))(*(_QWORD *)(a2 + 48) + 48))();
      return;
    }
LABEL_24:
    (*(void (**)(void))(*(_QWORD *)(a2 + 48) + 64))();
    return;
  }
  v33 = (_BYTE *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69);
  v34 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69);
  v36 = (_BYTE *)(v34 + 8 * v35);
  v71 = v73;
  v72 = 0x600000000;
  v37 = v36 - v33;
  if ((unint64_t)(v36 - v33) < 0x31)
  {
    v38 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v73, v37 >> 3, 8);
    v38 = v72;
  }
  if (v36 != v33)
  {
    memcpy((char *)v71 + 8 * v38, v33, v36 - v33);
    v38 = v72;
  }
  v45 = v38 + ((unint64_t)v37 >> 3);
  LODWORD(v72) = v45;
  v46 = v14;
  if ((_DWORD)v45 == (_DWORD)v14)
  {
LABEL_47:
    v47 = v71;
    v48 = (char *)v71 + 8 * v14;
    v49 = (uint64_t *)v71;
    goto LABEL_48;
  }
  if (v45 > v14)
  {
    LODWORD(v72) = v14;
    goto LABEL_47;
  }
  v62 = v14 - v45;
  if (HIDWORD(v72) < v14)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v73, v14, 8);
    v45 = v72;
    if (!v62)
      goto LABEL_74;
  }
  else if (!v62)
  {
    goto LABEL_74;
  }
  v63 = (int64x2_t *)((char *)v71 + 8 * v45);
  v64 = (unint64_t *)v63;
  v65 = v62;
  if (v62 < 4)
    goto LABEL_83;
  v64 = (unint64_t *)v63 + (v62 & 0xFFFFFFFFFFFFFFFCLL);
  v65 = v62 & 3;
  v66 = vdupq_n_s64(v16);
  v67 = v63 + 1;
  v68 = v62 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v67[-1] = v66;
    *v67 = v66;
    v67 += 2;
    v68 -= 4;
  }
  while (v68);
  if (v62 != (v62 & 0xFFFFFFFFFFFFFFFCLL))
  {
LABEL_83:
    do
    {
      *v64++ = v16;
      --v65;
    }
    while (v65);
  }
LABEL_74:
  v46 = (v45 + v62);
  LODWORD(v72) = v45 + v62;
  if (!((_DWORD)v45 + (_DWORD)v62))
  {
LABEL_50:
    (*(void (**)(void))(*(_QWORD *)(a2 + 48) + 64))();
    v50 = v71;
    if (v71 == v73)
      return;
LABEL_55:
    free(v50);
    return;
  }
  v47 = v71;
  v48 = (char *)v71 + 8 * v46;
  v49 = (uint64_t *)v71;
LABEL_48:
  while (1)
  {
    v70 = *v49;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v70))
      break;
    if (++v49 == (uint64_t *)v48)
      goto LABEL_50;
  }
  v52 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
  mlir::ArrayAttr::get(v52, (uint64_t)v47, v46);
  (*(void (**)(void))(*(_QWORD *)(a2 + 48) + 48))();
  v50 = v71;
  if (v71 != v73)
    goto LABEL_55;
}

uint64_t mlir::function_interface_impl::parseFunctionSignature(char *a1, char a2, uint64_t a3, _BYTE *a4, uint64_t a5, uint64_t a6)
{
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char v17;

  v17 = a2;
  *a4 = 0;
  v13 = a4;
  v14 = (uint64_t)a1;
  v15 = &v17;
  v16 = a3;
  if (!(*(unsigned __int8 (**)(char *, uint64_t, uint64_t (*)(uint64_t), _BYTE **, _QWORD, _QWORD))(*(_QWORD *)a1 + 360))(a1, 1, llvm::function_ref<mlir::ParseResult ()(void)>::callback_fn<parseFunctionArgumentList(mlir::OpAsmParser &,BOOL,llvm::SmallVectorImpl<mlir::OpAsmParser::Argument> &,BOOL &)::$_0>, &v13, 0, 0))return 0;
  if (!(*(unsigned __int8 (**)(char *))(*(_QWORD *)a1 + 64))(a1))
    return 1;
  if ((*(unsigned __int8 (**)(char *))(*(_QWORD *)a1 + 272))(a1))
  {
    if ((*(unsigned __int8 (**)(char *))(*(_QWORD *)a1 + 288))(a1))
      return 1;
    v13 = (_BYTE *)a5;
    v14 = a6;
    v15 = a1;
    if ((*(unsigned __int8 (**)(char *, _QWORD, uint64_t (*)(uint64_t *), _BYTE **, _QWORD, _QWORD))(*(_QWORD *)a1 + 360))(a1, 0, llvm::function_ref<mlir::ParseResult ()(void)>::callback_fn<parseFunctionResultList(mlir::OpAsmParser &,llvm::SmallVectorImpl<mlir::Type> &,llvm::SmallVectorImpl<mlir::DictionaryAttr> &)::$_0>, &v13, 0, 0))
    {
      return (*(uint64_t (**)(char *))(*(_QWORD *)a1 + 280))(a1);
    }
    return 0;
  }
  v13 = 0;
  if (!(*(unsigned __int8 (**)(char *, _BYTE **))(*(_QWORD *)a1 + 504))(a1, &v13))
    return 0;
  v10 = v13;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  v12 = *(unsigned int *)(a6 + 8);
  if (v12 >= *(_DWORD *)(a6 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a6, (void *)(a6 + 16), v12 + 1, 8);
    *(_QWORD *)(*(_QWORD *)a6 + 8 * *(unsigned int *)(a6 + 8)) = 0;
    LODWORD(v12) = *(_DWORD *)(a6 + 8);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)a6 + 8 * v12) = 0;
  }
  *(_DWORD *)(a6 + 8) = v12 + 1;
  return 1;
}

void mlir::function_interface_impl::addArgAndResultAttrs(mlir::DictionaryAttr **a1, uint64_t a2, uint64_t *a3, uint64_t a4, void **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  void **v17;
  uint64_t v18;
  uint64_t DictionaryAttr;
  uint64_t ArrayAttr;
  uint64_t v21;
  uint64_t v22;
  void **i;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  _QWORD v29[7];

  v29[6] = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v14 = a3;
    v15 = 8 * a4;
    v16 = 8 * a4;
    v17 = (void **)a3;
    while (1)
    {
      v27 = *v17;
      if (v27)
      {
        if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v27))
          break;
      }
      ++v17;
      v16 -= 8;
      if (!v16)
        goto LABEL_15;
    }
    LODWORD(v18) = 0;
    v27 = v29;
    v28 = 0x600000000;
    do
    {
      DictionaryAttr = *v14;
      if (!*v14)
      {
        DictionaryAttr = mlir::Builder::getDictionaryAttr(a1, 0, 0);
        LODWORD(v18) = v28;
      }
      if (v18 >= HIDWORD(v28))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v27, v29, v18 + 1, 8);
        LODWORD(v18) = v28;
      }
      *((_QWORD *)v27 + v18) = DictionaryAttr;
      v18 = (v28 + 1);
      LODWORD(v28) = v28 + 1;
      ++v14;
      v15 -= 8;
    }
    while (v15);
    ArrayAttr = mlir::Builder::getArrayAttr(a1, (uint64_t)v27, v18);
    if (v27 != v29)
      free(v27);
    mlir::NamedAttribute::NamedAttribute(&v27, a7, ArrayAttr);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)v27, v28);
  }
LABEL_15:
  if (a6)
  {
    v21 = 8 * a6;
    v22 = 8 * a6;
    for (i = a5; ; ++i)
    {
      v27 = *i;
      if (v27)
      {
        if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v27))
          break;
      }
      v22 -= 8;
      if (!v22)
        return;
    }
    LODWORD(v24) = 0;
    v27 = v29;
    v28 = 0x600000000;
    do
    {
      v25 = (uint64_t)*a5;
      if (!*a5)
      {
        v25 = mlir::Builder::getDictionaryAttr(a1, 0, 0);
        LODWORD(v24) = v28;
      }
      if (v24 >= HIDWORD(v28))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v27, v29, v24 + 1, 8);
        LODWORD(v24) = v28;
      }
      *((_QWORD *)v27 + v24) = v25;
      v24 = (v28 + 1);
      LODWORD(v28) = v28 + 1;
      ++a5;
      v21 -= 8;
    }
    while (v21);
    v26 = mlir::Builder::getArrayAttr(a1, (uint64_t)v27, v24);
    if (v27 != v29)
      free(v27);
    mlir::NamedAttribute::NamedAttribute(&v27, a8, v26);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)v27, v28);
  }
}

uint64_t mlir::function_interface_impl::parseFunctionOp(mlir::AsmParser *a1, uint64_t a2, char a3, uint64_t a4, uint64_t (*a5)(uint64_t, mlir::DictionaryAttr **, void *, _QWORD, void *, _QWORD, _QWORD, void **), uint64_t a6, uint64_t a7, uint64_t a8)
{
  mlir::DictionaryAttr **v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  size_t v26;
  const char *v27;
  uint64_t v28;
  const void ***v29;
  char *v30;
  char *v31;
  __int128 v32;
  _QWORD **v33;
  _QWORD **v34;
  void *v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  void *v39;
  void *v40;
  void **p_src;
  char *v42;
  char *v43;
  __int128 v44;
  uint64_t v45;
  const char *v46;
  _QWORD *v47;
  uint64_t v48;
  _QWORD **v49;
  _QWORD **v50;
  void *v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v59;
  uint64_t v60;
  uint64_t v61;
  void **v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  uint64_t *v68;
  _QWORD *v69;
  uint64_t v70;
  unsigned __int16 v71;
  unint64_t v72;
  unint64_t v73;
  int64_t v74;
  int64_t v75;
  const char *AttrData;
  const char *v79[4];
  __int16 v80;
  void *v81;
  uint64_t v82;
  uint64_t v83;
  unsigned __int8 v84;
  uint64_t v85;
  uint64_t v86;
  const void **v87;
  const char *v88;
  uint64_t v89;
  __int16 v90;
  void *__src;
  uint64_t v92;
  _QWORD v93[2];
  __int16 v94;
  uint64_t v95;
  void *v96;
  uint64_t v97;
  uint64_t v98;
  void *v99;
  unsigned int v100;
  unsigned int v101;
  _BYTE v102[96];
  void *v103;
  _QWORD *v104;
  void *__p;
  _QWORD **v106;
  char v107;
  void *v108;
  uint64_t v109;
  _BYTE v110[48];
  void *v111;
  uint64_t v112;
  _BYTE v113[48];
  void **v114;
  uint64_t v115;
  _BYTE v116[48];
  char *v117;
  uint64_t v118;
  _QWORD v119[10];

  v119[8] = *MEMORY[0x1E0C80C00];
  v86 = a4;
  v117 = (char *)v119;
  v118 = 0x100000000;
  v114 = (void **)v116;
  v115 = 0x600000000;
  v111 = v113;
  v112 = 0x600000000;
  v13 = (mlir::DictionaryAttr **)(*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 32))(a1);
  mlir::impl::parseOptionalVisibilityKeyword((uint64_t)a1, a2 + 112);
  v85 = 0;
  if (!mlir::AsmParser::parseSymbolName(a1, (mlir::StringAttr *)&v85))
  {
    v17 = 0;
    goto LABEL_77;
  }
  mlir::NamedAttrList::append(a2 + 112, (uint64_t)"sym_name", 8, v85);
  v14 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v84 = 0;
  if (!mlir::function_interface_impl::parseFunctionSignature((char *)a1, a3, (uint64_t)&v117, &v84, (uint64_t)&v111, (uint64_t)&v114))
  {
    v17 = 0;
    goto LABEL_77;
  }
  v81 = 0;
  v82 = 0;
  v83 = 0;
  v108 = v110;
  v109 = 0x600000000;
  v15 = v118;
  if (v118 < 7)
  {
    v16 = 0;
    if (!(_DWORD)v118)
      goto LABEL_13;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v110, v118, 8);
    v15 = v118;
    v16 = v109;
    if (!(_DWORD)v118)
      goto LABEL_13;
  }
  v18 = (unint64_t)v15 << 6;
  v19 = (uint64_t *)(v117 + 32);
  do
  {
    v20 = *v19;
    if (v16 >= HIDWORD(v109))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v110, v16 + 1, 8);
      v16 = v109;
    }
    *((_QWORD *)v108 + v16) = v20;
    v16 = v109 + 1;
    LODWORD(v109) = v109 + 1;
    v19 += 8;
    v18 -= 64;
  }
  while (v18);
LABEL_13:
  v21 = a5(a6, v13, v108, v16, v111, v112, v84, &v81);
  if (!v21)
  {
    v90 = 257;
    (*(void (**)(void **__return_ptr, mlir::AsmParser *, uint64_t, const void ***))(*(_QWORD *)a1 + 24))(&v96, a1, v14, &v87);
    if (v96)
    {
      LODWORD(__src) = 3;
      v92 = (uint64_t)"failed to construct function type";
      v93[0] = 33;
      p_src = &__src;
      v42 = (char *)v99;
      if (v100 >= v101)
      {
        v72 = v100 + 1;
        if (v99 <= &__src && (char *)v99 + 24 * v100 > (char *)&__src)
        {
          v74 = (char *)&__src - (_BYTE *)v99;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v72, 24);
          v42 = (char *)v99;
          p_src = (void **)((char *)v99 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v72, 24);
          p_src = &__src;
          v42 = (char *)v99;
        }
      }
      v43 = &v42[24 * v100];
      v44 = *(_OWORD *)p_src;
      *((_QWORD *)v43 + 2) = p_src[2];
      *(_OWORD *)v43 = v44;
      ++v100;
    }
    v45 = HIBYTE(v83);
    if (v83 < 0)
      v45 = v82;
    if (v45)
      v46 = ": ";
    else
      v46 = "";
    v79[0] = v46;
    v47 = (_QWORD *)mlir::InFlightDiagnostic::append<char const*&>((uint64_t)&v96, v79);
    v48 = (uint64_t)v47;
    if (*v47)
    {
      v94 = 260;
      __src = &v81;
      mlir::Diagnostic::operator<<((uint64_t)(v47 + 1), (const void ***)&__src);
    }
    v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v48);
    if (v96)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v96);
    if (!v107)
      goto LABEL_73;
    v49 = (_QWORD **)__p;
    if (__p)
    {
      v50 = v106;
      v51 = __p;
      if (v106 != __p)
      {
        do
          v50 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v50 - 1);
        while (v50 != v49);
        v51 = __p;
      }
      v106 = v49;
      operator delete(v51);
    }
    v52 = v103;
    if (v103)
    {
      v53 = v104;
      v54 = v103;
      if (v104 != v103)
      {
        do
        {
          v56 = (void *)*--v53;
          v55 = v56;
          *v53 = 0;
          if (v56)
            operator delete[](v55);
        }
        while (v53 != v52);
        v54 = v103;
      }
      v104 = v52;
      operator delete(v54);
    }
    v57 = v99;
    if (v99 == v102)
      goto LABEL_73;
    goto LABEL_72;
  }
  v22 = v86;
  v23 = mlir::TypeAttr::get(v21);
  mlir::NamedAttribute::NamedAttribute(&v96, v22, v23);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)v96, v97);
  __src = v93;
  v92 = 0x400000000;
  v95 = 4;
  v24 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *, void **))(*(_QWORD *)a1 + 464))(a1, &__src))
  {
    v17 = 0;
    v57 = __src;
    if (__src == v93)
      goto LABEL_73;
    goto LABEL_72;
  }
  AttrData = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v86);
  v26 = v25;
  v27 = "sym_visibility";
  v28 = 14;
  if (mlir::NamedAttrList::get((uint64_t)&__src, "sym_visibility", 0xEuLL))
    goto LABEL_19;
  v27 = "sym_name";
  v28 = 8;
  if (mlir::NamedAttrList::get((uint64_t)&__src, "sym_name", 8uLL))
    goto LABEL_19;
  v27 = AttrData;
  if (mlir::NamedAttrList::get((uint64_t)&__src, AttrData, v26))
  {
    v28 = v26;
LABEL_19:
    v79[0] = "'";
    v80 = 259;
    (*(void (**)(void **__return_ptr, mlir::AsmParser *, uint64_t, const char **))(*(_QWORD *)a1 + 24))(&v96, a1, v24, v79);
    if (v96)
    {
      v90 = 261;
      v87 = (const void **)v27;
      v88 = (const char *)v28;
      mlir::Diagnostic::operator<<((uint64_t)&v97, &v87);
      if (v96)
      {
        LODWORD(v87) = 3;
        v88 = "' is an inferred attribute and should not be specified in the explicit attribute dictionary";
        v89 = 91;
        v29 = &v87;
        v30 = (char *)v99;
        if (v100 >= v101)
        {
          v73 = v100 + 1;
          if (v99 <= &v87 && (char *)v99 + 24 * v100 > (char *)&v87)
          {
            v75 = (char *)&v87 - (_BYTE *)v99;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v73, 24);
            v30 = (char *)v99;
            v29 = (const void ***)((char *)v99 + v75);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v73, 24);
            v29 = &v87;
            v30 = (char *)v99;
          }
        }
        v31 = &v30[24 * v100];
        v32 = *(_OWORD *)v29;
        *((_QWORD *)v31 + 2) = v29[2];
        *(_OWORD *)v31 = v32;
        ++v100;
      }
    }
    v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v96);
    if (v96)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v96);
    if (v107)
    {
      v33 = (_QWORD **)__p;
      if (__p)
      {
        v34 = v106;
        v35 = __p;
        if (v106 != __p)
        {
          do
            v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
          while (v34 != v33);
          v35 = __p;
        }
        v106 = v33;
        operator delete(v35);
      }
      v36 = v103;
      if (v103)
      {
        v37 = v104;
        v38 = v103;
        if (v104 != v103)
        {
          do
          {
            v40 = (void *)*--v37;
            v39 = v40;
            *v37 = 0;
            if (v40)
              operator delete[](v39);
          }
          while (v37 != v36);
          v38 = v103;
        }
        v104 = v36;
        operator delete(v38);
      }
      if (v99 != v102)
        free(v99);
    }
    goto LABEL_71;
  }
  v59 = __src;
  v60 = v92;
  *(_QWORD *)(a2 + 192) = 0;
  v61 = *(unsigned int *)(a2 + 120);
  if (v61 + v60 > (unint64_t)*(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), v61 + v60, 16);
    LODWORD(v61) = *(_DWORD *)(a2 + 120);
  }
  if ((_DWORD)v60)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 112) + 16 * v61), v59, 16 * v60);
    LODWORD(v61) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v61 + v60;
  v62 = v114;
  v63 = v115;
  v96 = &v98;
  v97 = 0x600000000;
  if ((_DWORD)v118)
  {
    LODWORD(v64) = 0;
    v65 = (unint64_t)v118 << 6;
    v66 = (uint64_t *)(v117 + 40);
    do
    {
      v67 = *v66;
      if (v64 >= HIDWORD(v97))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, &v98, v64 + 1, 8);
        LODWORD(v64) = v97;
      }
      *((_QWORD *)v96 + v64) = v67;
      v64 = (v97 + 1);
      LODWORD(v97) = v97 + 1;
      v66 += 8;
      v65 -= 64;
    }
    while (v65);
    v68 = (uint64_t *)v96;
  }
  else
  {
    v64 = 0;
    v68 = &v98;
  }
  mlir::function_interface_impl::addArgAndResultAttrs(v13, a2, v68, v64, v62, v63, a7, a8);
  if (v96 != &v98)
    free(v96);
  v69 = (_QWORD *)mlir::OperationState::addRegion((mlir::OperationState *)a2);
  v70 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v71 = (*(uint64_t (**)(mlir::AsmParser *, _QWORD *, char *, _QWORD, _QWORD))(*(_QWORD *)a1 + 752))(a1, v69, v117, v118, 0);
  if (v71 < 0x100u)
    goto LABEL_100;
  if (!(_BYTE)v71)
  {
    v17 = 0;
    goto LABEL_71;
  }
  if ((_QWORD *)*v69 != v69)
  {
LABEL_100:
    v17 = 1;
    goto LABEL_71;
  }
  v87 = (const void **)"expected non-empty function body";
  v90 = 259;
  (*(void (**)(void **__return_ptr, mlir::AsmParser *, uint64_t, const void ***))(*(_QWORD *)a1 + 24))(&v96, a1, v70, &v87);
  v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v96);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v96);
LABEL_71:
  v57 = __src;
  if (__src != v93)
LABEL_72:
    free(v57);
LABEL_73:
  if (v108 != v110)
    free(v108);
  if (SHIBYTE(v83) < 0)
    operator delete(v81);
LABEL_77:
  if (v111 != v113)
    free(v111);
  if (v114 != (void **)v116)
    free(v114);
  if (v117 != (char *)v119)
    free(v117);
  return v17;
}

llvm::raw_ostream *mlir::function_interface_impl::printFunctionSignature(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5, char a6, _QWORD *a7, unint64_t a8)
{
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  llvm::raw_ostream *v17;
  _BYTE *v18;
  uint64_t ArgAttrsAttr;
  uint64_t v20;
  uint64_t Value;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t i;
  llvm::raw_ostream *v27;
  _WORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  llvm::raw_ostream *v33;
  _WORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  llvm::raw_ostream *v41;
  _WORD *v42;
  llvm::raw_ostream *v43;
  uint64_t v44;
  llvm::raw_ostream *result;
  _BYTE *v46;
  llvm::raw_ostream *v47;
  _DWORD *v48;
  uint64_t ResAttrsAttr;
  llvm::raw_ostream *v50;
  _BYTE *v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  _BYTE *v55;
  uint64_t v56;
  _WORD *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD v61[2];
  uint64_t v62;
  uint64_t v63;

  v61[0] = a2;
  v61[1] = a3;
  v14 = *(unsigned int *)(a2 + 44);
  if ((v14 & 0x7FFFFF) != 0)
    v15 = (_QWORD *)(((a2 + 16 * ((v14 >> 23) & 1) + ((v14 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                   + 32 * *(unsigned int *)(a2 + 40));
  else
    v15 = 0;
  v16 = (_QWORD *)*v15;
  v17 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v18 = (_BYTE *)*((_QWORD *)v17 + 4);
  if ((unint64_t)v18 >= *((_QWORD *)v17 + 3))
  {
    llvm::raw_ostream::write(v17, 40);
    ArgAttrsAttr = mlir::FunctionOpInterface::getArgAttrsAttr((mlir::FunctionOpInterface *)v61);
    v60 = ArgAttrsAttr;
    v20 = a5;
    if (!(_DWORD)a5)
      goto LABEL_26;
  }
  else
  {
    *((_QWORD *)v17 + 4) = v18 + 1;
    *v18 = 40;
    ArgAttrsAttr = mlir::FunctionOpInterface::getArgAttrsAttr((mlir::FunctionOpInterface *)v61);
    v60 = ArgAttrsAttr;
    v20 = a5;
    if (!(_DWORD)a5)
      goto LABEL_26;
  }
  if (v16 != v15)
  {
    if (ArgAttrsAttr)
    {
      v63 = *(_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60);
      Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v63);
      v23 = v22;
    }
    else
    {
      v23 = 0;
      Value = 0;
    }
    v31 = v15[1];
    if (v31)
      v32 = v31 - 8;
    else
      v32 = 0;
    (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 152))(a1, **(_QWORD **)(v32 + 48), Value, v23, 0);
    if (v20 == 1)
      goto LABEL_26;
    v35 = 1;
    while (1)
    {
      v41 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
      v42 = (_WORD *)*((_QWORD *)v41 + 4);
      if (*((_QWORD *)v41 + 3) - (_QWORD)v42 > 1uLL)
      {
        *v42 = 8236;
        *((_QWORD *)v41 + 4) += 2;
        if (!v60)
          goto LABEL_39;
      }
      else
      {
        llvm::raw_ostream::write(v41, ", ", 2uLL);
        if (!v60)
        {
LABEL_39:
          v38 = 0;
          v36 = 0;
          goto LABEL_33;
        }
      }
      v63 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60) + 8 * v35);
      v36 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v63);
      v38 = v37;
LABEL_33:
      v39 = v15[1];
      if (v39)
        v40 = v39 - 8;
      else
        v40 = 0;
      (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 152))(a1, *(_QWORD *)(*(_QWORD *)(v40 + 48) + 8 * v35++), v36, v38, 0);
      if (v20 == v35)
        goto LABEL_26;
    }
  }
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 32))(a1, *a4);
  if (v60)
  {
    v63 = *(_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60);
    v24 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v63);
    (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a1 + 192))(a1, v24, v25, 0, 0);
  }
  if (v20 != 1)
  {
    for (i = 1; i != v20; ++i)
    {
      v27 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
      v28 = (_WORD *)*((_QWORD *)v27 + 4);
      if (*((_QWORD *)v27 + 3) - (_QWORD)v28 >= 2uLL)
      {
        *v28 = 8236;
        *((_QWORD *)v27 + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(v27, ", ", 2uLL);
      }
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 32))(a1, a4[i]);
      if (v60)
      {
        v63 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60) + 8 * i);
        v29 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v63);
        (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a1 + 192))(a1, v29, v30, 0, 0);
      }
    }
  }
LABEL_26:
  if ((a6 & 1) != 0)
  {
    if (a5)
    {
      v33 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
      v34 = (_WORD *)*((_QWORD *)v33 + 4);
      if (*((_QWORD *)v33 + 3) - (_QWORD)v34 > 1uLL)
      {
        *v34 = 8236;
        *((_QWORD *)v33 + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(v33, ", ", 2uLL);
      }
    }
    v43 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v44 = *((_QWORD *)v43 + 4);
    if ((unint64_t)(*((_QWORD *)v43 + 3) - v44) > 2)
    {
      *(_BYTE *)(v44 + 2) = 46;
      *(_WORD *)v44 = 11822;
      *((_QWORD *)v43 + 4) += 3;
    }
    else
    {
      llvm::raw_ostream::write(v43, "...", 3uLL);
    }
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v46 = (_BYTE *)*((_QWORD *)result + 4);
  if ((unint64_t)v46 >= *((_QWORD *)result + 3))
  {
    result = llvm::raw_ostream::write(result, 41);
    if (!a8)
      return result;
  }
  else
  {
    *((_QWORD *)result + 4) = v46 + 1;
    *v46 = 41;
    if (!a8)
      return result;
  }
  v47 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v48 = (_DWORD *)*((_QWORD *)v47 + 4);
  if (*((_QWORD *)v47 + 3) - (_QWORD)v48 > 3uLL)
  {
    *v48 = 540945696;
    *((_QWORD *)v47 + 4) += 4;
  }
  else
  {
    llvm::raw_ostream::write(v47, " -> ", 4uLL);
  }
  ResAttrsAttr = mlir::FunctionOpInterface::getResAttrsAttr((mlir::FunctionOpInterface *)v61);
  v62 = ResAttrsAttr;
  v50 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (a8 > 1
    || *(_UNKNOWN **)(*(_QWORD *)*a7 + 136) == &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id
    || ResAttrsAttr
    && (v63 = *(_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62),
        mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v63)))
  {
    v51 = (_BYTE *)*((_QWORD *)v50 + 4);
    if ((unint64_t)v51 >= *((_QWORD *)v50 + 3))
    {
      llvm::raw_ostream::write(v50, 40);
    }
    else
    {
      *((_QWORD *)v50 + 4) = v51 + 1;
      *v51 = 40;
    }
    v52 = 1;
  }
  else
  {
    v52 = 0;
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 32))(a1, *a7);
  if (v62)
  {
    v63 = *(_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62);
    v53 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v63);
    result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a1 + 192))(a1, v53, v54, 0, 0);
  }
  if (a8 != 1)
  {
    v56 = 1;
    do
    {
      v57 = (_WORD *)*((_QWORD *)v50 + 4);
      if (*((_QWORD *)v50 + 3) - (_QWORD)v57 > 1uLL)
      {
        *v57 = 8236;
        *((_QWORD *)v50 + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(v50, ", ", 2uLL);
      }
      result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 32))(a1, a7[v56]);
      if (v62)
      {
        v63 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62) + 8 * v56);
        v58 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v63);
        result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a1 + 192))(a1, v58, v59, 0, 0);
      }
      ++v56;
    }
    while (a8 != v56);
  }
  if (v52)
  {
    v55 = (_BYTE *)*((_QWORD *)v50 + 4);
    if ((unint64_t)v55 >= *((_QWORD *)v50 + 3))
    {
      return llvm::raw_ostream::write(v50, 41);
    }
    else
    {
      *((_QWORD *)v50 + 4) = v55 + 1;
      *v55 = 41;
    }
  }
  return result;
}

void mlir::function_interface_impl::printFunctionAttributes(uint64_t a1, _BYTE *a2, const void *a3, uint64_t a4)
{
  unint64_t v8;
  unsigned int v9;
  size_t v10;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v13;
  unint64_t AttrDictionary;
  void *v15;
  uint64_t v16;
  _QWORD v17[17];

  v17[16] = *MEMORY[0x1E0C80C00];
  v15 = v17;
  v17[0] = "sym_name";
  v17[1] = 8;
  v16 = 0x800000001;
  v8 = ((16 * a4) >> 4) + 1;
  if (v8 < 9)
  {
    v9 = 1;
    v10 = 16 * a4;
    if (!a4)
      goto LABEL_6;
    goto LABEL_5;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v15, v17, v8, 16);
  v9 = v16;
  v10 = 16 * a4;
  if (a4)
  {
LABEL_5:
    memcpy((char *)v15 + 16 * v9, a3, v10);
    v9 = v16;
  }
LABEL_6:
  LODWORD(v16) = v9 + (v10 >> 4);
  if (a2[47])
  {
    AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::ArrayAttr *)(a2 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a1 + 200))(a1, Value, v13, v15, v16);
  if (v15 != v17)
    free(v15);
}

void mlir::function_interface_impl::printFunctionOp(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t InherentAttr;
  char v14;
  uint64_t v15;
  uint64_t AttrData;
  uint64_t v17;
  uint64_t v18;
  llvm::raw_ostream *v19;
  _BYTE *v20;
  uint64_t v21;
  char v22;
  void *v23;
  BOOL v24;
  uint64_t v25;
  const void *v26;
  size_t v27;
  size_t v28;
  llvm::raw_ostream *v29;
  void *v30;
  llvm::raw_ostream *v31;
  _BYTE *v32;
  _QWORD *ArgumentTypes;
  uint64_t v34;
  uint64_t v35;
  _QWORD *ResultTypes;
  unint64_t v37;
  _BYTE *v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  _QWORD *v42;
  llvm::raw_ostream *v43;
  _BYTE *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD v49[9];

  v49[8] = *MEMORY[0x1E0C80C00];
  v47 = a2;
  v48 = a3;
  v45 = a8;
  v46 = a7;
  if (*(_BYTE *)(a2 + 47))
  {
    InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"sym_name", 8);
    if (v14)
    {
      if (InherentAttr)
        goto LABEL_4;
LABEL_8:
      v15 = 0;
      goto LABEL_9;
    }
  }
  InherentAttr = mlir::DictionaryAttr::get(a2 + 56, "sym_name", 8uLL);
  if (!InherentAttr)
    goto LABEL_8;
LABEL_4:
  if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    v15 = InherentAttr;
  else
    v15 = 0;
LABEL_9:
  v49[0] = v15;
  AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  v18 = v17;
  v19 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v20 = (_BYTE *)*((_QWORD *)v19 + 4);
  if ((unint64_t)v20 >= *((_QWORD *)v19 + 3))
  {
    llvm::raw_ostream::write(v19, 32);
    if (!*(_BYTE *)(a2 + 47))
    {
LABEL_14:
      v21 = mlir::DictionaryAttr::get(a2 + 56, "sym_visibility", 0xEuLL);
      goto LABEL_15;
    }
  }
  else
  {
    *((_QWORD *)v19 + 4) = v20 + 1;
    *v20 = 32;
    if (!*(_BYTE *)(a2 + 47))
      goto LABEL_14;
  }
  v21 = mlir::Operation::getInherentAttr(a2, (uint64_t)"sym_visibility", 14);
  if (!v22)
    goto LABEL_14;
LABEL_15:
  if (v21)
  {
    v23 = *(void **)(*(_QWORD *)v21 + 136);
    v24 = v23 == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id;
    v25 = v23 == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id ? v21 : 0;
    v49[0] = v25;
    if (v24)
    {
      v26 = (const void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
      v28 = v27;
      v29 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
      v30 = (void *)*((_QWORD *)v29 + 4);
      if (v28 <= *((_QWORD *)v29 + 3) - (_QWORD)v30)
      {
        if (v28)
        {
          memcpy(v30, v26, v28);
          *((_QWORD *)v29 + 4) += v28;
        }
      }
      else
      {
        llvm::raw_ostream::write(v29, (const char *)v26, v28);
      }
      v31 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
      v32 = (_BYTE *)*((_QWORD *)v31 + 4);
      if ((unint64_t)v32 >= *((_QWORD *)v31 + 3))
      {
        llvm::raw_ostream::write(v31, 32);
      }
      else
      {
        *((_QWORD *)v31 + 4) = v32 + 1;
        *v32 = 32;
      }
    }
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 72))(a1, AttrData, v18);
  ArgumentTypes = (_QWORD *)mlir::FunctionOpInterface::getArgumentTypes((mlir::FunctionOpInterface *)&v47);
  v35 = v34;
  ResultTypes = (_QWORD *)mlir::FunctionOpInterface::getResultTypes((mlir::FunctionOpInterface *)&v47);
  mlir::function_interface_impl::printFunctionSignature(a1, v47, v48, ArgumentTypes, v35, a4, ResultTypes, v37);
  v38 = (_BYTE *)v47;
  v49[0] = "sym_visibility";
  v49[1] = 14;
  v49[2] = a5;
  v49[3] = a6;
  v49[4] = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v46);
  v49[5] = v39;
  v49[6] = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v45);
  v49[7] = v40;
  mlir::function_interface_impl::printFunctionAttributes(a1, v38, v49, 4);
  v41 = *(unsigned int *)(v47 + 44);
  if ((v41 & 0x7FFFFF) != 0)
  {
    v42 = (_QWORD *)(((v47 + 16 * ((v41 >> 23) & 1) + ((v41 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                   + 32 * *(unsigned int *)(v47 + 40));
    if ((_QWORD *)*v42 == v42)
      return;
  }
  else
  {
    v42 = 0;
    if (!MEMORY[0])
      return;
  }
  v43 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v44 = (_BYTE *)*((_QWORD *)v43 + 4);
  if ((unint64_t)v44 >= *((_QWORD *)v43 + 3))
  {
    llvm::raw_ostream::write(v43, 32);
  }
  else
  {
    *((_QWORD *)v43 + 4) = v44 + 1;
    *v44 = 32;
  }
  (*(void (**)(uint64_t, _QWORD *, _QWORD, uint64_t, _QWORD))(*(_QWORD *)a1 + 224))(a1, v42, 0, 1, 0);
}

uint64_t llvm::function_ref<mlir::ParseResult ()(void)>::callback_fn<parseFunctionArgumentList(mlir::OpAsmParser &,BOOL,llvm::SmallVectorImpl<mlir::OpAsmParser::Argument> &,BOOL &)::$_0>(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD **v5;
  _QWORD **v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  void *v11;
  void *v12;
  _BYTE *v13;
  unsigned __int16 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD **v20;
  _QWORD **v21;
  void *v22;
  _QWORD *v23;
  void *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD **v29;
  _QWORD **v30;
  void *v31;
  _QWORD *v32;
  void *v33;
  void *v34;
  mlir::MLIRContext *Context;
  unint64_t v36;
  char *v37;
  _OWORD *v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  unint64_t *v43;
  unint64_t v44;
  BOOL v45;
  char *v46;
  _QWORD v47[4];
  __int16 v48;
  _QWORD v49[4];
  uint64_t v50;
  unint64_t Dictionary;
  _BYTE v52[16];
  void *v53[2];
  uint64_t v54;
  void *v55;
  _QWORD v56[12];
  void *v57;
  _QWORD *v58;
  void *__p;
  _QWORD **v60;
  char v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  if (**(_BYTE **)a1)
  {
    v2 = *(_QWORD *)(a1 + 8);
    v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    v49[0] = "variadic arguments must be in the end of the argument list";
    LOWORD(v50) = 259;
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v2 + 24))(v53, v2, v3, v49);
    v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v53);
    if (v53[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v53);
    if (v61)
    {
      v5 = (_QWORD **)__p;
      if (__p)
      {
        v6 = v60;
        v7 = __p;
        if (v60 != __p)
        {
          do
            v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
          while (v6 != v5);
          v7 = __p;
        }
        v60 = v5;
        operator delete(v7);
      }
      v8 = v57;
      if (!v57)
        goto LABEL_55;
      v9 = v58;
      v10 = v57;
      if (v58 == v57)
      {
LABEL_54:
        v58 = v8;
        operator delete(v10);
LABEL_55:
        if (v55 != v56)
          free(v55);
        return v4;
      }
      do
      {
        v12 = (void *)*--v9;
        v11 = v12;
        *v9 = 0;
        if (v12)
          operator delete[](v11);
      }
      while (v9 != v8);
LABEL_53:
      v10 = v57;
      goto LABEL_54;
    }
    return v4;
  }
  if (**(_BYTE **)(a1 + 16)
    && (*(unsigned __int8 (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 336))(*(_QWORD *)(a1 + 8)))
  {
    v13 = *(_BYTE **)a1;
    v4 = 1;
    *v13 = 1;
    return v4;
  }
  memset(v49, 0, 24);
  v52[8] = 0;
  v50 = 0;
  Dictionary = 0;
  v52[0] = 0;
  v14 = (*(uint64_t (**)(_QWORD, _QWORD *, uint64_t, uint64_t))(**(_QWORD **)(a1 + 8) + 728))(*(_QWORD *)(a1 + 8), v49, 1, 1);
  if (v14 >= 0x100u)
  {
    if ((_BYTE)v14)
    {
      v26 = *(_QWORD *)(a1 + 24);
      v27 = *(unsigned int *)(v26 + 8);
      if ((_DWORD)v27 && !*(_QWORD *)(*(_QWORD *)v26 + (v27 << 6) - 48))
      {
        v28 = *(_QWORD *)(a1 + 8);
        v47[0] = "expected type instead of SSA identifier";
        v48 = 259;
        (*(void (**)(void **__return_ptr, uint64_t, _QWORD, _QWORD *))(*(_QWORD *)v28 + 24))(v53, v28, v49[0], v47);
        v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v53);
        if (v53[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v53);
        if (v61)
        {
          v29 = (_QWORD **)__p;
          if (__p)
          {
            v30 = v60;
            v31 = __p;
            if (v60 != __p)
            {
              do
                v30 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v30 - 1);
              while (v30 != v29);
              v31 = __p;
            }
            v60 = v29;
            operator delete(v31);
          }
          v8 = v57;
          if (!v57)
            goto LABEL_55;
          v32 = v58;
          v10 = v57;
          if (v58 == v57)
            goto LABEL_54;
          do
          {
            v34 = (void *)*--v32;
            v33 = v34;
            *v32 = 0;
            if (v34)
              operator delete[](v33);
          }
          while (v32 != v8);
          goto LABEL_53;
        }
        return v4;
      }
LABEL_63:
      v36 = *(_QWORD *)v26;
      v37 = (char *)v49;
      if (v27 >= *(_DWORD *)(v26 + 12))
      {
        v43 = (unint64_t *)v26;
        v44 = v27 + 1;
        v45 = v36 + ((unint64_t)v27 << 6) > (unint64_t)v49;
        if (v36 <= (unint64_t)v49 && v45)
        {
          v46 = (char *)v49 - v36;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v26, (void *)(v26 + 16), v44, 64);
          v26 = (uint64_t)v43;
          v36 = *v43;
          v37 = &v46[*v43];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v26, (void *)(v26 + 16), v44, 64);
          v26 = (uint64_t)v43;
          v36 = *v43;
          v37 = (char *)v49;
        }
      }
      v38 = (_OWORD *)(v36 + ((unint64_t)*(unsigned int *)(v26 + 8) << 6));
      v39 = *(_OWORD *)v37;
      v40 = *((_OWORD *)v37 + 1);
      v41 = *((_OWORD *)v37 + 3);
      v38[2] = *((_OWORD *)v37 + 2);
      v38[3] = v41;
      *v38 = v39;
      v38[1] = v40;
      ++*(_DWORD *)(v26 + 8);
      return 1;
    }
    return 0;
  }
  v15 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 40))(*(_QWORD *)(a1 + 8));
  v49[0] = v15;
  v16 = *(_QWORD *)(a1 + 24);
  v17 = *(unsigned int *)(v16 + 8);
  if (!(_DWORD)v17 || !*(_QWORD *)(*(_QWORD *)v16 + (v17 << 6) - 48))
  {
    v53[0] = &v54;
    v53[1] = (void *)0x400000000;
    v56[5] = 4;
    if ((*(unsigned __int8 (**)(_QWORD, uint64_t *))(**(_QWORD **)(a1 + 8) + 504))(*(_QWORD *)(a1 + 8), &v50)&& (*(unsigned __int8 (**)(_QWORD, void **))(**(_QWORD **)(a1 + 8) + 456))(*(_QWORD *)(a1 + 8), v53)&& (*(unsigned __int8 (**)(_QWORD, _BYTE *))(**(_QWORD **)(a1 + 8) + 624))(*(_QWORD *)(a1 + 8), v52))
    {
      Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(*(mlir::AsmParser **)(a1 + 8));
      Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v53, Context);
      if (v53[0] != &v54)
        free(v53[0]);
      v26 = *(_QWORD *)(a1 + 24);
      LODWORD(v27) = *(_DWORD *)(v26 + 8);
      goto LABEL_63;
    }
    if (v53[0] != &v54)
      free(v53[0]);
    return 0;
  }
  v18 = v15;
  v19 = *(_QWORD *)(a1 + 8);
  v47[0] = "expected SSA identifier";
  v48 = 259;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v19 + 24))(v53, v19, v18, v47);
  v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v53);
  if (v53[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v53);
  if (v61)
  {
    v20 = (_QWORD **)__p;
    if (__p)
    {
      v21 = v60;
      v22 = __p;
      if (v60 != __p)
      {
        do
          v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
        while (v21 != v20);
        v22 = __p;
      }
      v60 = v20;
      operator delete(v22);
    }
    v8 = v57;
    if (!v57)
      goto LABEL_55;
    v23 = v58;
    v10 = v57;
    if (v58 == v57)
      goto LABEL_54;
    do
    {
      v25 = (void *)*--v23;
      v24 = v25;
      *v23 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v23 != v8);
    goto LABEL_53;
  }
  return v4;
}

uint64_t llvm::function_ref<mlir::ParseResult ()(void)>::callback_fn<parseFunctionResultList(mlir::OpAsmParser &,llvm::SmallVectorImpl<mlir::Type> &,llvm::SmallVectorImpl<mlir::DictionaryAttr> &)::$_0>(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  mlir::MLIRContext *Context;
  uint64_t v7;
  void *v8;
  void *v10[2];
  _QWORD v11[10];

  v11[9] = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v3 = *(unsigned int *)(*a1 + 8);
  if (v3 >= *(_DWORD *)(*a1 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(*a1, (void *)(v2 + 16), v3 + 1, 8);
    *(_QWORD *)(*(_QWORD *)v2 + 8 * (*(_DWORD *)(v2 + 8))++) = 0;
    v4 = a1[1];
    v5 = *(unsigned int *)(v4 + 8);
    if (v5 < *(_DWORD *)(v4 + 12))
      goto LABEL_3;
LABEL_12:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v4 + 16), v5 + 1, 8);
    *(_QWORD *)(*(_QWORD *)v4 + 8 * *(unsigned int *)(v4 + 8)) = 0;
    LODWORD(v5) = *(_DWORD *)(v4 + 8);
    goto LABEL_4;
  }
  *(_QWORD *)(*(_QWORD *)v2 + 8 * v3) = 0;
  *(_DWORD *)(v2 + 8) = v3 + 1;
  v4 = a1[1];
  v5 = *(unsigned int *)(v4 + 8);
  if (v5 >= *(_DWORD *)(v4 + 12))
    goto LABEL_12;
LABEL_3:
  *(_QWORD *)(*(_QWORD *)v4 + 8 * v5) = 0;
LABEL_4:
  *(_DWORD *)(v4 + 8) = v5 + 1;
  v10[0] = v11;
  v10[1] = (void *)0x400000000;
  v11[8] = 4;
  if ((*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1[2] + 504))(a1[2], *(_QWORD *)*a1 + 8 * *(unsigned int *)(*a1 + 8) - 8)&& (*(unsigned __int8 (**)(uint64_t, void **))(*(_QWORD *)a1[2] + 456))(a1[2], v10))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext((mlir::AsmParser *)a1[2]);
    *(_QWORD *)(*(_QWORD *)a1[1] + 8 * *(unsigned int *)(a1[1] + 8) - 8) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v10, Context);
    v7 = 1;
    v8 = v10[0];
    if (v10[0] == v11)
      return v7;
    goto LABEL_9;
  }
  v7 = 0;
  v8 = v10[0];
  if (v10[0] != v11)
LABEL_9:
    free(v8);
  return v7;
}

uint64_t mlir::AsmParser::parseSymbolName(mlir::AsmParser *this, mlir::StringAttr *a2)
{
  uint64_t v3;
  uint64_t v5;
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v18;
  int64_t v19;
  char v20[32];
  __int16 v21;
  int v22;
  const char *v23;
  uint64_t v24;
  _QWORD v25[3];
  void *v26;
  unsigned int v27;
  unsigned int v28;
  _BYTE v29[96];
  void *v30;
  _QWORD *v31;
  void *__p;
  _QWORD **v33;
  char v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if ((*(unsigned __int8 (**)(mlir::AsmParser *, mlir::StringAttr *))(*(_QWORD *)this + 496))(this, a2))
    return 1;
  v5 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)this + 40))(this);
  v21 = 257;
  (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, char *))(*(_QWORD *)this + 24))(v25, this, v5, v20);
  if (v25[0])
  {
    v22 = 3;
    v23 = "expected valid '@'-identifier for symbol name";
    v24 = 45;
    v6 = &v22;
    v7 = (char *)v26;
    if (v27 >= v28)
    {
      v18 = v27 + 1;
      if (v26 <= &v22 && (char *)v26 + 24 * v27 > (char *)&v22)
      {
        v19 = (char *)&v22 - (_BYTE *)v26;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v29, v18, 24);
        v7 = (char *)v26;
        v6 = (int *)((char *)v26 + v19);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v29, v18, 24);
        v6 = &v22;
        v7 = (char *)v26;
      }
    }
    v8 = &v7[24 * v27];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v27;
  }
  v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v25);
  if (v25[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v25);
  if (v34)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v33;
      v12 = __p;
      if (v33 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v33 = v10;
      operator delete(v12);
    }
    v13 = v30;
    if (v30)
    {
      v14 = v31;
      v15 = v30;
      if (v31 != v30)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v30;
      }
      v31 = v13;
      operator delete(v15);
    }
    if (v26 != v29)
      free(v26);
  }
  return v3;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  __guard *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x10uLL);
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    if ((v4 & 1) == 0)
    {
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties]";
        v15 = 106;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
      }
    }
    a1[33] = v5[467];
    return a1[32];
  }
  return result;
}

void mlir::ub::PoisonOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v9;
  uint64_t v10;

  if (a4)
  {
    v9 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v9 = a4;
    v9[1] = a5;
  }
  v10 = *(unsigned int *)(a2 + 72);
  if (v10 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v10 + 1, 8);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v10) = a3;
  ++*(_DWORD *)(a2 + 72);
}

_QWORD *llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<void mlir::StorageUniquer::registerSingletonStorageType<mlir::AttributeStorage>(mlir::TypeID,llvm::function_ref<void ()(mlir::AttributeStorage *)>)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(void (***a1)(_QWORD, _QWORD *), uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  BOOL v6;
  unsigned int v7;
  uint64_t v8;
  char *buffer;
  uint64_t v10;
  _QWORD *v11;
  void (**v12)(_QWORD, _QWORD *);
  void (*v13)(_QWORD, _QWORD *);
  _QWORD *v14;

  a2[10] += 8;
  v4 = *a2;
  v5 = ((*a2 + 7) & 0xFFFFFFFFFFFFFFF8) - *a2;
  if (*a2)
    v6 = v5 + 8 > a2[1] - *a2;
  else
    v6 = 1;
  if (v6)
  {
    v7 = *((_DWORD *)a2 + 6) >> 7;
    if (v7 >= 0x1E)
      LOBYTE(v7) = 30;
    v8 = 4096 << v7;
    buffer = (char *)llvm::allocate_buffer(4096 << v7, (std::align_val_t)8uLL);
    v10 = *((unsigned int *)a2 + 6);
    if (v10 >= *((_DWORD *)a2 + 7))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(a2 + 2), a2 + 4, v10 + 1, 8);
      LODWORD(v10) = *((_DWORD *)a2 + 6);
    }
    *(_QWORD *)(a2[2] + 8 * v10) = buffer;
    ++*((_DWORD *)a2 + 6);
    a2[1] = (uint64_t)&buffer[v8];
    v11 = (_QWORD *)((unint64_t)(buffer + 7) & 0xFFFFFFFFFFFFFFF8);
    *v11 = 0;
    *a2 = (uint64_t)(v11 + 1);
    v12 = *a1;
    v13 = **a1;
    if (v13)
      goto LABEL_13;
  }
  else
  {
    v11 = (_QWORD *)(v4 + v5);
    v14 = (_QWORD *)(v4 + v5);
    *v14 = 0;
    *a2 = (uint64_t)(v14 + 1);
    v12 = *a1;
    v13 = **a1;
    if (v13)
LABEL_13:
      v13(v12[1], v11);
  }
  return v11;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p)
    operator delete(__p);
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

uint64_t mlir::AffineExpr::getKind(mlir::AffineExpr *this)
{
  return *(unsigned int *)(*(_QWORD *)this + 8);
}

_QWORD *mlir::AffineExpr::walk(uint64_t *a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *result;
  uint64_t v7;
  _QWORD v8[3];
  _QWORD *v9;
  _BYTE v10[24];
  _BYTE *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v3 = (_QWORD *)a2[3];
  if (!v3)
  {
    v9 = 0;
    goto LABEL_5;
  }
  if (v3 != a2)
  {
    v9 = (_QWORD *)a2[3];
    a2[3] = 0;
    goto LABEL_7;
  }
  v9 = v8;
  (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v8);
  v3 = v9;
  if (!v9)
  {
LABEL_5:
    v11 = 0;
    goto LABEL_10;
  }
LABEL_7:
  if (v3 == v8)
  {
    v11 = v10;
    (*(void (**)(_QWORD *, _BYTE *))(v8[0] + 24))(v8, v10);
  }
  else
  {
    v11 = v3;
    v9 = 0;
  }
LABEL_10:
  mlir::AffineExprVisitor<mlir::AffineExpr::walk(std::function<void ()(mlir::AffineExpr)>)::AffineExprWalker,void>::walkPostOrder((uint64_t)v10, *a1);
  v4 = v11;
  if (v11 == v10)
  {
    v5 = 4;
    v4 = v10;
  }
  else
  {
    if (!v11)
      goto LABEL_15;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_15:
  result = v9;
  if (v9 == v8)
  {
    v7 = 4;
    result = v8;
  }
  else
  {
    if (!v9)
      return result;
    v7 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v7))();
}

void mlir::AffineExprVisitor<mlir::AffineExpr::walk(std::function<void ()(mlir::AffineExpr)>)::AffineExprWalker,void>::walkPostOrder(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }
}

uint64_t sub_18039F980()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  ((void (*)(uint64_t, _QWORD))mlir::AffineExprVisitor<mlir::AffineExpr::walk(std::function<void ()(mlir::AffineExpr)>)::AffineExprWalker,void>::walkPostOrder)(v1, *(_QWORD *)(v0 + 16));
  ((void (*)(uint64_t, _QWORD))mlir::AffineExprVisitor<mlir::AffineExpr::walk(std::function<void ()(mlir::AffineExpr)>)::AffineExprWalker,void>::walkPostOrder)(v1, *(_QWORD *)(v0 + 24));
  v2 = *(_QWORD *)(v1 + 24);
  v5 = v0;
  if (v2)
    return (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v2 + 48))(v2, &v5);
  v4 = std::__throw_bad_function_call[abi:nn180100]();
  return ((uint64_t (*)(uint64_t))mlir::getAffineBinaryOpExpr)(v4);
}

uint64_t mlir::getAffineBinaryOpExpr(int a1, mlir::MLIRContext **a2, uint64_t a3)
{
  uint64_t result;
  mlir::MLIRContext **v4;

  v4 = a2;
  switch(a1)
  {
    case 0:
      result = mlir::AffineExpr::operator+((unint64_t *)&v4, a3);
      break;
    case 1:
      result = mlir::AffineExpr::operator*((unint64_t *)&v4, a3);
      break;
    case 3:
      result = mlir::AffineExpr::floorDiv(&v4, a3);
      break;
    case 4:
      result = mlir::AffineExpr::ceilDiv((unint64_t *)&v4, a3);
      break;
    default:
      result = mlir::AffineExpr::operator%((unint64_t *)&v4, a3);
      break;
  }
  return result;
}

uint64_t mlir::AffineExpr::operator+(unint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  BOOL v8;
  int v10;
  char v11;
  uint64_t v12;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  mlir::MLIRContext **v19;
  mlir::MLIRContext **v20;
  unsigned __int8 **v21;
  uint64_t v22;
  unsigned __int8 **AffineUniquer;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  unsigned __int8 **v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  BOOL v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  mlir::MLIRContext *v43;
  mlir::MLIRContext **v44;

  v40 = a2;
  v41 = a2;
  v3 = *a1;
  v42 = v3;
  v4 = *(_DWORD *)(v3 + 8);
  if (v4 == 5)
    v5 = v3;
  else
    v5 = 0;
  v6 = *(_DWORD *)(a2 + 8);
  if (v6 == 5)
    v7 = a2;
  else
    v7 = 0;
  if (v5)
    v8 = v7 == 0;
  else
    v8 = 1;
  if (v8)
  {
    if (v4 == 5
      || (mlir::AffineExpr::isSymbolicOrConstant((mlir::AffineExpr *)&v42), v10)
      && (mlir::AffineExpr::isSymbolicOrConstant((mlir::AffineExpr *)&v41), (v11 & 1) == 0))
    {
      v3 = mlir::AffineExpr::operator+(&v41, v3);
      if (v3)
        return v3;
      goto LABEL_29;
    }
    if (v7)
    {
      v12 = *(_QWORD *)(v7 + 16);
      if (!v12)
        return v3;
      if (v4 <= 4 && v3 != 0)
      {
        v14 = *(_DWORD *)(v3 + 8);
        if (!v14)
        {
          v15 = *(_QWORD *)(v3 + 24);
          v16 = 1;
          v17 = 1;
          if (v15)
          {
            v18 = v3;
            v19 = (mlir::MLIRContext **)v3;
            if (*(_DWORD *)(v15 + 8) == 5)
            {
              v44 = *(mlir::MLIRContext ***)(v3 + 16);
              v3 = mlir::AffineExpr::operator+(&v44, v12 + *(_QWORD *)(v15 + 16));
              if (v3)
                return v3;
LABEL_29:
              v3 = *a1;
LABEL_30:
              AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(*(mlir::MLIRContext **)v3);
              LODWORD(v44) = 0;
              return mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(AffineUniquer, 0, 0, &v44, a1, &v40);
            }
LABEL_48:
            if (v6 >= 5)
              v27 = 0;
            else
              v27 = a2;
            if (!v27)
              goto LABEL_57;
LABEL_52:
            if (*(_DWORD *)(v27 + 8) == 1)
            {
              v28 = *(_QWORD *)(v27 + 24);
              if (v28 && *(_DWORD *)(v28 + 8) == 5)
              {
                v30 = *(_QWORD *)(v28 + 16);
                if (v19 != *(mlir::MLIRContext ***)(v27 + 16))
                  goto LABEL_58;
                goto LABEL_74;
              }
            }
LABEL_57:
            v30 = 1;
            if (v19 != (mlir::MLIRContext **)a2)
            {
LABEL_58:
              if (v17)
              {
                if (!*(_DWORD *)(v18 + 8))
                {
                  v37 = *(_QWORD *)(v18 + 24);
                  if (v37)
                  {
                    if (*(_DWORD *)(v37 + 8) == 5)
                    {
                      v43 = *(mlir::MLIRContext **)(v18 + 16);
                      v44 = (mlir::MLIRContext **)mlir::AffineExpr::operator+(&v43, a2);
                      v3 = mlir::AffineExpr::operator+(&v44, v37);
                      if (v3)
                        return v3;
                      goto LABEL_29;
                    }
                  }
                }
              }
              if (!v27)
                goto LABEL_30;
              v31 = *(_QWORD *)(v27 + 16);
              v32 = *(_QWORD *)(v27 + 24);
              v44 = (mlir::MLIRContext **)v32;
              if (*(int *)(v31 + 8) >= 5)
                v31 = 0;
              if (v32 && *(_DWORD *)(v32 + 8) == 5 && *(_QWORD *)(v32 + 16) == -1)
              {
                if (!v31)
                  goto LABEL_29;
                v33 = *(_DWORD *)(v31 + 8);
                if (v33 == 1)
                {
                  v38 = *(_QWORD *)(v31 + 16);
                  if (v38)
                    v39 = *(_DWORD *)(v38 + 8) == 3;
                  else
                    v39 = 0;
                  if (!v39)
                    goto LABEL_29;
                  v34 = *(_QWORD *)(v31 + 24);
                  if (*(_QWORD *)(v38 + 24) != v34 || v3 != *(_QWORD *)(v38 + 16))
                    goto LABEL_29;
                  goto LABEL_71;
                }
              }
              else
              {
                if (!v31)
                  goto LABEL_29;
                v33 = *(_DWORD *)(v31 + 8);
              }
              if (v33 != 3)
                goto LABEL_29;
              if (v3 != *(_QWORD *)(v31 + 16))
                goto LABEL_29;
              v34 = *(_QWORD *)(v31 + 24);
              if (v34 != mlir::AffineExpr::operator-((unint64_t *)&v44))
                goto LABEL_29;
LABEL_71:
              v3 = mlir::AffineExpr::operator%((unint64_t *)&v42, v34);
              if (v3)
                return v3;
              goto LABEL_29;
            }
LABEL_74:
            v43 = *(mlir::MLIRContext **)v3;
            v44 = (mlir::MLIRContext **)(v30 + v16);
            v35 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v43);
            v36 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v35, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v43, &v44);
            v44 = v19;
            v3 = mlir::AffineExpr::operator*((unint64_t *)&v44, v36);
            if (v3)
              return v3;
            goto LABEL_29;
          }
LABEL_80:
          v18 = v3;
          v19 = (mlir::MLIRContext **)v3;
          if (v6 >= 5)
            v27 = 0;
          else
            v27 = a2;
          if (!v27)
            goto LABEL_57;
          goto LABEL_52;
        }
        goto LABEL_38;
      }
    }
    else if (v4 <= 4 && v3 != 0)
    {
      v14 = *(_DWORD *)(v3 + 8);
LABEL_38:
      if (v14 == 1)
      {
        v26 = *(_QWORD *)(v3 + 24);
        v16 = 1;
        v17 = 1;
        if (v26)
        {
          v18 = v3;
          v19 = (mlir::MLIRContext **)v3;
          if (*(_DWORD *)(v26 + 8) == 5)
          {
            v16 = *(_QWORD *)(v26 + 16);
            v19 = *(mlir::MLIRContext ***)(v3 + 16);
            v17 = 1;
            v18 = v3;
            if (v6 >= 5)
              v27 = 0;
            else
              v27 = a2;
            if (!v27)
              goto LABEL_57;
            goto LABEL_52;
          }
          goto LABEL_48;
        }
        goto LABEL_80;
      }
      v17 = 1;
      v18 = v3;
LABEL_47:
      v16 = 1;
      v19 = (mlir::MLIRContext **)v3;
      goto LABEL_48;
    }
    v18 = 0;
    v17 = 0;
    goto LABEL_47;
  }
  v20 = (mlir::MLIRContext **)(*(_QWORD *)(v7 + 16) + *(_QWORD *)(v5 + 16));
  v43 = *(mlir::MLIRContext **)v3;
  v44 = v20;
  v21 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v43);
  v22 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v21, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v43, &v44);
  v3 = v22;
  if (!v22)
    goto LABEL_29;
  return v3;
}

uint64_t mlir::AffineExpr::operator*(unint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  unint64_t v5;
  uint64_t v6;
  BOOL v7;
  char v9;
  uint64_t v10;
  uint64_t v12;
  mlir::MLIRContext **v13;
  unsigned __int8 **v14;
  uint64_t v15;
  unsigned __int8 **AffineUniquer;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  mlir::MLIRContext *v23;
  mlir::MLIRContext **v24;

  v21 = a2;
  v22 = a2;
  v3 = *a1;
  v4 = *(_DWORD *)(*a1 + 8);
  if (v4 == 5)
    v5 = *a1;
  else
    v5 = 0;
  if (*(_DWORD *)(a2 + 8) == 5)
    v6 = a2;
  else
    v6 = 0;
  if (v5)
    v7 = v6 == 0;
  else
    v7 = 1;
  if (v7)
  {
    mlir::AffineExpr::isSymbolicOrConstant((mlir::AffineExpr *)&v22);
    if (v4 != 5 && (v9 & 1) != 0)
    {
      if (v6)
      {
        v10 = *(_QWORD *)(v6 + 16);
        if (!v10)
          return a2;
        if (v10 == 1)
          return v3;
        if (v4 != 1 || v3 == 0)
          goto LABEL_29;
        v12 = *(_QWORD *)(v3 + 24);
        if (v12 && *(_DWORD *)(v12 + 8) == 5)
        {
          v24 = *(mlir::MLIRContext ***)(v3 + 16);
          v3 = mlir::AffineExpr::operator*(&v24, v10 * *(_QWORD *)(v12 + 16));
          if (v3)
            return v3;
LABEL_28:
          v3 = *a1;
LABEL_29:
          AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(*(mlir::MLIRContext **)v3);
          LODWORD(v24) = 1;
          return mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(AffineUniquer, 0, 0, &v24, a1, &v21);
        }
      }
      else if (v4 != 1 || v3 == 0)
      {
        goto LABEL_29;
      }
      v19 = *(_QWORD *)(v3 + 24);
      if (v19)
        v20 = *(_DWORD *)(v19 + 8) == 5;
      else
        v20 = 0;
      if (!v20)
        goto LABEL_29;
      v23 = *(mlir::MLIRContext **)(v3 + 16);
      v24 = (mlir::MLIRContext **)mlir::AffineExpr::operator*(&v23, a2);
      v3 = mlir::AffineExpr::operator*(&v24, v19);
      if (v3)
        return v3;
      goto LABEL_28;
    }
    v3 = mlir::AffineExpr::operator*(&v22, v3);
    if (v3)
      return v3;
    goto LABEL_28;
  }
  v13 = (mlir::MLIRContext **)(*(_QWORD *)(v6 + 16) * *(_QWORD *)(v5 + 16));
  v23 = *(mlir::MLIRContext **)v3;
  v24 = v13;
  v14 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v23);
  v15 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v14, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v23, &v24);
  v3 = v15;
  if (!v15)
    goto LABEL_28;
  return v3;
}

uint64_t mlir::AffineExpr::floorDiv(mlir::MLIRContext ***a1, uint64_t a2)
{
  uint64_t v3;
  mlir::MLIRContext **v4;
  uint64_t v6;
  mlir::MLIRContext *v7;
  BOOL v8;
  uint64_t v9;
  mlir::MLIRContext **v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 **AffineUniquer;
  uint64_t v14;
  unsigned __int8 **v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  mlir::MLIRContext **v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int8 **v25;
  uint64_t v27;
  uint64_t v28;
  mlir::MLIRContext **v29;
  mlir::MLIRContext **v30;
  uint64_t v31;

  v28 = a2;
  v3 = (uint64_t)*a1;
  if (*((_DWORD *)*a1 + 2) == 5)
    v4 = *a1;
  else
    v4 = 0;
  if (!a2)
    goto LABEL_27;
  if (*(_DWORD *)(a2 + 8) != 5)
    goto LABEL_27;
  v6 = *(_QWORD *)(a2 + 16);
  if (v6 < 1)
    goto LABEL_27;
  if (v4)
  {
    v7 = v4[2];
    if (v7)
      v8 = (unint64_t)v7 >> 63 == (unint64_t)v6 >> 63;
    else
      v8 = 1;
    v9 = (uint64_t)v7 / v6;
    v10 = *(mlir::MLIRContext ***)v3;
    v11 = (uint64_t)~(unint64_t)v7 / v6;
    if (v8)
      v12 = v9;
    else
      v12 = ~v11;
    v30 = *(mlir::MLIRContext ***)v3;
    v31 = v12;
    AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer((mlir::MLIRContext *)v10);
    v14 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v30, &v31);
  }
  else
  {
    v30 = *(mlir::MLIRContext ***)a2;
    v31 = 1;
    v15 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer((mlir::MLIRContext *)v30);
    if (mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v15, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v30, &v31) == a2)return v3;
    v16 = *(_DWORD *)(v3 + 8);
    if (v16 > 4)
    {
LABEL_27:
      v25 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(**a1);
      LODWORD(v31) = 3;
      return mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(v25, 0, 0, &v31, (unint64_t *)a1, &v28);
    }
    if (v16)
    {
      if (v16 != 1)
        goto LABEL_27;
      v17 = *(_QWORD *)(v3 + 24);
      if (!v17)
        goto LABEL_27;
      if (*(_DWORD *)(v17 + 8) != 5)
        goto LABEL_27;
      v18 = *(_QWORD *)(v17 + 16);
      v19 = *(_QWORD *)(a2 + 16);
      if (v18 % v19)
        goto LABEL_27;
      v31 = *(_QWORD *)(v3 + 16);
      v14 = mlir::AffineExpr::operator*((mlir::MLIRContext ***)&v31, v18 / v19);
    }
    else
    {
      v20 = *(mlir::MLIRContext ***)(v3 + 16);
      v31 = (uint64_t)v20;
      mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v31);
      v22 = v21;
      v31 = *(_QWORD *)(v3 + 24);
      mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v31);
      v24 = *(_QWORD *)(a2 + 16);
      if (v22 % v24 && v23 % v24)
        goto LABEL_27;
      v30 = v20;
      v31 = mlir::AffineExpr::floorDiv(&v30, v24);
      v29 = *(mlir::MLIRContext ***)(v3 + 24);
      v27 = mlir::AffineExpr::floorDiv(&v29, *(_QWORD *)(a2 + 16));
      v14 = mlir::AffineExpr::operator+((unint64_t *)&v31, v27);
    }
  }
  v3 = v14;
  if (!v14)
    goto LABEL_27;
  return v3;
}

uint64_t mlir::AffineExpr::ceilDiv(unint64_t *a1, uint64_t a2)
{
  uint64_t result;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  BOOL v9;
  unint64_t v10;
  mlir::MLIRContext *v11;
  unint64_t v12;
  unint64_t v13;
  unsigned __int8 **v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  unsigned __int8 **v18;
  uint64_t v19;
  unsigned __int8 **AffineUniquer;
  uint64_t v21;
  mlir::MLIRContext **v22;
  mlir::MLIRContext *v23;
  uint64_t v24;

  v21 = a2;
  result = *a1;
  v4 = *(_DWORD *)(result + 8);
  if (v4 == 5)
    v5 = result;
  else
    v5 = 0;
  if (!a2)
    goto LABEL_23;
  if (*(_DWORD *)(a2 + 8) != 5)
    goto LABEL_23;
  v6 = *(_QWORD *)(a2 + 16);
  if (v6 < 1)
    goto LABEL_23;
  if (!v5)
  {
    if (v6 == 1)
      return result;
    if (v4 != 1
      || ((v15 = *(_QWORD *)(result + 24)) != 0 ? (v16 = *(_DWORD *)(v15 + 8) == 5) : (v16 = 0),
          !v16 || (v17 = *(_QWORD *)(v15 + 16), v17 % v6)))
    {
LABEL_23:
      AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(*(mlir::MLIRContext **)result);
      LODWORD(v24) = 4;
      return mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(AffineUniquer, 0, 0, &v24, a1, &v21);
    }
    v22 = *(mlir::MLIRContext ***)(result + 16);
    v23 = *v22;
    v24 = v17 / v6;
    v18 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v23);
    v19 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v18, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v23, &v24);
    result = mlir::AffineExpr::operator*((unint64_t *)&v22, v19);
    if (result)
      return result;
LABEL_22:
    result = *a1;
    goto LABEL_23;
  }
  v7 = *(_QWORD *)(v5 + 16);
  v8 = -v7;
  v9 = v7 < 1;
  v10 = (v7 - 1) / (unint64_t)v6 + 1;
  v11 = *(mlir::MLIRContext **)result;
  v12 = v8 / v6;
  if (v9)
    v13 = -(uint64_t)v12;
  else
    v13 = v10;
  v23 = v11;
  v24 = v13;
  v14 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v11);
  result = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v14, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v23, &v24);
  if (!result)
    goto LABEL_22;
  return result;
}

uint64_t mlir::AffineExpr::operator%(unint64_t *a1, uint64_t a2)
{
  unint64_t v3;
  int v4;
  unint64_t v5;
  uint64_t v6;
  mlir::MLIRContext *v7;
  unsigned __int8 **AffineUniquer;
  uint64_t result;
  uint64_t v10;
  mlir::MLIRContext **v11;
  uint64_t v12;
  uint64_t v13;
  mlir::MLIRContext **v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int8 **v18;
  uint64_t v19;
  unint64_t v20;
  mlir::MLIRContext *v21;
  mlir::MLIRContext **v22;

  v3 = *a1;
  v19 = a2;
  v20 = v3;
  v4 = *(_DWORD *)(v3 + 8);
  if (v4 == 5)
    v5 = v3;
  else
    v5 = 0;
  if (!a2)
    goto LABEL_27;
  if (*(_DWORD *)(a2 + 8) != 5)
    goto LABEL_27;
  v6 = *(_QWORD *)(a2 + 16);
  if (v6 < 1)
    goto LABEL_27;
  if (v5)
  {
    v7 = *(mlir::MLIRContext **)v3;
    v22 = (mlir::MLIRContext **)((v6 & ((*(_QWORD *)(v5 + 16) % v6) >> 63)) + *(_QWORD *)(v5 + 16) % v6);
    goto LABEL_9;
  }
  mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v20);
  if (!(v10 % v6))
  {
    v7 = *(mlir::MLIRContext **)v3;
    v22 = 0;
LABEL_9:
    v21 = v7;
    AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v7);
    result = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v21, &v22);
    if (result)
      return result;
    goto LABEL_26;
  }
  if (v4 > 4)
    goto LABEL_27;
  if (v4 == 2)
  {
    v16 = *(_QWORD *)(v3 + 24);
    if (!v16)
      goto LABEL_27;
    if (*(_DWORD *)(v16 + 8) != 5)
      goto LABEL_27;
    v17 = *(_QWORD *)(v16 + 16);
    if (v17 < 1 || v17 % (unint64_t)v6)
      goto LABEL_27;
    v22 = *(mlir::MLIRContext ***)(v3 + 16);
  }
  else
  {
    if (v4)
      goto LABEL_27;
    v11 = *(mlir::MLIRContext ***)(v3 + 16);
    v22 = v11;
    mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v22);
    v13 = v12;
    v14 = *(mlir::MLIRContext ***)(v3 + 24);
    v22 = v14;
    mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v22);
    if (v13 % v6)
    {
      if (!(v15 % v6))
      {
        v22 = v11;
        goto LABEL_25;
      }
LABEL_27:
      v18 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(*(mlir::MLIRContext **)v3);
      LODWORD(v22) = 2;
      return mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(v18, 0, 0, &v22, a1, &v19);
    }
    v22 = v14;
  }
LABEL_25:
  result = mlir::AffineExpr::operator%(&v22, v6);
  if (!result)
  {
LABEL_26:
    v3 = *a1;
    goto LABEL_27;
  }
  return result;
}

void mlir::AffineExpr::replaceDimsAndSymbols(uint64_t a1)
{
  __asm { BR              X10 }
}

uint64_t sub_1803A04DC(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  mlir::MLIRContext **v6;
  uint64_t v7;
  mlir::MLIRContext **v8;
  uint64_t v9;
  uint64_t result;
  int v12;
  uint64_t v13;
  mlir::MLIRContext **v14;
  mlir::MLIRContext **v15[11];

  v6 = *(mlir::MLIRContext ***)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 24);
  v13 = v7;
  v14 = v6;
  v8 = (mlir::MLIRContext **)((uint64_t (*)(mlir::MLIRContext ***, uint64_t, uint64_t, uint64_t, uint64_t))mlir::AffineExpr::replaceDimsAndSymbols)(&v14, v5, v4, v3, v2);
  v9 = ((uint64_t (*)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))mlir::AffineExpr::replaceDimsAndSymbols)(&v13, v5, v4, v3, v2);
  result = *v1;
  if (v6 != v8 || v7 != v9)
  {
    v12 = *(_DWORD *)(result + 8);
    v15[0] = v8;
    switch(v12)
    {
      case 0:
        result = mlir::AffineExpr::operator+((unint64_t *)v15, v9);
        break;
      case 1:
        result = mlir::AffineExpr::operator*((unint64_t *)v15, v9);
        break;
      case 3:
        result = mlir::AffineExpr::floorDiv(v15, v9);
        break;
      case 4:
        result = mlir::AffineExpr::ceilDiv((unint64_t *)v15, v9);
        break;
      default:
        result = mlir::AffineExpr::operator%((unint64_t *)v15, v9);
        break;
    }
  }
  return result;
}

uint64_t mlir::AffineDimExpr::getPosition(mlir::AffineDimExpr *this)
{
  return *(unsigned int *)(*(_QWORD *)this + 16);
}

uint64_t mlir::AffineBinaryOpExpr::getLHS(mlir::AffineBinaryOpExpr *this)
{
  return *(_QWORD *)(*(_QWORD *)this + 16);
}

uint64_t mlir::AffineBinaryOpExpr::getRHS(mlir::AffineBinaryOpExpr *this)
{
  return *(_QWORD *)(*(_QWORD *)this + 24);
}

uint64_t mlir::AffineExpr::shiftDims(mlir::MLIRContext ***this, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int i;
  mlir::MLIRContext *v9;
  unsigned __int8 **AffineUniquer;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  mlir::MLIRContext *v15;
  unsigned __int8 **v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v22;
  mlir::MLIRContext *v23;
  unsigned int v24;
  void *v25;
  uint64_t v26;
  _QWORD v27[5];

  v27[4] = *MEMORY[0x1E0C80C00];
  v25 = v27;
  v26 = 0x400000000;
  if (a4)
  {
    for (i = 0; i != a4; ++i)
    {
      v9 = **this;
      v24 = i;
      v23 = v9;
      AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v9);
      v22 = 6;
      v11 = mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>, (unint64_t)&v23, &v22, &v24);
      v12 = v26;
      if (v26 >= (unint64_t)HIDWORD(v26))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 8);
        v12 = v26;
      }
      *((_QWORD *)v25 + v12) = v11;
      LODWORD(v26) = v26 + 1;
    }
  }
  v13 = a2 - a4;
  if (a2 > a4)
  {
    v14 = a4 + a3;
    do
    {
      v15 = **this;
      v24 = v14;
      v23 = v15;
      v16 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v15);
      v22 = 6;
      v17 = mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(v16, (const char *)llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>, (unint64_t)&v23, &v22, &v24);
      v18 = v26;
      if (v26 >= (unint64_t)HIDWORD(v26))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 8);
        v18 = v26;
      }
      *((_QWORD *)v25 + v18) = v17;
      LODWORD(v26) = v26 + 1;
      ++v14;
      --v13;
    }
    while (v13);
  }
  mlir::AffineExpr::replaceDimsAndSymbols((uint64_t)this);
  v20 = v19;
  if (v25 != v27)
    free(v25);
  return v20;
}

uint64_t mlir::getAffineDimExpr(mlir *this, mlir::MLIRContext *a2, mlir::MLIRContext *a3)
{
  unsigned __int8 **AffineUniquer;
  unsigned int v5;
  mlir::MLIRContext *v6;
  unsigned int v7;

  v7 = this;
  v6 = a2;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(a2);
  v5 = 6;
  return mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>, (unint64_t)&v6, &v5, &v7);
}

uint64_t mlir::AffineExpr::shiftSymbols(mlir::MLIRContext ***this, unsigned int a2, int a3, unsigned int a4)
{
  unsigned int i;
  mlir::MLIRContext *v9;
  unsigned __int8 **AffineUniquer;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  mlir::MLIRContext *v15;
  unsigned __int8 **v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v22;
  mlir::MLIRContext *v23;
  unsigned int v24;
  void *v25;
  uint64_t v26;
  _QWORD v27[5];

  v27[4] = *MEMORY[0x1E0C80C00];
  v25 = v27;
  v26 = 0x400000000;
  if (a4)
  {
    for (i = 0; i != a4; ++i)
    {
      v9 = **this;
      v24 = i;
      v23 = v9;
      AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v9);
      v22 = 7;
      v11 = mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>, (unint64_t)&v23, &v22, &v24);
      v12 = v26;
      if (v26 >= (unint64_t)HIDWORD(v26))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 8);
        v12 = v26;
      }
      *((_QWORD *)v25 + v12) = v11;
      LODWORD(v26) = v26 + 1;
    }
  }
  v13 = a2 - a4;
  if (a2 > a4)
  {
    v14 = a4 + a3;
    do
    {
      v15 = **this;
      v24 = v14;
      v23 = v15;
      v16 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v15);
      v22 = 7;
      v17 = mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(v16, (const char *)llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>, (unint64_t)&v23, &v22, &v24);
      v18 = v26;
      if (v26 >= (unint64_t)HIDWORD(v26))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 8);
        v18 = v26;
      }
      *((_QWORD *)v25 + v18) = v17;
      LODWORD(v26) = v26 + 1;
      ++v14;
      --v13;
    }
    while (v13);
  }
  mlir::AffineExpr::replaceDimsAndSymbols((uint64_t)this);
  v20 = v19;
  if (v25 != v27)
    free(v25);
  return v20;
}

uint64_t mlir::getAffineSymbolExpr(mlir *this, mlir::MLIRContext *a2, mlir::MLIRContext *a3)
{
  unsigned __int8 **AffineUniquer;
  unsigned int v5;
  mlir::MLIRContext *v6;
  unsigned int v7;

  v7 = this;
  v6 = a2;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(a2);
  v5 = 7;
  return mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>, (unint64_t)&v6, &v5, &v7);
}

mlir::MLIRContext *mlir::AffineExpr::replace(unint64_t *a1, uint64_t a2)
{
  mlir::MLIRContext *result;
  mlir::MLIRContext **v5;
  mlir::MLIRContext **v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  mlir::MLIRContext **v10;
  mlir::MLIRContext **v11;

  v11 = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>,mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>::LookupBucketFor<mlir::Value>((uint64_t *)a2, a1, &v11)&& v11 != (mlir::MLIRContext **)(*(_QWORD *)a2 + 16 * *(unsigned int *)(a2 + 16)))
  {
    return v11[1];
  }
  result = (mlir::MLIRContext *)*a1;
  if (*(_DWORD *)(*a1 + 8) <= 4u)
  {
    v5 = (mlir::MLIRContext **)*((_QWORD *)result + 2);
    v9 = *((_QWORD *)result + 3);
    v10 = v5;
    v6 = (mlir::MLIRContext **)mlir::AffineExpr::replace(&v10, a2);
    v7 = mlir::AffineExpr::replace(&v9, a2);
    result = (mlir::MLIRContext *)*a1;
    if (v10 != v6 || v9 != v7)
    {
      v8 = *((_DWORD *)result + 2);
      v11 = v6;
      switch(v8)
      {
        case 0:
          result = (mlir::MLIRContext *)mlir::AffineExpr::operator+((unint64_t *)&v11, v7);
          break;
        case 1:
          result = (mlir::MLIRContext *)mlir::AffineExpr::operator*((unint64_t *)&v11, v7);
          break;
        case 3:
          result = (mlir::MLIRContext *)mlir::AffineExpr::floorDiv(&v11, v7);
          break;
        case 4:
          result = (mlir::MLIRContext *)mlir::AffineExpr::ceilDiv((unint64_t *)&v11, v7);
          break;
        default:
          result = (mlir::MLIRContext *)mlir::AffineExpr::operator%((unint64_t *)&v11, v7);
          break;
      }
    }
  }
  return result;
}

void mlir::AffineExpr::replace(unint64_t *a1, unint64_t a2, uint64_t a3)
{
  _QWORD *v4;
  unint64_t v5;
  uint64_t v6;
  llvm *v7[2];
  unsigned int v8;
  _QWORD *v9;

  v7[0] = 0;
  v7[1] = 0;
  v8 = 0;
  v5 = a2;
  v6 = a3;
  v9 = 0;
  if ((llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>,mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>::LookupBucketFor<mlir::Value>((uint64_t *)v7, &v5, &v9) & 1) == 0)
  {
    v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>,mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v7, (uint64_t)&v5, &v5, v9);
    *v4 = v5;
    v4[1] = v6;
  }
  mlir::AffineExpr::replace(a1, (uint64_t)v7);
  llvm::deallocate_buffer(v7[0], (void *)(16 * v8));
}

uint64_t sub_1803A0C48()
{
  uint64_t v0;

  return v0;
}

void mlir::AffineExpr::isSymbolicOrConstant(mlir::AffineExpr *this)
{
  __asm { BR              X10 }
}

uint64_t sub_1803A0C90()
{
  uint64_t v0;
  uint64_t result;
  uint64_t v2;
  uint64_t v3;

  v3 = *(_QWORD *)(v0 + 16);
  result = mlir::AffineExpr::isSymbolicOrConstant((mlir::AffineExpr *)&v3);
  if ((_DWORD)result)
  {
    v2 = *(_QWORD *)(v0 + 24);
    return mlir::AffineExpr::isSymbolicOrConstant((mlir::AffineExpr *)&v2);
  }
  return result;
}

uint64_t sub_1803A0CC4()
{
  return 0;
}

void mlir::AffineExpr::isPureAffine(mlir::AffineExpr *this)
{
  __asm { BR              X10 }
}

uint64_t sub_1803A0D0C()
{
  uint64_t v0;
  uint64_t result;
  uint64_t v2;

  v2 = *(_QWORD *)(v0 + 16);
  result = mlir::AffineExpr::isPureAffine((mlir::AffineExpr *)&v2);
  if ((_DWORD)result)
    return *(_DWORD *)(*(_QWORD *)(v0 + 24) + 8) == 5;
  return result;
}

void sub_1803A0D40()
{
  uint64_t v0;
  int v1;
  uint64_t v2;
  uint64_t v3;

  v3 = *(_QWORD *)(v0 + 16);
  mlir::AffineExpr::isPureAffine((mlir::AffineExpr *)&v3);
  if (!v1)
    JUMPOUT(0x1803A0D30);
  v2 = *(_QWORD *)(v0 + 24);
  mlir::AffineExpr::isPureAffine((mlir::AffineExpr *)&v2);
}

uint64_t sub_1803A0D74()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  int v3;
  uint64_t v5;
  uint64_t v6;

  v1 = *(_QWORD *)(v0 + 16);
  v6 = v1;
  mlir::AffineExpr::isPureAffine((mlir::AffineExpr *)&v6);
  if (!v2 || (v5 = *(_QWORD *)(v0 + 24), mlir::AffineExpr::isPureAffine((mlir::AffineExpr *)&v5), !v3))
    JUMPOUT(0x1803A0D30);
  if (*(_DWORD *)(v1 + 8) != 5)
    JUMPOUT(0x1803A0D28);
  return 1;
}

void mlir::AffineExpr::getLargestKnownDivisor(mlir::AffineExpr *this)
{
  __asm { BR              X10 }
}

unint64_t sub_1803A0DF8()
{
  uint64_t v0;
  unint64_t LargestKnownDivisor;
  uint64_t v2;
  unint64_t v3;
  unint64_t result;
  uint64_t v5;
  uint64_t v6;

  v6 = *(_QWORD *)(v0 + 16);
  LargestKnownDivisor = mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v6);
  v5 = *(_QWORD *)(v0 + 24);
  v2 = mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v5);
  if (!v2)
    return LargestKnownDivisor;
  v3 = v2;
  do
  {
    result = v3;
    v3 = LargestKnownDivisor % v3;
    LargestKnownDivisor = result;
  }
  while (v3);
  return result;
}

_QWORD *mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

BOOL mlir::AffineExpr::operator==(mlir::MLIRContext ***a1, uint64_t a2)
{
  unsigned __int8 **AffineUniquer;
  mlir::MLIRContext *v5;
  uint64_t v6;

  v5 = **a1;
  v6 = a2;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v5);
  return *a1 == (mlir::MLIRContext **)mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v5, &v6);
}

uint64_t mlir::getAffineConstantExpr(mlir *this, mlir::MLIRContext *a2, mlir::MLIRContext *a3)
{
  unsigned __int8 **AffineUniquer;
  mlir::MLIRContext *v5;
  mlir *v6;

  v5 = a2;
  v6 = this;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(a2);
  return mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v5, &v6);
}

uint64_t mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(unsigned __int8 **a1, const char *a2, unint64_t a3, _QWORD *a4)
{
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  int v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  const char *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  const char *v17;
  unint64_t v18;
  _QWORD *v19;
  unsigned __int8 **v20;
  _QWORD v21[2];
  uint64_t *v22;
  uint64_t v23;
  const char *v24;
  unint64_t v25;

  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v19 = a4;
    v20 = a1;
    v17 = a2;
    v18 = a3;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    a2 = v17;
    a3 = v18;
    v9 = v8;
    a4 = v19;
    a1 = v20;
    if (v9)
    {
      v24 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::detail::AffineConstantExprStorage]";
      v25 = 89;
      v10 = llvm::StringRef::find((uint64_t *)&v24, "DesiredTypeName = ", 0x12uLL, 0);
      if (v25 >= v10)
        v11 = v10;
      else
        v11 = v25;
      v12 = &v24[v11];
      v13 = v25 - v11;
      if (v25 - v11 >= 0x12)
        v14 = 18;
      else
        v14 = v25 - v11;
      v15 = v13 - v14;
      if (v15 >= v15 - 1)
        v16 = v15 - 1;
      else
        v16 = v15;
      mlir::detail::TypeIDResolver<mlir::detail::AffineConstantExprStorage,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v12[v14], v16);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a2 = v17;
      a3 = v18;
      a4 = v19;
      a1 = v20;
    }
  }
  v6 = v5[132];
  v24 = a2;
  v25 = a3;
  v23 = *a4;
  v21[0] = &v23;
  v21[1] = &v24;
  v22 = &v23;
  return mlir::StorageUniquer::getParametricStorageTypeImpl(a1, v6, 37 * (int)v23, (uint64_t (*)(uint64_t))llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::detail::AffineConstantExprStorage * mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>,mlir::TypeID,long long &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, (uint64_t)&v22, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::detail::AffineConstantExprStorage * mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>,mlir::TypeID,long long &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, (uint64_t)v21);
}

uint64_t mlir::AffineExpr::operator+(mlir::MLIRContext ***a1, uint64_t a2)
{
  unsigned __int8 **AffineUniquer;
  uint64_t v4;
  mlir::MLIRContext *v6;
  uint64_t v7;

  v6 = **a1;
  v7 = a2;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v6);
  v4 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v6, &v7);
  return mlir::AffineExpr::operator+(a1, v4);
}

uint64_t mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(unsigned __int8 **a1, uint64_t a2, uint64_t a3, _DWORD *a4, unint64_t *a5, _QWORD *a6)
{
  unsigned __int8 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int HashValue;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int v16;
  unint64_t v17;
  unint64_t v18;
  const char *v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _DWORD *v26;
  unint64_t *v27;
  _QWORD *v28;
  _QWORD v29[2];
  const char **v30;
  const char *v31;
  unint64_t v32;
  uint64_t v33;
  _QWORD v34[2];

  if ((v7 & 1) == 0)
  {
    v27 = a5;
    v28 = a6;
    v25 = a3;
    v26 = a4;
    v24 = a2;
    a2 = v24;
    a3 = v25;
    a4 = v26;
    a5 = v27;
    a6 = v28;
    if (v16)
    {
      v31 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::detail::AffineBinaryOpExprStorage]";
      v32 = 89;
      v17 = llvm::StringRef::find((uint64_t *)&v31, "DesiredTypeName = ", 0x12uLL, 0);
      if (v32 >= v17)
        v18 = v17;
      else
        v18 = v32;
      v19 = &v31[v18];
      v20 = v32 - v18;
      if (v32 - v18 >= 0x12)
        v21 = 18;
      else
        v21 = v32 - v18;
      v22 = v20 - v21;
      if (v22 >= v22 - 1)
        v23 = v22 - 1;
      else
        v23 = v22;
      mlir::detail::TypeIDResolver<mlir::detail::AffineBinaryOpExprStorage,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v19[v21], v23);
      a2 = v24;
      a3 = v25;
      a4 = v26;
      a5 = v27;
      a6 = v28;
    }
  }
  v8 = mlir::detail::TypeIDResolver<mlir::detail::AffineBinaryOpExprStorage,void>::resolveTypeID(void)::id;
  v34[0] = a2;
  v34[1] = a3;
  LODWORD(v31) = *a4;
  v9 = *a6;
  v32 = *a5;
  v33 = v9;
  v10 = (37 * (_DWORD)v31);
  HashValue = llvm::DenseMapInfo<std::tuple<unsigned int,mlir::AffineExpr,mlir::AffineExpr>,void>::getHashValueImpl<1u>((uint64_t)&v31);
  v12 = (HashValue | (unint64_t)(v10 << 32)) + ~((unint64_t)HashValue << 32);
  v13 = (v12 ^ (v12 >> 22)) + ~((v12 ^ (v12 >> 22)) << 13);
  v14 = (9 * (v13 ^ (v13 >> 8))) ^ ((9 * (v13 ^ (v13 >> 8))) >> 15);
  v29[0] = &v31;
  v29[1] = v34;
  v30 = &v31;
  return mlir::StorageUniquer::getParametricStorageTypeImpl(a1, v8, ((v14 + ~(v14 << 27)) >> 31) ^ (v14 + ~((_DWORD)v14 << 27)), (uint64_t (*)(uint64_t))llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::detail::AffineBinaryOpExprStorage * mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(llvm::function_ref<void ()(mlir::detail::AffineBinaryOpExprStorage *)>,mlir::TypeID,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, (uint64_t)&v30, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::detail::AffineBinaryOpExprStorage * mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(llvm::function_ref<void ()(mlir::detail::AffineBinaryOpExprStorage *)>,mlir::TypeID,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, (uint64_t)v29);
}

uint64_t mlir::AffineExpr::operator*(mlir::MLIRContext ***a1, uint64_t a2)
{
  unsigned __int8 **AffineUniquer;
  uint64_t v4;
  mlir::MLIRContext *v6;
  uint64_t v7;

  v6 = **a1;
  v7 = a2;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v6);
  v4 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v6, &v7);
  return mlir::AffineExpr::operator*(a1, v4);
}

uint64_t mlir::AffineExpr::operator-(unint64_t *a1)
{
  unsigned __int8 **AffineUniquer;
  uint64_t v3;
  mlir::MLIRContext *v5;
  uint64_t v6;

  v5 = *(mlir::MLIRContext **)*a1;
  v6 = -1;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v5);
  v3 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v5, &v6);
  return mlir::AffineExpr::operator*(a1, v3);
}

uint64_t mlir::AffineExpr::operator-(unint64_t *a1, mlir::MLIRContext **a2)
{
  unsigned __int8 **AffineUniquer;
  uint64_t v4;
  uint64_t v5;
  mlir::MLIRContext **v7;
  mlir::MLIRContext *v8;
  uint64_t v9;

  v7 = a2;
  v8 = *a2;
  v9 = -1;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v8);
  v4 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v8, &v9);
  v5 = mlir::AffineExpr::operator*((unint64_t *)&v7, v4);
  return mlir::AffineExpr::operator+(a1, v5);
}

uint64_t mlir::AffineExpr::floorDiv(mlir::MLIRContext ***this, uint64_t a2)
{
  unsigned __int8 **AffineUniquer;
  uint64_t v4;
  mlir::MLIRContext *v6;
  uint64_t v7;

  v6 = **this;
  v7 = a2;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v6);
  v4 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v6, &v7);
  return mlir::AffineExpr::floorDiv(this, v4);
}

uint64_t mlir::AffineExpr::operator%(mlir::MLIRContext ***a1, uint64_t a2)
{
  unsigned __int8 **AffineUniquer;
  uint64_t v4;
  mlir::MLIRContext *v6;
  uint64_t v7;

  v6 = **a1;
  v7 = a2;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v6);
  v4 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v6, &v7);
  return mlir::AffineExpr::operator%(a1, v4);
}

mlir::MLIRContext **mlir::getAffineExprFromFlatForm(uint64_t a1, uint64_t a2, unsigned int a3, int a4, unint64_t *a5, int a6, mlir::MLIRContext *this)
{
  unsigned __int8 **AffineUniquer;
  mlir::MLIRContext **result;
  unint64_t v14;
  unint64_t v15;
  unsigned __int8 **v16;
  mlir::MLIRContext *v17;
  unsigned __int8 **v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  mlir::MLIRContext *v22;
  unsigned __int8 **v23;
  uint64_t v24;
  uint64_t v25;
  mlir::MLIRContext *v26;
  unsigned __int8 **v27;
  uint64_t v28;
  mlir::MLIRContext **v30;
  mlir::MLIRContext **v31;
  mlir::MLIRContext *v32;
  mlir::MLIRContext *v33;

  v32 = this;
  v33 = 0;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(this);
  result = (mlir::MLIRContext **)mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v32, &v33);
  v31 = result;
  v14 = a4 + a3;
  if (a4 + a3)
  {
    v15 = 0;
    do
    {
      if (*(_QWORD *)(a1 + 8 * v15))
      {
        if (v15 >= a3)
        {
          LODWORD(v32) = v15 - a3;
          v33 = this;
          v16 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(this);
          LODWORD(v30) = 7;
        }
        else
        {
          LODWORD(v32) = v15;
          v33 = this;
          v16 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(this);
          LODWORD(v30) = 6;
        }
        v30 = (mlir::MLIRContext **)mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(v16, (const char *)llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>, (unint64_t)&v33, (unsigned int *)&v30, (unsigned int *)&v32);
        v17 = *(mlir::MLIRContext **)(a1 + 8 * v15);
        v32 = *v30;
        v33 = v17;
        v18 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v32);
        v19 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v18, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v32, &v33);
        v20 = mlir::AffineExpr::operator*((unint64_t *)&v30, v19);
        result = (mlir::MLIRContext **)mlir::AffineExpr::operator+((unint64_t *)&v31, v20);
        v31 = result;
      }
      ++v15;
    }
    while (v14 != v15);
  }
  v21 = (a2 - 1);
  if (v14 < v21)
  {
    do
    {
      v22 = *(mlir::MLIRContext **)(a1 + 8 * v14);
      if (v22)
      {
        v32 = *(mlir::MLIRContext **)*a5;
        v33 = v22;
        v23 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v32);
        v24 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v23, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v32, &v33);
        v25 = mlir::AffineExpr::operator*(a5, v24);
        result = (mlir::MLIRContext **)mlir::AffineExpr::operator+((unint64_t *)&v31, v25);
        v31 = result;
      }
      ++v14;
      ++a5;
    }
    while (v14 < v21);
  }
  v26 = *(mlir::MLIRContext **)(a1 + 8 * a2 - 8);
  if (v26)
  {
    v32 = *result;
    v33 = v26;
    v27 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v32);
    v28 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v27, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v32, &v33);
    return (mlir::MLIRContext **)mlir::AffineExpr::operator+((unint64_t *)&v31, v28);
  }
  return result;
}

void std::vector<llvm::SmallVector<long long,8u>>::reserve(uint64_t a1, unint64_t a2)
{
  char *v2;
  _BYTE *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  char *v10;
  char *v11;
  char *v12;

  v2 = *(char **)a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 4) < a2)
  {
    if (a2 >= 0x333333333333334)
      abort();
    v4 = *(_BYTE **)(a1 + 8);
    v5 = 80 * a2;
    v6 = (char *)operator new(80 * a2);
    v7 = &v6[v5];
    v8 = &v6[v4 - v2];
    if (v4 == v2)
    {
      *(_QWORD *)a1 = v8;
      *(_QWORD *)(a1 + 8) = v8;
      *(_QWORD *)(a1 + 16) = v7;
    }
    else
    {
      v9 = 0;
      do
      {
        *(_QWORD *)&v8[v9 - 80] = &v8[v9 - 64];
        *(_QWORD *)&v8[v9 - 72] = 0x800000000;
        if (*(_DWORD *)&v4[v9 - 72])
          llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)&v8[v9 - 80], (uint64_t)&v4[v9 - 80]);
        v9 -= 80;
      }
      while (&v4[v9] != v2);
      v2 = *(char **)a1;
      v10 = *(char **)(a1 + 8);
      *(_QWORD *)a1 = &v8[v9];
      *(_QWORD *)(a1 + 8) = v8;
      *(_QWORD *)(a1 + 16) = v7;
      while (v10 != v2)
      {
        v12 = (char *)*((_QWORD *)v10 - 10);
        v10 -= 80;
        v11 = v12;
        if (v10 + 16 != v12)
          free(v11);
      }
    }
    if (v2)
      operator delete(v2);
  }
}

mlir::SimpleAffineExprFlattener *mlir::SimpleAffineExprFlattener::SimpleAffineExprFlattener(mlir::SimpleAffineExprFlattener *this, int a2, int a3)
{
  *(_QWORD *)this = off_1E0E47DA0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 8) = a2;
  *((_DWORD *)this + 9) = a3;
  *((_DWORD *)this + 10) = 0;
  *((_QWORD *)this + 6) = (char *)this + 64;
  *((_QWORD *)this + 7) = 0x400000000;
  std::vector<llvm::SmallVector<long long,8u>>::reserve((uint64_t)this + 8, 8uLL);
  return this;
}

uint64_t mlir::SimpleAffineExprFlattener::visitMulExpr(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v7;
  _QWORD *v8;
  void *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  mlir::MLIRContext *v15;
  mlir::MLIRContext **v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  mlir::MLIRContext **AffineExprFromFlatForm;
  void *v35;
  int v36[2];
  _QWORD v37[9];

  v37[8] = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 16);
  v35 = v37;
  *(_QWORD *)v36 = 0x800000000;
  v5 = *(_DWORD *)(v4 - 72);
  if (&v35 != (void **)(v4 - 80) && v5 != 0)
  {
    if (v5 < 9)
    {
      v8 = v37;
      v7 = *(_DWORD *)(v4 - 72);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v37, *(unsigned int *)(v4 - 72), 8);
      v7 = *(_DWORD *)(v4 - 72);
      if (!v7)
      {
LABEL_10:
        v36[0] = v5;
        v4 = *(_QWORD *)(a1 + 16);
        goto LABEL_11;
      }
      v8 = v35;
    }
    memcpy(v8, *(const void **)(v4 - 80), 8 * v7);
    goto LABEL_10;
  }
LABEL_11:
  v9 = *(void **)(v4 - 80);
  if (v9 != (void *)(v4 - 64))
    free(v9);
  *(_QWORD *)(a1 + 16) = v4 - 80;
  if (*(_DWORD *)(*(_QWORD *)(a2 + 24) + 8) == 5)
  {
    v10 = v35;
    v11 = *(unsigned int *)(v4 - 152);
    if (!(_DWORD)v11)
      goto LABEL_38;
    v12 = *((_QWORD *)v35 + (*(_DWORD *)(a1 + 36) + *(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 40)));
    v13 = *(_QWORD *)(v4 - 160);
    if ((_DWORD)v11 == 1)
    {
      v14 = 0;
LABEL_36:
      v31 = (_QWORD *)(v13 + 8 * v14);
      v32 = v11 - v14;
      do
      {
        *v31++ *= v12;
        --v32;
      }
      while (v32);
      goto LABEL_38;
    }
    v14 = v11 & 0xFFFFFFFE;
    v28 = (uint64_t *)(v13 + 8);
    v29 = v14;
    do
    {
      v30 = *v28 * v12;
      *(v28 - 1) *= v12;
      *v28 = v30;
      v28 += 2;
      v29 -= 2;
    }
    while (v29);
    if (v14 != v11)
      goto LABEL_36;
  }
  else
  {
    v15 = *(mlir::MLIRContext **)a2;
    AffineExprFromFlatForm = mlir::getAffineExprFromFlatForm(*(_QWORD *)(v4 - 160), *(unsigned int *)(v4 - 152), *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 36), *(unint64_t **)(a1 + 48), *(_DWORD *)(a1 + 56), v15);
    v16 = mlir::getAffineExprFromFlatForm((uint64_t)v35, v36[0], *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 36), *(unint64_t **)(a1 + 48), *(_DWORD *)(a1 + 56), v15);
    v17 = mlir::AffineExpr::operator*((unint64_t *)&AffineExprFromFlatForm, (uint64_t)v16);
    v18 = *(_QWORD *)(a1 + 48);
    v19 = *(unsigned int *)(a1 + 56);
    if (!(_DWORD)v19)
      goto LABEL_29;
    v20 = 8 * v19;
    v21 = *(_QWORD **)(a1 + 48);
    while (*v21 != v17)
    {
      ++v21;
      v20 -= 8;
      if (!v20)
      {
        v21 = (_QWORD *)(v18 + 8 * v19);
        break;
      }
    }
    v22 = (uint64_t)v21 - v18;
    if (v19 == v22 >> 3 || (v23 = (unint64_t)v22 >> 3, ((unint64_t)v22 >> 3) == -1))
    {
LABEL_29:
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 24))(a1, v17);
      v25 = *(_QWORD *)(v4 - 160);
      v27 = *(unsigned int *)(v4 - 152);
      if ((_DWORD)v27)
        bzero(*(void **)(v4 - 160), 8 * v27);
      v26 = *(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 36) + *(_DWORD *)(a1 + 40) - 1;
    }
    else
    {
      v24 = *(unsigned int *)(v4 - 152);
      v25 = *(_QWORD *)(v4 - 160);
      if ((_DWORD)v24)
        bzero(*(void **)(v4 - 160), 8 * v24);
      v26 = *(_DWORD *)(a1 + 32) + v23 + *(_DWORD *)(a1 + 36);
    }
    *(_QWORD *)(v25 + 8 * v26) = 1;
    v10 = v35;
  }
LABEL_38:
  if (v10 != v37)
    free(v10);
  return 1;
}

uint64_t mlir::SimpleAffineExprFlattener::visitModExpr(_DWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v7;
  _QWORD *v8;
  void *v9;
  void **v10;
  mlir::MLIRContext *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  mlir::MLIRContext **v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  unint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  _BYTE *v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  unsigned __int8 **AffineUniquer;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  unint64_t v56;
  unsigned int v57;
  mlir::MLIRContext **v59;
  mlir::MLIRContext *v60;
  uint64_t v61;
  void *AffineExprFromFlatForm;
  uint64_t v63;
  _BYTE v64[64];
  void *v65;
  int v66[2];
  _QWORD v67[9];

  v67[8] = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)a1 + 2);
  v65 = v67;
  *(_QWORD *)v66 = 0x800000000;
  v5 = *(_DWORD *)(v4 - 72);
  if (&v65 != (void **)(v4 - 80) && v5 != 0)
  {
    if (v5 < 9)
    {
      v8 = v67;
      v7 = *(_DWORD *)(v4 - 72);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v65, v67, *(unsigned int *)(v4 - 72), 8);
      v7 = *(_DWORD *)(v4 - 72);
      if (!v7)
      {
LABEL_10:
        v66[0] = v5;
        v4 = *((_QWORD *)a1 + 2);
        goto LABEL_11;
      }
      v8 = v65;
    }
    memcpy(v8, *(const void **)(v4 - 80), 8 * v7);
    goto LABEL_10;
  }
LABEL_11:
  v9 = *(void **)(v4 - 80);
  if (v9 != (void *)(v4 - 64))
    free(v9);
  *((_QWORD *)a1 + 2) = v4 - 80;
  v10 = (void **)(v4 - 160);
  v11 = *(mlir::MLIRContext **)a2;
  if (*(_DWORD *)(*(_QWORD *)(a2 + 24) + 8) != 5)
  {
    AffineExprFromFlatForm = mlir::getAffineExprFromFlatForm(*(_QWORD *)(v4 - 160), *(unsigned int *)(v4 - 152), a1[8], a1[9], *((unint64_t **)a1 + 6), a1[14], *(mlir::MLIRContext **)a2);
    v17 = mlir::getAffineExprFromFlatForm((uint64_t)v65, v66[0], a1[8], a1[9], *((unint64_t **)a1 + 6), a1[14], v11);
    v18 = mlir::AffineExpr::operator%((unint64_t *)&AffineExprFromFlatForm, (uint64_t)v17);
    v19 = *((_QWORD *)a1 + 6);
    v20 = a1[14];
    if (!(_DWORD)v20)
      goto LABEL_35;
    v21 = 8 * v20;
    v22 = (_QWORD *)*((_QWORD *)a1 + 6);
    while (*v22 != v18)
    {
      ++v22;
      v21 -= 8;
      if (!v21)
      {
        v22 = (_QWORD *)(v19 + 8 * v20);
        break;
      }
    }
    v23 = (uint64_t)v22 - v19;
    if (v20 == v23 >> 3 || (v26 = (unint64_t)v23 >> 3, ((unint64_t)v23 >> 3) == -1))
    {
LABEL_35:
      (*(void (**)(_DWORD *, uint64_t))(*(_QWORD *)a1 + 24))(a1, v18);
      v30 = *(_QWORD *)(v4 - 160);
      v31 = *(unsigned int *)(v4 - 152);
      if ((_DWORD)v31)
        bzero(*(void **)(v4 - 160), 8 * v31);
      v32 = a1[8] + a1[9] + a1[10] - 1;
      v24 = 1;
      *(_QWORD *)(v30 + 8 * v32) = 1;
      v25 = v65;
      if (v65 != v67)
        goto LABEL_82;
    }
    else
    {
      v27 = *(unsigned int *)(v4 - 152);
      v28 = *v10;
      if ((_DWORD)v27)
        bzero(*v10, 8 * v27);
      v29 = a1[8] + v26 + a1[9];
      v24 = 1;
      v28[v29] = 1;
      v25 = v65;
      if (v65 != v67)
        goto LABEL_82;
    }
    return v24;
  }
  v12 = *((_QWORD *)v65 + (a1[9] + a1[8] + a1[10]));
  if (v12 < 1)
  {
    v24 = 0;
    v25 = v65;
    if (v65 == v67)
      return v24;
    goto LABEL_82;
  }
  v13 = *(unsigned int *)(v4 - 152);
  if ((_DWORD)v13)
  {
    v14 = (uint64_t *)*v10;
    v15 = *(unsigned int *)(v4 - 152);
    while (1)
    {
      v16 = *v14++;
      if (v16 % v12)
        break;
      if (!--v15)
        goto LABEL_45;
    }
    if (!(_DWORD)v15)
    {
LABEL_45:
      bzero(*v10, 8 * v13);
      goto LABEL_81;
    }
    v33 = 0;
    AffineExprFromFlatForm = v64;
    v63 = 0x800000000;
    v34 = *(_DWORD *)(v4 - 152);
    if (&AffineExprFromFlatForm == v10 || !v34)
    {
LABEL_49:
      if (v34)
      {
        v37 = 0;
        v38 = v12;
        do
        {
          v40 = *((_QWORD *)*v10 + v37);
          if (v40)
          {
            if (v40 >= 0)
              v41 = *((_QWORD *)*v10 + v37);
            else
              v41 = -v40;
            do
            {
              v39 = v41;
              v41 = v38 % v41;
              v38 = v39;
            }
            while (v41);
          }
          else
          {
            v39 = v38;
          }
          ++v37;
          v38 = v39;
        }
        while (v37 != v34);
      }
      else
      {
        v39 = v12;
      }
      if (v39 == 1)
      {
        v42 = (uint64_t *)AffineExprFromFlatForm;
      }
      else
      {
        v42 = (uint64_t *)AffineExprFromFlatForm;
        if (v33)
        {
          if (v33 == 1)
          {
            v43 = 0;
          }
          else
          {
            v44 = 0;
            v43 = v33 & 0xFFFFFFFE;
            do
            {
              v45 = &v42[v44];
              v46 = v45[1] / v39;
              *v45 /= v39;
              v45[1] = v46;
              v44 += 2;
            }
            while (v43 != v44);
            if (v43 == v33)
              goto LABEL_69;
          }
          do
            v42[v43++] /= v39;
          while (v33 != v43);
        }
      }
LABEL_69:
      v47 = v12 / v39;
      v59 = mlir::getAffineExprFromFlatForm((uint64_t)v42, v33, a1[8], a1[9], *((unint64_t **)a1 + 6), a1[14], v11);
      v60 = v11;
      v61 = v47;
      AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v11);
      v49 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v60, &v61);
      v50 = mlir::AffineExpr::floorDiv(&v59, v49);
      v51 = *((_QWORD *)a1 + 6);
      v52 = a1[14];
      if ((_DWORD)v52)
      {
        v53 = 8 * v52;
        v54 = (_QWORD *)*((_QWORD *)a1 + 6);
        while (*v54 != v50)
        {
          ++v54;
          v53 -= 8;
          if (!v53)
          {
            v54 = (_QWORD *)(v51 + 8 * v52);
            break;
          }
        }
      }
      else
      {
        v54 = (_QWORD *)*((_QWORD *)a1 + 6);
      }
      v55 = (uint64_t)v54 - v51;
      if (v52 == v55 >> 3 || (v56 = (unint64_t)v55 >> 3, (_DWORD)v56 == -1))
      {
        (*(void (**)(_DWORD *, void *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 16))(a1, AffineExprFromFlatForm, v63, v47, v50);
        v57 = a1[8] + a1[9] + a1[10] - 1;
      }
      else
      {
        v57 = a1[8] + v56 + a1[9];
      }
      *((_QWORD *)*v10 + v57) = -v12;
      if (AffineExprFromFlatForm != v64)
        free(AffineExprFromFlatForm);
      goto LABEL_81;
    }
    if (v34 < 9)
    {
      v36 = v64;
      v35 = *(_DWORD *)(v4 - 152);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&AffineExprFromFlatForm, v64, *(unsigned int *)(v4 - 152), 8);
      v35 = *(_DWORD *)(v4 - 152);
      if (!v35)
      {
LABEL_48:
        LODWORD(v63) = v34;
        v33 = v34;
        v34 = *(_DWORD *)(v4 - 152);
        goto LABEL_49;
      }
      v36 = AffineExprFromFlatForm;
    }
    memcpy(v36, *v10, 8 * v35);
    goto LABEL_48;
  }
LABEL_81:
  v24 = 1;
  v25 = v65;
  if (v65 != v67)
LABEL_82:
    free(v25);
  return v24;
}

uint64_t mlir::SimpleAffineExprFlattener::visitDivExpr(_DWORD *a1, uint64_t a2, int a3)
{
  mlir::MLIRContext *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v10;
  _QWORD *v11;
  void *v12;
  void **v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  mlir::MLIRContext **v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  int v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  char *v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  unsigned __int8 **AffineUniquer;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int v61;
  _BYTE *v62;
  uint64_t v63;
  unsigned int v64;
  _BYTE *v65;
  _BYTE *v66;
  uint64_t v67;
  uint64_t v68;
  unsigned int v69;
  mlir::MLIRContext **v70;
  mlir::MLIRContext *v71;
  void *AffineExprFromFlatForm;
  uint64_t v73;
  _BYTE v74[64];
  void *v75;
  int v76[2];
  _QWORD v77[9];

  v77[8] = *MEMORY[0x1E0C80C00];
  v6 = *(mlir::MLIRContext **)a2;
  v7 = *((_QWORD *)a1 + 2);
  v75 = v77;
  *(_QWORD *)v76 = 0x800000000;
  v8 = *(_DWORD *)(v7 - 72);
  if (&v75 != (void **)(v7 - 80) && v8 != 0)
  {
    if (v8 < 9)
    {
      v11 = v77;
      v10 = *(_DWORD *)(v7 - 72);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v77, *(unsigned int *)(v7 - 72), 8);
      v10 = *(_DWORD *)(v7 - 72);
      if (!v10)
      {
LABEL_10:
        v76[0] = v8;
        v7 = *((_QWORD *)a1 + 2);
        goto LABEL_11;
      }
      v11 = v75;
    }
    memcpy(v11, *(const void **)(v7 - 80), 8 * v10);
    goto LABEL_10;
  }
LABEL_11:
  v12 = *(void **)(v7 - 80);
  if (v12 != (void *)(v7 - 64))
    free(v12);
  *((_QWORD *)a1 + 2) = v7 - 80;
  v13 = (void **)(v7 - 160);
  if (*(_DWORD *)(*(_QWORD *)(a2 + 24) + 8) != 5)
  {
    AffineExprFromFlatForm = mlir::getAffineExprFromFlatForm(*(_QWORD *)(v7 - 160), *(unsigned int *)(v7 - 152), a1[8], a1[9], *((unint64_t **)a1 + 6), a1[14], v6);
    v22 = mlir::getAffineExprFromFlatForm((uint64_t)v75, v76[0], a1[8], a1[9], *((unint64_t **)a1 + 6), a1[14], v6);
    if (a3)
    {
      v23 = mlir::AffineExpr::ceilDiv((unint64_t *)&AffineExprFromFlatForm, (uint64_t)v22);
      v24 = (char *)*((_QWORD *)a1 + 6);
      v25 = a1[14];
      if (!(_DWORD)v25)
        goto LABEL_39;
    }
    else
    {
      v23 = mlir::AffineExpr::floorDiv((mlir::MLIRContext ***)&AffineExprFromFlatForm, (uint64_t)v22);
      v24 = (char *)*((_QWORD *)a1 + 6);
      v25 = a1[14];
      if (!(_DWORD)v25)
        goto LABEL_39;
    }
    v26 = 8 * v25;
    v27 = v24;
    while (*(_QWORD *)v27 != v23)
    {
      v27 += 8;
      v26 -= 8;
      if (!v26)
      {
        v27 = &v24[8 * v25];
        break;
      }
    }
    v28 = v27 - v24;
    if (v25 != v28 >> 3)
    {
      v29 = (unint64_t)v28 >> 3;
      if (((unint64_t)v28 >> 3) != -1)
      {
        v30 = *(unsigned int *)(v7 - 152);
        v31 = *v13;
        if ((_DWORD)v30)
          bzero(*v13, 8 * v30);
        v32 = a1[8] + v29 + a1[9];
        v33 = 1;
        v31[v32] = 1;
        v34 = v75;
        if (v75 != v77)
          goto LABEL_42;
        return v33;
      }
    }
LABEL_39:
    (*(void (**)(_DWORD *))(*(_QWORD *)a1 + 24))(a1);
    v35 = *(_QWORD *)(v7 - 160);
    v36 = *(unsigned int *)(v7 - 152);
    if ((_DWORD)v36)
      bzero(*(void **)(v7 - 160), 8 * v36);
    v37 = a1[8] + a1[9] + a1[10] - 1;
    v33 = 1;
    *(_QWORD *)(v35 + 8 * v37) = 1;
    v34 = v75;
    if (v75 != v77)
      goto LABEL_42;
    return v33;
  }
  v14 = a1[8];
  v15 = a1[9];
  v16 = *((_QWORD *)v75 + v15 + v14 + a1[10]);
  if (v16 < 1)
  {
    v33 = 0;
    v34 = v75;
    if (v75 == v77)
      return v33;
    goto LABEL_42;
  }
  v17 = *(unsigned int *)(v7 - 152);
  if (!(_DWORD)v17)
  {
    v19 = *((_QWORD *)v75 + v15 + v14 + a1[10]);
    goto LABEL_55;
  }
  v18 = 0;
  v19 = *((_QWORD *)v75 + v15 + v14 + a1[10]);
  do
  {
    v20 = *((_QWORD *)*v13 + v18);
    if (v20)
    {
      if (v20 < 0)
        v20 = -v20;
      v21 = v19;
      do
      {
        v19 = v20;
        v20 = v21 % v20;
        v21 = v19;
      }
      while (v20);
    }
    ++v18;
  }
  while (v18 != v17);
  if (v19 != 1)
  {
    v39 = (char *)*v13;
    if (v17 < 2)
    {
      v40 = 0;
LABEL_53:
      v44 = (uint64_t *)&v39[8 * v40];
      v45 = v17 - v40;
      do
      {
        *v44++ /= v19;
        --v45;
      }
      while (v45);
      goto LABEL_55;
    }
    v40 = v17 & 0xFFFFFFFE;
    v41 = (uint64_t *)(v39 + 8);
    v42 = v40;
    do
    {
      v43 = *v41;
      *(v41 - 1) /= v19;
      *v41 = v43 / v19;
      v41 += 2;
      v42 -= 2;
    }
    while (v42);
    if (v40 != v17)
      goto LABEL_53;
  }
LABEL_55:
  v46 = v16 / v19;
  if (v16 / v19 == 1)
  {
    v33 = 1;
    v34 = v75;
    if (v75 == v77)
      return v33;
    goto LABEL_42;
  }
  v70 = mlir::getAffineExprFromFlatForm((uint64_t)*v13, v17, v14, v15, *((unint64_t **)a1 + 6), a1[14], v6);
  v71 = v6;
  AffineExprFromFlatForm = (void *)v46;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v6);
  v48 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v71, &AffineExprFromFlatForm);
  if (a3)
  {
    v49 = mlir::AffineExpr::ceilDiv((unint64_t *)&v70, v48);
    v50 = (char *)*((_QWORD *)a1 + 6);
    v51 = a1[14];
    if ((_DWORD)v51)
      goto LABEL_60;
LABEL_65:
    v53 = v50;
    goto LABEL_66;
  }
  v49 = mlir::AffineExpr::floorDiv(&v70, v48);
  v50 = (char *)*((_QWORD *)a1 + 6);
  v51 = a1[14];
  if (!(_DWORD)v51)
    goto LABEL_65;
LABEL_60:
  v52 = 8 * v51;
  v53 = v50;
  while (*(_QWORD *)v53 != v49)
  {
    v53 += 8;
    v52 -= 8;
    if (!v52)
    {
      v53 = &v50[8 * v51];
      break;
    }
  }
LABEL_66:
  v54 = v53 - v50;
  if (v51 != v54 >> 3)
  {
    v55 = (unint64_t)v54 >> 3;
    if (((unint64_t)v54 >> 3) != -1)
    {
      v56 = *(unsigned int *)(v7 - 152);
      v57 = *(_QWORD *)(v7 - 160);
      if ((_DWORD)v56)
        bzero(*(void **)(v7 - 160), 8 * v56);
      v58 = a1[8] + v55 + a1[9];
      v33 = 1;
      *(_QWORD *)(v57 + 8 * v58) = 1;
      v34 = v75;
      if (v75 == v77)
        return v33;
LABEL_42:
      free(v34);
      return v33;
    }
  }
  v59 = 0;
  if ((a3 & 1) != 0)
  {
    AffineExprFromFlatForm = v74;
    v73 = 0x800000000;
    if (&AffineExprFromFlatForm == v13 || (v60 = *(unsigned int *)(v7 - 152), !(_DWORD)v60))
    {
      v66 = v74;
LABEL_88:
      *(_QWORD *)&v66[8 * v59 - 8] = v46 + *(_QWORD *)&v66[8 * v59 - 8] - 1;
      goto LABEL_92;
    }
    if (v60 < 9)
    {
      v62 = v74;
      v61 = *(_DWORD *)(v7 - 152);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&AffineExprFromFlatForm, v74, *(unsigned int *)(v7 - 152), 8);
      v61 = *(_DWORD *)(v7 - 152);
      if (!v61)
      {
LABEL_87:
        LODWORD(v73) = v60;
        v66 = AffineExprFromFlatForm;
        v59 = v60;
        goto LABEL_88;
      }
      v62 = AffineExprFromFlatForm;
    }
    memcpy(v62, *v13, 8 * v61);
    goto LABEL_87;
  }
  AffineExprFromFlatForm = v74;
  v73 = 0x800000000;
  if (&AffineExprFromFlatForm == v13 || (v63 = *(unsigned int *)(v7 - 152), !(_DWORD)v63))
  {
    v66 = v74;
    goto LABEL_92;
  }
  if (v63 < 9)
  {
    v65 = v74;
    v64 = *(_DWORD *)(v7 - 152);
    goto LABEL_90;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&AffineExprFromFlatForm, v74, *(unsigned int *)(v7 - 152), 8);
  v64 = *(_DWORD *)(v7 - 152);
  if (v64)
  {
    v65 = AffineExprFromFlatForm;
LABEL_90:
    memcpy(v65, *v13, 8 * v64);
  }
  LODWORD(v73) = v63;
  v66 = AffineExprFromFlatForm;
  v59 = v63;
LABEL_92:
  (*(void (**)(_DWORD *, _BYTE *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 16))(a1, v66, v59, v46, v49);
  if (AffineExprFromFlatForm != v74)
    free(AffineExprFromFlatForm);
  v67 = *(_QWORD *)(v7 - 160);
  v68 = *(unsigned int *)(v7 - 152);
  if ((_DWORD)v68)
    bzero(*(void **)(v7 - 160), 8 * v68);
  v69 = a1[8] + a1[9] + a1[10] - 1;
  v33 = 1;
  *(_QWORD *)(v67 + 8 * v69) = 1;
  v34 = v75;
  if (v75 != v77)
    goto LABEL_42;
  return v33;
}

uint64_t mlir::SimpleAffineExprFlattener::visitDimExpr(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _QWORD *v5;
  size_t v6;
  unint64_t v7;
  unsigned int v8;
  char *v9;
  void *v10;
  unsigned int v11;
  void *__src;
  unsigned int v14;
  int v15;
  _QWORD v16[33];

  v16[32] = *MEMORY[0x1E0C80C00];
  v4 = (*(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 36) + *(_DWORD *)(a1 + 40) + 1);
  __src = v16;
  v15 = 32;
  if (v4 < 0x21)
  {
    if (!(_DWORD)v4)
      goto LABEL_6;
    v6 = 8 * v4;
    v5 = v16;
  }
  else
  {
    v14 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v16, v4, 8);
    v5 = __src;
    v6 = 8 * v4;
  }
  bzero(v5, v6);
LABEL_6:
  v14 = v4;
  v7 = *(_QWORD *)(a1 + 16);
  if (v7 >= *(_QWORD *)(a1 + 24))
  {
    v9 = std::vector<llvm::SmallVector<long long,8u>>::__emplace_back_slow_path<llvm::SmallVector<long long,32u>>((char **)(a1 + 8), (uint64_t)&__src);
    *(_QWORD *)(a1 + 16) = v9;
    v10 = __src;
    if (__src == v16)
      goto LABEL_20;
    goto LABEL_19;
  }
  *(_QWORD *)v7 = v7 + 16;
  *(_QWORD *)(v7 + 8) = 0x800000000;
  if ((void **)v7 != &__src)
  {
    v8 = v14;
    if (v14)
    {
      if (__src == v16)
      {
        v11 = v14;
        if (v14 < 9
          || (llvm::SmallVectorBase<unsigned int>::grow_pod(v7, (void *)(v7 + 16), v14, 8), (v11 = v14) != 0))
        {
          memcpy(*(void **)v7, __src, 8 * v11);
        }
        *(_DWORD *)(v7 + 8) = v8;
      }
      else
      {
        *(_QWORD *)v7 = __src;
        *(_DWORD *)(v7 + 8) = v8;
        *(_DWORD *)(v7 + 12) = v15;
        __src = v16;
        v15 = 0;
      }
      v14 = 0;
    }
  }
  v9 = (char *)(v7 + 80);
  *(_QWORD *)(a1 + 16) = v7 + 80;
  v10 = __src;
  if (__src != v16)
  {
LABEL_19:
    free(v10);
    v9 = *(char **)(a1 + 16);
  }
LABEL_20:
  *(_QWORD *)(*((_QWORD *)v9 - 10) + 8 * *(unsigned int *)(a2 + 16)) = 1;
  return 1;
}

uint64_t mlir::SimpleAffineExprFlattener::visitSymbolExpr(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _QWORD *v5;
  size_t v6;
  unint64_t v7;
  unsigned int v8;
  char *v9;
  void *v10;
  unsigned int v11;
  void *__src;
  unsigned int v14;
  int v15;
  _QWORD v16[33];

  v16[32] = *MEMORY[0x1E0C80C00];
  v4 = (*(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 36) + *(_DWORD *)(a1 + 40) + 1);
  __src = v16;
  v15 = 32;
  if (v4 < 0x21)
  {
    if (!(_DWORD)v4)
      goto LABEL_6;
    v6 = 8 * v4;
    v5 = v16;
  }
  else
  {
    v14 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v16, v4, 8);
    v5 = __src;
    v6 = 8 * v4;
  }
  bzero(v5, v6);
LABEL_6:
  v14 = v4;
  v7 = *(_QWORD *)(a1 + 16);
  if (v7 >= *(_QWORD *)(a1 + 24))
  {
    v9 = std::vector<llvm::SmallVector<long long,8u>>::__emplace_back_slow_path<llvm::SmallVector<long long,32u>>((char **)(a1 + 8), (uint64_t)&__src);
    *(_QWORD *)(a1 + 16) = v9;
    v10 = __src;
    if (__src == v16)
      goto LABEL_20;
    goto LABEL_19;
  }
  *(_QWORD *)v7 = v7 + 16;
  *(_QWORD *)(v7 + 8) = 0x800000000;
  if ((void **)v7 != &__src)
  {
    v8 = v14;
    if (v14)
    {
      if (__src == v16)
      {
        v11 = v14;
        if (v14 < 9
          || (llvm::SmallVectorBase<unsigned int>::grow_pod(v7, (void *)(v7 + 16), v14, 8), (v11 = v14) != 0))
        {
          memcpy(*(void **)v7, __src, 8 * v11);
        }
        *(_DWORD *)(v7 + 8) = v8;
      }
      else
      {
        *(_QWORD *)v7 = __src;
        *(_DWORD *)(v7 + 8) = v8;
        *(_DWORD *)(v7 + 12) = v15;
        __src = v16;
        v15 = 0;
      }
      v14 = 0;
    }
  }
  v9 = (char *)(v7 + 80);
  *(_QWORD *)(a1 + 16) = v7 + 80;
  v10 = __src;
  if (__src != v16)
  {
LABEL_19:
    free(v10);
    v9 = *(char **)(a1 + 16);
  }
LABEL_20:
  *(_QWORD *)(*((_QWORD *)v9 - 10) + 8 * (*(_DWORD *)(a2 + 16) + *(_DWORD *)(a1 + 32))) = 1;
  return 1;
}

uint64_t mlir::SimpleAffineExprFlattener::visitConstantExpr(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _QWORD *v5;
  size_t v6;
  unint64_t v7;
  unsigned int v8;
  char *v9;
  void *v10;
  unsigned int v11;
  void *__src;
  unsigned int v14;
  int v15;
  _QWORD v16[33];

  v16[32] = *MEMORY[0x1E0C80C00];
  v4 = (*(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 36) + *(_DWORD *)(a1 + 40) + 1);
  __src = v16;
  v15 = 32;
  if (v4 < 0x21)
  {
    if (!(_DWORD)v4)
      goto LABEL_6;
    v6 = 8 * v4;
    v5 = v16;
  }
  else
  {
    v14 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v16, v4, 8);
    v5 = __src;
    v6 = 8 * v4;
  }
  bzero(v5, v6);
LABEL_6:
  v14 = v4;
  v7 = *(_QWORD *)(a1 + 16);
  if (v7 >= *(_QWORD *)(a1 + 24))
  {
    v9 = std::vector<llvm::SmallVector<long long,8u>>::__emplace_back_slow_path<llvm::SmallVector<long long,32u>>((char **)(a1 + 8), (uint64_t)&__src);
    *(_QWORD *)(a1 + 16) = v9;
    v10 = __src;
    if (__src == v16)
      goto LABEL_20;
    goto LABEL_19;
  }
  *(_QWORD *)v7 = v7 + 16;
  *(_QWORD *)(v7 + 8) = 0x800000000;
  if ((void **)v7 != &__src)
  {
    v8 = v14;
    if (v14)
    {
      if (__src == v16)
      {
        v11 = v14;
        if (v14 < 9
          || (llvm::SmallVectorBase<unsigned int>::grow_pod(v7, (void *)(v7 + 16), v14, 8), (v11 = v14) != 0))
        {
          memcpy(*(void **)v7, __src, 8 * v11);
        }
        *(_DWORD *)(v7 + 8) = v8;
      }
      else
      {
        *(_QWORD *)v7 = __src;
        *(_DWORD *)(v7 + 8) = v8;
        *(_DWORD *)(v7 + 12) = v15;
        __src = v16;
        v15 = 0;
      }
      v14 = 0;
    }
  }
  v9 = (char *)(v7 + 80);
  *(_QWORD *)(a1 + 16) = v7 + 80;
  v10 = __src;
  if (__src != v16)
  {
LABEL_19:
    free(v10);
    v9 = *(char **)(a1 + 16);
  }
LABEL_20:
  *(_QWORD *)(*((_QWORD *)v9 - 10)
            + 8 * (*(_DWORD *)(a1 + 36) + *(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 40))) = *(_QWORD *)(a2 + 16);
  return 1;
}

void mlir::SimpleAffineExprFlattener::addLocalFloorDivId(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;

  v7 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); v7 != i; v7 += 80)
  {
    while (1)
    {
      v10 = *(_QWORD *)v7;
      v11 = *(_QWORD *)v7
          + 8 * (*(_DWORD *)(a1 + 36) + *(_DWORD *)(a1 + 32))
          + 8 * *(unsigned int *)(a1 + 40);
      v12 = *(unsigned int *)(v7 + 8);
      if (*(_QWORD *)v7 + 8 * v12 == v11)
        break;
      if (v12 >= *(_DWORD *)(v7 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v7, (void *)(v7 + 16), v12 + 1, 8);
        v13 = *(_QWORD *)v7;
        v12 = *(unsigned int *)(v7 + 8);
      }
      else
      {
        v13 = *(_QWORD *)v7;
      }
      v14 = (_QWORD *)(v13 + 8 * ((v11 - v10) >> 3));
      v15 = (_QWORD *)(v13 + 8 * v12);
      *v15 = *(v15 - 1);
      if (v15 - 1 != v14)
      {
        memmove(v14 + 1, v14, (char *)(v15 - 1) - (char *)v14);
        LODWORD(v12) = *(_DWORD *)(v7 + 8);
      }
      *(_DWORD *)(v7 + 8) = v12 + 1;
      *v14 = 0;
      v7 += 80;
      if (v7 == i)
        goto LABEL_2;
    }
    if (v12 >= *(_DWORD *)(v7 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v7, (void *)(v7 + 16), v12 + 1, 8);
      v12 = *(unsigned int *)(v7 + 8);
      v10 = *(_QWORD *)v7;
    }
    *(_QWORD *)(v10 + 8 * v12) = 0;
    ++*(_DWORD *)(v7 + 8);
  }
LABEL_2:
  v9 = *(unsigned int *)(a1 + 56);
  if (v9 >= *(_DWORD *)(a1 + 60))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 48, (void *)(a1 + 64), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a1 + 56);
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v9) = a5;
  ++*(_DWORD *)(a1 + 56);
  ++*(_DWORD *)(a1 + 40);
}

void mlir::SimpleAffineExprFlattener::addLocalIdSemiAffine(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;

  v4 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); v4 != i; v4 += 80)
  {
    while (1)
    {
      v7 = *(_QWORD *)v4;
      v8 = *(_QWORD *)v4
         + 8 * (*(_DWORD *)(a1 + 36) + *(_DWORD *)(a1 + 32))
         + 8 * *(unsigned int *)(a1 + 40);
      v9 = *(unsigned int *)(v4 + 8);
      if (*(_QWORD *)v4 + 8 * v9 == v8)
        break;
      if (v9 >= *(_DWORD *)(v4 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v4 + 16), v9 + 1, 8);
        v10 = *(_QWORD *)v4;
        v9 = *(unsigned int *)(v4 + 8);
      }
      else
      {
        v10 = *(_QWORD *)v4;
      }
      v11 = (_QWORD *)(v10 + 8 * ((v8 - v7) >> 3));
      v12 = (_QWORD *)(v10 + 8 * v9);
      *v12 = *(v12 - 1);
      if (v12 - 1 != v11)
      {
        memmove(v11 + 1, v11, (char *)(v12 - 1) - (char *)v11);
        LODWORD(v9) = *(_DWORD *)(v4 + 8);
      }
      *(_DWORD *)(v4 + 8) = v9 + 1;
      *v11 = 0;
      v4 += 80;
      if (v4 == i)
        goto LABEL_2;
    }
    if (v9 >= *(_DWORD *)(v4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v4 + 16), v9 + 1, 8);
      v9 = *(unsigned int *)(v4 + 8);
      v7 = *(_QWORD *)v4;
    }
    *(_QWORD *)(v7 + 8 * v9) = 0;
    ++*(_DWORD *)(v4 + 8);
  }
LABEL_2:
  v6 = *(unsigned int *)(a1 + 56);
  if (v6 >= *(_DWORD *)(a1 + 60))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 48, (void *)(a1 + 64), v6 + 1, 8);
    LODWORD(v6) = *(_DWORD *)(a1 + 56);
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * v6) = a2;
  ++*(_DWORD *)(a1 + 56);
  ++*(_DWORD *)(a1 + 40);
}

mlir::MLIRContext **mlir::simplifyAffineExpr(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3)
{
  mlir::MLIRContext **AffineExprFromFlatForm;
  char v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  int v11;
  char *v12;
  char *v13;
  unint64_t *v14;
  mlir::MLIRContext *v15;
  unsigned __int8 **AffineUniquer;
  unsigned int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned __int8 **v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unsigned __int8 **v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  char *v60;
  char *v61;
  int v62;
  int v63;
  uint64_t v64;
  int *v65;
  int v66;
  int v67;
  unint64_t v69;
  mlir::MLIRContext *v70;
  unsigned __int8 **v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  int v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int *v80;
  int v81;
  int v82;
  mlir::MLIRContext **v84;
  unsigned int v85;
  int v86;
  int v87;
  int *v88;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unsigned int v93;
  unsigned int v94;
  int *v95;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  mlir::MLIRContext *v100;
  unsigned __int8 **v101;
  uint64_t v102;
  uint64_t v103;
  mlir::MLIRContext *v104;
  unsigned __int8 **v105;
  uint64_t v106;
  char *v107;
  char *v108;
  void *v109;
  char *v110;
  char *v111;
  uint64_t v113;
  unsigned int v114;
  uint64_t v115;
  unsigned int v116;
  int v117;
  int v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  mlir::MLIRContext *v124;
  mlir::MLIRContext **v125;
  mlir::MLIRContext **v126;
  void *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  llvm *v131[2];
  unsigned int v132;
  llvm *v133[2];
  int v134;
  mlir::MLIRContext **v135;
  unint64_t v136;
  _QWORD v137[2];
  unint64_t v138;
  uint64_t v139;
  void (**v140)(mlir::SimpleAffineExprFlattener *__hidden);
  void *__p;
  char *v142;
  char *v143;
  int v144;
  int v145;
  int v146;
  void *v147;
  int v148[2];
  _BYTE v149[32];
  _QWORD *v150;
  uint64_t v151;
  _QWORD v152[10];

  AffineExprFromFlatForm = a1;
  v152[8] = *MEMORY[0x1E0C80C00];
  v125 = a1;
  mlir::AffineExpr::isPureAffine((mlir::AffineExpr *)&v125);
  if ((v6 & 1) == 0)
  {
    AffineExprFromFlatForm = (mlir::MLIRContext **)simplifySemiAffine((uint64_t)AffineExprFromFlatForm, a2, a3);
    v125 = AffineExprFromFlatForm;
  }
  v140 = off_1E0E47DA0;
  v144 = a2;
  v145 = a3;
  v146 = 0;
  v147 = v149;
  *(_QWORD *)v148 = 0x400000000;
  __p = operator new(0x280uLL);
  v142 = (char *)__p;
  v143 = (char *)__p + 640;
  mlir::AffineExprVisitor<mlir::SimpleAffineExprFlattener,mlir::LogicalResult>::walkPostOrder((uint64_t)&v140, (uint64_t)AffineExprFromFlatForm);
  if (v7)
  {
    v8 = *((_QWORD *)v142 - 10);
    v9 = *((unsigned int *)v142 - 18);
    mlir::AffineExpr::isPureAffine((mlir::AffineExpr *)&v125);
    if ((v10 & 1) != 0
      || AffineExprFromFlatForm != mlir::getAffineExprFromFlatForm(v8, v9, a2, a3, (unint64_t *)v147, v148[0], *AffineExprFromFlatForm))
    {
      mlir::AffineExpr::isPureAffine((mlir::AffineExpr *)&v125);
      if (v11)
      {
        AffineExprFromFlatForm = mlir::getAffineExprFromFlatForm(v8, v9, a2, a3, (unint64_t *)v147, v148[0], *AffineExprFromFlatForm);
        v13 = v142 - 80;
        v12 = (char *)*((_QWORD *)v142 - 10);
        if (v12 != v142 - 64)
          free(v12);
        v142 = v13;
        goto LABEL_106;
      }
      v14 = (unint64_t *)v147;
      v119 = v148[0];
      v15 = *AffineExprFromFlatForm;
      v150 = 0;
      v127 = v15;
      v124 = v15;
      AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v15);
      v135 = (mlir::MLIRContext **)mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v127, &v150);
      v133[0] = 0;
      v133[1] = 0;
      v134 = 0;
      v131[0] = 0;
      v131[1] = 0;
      v132 = 0;
      v150 = v152;
      v151 = 0x800000000;
      v17 = a3 + a2;
      v123 = v8;
      v116 = a2;
      v115 = v9;
      v114 = a3 + a2;
      if ((int)a3 + (int)a2 <= a2)
      {
        v19 = 0;
        v28 = a2;
      }
      else
      {
        v18 = 0;
        v19 = 0;
        v20 = a3;
        if (a2 > a3)
          LODWORD(a3) = a2;
        v121 = a2;
        v117 = v20;
        v21 = v20;
        v22 = v8 + 8 * a2;
        do
        {
          v24 = *(_QWORD *)(v22 + 8 * v18);
          if (v24)
          {
            LODWORD(v136) = v18;
            v127 = v124;
            v25 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v124);
            LODWORD(v138) = 7;
            v26 = mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(v25, (const char *)llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>, (unint64_t)&v127, (unsigned int *)&v138, (unsigned int *)&v136);
            v27 = v151;
            if (v151 >= (unint64_t)HIDWORD(v151))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v150, v152, v151 + 1, 8);
              v27 = v151;
            }
            v23 = v18 | ((unint64_t)(v19 + a3) << 32);
            v150[v27] = v23;
            ++v19;
            LODWORD(v151) = v151 + 1;
            v136 = v23;
            v137[0] = v24;
            llvm::DenseMapBase<llvm::DenseMap<std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>,std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>::try_emplace<long long>((uint64_t)v131, (int *)&v136, v137, (uint64_t)&v127);
            v136 = v23;
            v137[0] = v26;
            llvm::DenseMapBase<llvm::DenseMap<std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>,std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>::try_emplace<long long>((uint64_t)v133, (int *)&v136, v137, (uint64_t)&v127);
          }
          ++v18;
        }
        while (v21 != (_DWORD)v18);
        v17 = v114;
        v28 = v121;
        LODWORD(a3) = v117;
      }
      v29 = ~(v28 + a3) + v9;
      v127 = &v130;
      v129 = 4;
      if (v29 < 5)
      {
        if (!v29)
        {
LABEL_25:
          v128 = ~(v28 + a3) + v9;
          v31 = v123 + 8 * v17;
          v122 = v28;
          if ((_DWORD)v119)
          {
            v32 = 0;
            v33 = v116;
            if (v116 <= a3)
              v33 = a3;
            v118 = v33;
            v34 = &v139;
            v35 = 8 * v119;
            v120 = 0xFFFFFFFFLL;
            v113 = v123 + 8 * v17;
            while (1)
            {
              v37 = *(_QWORD *)(v31 + 8 * v32);
              if (!v37)
                goto LABEL_32;
              v38 = v14[v32];
              v39 = *(_QWORD *)(v38 + 16);
              v40 = *(_DWORD *)(v39 + 8);
              if ((v40 & 0xFFFFFFFE) != 6)
                goto LABEL_32;
              v41 = *(_QWORD *)(v38 + 24);
              v42 = *(_DWORD *)(v41 + 8);
              if ((v42 - 6) >= 2)
                break;
              v43 = *(unsigned int *)(v39 + 16);
              v44 = v151;
              if (v40 == 6)
              {
                v45 = v34;
                v46 = *(unsigned int *)(v41 + 16);
                if (v151 >= (unint64_t)HIDWORD(v151))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v150, v152, v151 + 1, 8);
                  v44 = v151;
                }
                v47 = v43 | (v46 << 32);
                v150[v44] = v47;
                LODWORD(v151) = v151 + 1;
                v138 = v47;
                v139 = v37;
                v34 = v45;
                llvm::DenseMapBase<llvm::DenseMap<std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>,std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>::try_emplace<long long>((uint64_t)v131, (int *)&v138, v45, (uint64_t)&v136);
                v138 = v47;
                v139 = v38;
                llvm::DenseMapBase<llvm::DenseMap<std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>,std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>::try_emplace<long long>((uint64_t)v133, (int *)&v138, v45, (uint64_t)&v136);
                v31 = v113;
                goto LABEL_31;
              }
              if (v151 >= (unint64_t)HIDWORD(v151))
                goto LABEL_46;
LABEL_30:
              v36 = v43 | ((unint64_t)(v19 + v118) << 32);
              v150[v44] = v36;
              ++v19;
              LODWORD(v151) = v151 + 1;
              v138 = v36;
              v139 = v37;
              llvm::DenseMapBase<llvm::DenseMap<std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>,std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>::try_emplace<long long>((uint64_t)v131, (int *)&v138, v34, (uint64_t)&v136);
              v138 = v36;
              v139 = v38;
              llvm::DenseMapBase<llvm::DenseMap<std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>,std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>::try_emplace<long long>((uint64_t)v133, (int *)&v138, v34, (uint64_t)&v136);
LABEL_31:
              *((_BYTE *)v127 + v32) = 1;
LABEL_32:
              ++v32;
              v35 -= 8;
              if (!v35)
                goto LABEL_48;
            }
            if (v42 != 5)
              goto LABEL_32;
            v43 = *(unsigned int *)(v39 + 16);
            if (v40 == 6)
            {
              v48 = v151;
              if (v151 >= (unint64_t)HIDWORD(v151))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v150, v152, v151 + 1, 8);
                v48 = v151;
              }
              v49 = v43 | (v120 << 32);
              v150[v48] = v49;
              LODWORD(v151) = v151 + 1;
              v138 = v49;
              v139 = v37;
              llvm::DenseMapBase<llvm::DenseMap<std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>,std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>::try_emplace<long long>((uint64_t)v131, (int *)&v138, v34, (uint64_t)&v136);
              v138 = v49;
              v139 = v38;
              llvm::DenseMapBase<llvm::DenseMap<std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>,std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>::try_emplace<long long>((uint64_t)v133, (int *)&v138, v34, (uint64_t)&v136);
              v120 = (v120 - 1);
              v28 = v122;
              goto LABEL_31;
            }
            v44 = v151;
            if (v151 < (unint64_t)HIDWORD(v151))
              goto LABEL_30;
LABEL_46:
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v150, v152, v44 + 1, 8);
            v44 = v151;
            goto LABEL_30;
          }
          v120 = 0xFFFFFFFFLL;
LABEL_48:
          v50 = v123;
          if (v116)
          {
            v51 = 0;
            v52 = v120;
            do
            {
              v54 = *(_QWORD *)(v50 + 8 * v51);
              if (v54)
              {
                LODWORD(v138) = v51;
                v136 = (unint64_t)v124;
                v55 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v124);
                LODWORD(v126) = 6;
                v56 = mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(v55, (const char *)llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>, (unint64_t)&v136, (unsigned int *)&v126, (unsigned int *)&v138);
                v57 = v151;
                if (v151 >= (unint64_t)HIDWORD(v151))
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v150, v152, v151 + 1, 8);
                  v57 = v151;
                }
                v53 = v51 | (v52 << 32);
                v150[v57] = v53;
                v52 = (v52 - 1);
                LODWORD(v151) = v151 + 1;
                v138 = v53;
                v139 = v54;
                llvm::DenseMapBase<llvm::DenseMap<std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>,std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>::try_emplace<long long>((uint64_t)v131, (int *)&v138, &v139, (uint64_t)&v136);
                v138 = v53;
                v139 = v56;
                llvm::DenseMapBase<llvm::DenseMap<std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>,std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>::try_emplace<long long>((uint64_t)v133, (int *)&v138, &v139, (uint64_t)&v136);
                v28 = v122;
                v50 = v123;
              }
              ++v51;
            }
            while (v28 != v51);
          }
          v58 = 126 - 2 * __clz(v151);
          if ((_DWORD)v151)
            v59 = v58;
          else
            v59 = 0;
          std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *,false>((uint64_t)v150, (unsigned int *)&v150[v151], (uint64_t)&v136, v59, 1);
          if (!(_DWORD)v151)
          {
LABEL_91:
            v97 = (v115 - 1);
            if (v114 < v97)
            {
              v98 = 0;
              v99 = v97 - v114;
              do
              {
                if (*(_QWORD *)(v31 + 8 * v98) && !*((_BYTE *)v127 + v98))
                {
                  v100 = *(mlir::MLIRContext **)*v14;
                  v136 = *(_QWORD *)(v31 + 8 * v98);
                  v138 = (unint64_t)v100;
                  v101 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v100);
                  v102 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v101, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v138, &v136);
                  v103 = mlir::AffineExpr::operator*(v14, v102);
                  v135 = (mlir::MLIRContext **)mlir::AffineExpr::operator+((unint64_t *)&v135, v103);
                }
                ++v98;
                ++v14;
              }
              while (v99 != v98);
            }
            if (*(_QWORD *)(v50 + 8 * v115 - 8))
            {
              v104 = *v135;
              v136 = *(_QWORD *)(v50 + 8 * v115 - 8);
              v138 = (unint64_t)v104;
              v105 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v104);
              v106 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v105, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v138, &v136);
              v135 = (mlir::MLIRContext **)mlir::AffineExpr::operator+((unint64_t *)&v135, v106);
            }
            if (v127 != &v130)
              free(v127);
            if (v150 != v152)
              free(v150);
            llvm::deallocate_buffer(v131[0], (void *)(16 * v132));
          }
          v60 = (char *)v150;
          v61 = (char *)&v150[v151];
          while (1)
          {
            v74 = *(_DWORD *)v60;
            v75 = *((_DWORD *)v60 + 1);
            if (!v134)
              goto LABEL_84;
            v76 = ((37 * v75) | ((unint64_t)(37 * v74) << 32))
                + ~((unint64_t)(37 * v75) << 32);
            v77 = (v76 ^ (v76 >> 22)) + ~((v76 ^ (v76 >> 22)) << 13);
            v78 = (9 * (v77 ^ (v77 >> 8))) ^ ((9 * (v77 ^ (v77 >> 8))) >> 15);
            v79 = (v134 - 1) & (((v78 + ~(v78 << 27)) >> 31) ^ ((_DWORD)v78 + ~((_DWORD)v78 << 27)));
            v80 = (int *)((char *)v133[0] + 16 * v79);
            v82 = *v80;
            v81 = v80[1];
            if (v74 != v82 || v75 != v81)
              break;
LABEL_75:
            v84 = (mlir::MLIRContext **)*((_QWORD *)v133[0] + 2 * v79 + 1);
            v126 = v84;
            v85 = v132;
            if (!v132)
              goto LABEL_67;
LABEL_85:
            v90 = ((37 * v75) | ((unint64_t)(37 * v74) << 32))
                + ~((unint64_t)(37 * v75) << 32);
            v91 = (v90 ^ (v90 >> 22)) + ~((v90 ^ (v90 >> 22)) << 13);
            v92 = (9 * (v91 ^ (v91 >> 8))) ^ ((9 * (v91 ^ (v91 >> 8))) >> 15);
            v93 = ((v92 + ~(v92 << 27)) >> 31) ^ (v92 + ~((_DWORD)v92 << 27));
            v94 = v85 - 1;
            v64 = (v85 - 1) & v93;
            v95 = (int *)((char *)v131[0] + 16 * v64);
            v67 = *v95;
            v66 = v95[1];
            if (v74 == v67 && v75 == v66)
            {
LABEL_90:
              v69 = *((_QWORD *)v131[0] + 2 * v64 + 1);
              goto LABEL_68;
            }
            v63 = 1;
            while (v67 != -1 || v66 != 0x7FFFFFFF)
            {
              v62 = v64 + v63++;
              v64 = v62 & v94;
              v65 = (int *)((char *)v131[0] + 16 * v64);
              v67 = *v65;
              v66 = v65[1];
              if (v74 == v67 && v75 == v66)
                goto LABEL_90;
            }
LABEL_67:
            v69 = 0;
LABEL_68:
            v70 = *v84;
            v136 = v69;
            v138 = (unint64_t)v70;
            v71 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v70);
            v72 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v71, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v138, &v136);
            v73 = mlir::AffineExpr::operator*((unint64_t *)&v126, v72);
            v135 = (mlir::MLIRContext **)mlir::AffineExpr::operator+((unint64_t *)&v135, v73);
            v60 += 8;
            if (v60 == v61)
              goto LABEL_91;
          }
          v86 = 1;
          while (v82 != -1 || v81 != 0x7FFFFFFF)
          {
            v87 = v79 + v86++;
            v79 = v87 & (v134 - 1);
            v88 = (int *)((char *)v133[0] + 16 * v79);
            v82 = *v88;
            v81 = v88[1];
            if (v74 == v82 && v75 == v81)
              goto LABEL_75;
          }
LABEL_84:
          v84 = 0;
          v126 = 0;
          v85 = v132;
          if (!v132)
            goto LABEL_67;
          goto LABEL_85;
        }
        v30 = &v130;
      }
      else
      {
        v128 = 0;
        llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v127, &v130, ~(v28 + a3) + v9, 1);
        v30 = (uint64_t *)v127;
      }
      bzero(v30, ~(v28 + a3) + v9);
      goto LABEL_25;
    }
  }
LABEL_106:
  v140 = off_1E0E47DA0;
  if (v147 != v149)
    free(v147);
  v107 = (char *)__p;
  if (__p)
  {
    v108 = v142;
    v109 = __p;
    if (v142 != __p)
    {
      do
      {
        v111 = (char *)*((_QWORD *)v108 - 10);
        v108 -= 80;
        v110 = v111;
        if (v108 + 16 != v111)
          free(v110);
      }
      while (v108 != v107);
      v109 = __p;
    }
    v142 = v107;
    operator delete(v109);
  }
  return AffineExprFromFlatForm;
}

uint64_t simplifySemiAffine(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  int v18;
  BOOL v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  unsigned __int8 **v23;
  uint64_t v24;
  unsigned __int8 **v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  unsigned __int8 **AffineUniquer;
  uint64_t v31;
  int v32;
  char v33;
  int v34;
  mlir::MLIRContext **v36;
  uint64_t v37;
  mlir::MLIRContext **v38;
  mlir::MLIRContext *v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  _QWORD v43[7];

  v43[6] = *MEMORY[0x1E0C80C00];
  v3 = *(_DWORD *)(a1 + 8);
  v6 = a1;
  if (((1 << v3) & 0x1C) != 0)
  {
    v10 = simplifySemiAffine(*(_QWORD *)(a1 + 16), a2, a3);
    v11 = simplifySemiAffine(*(_QWORD *)(v6 + 24), a2, a3);
    v41 = v43;
    v42 = 0x600000000;
    v36 = (mlir::MLIRContext **)v10;
    getSummandExprs(v10, (uint64_t)&v41);
    v12 = v42;
    if (!(_DWORD)v42)
    {
LABEL_42:
      v14 = 0;
LABEL_43:
      if (v41 != v43)
        free(v41);
      if (v14)
        goto LABEL_46;
      v31 = simplifySemiAffine(*(_QWORD *)(v6 + 24), a2, a3);
      if (!v31 || *(_DWORD *)(v31 + 8) != 7)
      {
        v34 = *(_DWORD *)(v6 + 8);
        v41 = v36;
        switch(v34)
        {
          case 0:
LABEL_54:
            v9 = mlir::AffineExpr::operator+((unint64_t *)&v41, v11);
            break;
          case 1:
LABEL_55:
            v8 = v11;
            return mlir::AffineExpr::operator*((unint64_t *)&v41, v8);
          case 3:
LABEL_59:
            v9 = mlir::AffineExpr::floorDiv((mlir::MLIRContext ***)&v41, v11);
            break;
          case 4:
LABEL_60:
            v9 = mlir::AffineExpr::ceilDiv((unint64_t *)&v41, v11);
            break;
          default:
LABEL_57:
            v8 = v11;
            return mlir::AffineExpr::operator%((unint64_t *)&v41, v8);
        }
        return v9;
      }
      v32 = *(_DWORD *)(v6 + 8);
      isDivisibleBySymbol(*(_QWORD *)(v6 + 16));
      if ((v33 & 1) == 0)
      {
        v41 = v36;
        switch(v32)
        {
          case 0:
            goto LABEL_54;
          case 1:
            goto LABEL_55;
          case 3:
            goto LABEL_59;
          case 4:
            goto LABEL_60;
          default:
            goto LABEL_57;
        }
      }
      if (v32 == 2)
      {
LABEL_46:
        v40 = *(_QWORD *)v6;
        v41 = 0;
        AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer((mlir::MLIRContext *)v40);
        return mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v40, &v41);
      }
      else
      {
        symbolicDivide((uint64_t)v36);
      }
      return v9;
    }
    v13 = 0;
    v14 = 1;
    while (1)
    {
      v15 = *((_QWORD *)v41 + v13);
      if (v15)
        v16 = *(_DWORD *)(v15 + 8) == 1;
      else
        v16 = 0;
      if (!v16)
        goto LABEL_9;
      v17 = *(_QWORD *)(v15 + 16);
      v18 = *(_DWORD *)(v17 + 8);
      if (v17)
        v19 = v18 == 5;
      else
        v19 = 0;
      if (v19 && *(_QWORD *)(v17 + 16) == -1)
      {
        v17 = *(_QWORD *)(v15 + 24);
        if (*(_DWORD *)(v17 + 8) != 2)
          goto LABEL_9;
      }
      else
      {
        v20 = *(_QWORD *)(v15 + 24);
        if (v20)
          v21 = *(_DWORD *)(v20 + 8) == 5;
        else
          v21 = 0;
        if (!v21 || *(_QWORD *)(v20 + 16) != -1 || v18 != 2)
          goto LABEL_9;
      }
      if (*(_QWORD *)(v17 + 24) == v11)
      {
        v22 = v11;
        v39 = *v36;
        v40 = 0;
        v23 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v39);
        v24 = 0;
        v37 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v23, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v39, &v40);
        do
        {
          if (v13 != v24)
            v37 = mlir::AffineExpr::operator+((unint64_t *)&v37, *((_QWORD *)v41 + v24));
          ++v24;
        }
        while (v12 != v24);
        v38 = *(mlir::MLIRContext ***)(v17 + 16);
        v39 = *v38;
        v40 = -1;
        v25 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v39);
        v26 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v25, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v39, &v40);
        v27 = mlir::AffineExpr::operator*((unint64_t *)&v38, v26);
        v37 = mlir::AffineExpr::operator+((unint64_t *)&v37, v27);
        v28 = mlir::simplifyAffineExpr(v37, a2, a3);
        if (v28)
          v29 = *(_DWORD *)(v28 + 8) == 5;
        else
          v29 = 0;
        if (v29 && !*(_QWORD *)(v28 + 16))
        {
          v11 = v22;
          goto LABEL_43;
        }
        v11 = v22;
      }
LABEL_9:
      v14 = ++v13 < v12;
      if (v13 == v12)
        goto LABEL_42;
    }
  }
  if (((1 << v3) & 0xE0) == 0)
  {
    v7 = (void *)simplifySemiAffine(*(_QWORD *)(a1 + 16), a2, a3);
    v8 = simplifySemiAffine(*(_QWORD *)(v6 + 24), a2, a3);
    v41 = v7;
    if (v3 == 1)
      return mlir::AffineExpr::operator*((unint64_t *)&v41, v8);
    if (v3)
      return mlir::AffineExpr::operator%((unint64_t *)&v41, v8);
    return mlir::AffineExpr::operator+((unint64_t *)&v41, v8);
  }
  return v6;
}

void mlir::AffineExprVisitor<mlir::SimpleAffineExprFlattener,mlir::LogicalResult>::walkPostOrder(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }
}

uint64_t sub_1803A3C64()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  int64x2_t *v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  uint64_t v8;
  int64x2_t *v9;
  int64x2_t *v10;
  uint64_t v11;
  int64x2_t v12;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t *v17;
  uint64_t v18;

  if (!mlir::AffineExprVisitor<mlir::SimpleAffineExprFlattener,mlir::LogicalResult>::walkOperandsPostOrder(v0, v1))
    return 0;
  v2 = *(_QWORD *)(v0 + 16);
  v4 = v2 - 80;
  v3 = *(int64x2_t **)(v2 - 80);
  v5 = *(unsigned int *)(v2 - 72);
  if ((_DWORD)v5)
  {
    v6 = *(_QWORD *)(v2 - 160);
    if (v5 < 6
      || (v6 < (unint64_t)v3 + 8 * v5 ? (v7 = (unint64_t)v3 >= v6 + 8 * v5) : (v7 = 1), !v7))
    {
      v8 = 0;
LABEL_15:
      v14 = v5 - v8;
      v15 = v8;
      v16 = (_QWORD *)(v6 + v15 * 8);
      v17 = &v3->i64[v15];
      do
      {
        v18 = *v17++;
        *v16++ += v18;
        --v14;
      }
      while (v14);
      goto LABEL_17;
    }
    v8 = v5 & 0xFFFFFFFC;
    v9 = v3 + 1;
    v10 = (int64x2_t *)(v6 + 16);
    v11 = v8;
    do
    {
      v12 = vaddq_s64(*v10, *v9);
      v10[-1] = vaddq_s64(v10[-1], v9[-1]);
      *v10 = v12;
      v9 += 2;
      v10 += 2;
      v11 -= 4;
    }
    while (v11);
    if (v8 != v5)
      goto LABEL_15;
  }
LABEL_17:
  if (v3 != (int64x2_t *)(v2 - 64))
    free(v3);
  *(_QWORD *)(v0 + 16) = v4;
  return 1;
}

void mlir::SimpleAffineExprFlattener::~SimpleAffineExprFlattener(mlir::SimpleAffineExprFlattener *this)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;

  *(_QWORD *)this = off_1E0E47DA0;
  v2 = (char *)*((_QWORD *)this + 6);
  if (v2 != (char *)this + 64)
    free(v2);
  v3 = *((_QWORD *)this + 1);
  if (v3)
  {
    v4 = *((_QWORD *)this + 2);
    v5 = (void *)*((_QWORD *)this + 1);
    if (v4 != v3)
    {
      do
      {
        v7 = *(void **)(v4 - 80);
        v4 -= 80;
        v6 = v7;
        if ((void *)(v4 + 16) != v7)
          free(v6);
      }
      while (v4 != v3);
      v5 = (void *)*((_QWORD *)this + 1);
    }
    *((_QWORD *)this + 2) = v3;
    operator delete(v5);
  }
}

{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;

  *(_QWORD *)this = off_1E0E47DA0;
  v2 = (char *)*((_QWORD *)this + 6);
  if (v2 != (char *)this + 64)
    free(v2);
  v3 = *((_QWORD *)this + 1);
  if (v3)
  {
    v4 = *((_QWORD *)this + 2);
    v5 = (void *)*((_QWORD *)this + 1);
    if (v4 != v3)
    {
      do
      {
        v7 = *(void **)(v4 - 80);
        v4 -= 80;
        v6 = v7;
        if ((void *)(v4 + 16) != v7)
          free(v6);
      }
      while (v4 != v3);
      v5 = (void *)*((_QWORD *)this + 1);
    }
    *((_QWORD *)this + 2) = v3;
    operator delete(v5);
  }
  operator delete(this);
}

unint64_t mlir::getBoundForAffineExpr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v14;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t BoundForAffineExpr;
  uint64_t v32;
  char v33;
  char v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  char v38;
  unint64_t v39;
  uint64_t v40;
  char v41;
  void *v42;
  char *v43;
  char *v44;
  void *v45;
  char *v46;
  char *v47;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _BYTE *v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  void (**v61)(mlir::SimpleAffineExprFlattener *__hidden);
  void *__p;
  char *v63;
  char *v64;
  int v65;
  int v66;
  int v67;
  void *v68;
  uint64_t v69;
  _QWORD v70[5];

  v70[4] = *MEMORY[0x1E0C80C00];
  if (!a1 || (v14 = *(_DWORD *)(a1 + 8), v14 > 4))
  {
LABEL_32:
    v61 = off_1E0E47DA0;
    v65 = a2;
    v66 = a3;
    v67 = 0;
    v68 = v70;
    v69 = 0x400000000;
    __p = operator new(0x280uLL);
    v63 = (char *)__p;
    v64 = (char *)__p + 640;
    mlir::AffineExprVisitor<mlir::SimpleAffineExprFlattener,mlir::LogicalResult>::walkPostOrder((uint64_t)&v61, a1);
    if (!v41 || v67)
    {
LABEL_34:
      LOBYTE(v17) = 0;
      v19 = 0;
      v61 = off_1E0E47DA0;
      v42 = v68;
      if (v68 == v70)
        goto LABEL_36;
      goto LABEL_35;
    }
    v49 = (a3 + a2);
    if (!((_DWORD)a3 + (_DWORD)a2))
    {
      v51 = 0;
LABEL_64:
      v17 = *(_QWORD *)(*((_QWORD *)v63 - 10) + 8 * *((unsigned int *)v63 - 18) - 8) + v51;
      v19 = v17 & 0xFFFFFFFFFFFFFF00;
      v61 = off_1E0E47DA0;
      v42 = v68;
      if (v68 == v70)
        goto LABEL_36;
LABEL_35:
      free(v42);
LABEL_36:
      v43 = (char *)__p;
      if (__p)
      {
        v44 = v63;
        v45 = __p;
        if (v63 != __p)
        {
          do
          {
            v47 = (char *)*((_QWORD *)v44 - 10);
            v44 -= 80;
            v46 = v47;
            if (v44 + 16 != v47)
              free(v46);
          }
          while (v44 != v43);
          v45 = __p;
        }
        v63 = v43;
        operator delete(v45);
      }
      return v19 & 0xFFFFFFFFFFFFFF00 | v17;
    }
    v50 = 0;
    v51 = 0;
    if ((_DWORD)a8)
      v52 = a4;
    else
      v52 = a6;
    if ((_DWORD)a8)
      v53 = a6;
    else
      v53 = a4;
    v54 = (_BYTE *)(v53 + 8);
    v55 = (uint64_t *)*((_QWORD *)v63 - 10);
    while (1)
    {
      v57 = *v55++;
      v56 = v57;
      if (v57 < 1)
      {
        if ((v56 & 0x8000000000000000) == 0)
          goto LABEL_54;
        v58 = (_QWORD *)v52;
        if (!*(_BYTE *)(v52 + 8))
          goto LABEL_34;
      }
      else
      {
        if (!*v54)
          goto LABEL_34;
        v58 = (_QWORD *)(v53 + 16 * v50);
      }
      v51 += *v58 * v56;
LABEL_54:
      ++v50;
      v52 += 16;
      v54 += 16;
      if (!--v49)
        goto LABEL_64;
    }
  }
  if (v14 == 2)
  {
    v29 = *(_QWORD *)(a1 + 24);
    if (v29)
    {
      if (*(_DWORD *)(v29 + 8) == 5)
      {
        v30 = *(_QWORD *)(v29 + 16);
        if (v30 >= 1)
        {
          BoundForAffineExpr = mlir::getBoundForAffineExpr(*(_QWORD *)(a1 + 16), a2, a3, a4, a5, a6, a7, 0);
          v32 = a8;
          v34 = v33;
          v35 = a6;
          v36 = v32;
          v37 = mlir::getBoundForAffineExpr(*(_QWORD *)(a1 + 16), a2, a3, a4, a5, v35, a7, v32);
          if (v38
            && v34
            && ((v39 = (unint64_t)v30 >> 63, BoundForAffineExpr)
             && (unint64_t)BoundForAffineExpr >> 63 != (_DWORD)v39
              ? (v40 = ~(~BoundForAffineExpr / v30))
              : (v40 = BoundForAffineExpr / v30),
                v37 && (unint64_t)v37 >> 63 != (_DWORD)v39 ? (v59 = ~(~v37 / v30)) : (v59 = v37 / v30),
                v40 == v59))
          {
            if (v36)
              v60 = v37;
            else
              v60 = BoundForAffineExpr;
            v17 = (v30 & ((v60 % v30) >> 63)) + v60 % v30;
          }
          else if (v36)
          {
            v17 = v30 - 1;
          }
          else
          {
            v17 = 0;
          }
          goto LABEL_80;
        }
      }
    }
    goto LABEL_32;
  }
  if (v14 != 4)
  {
    if (v14 == 3)
    {
      LOBYTE(v17) = 0;
      v18 = *(_QWORD *)(a1 + 24);
      if (v18)
      {
        v19 = 0;
        if (*(_DWORD *)(v18 + 8) == 5)
        {
          if (*(uint64_t *)(v18 + 16) >= 1)
          {
            v20 = *(_QWORD *)(a1 + 24);
            v21 = mlir::getBoundForAffineExpr(*(_QWORD *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
            if (v22)
            {
              v23 = *(_QWORD *)(v20 + 16);
              v24 = -1;
              if (v23 < 0)
                v24 = 1;
              if (v21 && (unint64_t)v21 >> 63 != (unint64_t)v23 >> 63)
              {
                v17 = ~((v24 - v21) / v23);
LABEL_80:
                v19 = v17 & 0xFFFFFFFFFFFFFF00;
                return v19 & 0xFFFFFFFFFFFFFF00 | v17;
              }
LABEL_66:
              v17 = v21 / v23;
              goto LABEL_80;
            }
          }
LABEL_61:
          LOBYTE(v17) = 0;
          v19 = 0;
          return v19 & 0xFFFFFFFFFFFFFF00 | v17;
        }
        return v19 & 0xFFFFFFFFFFFFFF00 | v17;
      }
LABEL_62:
      v19 = 0;
      return v19 & 0xFFFFFFFFFFFFFF00 | v17;
    }
    goto LABEL_32;
  }
  LOBYTE(v17) = 0;
  v25 = *(_QWORD *)(a1 + 24);
  if (!v25)
    goto LABEL_62;
  v19 = 0;
  if (*(_DWORD *)(v25 + 8) == 5)
  {
    if (*(uint64_t *)(v25 + 16) >= 1)
    {
      v26 = *(_QWORD *)(a1 + 24);
      v21 = mlir::getBoundForAffineExpr(*(_QWORD *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
      if (v27)
      {
        v23 = *(_QWORD *)(v26 + 16);
        v28 = v21 - 1;
        if (v21 && v21 < 1 != v23 > 0)
        {
          if (v23 <= 0)
            v28 = v21 + 1;
          v17 = v28 / v23 + 1;
          goto LABEL_80;
        }
        goto LABEL_66;
      }
    }
    goto LABEL_61;
  }
  return v19 & 0xFFFFFFFFFFFFFF00 | v17;
}

uint64_t mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(unsigned __int8 **a1, const char *a2, unint64_t a3, unsigned int *a4, unsigned int *a5)
{
  uint64_t *v5;
  unsigned __int8 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  int v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  const char *v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  const char *v24;
  unint64_t v25;
  unsigned int *v26;
  unsigned int *v27;
  unsigned __int8 **v28;
  _QWORD v29[2];
  uint64_t *v30;
  uint64_t v31;
  const char *v32;
  unint64_t v33;

  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v6 & 1) == 0)
  {
    v27 = a5;
    v28 = a1;
    v25 = a3;
    v26 = a4;
    v24 = a2;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    a2 = v24;
    a3 = v25;
    a4 = v26;
    a5 = v27;
    v16 = v15;
    a1 = v28;
    if (v16)
    {
      v32 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::detail::AffineDimExprStorage]";
      v33 = 84;
      v17 = llvm::StringRef::find((uint64_t *)&v32, "DesiredTypeName = ", 0x12uLL, 0);
      if (v33 >= v17)
        v18 = v17;
      else
        v18 = v33;
      v19 = &v32[v18];
      v20 = v33 - v18;
      if (v33 - v18 >= 0x12)
        v21 = 18;
      else
        v21 = v33 - v18;
      v22 = v20 - v21;
      if (v22 >= v22 - 1)
        v23 = v22 - 1;
      else
        v23 = v22;
      mlir::detail::TypeIDResolver<mlir::detail::AffineDimExprStorage,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v19[v21], v23);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a2 = v24;
      a3 = v25;
      a4 = v26;
      a5 = v27;
      a1 = v28;
    }
  }
  v7 = v5[130];
  v32 = a2;
  v33 = a3;
  v8 = *a4;
  v9 = *a5;
  v10 = v8 | (v9 << 32);
  v11 = ((37 * v9) | ((unint64_t)(37 * v8) << 32))
      + ~((unint64_t)(37 * v9) << 32);
  v12 = (v11 ^ (v11 >> 22)) + ~((v11 ^ (v11 >> 22)) << 13);
  v13 = (9 * (v12 ^ (v12 >> 8))) ^ ((9 * (v12 ^ (v12 >> 8))) >> 15);
  v30 = &v31;
  v31 = v10;
  v29[0] = &v31;
  v29[1] = &v32;
  return mlir::StorageUniquer::getParametricStorageTypeImpl(a1, v7, ((v13 + ~(v13 << 27)) >> 31) ^ (v13 + ~((_DWORD)v13 << 27)), (uint64_t (*)(uint64_t))llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::detail::AffineDimExprStorage * mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>,mlir::TypeID,unsigned int,unsigned int &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, (uint64_t)&v30, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::detail::AffineDimExprStorage * mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>,mlir::TypeID,unsigned int,unsigned int &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, (uint64_t)v29);
}

BOOL llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::detail::AffineDimExprStorage * mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>,mlir::TypeID,unsigned int,unsigned int &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 8) == **(_DWORD **)a1 && *(_DWORD *)(a2 + 16) == *(_DWORD *)(*(_QWORD *)a1 + 4);
}

unint64_t llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::detail::AffineDimExprStorage * mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>,mlir::TypeID,unsigned int,unsigned int &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t a1, uint64_t a2)
{
  _DWORD *v4;
  BOOL v5;
  unsigned int v6;
  uint64_t v7;
  char *buffer;
  uint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;

  v4 = *(_DWORD **)a1;
  *(_QWORD *)(a2 + 80) += 24;
  if (*(_QWORD *)a2)
    v5 = ((*(_QWORD *)a2 + 7) & 0xFFFFFFFFFFFFFFF8) - *(_QWORD *)a2 + 24 > *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  else
    v5 = 1;
  if (v5)
  {
    v6 = *(_DWORD *)(a2 + 24) >> 7;
    if (v6 >= 0x1E)
      LOBYTE(v6) = 30;
    v7 = 4096 << v6;
    buffer = (char *)llvm::allocate_buffer(4096 << v6, (std::align_val_t)8uLL);
    v9 = *(unsigned int *)(a2 + 24);
    if (v9 >= *(_DWORD *)(a2 + 28))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 16, (void *)(a2 + 32), v9 + 1, 8);
      LODWORD(v9) = *(_DWORD *)(a2 + 24);
    }
    *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * v9) = buffer;
    ++*(_DWORD *)(a2 + 24);
    *(_QWORD *)(a2 + 8) = &buffer[v7];
    v10 = (unint64_t)(buffer + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  else
  {
    v10 = (*(_QWORD *)a2 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(_QWORD *)a2 = v10 + 24;
  v11 = v4[1];
  *(_DWORD *)(v10 + 8) = *v4;
  *(_DWORD *)(v10 + 16) = v11;
  v12 = *(_QWORD *)(a1 + 8);
  if (*(_QWORD *)v12)
    (*(void (**)(_QWORD, unint64_t))v12)(*(_QWORD *)(v12 + 8), v10);
  return v10;
}

_QWORD *llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>(_QWORD *result, _QWORD *a2)
{
  *a2 = *result;
  return result;
}

void isDivisibleBySymbol(uint64_t a1)
{
  __asm { BR              X9 }
}

uint64_t sub_1803A46F8()
{
  uint64_t v0;
  char v1;

  isDivisibleBySymbol(*(_QWORD *)(v0 + 16));
  if ((v1 & 1) == 0)
    JUMPOUT(0x1803A46DCLL);
  return 1;
}

void symbolicDivide(uint64_t a1)
{
  __asm { BR              X9 }
}

uint64_t sub_1803A47D8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  mlir::MLIRContext **v3;
  uint64_t v4;
  mlir::MLIRContext **v6[23];

  v3 = (mlir::MLIRContext **)((uint64_t (*)(_QWORD, uint64_t, uint64_t))symbolicDivide)(*(_QWORD *)(v0 + 16), v1, v2);
  v4 = *(_QWORD *)(v0 + 24);
  v6[0] = v3;
  if ((_DWORD)v2 == 4)
    return mlir::AffineExpr::ceilDiv((unint64_t *)v6, v4);
  if ((_DWORD)v2 == 3)
    return mlir::AffineExpr::floorDiv(v6, v4);
  return mlir::AffineExpr::operator%((unint64_t *)v6, v4);
}

void getSummandExprs(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  BOOL v4;
  uint64_t v5;

  v3 = a1;
  if (a1 && !*(_DWORD *)(a1 + 8))
  {
    do
    {
      getSummandExprs(*(_QWORD *)(v3 + 16), a2);
      v3 = *(_QWORD *)(v3 + 24);
      if (v3)
        v4 = *(_DWORD *)(v3 + 8) == 0;
      else
        v4 = 0;
    }
    while (v4);
  }
  v5 = *(unsigned int *)(a2 + 8);
  if (v5 >= *(_DWORD *)(a2 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v5 + 1, 8);
    LODWORD(v5) = *(_DWORD *)(a2 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a2 + 8 * v5) = v3;
  ++*(_DWORD *)(a2 + 8);
}

char *llvm::DenseMapBase<llvm::DenseMap<std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>,std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>::try_emplace<long long>@<X0>(uint64_t a1@<X0>, int *a2@<X1>, _QWORD *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int v8;
  uint64_t v9;
  int v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unsigned int v15;
  char *result;
  int v17;
  int v18;
  char *v20;
  uint64_t v21;
  char *v22;
  int v23;
  BOOL v24;
  unsigned int v26;

  v8 = *(_DWORD *)(a1 + 16);
  if (v8)
  {
    v9 = *(_QWORD *)a1;
    v10 = *a2;
    v11 = a2[1];
    v12 = ((37 * v11) | ((unint64_t)(37 * *a2) << 32))
        + ~((unint64_t)(37 * v11) << 32);
    v13 = (v12 ^ (v12 >> 22)) + ~((v12 ^ (v12 >> 22)) << 13);
    v14 = (9 * (v13 ^ (v13 >> 8))) ^ ((9 * (v13 ^ (v13 >> 8))) >> 15);
    v15 = (v8 - 1) & (((v14 + ~(v14 << 27)) >> 31) ^ (v14 + ~((_DWORD)v14 << 27)));
    result = (char *)(*(_QWORD *)a1 + 16 * v15);
    v18 = *(_DWORD *)result;
    v17 = *((_DWORD *)result + 1);
    if (v10 == *(_DWORD *)result && v11 == v17)
    {
LABEL_7:
      *(_QWORD *)a4 = result;
      *(_QWORD *)(a4 + 8) = v9 + 16 * v8;
      *(_BYTE *)(a4 + 16) = 0;
      return result;
    }
    v22 = 0;
    v23 = 1;
    while (v18 != -1 || v17 != 0x7FFFFFFF)
    {
      if (v22)
        v24 = 0;
      else
        v24 = v17 == 0x80000000;
      if (v24 && v18 == -2)
        v22 = result;
      v26 = v15 + v23++;
      v15 = v26 & (v8 - 1);
      result = (char *)(v9 + 16 * v15);
      v18 = *(_DWORD *)result;
      v17 = *((_DWORD *)result + 1);
      if (v10 == *(_DWORD *)result && v11 == v17)
        goto LABEL_7;
    }
    if (v22)
      v20 = v22;
    else
      v20 = result;
  }
  else
  {
    v20 = 0;
  }
  result = llvm::DenseMapBase<llvm::DenseMap<std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>,std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>::InsertIntoBucket<std::pair<unsigned int,int>,long long>(a1, v20, a2, a3);
  v21 = *(_QWORD *)a1 + 16 * *(unsigned int *)(a1 + 16);
  *(_QWORD *)a4 = result;
  *(_QWORD *)(a4 + 8) = v21;
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

char *llvm::DenseMapBase<llvm::DenseMap<std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>,std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>::InsertIntoBucket<std::pair<unsigned int,int>,long long>(uint64_t a1, char *a2, _DWORD *a3, _QWORD *a4)
{
  int v7;
  uint64_t v8;
  int v11;
  int *v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  unsigned int v16;
  _QWORD *buffer;
  char *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  int v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  int v28;
  unsigned int v29;
  int v30;
  int v31;
  char *v33;
  int v34;
  BOOL v35;
  unsigned int v37;

  v7 = *(_DWORD *)(a1 + 8);
  v8 = *(unsigned int *)(a1 + 16);
  if (4 * v7 + 4 >= (3 * v8))
  {
    v11 = 2 * v8;
  }
  else
  {
    if ((int)v8 + ~v7 - *(_DWORD *)(a1 + 12) > v8 >> 3)
      goto LABEL_3;
    v11 = *(_DWORD *)(a1 + 16);
  }
  v12 = *(int **)a1;
  v13 = (v11 - 1) | ((unint64_t)(v11 - 1) >> 1);
  v14 = v13 | (v13 >> 2) | ((v13 | (v13 >> 2)) >> 4);
  v15 = ((v14 | (v14 >> 8)) >> 16) | v14 | (v14 >> 8);
  if ((v15 + 1) > 0x40)
    v16 = v15 + 1;
  else
    v16 = 64;
  *(_DWORD *)(a1 + 16) = v16;
  buffer = llvm::allocate_buffer(16 * v16, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = buffer;
  if (v12)
  {
    v18 = (char *)(16 * v8);
    llvm::DenseMapBase<llvm::DenseMap<std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>,std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>::moveFromOldBuckets(a1, v12, (int *)&v18[(_QWORD)v12]);
    llvm::deallocate_buffer((llvm *)v12, v18);
  }
  *(_QWORD *)(a1 + 8) = 0;
  v19 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v19)
  {
    v20 = buffer;
    if (((v19 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
      goto LABEL_48;
    v21 = ((v19 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    v20 = &buffer[2 * (v21 & 0x1FFFFFFFFFFFFFFELL)];
    v22 = buffer + 2;
    v23 = v21 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v22 - 2) = 0x7FFFFFFFFFFFFFFFLL;
      *v22 = 0x7FFFFFFFFFFFFFFFLL;
      v22 += 4;
      v23 -= 2;
    }
    while (v23);
    if (v21 != (v21 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_48:
      do
      {
        *v20 = 0x7FFFFFFFFFFFFFFFLL;
        v20 += 2;
      }
      while (v20 != &buffer[2 * v19]);
    }
    v24 = a3[1];
    v25 = ((37 * v24) | ((unint64_t)(37 * *a3) << 32))
        + ~((unint64_t)(37 * v24) << 32);
    v26 = (v25 ^ (v25 >> 22)) + ~((v25 ^ (v25 >> 22)) << 13);
    v27 = (9 * (v26 ^ (v26 >> 8))) ^ ((9 * (v26 ^ (v26 >> 8))) >> 15);
    v28 = v19 - 1;
    v29 = v28 & (((v27 + ~(v27 << 27)) >> 31) ^ (v27 + ~((_DWORD)v27 << 27)));
    a2 = (char *)&buffer[2 * v29];
    v30 = *(_DWORD *)a2;
    v31 = *((_DWORD *)a2 + 1);
    if (*a3 != *(_DWORD *)a2 || v24 != v31)
    {
      v33 = 0;
      v34 = 1;
      while (v30 != -1 || v31 != 0x7FFFFFFF)
      {
        if (v33)
          v35 = 0;
        else
          v35 = v31 == 0x80000000;
        if (v35 && v30 == -2)
          v33 = a2;
        v37 = v29 + v34++;
        v29 = v37 & v28;
        a2 = (char *)&buffer[2 * v29];
        v30 = *(_DWORD *)a2;
        v31 = *((_DWORD *)a2 + 1);
        if (*a3 == *(_DWORD *)a2 && v24 == v31)
          goto LABEL_3;
      }
      if (v33)
        a2 = v33;
    }
  }
  else
  {
    a2 = 0;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*(_DWORD *)a2 != -1 || *((_DWORD *)a2 + 1) != 0x7FFFFFFF)
    --*(_DWORD *)(a1 + 12);
  *(_DWORD *)a2 = *a3;
  *((_DWORD *)a2 + 1) = a3[1];
  *((_QWORD *)a2 + 1) = *a4;
  return a2;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>,std::pair<unsigned int,int>,long long,llvm::DenseMapInfo<std::pair<unsigned int,int>,void>,llvm::detail::DenseMapPair<std::pair<unsigned int,int>,long long>>::moveFromOldBuckets(uint64_t result, int *a2, int *a3)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  BOOL v12;
  uint64_t v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v22;
  int v23;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  int v29;
  int v30;

  *(_QWORD *)(result + 8) = 0;
  v3 = *(unsigned int *)(result + 16);
  if ((_DWORD)v3)
  {
    v4 = *(_QWORD **)result;
    v5 = (v3 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if (v5)
    {
      v6 = v5 + 1;
      v7 = (v5 + 1) & 0x1FFFFFFFFFFFFFFELL;
      v8 = &v4[2 * v7];
      v9 = v4 + 2;
      v10 = v7;
      do
      {
        *(v9 - 2) = 0x7FFFFFFFFFFFFFFFLL;
        *v9 = 0x7FFFFFFFFFFFFFFFLL;
        v9 += 4;
        v10 -= 2;
      }
      while (v10);
      if (v6 == v7)
        goto LABEL_10;
    }
    else
    {
      v8 = *(_QWORD **)result;
    }
    v11 = &v4[2 * v3];
    do
    {
      *v8 = 0x7FFFFFFFFFFFFFFFLL;
      v8 += 2;
    }
    while (v8 != v11);
  }
LABEL_10:
  while (a2 != a3)
  {
    v22 = *a2;
    v23 = a2[1];
    if ((*a2 != -1 || v23 != 0x7FFFFFFF) && (v22 != -2 || v23 != 0x80000000))
    {
      v26 = ((37 * v23) | ((unint64_t)(37 * v22) << 32))
          + ~((unint64_t)(37 * v23) << 32);
      v27 = (v26 ^ (v26 >> 22)) + ~((v26 ^ (v26 >> 22)) << 13);
      v28 = (9 * (v27 ^ (v27 >> 8))) ^ ((9 * (v27 ^ (v27 >> 8))) >> 15);
      v29 = ((v28 + ~(v28 << 27)) >> 31) ^ (v28 + ~((_DWORD)v28 << 27));
      v30 = *(_DWORD *)(result + 16) - 1;
      v17 = v30 & v29;
      v18 = *(_QWORD *)result + 16 * v17;
      v19 = *(_DWORD *)v18;
      v20 = *(_DWORD *)(v18 + 4);
      if (v22 != *(_DWORD *)v18 || v23 != v20)
      {
        v14 = 0;
        v16 = 1;
        while (v19 != -1 || v20 != 0x7FFFFFFF)
        {
          if (v14)
            v12 = 0;
          else
            v12 = v20 == 0x80000000;
          if (v12 && v19 == -2)
            v14 = v18;
          v15 = v17 + v16++;
          v17 = v15 & v30;
          v18 = *(_QWORD *)result + 16 * (v15 & v30);
          v19 = *(_DWORD *)v18;
          v20 = *(_DWORD *)(v18 + 4);
          if (v22 == *(_DWORD *)v18 && v23 == v20)
            goto LABEL_29;
        }
        if (v14)
          v18 = v14;
      }
LABEL_29:
      *(_DWORD *)v18 = v22;
      *(_DWORD *)(v18 + 4) = a2[1];
      *(_QWORD *)(v18 + 8) = *((_QWORD *)a2 + 1);
      ++*(_DWORD *)(result + 8);
    }
    a2 += 4;
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *,false>(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, int a5)
{
  unsigned int *v8;
  unsigned int *v9;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int *v16;
  unsigned int *v17;
  unsigned int *v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int *v21;
  char v22;
  BOOL v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  signed int v32;
  signed int v33;
  unsigned int v34;
  signed int v35;
  unsigned int *v36;
  BOOL v38;
  uint64_t v39;
  unsigned int *v40;
  unsigned int *v41;
  unsigned int *v42;
  unsigned int v43;
  unsigned int v44;
  signed int v45;
  unsigned int v46;
  unsigned int v47;
  uint64_t v48;
  signed int v49;
  unsigned int *v50;
  unsigned int v51;
  unint64_t v52;
  unint64_t v53;
  unsigned int *v54;
  unint64_t v55;
  unsigned int *v57;
  unsigned int *v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;
  signed int v62;
  int *i;
  int v64;
  int v65;

  v8 = (unsigned int *)result;
LABEL_2:
  v9 = a2 - 2;
  v10 = v8;
LABEL_3:
  v11 = 1 - a4;
  v65 = a5;
  while (2)
  {
    v8 = v10;
    v12 = (char *)a2 - (char *)v10;
    v13 = v12 >> 3;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v24 = *(a2 - 2);
        v25 = *v8;
        if (v24 < *v8 || v25 >= v24 && (int)*(a2 - 1) < (int)v8[1])
        {
          *v8 = v24;
          *(a2 - 2) = v25;
          v26 = v8[1];
          v8[1] = *(a2 - 1);
          *(a2 - 1) = v26;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(v8, v8 + 2, v9);
      case 4uLL:
        result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(v8, v8 + 2, v8 + 4);
        v27 = *(a2 - 2);
        v28 = v8[4];
        if (v27 >= v28 && (v28 < v27 || (int)*(a2 - 1) >= (int)v8[5]))
          return result;
        v8[4] = v27;
        *(a2 - 2) = v28;
        v29 = v8[5];
        v8[5] = *(a2 - 1);
        *(a2 - 1) = v29;
        v30 = v8[4];
        v31 = v8[2];
        if (v30 >= v31)
        {
          if (v31 < v30)
            return result;
          v33 = v8[5];
          v32 = v8[3];
          if (v33 >= v32)
            return result;
        }
        else
        {
          v32 = v8[3];
          v33 = v8[5];
        }
        v8[2] = v30;
        v8[3] = v33;
        v8[4] = v31;
        v8[5] = v32;
        v34 = *v8;
        if (v30 >= *v8)
        {
          if (v34 < v30)
            return result;
          v35 = v8[1];
          if (v33 >= v35)
            return result;
        }
        else
        {
          v35 = v8[1];
        }
        *v8 = v30;
        v8[1] = v33;
        v8[2] = v34;
        v8[3] = v35;
        return result;
      case 5uLL:
        return std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(v8, v8 + 2, v8 + 4, v8 + 6, v9);
      default:
        if (v12 > 191)
        {
          v14 = v11;
          if (v11 == 1)
          {
            if (v8 != a2)
            {
              v52 = (v13 - 2) >> 1;
              v53 = v52 + 1;
              v54 = &v8[2 * v52];
              do
              {
                std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>((uint64_t)v8, a3, v12 >> 3, v54);
                v54 -= 2;
                --v53;
              }
              while (v53);
              v55 = (unint64_t)v12 >> 3;
              do
              {
                result = (uint64_t)std::__pop_heap[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::pair<unsigned int,int> *>(v8, (uint64_t)a2, a3, v55);
                a2 -= 2;
              }
              while (v55-- > 2);
            }
            return result;
          }
          v15 = v13 >> 1;
          v16 = &v8[2 * (v13 >> 1)];
          if ((unint64_t)v12 < 0x401)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(v16, v8, v9);
            if ((a5 & 1) != 0)
              goto LABEL_14;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(v8, v16, v9);
            v17 = v9;
            v18 = &v8[2 * v15];
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(v8 + 2, v18 - 2, a2 - 4);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(v8 + 4, &v8[2 * v15 + 2], a2 - 6);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(v18 - 2, v16, &v8[2 * v15 + 2]);
            v19 = *(_QWORD *)v8;
            *(_QWORD *)v8 = *(_QWORD *)v18;
            *(_QWORD *)v18 = v19;
            v9 = v17;
            a5 = v65;
            if ((v65 & 1) != 0)
              goto LABEL_14;
          }
          v20 = *(v8 - 2);
          if (v20 >= *v8 && (*v8 < v20 || (int)*(v8 - 1) >= (int)v8[1]))
          {
            result = (uint64_t)std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<unsigned int,int> *,std::__less<void,void> &>(v8, a2);
            v10 = (unsigned int *)result;
            goto LABEL_19;
          }
LABEL_14:
          v21 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<unsigned int,int> *,std::__less<void,void> &>(v8, a2);
          if ((v22 & 1) == 0)
            goto LABEL_17;
          v23 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(v8, v21);
          v10 = v21 + 2;
          result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(v21 + 2, a2);
          if (!(_DWORD)result)
          {
            v11 = v14 + 1;
            if (v23)
              continue;
LABEL_17:
            result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *,false>(v8, v21, a3, -v14, a5 & 1);
            v10 = v21 + 2;
LABEL_19:
            a5 = 0;
            a4 = -v14;
            goto LABEL_3;
          }
          a4 = -v14;
          a2 = v21;
          if (v23)
            return result;
          goto LABEL_2;
        }
        v36 = v8 + 2;
        v38 = v8 == a2 || v36 == a2;
        if ((a5 & 1) == 0)
        {
          if (!v38)
          {
            v57 = v8 + 1;
            do
            {
              v58 = v8;
              v8 = v36;
              v59 = v58[2];
              v60 = *v58;
              if (v59 < *v58 || v60 >= v59 && (int)v58[3] < (int)v58[1])
              {
                v61 = *v8;
                v62 = v8[1];
                for (i = (int *)v57; ; i -= 2)
                {
                  v64 = *i;
                  i[1] = v60;
                  i[2] = v64;
                  v60 = *(i - 3);
                  if (v60 <= v61 && (v60 < v61 || *(i - 2) <= v62))
                    break;
                }
                *(i - 1) = v61;
                *i = v62;
              }
              v36 = v8 + 2;
              v57 += 2;
            }
            while (v8 + 2 != a2);
          }
          return result;
        }
        if (v38)
          return result;
        v39 = 0;
        v40 = v8;
        while (2)
        {
          v42 = v40;
          v40 = v36;
          v43 = v42[2];
          v44 = *v42;
          if (v43 >= *v42 && (v44 < v43 || (int)v42[3] >= (int)v42[1]))
            goto LABEL_43;
          v46 = v42[2];
          v45 = v42[3];
          v47 = v42[1];
          v42[2] = v44;
          v40[1] = v47;
          v41 = v8;
          if (v42 == v8)
            goto LABEL_42;
          v48 = v39;
          while (1)
          {
            v51 = *(unsigned int *)((char *)v8 + v48 - 8);
            if (v51 > v46)
            {
              v49 = *(unsigned int *)((char *)v8 + v48 - 4);
              goto LABEL_50;
            }
            if (v51 < v46)
            {
              v41 = (unsigned int *)((char *)v8 + v48);
              goto LABEL_42;
            }
            v49 = *(unsigned int *)((char *)v8 + v48 - 4);
            if (v49 <= v45)
              break;
LABEL_50:
            v42 -= 2;
            v50 = (unsigned int *)((char *)v8 + v48);
            *v50 = v51;
            v50[1] = v49;
            v48 -= 8;
            if (!v48)
            {
              v41 = v8;
              goto LABEL_42;
            }
          }
          v41 = v42;
LABEL_42:
          *v41 = v46;
          v41[1] = v45;
LABEL_43:
          v36 = v40 + 2;
          v39 += 8;
          if (v40 + 2 != a2)
            continue;
          return result;
        }
    }
  }
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(unsigned int *a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  int *v6;
  int *v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  int *v11;
  unsigned int v12;
  unsigned int v13;
  int *v14;
  int v15;
  int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;

  v3 = *a2;
  v4 = *a1;
  if (*a2 >= *a1 && (v4 < v3 || (int)a2[1] >= (int)a1[1]))
  {
    v9 = *a3;
    if (*a3 < v3)
      goto LABEL_7;
    if (v3 < v9)
      return 0;
    if ((int)a3[1] < (int)a2[1])
    {
LABEL_7:
      *a2 = v9;
      *a3 = v3;
      v11 = (int *)(a2 + 1);
      v10 = a2[1];
      a2[1] = a3[1];
      a3[1] = v10;
      v12 = *a2;
      v13 = *a1;
      if (*a2 < *a1)
        goto LABEL_8;
      if (v13 < v12)
        return 1;
      if (*v11 < (int)a1[1])
      {
LABEL_8:
        *a1 = v12;
        v14 = (int *)(a1 + 1);
        *a2 = v13;
        v15 = *v14;
        *v14 = *v11;
        *v11 = v15;
        return 2;
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v5 = *a3;
    if (*a3 < v3 || v3 >= v5 && (int)a3[1] < (int)a2[1])
    {
      *a1 = v5;
      v6 = (int *)(a1 + 1);
      *a3 = v4;
      v7 = (int *)(a3 + 1);
      v8 = 1;
LABEL_13:
      v20 = *v6;
      *v6 = *v7;
      *v7 = v20;
      return v8;
    }
    *a1 = v3;
    *a2 = v4;
    v17 = a1[1];
    a1[1] = a2[1];
    a2[1] = v17;
    v18 = *a3;
    v19 = *a2;
    if (*a3 < *a2)
    {
LABEL_12:
      *a2 = v18;
      *a3 = v19;
      v7 = (int *)(a3 + 1);
      v8 = 2;
      v6 = (int *)(a2 + 1);
      goto LABEL_13;
    }
    if (v19 >= v18)
    {
      if ((int)a3[1] < v17)
        goto LABEL_12;
      return 1;
    }
    else
    {
      return 1;
    }
  }
}

unsigned int *std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<unsigned int,int> *,std::__less<void,void> &>(unsigned int *a1, unsigned int *a2)
{
  int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int *i;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  BOOL v14;

  v3 = *a1;
  v2 = a1[1];
  v4 = *(a2 - 2);
  if (v4 <= *a1 && (v4 < v3 || (int)*(a2 - 1) <= v2))
  {
    for (i = a1 + 2; i < a2 && *i <= v3 && (*i < v3 || (int)i[1] <= v2); i += 2)
      ;
  }
  else
  {
    i = a1;
    do
    {
      v7 = i[2];
      i += 2;
      v6 = v7;
    }
    while (v7 <= v3 && (v6 < v3 || (int)i[1] <= v2));
  }
  if (i < a2)
  {
    for (a2 -= 2; v4 > v3 || v4 >= v3 && (int)a2[1] > v2; a2 -= 2)
    {
      v8 = *(a2 - 2);
      v4 = v8;
    }
  }
  if (i < a2)
  {
    v9 = *i;
    v10 = *a2;
    do
    {
      *i = v10;
      *a2 = v9;
      v11 = i[1];
      i[1] = a2[1];
      a2[1] = v11;
      do
      {
        v12 = i[2];
        i += 2;
        v9 = v12;
      }
      while (v12 <= v3 && (v9 < v3 || (int)i[1] <= v2));
      do
      {
        do
        {
          v13 = *(a2 - 2);
          a2 -= 2;
          v10 = v13;
          v14 = v13 >= v3;
        }
        while (v13 > v3);
      }
      while (v14 && (int)a2[1] > v2);
    }
    while (i < a2);
  }
  if (i - 2 != a1)
  {
    *a1 = *(i - 2);
    a1[1] = *(i - 1);
  }
  *(i - 2) = v3;
  *(i - 1) = v2;
  return i;
}

unsigned int *std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<unsigned int,int> *,std::__less<void,void> &>(unsigned int *a1, unsigned int *a2)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  unsigned int v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v12;
  unsigned int *v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  BOOL v17;
  unsigned int v18;

  v2 = 0;
  v3 = *a1;
  v4 = a1[1];
  while (1)
  {
    v5 = a1[v2 + 2];
    if (v5 >= v3 && (v5 > v3 || (int)a1[v2 + 3] >= v4))
      break;
    v2 += 2;
  }
  v6 = (unint64_t)&a1[v2 + 2];
  if (v2 * 4)
  {
    do
    {
      v8 = *(a2 - 2);
      a2 -= 2;
      v7 = v8;
    }
    while (v8 >= v3 && (v7 > v3 || (int)a2[1] >= v4));
  }
  else
  {
LABEL_19:
    if (v6 < (unint64_t)a2)
    {
      do
      {
        v10 = *(a2 - 2);
        a2 -= 2;
        v9 = v10;
        if (v10 < v3)
          break;
        if (v9 > v3)
          goto LABEL_19;
      }
      while ((int)a2[1] >= v4 && v6 < (unint64_t)a2);
    }
  }
  if (v6 >= (unint64_t)a2)
  {
    v13 = (unsigned int *)v6;
  }
  else
  {
    v12 = *a2;
    v13 = (unsigned int *)v6;
    v14 = a2;
    do
    {
      *v13 = v12;
      *v14 = v5;
      v15 = v13[1];
      v13[1] = v14[1];
      v14[1] = v15;
      do
      {
        do
        {
          v16 = v13[2];
          v13 += 2;
          v5 = v16;
          v17 = v16 > v3;
        }
        while (v16 < v3);
      }
      while (!v17 && (int)v13[1] < v4);
      do
      {
        v18 = *(v14 - 2);
        v14 -= 2;
        v12 = v18;
      }
      while (v18 >= v3 && (v12 > v3 || (int)v14[1] >= v4));
    }
    while (v13 < v14);
  }
  if (v13 - 2 != a1)
  {
    *a1 = *(v13 - 2);
    a1[1] = *(v13 - 1);
  }
  *(v13 - 2) = v3;
  *(v13 - 1) = v4;
  return v13 - 2;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(unsigned int *a1, unsigned int *a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned int *v6;
  unsigned int *v7;
  uint64_t v8;
  int v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  signed int v13;
  uint64_t v14;
  signed int v15;
  char *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  signed int v26;
  signed int v27;
  unsigned int v28;
  signed int v29;

  v4 = ((char *)a2 - (char *)a1) >> 3;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v18 = *(a2 - 2);
      v19 = *a1;
      if (v18 < *a1 || v19 >= v18 && (int)*(a2 - 1) < (int)a1[1])
      {
        *a1 = v18;
        *(a2 - 2) = v19;
        v20 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v20;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(a1, a1 + 2, a1 + 4);
      v21 = *(a2 - 2);
      v22 = a1[4];
      if (v21 >= v22 && (v22 < v21 || (int)*(a2 - 1) >= (int)a1[5]))
        return 1;
      a1[4] = v21;
      *(a2 - 2) = v22;
      v23 = a1[5];
      a1[5] = *(a2 - 1);
      *(a2 - 1) = v23;
      v24 = a1[4];
      v25 = a1[2];
      if (v24 >= v25)
      {
        if (v25 < v24)
          return 1;
        v27 = a1[5];
        v26 = a1[3];
        if (v27 >= v26)
          return 1;
      }
      else
      {
        v26 = a1[3];
        v27 = a1[5];
      }
      a1[2] = v24;
      a1[3] = v27;
      a1[4] = v25;
      a1[5] = v26;
      v28 = *a1;
      if (v24 < *a1)
      {
        v29 = a1[1];
LABEL_43:
        *a1 = v24;
        a1[1] = v27;
        result = 1;
        a1[2] = v28;
        a1[3] = v29;
        return result;
      }
      if (v28 >= v24)
      {
        v29 = a1[1];
        if (v27 < v29)
          goto LABEL_43;
      }
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      v6 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(a1, a1 + 2, a1 + 4);
      v7 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v8 = 0;
      v9 = 0;
      while (2)
      {
        v11 = *v6;
        if (*v7 >= *v6 && (v11 < *v7 || (int)v7[1] >= (int)v6[1]))
          goto LABEL_7;
        v12 = *v7;
        v13 = v7[1];
        *v7 = v11;
        v7[1] = v6[1];
        v10 = a1;
        if (v6 == a1)
          goto LABEL_6;
        v14 = v8;
        while (2)
        {
          v16 = (char *)a1 + v14;
          v17 = *(unsigned int *)((char *)a1 + v14 + 8);
          if (v17 > v12)
          {
            v15 = *((_DWORD *)v16 + 3);
LABEL_12:
            v6 -= 2;
            *((_DWORD *)v16 + 4) = v17;
            *(unsigned int *)((char *)a1 + v14 + 20) = v15;
            v14 -= 8;
            if (v14 == -16)
            {
              v10 = a1;
              goto LABEL_6;
            }
            continue;
          }
          break;
        }
        if (v17 < v12)
        {
          v10 = v6;
          goto LABEL_6;
        }
        v15 = *(unsigned int *)((char *)a1 + v14 + 12);
        if (v15 > v13)
          goto LABEL_12;
        v10 = (unsigned int *)((char *)a1 + v14 + 16);
LABEL_6:
        *v10 = v12;
        v10[1] = v13;
        if (++v9 == 8)
          return v7 + 2 == a2;
LABEL_7:
        v6 = v7;
        v8 += 8;
        v7 += 2;
        if (v7 != a2)
          continue;
        return 1;
      }
  }
}

uint64_t std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  uint64_t result;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;

  result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(a1, a2, a3);
  v11 = *a4;
  v12 = *a3;
  if (*a4 < *a3 || v12 >= v11 && (int)a4[1] < (int)a3[1])
  {
    *a3 = v11;
    *a4 = v12;
    v13 = a3[1];
    a3[1] = a4[1];
    a4[1] = v13;
    v14 = *a3;
    v15 = *a2;
    if (*a3 < *a2 || v15 >= v14 && (int)a3[1] < (int)a2[1])
    {
      *a2 = v14;
      *a3 = v15;
      v16 = a2[1];
      a2[1] = a3[1];
      a3[1] = v16;
      v17 = *a2;
      v18 = *a1;
      if (*a2 < *a1 || v18 >= v17 && (int)a2[1] < (int)a1[1])
      {
        *a1 = v17;
        *a2 = v18;
        v19 = a1[1];
        a1[1] = a2[1];
        a2[1] = v19;
      }
    }
  }
  v20 = *a5;
  v21 = *a4;
  if (*a5 < *a4 || v21 >= v20 && (int)a5[1] < (int)a4[1])
  {
    *a4 = v20;
    *a5 = v21;
    v22 = a4[1];
    a4[1] = a5[1];
    a5[1] = v22;
    v23 = *a4;
    v24 = *a3;
    if (*a4 < *a3 || v24 >= v23 && (int)a4[1] < (int)a3[1])
    {
      *a3 = v23;
      *a4 = v24;
      v25 = a3[1];
      a3[1] = a4[1];
      a4[1] = v25;
      v26 = *a3;
      v27 = *a2;
      if (*a3 < *a2 || v27 >= v26 && (int)a3[1] < (int)a2[1])
      {
        *a2 = v26;
        *a3 = v27;
        v28 = a2[1];
        a2[1] = a3[1];
        a3[1] = v28;
        v29 = *a2;
        v30 = *a1;
        if (*a2 < *a1 || v30 >= v29 && (int)a2[1] < (int)a1[1])
        {
          *a1 = v29;
          *a2 = v30;
          v31 = a1[1];
          a1[1] = a2[1];
          a2[1] = v31;
        }
      }
    }
  }
  return result;
}

uint64_t std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,int> *>(uint64_t result, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 3)
    {
      v6 = v4 >> 2;
      v7 = (v4 >> 2) + 1;
      v8 = (unsigned int *)(result + 8 * v7);
      v9 = v6 + 2;
      if (v9 < a3)
      {
        v10 = v8[2];
        if (*v8 < v10 || v10 >= *v8 && *(_DWORD *)(result + 8 * v7 + 4) < (signed int)v8[3])
        {
          v8 += 2;
          v7 = v9;
        }
      }
      v11 = *v8;
      if (*v8 >= *a4 && (*a4 < v11 || (int)v8[1] >= (int)a4[1]))
      {
        v12 = *a4;
        v13 = a4[1];
        *a4 = v11;
        a4[1] = v8[1];
        if (v5 >= v7)
        {
          while (1)
          {
            v15 = 2 * v7;
            v7 = (2 * v7) | 1;
            v14 = (unsigned int *)(result + 8 * v7);
            v16 = v15 + 2;
            if (v16 < a3)
            {
              v17 = v14[2];
              if (*v14 < v17 || v17 >= *v14 && *(_DWORD *)(result + 8 * v7 + 4) < (signed int)v14[3])
              {
                v14 += 2;
                v7 = v16;
              }
            }
            v18 = *v14;
            if (*v14 < v12 || v18 <= v12 && (int)v14[1] < v13)
              break;
            *v8 = v18;
            v8[1] = v14[1];
            v8 = v14;
            if (v5 < v7)
              goto LABEL_13;
          }
        }
        v14 = v8;
LABEL_13:
        *v14 = v12;
        v14[1] = v13;
      }
    }
  }
  return result;
}

unsigned int *std::__pop_heap[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::pair<unsigned int,int> *>(unsigned int *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  unsigned int *v19;
  int v20;
  unint64_t v21;
  unsigned int v22;

  if (a4 >= 2)
  {
    v4 = 0;
    v5 = *(_QWORD *)result;
    v6 = result;
    do
    {
      v7 = v6;
      v8 = v4 + 1;
      v6 += 2 * v4 + 2;
      v9 = 2 * v4;
      v4 = (2 * v4) | 1;
      v10 = v9 + 2;
      if (v10 < a4)
      {
        v11 = v6[2];
        if (*v6 < v11 || v11 >= *v6 && (int)v7[2 * v8 + 1] < (int)v6[3])
        {
          v6 += 2;
          v4 = v10;
        }
      }
      *v7 = *v6;
      v7[1] = v6[1];
    }
    while (v4 <= (uint64_t)((unint64_t)(a4 - 2) >> 1));
    if (v6 == (unsigned int *)(a2 - 8))
    {
      *(_QWORD *)v6 = v5;
    }
    else
    {
      *v6 = *(_DWORD *)(a2 - 8);
      v6[1] = *(_DWORD *)(a2 - 4);
      *(_QWORD *)(a2 - 8) = v5;
      v12 = (char *)v6 - (char *)result + 8;
      if (v12 >= 9)
      {
        v13 = ((unint64_t)v12 >> 3) - 2;
        v14 = v13 >> 1;
        v15 = &result[2 * (v13 >> 1)];
        v16 = *v15;
        if (*v15 < *v6 || *v6 >= v16 && (int)result[2 * v14 + 1] < (int)v6[1])
        {
          v17 = *v6;
          v18 = v6[1];
          *v6 = v16;
          v6[1] = v15[1];
          if (v13 >= 2)
          {
            while (1)
            {
              v21 = v14 - 1;
              v14 = (v14 - 1) >> 1;
              v19 = &result[2 * v14];
              v22 = *v19;
              if (*v19 < v17)
              {
                v20 = v19[1];
              }
              else
              {
                if (v22 > v17)
                  break;
                v20 = result[2 * v14 + 1];
                if (v20 >= v18)
                  break;
              }
              *v15 = v22;
              v15[1] = v20;
              v15 = &result[2 * v14];
              if (v21 <= 1)
                goto LABEL_17;
            }
          }
          v19 = v15;
LABEL_17:
          *v19 = v17;
          v19[1] = v18;
        }
      }
    }
  }
  return result;
}

BOOL llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::detail::AffineConstantExprStorage * mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>,mlir::TypeID,long long &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>(_QWORD **a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16) == **a1;
}

unint64_t llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::detail::AffineConstantExprStorage * mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>,mlir::TypeID,long long &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  BOOL v5;
  unsigned int v6;
  uint64_t v7;
  char *buffer;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;

  v4 = *(_QWORD **)a1;
  *(_QWORD *)(a2 + 80) += 24;
  if (*(_QWORD *)a2)
    v5 = ((*(_QWORD *)a2 + 7) & 0xFFFFFFFFFFFFFFF8) - *(_QWORD *)a2 + 24 > *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  else
    v5 = 1;
  if (v5)
  {
    v6 = *(_DWORD *)(a2 + 24) >> 7;
    if (v6 >= 0x1E)
      LOBYTE(v6) = 30;
    v7 = 4096 << v6;
    buffer = (char *)llvm::allocate_buffer(4096 << v6, (std::align_val_t)8uLL);
    v9 = *(unsigned int *)(a2 + 24);
    if (v9 >= *(_DWORD *)(a2 + 28))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 16, (void *)(a2 + 32), v9 + 1, 8);
      LODWORD(v9) = *(_DWORD *)(a2 + 24);
    }
    *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * v9) = buffer;
    ++*(_DWORD *)(a2 + 24);
    *(_QWORD *)(a2 + 8) = &buffer[v7];
    v10 = (unint64_t)(buffer + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  else
  {
    v10 = (*(_QWORD *)a2 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(_QWORD *)a2 = v10 + 24;
  *(_DWORD *)(v10 + 8) = 5;
  *(_QWORD *)(v10 + 16) = *v4;
  v11 = *(_QWORD *)(a1 + 8);
  if (*(_QWORD *)v11)
    (*(void (**)(_QWORD, unint64_t))v11)(*(_QWORD *)(v11 + 8), v10);
  return v10;
}

_QWORD *llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>(_QWORD *result, _QWORD *a2)
{
  *a2 = *result;
  return result;
}

uint64_t llvm::DenseMapInfo<std::tuple<unsigned int,mlir::AffineExpr,mlir::AffineExpr>,void>::getHashValueImpl<1u>(uint64_t a1)
{
  unint64_t v1;
  unsigned __int8 v2;
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unsigned __int8 v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  int v19;
  int v20;
  unint64_t v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;

  v1 = *(_QWORD *)(a1 + 8);
  v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v2 & 1) == 0)
  {
    v25 = a1;
    v27 = *(_QWORD *)(a1 + 8);
    v1 = v27;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v20 = v19;
    a1 = v25;
    if (v20)
    {
      v21 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v21 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v21;
      v1 = v27;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v25;
    }
  }
  v4 = v3[19];
  v5 = *(_QWORD *)(a1 + 16);
  if ((v6 & 1) == 0)
  {
    v28 = v1;
    v24 = v3[19];
    v26 = *(_QWORD *)(a1 + 16);
    v4 = v24;
    v5 = v26;
    v1 = v28;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    if (v22)
    {
      v23 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v23 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v23;
      v4 = v24;
      v5 = v26;
      v1 = v28;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v7 = HIDWORD(v1);
  v8 = (v4 + 8 * v1) ^ HIDWORD(v1);
  v9 = 0x9DDFEA08EB382D69 * (v7 ^ ((0x9DDFEA08EB382D69 * v8) >> 47) ^ (0x9DDFEA08EB382D69 * v8));
  v10 = HIDWORD(v5);
  v11 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v5) ^ HIDWORD(v5));
  v12 = 0xEB382D6900000000
      * ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) ^ ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) >> 47))
      - 1;
  v13 = (v12 ^ (v12 >> 22)) + ~((v12 ^ (v12 >> 22)) << 13);
  v14 = (9 * (v13 ^ (v13 >> 8))) ^ ((9 * (v13 ^ (v13 >> 8))) >> 15);
  v15 = (((v14 + ~(v14 << 27)) >> 31) ^ ((_DWORD)v14 + ~((_DWORD)v14 << 27)) | (0xEB382D6900000000
                                                                                            * (v9 ^ (v9 >> 47))))
      + ~((unint64_t)(((v14 + ~(v14 << 27)) >> 31) ^ ((_DWORD)v14 + ~((_DWORD)v14 << 27))) << 32);
  v16 = (v15 ^ (v15 >> 22)) + ~((v15 ^ (v15 >> 22)) << 13);
  v17 = (9 * (v16 ^ (v16 >> 8))) ^ ((9 * (v16 ^ (v16 >> 8))) >> 15);
  return ((v17 + ~(v17 << 27)) >> 31) ^ ((_DWORD)v17 + ~((_DWORD)v17 << 27));
}

BOOL llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::detail::AffineBinaryOpExprStorage * mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(llvm::function_ref<void ()(mlir::detail::AffineBinaryOpExprStorage *)>,mlir::TypeID,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>(_QWORD *a1, uint64_t a2)
{
  _DWORD *v2;

  v2 = (_DWORD *)*a1;
  return *(_DWORD *)*a1 == *(_DWORD *)(a2 + 8)
      && *((_QWORD *)v2 + 1) == *(_QWORD *)(a2 + 16)
      && *((_QWORD *)v2 + 2) == *(_QWORD *)(a2 + 24);
}

unint64_t llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::detail::AffineBinaryOpExprStorage * mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(llvm::function_ref<void ()(mlir::detail::AffineBinaryOpExprStorage *)>,mlir::TypeID,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t *a1, uint64_t a2)
{
  unint64_t v3;
  uint64_t v4;

  v3 = mlir::detail::AffineBinaryOpExprStorage::construct(a2, *a1);
  v4 = a1[1];
  if (*(_QWORD *)v4)
    (*(void (**)(_QWORD, unint64_t))v4)(*(_QWORD *)(v4 + 8), v3);
  return v3;
}

unint64_t mlir::detail::AffineBinaryOpExprStorage::construct(uint64_t a1, uint64_t a2)
{
  BOOL v4;
  unsigned int v5;
  uint64_t v6;
  char *buffer;
  uint64_t v8;
  unint64_t result;
  _QWORD *v10;

  *(_QWORD *)(a1 + 80) += 32;
  if (*(_QWORD *)a1)
    v4 = ((*(_QWORD *)a1 + 7) & 0xFFFFFFFFFFFFFFF8) - *(_QWORD *)a1 + 32 > *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  else
    v4 = 1;
  if (v4)
  {
    v5 = *(_DWORD *)(a1 + 24) >> 7;
    if (v5 >= 0x1E)
      LOBYTE(v5) = 30;
    v6 = 4096 << v5;
    buffer = (char *)llvm::allocate_buffer(4096 << v5, (std::align_val_t)8uLL);
    v8 = *(unsigned int *)(a1 + 24);
    if (v8 >= *(_DWORD *)(a1 + 28))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v8 + 1, 8);
      LODWORD(v8) = *(_DWORD *)(a1 + 24);
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v8) = buffer;
    ++*(_DWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 8) = &buffer[v6];
    result = (unint64_t)(buffer + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  else
  {
    result = (*(_QWORD *)a1 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(_QWORD *)a1 = result + 32;
  *(_DWORD *)(result + 8) = *(_DWORD *)a2;
  v10 = *(_QWORD **)(a2 + 8);
  *(_QWORD *)(result + 16) = v10;
  *(_QWORD *)(result + 24) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)result = *v10;
  return result;
}

char *std::vector<llvm::SmallVector<long long,8u>>::__emplace_back_slow_path<llvm::SmallVector<long long,32u>>(char **a1, uint64_t a2)
{
  char *v2;
  char *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;

  v2 = *a1;
  v3 = a1[1];
  v4 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - *a1) >> 4);
  v5 = v4 + 1;
  if (v4 + 1 > 0x333333333333333)
    abort();
  if (0x999999999999999ALL * ((a1[2] - v2) >> 4) > v5)
    v5 = 0x999999999999999ALL * ((a1[2] - v2) >> 4);
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v2) >> 4) >= 0x199999999999999)
    v8 = 0x333333333333333;
  else
    v8 = v5;
  if (v8)
  {
    if (v8 > 0x333333333333333)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v9 = (char *)operator new(80 * v8);
  }
  else
  {
    v9 = 0;
  }
  v10 = &v9[80 * v4];
  *(_QWORD *)v10 = v10 + 16;
  *((_QWORD *)v10 + 1) = 0x800000000;
  if (*(_DWORD *)(a2 + 8))
  {
    llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v10, a2);
    v2 = *a1;
    v3 = a1[1];
  }
  v11 = &v9[80 * v8];
  v12 = v10 + 80;
  if (v3 == v2)
  {
    *a1 = v10;
    a1[1] = v12;
    a1[2] = v11;
  }
  else
  {
    v13 = 0;
    do
    {
      *(_QWORD *)&v10[v13 - 80] = &v10[v13 - 64];
      *(_QWORD *)&v10[v13 - 72] = 0x800000000;
      if (*(_DWORD *)&v3[v13 - 72])
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)&v10[v13 - 80], (uint64_t)&v3[v13 - 80]);
      v13 -= 80;
    }
    while (&v3[v13] != v2);
    v2 = *a1;
    v14 = a1[1];
    *a1 = &v10[v13];
    a1[1] = v12;
    a1[2] = v11;
    while (v14 != v2)
    {
      v16 = (char *)*((_QWORD *)v14 - 10);
      v14 -= 80;
      v15 = v16;
      if (v14 + 16 != v16)
        free(v15);
    }
  }
  if (v2)
    operator delete(v2);
  return v10 + 80;
}

BOOL mlir::AffineExprVisitor<mlir::SimpleAffineExprFlattener,mlir::LogicalResult>::walkOperandsPostOrder(uint64_t a1, uint64_t a2)
{
  return mlir::AffineExprVisitor<mlir::SimpleAffineExprFlattener,mlir::LogicalResult>::walkPostOrder(a1, *(_QWORD *)(a2 + 16))&& mlir::AffineExprVisitor<mlir::SimpleAffineExprFlattener,mlir::LogicalResult>::walkPostOrder(a1, *(_QWORD *)(a2 + 24)) != 0;
}

uint64_t mlir::AffineMap::getConstantMap(mlir::AffineMap *this, mlir::MLIRContext *a2, mlir::MLIRContext *a3)
{
  uint64_t AffineConstantExpr;

  AffineConstantExpr = mlir::getAffineConstantExpr(this, a2, a3);
  return mlir::AffineMap::get(0, 0, AffineConstantExpr);
}

uint64_t mlir::AffineMap::getMultiDimIdentityMap(mlir::AffineMap *this, mlir::MLIRContext *a2, mlir::MLIRContext *a3)
{
  int v4;
  mlir *v5;
  uint64_t AffineDimExpr;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  void *v11;
  uint64_t v12;
  _QWORD v13[5];

  v4 = (int)this;
  v13[4] = *MEMORY[0x1E0C80C00];
  v11 = v13;
  v12 = 0x400000000;
  if (this < 5)
  {
    if (!(_DWORD)this)
    {
      v8 = v12;
      goto LABEL_10;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v11, v13, this, 8);
  }
  v5 = 0;
  do
  {
    AffineDimExpr = mlir::getAffineDimExpr(v5, a2, a3);
    v7 = v12;
    if (v12 >= (unint64_t)HIDWORD(v12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v11, v13, v12 + 1, 8);
      v7 = v12;
    }
    *((_QWORD *)v11 + v7) = AffineDimExpr;
    v8 = v12 + 1;
    LODWORD(v12) = v12 + 1;
    v5 = (mlir *)((_DWORD)v5 + 1);
  }
  while (v4 != (_DWORD)v5);
LABEL_10:
  v9 = mlir::AffineMap::get(v4, 0, (uint64_t)v11, v8, a2);
  if (v11 != v13)
    free(v11);
  return v9;
}

uint64_t mlir::AffineMap::getResults(mlir::AffineMap *this)
{
  return *(_QWORD *)this + 24;
}

uint64_t mlir::AffineMap::getNumDims(mlir::AffineMap *this)
{
  return **(unsigned int **)this;
}

uint64_t mlir::AffineMap::getNumInputs(mlir::AffineMap *this)
{
  return (*(_DWORD *)(*(_QWORD *)this + 4) + **(_DWORD **)this);
}

double mlir::AffineMap::inferFromExprList@<D0>(mlir::BytecodeWriterConfig **a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t *v4;
  uint64_t DesiredBytecodeVersion;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t i;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  double result;
  unint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[3];
  _QWORD *v22;
  uint64_t v23;

  v4 = (uint64_t *)a1;
  v23 = *MEMORY[0x1E0C80C00];
  DesiredBytecodeVersion = mlir::BytecodeWriterConfig::getDesiredBytecodeVersion(*a1);
  v18 = -1;
  v19 = -1;
  if (!a2)
  {
    *(_QWORD *)a3 = a3 + 16;
    *(_QWORD *)&result = 0x400000000;
    *(_QWORD *)(a3 + 8) = 0x400000000;
    return result;
  }
  v17 = (_QWORD *)DesiredBytecodeVersion;
  v7 = &v4[2 * a2];
  v8 = v4;
  do
  {
    v9 = v8[1];
    if (v9)
    {
      v10 = (uint64_t *)*v8;
      for (i = 8 * v9; i; i -= 8)
      {
        v20 = *v10;
        v21[0] = off_1E0E51798;
        v21[1] = &v19;
        v21[2] = &v18;
        v22 = v21;
        mlir::AffineExpr::walk(&v20, v21);
        v12 = v22;
        if (v22 == v21)
        {
          v12 = v21;
          v13 = 4;
        }
        else
        {
          if (!v22)
            goto LABEL_8;
          v13 = 5;
        }
        (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_8:
        ++v10;
      }
    }
    v8 += 2;
  }
  while (v8 != v7);
  *(_QWORD *)a3 = a3 + 16;
  *(_QWORD *)(a3 + 8) = 0x400000000;
  if (a2 >= 5)
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), a2, 8);
  do
  {
    v14 = mlir::AffineMap::get((int)v19 + 1, (int)v18 + 1, *v4, v4[1], v17);
    v16 = *(unsigned int *)(a3 + 8);
    if (v16 >= *(unsigned int *)(a3 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v16 + 1, 8);
      v16 = *(unsigned int *)(a3 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a3 + 8 * v16) = v14;
    ++*(_DWORD *)(a3 + 8);
    v4 += 2;
  }
  while (v4 != v7);
  return result;
}

unint64_t mlir::AffineMap::getLargestKnownDivisorOfMapExprs(mlir::AffineMap *this)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v9;

  v1 = *(_QWORD *)this;
  v2 = *(unsigned int *)(*(_QWORD *)this + 8);
  if (!(_DWORD)v2)
    return -1;
  v3 = 0;
  v4 = (uint64_t *)(v1 + 24);
  v5 = v1 + 24 + 8 * v2;
  do
  {
    v9 = *v4;
    mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v9);
    if (v7)
    {
      do
      {
        v6 = v7;
        v7 = v3 % v7;
        v3 = v6;
      }
      while (v7);
    }
    else
    {
      v6 = v3;
    }
    v3 = v6;
    ++v4;
  }
  while (v4 != (uint64_t *)v5);
  if (v6)
    return v6;
  else
    return -1;
}

uint64_t mlir::AffineMap::isIdentity(mlir::AffineMap *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;

  v1 = **(unsigned int **)this;
  if ((_DWORD)v1 == *(_DWORD *)(*(_QWORD *)this + 8))
  {
    if (!(_DWORD)v1)
      return 1;
    v2 = 0;
    v3 = *(_QWORD *)this + 24;
    while (1)
    {
      v4 = *(_QWORD *)(v3 + 8 * v2);
      v7 = v4;
      if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v7) == 6)
      {
        mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v7, v4);
        v6 = v7;
        if (!v7)
          return 0;
      }
      else
      {
        mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v7, 0);
        v6 = v7;
        if (!v7)
          return 0;
      }
      if (v2 != mlir::AffineDimExpr::getPosition((mlir::AffineDimExpr *)&v6))
        break;
      if (v1 == ++v2)
        return 1;
    }
  }
  return 0;
}

uint64_t mlir::AffineMap::isSymbolIdentity(mlir::AffineMap *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;

  v1 = *(unsigned int *)(*(_QWORD *)this + 4);
  if ((_DWORD)v1 == *(_DWORD *)(*(_QWORD *)this + 8))
  {
    if (!(_DWORD)v1)
      return 1;
    v2 = 0;
    v3 = *(_QWORD *)this + 24;
    while (1)
    {
      v4 = *(_QWORD *)(v3 + 8 * v2);
      v7 = v4;
      if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v7) == 6)
      {
        mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v7, v4);
        v6 = v7;
        if (!v7)
          return 0;
      }
      else
      {
        mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v7, 0);
        v6 = v7;
        if (!v7)
          return 0;
      }
      if (v2 != mlir::AffineDimExpr::getPosition((mlir::AffineDimExpr *)&v6))
        break;
      if (v1 == ++v2)
        return 1;
    }
  }
  return 0;
}

uint64_t mlir::AffineMap::getNumSymbols(mlir::AffineMap *this)
{
  return *(unsigned int *)(*(_QWORD *)this + 4);
}

BOOL mlir::AffineMap::isSingleConstant(mlir::AffineMap *this)
{
  uint64_t v2;

  if (*(_DWORD *)(*(_QWORD *)this + 8) != 1)
    return 0;
  v2 = *(_QWORD *)(*(_QWORD *)this + 24);
  return mlir::AffineExpr::getKind((mlir::AffineExpr *)&v2) == 5;
}

uint64_t mlir::AffineMap::getResult(mlir::AffineMap *this, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)this + 8 * a2 + 24);
}

BOOL mlir::AffineMap::isConstant(mlir::AffineMap *this)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  _BOOL8 result;
  BOOL v6;
  uint64_t v7;

  v1 = *(unsigned int *)(*(_QWORD *)this + 8);
  if (!(_DWORD)v1)
    return 1;
  v2 = (uint64_t *)(*(_QWORD *)this + 24);
  v3 = 8 * v1 - 8;
  do
  {
    v4 = *v2++;
    v7 = v4;
    v6 = mlir::AffineExpr::getKind((mlir::AffineExpr *)&v7) == 5;
    result = v6;
    v6 = !v6 || v3 == 0;
    v3 -= 8;
  }
  while (!v6);
  return result;
}

uint64_t mlir::AffineMap::getSingleConstantResult(mlir::AffineMap *this)
{
  uint64_t v2;

  mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v2, *(_QWORD *)(*(_QWORD *)this + 24));
  return mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v2);
}

void mlir::AffineMap::getConstantResults(mlir::AffineMap *this@<X0>, uint64_t a2@<X8>)
{
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t LHS;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = (void *)(a2 + 16);
  *(_QWORD *)a2 = a2 + 16;
  *(_QWORD *)(a2 + 8) = 0x600000000;
  v4 = *(unsigned int *)(*(_QWORD *)this + 8);
  if ((_DWORD)v4)
  {
    v5 = (uint64_t *)(*(_QWORD *)this + 24);
    v6 = 8 * v4;
    do
    {
      while (1)
      {
        mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v10, *v5);
        LHS = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v10);
        v8 = LHS;
        v9 = *(unsigned int *)(a2 + 8);
        if (v9 >= *(_DWORD *)(a2 + 12))
          break;
        *(_QWORD *)(*(_QWORD *)a2 + 8 * v9) = LHS;
        *(_DWORD *)(a2 + 8) = v9 + 1;
        ++v5;
        v6 -= 8;
        if (!v6)
          return;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, v3, v9 + 1, 8);
      *(_QWORD *)(*(_QWORD *)a2 + 8 * (*(_DWORD *)(a2 + 8))++) = v8;
      ++v5;
      v6 -= 8;
    }
    while (v6);
  }
}

uint64_t mlir::AffineMap::constantFold(int **a1, uint64_t a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  mlir::MLIRContext *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v17;
  uint64_t v18;
  _QWORD v19[3];

  v19[2] = *MEMORY[0x1E0C80C00];
  v17 = v19;
  v18 = 0x200000000;
  mlir::AffineMap::partialConstantFold(a1, a2, a3, (uint64_t)&v17, a5);
  v8 = v18;
  v9 = (uint64_t *)v17;
  if (!(_DWORD)v18)
  {
    v15 = 0;
    if (v17 == v19)
      return v15;
    goto LABEL_7;
  }
  v10 = *(unsigned int *)(a4 + 8);
  if (v10 + (unint64_t)v18 > *(unsigned int *)(a4 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v10 + v18, 8);
    v10 = *(unsigned int *)(a4 + 8);
  }
  v11 = (uint64_t *)(*(_QWORD *)a4 + 8 * v10);
  v12 = 8 * v8;
  do
  {
    v13 = *v9++;
    v14 = mlir::IndexType::get(*((mlir::IndexType **)*a1 + 2), v7);
    *v11++ = mlir::IntegerAttr::get(v14, v13);
    v12 -= 8;
  }
  while (v12);
  *(_DWORD *)(a4 + 8) += v8;
  v15 = 1;
  v9 = (uint64_t *)v17;
  if (v17 != v19)
LABEL_7:
    free(v9);
  return v15;
}

uint64_t mlir::AffineMap::partialConstantFold(int **a1, uint64_t a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  int *v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  mlir::IndexType *DesiredBytecodeVersion;
  mlir::MLIRContext *v17;
  uint64_t v18;
  uint64_t v19;
  mlir *Int;
  mlir::MLIRContext *Context;
  mlir::MLIRContext *v22;
  uint64_t AffineConstantExpr;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  _QWORD v38[5];

  v38[4] = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  v31 = **a1;
  v32 = a2;
  v33 = a3;
  v34 = 0;
  v36 = v38;
  v37 = 0x400000000;
  v9 = v8[2];
  if (v9 >= 5)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v36, v38, v9, 8);
    v8 = *a1;
    LODWORD(v9) = (*a1)[2];
  }
  if ((_DWORD)v9)
  {
    v10 = (uint64_t *)(v8 + 6);
    v11 = 8 * v9;
    while (1)
    {
      v12 = *v10;
      v35 = v12;
      if (v14)
      {
        v15 = v13;
        DesiredBytecodeVersion = (mlir::IndexType *)mlir::BytecodeWriterConfig::getDesiredBytecodeVersion((mlir::BytecodeWriterConfig *)&v35);
        v18 = mlir::IndexType::get(DesiredBytecodeVersion, v17);
        v19 = mlir::IntegerAttr::get(v18, v15);
        v30 = v19;
        if (a5 && v34)
          goto LABEL_24;
        if (v19)
        {
          Int = (mlir *)mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v30);
          Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v30);
          AffineConstantExpr = mlir::getAffineConstantExpr(Int, Context, v22);
          v24 = AffineConstantExpr;
          if (v37 >= (unint64_t)HIDWORD(v37))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v36, v38, v37 + 1, 8);
            *((_QWORD *)v36 + v37) = v24;
            LODWORD(v37) = v37 + 1;
            if (a4)
            {
LABEL_13:
              v25 = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v30);
              v26 = *(unsigned int *)(a4 + 8);
              if (v26 >= *(unsigned int *)(a4 + 12))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v26 + 1, 8);
                v26 = *(unsigned int *)(a4 + 8);
              }
              *(_QWORD *)(*(_QWORD *)a4 + 8 * v26) = v25;
              ++*(_DWORD *)(a4 + 8);
              goto LABEL_6;
            }
          }
          else
          {
            *((_QWORD *)v36 + v37) = AffineConstantExpr;
            LODWORD(v37) = v37 + 1;
            if (a4)
              goto LABEL_13;
          }
          goto LABEL_6;
        }
      }
      else
      {
        v30 = 0;
        if (a5 && v34)
        {
LABEL_24:
          v27 = 0;
          *a5 = 1;
          v28 = v36;
          if (v36 != v38)
            goto LABEL_28;
          return v27;
        }
      }
      if (v37 >= (unint64_t)HIDWORD(v37))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v36, v38, v37 + 1, 8);
        *((_QWORD *)v36 + v37) = v12;
        LODWORD(v37) = v37 + 1;
        if (!a4)
          goto LABEL_6;
LABEL_19:
        *(_DWORD *)(a4 + 8) = 0;
        a4 = 0;
        goto LABEL_6;
      }
      *((_QWORD *)v36 + v37) = v12;
      LODWORD(v37) = v37 + 1;
      if (a4)
        goto LABEL_19;
LABEL_6:
      ++v10;
      v11 -= 8;
      if (!v11)
      {
        v8 = *a1;
        break;
      }
    }
  }
  v27 = mlir::AffineMap::get(*v8, v8[1], (uint64_t)v36, v37, *((_QWORD **)v8 + 2));
  v28 = v36;
  if (v36 != v38)
LABEL_28:
    free(v28);
  return v27;
}

_QWORD *mlir::AffineMap::walkExprs(_QWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t *v6;
  uint64_t i;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[3];
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v3 = *(unsigned int *)(*result + 8);
  if ((_DWORD)v3)
  {
    v6 = (uint64_t *)(*result + 24);
    for (i = 8 * v3; i; i -= 8)
    {
      v9 = *v6;
      v10[0] = &unk_1E0E4F6B0;
      v10[1] = a2;
      v10[2] = a3;
      v11 = v10;
      mlir::AffineExpr::walk(&v9, v10);
      result = v11;
      if (v11 == v10)
      {
        result = v10;
        v8 = 4;
      }
      else
      {
        if (!v11)
          goto LABEL_5;
        v8 = 5;
      }
      result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v8))();
LABEL_5:
      ++v6;
    }
  }
  return result;
}

uint64_t mlir::AffineMap::replaceDimsAndSymbols(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  uint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  int v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  _QWORD v25[9];

  v25[8] = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x800000000;
  v10 = *a1;
  v11 = *(unsigned int *)(*a1 + 8);
  if (v11 >= 9)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v23, v25, v11, 8);
    v10 = *a1;
    LODWORD(v11) = *(_DWORD *)(*a1 + 8);
  }
  if ((_DWORD)v11)
  {
    v21 = a6;
    v12 = a7;
    v13 = (uint64_t *)(v10 + 24);
    v14 = 8 * v11;
    do
    {
      v22 = *v13;
      mlir::AffineExpr::replaceDimsAndSymbols((uint64_t)&v22);
      v16 = v15;
      v17 = v24;
      if (v24 >= (unint64_t)HIDWORD(v24))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v23, v25, v24 + 1, 8);
        v17 = v24;
      }
      *((_QWORD *)v23 + v17) = v16;
      v18 = v24 + 1;
      LODWORD(v24) = v24 + 1;
      ++v13;
      v14 -= 8;
    }
    while (v14);
    v10 = *a1;
    a7 = v12;
    a6 = v21;
  }
  else
  {
    v18 = v24;
  }
  v19 = mlir::AffineMap::get(a6, a7, (uint64_t)v23, v18, *(_QWORD **)(v10 + 16));
  if (v23 != v25)
    free(v23);
  return v19;
}

uint64_t mlir::AffineMap::replace(uint64_t *a1, unint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v14;
  void *v15;
  uint64_t v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x1E0C80C00];
  v15 = v17;
  v16 = 0x400000000;
  v10 = *a1;
  v11 = *(unsigned int *)(*a1 + 8);
  if (v11 >= 5)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v15, v17, v11, 8);
    v10 = *a1;
    LODWORD(v11) = *(_DWORD *)(*a1 + 8);
  }
  if ((_DWORD)v11)
  {
    v14 = *(_QWORD *)(v10 + 24);
    mlir::AffineExpr::replace(&v14, a2, a3);
  }
  v12 = mlir::AffineMap::get(a4, a5, (uint64_t)v15, v16, *(_QWORD **)(v10 + 16));
  if (v15 != v17)
    free(v15);
  return v12;
}

uint64_t mlir::AffineMap::isProjectedPermutation(mlir::AffineMap *this, int a2)
{
  unsigned int *v2;
  unsigned int v3;
  size_t v4;
  uint64_t v5;
  uint64_t *v9;
  uint64_t v10;
  unsigned int Position;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  size_t v20;
  uint64_t v21;
  _QWORD v22[2];

  v22[1] = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned int **)this;
  if (*(_DWORD *)(*(_QWORD *)this + 4))
    return 0;
  v3 = v2[2];
  v4 = *v2;
  if (v3 > v4)
    return 0;
  v19 = v22;
  v21 = 8;
  if (v4 < 9)
  {
    if ((_DWORD)v4)
      bzero(v22, v4);
  }
  else
  {
    v20 = 0;
    llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v19, v22, v4, 1);
    bzero(v19, v4);
    v2 = *(unsigned int **)this;
    v3 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v20 = v4;
  v5 = 1;
  if (!v3)
  {
LABEL_24:
    v15 = v19;
    if (v19 != v22)
      goto LABEL_27;
    return v5;
  }
  v9 = (uint64_t *)(v2 + 6);
  v10 = 8 * v3;
  do
  {
    v13 = *v9;
    v18 = *v9;
    if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v18) == 6)
    {
      mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v18, v13);
      v17 = v18;
      if (!v18)
      {
LABEL_17:
        v18 = v13;
        if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v18) == 5)
          v14 = v13;
        else
          v14 = 0;
        mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v18, v14);
        v16 = v18;
        if (!a2 || !v18 || mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v16))
        {
LABEL_23:
          v5 = 0;
          goto LABEL_24;
        }
        goto LABEL_14;
      }
    }
    else
    {
      mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v18, 0);
      v17 = v18;
      if (!v18)
        goto LABEL_17;
    }
    Position = mlir::AffineDimExpr::getPosition((mlir::AffineDimExpr *)&v17);
    if (*((_BYTE *)v19 + Position))
      goto LABEL_23;
    v12 = mlir::AffineDimExpr::getPosition((mlir::AffineDimExpr *)&v17);
    *((_BYTE *)v19 + v12) = 1;
LABEL_14:
    ++v9;
    v10 -= 8;
  }
  while (v10);
  v5 = 1;
  v15 = v19;
  if (v19 != v22)
LABEL_27:
    free(v15);
  return v5;
}

uint64_t mlir::AffineMap::isPermutation(mlir::AffineMap *this)
{
  if (**(_DWORD **)this == *(_DWORD *)(*(_QWORD *)this + 8))
    return mlir::AffineMap::isProjectedPermutation(this, 0);
  else
    return 0;
}

uint64_t mlir::AffineMap::getSliceMap(int **this, int a2, unsigned int a3)
{
  return mlir::AffineMap::get(**this, (*this)[1], (uint64_t)&(*this)[2 * a2 + 6], a3, *((_QWORD **)*this + 2));
}

uint64_t mlir::simplifyAffineMap(int *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  mlir::MLIRContext **v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  void *v11;
  uint64_t v12;
  _QWORD v13[9];

  v13[8] = *MEMORY[0x1E0C80C00];
  v11 = v13;
  v12 = 0x800000000;
  v2 = a1[2];
  if ((_DWORD)v2)
  {
    v3 = 0;
    v4 = 8 * v2;
    do
    {
      v5 = mlir::simplifyAffineExpr(*(mlir::MLIRContext ***)&a1[v3 / 4 + 6], *a1, a1[1]);
      v6 = v12;
      if (v12 >= (unint64_t)HIDWORD(v12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v11, v13, v12 + 1, 8);
        v6 = v12;
      }
      *((_QWORD *)v11 + v6) = v5;
      v7 = (v12 + 1);
      LODWORD(v12) = v12 + 1;
      v3 += 8;
    }
    while (v4 != v3);
    v8 = v11;
  }
  else
  {
    v7 = 0;
    v8 = v13;
  }
  v9 = mlir::AffineMap::get(*a1, a1[1], (uint64_t)v8, v7, *((_QWORD **)a1 + 2));
  if (v11 != v13)
    free(v11);
  return v9;
}

uint64_t mlir::removeDuplicateExprs(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v17;
  uint64_t v18;
  _QWORD v19[5];

  v19[4] = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned int *)(a1 + 8);
  v17 = v19;
  v18 = 0x400000000;
  if (v2 < 5)
  {
    if (!(_DWORD)v2)
    {
      v5 = (char *)v19;
      v6 = (char *)v19;
      LODWORD(v18) = 0;
      goto LABEL_15;
    }
    v3 = 0;
    v4 = v19;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v17, v19, v2, 8);
    v3 = v18;
    v4 = v17;
  }
  memcpy(&v4[v3], (const void *)(a1 + 24), 8 * v2);
  v5 = (char *)v17;
  v6 = (char *)v17;
  v7 = (v18 + v2);
  LODWORD(v18) = v18 + v2;
  if ((_DWORD)v18)
  {
    v6 = (char *)v17 + 8 * v7;
    v8 = 8 * v7 - 16;
    v9 = (char *)v17;
    while (1)
    {
      v10 = v9;
      v9 += 8;
      if (v9 == v6)
        break;
      v11 = v8;
      v12 = v10[1];
      v8 -= 8;
      if (*v10 == v12)
      {
        if (v10 + 2 != (_QWORD *)v6)
        {
          v13 = 8;
          do
          {
            v14 = v12;
            v12 = *(_QWORD *)&v9[v13];
            if (v14 != v12)
            {
              v10[1] = v12;
              ++v10;
            }
            v13 += 8;
            v11 -= 8;
          }
          while (v11);
        }
        v6 = (char *)(v10 + 1);
        break;
      }
    }
  }
LABEL_15:
  LODWORD(v18) = (unint64_t)(v6 - v5) >> 3;
  v15 = mlir::AffineMap::get(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), (uint64_t)v5, v18, *(_QWORD **)(a1 + 16));
  if (v17 != v19)
    free(v17);
  return v15;
}

_QWORD *mlir::MutableAffineMap::MutableAffineMap(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  char *v5;
  uint64_t v6;
  int v7;

  v4 = *(unsigned int *)(a2 + 8);
  v5 = (char *)(a1 + 2);
  *a1 = a1 + 2;
  a1[1] = 0x800000000;
  if (v4 < 9)
  {
    if (!(_DWORD)v4)
    {
      v7 = 0;
      goto LABEL_7;
    }
    v6 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, v5, v4, 8);
    v6 = *((unsigned int *)a1 + 2);
    v5 = (char *)*a1;
  }
  memcpy(&v5[8 * v6], (const void *)(a2 + 24), 8 * v4);
  v7 = *((_DWORD *)a1 + 2);
LABEL_7:
  *((_DWORD *)a1 + 2) = v7 + v4;
  a1[10] = *(_QWORD *)a2;
  a1[11] = *(_QWORD *)(a2 + 16);
  return a1;
}

uint64_t mlir::MutableAffineMap::reset(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 80) = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 16);
  return llvm::SmallVectorImpl<mlir::Attribute>::insert<mlir::Attribute const*,void>(a1, *(_QWORD *)a1, (char *)(a2 + 24), (char *)(a2 + 24 + 8 * *(unsigned int *)(a2 + 8)));
}

uint64_t mlir::MutableAffineMap::getAffineMap(mlir::MutableAffineMap *this)
{
  return mlir::AffineMap::get(*((_DWORD *)this + 20), *((_DWORD *)this + 21), *(_QWORD *)this, *((unsigned int *)this + 2), *((_QWORD **)this + 11));
}

void `anonymous namespace'::AffineExprConstantFolder::constantFoldImpl(uint64_t a1, uint64_t a2)
{
  char *v2;
  uint64_t v3;

  v3 = a2;
  v2 = (char *)sub_1803A7C70 + 4 * byte_181236A22[mlir::AffineExpr::getKind((mlir::AffineExpr *)&v3)];
  __asm { BR              X10 }
}

unint64_t sub_1803A7C70()
{
  uint64_t v0;
  uint64_t v2[6];

}

unint64_t `anonymous namespace'::AffineExprConstantFolder::constantFoldBinExpr(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t LHS;
  uint64_t v8;
  char v9;
  uint64_t v10;
  uint64_t RHS;
  uint64_t v12;
  char v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v18;

  mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v18, a2);
  LHS = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v18);
  if (v9
    && (v10 = v8,
        RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v18),
        v13))
  {
    v14 = a3(a4, v10, v12);
    v15 = v14 & 0xFFFFFFFFFFFFFF00;
    v16 = v14;
  }
  else
  {
    v16 = 0;
    v15 = 0;
  }
  return v15 | v16;
}

uint64_t llvm::function_ref<std::optional<long long> ()(long long,long long)>::callback_fn<`anonymous namespace'::AffineExprConstantFolder::constantFoldImpl(mlir::AffineExpr)::{lambda(long long,long long)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 + a2;
}

uint64_t llvm::function_ref<std::optional<long long> ()(long long,long long)>::callback_fn<`anonymous namespace'::AffineExprConstantFolder::constantFoldImpl(mlir::AffineExpr)::{lambda(long long,long long)#2}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 * a2;
}

uint64_t llvm::function_ref<std::optional<long long> ()(long long,long long)>::callback_fn<`anonymous namespace'::AffineExprConstantFolder::constantFoldImpl(mlir::AffineExpr)::{lambda(long long,long long)#3}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  if (a3 > 0)
    return (a3 & ((a2 % a3) >> 63)) + a2 % a3;
  result = 0;
  *(_BYTE *)(*(_QWORD *)a1 + 24) = 1;
  return result;
}

uint64_t llvm::function_ref<std::optional<long long> ()(long long,long long)>::callback_fn<`anonymous namespace'::AffineExprConstantFolder::constantFoldImpl(mlir::AffineExpr)::{lambda(long long,long long)#4}>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t result;

  if (a3)
  {
    v3 = -1;
    if (a3 < 0)
      v3 = 1;
    if (a2 && a2 >> 63 != (unint64_t)a3 >> 63)
      return ~((uint64_t)(v3 - a2) / a3);
    else
      return (uint64_t)a2 / a3;
  }
  else
  {
    result = 0;
    *(_BYTE *)(*(_QWORD *)a1 + 24) = 1;
  }
  return result;
}

uint64_t llvm::function_ref<std::optional<long long> ()(long long,long long)>::callback_fn<`anonymous namespace'::AffineExprConstantFolder::constantFoldImpl(mlir::AffineExpr)::{lambda(long long,long long)#5}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t result;

  if (a3)
  {
    if (a2 && a2 < 1 != a3 > 0)
    {
      if (a3 <= 0)
        v3 = a2 + 1;
      else
        v3 = a2 - 1;
      return v3 / a3 + 1;
    }
    else
    {
      return a2 / a3;
    }
  }
  else
  {
    result = 0;
    *(_BYTE *)(*(_QWORD *)a1 + 24) = 1;
  }
  return result;
}

__n128 std::__function::__func<void mlir::getMaxDimAndSymbol<llvm::ArrayRef<mlir::AffineExpr>>(llvm::ArrayRef<llvm::ArrayRef<mlir::AffineExpr>>,long long &,long long &)::{lambda(mlir::AffineExpr)#1},std::allocator<void mlir::getMaxDimAndSymbol<llvm::ArrayRef<mlir::AffineExpr>>(llvm::ArrayRef<llvm::ArrayRef<mlir::AffineExpr>>,long long &,long long &)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = off_1E0E51798;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<void mlir::getMaxDimAndSymbol<llvm::ArrayRef<mlir::AffineExpr>>(llvm::ArrayRef<llvm::ArrayRef<mlir::AffineExpr>>,long long &,long long &)::{lambda(mlir::AffineExpr)#1},std::allocator<void mlir::getMaxDimAndSymbol<llvm::ArrayRef<mlir::AffineExpr>>(llvm::ArrayRef<llvm::ArrayRef<mlir::AffineExpr>>,long long &,long long &)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = off_1E0E51798;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

_QWORD *std::__function::__func<void mlir::getMaxDimAndSymbol<llvm::ArrayRef<mlir::AffineExpr>>(llvm::ArrayRef<llvm::ArrayRef<mlir::AffineExpr>>,long long &,long long &)::{lambda(mlir::AffineExpr)#1},std::allocator<void mlir::getMaxDimAndSymbol<llvm::ArrayRef<mlir::AffineExpr>>(llvm::ArrayRef<llvm::ArrayRef<mlir::AffineExpr>>,long long &,long long &)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t Position;
  _QWORD *result;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v3 = *a2;
  v9 = *a2;
  if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v9) == 6)
  {
    mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v9, v3);
    if (!v9)
      goto LABEL_8;
  }
  else
  {
    mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v9, 0);
    if (!v9)
      goto LABEL_8;
  }
  v4 = *(uint64_t **)(a1 + 8);
  Position = mlir::AffineDimExpr::getPosition((mlir::AffineDimExpr *)&v9);
  if (*v4 > Position)
    Position = *v4;
  **(_QWORD **)(a1 + 8) = Position;
LABEL_8:
  v9 = v3;
  if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v9) == 7)
  {
    result = mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v9, v3);
    if (!v9)
      return result;
  }
  else
  {
    result = mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v9, 0);
    if (!v9)
      return result;
  }
  v7 = *(uint64_t **)(a1 + 16);
  result = (_QWORD *)mlir::AffineDimExpr::getPosition((mlir::AffineDimExpr *)&v9);
  v8 = result;
  if (*v7 > result)
    v8 = *v7;
  **(_QWORD **)(a1 + 16) = v8;
  return result;
}

uint64_t std::__function::__func<void mlir::getMaxDimAndSymbol<llvm::ArrayRef<mlir::AffineExpr>>(llvm::ArrayRef<llvm::ArrayRef<mlir::AffineExpr>>,long long &,long long &)::{lambda(mlir::AffineExpr)#1},std::allocator<void mlir::getMaxDimAndSymbol<llvm::ArrayRef<mlir::AffineExpr>>(llvm::ArrayRef<llvm::ArrayRef<mlir::AffineExpr>>,long long &,long long &)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if ((char *)v3 == "ZN4mlirL18getMaxDimAndSymbolIN4llvm8ArrayRefINS_10AffineExprEEEEEvNS2_IT_EERxS7_EUlS3_E_")
    return a1 + 8;
  if (((v3 & (unint64_t)"ZN4mlirL18getMaxDimAndSymbolIN4llvm8ArrayRefINS_10AffineExprEEEEEvNS2_IT_EERxS7_EUlS3_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN4mlirL18getMaxDimAndSymbolIN4llvm8ArrayRefINS_10AffineExprEEEEEvNS2_IT_EERxS7_EUlS3_E_"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN4mlirL18getMaxDimAndSymbolIN4llvm8ArrayRefINS_10AffineExprEEEEEvNS2_IT_EERxS7_EUlS3_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  return 0;
}

void *std::__function::__func<void mlir::getMaxDimAndSymbol<llvm::ArrayRef<mlir::AffineExpr>>(llvm::ArrayRef<llvm::ArrayRef<mlir::AffineExpr>>,long long &,long long &)::{lambda(mlir::AffineExpr)#1},std::allocator<void mlir::getMaxDimAndSymbol<llvm::ArrayRef<mlir::AffineExpr>>(llvm::ArrayRef<llvm::ArrayRef<mlir::AffineExpr>>,long long &,long long &)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::target_type()
{
}

__n128 std::__function::__func<llvm::function_ref<void ()(mlir::AffineExpr)>,std::allocator<llvm::function_ref<void ()(mlir::AffineExpr)>>,void ()(mlir::AffineExpr)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &unk_1E0E4F6B0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<llvm::function_ref<void ()(mlir::AffineExpr)>,std::allocator<llvm::function_ref<void ()(mlir::AffineExpr)>>,void ()(mlir::AffineExpr)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &unk_1E0E4F6B0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<llvm::function_ref<void ()(mlir::AffineExpr)>,std::allocator<llvm::function_ref<void ()(mlir::AffineExpr)>>,void ()(mlir::AffineExpr)>::operator()(uint64_t a1, _QWORD *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 8))(*(_QWORD *)(a1 + 16), *a2);
}

uint64_t std::__function::__func<llvm::function_ref<void ()(mlir::AffineExpr)>,std::allocator<llvm::function_ref<void ()(mlir::AffineExpr)>>,void ()(mlir::AffineExpr)>::target(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3 == 0x8000000181236B74)
    return a1 + 8;
  if (((v3 & 0x8000000181236B74 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x8000000181236B74))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x8000000181236B74 & 0x7FFFFFFFFFFFFFFFLL)))
    return a1 + 8;
  return 0;
}

void *std::__function::__func<llvm::function_ref<void ()(mlir::AffineExpr)>,std::allocator<llvm::function_ref<void ()(mlir::AffineExpr)>>,void ()(mlir::AffineExpr)>::target_type()
{
}

llvm::raw_ostream *mlir::OperationName::print(mlir::OperationName *this, llvm::raw_ostream *a2)
{
  size_t v3;
  const char *AttrData;
  size_t v5;
  llvm::raw_ostream *result;
  uint64_t v7;

  v7 = *(_QWORD *)(*(_QWORD *)this + 8);
  AttrData = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v7);
  v5 = v3;
  result = (llvm::raw_ostream *)*((_QWORD *)a2 + 4);
  if (v3 > *((_QWORD *)a2 + 3) - (_QWORD)result)
    return llvm::raw_ostream::write(a2, AttrData, v3);
  if (v3)
  {
    result = (llvm::raw_ostream *)memcpy(result, AttrData, v3);
    *((_QWORD *)a2 + 4) += v5;
  }
  return result;
}

uint64_t mlir::AsmParser::getContext(mlir::AsmParser *this)
{
  return *(_QWORD *)(*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)this + 32))(this);
}

uint64_t mlir::AsmParser::parseTypeList(uint64_t a1, uint64_t a2)
{
  _QWORD v3[2];

  v3[0] = a1;
  v3[1] = a2;
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(uint64_t *), _QWORD *, _QWORD, _QWORD))(*(_QWORD *)a1 + 360))(a1, 0, llvm::function_ref<mlir::ParseResult ()(void)>::callback_fn<mlir::AsmParser::parseTypeList(llvm::SmallVectorImpl<mlir::Type> &)::$_0>, v3, 0, 0);
}

llvm::raw_ostream *mlir::OpAsmPrinter::printFunctionalType(mlir::OpAsmPrinter *this, mlir::Operation *a2)
{
  llvm::raw_ostream *v4;
  llvm::raw_ostream *v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _BYTE *v13;
  uint64_t v14;
  llvm::raw_ostream *result;
  char *v16;
  uint64_t v17;
  uint64_t *v18;
  unint64_t v19;
  _WORD *v20;
  uint64_t v21;
  uint64_t NextResultAtOffset;
  _BYTE *v23;
  uint64_t i;
  unint64_t v25;
  _WORD *v26;
  uint64_t v27;

  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)this + 16))(this);
  v5 = v4;
  v6 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v6 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 40);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v6 + 1;
    *v6 = 40;
  }
  if ((*((_BYTE *)a2 + 46) & 0x80) != 0)
  {
    v7 = *((unsigned int *)a2 + 17);
    if ((_DWORD)v7)
    {
      v8 = *((_QWORD *)a2 + 9);
      v9 = *(_QWORD *)(v8 + 24);
      if (v9)
      {
        (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)this + 32))(this, *(_QWORD *)(v9 + 8) & 0xFFFFFFFFFFFFFFF8);
        if ((_DWORD)v7 != 1)
          goto LABEL_24;
      }
      else
      {
        (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)this + 32))(this, 0);
        if ((_DWORD)v7 != 1)
        {
LABEL_24:
          v17 = v7 - 1;
          v18 = (uint64_t *)(v8 + 56);
          do
          {
            v20 = (_WORD *)*((_QWORD *)v5 + 4);
            if (*((_QWORD *)v5 + 3) - (_QWORD)v20 > 1uLL)
            {
              *v20 = 8236;
              *((_QWORD *)v5 + 4) += 2;
              v21 = *v18;
              if (!*v18)
              {
LABEL_31:
                v19 = 0;
                goto LABEL_26;
              }
            }
            else
            {
              llvm::raw_ostream::write(v5, ", ", 2uLL);
              v21 = *v18;
              if (!*v18)
                goto LABEL_31;
            }
            v19 = *(_QWORD *)(v21 + 8) & 0xFFFFFFFFFFFFFFF8;
LABEL_26:
            (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)this + 32))(this, v19);
            v18 += 4;
            --v17;
          }
          while (v17);
        }
      }
    }
  }
  v10 = *((_QWORD *)v5 + 4);
  if ((unint64_t)(*((_QWORD *)v5 + 3) - v10) > 4)
  {
    *(_BYTE *)(v10 + 4) = 32;
    *(_DWORD *)v10 = 1043144745;
    *((_QWORD *)v5 + 4) += 5;
    if (*((_DWORD *)a2 + 9) != 1)
      goto LABEL_18;
  }
  else
  {
    llvm::raw_ostream::write(v5, ") -> ", 5uLL);
    if (*((_DWORD *)a2 + 9) != 1)
      goto LABEL_18;
  }
  if ((*((_QWORD *)a2 - 1) & 0xFFFFFFFFFFFFFFF8) != 0
    && *(_UNKNOWN **)(*(_QWORD *)(*((_QWORD *)a2 - 1) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
  {
LABEL_18:
    v13 = (_BYTE *)*((_QWORD *)v5 + 4);
    if ((unint64_t)v13 >= *((_QWORD *)v5 + 3))
    {
      llvm::raw_ostream::write(v5, 40);
      v14 = *((unsigned int *)a2 + 9);
      result = (mlir::Operation *)((char *)a2 - 16);
      if ((_DWORD)v14)
        v16 = (char *)a2 - 16;
      else
        v16 = 0;
      if (!(_DWORD)v14)
        goto LABEL_42;
    }
    else
    {
      *((_QWORD *)v5 + 4) = v13 + 1;
      *v13 = 40;
      v14 = *((unsigned int *)a2 + 9);
      result = (mlir::Operation *)((char *)a2 - 16);
      if ((_DWORD)v14)
        v16 = (char *)a2 - 16;
      else
        v16 = 0;
      if (!(_DWORD)v14)
        goto LABEL_42;
    }
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)result, 0);
    if (NextResultAtOffset)
    {
      result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)this + 32))(this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
      if ((_DWORD)v14 != 1)
        goto LABEL_45;
    }
    else
    {
      result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)this + 32))(this, 0);
      if ((_DWORD)v14 != 1)
      {
LABEL_45:
        for (i = 1; v14 != i; ++i)
        {
          v26 = (_WORD *)*((_QWORD *)v5 + 4);
          if (*((_QWORD *)v5 + 3) - (_QWORD)v26 > 1uLL)
          {
            *v26 = 8236;
            *((_QWORD *)v5 + 4) += 2;
            v27 = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v16, i);
            if (!v27)
            {
LABEL_52:
              v25 = 0;
              goto LABEL_47;
            }
          }
          else
          {
            llvm::raw_ostream::write(v5, ", ", 2uLL);
            v27 = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v16, i);
            if (!v27)
              goto LABEL_52;
          }
          v25 = *(_QWORD *)(v27 + 8) & 0xFFFFFFFFFFFFFFF8;
LABEL_47:
          result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)this + 32))(this, v25);
        }
      }
    }
LABEL_42:
    v23 = (_BYTE *)*((_QWORD *)v5 + 4);
    if ((unint64_t)v23 >= *((_QWORD *)v5 + 3))
      return llvm::raw_ostream::write(v5, 41);
    *((_QWORD *)v5 + 4) = v23 + 1;
    *v23 = 41;
    return result;
  }
  v11 = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)a2 - 16, 0);
  if (v11)
    v12 = *(_QWORD *)(v11 + 8) & 0xFFFFFFFFFFFFFFF8;
  else
    v12 = 0;
  return (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)this + 32))(this, v12);
}

void mlir::registerAsmPrinterCLOptions(mlir *this)
{
  if (!atomic_load(clOptions))
}

mlir::OpPrintingFlags *mlir::OpPrintingFlags::OpPrintingFlags(mlir::OpPrintingFlags *this)
{
  uint64_t v5;
  uint64_t v8;

  *(_BYTE *)this = 0;
  *((_BYTE *)this + 8) = 0;
  *((_BYTE *)this + 16) = 0;
  *((_BYTE *)this + 24) = 0;
  *((_BYTE *)this + 32) &= 0x80u;
  if (!atomic_load(clOptions))
    return this;
  if (!atomic_load(clOptions))
  if (*(_WORD *)(clOptions[0] + 208))
  {
    if (atomic_load(clOptions))
    {
      v5 = *(unsigned int *)(clOptions[0] + 328);
      if (*((_BYTE *)this + 8))
      {
LABEL_7:
        *(_QWORD *)this = v5;
        goto LABEL_8;
      }
    }
    else
    {
      v5 = *(unsigned int *)(clOptions[0] + 328);
      if (*((_BYTE *)this + 8))
        goto LABEL_7;
    }
    *((_BYTE *)this + 8) = 1;
    goto LABEL_7;
  }
LABEL_8:
  if (!atomic_load(clOptions))
  if (!*(_WORD *)(clOptions[0] + 400))
    goto LABEL_14;
  if (!atomic_load(clOptions))
  {
    v8 = *(unsigned int *)(clOptions[0] + 520);
    if (*((_BYTE *)this + 24))
      goto LABEL_13;
LABEL_31:
    *((_BYTE *)this + 24) = 1;
    goto LABEL_13;
  }
  v8 = *(unsigned int *)(clOptions[0] + 520);
  if (!*((_BYTE *)this + 24))
    goto LABEL_31;
LABEL_13:
  *((_QWORD *)this + 2) = v8;
LABEL_14:
  if (!atomic_load(clOptions))
  *((_BYTE *)this + 32) = *((_BYTE *)this + 32) & 0xFE | *(_BYTE *)(clOptions[0] + 712);
  if (!atomic_load(clOptions))
  *((_BYTE *)this + 32) = *((_BYTE *)this + 32) & 0xFD | (2 * *(_BYTE *)(clOptions[0] + 904));
  if (!atomic_load(clOptions))
  *((_BYTE *)this + 32) = *((_BYTE *)this + 32) & 0xFB | (4 * *(_BYTE *)(clOptions[0] + 1096));
  if (!atomic_load(clOptions))
  *((_BYTE *)this + 32) = *((_BYTE *)this + 32) & 0xEF | (16 * *(_BYTE *)(clOptions[0] + 1288));
  if (!atomic_load(clOptions))
  *((_BYTE *)this + 32) = *((_BYTE *)this + 32) & 0xDF | (32 * *(_BYTE *)(clOptions[0] + 1480));
  if (!atomic_load(clOptions))
  *((_BYTE *)this + 32) = *((_BYTE *)this + 32) & 0xBF | (*(_BYTE *)(clOptions[0] + 1672) << 6);
  return this;
}

uint64_t mlir::OpPrintingFlags::elideLargeElementsAttrs(uint64_t this, uint64_t a2)
{
  *(_QWORD *)this = a2;
  *(_BYTE *)(this + 8) = 1;
  return this;
}

uint64_t mlir::OpPrintingFlags::elideLargeResourceString(uint64_t this, uint64_t a2)
{
  if (!*(_BYTE *)(this + 24))
    *(_BYTE *)(this + 24) = 1;
  *(_QWORD *)(this + 16) = a2;
  return this;
}

uint64_t mlir::OpPrintingFlags::enableDebugInfo(uint64_t this, char a2, int a3)
{
  char v3;

  if (a3)
    v3 = 2;
  else
    v3 = 0;
  *(_BYTE *)(this + 32) = v3 | a2 | *(_BYTE *)(this + 32) & 0xFC;
  return this;
}

uint64_t mlir::OpPrintingFlags::printGenericOpForm(uint64_t this, int a2)
{
  char v2;

  if (a2)
    v2 = 4;
  else
    v2 = 0;
  *(_BYTE *)(this + 32) = *(_BYTE *)(this + 32) & 0xFB | v2;
  return this;
}

uint64_t mlir::OpPrintingFlags::useLocalScope(uint64_t this)
{
  *(_BYTE *)(this + 32) |= 0x20u;
  return this;
}

uint64_t mlir::OpPrintingFlags::shouldElideElementsAttr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;

  if (!*(_BYTE *)(a1 + 8))
    return 0;
  v4 = *(_QWORD *)a1;
  if (v4 >= mlir::ElementsAttr::getNumElements(a2, a3))
    return 0;
  if (mlir::DenseElementsAttr::classof(a2))
    v5 = a2;
  else
    v5 = 0;
  v7 = v5;
  if (v5)
    return mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v7) ^ 1;
  else
    return 1;
}

uint64_t mlir::OpPrintingFlags::getLargeElementsAttrLimit(mlir::OpPrintingFlags *this)
{
  return *(_QWORD *)this;
}

void mlir::AsmResourcePrinter::~AsmResourcePrinter(void **this)
{
  *this = off_1E0E2BBB0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

char *mlir::toString(int a1)
{
  return (&off_1E0E54110)[a1];
}

_QWORD *mlir::FallbackAsmResourceMap::getParserFor(uint64_t a1, const void *a2, size_t a3)
{
  void **p_dst;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  void **__dst;
  size_t v18;
  unint64_t v19;

  if (!a2)
  {
    __dst = 0;
    v18 = 0;
    v19 = 0;
    v7 = llvm::MapVector<std::string,std::unique_ptr<mlir::FallbackAsmResourceMap::ResourceCollection>,llvm::StringMap<unsigned int,llvm::MallocAllocator>,llvm::SmallVector<std::pair<std::string,std::unique_ptr<mlir::FallbackAsmResourceMap::ResourceCollection>>,0u>>::operator[](a1, (uint64_t)&__dst);
    if ((SHIBYTE(v19) & 0x80000000) == 0)
      goto LABEL_13;
LABEL_15:
    operator delete(__dst);
    v10 = *(_QWORD **)v7;
    if (*(_QWORD *)v7)
      return v10;
    goto LABEL_16;
  }
  if (a3 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_29;
  if (a3 >= 0x17)
  {
    v8 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17)
      v8 = a3 | 7;
    v9 = v8 + 1;
    p_dst = (void **)operator new(v8 + 1);
    v18 = a3;
    v19 = v9 | 0x8000000000000000;
    __dst = p_dst;
    goto LABEL_11;
  }
  HIBYTE(v19) = a3;
  p_dst = (void **)&__dst;
  if (a3)
LABEL_11:
    memmove(p_dst, a2, a3);
  *((_BYTE *)p_dst + a3) = 0;
  v7 = llvm::MapVector<std::string,std::unique_ptr<mlir::FallbackAsmResourceMap::ResourceCollection>,llvm::StringMap<unsigned int,llvm::MallocAllocator>,llvm::SmallVector<std::pair<std::string,std::unique_ptr<mlir::FallbackAsmResourceMap::ResourceCollection>>,0u>>::operator[](a1, (uint64_t)&__dst);
  if (SHIBYTE(v19) < 0)
    goto LABEL_15;
LABEL_13:
  v10 = *(_QWORD **)v7;
  if (*(_QWORD *)v7)
    return v10;
LABEL_16:
  v11 = operator new(0x90uLL);
  v10 = v11;
  v12 = v11 + 1;
  if (!a2)
  {
    *v12 = 0;
    v11[2] = 0;
    v11[3] = 0;
    *v11 = off_1E0E2BDF0;
    v11[4] = v11 + 6;
    v11[5] = 0x100000000;
    *(_QWORD *)v7 = v11;
    return v10;
  }
  if (a3 > 0x7FFFFFFFFFFFFFF7)
LABEL_29:
    abort();
  if (a3 >= 0x17)
  {
    v13 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17)
      v13 = a3 | 7;
    v14 = v13 + 1;
    v12 = operator new(v13 + 1);
    v10[2] = a3;
    v10[3] = v14 | 0x8000000000000000;
    v10[1] = v12;
    goto LABEL_25;
  }
  *((_BYTE *)v11 + 31) = a3;
  if (a3)
LABEL_25:
    memmove(v12, a2, a3);
  *((_BYTE *)v12 + a3) = 0;
  v15 = *(_QWORD **)v7;
  *v10 = off_1E0E2BDF0;
  v10[4] = v10 + 6;
  v10[5] = 0x100000000;
  *(_QWORD *)v7 = v10;
  if (v15)
  {
    (*(void (**)(_QWORD *))(*v15 + 8))(v15);
    return *(_QWORD **)v7;
  }
  return v10;
}

uint64_t llvm::MapVector<std::string,std::unique_ptr<mlir::FallbackAsmResourceMap::ResourceCollection>,llvm::StringMap<unsigned int,llvm::MallocAllocator>,llvm::SmallVector<std::pair<std::string,std::unique_ptr<mlir::FallbackAsmResourceMap::ResourceCollection>>,0u>>::operator[](uint64_t a1, uint64_t a2)
{
  int8x16_t *p_p;
  std::string::size_type size;
  uint64_t v6;
  char v7;
  uint64_t v8;
  unint64_t v9;
  std::string *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  std::string::pointer data;
  uint64_t v16;
  unint64_t *v18;
  unint64_t v19;
  BOOL v20;
  char *v21;
  int v22;
  std::string v23;
  uint64_t v24;
  std::string __p;
  int v26;

  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v23, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v23 = *(std::string *)a2;
  __p = v23;
  if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = (int8x16_t *)&__p;
  else
    p_p = (int8x16_t *)v23.__r_.__value_.__r.__words[0];
  v26 = 0;
  if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v23.__r_.__value_.__r.__words[2]);
  else
    size = v23.__r_.__value_.__l.__size_;
  v22 = 0;
  v6 = *llvm::StringMap<unsigned int,llvm::MallocAllocator>::try_emplace<unsigned int>(a1, p_p, (const unsigned __int8 *)size, &v22);
  if (v7)
  {
    if (*(char *)(a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v23, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
      v24 = 0;
      v8 = *(unsigned int *)(a1 + 32);
      v9 = *(_QWORD *)(a1 + 24);
      v10 = &v23;
      if (v8 < *(_DWORD *)(a1 + 36))
        goto LABEL_17;
    }
    else
    {
      v23 = *(std::string *)a2;
      v24 = 0;
      v8 = *(unsigned int *)(a1 + 32);
      v9 = *(_QWORD *)(a1 + 24);
      v10 = &v23;
      if (v8 < *(_DWORD *)(a1 + 36))
        goto LABEL_17;
    }
    v18 = (unint64_t *)(a1 + 24);
    v19 = v8 + 1;
    v20 = v9 + 32 * v8 > (unint64_t)&v23;
    if (v9 <= (unint64_t)&v23 && v20)
    {
      v21 = (char *)&v23 - v9;
      llvm::SmallVectorTemplateBase<std::pair<std::string,std::unique_ptr<mlir::FallbackAsmResourceMap::ResourceCollection>>,false>::grow(a1 + 24, v19);
      v9 = *v18;
      v10 = (std::string *)&v21[*v18];
    }
    else
    {
      llvm::SmallVectorTemplateBase<std::pair<std::string,std::unique_ptr<mlir::FallbackAsmResourceMap::ResourceCollection>>,false>::grow(a1 + 24, v19);
      v9 = *v18;
      v10 = &v23;
    }
LABEL_17:
    v13 = v9 + 32 * *(unsigned int *)(a1 + 32);
    v14 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    *(_QWORD *)(v13 + 16) = *((_QWORD *)&v10->__r_.__value_.__l + 2);
    *(_OWORD *)v13 = v14;
    v10->__r_.__value_.__r.__words[0] = 0;
    v10->__r_.__value_.__l.__size_ = 0;
    data = v10[1].__r_.__value_.__l.__data_;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10[1].__r_.__value_.__r.__words[0] = 0;
    *(_QWORD *)(v13 + 24) = data;
    ++*(_DWORD *)(a1 + 32);
    v16 = v24;
    v24 = 0;
    if (v16)
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v23.__r_.__value_.__l.__data_);
    v11 = *(_DWORD *)(a1 + 32) - 1;
    *(_DWORD *)(v6 + 8) = v11;
    v12 = *(_QWORD *)(a1 + 24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      goto LABEL_22;
    return v12 + 32 * v11 + 24;
  }
  v11 = *(_DWORD *)(v6 + 8);
  v12 = *(_QWORD *)(a1 + 24);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
LABEL_22:
    operator delete(__p.__r_.__value_.__l.__data_);
  return v12 + 32 * v11 + 24;
}

_QWORD *mlir::FallbackAsmResourceMap::getPrinters@<X0>(_QWORD *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  int v7;
  const void *v8;
  size_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v3 = *((unsigned int *)this + 8);
  if ((_DWORD)v3)
  {
    v4 = 32 * v3;
    for (i = this[3] + 24; ; i += 32)
    {
      v6 = *(_QWORD *)i;
      v7 = *(char *)(*(_QWORD *)i + 31);
      if (v7 >= 0)
        v8 = (const void *)(*(_QWORD *)i + 8);
      else
        v8 = *(const void **)(*(_QWORD *)i + 8);
      if (v7 >= 0)
        v9 = *(unsigned __int8 *)(*(_QWORD *)i + 31);
      else
        v9 = *(_QWORD *)(v6 + 16);
      v10 = operator new(0x28uLL);
      v11 = v10;
      v12 = v10 + 1;
      if (!v8)
      {
        *v12 = 0;
        v10[2] = 0;
        v10[3] = 0;
        *v10 = &off_1E0E52D10;
        v10[4] = v6;
        v16 = v10;
        v13 = (_QWORD *)a2[1];
        if ((unint64_t)v13 >= a2[2])
          goto LABEL_16;
        goto LABEL_23;
      }
      if (v9 >= 0x7FFFFFFFFFFFFFF8)
        abort();
      if (v9 >= 0x17)
        break;
      *((_BYTE *)v10 + 31) = v9;
      if (v9)
        goto LABEL_21;
LABEL_22:
      *((_BYTE *)v12 + v9) = 0;
      *v11 = &off_1E0E52D10;
      v11[4] = v6;
      v16 = v11;
      v13 = (_QWORD *)a2[1];
      if ((unint64_t)v13 >= a2[2])
      {
LABEL_16:
        a2[1] = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2, (uint64_t *)&v16);
        this = v16;
        v16 = 0;
        if (!this)
          goto LABEL_3;
LABEL_24:
        this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
        goto LABEL_3;
      }
LABEL_23:
      v16 = 0;
      *v13 = v11;
      a2[1] = v13 + 1;
      this = v16;
      v16 = 0;
      if (this)
        goto LABEL_24;
LABEL_3:
      v4 -= 32;
      if (!v4)
        return this;
    }
    v14 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17)
      v14 = v9 | 7;
    v15 = v14 + 1;
    v12 = operator new(v14 + 1);
    v11[2] = v9;
    v11[3] = v15 | 0x8000000000000000;
    v11[1] = v12;
LABEL_21:
    memmove(v12, v8, v9);
    goto LABEL_22;
  }
  return this;
}

uint64_t mlir::FallbackAsmResourceMap::ResourceCollection::parseResource(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  llvm **v6;
  char v7;
  llvm **v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *__p;
  uint64_t v15;
  uint64_t v16;
  llvm *v17[2];
  unint64_t v18;
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2);
  switch(v4)
  {
    case 2:
      (*(void (**)(void **__return_ptr, uint64_t))(*(_QWORD *)a2 + 48))(&__p, a2);
      if (LOBYTE(v17[0]))
      {
        v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
        v13 = v9;
        llvm::SmallVectorImpl<mlir::FallbackAsmResourceMap::OpaqueAsmResource>::emplace_back<llvm::StringRef,std::string>(a1 + 32, (const void **)&v12, (uint64_t)&__p);
        if (LOBYTE(v17[0]) && SHIBYTE(v16) < 0)
          operator delete(__p);
        return 1;
      }
      return 0;
    case 1:
      LOWORD(v12) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
      if ((unsigned __int16)v12 <= 0xFFu)
        return 0;
      __p = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
      v15 = v11;
      llvm::SmallVectorImpl<mlir::FallbackAsmResourceMap::OpaqueAsmResource>::emplace_back<llvm::StringRef,BOOL &>(a1 + 32, (const void **)&__p, &v12);
      break;
    case 0:
      (*(void (**)(void **__return_ptr, uint64_t, void *(*)@<X0>(size_t@<X1>, std::align_val_t@<X2>, uint64_t@<X8>), uint64_t *))(*(_QWORD *)a2 + 56))(&__p, a2, llvm::function_ref<mlir::AsmResourceBlob ()(unsigned long,unsigned long)>::callback_fn<mlir::AsmParsedResourceEntry::parseAsBlob(void)::{lambda(unsigned long,unsigned long)#1}>, &v12);
      if (v19)
      {
        v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
        v13 = v5;
        llvm::SmallVectorImpl<mlir::FallbackAsmResourceMap::OpaqueAsmResource>::emplace_back<llvm::StringRef,mlir::AsmResourceBlob>(a1 + 32, (const void **)&v12, (uint64_t)&__p);
        if (v19 && v18 >= 8)
        {
          v6 = (v18 & 2) != 0 ? v17 : (llvm **)v17[0];
          (*(void (**)(llvm **, void *, uint64_t, uint64_t))(v18 & 0xFFFFFFFFFFFFFFF8))(v6, __p, v15, v16);
          v7 = v18;
          if (v18 >= 8)
          {
            if ((v18 & 4) != 0)
            {
              if ((v18 & 2) != 0)
                v8 = v17;
              else
                v8 = (llvm **)v17[0];
              (*(void (**)(llvm **))((v18 & 0xFFFFFFFFFFFFFFF8) + 16))(v8);
            }
            if ((v7 & 2) == 0)
              llvm::deallocate_buffer(v17[0], v17[1]);
          }
        }
        return 1;
      }
      return 0;
  }
  return 1;
}

uint64_t llvm::SmallVectorImpl<mlir::FallbackAsmResourceMap::OpaqueAsmResource>::emplace_back<llvm::StringRef,mlir::AsmResourceBlob>(uint64_t a1, const void **a2, uint64_t a3)
{
  unsigned int v5;
  uint64_t v6;
  _QWORD *v7;
  size_t v8;
  const void *v9;
  unint64_t v10;
  __int128 *v11;
  int v12;
  uint64_t v13;
  _DWORD *v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  unsigned int v20;
  char v22;
  __int128 v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  unint64_t v27;
  char v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v5 = *(_DWORD *)(a1 + 8);
  if (v5 < *(_DWORD *)(a1 + 12))
  {
    v6 = *(_QWORD *)a1;
    v7 = (_QWORD *)(*(_QWORD *)a1 + 96 * v5);
    v9 = *a2;
    v8 = (size_t)a2[1];
    v23 = *(_OWORD *)a3;
    v10 = *(_QWORD *)(a3 + 48);
    v24 = *(_QWORD *)(a3 + 16);
    v27 = v10;
    if (v10 >= 8)
    {
      v11 = (__int128 *)(a3 + 24);
      if ((v10 & 2) != 0 && (v10 & 4) != 0)
      {
        (*(void (**)(__int128 *, __int128 *))((v10 & 0xFFFFFFFFFFFFFFF8) + 8))(&v25, v11);
      }
      else
      {
        v25 = *v11;
        v26 = *(_QWORD *)(a3 + 40);
      }
      *(_QWORD *)(a3 + 48) = 0;
    }
    v28 = *(_BYTE *)(a3 + 56);
    v29 = 0;
    if (!v9)
    {
      v12 = 0;
      v13 = v6 + 96 * v5;
      *(_DWORD *)(v13 + 88) = -1;
      v14 = (_DWORD *)(v13 + 88);
      *v7 = 0;
      v7[1] = 0;
      v15 = v14 - 16;
      *((_BYTE *)v7 + 24) = 0;
      v7[2] = 0;
      goto LABEL_19;
    }
    if (v8 >= 0x7FFFFFFFFFFFFFF8)
      abort();
    if (v8 >= 0x17)
    {
      v16 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v8 | 7) != 0x17)
        v16 = v8 | 7;
      v17 = v16 + 1;
      v18 = operator new(v16 + 1);
      v7[1] = v8;
      v7[2] = v17 | 0x8000000000000000;
      *v7 = v18;
      v7 = v18;
    }
    else
    {
      *((_BYTE *)v7 + 23) = v8;
      if (!v8)
      {
LABEL_18:
        *((_BYTE *)v7 + v8) = 0;
        v12 = v29;
        v19 = v6 + 96 * v5;
        *(_BYTE *)(v19 + 24) = 0;
        v15 = (_DWORD *)(v19 + 24);
        v15[16] = -1;
        v14 = v15 + 16;
        if (v12 == -1)
        {
LABEL_21:
          v20 = *(_DWORD *)(a1 + 8) + 1;
          *(_DWORD *)(a1 + 8) = v20;
          return *(_QWORD *)a1 + 96 * v20 - 96;
        }
LABEL_19:
        ((void (*)(char *, _DWORD *, __int128 *))off_1E0E540F8[v12])(&v22, v15, &v23);
        *v14 = v12;
        if (v29 != -1)
          ((void (*)(char *, __int128 *))off_1E0E540E0[v29])(&v22, &v23);
        goto LABEL_21;
      }
    }
    memmove(v7, v9, v8);
    goto LABEL_18;
  }
  return llvm::SmallVectorTemplateBase<mlir::FallbackAsmResourceMap::OpaqueAsmResource,false>::growAndEmplaceBack<llvm::StringRef,mlir::AsmResourceBlob>(a1, (uint64_t)a2, (__int128 *)a3);
}

uint64_t llvm::SmallVectorImpl<mlir::FallbackAsmResourceMap::OpaqueAsmResource>::emplace_back<llvm::StringRef,BOOL &>(uint64_t a1, const void **a2, _BYTE *a3)
{
  unsigned int v4;
  uint64_t v5;
  _QWORD *v6;
  size_t v7;
  const void *v8;
  uint64_t v9;
  int *v10;
  int *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  unsigned int v17;
  char v19;
  _BYTE v20[64];
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 8);
  if (v4 < *(_DWORD *)(a1 + 12))
  {
    v5 = *(_QWORD *)a1;
    v6 = (_QWORD *)(*(_QWORD *)a1 + 96 * v4);
    v8 = *a2;
    v7 = (size_t)a2[1];
    v20[0] = *a3;
    v21 = 1;
    if (!v8)
    {
      v9 = v5 + 96 * v4;
      *(_DWORD *)(v9 + 88) = -1;
      v10 = (int *)(v9 + 88);
      v11 = v10 - 16;
      *v6 = 0;
      v6[1] = 0;
      *((_BYTE *)v6 + 24) = 0;
      v6[2] = 0;
      v12 = 1;
      goto LABEL_13;
    }
    if (v7 >= 0x7FFFFFFFFFFFFFF8)
      abort();
    if (v7 >= 0x17)
    {
      v13 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17)
        v13 = v7 | 7;
      v14 = v13 + 1;
      v15 = operator new(v13 + 1);
      v6[1] = v7;
      v6[2] = v14 | 0x8000000000000000;
      *v6 = v15;
      v6 = v15;
    }
    else
    {
      *((_BYTE *)v6 + 23) = v7;
      if (!v7)
      {
LABEL_12:
        *((_BYTE *)v6 + v7) = 0;
        v12 = v21;
        v16 = v5 + 96 * v4;
        *(_BYTE *)(v16 + 24) = 0;
        v11 = (int *)(v16 + 24);
        v11[16] = -1;
        v10 = v11 + 16;
        if (v12 == -1)
        {
LABEL_15:
          v17 = *(_DWORD *)(a1 + 8) + 1;
          *(_DWORD *)(a1 + 8) = v17;
          return *(_QWORD *)a1 + 96 * v17 - 96;
        }
LABEL_13:
        ((void (*)(char *, int *, _BYTE *))off_1E0E540F8[v12])(&v19, v11, v20);
        *v10 = v12;
        if (v21 != -1)
          ((void (*)(char *, _BYTE *))off_1E0E540E0[v21])(&v19, v20);
        goto LABEL_15;
      }
    }
    memmove(v6, v8, v7);
    goto LABEL_12;
  }
  return llvm::SmallVectorTemplateBase<mlir::FallbackAsmResourceMap::OpaqueAsmResource,false>::growAndEmplaceBack<llvm::StringRef,BOOL &>(a1, (uint64_t)a2, a3);
}

uint64_t llvm::SmallVectorImpl<mlir::FallbackAsmResourceMap::OpaqueAsmResource>::emplace_back<llvm::StringRef,std::string>(uint64_t a1, const void **a2, uint64_t a3)
{
  unsigned int v4;
  uint64_t v5;
  _QWORD *v6;
  size_t v7;
  const void *v8;
  uint64_t v9;
  int *v10;
  int *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  unsigned int v17;
  char v19;
  __int128 v20;
  uint64_t v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 8);
  if (v4 < *(_DWORD *)(a1 + 12))
  {
    v5 = *(_QWORD *)a1;
    v6 = (_QWORD *)(*(_QWORD *)a1 + 96 * v4);
    v8 = *a2;
    v7 = (size_t)a2[1];
    v20 = *(_OWORD *)a3;
    v21 = *(_QWORD *)(a3 + 16);
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    v22 = 2;
    if (!v8)
    {
      v9 = v5 + 96 * v4;
      *(_DWORD *)(v9 + 88) = -1;
      v10 = (int *)(v9 + 88);
      v11 = v10 - 16;
      *v6 = 0;
      v6[1] = 0;
      *((_BYTE *)v6 + 24) = 0;
      v6[2] = 0;
      v12 = 2;
      goto LABEL_13;
    }
    if (v7 >= 0x7FFFFFFFFFFFFFF8)
      abort();
    if (v7 >= 0x17)
    {
      v13 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17)
        v13 = v7 | 7;
      v14 = v13 + 1;
      v15 = operator new(v13 + 1);
      v6[1] = v7;
      v6[2] = v14 | 0x8000000000000000;
      *v6 = v15;
      v6 = v15;
    }
    else
    {
      *((_BYTE *)v6 + 23) = v7;
      if (!v7)
      {
LABEL_12:
        *((_BYTE *)v6 + v7) = 0;
        v12 = v22;
        v16 = v5 + 96 * v4;
        *(_BYTE *)(v16 + 24) = 0;
        v11 = (int *)(v16 + 24);
        v11[16] = -1;
        v10 = v11 + 16;
        if (v12 == -1)
        {
LABEL_15:
          v17 = *(_DWORD *)(a1 + 8) + 1;
          *(_DWORD *)(a1 + 8) = v17;
          return *(_QWORD *)a1 + 96 * v17 - 96;
        }
LABEL_13:
        ((void (*)(char *, int *, __int128 *))off_1E0E540F8[v12])(&v19, v11, &v20);
        *v10 = v12;
        if (v22 != -1)
          ((void (*)(char *, __int128 *))off_1E0E540E0[v22])(&v19, &v20);
        goto LABEL_15;
      }
    }
    memmove(v6, v8, v7);
    goto LABEL_12;
  }
  return llvm::SmallVectorTemplateBase<mlir::FallbackAsmResourceMap::OpaqueAsmResource,false>::growAndEmplaceBack<llvm::StringRef,std::string>(a1, (uint64_t)a2, (__int128 *)a3);
}

uint64_t mlir::FallbackAsmResourceMap::ResourceCollection::buildResources(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;

  v3 = *(unsigned int *)(result + 40);
  if ((_DWORD)v3)
  {
    v5 = 0;
    v6 = *(_QWORD *)(result + 32);
    v7 = 96 * v3;
    do
    {
      v15 = (uint64_t *)(v6 + v5);
      v16 = (uint64_t *)(v6 + v5 + 24);
      v17 = *(_DWORD *)(v6 + v5 + 88);
      if (v17 == 1)
      {
        v21 = *((char *)v15 + 23);
        if (v21 >= 0)
          v22 = v6 + v5;
        else
          v22 = *v15;
        if (v21 >= 0)
          v23 = *((unsigned __int8 *)v15 + 23);
        else
          v23 = v15[1];
        result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v22, v23, *(unsigned __int8 *)v16);
      }
      else if (v17)
      {
        v8 = v6 + v5;
        v9 = *(char *)(v6 + v5 + 23);
        if (v9 >= 0)
          v10 = v6 + v5;
        else
          v10 = *(_QWORD *)(v6 + v5);
        if (v9 >= 0)
          v11 = *(unsigned __int8 *)(v6 + v5 + 23);
        else
          v11 = *(_QWORD *)(v6 + v5 + 8);
        v12 = *(char *)(v8 + 47);
        if (v12 >= 0)
          v13 = v6 + v5 + 24;
        else
          v13 = *v16;
        if (v12 >= 0)
          v14 = *(unsigned __int8 *)(v8 + 47);
        else
          v14 = *(_QWORD *)(v8 + 32);
        result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a3 + 24))(a3, v10, v11, v13, v14);
      }
      else
      {
        v18 = *(char *)(v6 + v5 + 23);
        if (v18 >= 0)
          v19 = v6 + v5;
        else
          v19 = *(_QWORD *)(v6 + v5);
        if (v18 >= 0)
          v20 = *(unsigned __int8 *)(v6 + v5 + 23);
        else
          v20 = *(_QWORD *)(v6 + v5 + 8);
        result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a3 + 32))(a3, v19, v20, *v16, *(_QWORD *)(v6 + v5 + 32), *(unsigned int *)(v6 + v5 + 40));
      }
      v5 += 96;
    }
    while (v7 != v5);
  }
  return result;
}

llvm *mlir::AsmState::AsmState(llvm *a1, uint64_t a2, uint64_t a3, uint64_t a4, mlir::FallbackAsmResourceMap *a5)
{
  char v9;
  __int128 v10;
  std::recursive_mutex **DiagEngine;
  mlir::Diagnostic *v12;
  char v13;
  mlir::SourceMgrDiagnosticHandler **v14;
  void *v15;
  mlir::MLIRContext *Context;
  uint64_t threadid;
  __int128 v19;
  unint64_t v20[2];
  char v21;
  _BYTE v22[7];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v9 = *(_BYTE *)(a3 + 32);
  if ((v9 & 0x14) == 0)
  {
    threadid = llvm::get_threadid(a1);
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    DiagEngine = (std::recursive_mutex **)mlir::MLIRContext::getDiagEngine(Context);
    *(_QWORD *)&v19 = &threadid;
    v20[1] = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Diagnostic &>::CallbacksHolder<verifyOpAndAdjustFlags(mlir::Operation *,mlir::OpPrintingFlags)::$_0,verifyOpAndAdjustFlags(mlir::Operation *,mlir::OpPrintingFlags)::$_0,void>::Callbacks
           + 2;
    mlir::DiagnosticEngine::registerHandler(DiagEngine, &v19);
    v13 = v20[1];
    if (v20[1] >= 8)
    {
      if ((v20[1] & 4) != 0)
      {
        if ((v20[1] & 2) != 0)
          v14 = (mlir::SourceMgrDiagnosticHandler **)&v19;
        else
          v14 = (mlir::SourceMgrDiagnosticHandler **)v19;
        (*(void (**)(mlir::SourceMgrDiagnosticHandler **, mlir::Diagnostic *))((v20[1] & 0xFFFFFFFFFFFFFFF8)
                                                                                        + 16))(v14, v12);
      }
      if ((v13 & 2) == 0)
        llvm::deallocate_buffer((llvm *)v19, *((void **)&v19 + 1));
    }
    mlir::verify((mlir *)a2, (mlir::Operation *)1);
  }
  v10 = *(_OWORD *)(a3 + 16);
  v19 = *(_OWORD *)a3;
  *(_OWORD *)v20 = v10;
  v21 = v9;
  *(_DWORD *)v22 = *(_DWORD *)(a3 + 33);
  *(_DWORD *)&v22[3] = *(_DWORD *)(a3 + 36);
  v15 = operator new(0x2C0uLL);
  *(_QWORD *)a1 = mlir::detail::AsmStateImpl::AsmStateImpl((uint64_t)v15, (unsigned int *)a2, &v19, a4);
  if (a5)
    mlir::AsmState::attachFallbackResourcePrinter(a1, a5);
  return a1;
}

void mlir::AsmState::attachFallbackResourcePrinter(mlir::AsmState *this, mlir::FallbackAsmResourceMap *a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *__p;
  uint64_t *v13;

  mlir::FallbackAsmResourceMap::getPrinters(a2, &__p);
  v3 = (uint64_t *)__p;
  v4 = v13;
  if (__p == v13)
  {
    if (!__p)
      return;
    goto LABEL_8;
  }
  do
  {
    v5 = *v3;
    *v3 = 0;
    v11 = v5;
    mlir::AsmState::attachResourcePrinter((uint64_t *)this, &v11);
    v6 = v11;
    v11 = 0;
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    ++v3;
  }
  while (v3 != v4);
  v3 = (uint64_t *)__p;
  if (__p)
  {
LABEL_8:
    v7 = v13;
    v8 = v3;
    if (v13 != v3)
    {
      do
      {
        v10 = *--v7;
        v9 = v10;
        *v7 = 0;
        if (v10)
          (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
      }
      while (v7 != v3);
      v8 = __p;
    }
    v13 = v3;
    operator delete(v8);
  }
}

mlir::AsmState *mlir::AsmState::AsmState(mlir::AsmState *a1, mlir::MLIRContext *a2, uint64_t a3, uint64_t a4, mlir::FallbackAsmResourceMap *a5)
{
  char *v10;
  uint64_t v11;
  __int128 v12;

  v10 = (char *)operator new(0x2C0uLL);
  v11 = mlir::DialectInterfaceCollection<mlir::OpAsmDialectInterface>::DialectInterfaceCollection(v10, a2);
  *(_QWORD *)(v11 + 56) = v11 + 72;
  *(_QWORD *)(v11 + 64) = 0x600000000;
  *(_OWORD *)(v11 + 120) = 0u;
  *(_DWORD *)(v11 + 136) = 0;
  *(_OWORD *)(v11 + 144) = 0u;
  *(_DWORD *)(v11 + 160) = 0;
  *(_OWORD *)(v11 + 184) = 0u;
  *(_QWORD *)(v11 + 168) = v11 + 184;
  *(_QWORD *)(v11 + 176) = 0;
  *(_QWORD *)(v11 + 200) = v11 + 216;
  *(_QWORD *)(v11 + 208) = 0x400000000;
  *(_QWORD *)(v11 + 248) = v11 + 264;
  *(_OWORD *)(v11 + 256) = 0u;
  *(_QWORD *)(v11 + 272) = 1;
  *(_OWORD *)(v11 + 280) = 0u;
  *(_DWORD *)(v11 + 296) = 0;
  *(_DWORD *)(v11 + 320) = 0;
  *(_OWORD *)(v11 + 304) = 0u;
  *(_DWORD *)(v11 + 344) = 0;
  *(_OWORD *)(v11 + 328) = 0u;
  *(_DWORD *)(v11 + 368) = 0;
  *(_OWORD *)(v11 + 352) = 0u;
  *(_DWORD *)(v11 + 392) = 0;
  *(_OWORD *)(v11 + 376) = 0u;
  *(_DWORD *)(v11 + 416) = 0;
  *(_OWORD *)(v11 + 400) = 0u;
  *(_OWORD *)(v11 + 424) = 0u;
  *(_QWORD *)(v11 + 440) = 0;
  *(_QWORD *)(v11 + 448) = v11 + 464;
  *(_QWORD *)(v11 + 456) = 0x400000000;
  *(_QWORD *)(v11 + 496) = v11 + 512;
  *(_OWORD *)(v11 + 504) = 0u;
  *(_QWORD *)(v11 + 520) = 1;
  *(_QWORD *)(v11 + 528) = 0;
  *((_DWORD *)v10 + 134) = 0;
  mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)(v11 + 544));
  *((_DWORD *)v10 + 152) = 0;
  *((_QWORD *)v10 + 75) = 0;
  *(_OWORD *)(v10 + 584) = 0u;
  v12 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(v10 + 616) = *(_OWORD *)a3;
  *(_OWORD *)(v10 + 632) = v12;
  *((_QWORD *)v10 + 81) = *(_QWORD *)(a3 + 32);
  *((_QWORD *)v10 + 82) = a4;
  *(_OWORD *)(v10 + 664) = 0u;
  *((_DWORD *)v10 + 170) = 0;
  *((_QWORD *)v10 + 86) = v10 + 704;
  *((_QWORD *)v10 + 87) = 0;
  *(_QWORD *)a1 = v10;
  if (a5)
    mlir::AsmState::attachFallbackResourcePrinter(a1, a5);
  return a1;
}

void mlir::AsmState::~AsmState(mlir::detail::AsmStateImpl **this)
{
  mlir::detail::AsmStateImpl *v2;

  v2 = *this;
  *this = 0;
  if (v2)
    mlir::detail::AsmStateImpl::~AsmStateImpl(v2);
}

void mlir::AsmState::attachResourcePrinter(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  char **v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  char *v15;
  char *v16;
  BOOL v17;
  unint64_t v18;
  uint64_t v19;
  __int128 *v20;
  _OWORD *v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  unint64_t v29;

  v3 = *a1;
  v4 = *(unsigned int *)(*a1 + 64);
  if (v4 < *(_DWORD *)(*a1 + 68))
  {
    v5 = *(_QWORD *)(v3 + 56);
    v6 = *a2;
    *a2 = 0;
    *(_QWORD *)(v5 + 8 * v4) = v6;
    v7 = v4 + 1;
    goto LABEL_3;
  }
  v8 = (char **)(v3 + 56);
  v29 = 0;
  v9 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(v3 + 56, (void *)(v3 + 72), 0, 8, &v29);
  v10 = *(unsigned int *)(v3 + 64);
  v11 = 8 * v10;
  v12 = *a2;
  *a2 = 0;
  *(_QWORD *)&v9[8 * v10] = v12;
  v13 = *(char **)(v3 + 56);
  if ((_DWORD)v10)
  {
    v14 = (v10 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v14 >= 0xB)
    {
      v17 = v13 >= &v9[v11] || v9 >= &v13[v11];
      v15 = v9;
      v16 = *(char **)(v3 + 56);
      if (v17)
      {
        v18 = v14 + 1;
        v19 = 8 * (v18 & 0x3FFFFFFFFFFFFFFCLL);
        v15 = &v9[v19];
        v16 = &v13[v19];
        v20 = (__int128 *)(v13 + 16);
        v21 = v9 + 16;
        v22 = v18 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v23 = *(v20 - 1);
          v24 = *v20;
          *(v20 - 1) = 0uLL;
          *v20 = 0uLL;
          *(v21 - 1) = v23;
          *v21 = v24;
          v20 += 2;
          v21 += 2;
          v22 -= 4;
        }
        while (v22);
        if (v18 == (v18 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_16:
          v26 = (uint64_t)(*v8 - 8);
          do
          {
            v27 = *(_QWORD *)(v26 + v11);
            *(_QWORD *)(v26 + v11) = 0;
            if (v27)
              (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
            v11 -= 8;
          }
          while (v11);
          v13 = *v8;
          goto LABEL_21;
        }
      }
    }
    else
    {
      v15 = v9;
      v16 = *(char **)(v3 + 56);
    }
    do
    {
      v25 = *(_QWORD *)v16;
      *(_QWORD *)v16 = 0;
      v16 += 8;
      *(_QWORD *)v15 = v25;
      v15 += 8;
    }
    while (v16 != &v13[v11]);
    goto LABEL_16;
  }
LABEL_21:
  v28 = v29;
  if (v13 != (char *)(v3 + 72))
    free(v13);
  *(_QWORD *)(v3 + 56) = v9;
  v7 = *(_DWORD *)(v3 + 64) + 1;
  *(_DWORD *)(v3 + 68) = v28;
LABEL_3:
  *(_DWORD *)(v3 + 64) = v7;
}

uint64_t mlir::AsmState::getDialectResources(mlir::AsmState *this)
{
  return *(_QWORD *)this + 120;
}

llvm::raw_ostream *mlir::AsmPrinter::Impl::printLocation(uint64_t a1, uint64_t a2, int a3)
{
  llvm::raw_ostream *v6;
  _DWORD *v7;
  llvm::raw_ostream *result;
  _BYTE *v9;

  if ((*(_BYTE *)(a1 + 48) & 2) != 0)
    return mlir::AsmPrinter::Impl::printLocationInternal((llvm::raw_ostream *)a1, a2, 1, 1);
  v6 = *(llvm::raw_ostream **)a1;
  v7 = *(_DWORD **)(*(_QWORD *)a1 + 32);
  if (*(_QWORD *)(*(_QWORD *)a1 + 24) - (_QWORD)v7 > 3uLL)
  {
    *v7 = 677605228;
    *((_QWORD *)v6 + 4) += 4;
    if (!a3)
      goto LABEL_10;
  }
  else
  {
    llvm::raw_ostream::write(v6, "loc(", 4uLL);
    if (!a3)
    {
LABEL_10:
      mlir::AsmPrinter::Impl::printLocationInternal((llvm::raw_ostream *)a1, a2, 0, 1);
      result = *(llvm::raw_ostream **)a1;
      v9 = *(_BYTE **)(*(_QWORD *)a1 + 32);
      if ((unint64_t)v9 >= *(_QWORD *)(*(_QWORD *)a1 + 24))
        return llvm::raw_ostream::write(result, 41);
LABEL_9:
      *((_QWORD *)result + 4) = v9 + 1;
      *v9 = 41;
      return result;
    }
  }
  result = *(llvm::raw_ostream **)a1;
  v9 = *(_BYTE **)(*(_QWORD *)a1 + 32);
  if ((unint64_t)v9 < *(_QWORD *)(*(_QWORD *)a1 + 24))
    goto LABEL_9;
  return llvm::raw_ostream::write(result, 41);
}

llvm::raw_ostream *mlir::AsmPrinter::Impl::printLocationInternal(llvm::raw_ostream *result, uint64_t a2, uint64_t a3, char a4)
{
  llvm::raw_ostream *v6;
  void *v7;
  llvm::raw_ostream *v12;
  uint64_t v13;
  uint64_t RHS;
  llvm::raw_ostream *v15;
  uint64_t v16;
  unint64_t v17;
  const char *v18;
  size_t v19;
  llvm::raw_ostream *v20;
  size_t v21;
  const char *AttrData;
  size_t v23;
  void *v24;
  llvm::raw_ostream *v25;
  _BYTE *v26;
  llvm::raw_ostream *v27;
  uint64_t v28;
  uint64_t v29;
  llvm::raw_ostream *v30;
  _BYTE *v31;
  llvm::raw_ostream *v32;
  uint64_t v33;
  uint64_t v34;
  llvm::raw_ostream *v35;
  _BYTE *v36;
  uint64_t LHS;
  uint64_t v38;
  uint64_t v39;
  llvm::raw_ostream *v40;
  llvm::raw_ostream *v41;
  _BYTE *v42;
  llvm::raw_ostream *v43;
  llvm::raw_ostream *v44;
  _BYTE *v45;
  char *v46;
  char v47;
  llvm::raw_ostream *v48;
  uint64_t v49;
  llvm::raw_ostream *v50;
  _BYTE *v51;
  unsigned int Position;
  llvm::raw_ostream *v53;
  llvm::raw_ostream *v54;
  _BYTE *v55;
  unsigned int Column;
  llvm::raw_ostream *v57;
  _DWORD *v58;
  _BYTE *v59;
  _BYTE *v60;
  _DWORD *v61;
  uint64_t v62;
  uint64_t v63;
  llvm::raw_ostream *v64;
  _BYTE *v65;
  llvm::raw_ostream *v66;
  _BYTE *v67;
  llvm::raw_ostream *v68;
  _BYTE *v69;
  _QWORD *v70;
  uint64_t v71;
  _QWORD *v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t v75;
  uint64_t v76;
  llvm::raw_ostream *v77;
  _WORD *v78;
  uint64_t Value;
  uint64_t v80;

  v6 = result;
  if ((a4 & 1) == 0)
  {
    if ((_BYTE)result)
      return result;
  }
  v7 = *(void **)(*(_QWORD *)a2 + 136);
  if (v7 == &mlir::detail::TypeIDResolver<mlir::OpaqueLoc,void>::id && a2 != 0)
  {
    v80 = a2;
    RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v80);
    v15 = v6;
    return (llvm::raw_ostream *)mlir::AsmPrinter::Impl::printLocationInternal(v15, RHS, a3, 0);
  }
  if (v7 == &mlir::detail::TypeIDResolver<mlir::UnknownLoc,void>::id)
  {
    result = *(llvm::raw_ostream **)v6;
    v16 = *(_QWORD *)(*(_QWORD *)v6 + 32);
    v17 = *(_QWORD *)(*(_QWORD *)v6 + 24) - v16;
    if ((_DWORD)a3)
    {
      if (v17 > 8)
      {
        *(_BYTE *)(v16 + 8) = 93;
        *(_QWORD *)v16 = *(_QWORD *)"[unknown]";
        *((_QWORD *)result + 4) += 9;
        return result;
      }
      v18 = "[unknown]";
      v19 = 9;
    }
    else
    {
      if (v17 > 6)
      {
        *(_DWORD *)(v16 + 3) = 1853321070;
        *(_DWORD *)v16 = 1852534389;
        *((_QWORD *)result + 4) += 7;
        return result;
      }
      v18 = "unknown";
      v19 = 7;
    }
    return llvm::raw_ostream::write(result, v18, v19);
  }
  if (v7 == &mlir::detail::TypeIDResolver<mlir::FileLineColLoc,void>::id)
  {
    v80 = a2;
    if ((_DWORD)a3)
    {
      v20 = *(llvm::raw_ostream **)v6;
      Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v80);
      AttrData = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&Value);
      v23 = v21;
      v24 = (void *)*((_QWORD *)v20 + 4);
      if (v21 > *((_QWORD *)v20 + 3) - (_QWORD)v24)
      {
        llvm::raw_ostream::write(v20, AttrData, v21);
        v25 = *(llvm::raw_ostream **)v6;
        v26 = (_BYTE *)*((_QWORD *)v25 + 4);
        if ((unint64_t)v26 >= *((_QWORD *)v25 + 3))
          goto LABEL_70;
LABEL_68:
        *((_QWORD *)v25 + 4) = v26 + 1;
        *v26 = 58;
LABEL_71:
        Position = mlir::AffineDimExpr::getPosition((mlir::AffineDimExpr *)&v80);
        v53 = llvm::raw_ostream::operator<<(v25, Position);
        v54 = v53;
        v55 = (_BYTE *)*((_QWORD *)v53 + 4);
        if ((unint64_t)v55 >= *((_QWORD *)v53 + 3))
        {
          v54 = llvm::raw_ostream::write(v53, 58);
        }
        else
        {
          *((_QWORD *)v53 + 4) = v55 + 1;
          *v55 = 58;
        }
        Column = mlir::FileLineColLoc::getColumn((mlir::FileLineColLoc *)&v80);
        return llvm::raw_ostream::operator<<(v54, Column);
      }
      if (v21)
      {
        memcpy(v24, AttrData, v21);
        *((_QWORD *)v20 + 4) += v23;
        v25 = *(llvm::raw_ostream **)v6;
        v26 = (_BYTE *)*((_QWORD *)v25 + 4);
        if ((unint64_t)v26 >= *((_QWORD *)v25 + 3))
          goto LABEL_70;
        goto LABEL_68;
      }
    }
    else
    {
      Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v80);
      v32 = (llvm::raw_ostream *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&Value);
      v34 = v33;
      v35 = *(llvm::raw_ostream **)v6;
      v36 = *(_BYTE **)(*(_QWORD *)v6 + 32);
      if (*(_BYTE **)(*(_QWORD *)v6 + 24) == v36)
      {
        llvm::raw_ostream::write(v35, "\"", 1uLL);
      }
      else
      {
        *v36 = 34;
        ++*((_QWORD *)v35 + 4);
      }
      llvm::printEscapedString(v32, v34, *(llvm::raw_ostream **)v6);
      v50 = *(llvm::raw_ostream **)v6;
      v51 = *(_BYTE **)(*(_QWORD *)v6 + 32);
      if (*(_BYTE **)(*(_QWORD *)v6 + 24) == v51)
      {
        llvm::raw_ostream::write(v50, "\"", 1uLL);
        v25 = *(llvm::raw_ostream **)v6;
        v26 = (_BYTE *)*((_QWORD *)v25 + 4);
        if ((unint64_t)v26 < *((_QWORD *)v25 + 3))
          goto LABEL_68;
        goto LABEL_70;
      }
      *v51 = 34;
      ++*((_QWORD *)v50 + 4);
    }
    v25 = *(llvm::raw_ostream **)v6;
    v26 = (_BYTE *)*((_QWORD *)v25 + 4);
    if ((unint64_t)v26 < *((_QWORD *)v25 + 3))
      goto LABEL_68;
LABEL_70:
    v25 = llvm::raw_ostream::write(v25, 58);
    goto LABEL_71;
  }
  if (v7 == &mlir::detail::TypeIDResolver<mlir::NameLoc,void>::id && a2 != 0)
  {
    v80 = a2;
    Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v80);
    v27 = (llvm::raw_ostream *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&Value);
    v29 = v28;
    v30 = *(llvm::raw_ostream **)v6;
    v31 = *(_BYTE **)(*(_QWORD *)v6 + 32);
    if (*(_BYTE **)(*(_QWORD *)v6 + 24) == v31)
    {
      llvm::raw_ostream::write(v30, "\"", 1uLL);
    }
    else
    {
      *v31 = 34;
      ++*((_QWORD *)v30 + 4);
    }
    llvm::printEscapedString(v27, v29, *(llvm::raw_ostream **)v6);
    v41 = *(llvm::raw_ostream **)v6;
    v42 = *(_BYTE **)(*(_QWORD *)v6 + 32);
    if (*(_BYTE **)(*(_QWORD *)v6 + 24) == v42)
    {
      llvm::raw_ostream::write(v41, "\"", 1uLL);
      result = (llvm::raw_ostream *)mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v80);
      if (*(_UNKNOWN **)(*(_QWORD *)result + 136) == &mlir::detail::TypeIDResolver<mlir::UnknownLoc,void>::id)
        return result;
    }
    else
    {
      *v42 = 34;
      ++*((_QWORD *)v41 + 4);
      result = (llvm::raw_ostream *)mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v80);
      if (*(_UNKNOWN **)(*(_QWORD *)result + 136) == &mlir::detail::TypeIDResolver<mlir::UnknownLoc,void>::id)
        return result;
    }
    v43 = result;
    v44 = *(llvm::raw_ostream **)v6;
    v45 = *(_BYTE **)(*(_QWORD *)v6 + 32);
    if ((unint64_t)v45 >= *(_QWORD *)(*(_QWORD *)v6 + 24))
    {
      llvm::raw_ostream::write(v44, 40);
    }
    else
    {
      *((_QWORD *)v44 + 4) = v45 + 1;
      *v45 = 40;
    }
    mlir::AsmPrinter::Impl::printLocationInternal(v6, v43, a3, 0);
    result = *(llvm::raw_ostream **)v6;
    v46 = *(char **)(*(_QWORD *)v6 + 32);
    if ((unint64_t)v46 >= *(_QWORD *)(*(_QWORD *)v6 + 24))
      return llvm::raw_ostream::write(result, 41);
    *((_QWORD *)result + 4) = v46 + 1;
    v47 = 41;
LABEL_107:
    *v46 = v47;
    return result;
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::CallSiteLoc,void>::id || a2 == 0)
  {
    if (v7 == &mlir::detail::TypeIDResolver<mlir::FusedLoc,void>::id && a2 != 0)
    {
      v80 = a2;
      if ((a3 & 1) == 0)
      {
        v12 = *(llvm::raw_ostream **)v6;
        v13 = *(_QWORD *)(*(_QWORD *)v6 + 32);
        if ((unint64_t)(*(_QWORD *)(*(_QWORD *)v6 + 24) - v13) > 4)
        {
          *(_BYTE *)(v13 + 4) = 100;
          *(_DWORD *)v13 = 1702065510;
          *((_QWORD *)v12 + 4) += 5;
        }
        else
        {
          llvm::raw_ostream::write(v12, "fused", 5uLL);
        }
      }
      v62 = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v80);
      if (v62)
      {
        v63 = v62;
        v64 = *(llvm::raw_ostream **)v6;
        v65 = *(_BYTE **)(*(_QWORD *)v6 + 32);
        if ((unint64_t)v65 >= *(_QWORD *)(*(_QWORD *)v6 + 24))
        {
          llvm::raw_ostream::write(v64, 60);
        }
        else
        {
          *((_QWORD *)v64 + 4) = v65 + 1;
          *v65 = 60;
        }
        v66 = *(llvm::raw_ostream **)v6;
        v67 = *(_BYTE **)(*(_QWORD *)v6 + 32);
        if ((unint64_t)v67 >= *(_QWORD *)(*(_QWORD *)v6 + 24))
        {
          llvm::raw_ostream::write(v66, 62);
        }
        else
        {
          *((_QWORD *)v66 + 4) = v67 + 1;
          *v67 = 62;
        }
      }
      v68 = *(llvm::raw_ostream **)v6;
      v69 = *(_BYTE **)(*(_QWORD *)v6 + 32);
      if ((unint64_t)v69 >= *(_QWORD *)(*(_QWORD *)v6 + 24))
      {
        llvm::raw_ostream::write(v68, 91);
      }
      else
      {
        *((_QWORD *)v68 + 4) = v69 + 1;
        *v69 = 91;
      }
      v70 = (_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v80);
      if (v71)
      {
        v72 = v70;
        v73 = v71;
        mlir::AsmPrinter::Impl::printLocationInternal(v6, *v70, a3, 0);
        if (v73 != 1)
        {
          v74 = v72 + 1;
          v75 = 8 * v73 - 8;
          do
          {
            v77 = *(llvm::raw_ostream **)v6;
            v78 = *(_WORD **)(*(_QWORD *)v6 + 32);
            if (*(_QWORD *)(*(_QWORD *)v6 + 24) - (_QWORD)v78 > 1uLL)
            {
              *v78 = 8236;
              *((_QWORD *)v77 + 4) += 2;
            }
            else
            {
              llvm::raw_ostream::write(v77, ", ", 2uLL);
            }
            v76 = *v74++;
            mlir::AsmPrinter::Impl::printLocationInternal(v6, v76, a3, 0);
            v75 -= 8;
          }
          while (v75);
        }
      }
      result = *(llvm::raw_ostream **)v6;
      v46 = *(char **)(*(_QWORD *)v6 + 32);
      if ((unint64_t)v46 >= *(_QWORD *)(*(_QWORD *)v6 + 24))
        return llvm::raw_ostream::write(result, 93);
      *((_QWORD *)result + 4) = v46 + 1;
      v47 = 93;
      goto LABEL_107;
    }
  }
  else
  {
    v80 = a2;
    LHS = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v80);
    v38 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v80);
    v39 = v38;
    if ((a3 & 1) != 0)
    {
      mlir::AsmPrinter::Impl::printLocationInternal(v6, v38, a3, 0);
      if (*(_UNKNOWN **)(*(_QWORD *)v39 + 136) == &mlir::detail::TypeIDResolver<mlir::NameLoc,void>::id)
      {
        v40 = *(llvm::raw_ostream **)v6;
        if (*(_UNKNOWN **)(*(_QWORD *)LHS + 136) == &mlir::detail::TypeIDResolver<mlir::FileLineColLoc,void>::id)
          goto LABEL_85;
      }
      else
      {
        v40 = *(llvm::raw_ostream **)v6;
      }
      ++*((_DWORD *)v6 + 14);
      v60 = (_BYTE *)*((_QWORD *)v40 + 4);
      if ((unint64_t)v60 >= *((_QWORD *)v40 + 3))
      {
        v40 = llvm::raw_ostream::write(v40, 10);
      }
      else
      {
        *((_QWORD *)v40 + 4) = v60 + 1;
        *v60 = 10;
      }
LABEL_85:
      v61 = (_DWORD *)*((_QWORD *)v40 + 4);
      if (*((_QWORD *)v40 + 3) - (_QWORD)v61 > 3uLL)
      {
        *v61 = 544497952;
        *((_QWORD *)v40 + 4) += 4;
      }
      else
      {
        llvm::raw_ostream::write(v40, " at ", 4uLL);
      }
      v15 = v6;
      RHS = LHS;
      return (llvm::raw_ostream *)mlir::AsmPrinter::Impl::printLocationInternal(v15, RHS, a3, 0);
    }
    v48 = *(llvm::raw_ostream **)v6;
    v49 = *(_QWORD *)(*(_QWORD *)v6 + 32);
    if ((unint64_t)(*(_QWORD *)(*(_QWORD *)v6 + 24) - v49) > 8)
    {
      *(_BYTE *)(v49 + 8) = 40;
      *(_QWORD *)v49 = *(_QWORD *)"callsite(";
      *((_QWORD *)v48 + 4) += 9;
    }
    else
    {
      llvm::raw_ostream::write(v48, "callsite(", 9uLL);
    }
    mlir::AsmPrinter::Impl::printLocationInternal(v6, v39, a3, 0);
    v57 = *(llvm::raw_ostream **)v6;
    v58 = *(_DWORD **)(*(_QWORD *)v6 + 32);
    if (*(_QWORD *)(*(_QWORD *)v6 + 24) - (_QWORD)v58 > 3uLL)
    {
      *v58 = 544497952;
      *((_QWORD *)v57 + 4) += 4;
    }
    else
    {
      llvm::raw_ostream::write(v57, " at ", 4uLL);
    }
    mlir::AsmPrinter::Impl::printLocationInternal(v6, LHS, a3, 0);
    result = *(llvm::raw_ostream **)v6;
    v59 = *(_BYTE **)(*(_QWORD *)v6 + 32);
    if (*(_BYTE **)(*(_QWORD *)v6 + 24) == v59)
    {
      return llvm::raw_ostream::write(result, ")", 1uLL);
    }
    else
    {
      *v59 = 41;
      ++*((_QWORD *)result + 4);
    }
  }
  return result;
}

uint64_t `anonymous namespace'::AliasState::getAlias(uint64_t *a1, uint64_t a2, llvm::raw_ostream *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  int v9;
  int v10;
  BOOL v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  char *v18;
  void *v19;
  llvm::raw_ostream *v20;
  _DWORD *v21;
  const void *v22;
  size_t v23;

  v4 = *a1;
  v5 = *((unsigned int *)a1 + 4);
  if ((_DWORD)v5)
  {
    LODWORD(v6) = (v5 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    v7 = (_QWORD *)(v4 + 16 * v6);
    v8 = *v7;
    if (*v7 == a2)
      goto LABEL_8;
    v9 = 1;
    while (v8 != -4096)
    {
      v10 = v6 + v9++;
      v6 = v10 & (v5 - 1);
      v8 = *(_QWORD *)(v4 + 16 * v6);
      if (v8 == a2)
      {
        v7 = (_QWORD *)(v4 + 16 * v6);
        goto LABEL_8;
      }
    }
  }
  v7 = (_QWORD *)(v4 + 16 * v5);
LABEL_8:
  v11 = v7 == (_QWORD *)(v4 + 16 * v5);
  v12 = (unsigned int *)(a1 + 4);
  if (!v11)
    v12 = (unsigned int *)(v7 + 1);
  v13 = *v12;
  if ((_DWORD)v13 == *((_DWORD *)a1 + 8))
    return 0;
  v15 = a1[3] + 32 * v13;
  v16 = v15 + 8;
  if ((*(_BYTE *)(v15 + 27) & 0x40) != 0)
    v17 = "!";
  else
    v17 = "#";
  v18 = (char *)*((_QWORD *)a3 + 4);
  if (*((char **)a3 + 3) == v18)
  {
    v20 = llvm::raw_ostream::write(a3, v17, 1uLL);
    v19 = (void *)*((_QWORD *)v20 + 4);
    v21 = (_DWORD *)(v15 + 24);
    v22 = *(const void **)v16;
    v23 = *(_QWORD *)(v16 + 8);
    if (v23 > *((_QWORD *)v20 + 3) - (_QWORD)v19)
      goto LABEL_17;
LABEL_19:
    if (v23)
    {
      memcpy(v19, v22, v23);
      *((_QWORD *)v20 + 4) += v23;
    }
    goto LABEL_21;
  }
  *v18 = *v17;
  v19 = (void *)(*((_QWORD *)a3 + 4) + 1);
  *((_QWORD *)a3 + 4) = v19;
  v20 = a3;
  v21 = (_DWORD *)(v15 + 24);
  v22 = *(const void **)v16;
  v23 = *(_QWORD *)(v16 + 8);
  if (v23 <= *((_QWORD *)a3 + 3) - (_QWORD)v19)
    goto LABEL_19;
LABEL_17:
  llvm::raw_ostream::write(v20, (const char *)v22, v23);
LABEL_21:
  if ((*v21 & 0x3FFFFFFF) != 0)
    llvm::raw_ostream::operator<<(a3, *v21 & 0x3FFFFFFF);
  return 1;
}

uint64_t mlir::AsmPrinter::Impl::printResourceHandle(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  llvm::raw_ostream *v5;
  void **v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  int v13;
  int v14;
  unsigned int v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  int v19;
  BOOL v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  void *__p[2];
  unsigned __int8 v27;

  v4 = mlir::Dialect::getRegisteredInterface<mlir::OpAsmDialectInterface>(a2[2]);
  v5 = *(llvm::raw_ostream **)a1;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t *))(*(_QWORD *)v4 + 40))(__p, v4, a2);
  if ((v27 & 0x80u) == 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  if ((v27 & 0x80u) == 0)
    v7 = v27;
  else
    v7 = (size_t)__p[1];
  llvm::raw_ostream::write(v5, (const char *)v6, v7);
  if (((char)v27 & 0x80000000) == 0)
  {
    v8 = *(_QWORD *)(a1 + 8);
    v11 = *(_QWORD *)(v8 + 120);
    v9 = v8 + 120;
    v10 = v11;
    v12 = (void *)a2[2];
    __p[0] = v12;
    v13 = *(_DWORD *)(v9 + 16);
    if (v13)
      goto LABEL_9;
LABEL_20:
    v24 = 0;
LABEL_21:
    v16 = llvm::DenseMapBase<llvm::DenseMap<mlir::Dialect *,llvm::SetVector<mlir::AsmDialectResourceHandle,llvm::SmallVector<mlir::AsmDialectResourceHandle,0u>,llvm::DenseSet<mlir::AsmDialectResourceHandle,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>>,0u>,llvm::DenseMapInfo<mlir::Dialect *,void>,llvm::detail::DenseMapPair<mlir::Dialect *,llvm::SetVector<mlir::AsmDialectResourceHandle,llvm::SmallVector<mlir::AsmDialectResourceHandle,0u>,llvm::DenseSet<mlir::AsmDialectResourceHandle,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>>,0u>>>,mlir::Dialect *,llvm::SetVector<mlir::AsmDialectResourceHandle,llvm::SmallVector<mlir::AsmDialectResourceHandle,0u>,llvm::DenseSet<mlir::AsmDialectResourceHandle,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>>,0u>,llvm::DenseMapInfo<mlir::Dialect *,void>,llvm::detail::DenseMapPair<mlir::Dialect *,llvm::SetVector<mlir::AsmDialectResourceHandle,llvm::SmallVector<mlir::AsmDialectResourceHandle,0u>,llvm::DenseSet<mlir::AsmDialectResourceHandle,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>>,0u>>>::InsertIntoBucket<mlir::Dialect *>(v9, v24, (uint64_t *)__p);
    return llvm::SetVector<mlir::AsmDialectResourceHandle,llvm::SmallVector<mlir::AsmDialectResourceHandle,0u>,llvm::DenseSet<mlir::AsmDialectResourceHandle,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>>,0u>::insert((uint64_t)(v16 + 1), a2);
  }
  operator delete(__p[0]);
  v22 = *(_QWORD *)(a1 + 8);
  v23 = *(_QWORD *)(v22 + 120);
  v9 = v22 + 120;
  v10 = v23;
  v12 = (void *)a2[2];
  __p[0] = v12;
  v13 = *(_DWORD *)(v9 + 16);
  if (!v13)
    goto LABEL_20;
LABEL_9:
  v14 = v13 - 1;
  v15 = ((v12 >> 4) ^ (v12 >> 9)) & (v13 - 1);
  v16 = (uint64_t *)(v10 + 48 * v15);
  v17 = *v16;
  if (v12 != (void *)*v16)
  {
    v18 = 0;
    v19 = 1;
    while (v17 != -4096)
    {
      if (v18)
        v20 = 0;
      else
        v20 = v17 == -8192;
      if (v20)
        v18 = v16;
      v21 = v15 + v19++;
      v15 = v21 & v14;
      v16 = (uint64_t *)(v10 + 48 * (v21 & v14));
      v17 = *v16;
      if (v12 == (void *)*v16)
        return llvm::SetVector<mlir::AsmDialectResourceHandle,llvm::SmallVector<mlir::AsmDialectResourceHandle,0u>,llvm::DenseSet<mlir::AsmDialectResourceHandle,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>>,0u>::insert((uint64_t)(v16 + 1), a2);
    }
    if (v18)
      v24 = v18;
    else
      v24 = v16;
    goto LABEL_21;
  }
  return llvm::SetVector<mlir::AsmDialectResourceHandle,llvm::SmallVector<mlir::AsmDialectResourceHandle,0u>,llvm::DenseSet<mlir::AsmDialectResourceHandle,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>>,0u>::insert((uint64_t)(v16 + 1), a2);
}

uint64_t mlir::AsmPrinter::Impl::printAlias(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;
  int v9;
  BOOL v10;
  unsigned int *v11;
  uint64_t v12;
  llvm::raw_ostream *v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  char *v18;
  void *v19;
  llvm::raw_ostream *v20;
  _DWORD *v21;
  const void *v22;
  size_t v23;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(v2 + 144);
  v4 = *(unsigned int *)(v2 + 160);
  if ((_DWORD)v4)
  {
    LODWORD(v5) = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    v6 = (_QWORD *)(v3 + 16 * v5);
    v7 = *v6;
    if (*v6 == a2)
      goto LABEL_8;
    v8 = 1;
    while (v7 != -4096)
    {
      v9 = v5 + v8++;
      v5 = v9 & (v4 - 1);
      v7 = *(_QWORD *)(v3 + 16 * v5);
      if (v7 == a2)
      {
        v6 = (_QWORD *)(v3 + 16 * v5);
        goto LABEL_8;
      }
    }
  }
  v6 = (_QWORD *)(v3 + 16 * v4);
LABEL_8:
  v10 = v6 == (_QWORD *)(v3 + 16 * v4);
  v11 = (unsigned int *)(v2 + 176);
  if (!v10)
    v11 = (unsigned int *)(v6 + 1);
  v12 = *v11;
  if ((_DWORD)v12 == *(_DWORD *)(v2 + 176))
    return 0;
  v14 = *(llvm::raw_ostream **)a1;
  v15 = *(_QWORD *)(v2 + 168) + 32 * v12;
  v16 = v15 + 8;
  if ((*(_BYTE *)(v15 + 27) & 0x40) != 0)
    v17 = "!";
  else
    v17 = "#";
  v18 = (char *)*((_QWORD *)v14 + 4);
  if (*((char **)v14 + 3) == v18)
  {
    v20 = llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, v17, 1uLL);
    v19 = (void *)*((_QWORD *)v20 + 4);
    v21 = (_DWORD *)(v15 + 24);
    v22 = *(const void **)v16;
    v23 = *(_QWORD *)(v16 + 8);
    if (v23 > *((_QWORD *)v20 + 3) - (_QWORD)v19)
      goto LABEL_17;
LABEL_19:
    if (v23)
    {
      memcpy(v19, v22, v23);
      *((_QWORD *)v20 + 4) += v23;
    }
    goto LABEL_21;
  }
  *v18 = *v17;
  v19 = (void *)(*((_QWORD *)v14 + 4) + 1);
  *((_QWORD *)v14 + 4) = v19;
  v20 = v14;
  v21 = (_DWORD *)(v15 + 24);
  v22 = *(const void **)v16;
  v23 = *(_QWORD *)(v16 + 8);
  if (v23 <= *((_QWORD *)v14 + 3) - (_QWORD)v19)
    goto LABEL_19;
LABEL_17:
  llvm::raw_ostream::write(v20, (const char *)v22, v23);
LABEL_21:
  if ((*v21 & 0x3FFFFFFF) != 0)
    llvm::raw_ostream::operator<<(v14, *v21 & 0x3FFFFFFF);
  return 1;
}

void mlir::AsmPrinter::Impl::printAttributeImpl(llvm::raw_ostream **a1, uint64_t **a2, int a3)
{
  void *v6;
  uint64_t **v7;
  llvm::raw_ostream *v8;
  const char *AttrData;
  size_t v10;
  size_t v11;
  char *v12;
  size_t v13;
  uint64_t v14;
  uint64_t canMapOperands;
  uint64_t **v16;
  llvm::raw_ostream *v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t **v20;
  llvm::raw_ostream *v21;
  uint64_t v22;
  llvm::raw_ostream *v23;
  unsigned int v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t ***v28;
  uint64_t **v29;
  uint64_t ***v30;
  int v31;
  BOOL v32;
  unsigned int v33;
  llvm::raw_ostream *v34;
  _DWORD *v35;
  uint64_t *v36;
  void *v37;
  uint64_t **v38;
  llvm::raw_ostream *v39;
  _BYTE *v40;
  int v41;
  uint64_t **v42;
  llvm::raw_ostream *v43;
  _WORD *v44;
  uint64_t Value;
  uint64_t v46;
  llvm::raw_ostream *v47;
  uint64_t v48;
  uint64_t **v49;
  llvm::raw_ostream *v50;
  unsigned __int32 v51;
  BOOL v52;
  uint64_t *v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  llvm::raw_ostream *v57;
  uint64_t *v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  _WORD *v62;
  uint64_t v63;
  uint64_t v64;
  llvm::raw_ostream *v65;
  char *v66;
  char v67;
  llvm::raw_ostream *v68;
  _BYTE *v69;
  uint64_t **v70;
  char v71;
  char *v73;
  uint64_t **v74;
  llvm::raw_ostream *v75;
  uint64_t v76;
  uint64_t **v77;
  llvm::raw_ostream *v78;
  _BYTE *v79;
  uint64_t **v80;
  unint64_t v81;
  llvm::raw_ostream *v82;
  uint64_t **v83;
  uint64_t **v84;
  uint64_t **v85;
  uint64_t v86;
  int v87;
  unsigned int v88;
  uint64_t **v89;
  uint64_t **v90;
  char *v91;
  size_t v92;
  uint64_t v93;
  uint64_t v94;
  unint64_t *v95;
  uint64_t v96;
  unint64_t v97;
  char *v98;
  size_t v99;
  uint64_t v100;
  int shouldElideElementsAttr;
  llvm::raw_ostream *v102;
  uint64_t v103;
  int v104;
  uint64_t **v105;
  _QWORD *RHS;
  uint64_t v107;
  uint64_t v108;
  llvm::raw_ostream *v109;
  uint64_t **v110;
  _QWORD *Values;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t **v115;
  uint64_t v116;
  unint64_t v117;
  unint64_t v118;
  unint64_t v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  uint64_t **v124;
  uint64_t ***v125;
  int v126;
  BOOL v127;
  unsigned int v128;
  uint64_t **v129;
  uint64_t **v130;
  uint64_t v131;
  uint64_t **v132;
  uint64_t **v133;
  uint64_t **v134;
  uint64_t **v135;
  uint64_t **v136;
  uint64_t **v137;
  uint64_t **v138;
  uint64_t **v139;
  uint64_t v140;
  uint64_t **v141;
  uint64_t **v142;
  uint64_t **v143;
  uint64_t **v144;
  __n128 v145[2];
  uint64_t v146;

  v146 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(**a2 + 24) != &mlir::detail::TypeIDResolver<mlir::BuiltinDialect,void>::id)
  {
    mlir::AsmPrinter::Impl::printDialectAttribute((uint64_t)a1, a2);
LABEL_8:
    if (a3 != 2)
    {
      if (!mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>((uint64_t)(*a2 + 1)))
      {
        v145[0] = 0uLL;
        return;
      }
      v14 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>((uint64_t)(*a2 + 1));
      v145[0].n128_u64[0] = (unint64_t)a2;
      v145[0].n128_u64[1] = v14;
      if (a2)
      {
        canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)v145);
        if (*(_UNKNOWN **)(*(_QWORD *)canMapOperands + 136) != &mlir::detail::TypeIDResolver<mlir::NoneType,void>::id)
        {
          v16 = (uint64_t **)canMapOperands;
          v17 = *a1;
          v18 = *((_QWORD *)*a1 + 4);
          if ((unint64_t)(*((_QWORD *)*a1 + 3) - v18) > 2)
          {
            *(_BYTE *)(v18 + 2) = 32;
            *(_WORD *)v18 = 14880;
            *((_QWORD *)v17 + 4) += 3;
            if (!mlir::AsmPrinter::Impl::printAlias((uint64_t)a1, (uint64_t)v16))
            {
LABEL_37:
              mlir::AsmPrinter::Impl::printTypeImpl((uint64_t)a1, v16);
              return;
            }
          }
          else
          {
            llvm::raw_ostream::write(v17, " : ", 3uLL);
            if (!mlir::AsmPrinter::Impl::printAlias((uint64_t)a1, (uint64_t)v16))
              goto LABEL_37;
          }
        }
      }
    }
    return;
  }
  v6 = (void *)(*a2)[17];
  if (v6 == &mlir::detail::TypeIDResolver<mlir::OpaqueAttr,void>::id)
    v7 = a2;
  else
    v7 = 0;
  v144 = v7;
  if (v7)
  {
    v8 = *a1;
    v145[0].n128_u64[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v144);
    AttrData = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v145);
    v11 = v10;
    v12 = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v144);
    printDialectSymbol(v8, "#", 1uLL, AttrData, v11, v12, v13);
    goto LABEL_8;
  }
  if (v6 == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    v34 = *a1;
    v35 = (_DWORD *)*((_QWORD *)*a1 + 4);
    if (*((_QWORD *)*a1 + 3) - (_QWORD)v35 > 3uLL)
    {
      *v35 = 1953066613;
      *((_QWORD *)v34 + 4) += 4;
    }
    else
    {
      llvm::raw_ostream::write(v34, "unit", 4uLL);
    }
    return;
  }
  if ((v19 & 1) == 0
  {
    v145[0].n128_u64[0] = (unint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::DistinctAttr]";
    v145[0].n128_u64[1] = 68;
    v117 = llvm::StringRef::find((uint64_t *)v145, "DesiredTypeName = ", 0x12uLL, 0);
    if (v145[0].n128_u64[1] >= v117)
      v118 = v117;
    else
      v118 = v145[0].n128_u64[1];
    v119 = v145[0].n128_u64[0] + v118;
    v120 = v145[0].n128_u64[1] - v118;
    if (v145[0].n128_u64[1] - v118 >= 0x12)
      v121 = 18;
    else
      v121 = v145[0].n128_u64[1] - v118;
    v122 = v120 - v121;
    if (v122 >= v122 - 1)
      v123 = v122 - 1;
    else
      v123 = v122;
    mlir::detail::TypeIDResolver<mlir::DistinctAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v119 + v121, v123);
  }
  if (v6 == (void *)mlir::detail::TypeIDResolver<mlir::DistinctAttr,void>::resolveTypeID(void)::id)
    v20 = a2;
  else
    v20 = 0;
  v143 = v20;
  if (v20)
  {
    v21 = *a1;
    v22 = *((_QWORD *)*a1 + 4);
    if ((unint64_t)(*((_QWORD *)*a1 + 3) - v22) > 8)
    {
      *(_BYTE *)(v22 + 8) = 91;
      *(_QWORD *)v22 = *(_QWORD *)"distinct[";
      *((_QWORD *)v21 + 4) += 9;
      v23 = a1[1];
      v24 = *((_DWORD *)v23 + 152);
      if (v24)
      {
LABEL_26:
        v25 = *((_QWORD *)v23 + 74);
        v26 = v24 - 1;
        v27 = ((v20 >> 4) ^ (v20 >> 9)) & (v24 - 1);
        v28 = (uint64_t ***)(v25 + 16 * v27);
        v29 = *v28;
        if (*v28 == v20)
          goto LABEL_52;
        v30 = 0;
        v31 = 1;
        while (v29 != (uint64_t **)-4096)
        {
          if (v30)
            v32 = 0;
          else
            v32 = v29 == (uint64_t **)-8192;
          if (v32)
            v30 = v28;
          v33 = v27 + v31++;
          v27 = v33 & v26;
          v28 = (uint64_t ***)(v25 + 16 * (v33 & v26));
          v29 = *v28;
          if (*v28 == v20)
            goto LABEL_52;
        }
        if (v30)
          v28 = v30;
        v41 = *((_DWORD *)v23 + 150);
        if (4 * v41 + 4 >= 3 * v24)
          goto LABEL_143;
        goto LABEL_48;
      }
    }
    else
    {
      v21 = llvm::raw_ostream::write(*a1, "distinct[", 9uLL);
      v23 = a1[1];
      v24 = *((_DWORD *)v23 + 152);
      if (v24)
        goto LABEL_26;
    }
    v28 = 0;
    v41 = *((_DWORD *)v23 + 150);
    if (4 * v41 + 4 >= 3 * v24)
    {
LABEL_143:
      v24 *= 2;
      goto LABEL_144;
    }
LABEL_48:
    if (v24 + ~v41 - *((_DWORD *)v23 + 151) > v24 >> 3)
    {
      v42 = *v28;
      ++*((_DWORD *)v23 + 150);
      if (v42 == (uint64_t **)-4096)
      {
LABEL_51:
        *v28 = v20;
        v28[1] = (uint64_t **)(*((_QWORD *)v23 + 73))++;
LABEL_52:
        v43 = llvm::raw_ostream::operator<<(v21, (unint64_t)v28[1]);
        v44 = (_WORD *)*((_QWORD *)v43 + 4);
        if (*((_QWORD *)v43 + 3) - (_QWORD)v44 > 1uLL)
        {
          *v44 = 15453;
          *((_QWORD *)v43 + 4) += 2;
        }
        else
        {
          llvm::raw_ostream::write(v43, "]<", 2uLL);
        }
        if (*(_UNKNOWN **)(*(_QWORD *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v143) + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        {
          Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v143);
          if (Value)
          {
            v46 = Value;
              mlir::AsmPrinter::Impl::printAttributeImpl(a1, v46, 0);
          }
          else
          {
            v47 = *a1;
            v48 = *((_QWORD *)*a1 + 4);
            if ((unint64_t)(*((_QWORD *)*a1 + 3) - v48) > 0x11)
            {
              *(_WORD *)(v48 + 16) = 15934;
              *(_OWORD *)v48 = *(_OWORD *)"<<NULL ATTRIBUTE>>";
              *((_QWORD *)v47 + 4) += 18;
            }
            else
            {
              llvm::raw_ostream::write(v47, "<<NULL ATTRIBUTE>>", 0x12uLL);
            }
          }
        }
        goto LABEL_81;
      }
LABEL_50:
      --*((_DWORD *)v23 + 151);
      goto LABEL_51;
    }
LABEL_144:
    llvm::DenseMap<mlir::Region *,std::pair<unsigned int,unsigned int>,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,std::pair<unsigned int,unsigned int>>>::grow((uint64_t)v23 + 592, v24);
    v86 = *((_QWORD *)v23 + 74);
    v87 = *((_DWORD *)v23 + 152) - 1;
    v88 = v87 & ((v20 >> 4) ^ (v20 >> 9));
    v28 = (uint64_t ***)(v86 + 16 * v88);
    v89 = *v28;
    if (*v28 == v20)
    {
LABEL_145:
      ++*((_DWORD *)v23 + 150);
      if (v20 == (uint64_t **)-4096)
        goto LABEL_51;
    }
    else
    {
      v125 = 0;
      v126 = 1;
      while (v89 != (uint64_t **)-4096)
      {
        if (v125)
          v127 = 0;
        else
          v127 = v89 == (uint64_t **)-8192;
        if (v127)
          v125 = v28;
        v128 = v88 + v126++;
        v88 = v128 & v87;
        v28 = (uint64_t ***)(v86 + 16 * (v128 & v87));
        v89 = *v28;
        if (*v28 == v20)
          goto LABEL_145;
      }
      if (v125)
        v28 = v125;
      v129 = *v28;
      ++*((_DWORD *)v23 + 150);
      if (v129 == (uint64_t **)-4096)
        goto LABEL_51;
    }
    goto LABEL_50;
  }
  v36 = *a2;
  v37 = (void *)(*a2)[17];
  if (v37 == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v38 = a2;
  else
    v38 = 0;
  v142 = v38;
  if (v38)
  {
    v39 = *a1;
    v40 = (_BYTE *)*((_QWORD *)*a1 + 4);
    if ((unint64_t)v40 >= *((_QWORD *)*a1 + 3))
    {
      llvm::raw_ostream::write(v39, 123);
    }
    else
    {
      *((_QWORD *)v39 + 4) = v40 + 1;
      *v40 = 123;
    }
    v53 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v142);
    if (v54)
    {
      v55 = v53;
      v56 = v54;
      v57 = *a1;
      mlir::AsmPrinter::Impl::printNamedAttribute(a1, *v53, v53[1]);
      if (v56 != 1)
      {
        v58 = &v55[2 * v56];
        v59 = v55 + 2;
        do
        {
          while (1)
          {
            v62 = (_WORD *)*((_QWORD *)v57 + 4);
            if (*((_QWORD *)v57 + 3) - (_QWORD)v62 <= 1uLL)
              break;
            *v62 = 8236;
            *((_QWORD *)v57 + 4) += 2;
            v60 = *v59;
            v61 = v59[1];
            v59 += 2;
            mlir::AsmPrinter::Impl::printNamedAttribute(a1, v60, v61);
            if (v59 == v58)
              goto LABEL_76;
          }
          llvm::raw_ostream::write(v57, ", ", 2uLL);
          v63 = *v59;
          v64 = v59[1];
          v59 += 2;
          mlir::AsmPrinter::Impl::printNamedAttribute(a1, v63, v64);
        }
        while (v59 != v58);
      }
    }
LABEL_76:
    v65 = *a1;
    v66 = (char *)*((_QWORD *)*a1 + 4);
    if ((unint64_t)v66 >= *((_QWORD *)*a1 + 3))
    {
      llvm::raw_ostream::write(v65, 125);
      goto LABEL_8;
    }
    *((_QWORD *)v65 + 4) = v66 + 1;
    v67 = 125;
    goto LABEL_78;
  }
  if (v37 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    v49 = a2;
  else
    v49 = 0;
  v141 = v49;
  if (!v49)
  {
    if (v37 == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
      v70 = a2;
    else
      v70 = 0;
    v140 = (uint64_t)v70;
    if (v70)
    {
      mlir::FloatAttr::getValue((mlir::FloatAttr *)&v140, (uint64_t)v145);
      printFloatValue((const llvm::APFloat *)v145, *a1);
      llvm::APFloat::~APFloat((llvm::APFloat *)v145);
      if (a3 == 1)
      {
        v145[0].n128_u64[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v140);
        if (mlir::Type::isF64((mlir::Type *)v145))
          return;
      }
      goto LABEL_8;
    }
    if (v37 == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
      v74 = a2;
    else
      v74 = 0;
    v139 = v74;
    if (v74)
    {
      v75 = (llvm::raw_ostream *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v139);
      mlir::AsmPrinter::Impl::printEscapedString(a1, v75, v76);
      goto LABEL_8;
    }
    if (v37 == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
      v77 = a2;
    else
      v77 = 0;
    v138 = v77;
    if (v77)
    {
      v78 = *a1;
      v79 = (_BYTE *)*((_QWORD *)*a1 + 4);
      if ((unint64_t)v79 >= *((_QWORD *)*a1 + 3))
      {
        llvm::raw_ostream::write(v78, 91);
      }
      else
      {
        *((_QWORD *)v78 + 4) = v79 + 1;
        *v79 = 91;
      }
      v145[0].n128_u64[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v138);
      v145[0].n128_u64[1] = v81;
      llvm::interleaveComma<llvm::ArrayRef<mlir::Attribute>,mlir::AsmPrinter::Impl::printAttributeImpl(mlir::Attribute,mlir::AsmPrinter::Impl::AttrTypeElision)::$_1,llvm::raw_ostream,mlir::Attribute const>((llvm::raw_ostream *)v145, *a1, a1);
      v82 = *a1;
      v66 = (char *)*((_QWORD *)*a1 + 4);
      if ((unint64_t)v66 >= *((_QWORD *)*a1 + 3))
      {
        llvm::raw_ostream::write(v82, 93);
        goto LABEL_8;
      }
      *((_QWORD *)v82 + 4) = v66 + 1;
      v67 = 93;
      goto LABEL_78;
    }
    if (v37 == &mlir::detail::TypeIDResolver<mlir::AffineMapAttr,void>::id)
      v80 = a2;
    else
      v80 = 0;
    v137 = v80;
    if (v80)
    {
      llvm::raw_ostream::operator<<(*a1, "affine_map<");
      v145[0].n128_u64[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v137);
      mlir::AffineMap::print((mlir::AffineMap *)v145, *a1);
LABEL_81:
      v68 = *a1;
      v69 = (_BYTE *)*((_QWORD *)*a1 + 4);
      if ((unint64_t)v69 >= *((_QWORD *)*a1 + 3))
      {
        llvm::raw_ostream::write(v68, 62);
      }
      else
      {
        *((_QWORD *)v68 + 4) = v69 + 1;
        *v69 = 62;
      }
      return;
    }
    if (v37 == &mlir::detail::TypeIDResolver<mlir::IntegerSetAttr,void>::id)
      v83 = a2;
    else
      v83 = 0;
    v136 = v83;
    if (v83)
    {
      llvm::raw_ostream::operator<<(*a1, "affine_set<");
      v145[0].n128_u64[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v136);
      mlir::IntegerSet::print((mlir::IntegerSet *)v145, *a1);
    }
    if (v37 == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
      v84 = a2;
    else
      v84 = 0;
    v135 = v84;
    if (v84)
    {
      v85 = (uint64_t **)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v135);
      mlir::AsmPrinter::Impl::printType((uint64_t)a1, v85);
      goto LABEL_8;
    }
    if (v37 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
      v90 = a2;
    else
      v90 = 0;
    v134 = v90;
    if (v90)
    {
      v145[0].n128_u64[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v134);
      v91 = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v145);
      printSymbolReference(v91, v92, *a1);
      v93 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v134);
      if (v94)
      {
        v95 = (unint64_t *)v93;
        v96 = 8 * v94;
        do
        {
          v97 = *v95++;
          v145[0].n128_u64[0] = v97;
          llvm::raw_ostream::operator<<(*a1, "::");
          v98 = (char *)mlir::FlatSymbolRefAttr::getValue((mlir::FlatSymbolRefAttr *)v145);
          printSymbolReference(v98, v99, *a1);
          v96 -= 8;
        }
        while (v96);
      }
      goto LABEL_8;
    }
    if (v37 == &mlir::detail::TypeIDResolver<mlir::DenseIntOrFPElementsAttr,void>::id && a2)
    {
      v100 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)(v36 + 1));
      shouldElideElementsAttr = mlir::OpPrintingFlags::shouldElideElementsAttr((uint64_t)(a1 + 2), (uint64_t)a2, v100);
      v102 = *a1;
      if (!shouldElideElementsAttr)
      {
        llvm::raw_ostream::operator<<(v102, "dense<");
        mlir::AsmPrinter::Impl::printDenseIntOrFPElementsAttr(a1, (uint64_t)a2, 1);
LABEL_170:
        v109 = *a1;
        v66 = (char *)*((_QWORD *)*a1 + 4);
        if ((unint64_t)v66 >= *((_QWORD *)*a1 + 3))
        {
          llvm::raw_ostream::write(v109, 62);
          goto LABEL_8;
        }
        *((_QWORD *)v109 + 4) = v66 + 1;
        v67 = 62;
LABEL_78:
        *v66 = v67;
        goto LABEL_8;
      }
    }
    else
    {
      if (v37 != &mlir::detail::TypeIDResolver<mlir::DenseStringElementsAttr,void>::id || !a2)
      {
        if (v37 == &mlir::detail::TypeIDResolver<mlir::SparseElementsAttr,void>::id)
          v105 = a2;
        else
          v105 = 0;
        v133 = v105;
        if (!v105)
        {
          if (v37 == &mlir::detail::TypeIDResolver<mlir::StridedLayoutAttr,void>::id)
            v110 = a2;
          else
            v110 = 0;
          v132 = v110;
          if (v110)
          {
            mlir::StridedLayoutAttr::print((llvm::raw_ostream *)&v132, *a1);
          }
          else
          {
            if (v37 == &mlir::detail::TypeIDResolver<mlir::DenseArrayAttr,void>::id)
              v114 = (uint64_t)a2;
            else
              v114 = 0;
            v131 = v114;
            if (v114)
            {
              llvm::raw_ostream::operator<<(*a1, "array<");
              v115 = (uint64_t **)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v131);
              mlir::AsmPrinter::Impl::printType((uint64_t)a1, v115);
              if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v131))
              {
                llvm::raw_ostream::operator<<(*a1, ": ");
                mlir::AsmPrinter::Impl::printDenseArrayAttr(a1, v131);
              }
              llvm::raw_ostream::operator<<(*a1, ">");
              return;
            }
            if (v37 == &mlir::detail::TypeIDResolver<mlir::DenseResourceElementsAttr,void>::id)
              v124 = a2;
            else
              v124 = 0;
            v130 = v124;
            if (v124)
            {
              llvm::raw_ostream::operator<<(*a1, "dense_resource<");
              mlir::DenseResourceElementsAttr::getRawHandle((mlir::DenseResourceElementsAttr *)&v130, v145);
              mlir::AsmPrinter::Impl::printResourceHandle((uint64_t)a1, (uint64_t *)v145);
              llvm::raw_ostream::operator<<(*a1, ">");
            }
            else
            {
              if (!mlir::LocationAttr::classof((uint64_t)a2) || !a2)
                llvm::report_fatal_error((llvm *)"Unknown builtin attribute", (const char *)1);
              mlir::AsmPrinter::Impl::printLocation((uint64_t)a1, (uint64_t)a2, 0);
            }
          }
          goto LABEL_8;
        }
        RHS = (_QWORD *)mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v133);
        v107 = (uint64_t)RHS;
        if (RHS)
          v108 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*RHS + 8);
        else
          v108 = 0;
        if ((mlir::OpPrintingFlags::shouldElideElementsAttr((uint64_t)(a1 + 2), v107, v108) & 1) != 0
          || ((Values = (_QWORD *)mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v133),
               (v112 = (uint64_t)Values) == 0)
            ? (v113 = 0)
            : (v113 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*Values + 8)),
              mlir::OpPrintingFlags::shouldElideElementsAttr((uint64_t)(a1 + 2), v112, v113)))
        {
          printElidedElementsAttr(*a1);
          goto LABEL_8;
        }
        llvm::raw_ostream::operator<<(*a1, "sparse<");
        v145[0].n128_u64[0] = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v133);
        if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v145))
        {
          mlir::AsmPrinter::Impl::printDenseIntOrFPElementsAttr(a1, v145[0].n128_i64[0], 0);
          llvm::raw_ostream::operator<<(*a1, ", ");
          v116 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v133);
          mlir::AsmPrinter::Impl::printDenseElementsAttr(a1, v116, 1);
        }
        goto LABEL_170;
      }
      v103 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)(v36 + 1));
      v104 = mlir::OpPrintingFlags::shouldElideElementsAttr((uint64_t)(a1 + 2), (uint64_t)a2, v103);
      v102 = *a1;
      if (!v104)
      {
        llvm::raw_ostream::operator<<(v102, "dense<");
        mlir::AsmPrinter::Impl::printDenseStringElementsAttr(a1, (uint64_t)a2);
        goto LABEL_170;
      }
    }
    printElidedElementsAttr(v102);
    goto LABEL_8;
  }
  v140 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v141);
  if (mlir::Type::isSignlessInteger((mlir::Type *)&v140, 1))
  {
    v50 = *a1;
    mlir::IntegerAttr::getValue(&v141, (llvm::APInt *)v145);
    v51 = v145[0].n128_u32[2];
    if (v145[0].n128_u32[2] > 0x40)
      v52 = llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)v145) == v51;
    else
      v52 = v145[0].n128_u64[0] == 0;
    if (v52)
      v73 = "false";
    else
      v73 = "true";
    llvm::raw_ostream::operator<<(v50, v73);
    if (v145[0].n128_u32[2] >= 0x41 && v145[0].n128_u64[0])
      operator delete[]((void *)v145[0].n128_u64[0]);
    return;
  }
  v71 = !mlir::Type::isUnsignedInteger((mlir::Type *)&v140) && !mlir::Type::isSignlessInteger((mlir::Type *)&v140, 1);
  mlir::IntegerAttr::getValue(&v141, (llvm::APInt *)v145);
  llvm::APInt::print((llvm::APInt *)v145, *a1, v71);
  if (v145[0].n128_u32[2] >= 0x41 && v145[0].n128_u64[0])
    operator delete[]((void *)v145[0].n128_u64[0]);
  if (a3 != 1 || !mlir::Type::isSignlessInteger((mlir::Type *)&v140, 64))
    goto LABEL_8;
}

void mlir::AsmPrinter::Impl::printDialectAttribute(uint64_t a1, uint64_t **a2)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  char *v7;
  size_t v8;
  _QWORD v9[2];
  _QWORD v10[2];
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  int v14;
  void *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  int v22;
  void **v23;
  char *v24;
  size_t v25;
  uint64_t v26;

  v4 = **a2;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v16 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 1;
  v18 = 0;
  v19 = 0;
  v17 = 0;
  v15 = &unk_1E0E22B10;
  v23 = (void **)&v24;
  llvm::raw_ostream::SetBufferAndMode((uint64_t)&v15, 0, 0, 0);
  v5 = *(_QWORD *)(a1 + 8);
  v10[0] = &v15;
  v10[1] = v5;
  v13 = *(_QWORD *)(v5 + 648);
  v6 = *(_OWORD *)(v5 + 632);
  v11 = *(_OWORD *)(v5 + 616);
  v12 = v6;
  v14 = 1;
  v9[0] = off_1E0E2B7F0;
  v9[1] = v10;
  (*(void (**)(uint64_t, uint64_t **, _QWORD *))(*(_QWORD *)v4 + 40))(v4, a2, v9);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v15);
  if (v26 >= 0)
    v7 = (char *)&v24;
  else
    v7 = v24;
  if (v26 >= 0)
    v8 = HIBYTE(v26);
  else
    v8 = v25;
  printDialectSymbol(*(llvm::raw_ostream **)a1, "#", 1uLL, *(const char **)(v4 + 8), *(_QWORD *)(v4 + 16), v7, v8);
  if (SHIBYTE(v26) < 0)
    operator delete(v24);
}

llvm::raw_ostream *printDialectSymbol(llvm::raw_ostream *a1, const char *a2, size_t a3, const char *a4, size_t a5, char *a6, size_t a7)
{
  llvm::raw_ostream *v12;
  void *v13;
  uint64_t v14;
  llvm::raw_ostream *v15;
  unsigned int v16;
  size_t v17;
  int v18;
  BOOL v19;
  BOOL v21;
  _BYTE *v22;
  void *v23;
  llvm::raw_ostream *result;
  _BYTE *v25;

  v12 = a1;
  v14 = *((_QWORD *)a1 + 3);
  v13 = (void *)*((_QWORD *)a1 + 4);
  if (a3 > v14 - (uint64_t)v13)
  {
    v15 = llvm::raw_ostream::write(v12, a2, a3);
    v13 = (void *)*((_QWORD *)v15 + 4);
    if (a5 <= *((_QWORD *)v15 + 3) - (_QWORD)v13)
      goto LABEL_3;
LABEL_10:
    llvm::raw_ostream::write(v15, a4, a5);
    if (!a7)
      goto LABEL_35;
    goto LABEL_11;
  }
  if (a3)
  {
    memcpy(v13, a2, a3);
    v13 = (void *)(*((_QWORD *)v12 + 4) + a3);
    *((_QWORD *)v12 + 4) = v13;
  }
  v15 = v12;
  if (a5 > *((_QWORD *)v12 + 3) - (_QWORD)v13)
    goto LABEL_10;
LABEL_3:
  if (a5)
  {
    memcpy(v13, a4, a5);
    *((_QWORD *)v15 + 4) += a5;
  }
  if (!a7)
    goto LABEL_35;
LABEL_11:
  v16 = *a6;
  if ((v16 & 0x80000000) != 0)
  {
    if (!__maskrune(v16, 0x100uLL))
      goto LABEL_35;
  }
  else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v16 + 60) & 0x100) == 0)
  {
    goto LABEL_35;
  }
  v17 = 0;
  while (1)
  {
    v18 = a6[v17];
    if (v18 != 95)
    {
      v19 = v18 != 46 && (v18 - 48) >= 0xA;
      if (v19 && (v18 & 0xFFFFFFDF) - 65 > 0x19)
        break;
    }
    if (a7 == ++v17)
      goto LABEL_32;
  }
  v21 = a7 > v17;
  if (a7 < v17)
    v17 = a7;
  if (v21 && (a6[v17] != 60 || a6[v17 + a7 + ~v17] != 62))
  {
LABEL_35:
    v25 = (_BYTE *)*((_QWORD *)v12 + 4);
    if ((unint64_t)v25 >= *((_QWORD *)v12 + 3))
    {
      v12 = llvm::raw_ostream::write(v12, 60);
      result = (llvm::raw_ostream *)*((_QWORD *)v12 + 4);
      if (a7 <= *((_QWORD *)v12 + 3) - (_QWORD)result)
      {
LABEL_37:
        if (a7)
        {
          memcpy(result, a6, a7);
          result = (llvm::raw_ostream *)(*((_QWORD *)v12 + 4) + a7);
          *((_QWORD *)v12 + 4) = result;
        }
        if ((unint64_t)result < *((_QWORD *)v12 + 3))
          goto LABEL_40;
        return llvm::raw_ostream::write(v12, 62);
      }
    }
    else
    {
      *((_QWORD *)v12 + 4) = v25 + 1;
      *v25 = 60;
      result = (llvm::raw_ostream *)*((_QWORD *)v12 + 4);
      if (a7 <= *((_QWORD *)v12 + 3) - (_QWORD)result)
        goto LABEL_37;
    }
    v12 = llvm::raw_ostream::write(v12, a6, a7);
    result = (llvm::raw_ostream *)*((_QWORD *)v12 + 4);
    if ((unint64_t)result < *((_QWORD *)v12 + 3))
    {
LABEL_40:
      *((_QWORD *)v12 + 4) = (char *)result + 1;
      *(_BYTE *)result = 62;
      return result;
    }
    return llvm::raw_ostream::write(v12, 62);
  }
LABEL_32:
  v22 = (_BYTE *)*((_QWORD *)v12 + 4);
  if ((unint64_t)v22 >= *((_QWORD *)v12 + 3))
  {
    v12 = llvm::raw_ostream::write(v12, 46);
    v23 = (void *)*((_QWORD *)v12 + 4);
    if (a7 <= *((_QWORD *)v12 + 3) - (_QWORD)v23)
      goto LABEL_34;
  }
  else
  {
    *((_QWORD *)v12 + 4) = v22 + 1;
    *v22 = 46;
    v23 = (void *)*((_QWORD *)v12 + 4);
    if (a7 <= *((_QWORD *)v12 + 3) - (_QWORD)v23)
    {
LABEL_34:
      result = (llvm::raw_ostream *)memcpy(v23, a6, a7);
      *((_QWORD *)v12 + 4) += a7;
      return result;
    }
  }
  return llvm::raw_ostream::write(v12, a6, a7);
}

void printFloatValue(const llvm::APFloat *a1, llvm::raw_ostream *a2)
{
  llvm::detail::DoubleAPFloat *v4;
  void *v5;
  void *v6;
  const llvm::APFloat *v7;
  int IsEqual;
  void *v9;
  _QWORD *v10;
  size_t v11;
  _BYTE *v12;
  void *__p;
  _QWORD v14[3];
  void *v15;
  __int128 v16;
  _QWORD v17[17];

  v17[16] = *MEMORY[0x1E0C80C00];
  v4 = (const llvm::APFloat *)((char *)a1 + 8);
  v5 = (void *)*((_QWORD *)a1 + 1);
  v6 = llvm::APFloatBase::PPCDoubleDouble(a1);
  v7 = (const llvm::APFloat *)*((_QWORD *)a1 + 2);
  if (v6 != v5)
    v7 = a1;
  if ((*((_BYTE *)v7 + 28) & 6) == 0)
  {
LABEL_28:
    v15 = v17;
    v16 = xmmword_181236BC0;
    if (v6 == v5)
      llvm::detail::DoubleAPFloat::bitcastToAPInt(v4, (llvm::APInt *)&__p);
    else
      llvm::detail::IEEEFloat::bitcastToAPInt(v4, (uint64_t)&__p);
    llvm::APInt::toString((uint64_t)&__p, &v15, 0x10u, 0, 1, 1);
    llvm::raw_ostream::write(a2, (const char *)v15, v16);
    if (LODWORD(v14[0]) >= 0x41)
    {
      if (__p)
        operator delete[](__p);
    }
    v9 = v15;
    if (v15 != v17)
      goto LABEL_35;
    return;
  }
  v15 = v17;
  v16 = xmmword_181236BB0;
  if (v6 == v5)
    llvm::detail::DoubleAPFloat::toString(v4, (uint64_t *)&v15, 6, 0, 0);
  else
    llvm::detail::IEEEFloat::toString((uint64_t)v4, (uint64_t *)&v15, 6u, 0, 0);
  llvm::APFloat::APFloat((llvm::APFloatBase *)&__p, *(void **)v4, (unsigned __int8 *)v15, v16);
  if (v14[0] == *(_QWORD *)v4)
  {
    if (v6 == (void *)v14[0])
    {
      IsEqual = llvm::detail::DoubleAPFloat::bitwiseIsEqual((llvm::detail::DoubleAPFloat *)v14, v4);
      if (v6 == (void *)v14[0])
        goto LABEL_16;
    }
    else
    {
      IsEqual = llvm::detail::IEEEFloat::bitwiseIsEqual((llvm::detail::IEEEFloat *)v14, v4);
      if (v6 == (void *)v14[0])
        goto LABEL_16;
    }
LABEL_9:
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v14);
    if (IsEqual)
      goto LABEL_10;
    goto LABEL_17;
  }
  IsEqual = 0;
  if (v6 != (void *)v14[0])
    goto LABEL_9;
LABEL_16:
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v14);
  if (IsEqual)
  {
LABEL_10:
    llvm::raw_ostream::write(a2, (const char *)v15, v16);
    v9 = v15;
    if (v15 == v17)
      return;
LABEL_35:
    free(v9);
    return;
  }
LABEL_17:
  *(_QWORD *)&v16 = 0;
  if (v6 == *(void **)v4)
  {
    llvm::detail::DoubleAPFloat::toString(v4, (uint64_t *)&v15, 0, 3, 1);
    v10 = v15;
    v11 = v16;
    if (!(_QWORD)v16)
    {
LABEL_25:
      if (v10 != v17)
        free(v10);
      v5 = *(void **)v4;
      goto LABEL_28;
    }
  }
  else
  {
    llvm::detail::IEEEFloat::toString((uint64_t)v4, (uint64_t *)&v15, 0, 3u, 1);
    v10 = v15;
    v11 = v16;
    if (!(_QWORD)v16)
      goto LABEL_25;
  }
  v12 = memchr(v10, 46, v11);
  if (!v12 || v12 - (_BYTE *)v10 == -1)
    goto LABEL_25;
  llvm::raw_ostream::write(a2, (const char *)v10, v11);
  v9 = v15;
  if (v15 != v17)
    goto LABEL_35;
}

llvm::raw_ostream *mlir::AsmPrinter::Impl::printEscapedString(llvm::raw_ostream **a1, llvm::raw_ostream *a2, uint64_t a3)
{
  llvm::raw_ostream *v6;
  _BYTE *v7;
  llvm::raw_ostream *result;
  _BYTE *v9;

  v6 = *a1;
  v7 = (_BYTE *)*((_QWORD *)v6 + 4);
  if (*((_BYTE **)v6 + 3) == v7)
  {
    llvm::raw_ostream::write(v6, "\"", 1uLL);
  }
  else
  {
    *v7 = 34;
    ++*((_QWORD *)v6 + 4);
  }
  llvm::printEscapedString(a2, a3, *a1);
  result = *a1;
  v9 = (_BYTE *)*((_QWORD *)*a1 + 4);
  if (*((_BYTE **)*a1 + 3) == v9)
    return llvm::raw_ostream::write(result, "\"", 1uLL);
  *v9 = 34;
  ++*((_QWORD *)result + 4);
  return result;
}

double mlir::AffineMap::print(mlir::AffineMap *this, llvm::raw_ostream *a2)
{
  mlir::MLIRContext *LHS;
  char *v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  double result;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  int v15;

  if (*(_QWORD *)this)
  {
    LHS = (mlir::MLIRContext *)mlir::AffineBinaryOpExpr::getLHS(this);
    mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)&v11);
    v5 = (char *)operator new(0x2C0uLL);
    v6 = mlir::DialectInterfaceCollection<mlir::OpAsmDialectInterface>::DialectInterfaceCollection(v5, LHS);
    *(_QWORD *)(v6 + 56) = v6 + 72;
    *(_QWORD *)(v6 + 64) = 0x600000000;
    *(_OWORD *)(v6 + 120) = 0u;
    *(_DWORD *)(v6 + 136) = 0;
    *(_OWORD *)(v6 + 144) = 0u;
    *(_DWORD *)(v6 + 160) = 0;
    *(_OWORD *)(v6 + 184) = 0u;
    *(_QWORD *)(v6 + 168) = v6 + 184;
    *(_QWORD *)(v6 + 176) = 0;
    *(_QWORD *)(v6 + 200) = v6 + 216;
    *(_QWORD *)(v6 + 208) = 0x400000000;
    *(_QWORD *)(v6 + 248) = v6 + 264;
    *(_OWORD *)(v6 + 256) = 0u;
    *(_QWORD *)(v6 + 272) = 1;
    *(_OWORD *)(v6 + 280) = 0u;
    *(_DWORD *)(v6 + 296) = 0;
    *(_DWORD *)(v6 + 320) = 0;
    *(_OWORD *)(v6 + 304) = 0u;
    *(_DWORD *)(v6 + 344) = 0;
    *(_OWORD *)(v6 + 328) = 0u;
    *(_DWORD *)(v6 + 368) = 0;
    *(_OWORD *)(v6 + 352) = 0u;
    *(_DWORD *)(v6 + 392) = 0;
    *(_OWORD *)(v6 + 376) = 0u;
    *(_DWORD *)(v6 + 416) = 0;
    *(_OWORD *)(v6 + 400) = 0u;
    *(_OWORD *)(v6 + 424) = 0u;
    *(_QWORD *)(v6 + 440) = 0;
    *(_QWORD *)(v6 + 448) = v6 + 464;
    *(_QWORD *)(v6 + 456) = 0x400000000;
    *(_QWORD *)(v6 + 496) = v6 + 512;
    *(_OWORD *)(v6 + 504) = 0u;
    *(_QWORD *)(v6 + 520) = 1;
    *(_QWORD *)(v6 + 528) = 0;
    *((_DWORD *)v5 + 134) = 0;
    mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)(v6 + 544));
    *((_DWORD *)v5 + 152) = 0;
    *((_QWORD *)v5 + 75) = 0;
    *(_OWORD *)(v5 + 584) = 0u;
    v7 = v12;
    *(_OWORD *)(v5 + 616) = v11;
    *(_OWORD *)(v5 + 632) = v7;
    *((_QWORD *)v5 + 81) = v13;
    *((_QWORD *)v5 + 82) = 0;
    *(_OWORD *)(v5 + 664) = 0u;
    *((_DWORD *)v5 + 170) = 0;
    *((_QWORD *)v5 + 86) = v5 + 704;
    *((_QWORD *)v5 + 87) = 0;
    *(_QWORD *)&v11 = a2;
    *((_QWORD *)&v11 + 1) = v5;
    v8 = *(_OWORD *)(v5 + 632);
    v12 = *(_OWORD *)(v5 + 616);
    v13 = v8;
    v14 = *((_QWORD *)v5 + 81);
    v15 = 1;
    mlir::AsmPrinter::Impl::printAffineMap((llvm::raw_ostream **)&v11, *(_QWORD *)this);
    mlir::detail::AsmStateImpl::~AsmStateImpl((mlir::detail::AsmStateImpl *)v5);
  }
  v9 = *((_QWORD *)a2 + 4);
  if ((unint64_t)(*((_QWORD *)a2 + 3) - v9) > 0x12)
  {
    *(_DWORD *)(v9 + 15) = 1044271169;
    result = *(double *)"<<NULL AFFINE MAP>>";
    *(_OWORD *)v9 = *(_OWORD *)"<<NULL AFFINE MAP>>";
    *((_QWORD *)a2 + 4) += 19;
  }
  else
  {
    llvm::raw_ostream::write(a2, "<<NULL AFFINE MAP>>", 0x13uLL);
  }
  return result;
}

void mlir::IntegerSet::print(mlir::IntegerSet *this, llvm::raw_ostream *a2)
{
  mlir::MLIRContext *Context;
  char *v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  int v13;

  Context = (mlir::MLIRContext *)mlir::IntegerSet::getContext(this);
  mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)&v9);
  v5 = (char *)operator new(0x2C0uLL);
  v6 = mlir::DialectInterfaceCollection<mlir::OpAsmDialectInterface>::DialectInterfaceCollection(v5, Context);
  *(_QWORD *)(v6 + 56) = v6 + 72;
  *(_QWORD *)(v6 + 64) = 0x600000000;
  *(_OWORD *)(v6 + 120) = 0u;
  *(_DWORD *)(v6 + 136) = 0;
  *(_OWORD *)(v6 + 144) = 0u;
  *(_DWORD *)(v6 + 160) = 0;
  *(_OWORD *)(v6 + 184) = 0u;
  *(_QWORD *)(v6 + 168) = v6 + 184;
  *(_QWORD *)(v6 + 176) = 0;
  *(_QWORD *)(v6 + 200) = v6 + 216;
  *(_QWORD *)(v6 + 208) = 0x400000000;
  *(_QWORD *)(v6 + 248) = v6 + 264;
  *(_OWORD *)(v6 + 256) = 0u;
  *(_QWORD *)(v6 + 272) = 1;
  *(_OWORD *)(v6 + 280) = 0u;
  *(_DWORD *)(v6 + 296) = 0;
  *(_DWORD *)(v6 + 320) = 0;
  *(_OWORD *)(v6 + 304) = 0u;
  *(_DWORD *)(v6 + 344) = 0;
  *(_OWORD *)(v6 + 328) = 0u;
  *(_DWORD *)(v6 + 368) = 0;
  *(_OWORD *)(v6 + 352) = 0u;
  *(_DWORD *)(v6 + 392) = 0;
  *(_OWORD *)(v6 + 376) = 0u;
  *(_DWORD *)(v6 + 416) = 0;
  *(_OWORD *)(v6 + 400) = 0u;
  *(_OWORD *)(v6 + 424) = 0u;
  *(_QWORD *)(v6 + 440) = 0;
  *(_QWORD *)(v6 + 448) = v6 + 464;
  *(_QWORD *)(v6 + 456) = 0x400000000;
  *(_QWORD *)(v6 + 496) = v6 + 512;
  *(_OWORD *)(v6 + 504) = 0u;
  *(_QWORD *)(v6 + 520) = 1;
  *(_QWORD *)(v6 + 528) = 0;
  *((_DWORD *)v5 + 134) = 0;
  mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)(v6 + 544));
  *((_DWORD *)v5 + 152) = 0;
  *((_QWORD *)v5 + 75) = 0;
  *(_OWORD *)(v5 + 584) = 0u;
  v7 = v10;
  *(_OWORD *)(v5 + 616) = v9;
  *(_OWORD *)(v5 + 632) = v7;
  *((_QWORD *)v5 + 81) = v11;
  *((_QWORD *)v5 + 82) = 0;
  *(_OWORD *)(v5 + 664) = 0u;
  *((_DWORD *)v5 + 170) = 0;
  *((_QWORD *)v5 + 86) = v5 + 704;
  *((_QWORD *)v5 + 87) = 0;
  *(_QWORD *)&v9 = a2;
  *((_QWORD *)&v9 + 1) = v5;
  v8 = *(_OWORD *)(v5 + 632);
  v10 = *(_OWORD *)(v5 + 616);
  v11 = v8;
  v12 = *((_QWORD *)v5 + 81);
  v13 = 1;
  mlir::AsmPrinter::Impl::printIntegerSet((llvm::raw_ostream **)&v9, *(_QWORD *)this);
  mlir::detail::AsmStateImpl::~AsmStateImpl((mlir::detail::AsmStateImpl *)v5);
}

