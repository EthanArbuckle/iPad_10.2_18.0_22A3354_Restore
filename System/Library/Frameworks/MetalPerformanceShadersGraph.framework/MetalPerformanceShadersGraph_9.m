uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(uint64_t a1, uint64_t *a2, _BYTE *a3)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  _BYTE *v7;
  char v8;
  char v9;
  _QWORD *v10;

  v3 = 1;
  v9 = 1;
  if (*a3)
  {
    v7 = a3;
    v3 = 3;
  }
  v8 = v3;
  v4 = *a2;
  v10 = &v7;
  v5 = *(_QWORD *)(a1 + 16);
  if (!v5)
    return 0;
  result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v5 + 64))(v5, *(_QWORD *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::PoolL2NormOp &>(mlir::mps::PoolL2NormOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::PoolL2NormOp,mlir::Value,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyleAttr,mlir::DenseIntElementsAttr&,mlir::UnitAttr,mlir::UnitAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10)
{
  uint64_t *Context;
  uint64_t v19;
  char v20;
  mlir::GenericProgramPoint *v21;
  mlir::GenericProgramPoint *v22;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  uint64_t v27[4];
  __int16 v28;
  _QWORD v29[40];

  v29[38] = *MEMORY[0x1E0C80C00];
  v24 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_l2_norm", (const unsigned __int8 *)0x13, Context);
  if (!v20)
  {
    v28 = 1283;
    v27[2] = (uint64_t)"mps.pooling_l2_norm";
    v27[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v19);
  mlir::mps::PoolL2NormOp::build(a1, (uint64_t)v29, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10);
  v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((_QWORD *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PoolL2NormOp,void>::id)
    v22 = v21;
  else
    v22 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v22;
}

void mlir::mps::`anonymous namespace'::CanonicalizeConv2DWithConstantOperands::~CanonicalizeConv2DWithConstantOperands(mlir::mps::_anonymous_namespace_::CanonicalizeConv2DWithConstantOperands *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeConv2DWithConstantOperands::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  void *v17;
  uint64_t InterfaceFor;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  void *v23;
  uint64_t Input;
  void *v25;
  uint64_t v26;
  _QWORD v27[2];

  v27[1] = *MEMORY[0x1E0C80C00];
  v22 = 0;
  v23 = (void *)a2;
  v20 = 0;
  v21 = 0;
  v19 = 0;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v23);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Input);
  if (!DefiningOp)
    return 0;
  v5 = DefiningOp;
  v6 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v5 + 48) + 32))(*(_QWORD *)(v5 + 48), v6))
    return 0;
  v25 = v27;
  v26 = 0x100000000;
  mlir::Operation::fold(v5, 0, 0, (uint64_t)&v25);
  v7 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v25 & 0xFFFFFFFFFFFFFFF8));
  v9 = v7;
  if (v7)
  {
    v21 = v7;
    v22 = v8;
  }
  if (v25 != v27)
    free(v25);
  if (!v9)
    return 0;
  Input = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v23);
  v10 = mlir::Value::getDefiningOp((mlir::Value *)&Input);
  if (!v10)
    return 0;
  v11 = v10;
  v12 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v11 + 48) + 32))(*(_QWORD *)(v11 + 48), v12))
    return 0;
  v25 = v27;
  v26 = 0x100000000;
  mlir::Operation::fold(v11, 0, 0, (uint64_t)&v25);
  v13 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v25 & 0xFFFFFFFFFFFFFFF8));
  v15 = v13;
  if (v13)
  {
    v19 = v13;
    v20 = v14;
  }
  if (v25 != v27)
    free(v25);
  if (!v15
    || (mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v21) & 1) != 0
    || (mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v19) & 1) != 0)
  {
    return 0;
  }
  v17 = v23;
  if (v23)
    InterfaceFor = mlir::OpInterface<mlir::ConvertOpLayoutInterface,mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)v23);
  else
    InterfaceFor = 0;
  v25 = v17;
  v26 = InterfaceFor;
  return mlir::ConvertOpLayoutInterface::convertLayout((uint64_t)&v25, 1, 1, a3);
}

uint64_t mlir::OpInterface<mlir::ConvertOpLayoutInterface,mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  BOOL v3;
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  __guard v18;
  uint64_t v19;
  __guard v20;
  uint64_t v21;

  v1 = *(_QWORD *)(a1 + 48);
  v2 = *(void **)(v1 + 16);
  v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
    v4 = 0;
  else
    v4 = *(_QWORD *)(a1 + 48);
  if (v3)
  {
    v21 = *(_QWORD *)(v1 + 8);
    result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v21);
    if (result)
    {
      v19 = result;
      v20 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
      return (*(uint64_t (**)(uint64_t, __guard, uint64_t))(*(_QWORD *)v19 + 104))(v19, v20, v1);
    }
  }
  else
  {
    v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    v7 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
    v8 = *(unsigned int *)(v6 + 40);
    if (!(_DWORD)v8)
      goto LABEL_14;
    v9 = *(_QWORD **)(v6 + 32);
    v10 = &v9[2 * v8];
    do
    {
      v11 = v8 >> 1;
      v12 = &v9[2 * (v8 >> 1)];
      v14 = *v12;
      v13 = v12 + 2;
      v8 += ~(v8 >> 1);
      if (v14 < v7)
        v9 = v13;
      else
        v8 = v11;
    }
    while (v8);
    if (v9 == v10 || *v9 != v7 || (result = v9[1]) == 0)
    {
LABEL_14:
      v16 = *(_QWORD *)(v6 + 24);
      v17 = *(_QWORD *)(a1 + 48);
      v18 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
      return (*(uint64_t (**)(uint64_t, __guard, uint64_t))(*(_QWORD *)v16 + 104))(v16, v18, v17);
    }
  }
  return result;
}

__guard mlir::TypeID::get<mlir::ConvertOpLayoutInterface>()
{
  unsigned __int8 v0;
  __guard *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  if ((v0 & 1) == 0)
  {
    if (v3)
    {
      v11 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConvertOpLayoutInterface]";
      v12 = 80;
      v4 = llvm::StringRef::find((uint64_t *)&v11, "DesiredTypeName = ", 0x12uLL, 0);
      if (v12 >= v4)
        v5 = v4;
      else
        v5 = v12;
      v6 = &v11[v5];
      v7 = v12 - v5;
      if (v12 - v5 >= 0x12)
        v8 = 18;
      else
        v8 = v12 - v5;
      v9 = v7 - v8;
      if (v9 >= v9 - 1)
        v10 = v9 - 1;
      else
        v10 = v9;
      mlir::detail::TypeIDResolver<mlir::ConvertOpLayoutInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v6[v8], v10);
    }
  }
  return v1[124];
}

void mlir::mps::`anonymous namespace'::CanonicalizeMatMulTransposes::~CanonicalizeMatMulTransposes(mlir::mps::_anonymous_namespace_::CanonicalizeMatMulTransposes *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::MatMulOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::MatMulOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::MatMulOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeMatMulTransposes::matchAndRewrite(uint64_t a1, uint64_t *a2, mlir::BoolAttr **a3)
{
  uint64_t DefiningOp;
  uint64_t result;
  uint64_t v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  BOOL TransposeRhs;
  BOOL IsNegated;
  uint64_t Filter;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  mlir::GenericProgramPoint *Input;

  v21 = a2;
  Input = (mlir::GenericProgramPoint *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v21);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Input);
  if (!DefiningOp
    || *(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id)
  {
    Input = (mlir::GenericProgramPoint *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v21);
    result = mlir::Value::getDefiningOp((mlir::Value *)&Input);
    if (!result)
      return result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id)
      return 0;
  }
  Input = (mlir::GenericProgramPoint *)v21;
  v19 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v21);
  v6 = mlir::Value::getDefiningOp((mlir::Value *)&v19);
  if (v6)
  {
    v7 = *(void **)(*(_QWORD *)(v6 + 48) + 16);
    v8 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id;
    v9 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id ? v6 : 0;
    v20 = v9;
    if (v8)
    {
      {
        v10 = v21[3];
        v19 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v20);
        Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&Input);
        IsNegated = !mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&Input);
        TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&Input);
        Input = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value,mlir::Value,BOOL,BOOL>(a3 + 1, v10, &v19, &Filter, (unsigned __int8 *)&IsNegated, (unsigned __int8 *)&TransposeRhs);
      }
    }
  }
  v19 = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v21);
  v11 = mlir::Value::getDefiningOp((mlir::Value *)&v19);
  if (v11)
  {
    v12 = *(void **)(*(_QWORD *)(v11 + 48) + 16);
    v13 = v12 == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id;
    if (v12 == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id)
      v14 = v11;
    else
      v14 = 0;
    v20 = v14;
    if (v13)
    {
      {
        v15 = v21[3];
        v19 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&Input);
        Filter = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v20);
        IsNegated = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&Input);
        TransposeRhs = !mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&Input);
        Input = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value,mlir::Value,BOOL,BOOL>(a3 + 1, v15, &v19, &Filter, (unsigned __int8 *)&IsNegated, (unsigned __int8 *)&TransposeRhs);
      }
    }
  }
  if (Input == (mlir::GenericProgramPoint *)v21)
    return 0;
  (*((void (**)(mlir::BoolAttr **))*a3 + 4))(a3);
  return 1;
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeMatMulTransposes::checkCompatibleTranspose(uint64_t a1)
{
  uint64_t DefiningOp;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t *v20;
  _QWORD *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD v31[2];
  uint64_t v32;
  void *v33[2];
  uint64_t v34;
  void *v35;
  uint64_t v36;
  _QWORD v37[2];

  v37[1] = *MEMORY[0x1E0C80C00];
  v32 = a1;
  v33[0] = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v32);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v33);
  if (!DefiningOp)
    return 0;
  v2 = DefiningOp;
  v3 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 48) + 32))(*(_QWORD *)(v2 + 48), v3))
    return 0;
  v35 = v37;
  v36 = 0x100000000;
  mlir::Operation::fold(v2, 0, 0, (uint64_t)&v35);
  v5 = (uint64_t)llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v35 & 0xFFFFFFFFFFFFFFF8));
  if (v5)
    v6 = v4;
  else
    v6 = 0;
  if (v35 != v37)
    free(v35);
  if (v5)
  {
    v33[0] = (void *)mlir::anec::GOC::getBias((mlir::anec::GOC *)&v32);
    v7 = mlir::Value::getDefiningOp((mlir::Value *)v33);
    if (v7)
    {
      v8 = v7;
      v9 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v8 + 48) + 32))(*(_QWORD *)(v8 + 48), v9))
      {
        v35 = v37;
        v36 = 0x100000000;
        mlir::Operation::fold(v8, 0, 0, (uint64_t)&v35);
        v11 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v35 & 0xFFFFFFFFFFFFFFF8));
        if (v11)
          v12 = v10;
        else
          v12 = 0;
        if (v35 != v37)
          free(v35);
        if (v11)
        {
          v13 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v32) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v13)
            goto LABEL_26;
          v14 = *v13;
          v15 = mlir::TypeID::get<mlir::ShapedType>();
          v16 = *(unsigned int *)(v14 + 16);
          if (!(_DWORD)v16)
            goto LABEL_26;
          v17 = *(_QWORD **)(v14 + 8);
          v18 = &v17[2 * v16];
          do
          {
            v19 = v16 >> 1;
            v20 = &v17[2 * (v16 >> 1)];
            v22 = *v20;
            v21 = v20 + 2;
            v16 += ~(v16 >> 1);
            if (v22 < v15)
              v17 = v21;
            else
              v16 = v19;
          }
          while (v16);
          if (v17 != v18 && *v17 == v15)
            v23 = v17[1];
          else
LABEL_26:
            v23 = 0;
          v31[0] = v13;
          v31[1] = v23;
          v35 = v37;
          v36 = 0x100000000;
          mlir::getIntValues<long long>(v5, v6, (uint64_t)&v35, 1);
          v33[0] = &v34;
          v33[1] = (void *)0x100000000;
          mlir::getIntValues<long long>((uint64_t)v11, v12, (uint64_t)v33, 1);
          v24 = *(_QWORD *)v33[0];
          v25 = v36;
          if (v36 >= HIDWORD(v36))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v37, v36 + 1, 8);
            v25 = v36;
          }
          *((_QWORD *)v35 + v25) = v24;
          LODWORD(v36) = v36 + 1;
          std::__sort<std::__less<long long,long long> &,long long *>();
          if (*(_QWORD *)v35 == -2 && *((_QWORD *)v35 + 1) == -1)
          {
            v5 = 1;
          }
          else if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31)
                 && (v26 = *(_QWORD *)v35,
                     mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v31),
                     v26 == v27 - 2))
          {
            v28 = *((_QWORD *)v35 + 1);
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v31);
            v5 = v28 == v29 - 1;
          }
          else
          {
            v5 = 0;
          }
          if (v33[0] != &v34)
            free(v33[0]);
          if (v35 != v37)
            free(v35);
          return v5;
        }
      }
    }
    return 0;
  }
  return v5;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value,mlir::Value,BOOL,BOOL>(mlir::BoolAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5, unsigned __int8 *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matmul", (const unsigned __int8 *)0xA, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.matmul";
    v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::MatMulOp::build(a1, (uint64_t)v23, *a3, *a4, (mlir::MLIRContext *)*a5, (mlir::MLIRContext *)*a6);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::getIntValues<long long>(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unint64_t NumElements;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v8 = a1;
  v9 = a2;
  if (!mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v8) || a4)
    NumElements = mlir::ElementsAttr::getNumElements(v8, v9);
  else
    NumElements = 1;
  v7 = *(unsigned int *)(a3 + 8);
  if (NumElements != v7)
  {
    if (NumElements >= v7)
    {
      if (NumElements > *(unsigned int *)(a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), NumElements, 8);
        v7 = *(unsigned int *)(a3 + 8);
      }
      if (NumElements != v7)
        bzero((void *)(*(_QWORD *)a3 + 8 * v7), 8 * (NumElements - v7));
    }
    *(_DWORD *)(a3 + 8) = NumElements;
  }
  mlir::copyElementsAttrData<long long>(v8, v9, *(_QWORD *)a3, a4);
}

void mlir::copyElementsAttrData<long long>(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  _QWORD *Type;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t *v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  unsigned __int8 *ElementsAttrRawData;
  uint64_t v20;
  uint64_t v21;
  int64_t NumElements;
  uint64_t i;
  uint64_t v24;
  uint64_t j;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  uint64_t k;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  uint64_t m;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v67;
  uint64_t *v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  _QWORD *v75;
  int64x2_t v76;
  unint64_t v77;
  unint64_t v78;
  unsigned __int8 *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  _QWORD *v84;
  unsigned int IntOrFloatBitWidth;
  uint64_t v86;
  int64x2_t *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  _QWORD *v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  uint64_t OperandRange;
  _QWORD v108[2];
  uint64_t v109;
  uint64_t v110;
  void *v111[3];
  _QWORD v112[6];

  v112[5] = *MEMORY[0x1E0C80C00];
  v109 = a1;
  v110 = a2;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v109);
  v7 = Type;
  if (!Type)
    goto LABEL_10;
  v8 = *Type;
  v9 = mlir::TypeID::get<mlir::ShapedType>();
  v10 = *(unsigned int *)(v8 + 16);
  if (!(_DWORD)v10)
    goto LABEL_10;
  v11 = *(_QWORD **)(v8 + 8);
  v12 = &v11[2 * v10];
  do
  {
    v13 = v10 >> 1;
    v14 = &v11[2 * (v10 >> 1)];
    v16 = *v14;
    v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9)
      v11 = v15;
    else
      v10 = v13;
  }
  while (v10);
  if (v11 != v12 && *v11 == v9)
    v17 = v11[1];
  else
LABEL_10:
    v17 = 0;
  v108[0] = v7;
  v108[1] = v17;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v108);
  v18 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v109);
  ElementsAttrRawData = (unsigned __int8 *)mlir::getElementsAttrRawData(v109);
  v21 = v20;
  if (!v18 || a4)
  {
    NumElements = mlir::ElementsAttr::getNumElements(v109, v110);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
    {
      if (NumElements < 1)
        return;
      goto LABEL_17;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
    {
      if (NumElements < 1)
        return;
      goto LABEL_28;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
    {
      if (NumElements < 1)
        return;
      if ((unint64_t)NumElements >= 2)
      {
        v28 = 0;
        v27 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18)
            v29 = 0;
          else
            v29 = v28;
          if (v18)
            v30 = 0;
          else
            v30 = v28 + 1;
          v31 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v30];
          v32 = (_QWORD *)(a3 + 8 * v28);
          *v32 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v29];
          v32[1] = v31;
          v28 += 2;
        }
        while (v28 != v27);
        goto LABEL_204;
      }
      goto LABEL_37;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
    {
      if (NumElements < 1)
        return;
      goto LABEL_55;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      if (NumElements < 1)
        return;
      goto LABEL_62;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
    {
      if (NumElements < 1)
        return;
      goto LABEL_78;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      if (NumElements < 1)
        return;
      goto LABEL_94;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
    {
      if (NumElements < 1)
        return;
      goto LABEL_114;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1)
        return;
      goto LABEL_125;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1)
        return;
      goto LABEL_132;
    }
    if (mlir::Type::isF64((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1)
        return;
      goto LABEL_148;
    }
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      if (NumElements < 1)
        return;
LABEL_163:
      if ((unint64_t)NumElements >= 2)
      {
        v86 = 0;
        v77 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        v87 = (int64x2_t *)a3;
        do
        {
          if (v18)
            v88 = 0;
          else
            v88 = v86;
          if (v18)
            v89 = 0;
          else
            v89 = v86 + 1;
          v76.i16[0] = *(_WORD *)&ElementsAttrRawData[2 * v88];
          v76.i16[2] = *(_WORD *)&ElementsAttrRawData[2 * v89];
          v76 = vcvtq_s64_f64(vcvtq_f64_f32((float32x2_t)vshl_n_s32(*(int32x2_t *)v76.i8, 0x10uLL)));
          *v87++ = v76;
          v86 += 2;
        }
        while (v86 != v77);
        goto LABEL_246;
      }
      v77 = 0;
      do
      {
        if (v18)
          v105 = 0;
        else
          v105 = v77;
        *(_QWORD *)(a3 + 8 * v77++) = (uint64_t)COERCE_FLOAT(*(unsigned __int16 *)&ElementsAttrRawData[2 * v105] << 16);
LABEL_246:
        ;
      }
      while (NumElements != v77);
      return;
    }
  }
  else
  {
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
    {
      NumElements = 1;
LABEL_17:
      for (i = 0; i != NumElements; ++i)
      {
        if (v18)
          v24 = 0;
        else
          v24 = i;
        *(_QWORD *)(a3 + 8 * i) = ElementsAttrRawData[v24];
      }
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
    {
      NumElements = 1;
LABEL_28:
      for (j = 0; j != NumElements; ++j)
      {
        if (v18)
          v26 = 0;
        else
          v26 = j;
        *(_QWORD *)(a3 + 8 * j) = (char)ElementsAttrRawData[v26];
      }
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
    {
      NumElements = 1;
LABEL_37:
      v27 = 0;
      do
      {
        if (v18)
          v96 = 0;
        else
          v96 = v27;
        *(_QWORD *)(a3 + 8 * v27++) = *(unsigned __int16 *)&ElementsAttrRawData[2 * v96];
LABEL_204:
        ;
      }
      while (NumElements != v27);
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
    {
      NumElements = 1;
LABEL_55:
      if ((unint64_t)NumElements >= 2)
      {
        v35 = 0;
        v33 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18)
            v36 = 0;
          else
            v36 = v35;
          if (v18)
            v37 = 0;
          else
            v37 = v35 + 1;
          v38 = *(__int16 *)&ElementsAttrRawData[2 * v37];
          v39 = (_QWORD *)(a3 + 8 * v35);
          *v39 = *(__int16 *)&ElementsAttrRawData[2 * v36];
          v39[1] = v38;
          v35 += 2;
        }
        while (v35 != v33);
        goto LABEL_210;
      }
      v33 = 0;
      do
      {
        if (v18)
          v97 = 0;
        else
          v97 = v33;
        *(_QWORD *)(a3 + 8 * v33++) = *(__int16 *)&ElementsAttrRawData[2 * v97];
LABEL_210:
        ;
      }
      while (NumElements != v33);
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      NumElements = 1;
LABEL_62:
      if ((unint64_t)NumElements >= 2)
      {
        v41 = 0;
        v34 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18)
            v42 = 0;
          else
            v42 = v41;
          if (v18)
            v43 = 0;
          else
            v43 = v41 + 1;
          v44 = *(unsigned int *)&ElementsAttrRawData[4 * v43];
          v45 = (_QWORD *)(a3 + 8 * v41);
          *v45 = *(unsigned int *)&ElementsAttrRawData[4 * v42];
          v45[1] = v44;
          v41 += 2;
        }
        while (v41 != v34);
        goto LABEL_216;
      }
      v34 = 0;
      do
      {
        if (v18)
          v98 = 0;
        else
          v98 = v34;
        *(_QWORD *)(a3 + 8 * v34++) = *(unsigned int *)&ElementsAttrRawData[4 * v98];
LABEL_216:
        ;
      }
      while (NumElements != v34);
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
    {
      NumElements = 1;
LABEL_78:
      if ((unint64_t)NumElements >= 2)
      {
        v48 = 0;
        v40 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18)
            v49 = 0;
          else
            v49 = v48;
          if (v18)
            v50 = 0;
          else
            v50 = v48 + 1;
          v51 = *(int *)&ElementsAttrRawData[4 * v50];
          v52 = (_QWORD *)(a3 + 8 * v48);
          *v52 = *(int *)&ElementsAttrRawData[4 * v49];
          v52[1] = v51;
          v48 += 2;
        }
        while (v48 != v40);
        goto LABEL_222;
      }
      v40 = 0;
      do
      {
        if (v18)
          v99 = 0;
        else
          v99 = v40;
        *(_QWORD *)(a3 + 8 * v40++) = *(int *)&ElementsAttrRawData[4 * v99];
LABEL_222:
        ;
      }
      while (NumElements != v40);
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      NumElements = 1;
LABEL_94:
      for (k = 0; k != NumElements; ++k)
      {
        if (v18)
          v47 = 0;
        else
          v47 = k;
        *(_QWORD *)(a3 + 8 * k) = *(_QWORD *)&ElementsAttrRawData[8 * v47];
      }
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
    {
      NumElements = 1;
LABEL_114:
      for (m = 0; m != NumElements; ++m)
      {
        if (v18)
          v54 = 0;
        else
          v54 = m;
        *(_QWORD *)(a3 + 8 * m) = *(_QWORD *)&ElementsAttrRawData[8 * v54];
      }
      return;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
    {
      NumElements = 1;
LABEL_125:
      if ((unint64_t)NumElements >= 2)
      {
        v57 = 0;
        v55 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18)
            v58 = 0;
          else
            v58 = v57;
          if (v18)
            v59 = 0;
          else
            v59 = v57 + 1;
          _H0 = *(_WORD *)&ElementsAttrRawData[2 * v58];
          _H1 = *(_WORD *)&ElementsAttrRawData[2 * v59];
          __asm { FCVT            S0, H0 }
          v67 = (uint64_t)_S0;
          __asm { FCVT            S0, H1 }
          v69 = (uint64_t *)(a3 + 8 * v57);
          *v69 = v67;
          v69[1] = (uint64_t)_S0;
          v57 += 2;
        }
        while (v57 != v55);
        goto LABEL_228;
      }
      v55 = 0;
      do
      {
        if (v18)
          v100 = 0;
        else
          v100 = v55;
        _H0 = *(_WORD *)&ElementsAttrRawData[2 * v100];
        __asm { FCVT            S0, H0 }
        *(_QWORD *)(a3 + 8 * v55++) = (uint64_t)_S0;
LABEL_228:
        ;
      }
      while (NumElements != v55);
      return;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      NumElements = 1;
LABEL_132:
      if ((unint64_t)NumElements >= 2)
      {
        v71 = 0;
        v56 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18)
            v72 = 0;
          else
            v72 = v71;
          if (v18)
            v73 = 0;
          else
            v73 = v71 + 1;
          v74 = (uint64_t)*(float *)&ElementsAttrRawData[4 * v73];
          v75 = (_QWORD *)(a3 + 8 * v71);
          *v75 = (uint64_t)*(float *)&ElementsAttrRawData[4 * v72];
          v75[1] = v74;
          v71 += 2;
        }
        while (v71 != v56);
        goto LABEL_234;
      }
      v56 = 0;
      do
      {
        if (v18)
          v103 = 0;
        else
          v103 = v56;
        *(_QWORD *)(a3 + 8 * v56++) = (uint64_t)*(float *)&ElementsAttrRawData[4 * v103];
LABEL_234:
        ;
      }
      while (NumElements != v56);
      return;
    }
    if (mlir::Type::isF64((mlir::Type *)&OperandRange))
    {
      NumElements = 1;
LABEL_148:
      if ((unint64_t)NumElements >= 2)
      {
        v80 = 0;
        v70 = NumElements & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v18)
            v81 = 0;
          else
            v81 = v80;
          if (v18)
            v82 = 0;
          else
            v82 = v80 + 1;
          v83 = (uint64_t)*(double *)&ElementsAttrRawData[8 * v82];
          v84 = (_QWORD *)(a3 + 8 * v80);
          *v84 = (uint64_t)*(double *)&ElementsAttrRawData[8 * v81];
          v84[1] = v83;
          v80 += 2;
        }
        while (v80 != v70);
        goto LABEL_240;
      }
      v70 = 0;
      do
      {
        if (v18)
          v104 = 0;
        else
          v104 = v70;
        *(_QWORD *)(a3 + 8 * v70++) = (uint64_t)*(double *)&ElementsAttrRawData[8 * v104];
LABEL_240:
        ;
      }
      while (NumElements != v70);
      return;
    }
    NumElements = 1;
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange))
      goto LABEL_163;
  }
  if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 1))
  {
    if (v18)
      v78 = 1;
    else
      v78 = NumElements;
    llvm::SmallVector<BOOL,40u>::SmallVector((uint64_t)v111, v78);
    mlir::detail::unpackBooleanData(ElementsAttrRawData, v21, (uint64_t)v111[0], (unint64_t)v111[1]);
    v79 = (unsigned __int8 *)v111[0];
    if (NumElements >= 1)
    {
      if (NumElements == 1)
      {
        v91 = 0;
        goto LABEL_248;
      }
      v90 = 0;
      v91 = NumElements & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        if (v18)
          v92 = 0;
        else
          v92 = v90;
        if (v18)
          v93 = 0;
        else
          v93 = v90 + 1;
        v94 = v79[v93];
        v95 = (_QWORD *)(a3 + 8 * v90);
        *v95 = v79[v92];
        v95[1] = v94;
        v90 += 2;
      }
      while (v90 != v91);
      while (NumElements != v91)
      {
LABEL_248:
        if (v18)
          v106 = 0;
        else
          v106 = v91;
        *(_QWORD *)(a3 + 8 * v91++) = v79[v106];
      }
    }
    if (v79 != (unsigned __int8 *)v112)
      free(v79);
  }
  else
  {
    mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
    IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
    mlir::detail::unpackQuantizedData<long long>(ElementsAttrRawData, v21, a3, NumElements, IntOrFloatBitWidth);
  }
}

unsigned __int8 *mlir::detail::unpackQuantizedData<long long>(unsigned __int8 *result, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  uint64_t v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  unint64_t v12;
  uint64x2_t v13;
  int32x2_t v14;
  uint64_t v15;
  int32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;

  if (a2)
  {
    v5 = 0;
    v6 = ~(-1 << a5);
    v7 = a4;
    v8 = 8 / a5;
    do
    {
      v9 = v5 * v8;
      v10 = a4 - v5 * v8;
      if (v10 >= v8)
        v10 = 8 / a5;
      if (!v10)
        goto LABEL_3;
      v11 = *result;
      if (v7 >= v8)
        v12 = 8 / a5;
      else
        v12 = v7;
      v13 = (uint64x2_t)vdupq_n_s64(v12 - 1);
      v14 = vmovn_s64((int64x2_t)vcgeq_u64(v13, (uint64x2_t)xmmword_181233120));
      if ((v14.i8[0] & 1) != 0)
        *(_QWORD *)(a3 + 8 * v9) = v6 & v11;
      if ((v14.i8[4] & 1) != 0)
        *(_QWORD *)(a3 + 8 * v9 + 8) = (v11 >> a5) & v6;
      v15 = ((_BYTE)v12 + 1) & 0x1E;
      if (v15 == 2)
        goto LABEL_3;
      v16 = vmovn_s64((int64x2_t)vcgtq_u64(v13, (uint64x2_t)xmmword_181233160));
      if ((v16.i8[0] & 1) != 0)
      {
        *(_QWORD *)(a3 + 8 * v9 + 16) = (v11 >> (2 * a5)) & v6;
        if ((v16.i8[4] & 1) != 0)
        {
LABEL_20:
          *(_QWORD *)(a3 + 8 * v9 + 24) = (v11 >> (3 * a5)) & v6;
          if (v15 == 4)
            goto LABEL_3;
          goto LABEL_21;
        }
      }
      else if ((v16.i8[4] & 1) != 0)
      {
        goto LABEL_20;
      }
      if (v15 == 4)
        goto LABEL_3;
LABEL_21:
      v17 = vmovn_s64((int64x2_t)vcgtq_u64(v13, (uint64x2_t)xmmword_181233170));
      if ((v17.i8[0] & 1) != 0)
      {
        *(_QWORD *)(a3 + 8 * v9 + 32) = (v11 >> (4 * a5)) & v6;
        if ((v17.i8[4] & 1) == 0)
        {
LABEL_23:
          if (v15 != 6)
            goto LABEL_27;
          goto LABEL_3;
        }
      }
      else if ((v17.i8[4] & 1) == 0)
      {
        goto LABEL_23;
      }
      *(_QWORD *)(a3 + 8 * v9 + 40) = (v11 >> (5 * a5)) & v6;
      if (v15 != 6)
      {
LABEL_27:
        v18 = vmovn_s64((int64x2_t)vcgtq_u64(v13, (uint64x2_t)xmmword_181233180));
        if ((v18.i8[0] & 1) != 0)
          *(_QWORD *)(a3 + 8 * v9 + 48) = (v11 >> (6 * a5)) & v6;
        if ((v18.i8[4] & 1) != 0)
          *(_QWORD *)(a3 + 8 * v9 + 56) = (v11 >> (7 * a5)) & v6;
      }
LABEL_3:
      ++v5;
      v7 -= v8;
      ++result;
      --a2;
    }
    while (a2);
  }
  return result;
}

void mlir::mps::`anonymous namespace'::ReorderDequantPermute::~ReorderDequantPermute(mlir::mps::_anonymous_namespace_::ReorderDequantPermute *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PermuteOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PermuteOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PermuteOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::ReorderDequantPermute::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD *Value;
  uint64_t v7;
  uint64_t v8;
  uint64_t NumElements;
  uint64_t v10;
  uint64_t PositiveAxis;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t Input;
  mlir::GenericProgramPoint *v21;
  uint64_t FunctionType;
  uint64_t SparseShape;
  uint64_t Bias;
  uint64_t Filter;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28[2];
  mlir::GenericProgramPoint *v29;
  uint64_t v30;
  uint64_t v31;
  mlir::GenericProgramPoint *FastmathAttr;
  void *__p;
  uint64_t v34;
  _QWORD v35[6];

  v35[4] = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 24);
  v30 = 0;
  v31 = 0;
  v28[0] = &v31;
  v28[1] = &v30;
  v29 = 0;
  FastmathAttr = (mlir::GenericProgramPoint *)a2;
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id)
    return 0;
  if ((*(_BYTE *)(a2 + 46) & 0x80) == 0)
    return 0;
  if (*(_DWORD *)(a2 + 68) != 2)
    return 0;
  LOBYTE(v27) = 1;
  __p = &v27;
  v34 = (uint64_t)&FastmathAttr;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::PermuteOp,mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul>(v28, (uint64_t)&__p);
  if (!(_BYTE)v27)
    return 0;
  v29 = FastmathAttr;
  v26 = v30;
  v27 = v31;
  Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v26);
  v8 = v7;
  FastmathAttr = (mlir::GenericProgramPoint *)mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v27);
  if (FastmathAttr)
  {
    NumElements = mlir::ElementsAttr::getNumElements((uint64_t)Value, v8);
    mlir::IntegerAttr::getValue(&FastmathAttr, (llvm::APInt *)&__p);
    if (v34 > 0x40)
    {
      v10 = *(_QWORD *)__p;
      operator delete[](__p);
    }
    else
    {
      v10 = (uint64_t)((_QWORD)__p << -(uint64_t)v34) >> -(uint64_t)v34;
    }
    __p = v35;
    v34 = 0x400000000;
    mlir::getIntValues<long long>((uint64_t)Value, v8, (uint64_t)&__p, 1);
    PositiveAxis = mlir::getPositiveAxis(v10, NumElements);
    if ((_DWORD)v34)
    {
      v12 = PositiveAxis;
      v13 = 0;
      v14 = __p;
      v15 = ((v34 - 1) & 0x1FFFFFFFFFFFFFFFLL) + 1;
      v16 = 8 * v34;
      while (mlir::getPositiveAxis(v14[v13], NumElements) != v12)
      {
        ++v13;
        v16 -= 8;
        if (!v16)
        {
          v13 = v15;
          break;
        }
      }
    }
    else
    {
      v13 = 0;
    }
    v17 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&FastmathAttr);
    v18 = (void *)mlir::IntegerAttr::get(v17, v13);
    if (__p != v35)
      free(__p);
    __p = v18;
    if (v18)
      goto LABEL_22;
  }
  else
  {
    __p = 0;
  }
  if ((mlir::mps::DequantizeOp::hasNDParams((mlir::mps::DequantizeOp *)&v27) & 1) == 0)
  {
LABEL_22:
    Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v27);
    Bias = v30;
    Filter = Input;
    FastmathAttr = mlir::OpBuilder::create<mlir::mps::PermuteOp,mlir::Value,mlir::mps::ConstantOp>((mlir::OpBuilder *)(a3 + 8), v3, &Filter, &Bias);
    Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v27);
    Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v27);
    SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v27);
    FunctionType = mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v27);
    v21 = mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::mps::PermuteOp &,mlir::Value,mlir::Value,mlir::Value,mlir::Type,mlir::IntegerAttr &>((mlir::UnknownLoc **)(a3 + 8), *(_QWORD *)(a2 + 24), &FastmathAttr, &Filter, &Bias, &SparseShape, &FunctionType, (uint64_t *)&__p);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, a2, v21);
    return 1;
  }
  return 0;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::PermuteOp,mlir::Value,mlir::mps::ConstantOp>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.permute", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.permute";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::PermuteOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4 - 16);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::PermuteOp,mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul>(uint64_t **a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t DefiningOp;
  char v6;
  BOOL v7;
  char v8;
  uint64_t *v9;
  uint64_t result;
  char v11;
  char v12;
  uint64_t v13;

  v4 = *a1;
  v13 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v13);
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id
      && (*v4 ? (v7 = *v4 == DefiningOp) : (v7 = 1), v7))
    {
      *v4 = DefiningOp;
      v6 = 1;
    }
    else
    {
      v6 = 0;
    }
  }
  v8 = v6 & (**(_BYTE **)a2 != 0);
  if (!DefiningOp)
    v8 = 0;
  **(_BYTE **)a2 = v8;
  v9 = a1[1];
  v13 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 56);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v13);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v9 || *v9 == result))
    {
      *v9 = result;
      v11 = 1;
    }
    else
    {
      v11 = 0;
    }
  }
  v12 = v11 & (**(_BYTE **)a2 != 0);
  if (!result)
    v12 = 0;
  **(_BYTE **)a2 = v12;
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::mps::PermuteOp &,mlir::Value,mlir::Value,mlir::Value,mlir::Type,mlir::IntegerAttr &>(mlir::UnknownLoc **a1, uint64_t a2, _QWORD *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  uint64_t *Context;
  uint64_t v17;
  char v18;
  mlir::GenericProgramPoint *v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  _QWORD v27[39];

  v27[38] = *MEMORY[0x1E0C80C00];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize", (const unsigned __int8 *)0xE, Context);
  if (!v18)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"mps.dequantize";
    v25[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v27, a2, v17);
  mlir::mps::DequantizeOp::build(a1, (uint64_t)v27, *a3 - 16, *a4, *a5, *a6, *a7, *a8);
  v19 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v27);
  if (*(_UNKNOWN **)(*((_QWORD *)v19 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id)
    v20 = v19;
  else
    v20 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
  return v20;
}

void mlir::mps::`anonymous namespace'::ReorderDequantTranspose::~ReorderDequantTranspose(mlir::mps::_anonymous_namespace_::ReorderDequantTranspose *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::TransposeOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::TransposeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::TransposeOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::ReorderDequantTranspose::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  _QWORD *Value;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t PositiveAxis;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v26;
  mlir::GenericProgramPoint *v27;
  uint64_t FastmathAttr;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32[3];
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *__p;
  unsigned int v38;
  uint64_t v39[2];
  uint64_t v40[2];
  uint64_t FunctionType;
  void *v42;
  uint64_t *v43;
  uint64_t v44;

  v3 = *(_QWORD *)(a2 + 24);
  v35 = 0;
  v36 = 0;
  v33 = 0;
  v34 = 0;
  v32[0] = &v36;
  v32[1] = &v35;
  v32[2] = &v34;
  v40[0] = a2;
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id
    && (*(_BYTE *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 3)
  {
    LOBYTE(v39[0]) = 1;
    v42 = v39;
    v43 = v40;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::TransposeOp,mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul,2ul>(v32, (uint64_t)&v42);
    if (LOBYTE(v39[0]))
    {
      v33 = v40[0];
      v30 = v34;
      v31 = v35;
      v29 = v36;
      if (mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v29)
        || (mlir::mps::DequantizeOp::hasNDParams((mlir::mps::DequantizeOp *)&v29) & 1) == 0)
      {
        FastmathAttr = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v29);
        if (!FastmathAttr)
        {
LABEL_53:
          v40[0] = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v29);
          v42 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(a3 + 1, v3, v40, &v31, &v30);
          v40[0] = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v29);
          v39[0] = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v29);
          __p = (void *)mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v29);
          FunctionType = mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v29);
          v27 = mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::mps::PermuteOp &,mlir::Value,mlir::Value,mlir::Value,mlir::Type,mlir::IntegerAttr &>(a3 + 1, *(_QWORD *)(a2 + 24), &v42, v40, v39, (uint64_t *)&__p, &FunctionType, &FastmathAttr);
          (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, a2, v27);
          return 1;
        }
        v6 = *(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v29) + 8);
        v7 = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v29);
        Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v31);
        v10 = v9;
        v11 = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v30);
        v40[1] = v10;
        FunctionType = v7;
        v40[0] = (uint64_t)Value;
        v39[0] = (uint64_t)v11;
        v39[1] = v12;
        mlir::IntegerAttr::getValue(&FunctionType, (llvm::APInt *)&v42);
        if (v43 > 0x40)
        {
          PositiveAxis = *(_QWORD *)v42;
          operator delete[](v42);
        }
        else
        {
          PositiveAxis = (uint64_t)((_QWORD)v42 << -(char)v43) >> -(char)v43;
        }
        mlir::ElementsAttr::value_begin<llvm::APInt>((mlir::BranchOpInterface *)v40, (uint64_t)&v42);
        if (BYTE1(v42))
          v14 = 0;
        else
          v14 = v44;
        if ((_BYTE)v42)
        {
          v15 = &v43[2 * v14];
          v38 = *((_DWORD *)v15 + 2);
          if (v38 > 0x40)
            llvm::APInt::initSlowCase((llvm::APInt *)&__p, (const void **)v15);
          else
            __p = (void *)*v15;
        }
        else
        {
          (*(void (**)(void **__return_ptr))(*v43 + 24))(&__p);
        }
        if (!(_BYTE)v42)
        {
          v16 = v43;
          v43 = 0;
          if (v16)
            (*(void (**)(uint64_t *))(*v16 + 8))(v16);
        }
        if (v38 > 0x40)
        {
          v17 = *(_QWORD *)__p;
          operator delete[](__p);
        }
        else
        {
          v17 = (uint64_t)((_QWORD)__p << -(uint64_t)v38) >> -(uint64_t)v38;
        }
        mlir::ElementsAttr::value_begin<llvm::APInt>((mlir::BranchOpInterface *)v39, (uint64_t)&v42);
        if (BYTE1(v42))
          v18 = 0;
        else
          v18 = v44;
        if ((_BYTE)v42)
        {
          v19 = &v43[2 * v18];
          v38 = *((_DWORD *)v19 + 2);
          if (v38 > 0x40)
            llvm::APInt::initSlowCase((llvm::APInt *)&__p, (const void **)v19);
          else
            __p = (void *)*v19;
        }
        else
        {
          (*(void (**)(void **__return_ptr))(*v43 + 24))(&__p);
        }
        if (!(_BYTE)v42)
        {
          v20 = v43;
          v43 = 0;
          if (v20)
            (*(void (**)(uint64_t *))(*v20 + 8))(v20);
        }
        if (v38 > 0x40)
        {
          v21 = *(_QWORD *)__p;
          operator delete[](__p);
        }
        else
        {
          v21 = (uint64_t)((_QWORD)__p << -(uint64_t)v38) >> -(uint64_t)v38;
        }
        if (((v17 ^ PositiveAxis) & 0x8000000000000000) == 0 && ((v21 ^ PositiveAxis) & 0x8000000000000000) == 0)
        {
LABEL_44:
          if (PositiveAxis == v17 || PositiveAxis == v21)
          {
            if (PositiveAxis == v17)
              v26 = v39;
            else
              v26 = v40;
            FastmathAttr = mlir::ElementsAttr::getSplatValue<mlir::IntegerAttr>((mlir::CallOpInterface *)v26);
          }
          else
          {
            FastmathAttr = FunctionType;
          }
          goto LABEL_53;
        }
        v42 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(v6 & 0xFFFFFFFFFFFFFFF8));
        v43 = v22;
        if (v42 && mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v42))
        {
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v42);
          v24 = v23;
          PositiveAxis = mlir::getPositiveAxis(PositiveAxis, v23);
          v17 = mlir::getPositiveAxis(v17, v24);
          v21 = mlir::getPositiveAxis(v21, v24);
          goto LABEL_44;
        }
      }
    }
  }
  return 0;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.transpose";
    v19[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::TransposeOp::build(a1, (uint64_t)v21, *a3, *a4 - 16, *a5 - 16);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::TransposeOp,mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::op_matcher_with_bind<mlir::mps::DequantizeOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul,2ul>(uint64_t **a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t DefiningOp;
  char v6;
  BOOL v7;
  char v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;
  char v12;
  uint64_t *v13;
  uint64_t result;
  char v15;
  char v16;
  uint64_t v17;

  v4 = *a1;
  v17 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v17);
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id
      && (*v4 ? (v7 = *v4 == DefiningOp) : (v7 = 1), v7))
    {
      *v4 = DefiningOp;
      v6 = 1;
    }
    else
    {
      v6 = 0;
    }
  }
  v8 = v6 & (**(_BYTE **)a2 != 0);
  if (!DefiningOp)
    v8 = 0;
  **(_BYTE **)a2 = v8;
  v9 = a1[1];
  v17 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 56);
  v10 = mlir::Value::getDefiningOp((mlir::Value *)&v17);
  if (v10)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(v10 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v9 || *v9 == v10))
    {
      *v9 = v10;
      v11 = 1;
    }
    else
    {
      v11 = 0;
    }
  }
  v12 = v11 & (**(_BYTE **)a2 != 0);
  if (!v10)
    v12 = 0;
  **(_BYTE **)a2 = v12;
  v13 = a1[2];
  v17 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 88);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v17);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v13 || *v13 == result))
    {
      *v13 = result;
      v15 = 1;
    }
    else
    {
      v15 = 0;
    }
  }
  v16 = v15 & (**(_BYTE **)a2 != 0);
  if (!result)
    v16 = 0;
  **(_BYTE **)a2 = v16;
  return result;
}

uint64_t mlir::ElementsAttr::getSplatValue<mlir::IntegerAttr>(mlir::CallOpInterface *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v8;
  char v9;
  uint64_t v10;
  __int128 v11;
  _BYTE v12[8];
  uint64_t v13;
  __int128 v14;
  char v15;
  uint64_t v16;

  mlir::ElementsAttr::getValues<mlir::IntegerAttr,void>(a1, (uint64_t)v12);
  v8 = v12[0];
  v9 = v12[1];
  if (v12[0])
    v10 = v13;
  else
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v13 + 16))(&v10);
  v11 = v14;
  if (!v15)
  {
    v1 = v16;
    v16 = 0;
    if (v1)
      (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  }
  if (!v12[0])
  {
    v2 = v13;
    v13 = 0;
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  }
  if (v9)
    v3 = 0;
  else
    v3 = v11;
  if (v8)
    v4 = *(_QWORD *)(v10 + 8 * v3);
  else
    v4 = (*(uint64_t (**)(void))(*(_QWORD *)v10 + 24))();
  v5 = (*((uint64_t (**)(uint64_t))&v11 + 1))(v4);
  if (!v8)
  {
    v6 = v10;
    v10 = 0;
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  }
  return v5;
}

uint64_t mlir::ElementsAttr::value_begin<llvm::APInt>@<X0>(mlir::BranchOpInterface *a1@<X0>, uint64_t a2@<X8>)
{
  void *v4;
  uint64_t result;
  char v6;
  uint64_t v7;
  char v8;
  _BYTE v9[8];
  uint64_t v10;
  char v11;

  v4 = mlir::TypeID::get<llvm::APInt>();
  result = mlir::BranchOpInterface::getSuccessorOperands(a1, (uint64_t)v4);
  if (!v11)
    mlir::ElementsAttr::value_begin<llvm::APInt>((llvm *)v9, (uint64_t *)a1);
  v6 = v9[1];
  if (v9[0])
  {
    v7 = v10;
    v8 = 1;
  }
  else
  {
    v8 = 0;
    v7 = v10;
  }
  *(_BYTE *)a2 = v8;
  *(_BYTE *)(a2 + 1) = v6;
  *(_QWORD *)(a2 + 8) = v7;
  *(_QWORD *)(a2 + 16) = 0;
  return result;
}

const char *llvm::getTypeName<llvm::APInt>()
{
  unint64_t v0;
  unint64_t v1;
  const char *v2;
  uint64_t v3;
  const char *v5;
  unint64_t v6;

  v5 = "StringRef llvm::getTypeName() [DesiredTypeName = llvm::APInt]";
  v6 = 61;
  v0 = llvm::StringRef::find((uint64_t *)&v5, "DesiredTypeName = ", 0x12uLL, 0);
  if (v6 >= v0)
    v1 = v0;
  else
    v1 = v6;
  v2 = &v5[v1];
  if (v6 - v1 >= 0x12)
    v3 = 18;
  else
    v3 = v6 - v1;
  return &v2[v3];
}

void *mlir::TypeID::get<llvm::APInt>()
{
  unsigned __int8 v0;
  void **p_vtable;
  int v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v0 & 1) == 0)
  {
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    if (v3)
    {
      v11 = "StringRef llvm::getTypeName() [DesiredTypeName = llvm::APInt]";
      v12 = 61;
      v4 = llvm::StringRef::find((uint64_t *)&v11, "DesiredTypeName = ", 0x12uLL, 0);
      if (v12 >= v4)
        v5 = v4;
      else
        v5 = v12;
      v6 = &v11[v5];
      v7 = v12 - v5;
      if (v12 - v5 >= 0x12)
        v8 = 18;
      else
        v8 = v12 - v5;
      v9 = v7 - v8;
      if (v9 >= v9 - 1)
        v10 = v9 - 1;
      else
        v10 = v9;
      mlir::detail::TypeIDResolver<llvm::APInt,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v6[v8], v10);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    }
  }
  return p_vtable[479];
}

uint64_t mlir::ElementsAttr::getValues<mlir::IntegerAttr,void>@<X0>(mlir::CallOpInterface *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t ArgOperands;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  int v8;
  int v9;
  int v10;
  char v11[8];
  uint64_t v12;
  char v13;
  uint64_t v14;
  _BYTE v15[8];
  uint64_t v16;
  __int128 v17;
  unsigned __int8 v18;
  char v19;
  _BYTE v20[24];

  ArgOperands = mlir::CallOpInterface::getArgOperands(a1);
  v6 = v5;
  mlir::ElementsAttr::getValues<mlir::Attribute>((uint64_t *)a1, (uint64_t)v11);
  result = llvm::map_range<mlir::detail::ElementsAttrRange<mlir::detail::ElementsAttrIterator<mlir::Attribute>>,mlir::TypedAttr (*)(mlir::Attribute)>(v11, (uint64_t)_ZZNK4mlir12ElementsAttr9getValuesINS_11IntegerAttrEvEENS_6detail17ElementsAttrRangeIN4llvm15mapped_iteratorINS3_20ElementsAttrIteratorINS_9AttributeEEEPFT_S8_EDTclclsr3stdE7declvalISC_EEdeclL_ZNSt3__17declvalB8nn180100IS9_EEDTclsr3stdE9__declvalISA_ELi0EEEvEEEEEEEEvENUlS8_E_8__invokeES8_, (uint64_t)v15);
  v8 = v15[0];
  *(_BYTE *)a2 = v15[0];
  *(_BYTE *)(a2 + 1) = v15[1];
  if (v8)
    *(_QWORD *)(a2 + 8) = v16;
  else
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 16))(v16);
  *(_OWORD *)(a2 + 16) = v17;
  v9 = v18;
  *(_BYTE *)(a2 + 32) = v18;
  *(_BYTE *)(a2 + 33) = v19;
  if (v9)
  {
    *(_OWORD *)(a2 + 40) = *(_OWORD *)v20;
    *(_QWORD *)(a2 + 56) = *(_QWORD *)&v20[16];
    *(_QWORD *)(a2 + 64) = ArgOperands;
    *(_QWORD *)(a2 + 72) = v6;
  }
  else
  {
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v20 + 16))(*(_QWORD *)v20);
    v10 = v18;
    *(_OWORD *)(a2 + 48) = *(_OWORD *)&v20[8];
    *(_QWORD *)(a2 + 64) = ArgOperands;
    *(_QWORD *)(a2 + 72) = v6;
    if (!v10)
    {
      result = *(_QWORD *)v20;
      *(_QWORD *)v20 = 0;
      if (result)
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
    }
  }
  if (!v15[0])
  {
    result = v16;
    v16 = 0;
    if (result)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  if (!v13)
  {
    result = v14;
    v14 = 0;
    if (result)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  if (!v11[0])
  {
    result = v12;
    v12 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

void mlir::mps::`anonymous namespace'::DivByConstant::~DivByConstant(mlir::mps::_anonymous_namespace_::DivByConstant *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::DivideOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::DivideOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::DivideOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::DivByConstant::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  void *v6;
  uint64_t DefiningOp;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  llvm::APFloatBase *v12;
  int v13;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  unint64_t v30;
  unint64_t *v31;
  _QWORD *v32;
  unint64_t v33;
  uint64_t v34;
  unsigned int IntOrFloatBitWidth;
  void *v36;
  mlir::GenericProgramPoint *v37;
  uint64_t v38;
  uint64_t *DenseElementsAttrOf;
  llvm::APFloatBase *v40;
  void *__p;
  uint64_t v42;
  uint64_t OperandRange;
  void *ElementTypeOrSelf;
  uint64_t v45;
  _QWORD v46[2];

  v46[1] = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id)
    return 0;
  if ((*(_BYTE *)(a2 + 46) & 0x80) == 0)
    return 0;
  if (*(_DWORD *)(a2 + 68) != 2)
    return 0;
  v5 = *(_QWORD *)(a2 + 72);
  v6 = *(void **)(v5 + 24);
  ElementTypeOrSelf = *(void **)(v5 + 56);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ElementTypeOrSelf);
  if (!DefiningOp)
    return 0;
  v8 = DefiningOp;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
    return 0;
  ElementTypeOrSelf = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(DefiningOp - 8) & 0xFFFFFFFFFFFFFFF8));
  if (!mlir::Type::isF32((mlir::Type *)&ElementTypeOrSelf))
    return 0;
  __p = (void *)mlir::getElementTypeOrSelf((uint64_t)v6);
  if (!mlir::Type::isF32((mlir::Type *)&__p))
    return 0;
  v9 = *(_QWORD *)(a2 + 24);
  v38 = v8;
  ElementTypeOrSelf = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v38);
  v45 = v10;
  __p = (void *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&ElementTypeOrSelf);
  v42 = v11;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&__p);
  v12 = (llvm::APFloatBase *)mlir::RankedTensorType::get(0, 0, OperandRange, 0);
  DenseElementsAttrOf = 0;
  v40 = v12;
  if (mlir::Type::isIntOrIndex((mlir::Type *)&OperandRange))
  {
    v13 = mlir::Type::isSignedInteger((mlir::Type *)&OperandRange)
       || mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange);
    if (!v12)
      goto LABEL_34;
    v25 = *(_QWORD *)v12;
    v26 = mlir::TypeID::get<mlir::ShapedType>();
    v27 = *(unsigned int *)(v25 + 16);
    if (!(_DWORD)v27)
      goto LABEL_34;
    v28 = *(_QWORD **)(v25 + 8);
    v29 = &v28[2 * v27];
    do
    {
      v30 = v27 >> 1;
      v31 = &v28[2 * (v27 >> 1)];
      v33 = *v31;
      v32 = v31 + 2;
      v27 += ~(v27 >> 1);
      if (v33 < v26)
        v28 = v32;
      else
        v27 = v30;
    }
    while (v27);
    if (v28 != v29 && *v28 == v26)
      v34 = v28[1];
    else
LABEL_34:
      v34 = 0;
    __p = (void *)mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v40);
    IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&__p);
    LODWORD(v42) = IntOrFloatBitWidth;
    if (IntOrFloatBitWidth > 0x40)
      llvm::APInt::initSlowCase((llvm::APInt *)&__p, 1, v13);
    else
      __p = (void *)(IntOrFloatBitWidth != 0);
    DenseElementsAttrOf = (uint64_t *)mlir::DenseElementsAttr::get((uint64_t)v12, v34, (llvm::APInt *)&__p, 1);
    if (v42 >= 0x41 && __p)
      operator delete[](__p);
  }
  else
  {
    if (!v12)
      goto LABEL_22;
    v15 = *(_QWORD *)v12;
    v16 = mlir::TypeID::get<mlir::ShapedType>();
    v17 = *(unsigned int *)(v15 + 16);
    if (!(_DWORD)v17)
      goto LABEL_22;
    v18 = *(_QWORD **)(v15 + 8);
    v19 = &v18[2 * v17];
    do
    {
      v20 = v17 >> 1;
      v21 = &v18[2 * (v17 >> 1)];
      v23 = *v21;
      v22 = v21 + 2;
      v17 += ~(v17 >> 1);
      if (v23 < v16)
        v18 = v22;
      else
        v17 = v20;
    }
    while (v17);
    if (v18 != v19 && *v18 == v16)
      v24 = v18[1];
    else
LABEL_22:
      v24 = 0;
    DenseElementsAttrOf = (uint64_t *)mlir::createDenseElementsAttrOfType<float>(v12, v24, 1.0);
  }
  __p = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 8), v9, &DenseElementsAttrOf);
  __p = (void *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&__p);
  OperandRange = v8;
  ElementTypeOrSelf = v46;
  v45 = 0x100000000;
  mlir::OpBuilder::createOrFold<mlir::mps::DivideOp,mlir::Value,mlir::mps::ConstantOp>(a3 + 8, (uint64_t)&ElementTypeOrSelf, v9, (uint64_t *)&__p, &OperandRange);
  v36 = *(void **)ElementTypeOrSelf;
  if (ElementTypeOrSelf != v46)
    free(ElementTypeOrSelf);
  ElementTypeOrSelf = v36;
  __p = v6;
  v37 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&__p, (uint64_t *)&ElementTypeOrSelf);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, a2, v37);
  return 1;
}

void mlir::OpBuilder::createOrFold<mlir::mps::DivideOp,mlir::Value,mlir::mps::ConstantOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, _QWORD *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  const mlir::OperationState *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x1E0C80C00];
  v20 = a3;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.divide", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.divide";
    v23[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a3, v11);
  mlir::mps::ATan2Op::build((mlir::Float32Type **)a1, (uint64_t)v25, *a4, *a5 - 16);
  v14 = (mlir::GenericProgramPoint *)mlir::Operation::create((mlir::Operation *)v25, v13);
  v15 = *(_QWORD *)(a1 + 16);
  if (v15)
  {
    v16 = *(uint64_t **)(a1 + 24);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v15 + 32, (uint64_t)v14);
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
    v17 = *v16;
    *v18 = *v16;
    v18[1] = (uint64_t)v16;
    *(_QWORD *)(v17 + 8) = v18;
    *v16 = (uint64_t)v18;
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
  }
  if (mlir::OpBuilder::tryFold((_QWORD *)a1, (uint64_t)v14, a2))
  {
    mlir::Operation::erase(v14);
  }
  else
  {
    v19 = *(_QWORD *)(a1 + 8);
    if (v19)
      (*(void (**)(uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)v19 + 16))(v19, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
}

llvm::APFloatBase *mlir::createDenseElementsAttrOfType<float>(llvm::APFloatBase *a1, uint64_t a2, float a3)
{
  llvm::APFloatBase *v4;
  void *v5;
  llvm::APFloatBase *v6;
  void *v7;
  llvm::APFloatBase *v8;
  uint64_t v9;
  llvm::APFloatBase *v10;
  uint64_t v11;
  llvm::APFloatBase *v12;
  void *v13;
  llvm::APFloatBase *v14;
  void *v15;
  char v17;
  llvm::APFloatBase *v18;
  uint64_t v19;
  _BYTE v20[24];
  uint64_t OperandRange;
  _QWORD v22[4];

  v22[3] = *MEMORY[0x1E0C80C00];
  v18 = a1;
  v19 = a2;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v18);
  if (mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    v17 = 0;
    v4 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v20, a3);
    v5 = llvm::APFloatBase::IEEEsingle(v4);
    llvm::APFloat::Storage::Storage(v22, v20, v5);
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v20);
    v7 = llvm::APFloatBase::IEEEhalf(v6);
    llvm::APFloat::convert((uint64_t)&OperandRange, v7, 1, &v17);
    v8 = v18;
    v9 = v19;
  }
  else
  {
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v18);
    if (!mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v18);
      mlir::Type::isIntOrIndex((mlir::Type *)&OperandRange);
      return 0;
    }
    v10 = v18;
    v11 = v19;
    v12 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v20, a3);
    v13 = llvm::APFloatBase::IEEEsingle(v12);
    llvm::APFloat::Storage::Storage(v22, v20, v13);
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v20);
    v8 = v10;
    v9 = v11;
  }
  v14 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get(v8, v9, (uint64_t)&OperandRange, 1);
  v15 = (void *)v22[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v14) == v15)
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v22);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v22);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.multiply";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::`anonymous namespace'::AddSubConsts::~AddSubConsts(mlir::mps::_anonymous_namespace_::AddSubConsts *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::AddOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::AddOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::AddOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::AddSubConsts::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  int v5;
  uint64_t result;
  int v7;
  uint64_t v8;
  void *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13[3];
  uint64_t v14;
  uint64_t v15;
  void *v16[2];
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  v14 = 0;
  v15 = 0;
  v13[0] = &v15;
  v13[1] = &v14;
  v13[2] = 0;
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id
    || (*(_BYTE *)(a2 + 46) & 0x80) == 0
    || *(_DWORD *)(a2 + 68) != 2)
  {
    return 0;
  }
  v5 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(a2, 0, v13);
  v16[0] = *(void **)(*(_QWORD *)(a2 + 72) + 56);
  result = mlir::Value::getDefiningOp((mlir::Value *)v16);
  if (!result)
    return result;
  v7 = *(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
     ? v5
     : 0;
  if (v7 != 1)
    return 0;
  v8 = *(_QWORD *)(a2 + 24);
  v11 = v14;
  v12 = result;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  mlir::OpBuilder::createOrFold<mlir::mps::SubtractOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp>((uint64_t)(a3 + 1), (uint64_t)v16, v8, &v12, &v11);
  v9 = *(void **)v16[0];
  if (v16[0] != v17)
    free(v16[0]);
  v16[0] = v9;
  v12 = v15;
  v10 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 1, *(_QWORD *)(a2 + 24), &v12, (uint64_t *)v16);
  (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, a2, v10);
  return 1;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  uint64_t DefiningOp;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v14;

  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v14);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id
      || (*(_BYTE *)(DefiningOp + 46) & 0x80) == 0
      || *(_DWORD *)(DefiningOp + 68) != 2)
    {
      goto LABEL_15;
    }
    v7 = *(_QWORD *)(DefiningOp + 72);
    v8 = *(_QWORD *)(v7 + 24);
    v9 = **a3;
    if (v9)
    {
      v10 = v9 == v8;
    }
    else
    {
      **a3 = v8;
      v7 = *(_QWORD *)(DefiningOp + 72);
      v10 = 1;
    }
    if ((v11 = a3[1], v14 = *(_QWORD *)(v7 + 56), (v12 = mlir::Value::getDefiningOp((mlir::Value *)&v14)) != 0)
      && *(_UNKNOWN **)(*(_QWORD *)(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v11 || *v11 == v12)
      && (*v11 = v12, v10))
    {
      a3[2] = (uint64_t *)v6;
      v5 = 1;
    }
    else
    {
LABEL_15:
      v5 = 0;
    }
  }
  return (v6 != 0) & v5;
}

void mlir::OpBuilder::createOrFold<mlir::mps::SubtractOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp>(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  const mlir::OperationState *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x1E0C80C00];
  v20 = a3;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.subtract", (const unsigned __int8 *)0xC, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.subtract";
    v23[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a3, v11);
  mlir::mps::ATan2Op::build((mlir::Float32Type **)a1, (uint64_t)v25, *a4 - 16, *a5 - 16);
  v14 = (mlir::GenericProgramPoint *)mlir::Operation::create((mlir::Operation *)v25, v13);
  v15 = *(_QWORD *)(a1 + 16);
  if (v15)
  {
    v16 = *(uint64_t **)(a1 + 24);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v15 + 32, (uint64_t)v14);
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
    v17 = *v16;
    *v18 = *v16;
    v18[1] = (uint64_t)v16;
    *(_QWORD *)(v17 + 8) = v18;
    *v16 = (uint64_t)v18;
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
  }
  if (mlir::OpBuilder::tryFold((_QWORD *)a1, (uint64_t)v14, a2))
  {
    mlir::Operation::erase(v14);
  }
  else
  {
    v19 = *(_QWORD *)(a1 + 8);
    if (v19)
      (*(void (**)(uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)v19 + 16))(v19, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.add";
    v17[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::`anonymous namespace'::CanonicalizeInstanceNorm::~CanonicalizeInstanceNorm(mlir::mps::_anonymous_namespace_::CanonicalizeInstanceNorm *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::NormalizationOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::NormalizationOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::NormalizationOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeInstanceNorm::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  uint64_t v5;
  void *v6;
  uint64_t v8;
  uint64_t v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13[5];
  llvm::APFloatBase *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[2];
  llvm::APFloatBase *v18;
  _QWORD v19[3];
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  llvm::APFloatBase *v23;
  mlir::GenericProgramPoint *v24;
  _QWORD v25[4];

  v25[3] = *MEMORY[0x1E0C80C00];
  v21 = 0;
  v22 = a2;
  v20 = 0;
  v19[0] = &v21;
  v19[1] = &v20;
  v19[2] = 0;
  v17[0] = &v21;
  v17[1] = &v20;
  v18 = 0;
  v15 = 0;
  v16 = 0;
  v13[0] = &v21;
  v13[1] = v19;
  v13[2] = v17;
  v13[3] = &v16;
  v13[4] = &v15;
  v14 = 0;
  v23 = (llvm::APFloatBase *)a2;
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::NormalizationOp,void>::id)
    return 0;
  if ((*(_BYTE *)(a2 + 46) & 0x80) == 0)
    return 0;
  if (*(_DWORD *)(a2 + 68) != 5)
    return 0;
  LOBYTE(v12) = 1;
  v24 = (mlir::GenericProgramPoint *)&v12;
  v25[0] = &v23;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionVarianceOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::NormalizationOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionVarianceOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionVarianceOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> & *)#1},0ul,1ul,2ul,3ul,4ul>(v13, (uint64_t)&v24);
  if (!(_BYTE)v12)
    return 0;
  v14 = v23;
  v24 = v18;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v24))
    return 0;
  v23 = v18;
  if (!mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v23))
    return 0;
  v5 = *(_QWORD *)(a2 + 24);
  v11 = v20;
  v12 = v21;
  mlir::mps::InstanceNormOp::getEpsilon((mlir::mps::InstanceNormOp *)&v22, (uint64_t)&v24);
  v23 = mlir::OpBuilder::create<mlir::mps::InstanceNormOp,mlir::Value,mlir::Value,llvm::APFloat>(a3 + 1, v5, &v12, &v11, (uint64_t)&v24);
  v6 = (void *)v25[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v23) == v6)
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v25);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v25);
  v8 = *(_QWORD *)(v22 + 24);
  v12 = v16;
  v24 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::InstanceNormOp &,mlir::Value>(a3 + 1, v8, &v23, &v12);
  v9 = v22;
  v12 = v15;
  v10 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::MultiplyOp &,mlir::Value>(a3 + 1, *(_QWORD *)(v22 + 24), &v24, &v12);
  (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, v9, v10);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::InstanceNormOp,mlir::Value,mlir::Value,llvm::APFloat>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  void *v16;
  llvm::APFloatBase *v17;
  void *v18;
  mlir::GenericProgramPoint *v19;
  mlir::GenericProgramPoint *v20;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  char v27[8];
  _QWORD v28[3];
  _QWORD v29[39];

  v29[38] = *MEMORY[0x1E0C80C00];
  v22 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.instance_norm", (const unsigned __int8 *)0x11, Context);
  if (!v12)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"mps.instance_norm";
    v25[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v11);
  v13 = *a3;
  v14 = *a4;
  v16 = *(void **)(a5 + 8);
  v15 = (_QWORD *)(a5 + 8);
  v18 = llvm::APFloatBase::PPCDoubleDouble(v17);
  if (v18 == v16)
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v28, v15);
  else
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v28, (uint64_t)v15);
  mlir::mps::InstanceNormOp::build(a1, (uint64_t)v29, v13, v14, (uint64_t)v27);
  if (v18 == (void *)v28[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v28);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v28);
  v19 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((_QWORD *)v19 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::InstanceNormOp,void>::id)
    v20 = v19;
  else
    v20 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v20;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::InstanceNormOp &,mlir::Value>(mlir::Float32Type **a1, uint64_t a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.multiply";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3 - 16, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionVarianceOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::NormalizationOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionVarianceOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMeanOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionVarianceOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> & *)#1},0ul,1ul,2ul,3ul,4ul>(uint64_t **a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t **v8;
  uint64_t DefiningOp;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _BOOL4 v14;
  uint64_t *v15;
  uint64_t v16;
  _BOOL4 v17;
  char v18;
  uint64_t **v19;
  uint64_t result;
  char v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _BOOL4 v25;
  uint64_t *v26;
  uint64_t v27;
  _BOOL4 v28;
  BOOL *v29;
  BOOL v30;
  BOOL v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  BOOL v35;
  BOOL v36;
  uint64_t *v37;
  uint64_t v38;
  BOOL v39;
  uint64_t v40;

  v4 = *(_QWORD *)(**(_QWORD **)(a2 + 8) + 72);
  v5 = *(_QWORD *)(v4 + 24);
  v6 = **a1;
  if (v6)
  {
    v7 = v6 == v5;
  }
  else
  {
    **a1 = v5;
    v4 = *(_QWORD *)(**(_QWORD **)(a2 + 8) + 72);
    v7 = 1;
  }
  if (!**(_BYTE **)a2)
    v7 = 0;
  **(_BYTE **)a2 = v7;
  v8 = (uint64_t **)a1[1];
  v40 = *(_QWORD *)(v4 + 56);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v40);
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReductionMeanOp,void>::id
      || (*(_BYTE *)(DefiningOp + 46) & 0x80) == 0
      || *(_DWORD *)(DefiningOp + 68) != 2)
    {
      goto LABEL_19;
    }
    v11 = *(_QWORD *)(DefiningOp + 72);
    v12 = *(_QWORD *)(v11 + 24);
    v13 = **v8;
    if (v13)
    {
      v14 = v13 == v12;
    }
    else
    {
      **v8 = v12;
      v11 = *(_QWORD *)(DefiningOp + 72);
      v14 = 1;
    }
    v15 = v8[1];
    v16 = *(_QWORD *)(v11 + 56);
    if (*v15)
    {
      v17 = *v15 == v16;
    }
    else
    {
      *v15 = v16;
      v17 = 1;
    }
    v10 = v14 && v17;
    if (v10 == 1)
      v8[2] = (uint64_t *)DefiningOp;
    else
LABEL_19:
      LOBYTE(v10) = 0;
  }
  v18 = v10 & (**(_BYTE **)a2 != 0);
  if (!DefiningOp)
    v18 = 0;
  **(_BYTE **)a2 = v18;
  v19 = (uint64_t **)a1[2];
  v40 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 88);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v40);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReductionVarianceOp,void>::id
      || (*(_BYTE *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 2)
    {
      goto LABEL_35;
    }
    v22 = *(_QWORD *)(result + 72);
    v23 = *(_QWORD *)(v22 + 24);
    v24 = **v19;
    if (v24)
    {
      v25 = v24 == v23;
    }
    else
    {
      **v19 = v23;
      v22 = *(_QWORD *)(result + 72);
      v25 = 1;
    }
    v26 = v19[1];
    v27 = *(_QWORD *)(v22 + 56);
    if (*v26)
    {
      v28 = *v26 == v27;
    }
    else
    {
      *v26 = v27;
      v28 = 1;
    }
    if (v25 && v28)
    {
      v19[2] = (uint64_t *)result;
      v21 = 1;
    }
    else
    {
LABEL_35:
      v21 = 0;
    }
  }
  v29 = *(BOOL **)a2;
  v30 = v21 & (**(_BYTE **)a2 != 0);
  if (result)
    v31 = v30;
  else
    v31 = 0;
  *v29 = v31;
  v32 = a1[3];
  v33 = *(_QWORD *)(**(_QWORD **)(a2 + 8) + 72);
  v34 = *(_QWORD *)(v33 + 120);
  if (*v32)
  {
    v35 = *v32 == v34;
  }
  else
  {
    *v32 = v34;
    v29 = *(BOOL **)a2;
    v33 = *(_QWORD *)(**(_QWORD **)(a2 + 8) + 72);
    v31 = **(_BYTE **)a2 != 0;
    v35 = 1;
  }
  v36 = v35 && v31;
  *v29 = v36;
  v37 = a1[4];
  v38 = *(_QWORD *)(v33 + 152);
  if (*v37)
  {
    v39 = *v37 == v38;
  }
  else
  {
    *v37 = v38;
    v29 = *(BOOL **)a2;
    v36 = **(_BYTE **)a2 != 0;
    v39 = 1;
  }
  *v29 = v39 && v36;
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::MultiplyOp &,mlir::Value>(mlir::Float32Type **a1, uint64_t a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.add";
    v17[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3 - 16, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::`anonymous namespace'::CanonicalizeMultiply::~CanonicalizeMultiply(mlir::mps::_anonymous_namespace_::CanonicalizeMultiply *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::MultiplyOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::MultiplyOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::MultiplyOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeMultiply::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Input;
  uint64_t Filter;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t *v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD *ArgAttrsAttr;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  mlir::GenericProgramPoint *v23;
  uint64_t *v25;
  uint64_t v26[2];
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v29 = a2;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v29);
  v28 = Input;
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v29);
  v27 = Filter;
  if (Input == Filter)
  {
    v22 = v29;
    v26[0] = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v29);
    v23 = mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(v22 + 24), v26);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v22, v23);
    return 1;
  }
  v6 = Filter;
  v7 = (uint64_t *)(*(_QWORD *)(v29 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v7)
    goto LABEL_11;
  v8 = *v7;
  v9 = mlir::TypeID::get<mlir::ShapedType>();
  v10 = *(unsigned int *)(v8 + 16);
  if (!(_DWORD)v10)
    goto LABEL_11;
  v11 = *(_QWORD **)(v8 + 8);
  v12 = &v11[2 * v10];
  do
  {
    v13 = v10 >> 1;
    v14 = &v11[2 * (v10 >> 1)];
    v16 = *v14;
    v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9)
      v11 = v15;
    else
      v10 = v13;
  }
  while (v10);
  if (v11 != v12 && *v11 == v9)
    v17 = v11[1];
  else
LABEL_11:
    v17 = 0;
  v26[0] = (uint64_t)v7;
  v26[1] = v17;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v26))
  {
    ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v26);
    if (v19)
    {
      v20 = 8 * v19;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v20 -= 8;
        if (!v20)
          goto LABEL_17;
      }
      return 0;
    }
LABEL_17:
    if (mlir::isConstantFPOne(Input) && v26[0] == (*(_QWORD *)(v6 + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      v25 = &v27;
    }
    else
    {
      if (!mlir::isConstantFPOne(v6) || v26[0] != (*(_QWORD *)(Input + 8) & 0xFFFFFFFFFFFFFFF8))
        return 0;
      v25 = &v28;
    }
    v21 = 1;
    (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(_QWORD *)a3 + 24))(a3, v29, v25, 1);
    return v21;
  }
  return 0;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square", (const unsigned __int8 *)0xA, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.square";
    v15[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SquareOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void mlir::mps::`anonymous namespace'::CanonicalizeAdd::~CanonicalizeAdd(mlir::mps::_anonymous_namespace_::CanonicalizeAdd *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeAdd::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t *v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  _QWORD *ArgAttrsAttr;
  uint64_t v16;
  uint64_t v17;
  uint64_t Input;
  uint64_t Filter;
  uint64_t v20;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD v25[2];
  uint64_t v26;

  v26 = a2;
  v4 = (uint64_t *)(*(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4)
    goto LABEL_10;
  v5 = *v4;
  v6 = mlir::TypeID::get<mlir::ShapedType>();
  v7 = *(unsigned int *)(v5 + 16);
  if (!(_DWORD)v7)
    goto LABEL_10;
  v8 = *(_QWORD **)(v5 + 8);
  v9 = &v8[2 * v7];
  do
  {
    v10 = v7 >> 1;
    v11 = &v8[2 * (v7 >> 1)];
    v13 = *v11;
    v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6)
      v8 = v12;
    else
      v7 = v10;
  }
  while (v7);
  if (v8 != v9 && *v8 == v6)
    v14 = v8[1];
  else
LABEL_10:
    v14 = 0;
  v25[0] = v4;
  v25[1] = v14;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v25))
    return 0;
  ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v25);
  if (v16)
  {
    v17 = 8 * v16;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v17 -= 8;
      if (!v17)
        goto LABEL_16;
    }
    return 0;
  }
LABEL_16:
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v26);
  v24 = Input;
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v26);
  v23 = Filter;
  if (mlir::isConstantFPValue(Input, 0.0) && v25[0] == (*(_QWORD *)(Filter + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    v22 = &v23;
LABEL_25:
    v20 = 1;
    (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(_QWORD *)a3 + 24))(a3, v26, v22, 1);
    return v20;
  }
  if (mlir::isConstantFPValue(Filter, 0.0) && v25[0] == (*(_QWORD *)(Input + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    v22 = &v24;
    goto LABEL_25;
  }
  return 0;
}

_QWORD *mlir::mps::`anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::ReshapeOp>::~CanonicalizeReshapeChain(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::ReshapeOp>::~CanonicalizeReshapeChain(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::ReshapeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  mlir::OpBuilder *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *p_FastmathAttr;
  mlir::GenericProgramPoint *v10;
  uint64_t FastmathAttr;
  uint64_t **v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t ****v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t **v21;
  uint64_t v22;
  uint64_t ***v23;
  uint64_t *v24;
  uint64_t v25;

  v21 = 0;
  v22 = a2;
  v19 = 0;
  v20 = 0;
  v16 = (uint64_t ****)&v21;
  v17 = &v20;
  v18 = 0;
  v13 = (uint64_t **)&v16;
  v14 = &v19;
  v15 = 0;
  v25 = a2;
  v4 = *(_QWORD *)(a2 + 48);
  if (*(_UNKNOWN **)(v4 + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
    && (*(_BYTE *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    LOBYTE(FastmathAttr) = 1;
    v23 = (uint64_t ***)&FastmathAttr;
    v24 = &v25;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(&v13, (uint64_t)&v23);
    if ((_BYTE)FastmathAttr)
    {
      v15 = v25;
      v5 = v22;
      v23 = (uint64_t ***)v21;
      v25 = v19;
      FastmathAttr = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v22);
      v6 = (mlir::OpBuilder *)(a3 + 8);
      v7 = *(_QWORD *)(v5 + 24);
      v8 = (uint64_t *)&v23;
      p_FastmathAttr = &FastmathAttr;
LABEL_12:
      v10 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value,mlir::UnitAttr>(v6, v7, v8, &v25, p_FastmathAttr);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v5, v10);
      return 1;
    }
    a2 = v22;
    v4 = *(_QWORD *)(v22 + 48);
  }
  v21 = 0;
  v20 = 0;
  v23 = &v21;
  v24 = 0;
  v16 = &v23;
  v17 = &v20;
  v18 = 0;
  v25 = a2;
  if (*(_UNKNOWN **)(v4 + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
    && (*(_BYTE *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    LOBYTE(v19) = 1;
    v13 = (uint64_t **)&v19;
    v14 = &v25;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t ***)&v16, (uint64_t)&v13);
    if ((_BYTE)v19)
    {
      v18 = v25;
      v5 = v22;
      v13 = v21;
      v25 = v20;
      v19 = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v22);
      v6 = (mlir::OpBuilder *)(a3 + 8);
      v7 = *(_QWORD *)(v5 + 24);
      v8 = (uint64_t *)&v13;
      p_FastmathAttr = &v19;
      goto LABEL_12;
    }
  }
  return 0;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t **v4;
  uint64_t result;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  uint64_t *v11;
  uint64_t v12;
  _BOOL4 v13;
  _BYTE *v14;
  uint64_t v15;
  char v16;
  uint64_t **v17;
  uint64_t *v18;
  BOOL v19;
  uint64_t v20;

  v4 = *a1;
  v20 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v20);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
      || (*(_BYTE *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 2)
    {
      goto LABEL_14;
    }
    v7 = *(_QWORD *)(result + 72);
    v8 = *(_QWORD *)(v7 + 24);
    v9 = **v4;
    if (v9)
    {
      v10 = v9 == v8;
    }
    else
    {
      **v4 = v8;
      v7 = *(_QWORD *)(result + 72);
      v10 = 1;
    }
    v11 = v4[1];
    v12 = *(_QWORD *)(v7 + 56);
    if (*v11)
    {
      v13 = *v11 == v12;
    }
    else
    {
      *v11 = v12;
      v13 = 1;
    }
    if (v10 && v13)
    {
      v4[2] = (uint64_t *)result;
      v6 = 1;
    }
    else
    {
LABEL_14:
      v6 = 0;
    }
  }
  v14 = *(_BYTE **)a2;
  v15 = *(_QWORD *)(a2 + 8);
  v16 = v6 & (**(_BYTE **)a2 != 0);
  if (!result)
    v16 = 0;
  *v14 = v16;
  v17 = a1[1];
  v18 = *(uint64_t **)(*(_QWORD *)(*(_QWORD *)v15 + 72) + 56);
  if (*v17)
  {
    v19 = *v17 == v18;
  }
  else
  {
    *v17 = v18;
    v14 = *(_BYTE **)a2;
    v16 = **(_BYTE **)a2 != 0;
    v19 = 1;
  }
  *v14 = v19 & v16;
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value,mlir::UnitAttr>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.reshape";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReshapeOp::build((uint64_t)a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t **v4;
  uint64_t result;
  char v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  char v11;
  uint64_t **v12;
  uint64_t *v13;
  BOOL v14;
  uint64_t v15;

  v4 = *a1;
  v15 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
      || (*(_BYTE *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 1)
    {
      goto LABEL_7;
    }
    v7 = *(_QWORD *)(*(_QWORD *)(result + 72) + 24);
    v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        v6 = 0;
        goto LABEL_8;
      }
    }
    else
    {
      **v4 = v7;
    }
    v4[1] = (uint64_t *)result;
    v6 = 1;
  }
LABEL_8:
  v9 = *(_BYTE **)a2;
  v10 = *(_QWORD *)(a2 + 8);
  v11 = v6 & (**(_BYTE **)a2 != 0);
  if (!result)
    v11 = 0;
  *v9 = v11;
  v12 = a1[1];
  v13 = *(uint64_t **)(*(_QWORD *)(*(_QWORD *)v10 + 72) + 56);
  if (*v12)
  {
    v14 = *v12 == v13;
  }
  else
  {
    *v12 = v13;
    v9 = *(_BYTE **)a2;
    v11 = **(_BYTE **)a2 != 0;
    v14 = 1;
  }
  *v9 = v14 & v11;
  return result;
}

_QWORD *mlir::mps::`anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::SqueezeOp>::~CanonicalizeReshapeChain(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::SqueezeOp>::~CanonicalizeReshapeChain(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::SqueezeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  mlir::OpBuilder *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *p_FastmathAttr;
  mlir::GenericProgramPoint *v10;
  uint64_t FastmathAttr;
  uint64_t **v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t ****v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t **v21;
  uint64_t v22;
  uint64_t ***v23;
  uint64_t *v24;
  uint64_t v25;

  v21 = 0;
  v22 = a2;
  v19 = 0;
  v20 = 0;
  v16 = (uint64_t ****)&v21;
  v17 = &v20;
  v18 = 0;
  v13 = (uint64_t **)&v16;
  v14 = &v19;
  v15 = 0;
  v25 = a2;
  v4 = *(_QWORD *)(a2 + 48);
  if (*(_UNKNOWN **)(v4 + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
    && (*(_BYTE *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    LOBYTE(FastmathAttr) = 1;
    v23 = (uint64_t ***)&FastmathAttr;
    v24 = &v25;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(&v13, (uint64_t)&v23);
    if ((_BYTE)FastmathAttr)
    {
      v15 = v25;
      v5 = v22;
      v23 = (uint64_t ***)v21;
      v25 = v19;
      FastmathAttr = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v22);
      v6 = (mlir::OpBuilder *)(a3 + 8);
      v7 = *(_QWORD *)(v5 + 24);
      v8 = (uint64_t *)&v23;
      p_FastmathAttr = &FastmathAttr;
LABEL_12:
      v10 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value,mlir::UnitAttr>(v6, v7, v8, &v25, p_FastmathAttr);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v5, v10);
      return 1;
    }
    a2 = v22;
    v4 = *(_QWORD *)(v22 + 48);
  }
  v21 = 0;
  v20 = 0;
  v23 = &v21;
  v24 = 0;
  v16 = &v23;
  v17 = &v20;
  v18 = 0;
  v25 = a2;
  if (*(_UNKNOWN **)(v4 + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
    && (*(_BYTE *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    LOBYTE(v19) = 1;
    v13 = (uint64_t **)&v19;
    v14 = &v25;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t ***)&v16, (uint64_t)&v13);
    if ((_BYTE)v19)
    {
      v18 = v25;
      v5 = v22;
      v13 = v21;
      v25 = v20;
      v19 = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v22);
      v6 = (mlir::OpBuilder *)(a3 + 8);
      v7 = *(_QWORD *)(v5 + 24);
      v8 = (uint64_t *)&v13;
      p_FastmathAttr = &v19;
      goto LABEL_12;
    }
  }
  return 0;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t **v4;
  uint64_t result;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  uint64_t *v11;
  uint64_t v12;
  _BOOL4 v13;
  _BYTE *v14;
  uint64_t v15;
  char v16;
  uint64_t **v17;
  uint64_t *v18;
  BOOL v19;
  uint64_t v20;

  v4 = *a1;
  v20 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v20);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::SqueezeOp,void>::id
      || (*(_BYTE *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 2)
    {
      goto LABEL_14;
    }
    v7 = *(_QWORD *)(result + 72);
    v8 = *(_QWORD *)(v7 + 24);
    v9 = **v4;
    if (v9)
    {
      v10 = v9 == v8;
    }
    else
    {
      **v4 = v8;
      v7 = *(_QWORD *)(result + 72);
      v10 = 1;
    }
    v11 = v4[1];
    v12 = *(_QWORD *)(v7 + 56);
    if (*v11)
    {
      v13 = *v11 == v12;
    }
    else
    {
      *v11 = v12;
      v13 = 1;
    }
    if (v10 && v13)
    {
      v4[2] = (uint64_t *)result;
      v6 = 1;
    }
    else
    {
LABEL_14:
      v6 = 0;
    }
  }
  v14 = *(_BYTE **)a2;
  v15 = *(_QWORD *)(a2 + 8);
  v16 = v6 & (**(_BYTE **)a2 != 0);
  if (!result)
    v16 = 0;
  *v14 = v16;
  v17 = a1[1];
  v18 = *(uint64_t **)(*(_QWORD *)(*(_QWORD *)v15 + 72) + 56);
  if (*v17)
  {
    v19 = *v17 == v18;
  }
  else
  {
    *v17 = v18;
    v14 = *(_BYTE **)a2;
    v16 = **(_BYTE **)a2 != 0;
    v19 = 1;
  }
  *v14 = v19 & v16;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SqueezeOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t **v4;
  uint64_t result;
  char v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  char v11;
  uint64_t **v12;
  uint64_t *v13;
  BOOL v14;
  uint64_t v15;

  v4 = *a1;
  v15 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::SqueezeOp,void>::id
      || (*(_BYTE *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 1)
    {
      goto LABEL_7;
    }
    v7 = *(_QWORD *)(*(_QWORD *)(result + 72) + 24);
    v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        v6 = 0;
        goto LABEL_8;
      }
    }
    else
    {
      **v4 = v7;
    }
    v4[1] = (uint64_t *)result;
    v6 = 1;
  }
LABEL_8:
  v9 = *(_BYTE **)a2;
  v10 = *(_QWORD *)(a2 + 8);
  v11 = v6 & (**(_BYTE **)a2 != 0);
  if (!result)
    v11 = 0;
  *v9 = v11;
  v12 = a1[1];
  v13 = *(uint64_t **)(*(_QWORD *)(*(_QWORD *)v10 + 72) + 56);
  if (*v12)
  {
    v14 = *v12 == v13;
  }
  else
  {
    *v12 = v13;
    v9 = *(_BYTE **)a2;
    v11 = **(_BYTE **)a2 != 0;
    v14 = 1;
  }
  *v9 = v14 & v11;
  return result;
}

_QWORD *mlir::mps::`anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::ExpandDimsOp>::~CanonicalizeReshapeChain(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::ExpandDimsOp>::~CanonicalizeReshapeChain(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeReshapeChain<mlir::mps::ExpandDimsOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  mlir::OpBuilder *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *p_FastmathAttr;
  mlir::GenericProgramPoint *v10;
  uint64_t FastmathAttr;
  uint64_t **v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t ****v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t **v21;
  uint64_t v22;
  uint64_t ***v23;
  uint64_t *v24;
  uint64_t v25;

  v21 = 0;
  v22 = a2;
  v19 = 0;
  v20 = 0;
  v16 = (uint64_t ****)&v21;
  v17 = &v20;
  v18 = 0;
  v13 = (uint64_t **)&v16;
  v14 = &v19;
  v15 = 0;
  v25 = a2;
  v4 = *(_QWORD *)(a2 + 48);
  if (*(_UNKNOWN **)(v4 + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
    && (*(_BYTE *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    LOBYTE(FastmathAttr) = 1;
    v23 = (uint64_t ***)&FastmathAttr;
    v24 = &v25;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(&v13, (uint64_t)&v23);
    if ((_BYTE)FastmathAttr)
    {
      v15 = v25;
      v5 = v22;
      v23 = (uint64_t ***)v21;
      v25 = v19;
      FastmathAttr = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v22);
      v6 = (mlir::OpBuilder *)(a3 + 8);
      v7 = *(_QWORD *)(v5 + 24);
      v8 = (uint64_t *)&v23;
      p_FastmathAttr = &FastmathAttr;
LABEL_12:
      v10 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value,mlir::UnitAttr>(v6, v7, v8, &v25, p_FastmathAttr);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v5, v10);
      return 1;
    }
    a2 = v22;
    v4 = *(_QWORD *)(v22 + 48);
  }
  v21 = 0;
  v20 = 0;
  v23 = &v21;
  v24 = 0;
  v16 = &v23;
  v17 = &v20;
  v18 = 0;
  v25 = a2;
  if (*(_UNKNOWN **)(v4 + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
    && (*(_BYTE *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    LOBYTE(v19) = 1;
    v13 = (uint64_t **)&v19;
    v14 = &v25;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t ***)&v16, (uint64_t)&v13);
    if ((_BYTE)v19)
    {
      v18 = v25;
      v5 = v22;
      v13 = v21;
      v25 = v20;
      v19 = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v22);
      v6 = (mlir::OpBuilder *)(a3 + 8);
      v7 = *(_QWORD *)(v5 + 24);
      v8 = (uint64_t *)&v13;
      p_FastmathAttr = &v19;
      goto LABEL_12;
    }
  }
  return 0;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t **v4;
  uint64_t result;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  uint64_t *v11;
  uint64_t v12;
  _BOOL4 v13;
  _BYTE *v14;
  uint64_t v15;
  char v16;
  uint64_t **v17;
  uint64_t *v18;
  BOOL v19;
  uint64_t v20;

  v4 = *a1;
  v20 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v20);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id
      || (*(_BYTE *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 2)
    {
      goto LABEL_14;
    }
    v7 = *(_QWORD *)(result + 72);
    v8 = *(_QWORD *)(v7 + 24);
    v9 = **v4;
    if (v9)
    {
      v10 = v9 == v8;
    }
    else
    {
      **v4 = v8;
      v7 = *(_QWORD *)(result + 72);
      v10 = 1;
    }
    v11 = v4[1];
    v12 = *(_QWORD *)(v7 + 56);
    if (*v11)
    {
      v13 = *v11 == v12;
    }
    else
    {
      *v11 = v12;
      v13 = 1;
    }
    if (v10 && v13)
    {
      v4[2] = (uint64_t *)result;
      v6 = 1;
    }
    else
    {
LABEL_14:
      v6 = 0;
    }
  }
  v14 = *(_BYTE **)a2;
  v15 = *(_QWORD *)(a2 + 8);
  v16 = v6 & (**(_BYTE **)a2 != 0);
  if (!result)
    v16 = 0;
  *v14 = v16;
  v17 = a1[1];
  v18 = *(uint64_t **)(*(_QWORD *)(*(_QWORD *)v15 + 72) + 56);
  if (*v17)
  {
    v19 = *v17 == v18;
  }
  else
  {
    *v17 = v18;
    v14 = *(_BYTE **)a2;
    v16 = **(_BYTE **)a2 != 0;
    v19 = 1;
  }
  *v14 = v19 & v16;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExpandDimsOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t **v4;
  uint64_t result;
  char v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  char v11;
  uint64_t **v12;
  uint64_t *v13;
  BOOL v14;
  uint64_t v15;

  v4 = *a1;
  v15 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id
      || (*(_BYTE *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 1)
    {
      goto LABEL_7;
    }
    v7 = *(_QWORD *)(*(_QWORD *)(result + 72) + 24);
    v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        v6 = 0;
        goto LABEL_8;
      }
    }
    else
    {
      **v4 = v7;
    }
    v4[1] = (uint64_t *)result;
    v6 = 1;
  }
LABEL_8:
  v9 = *(_BYTE **)a2;
  v10 = *(_QWORD *)(a2 + 8);
  v11 = v6 & (**(_BYTE **)a2 != 0);
  if (!result)
    v11 = 0;
  *v9 = v11;
  v12 = a1[1];
  v13 = *(uint64_t **)(*(_QWORD *)(*(_QWORD *)v10 + 72) + 56);
  if (*v12)
  {
    v14 = *v12 == v13;
  }
  else
  {
    *v12 = v13;
    v9 = *(_BYTE **)a2;
    v11 = **(_BYTE **)a2 != 0;
    v14 = 1;
  }
  *v9 = v14 & v11;
  return result;
}

void mlir::mps::`anonymous namespace'::CanonicalizePower::~CanonicalizePower(mlir::mps::_anonymous_namespace_::CanonicalizePower *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PowerOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PowerOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::PowerOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizePower::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Filter;
  uint64_t v5;
  mlir::GenericProgramPoint *v6;
  _BOOL8 v7;
  mlir::Operation *DefiningOp;
  uint64_t v10;
  uint64_t v11;
  uint64_t Input;
  uint64_t v13;
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t p_p;
  void *__p;
  unsigned int v21;

  v17 = a2;
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v17);
  if (mlir::isConstantFPTwo(Filter))
  {
    v5 = v17;
    __p = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v17);
    v6 = mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(v5 + 24), (uint64_t *)&__p);
LABEL_9:
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v5, v6);
    return 1;
  }
  if (mlir::isConstantFPValue(Filter, 0.5))
  {
    v5 = v17;
    __p = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v17);
    v6 = mlir::OpBuilder::create<mlir::mps::SquareRootOp,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(v5 + 24), (uint64_t *)&__p);
    goto LABEL_9;
  }
  if (mlir::isConstantFPValue(Filter, -0.5))
  {
    v5 = v17;
    __p = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v17);
    v6 = mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(v5 + 24), (uint64_t *)&__p);
    goto LABEL_9;
  }
  if (mlir::isConstantFPValue(Filter, -1.0))
  {
    v5 = v17;
    __p = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v17);
    v6 = mlir::OpBuilder::create<mlir::mps::ReciprocalOp,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(v5 + 24), (uint64_t *)&__p);
    goto LABEL_9;
  }
  if (mlir::isConstantFPZero(Filter))
    goto LABEL_21;
  v18 = Filter;
  DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v18);
  if (!DefiningOp)
    return 0;
  v21 = 1;
  p_p = (uint64_t)&__p;
  __p = 0;
  v7 = mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)&p_p, DefiningOp)
    && (uint64_t)mlir::m_Zero(void)::{lambda(llvm::APInt const&)#1}::__invoke((llvm::APInt *)&__p);
  if (v21 >= 0x41 && __p)
    operator delete[](__p);
  if (v7)
  {
LABEL_21:
    v10 = *(_QWORD *)(v17 + 24);
    v7 = 1;
    LODWORD(p_p) = 1;
    __p = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((mlir::mps::ConstantOp *)(a3 + 8), v10, (unsigned int *)&p_p)- 16;
    v11 = *(_QWORD *)(v17 + 24);
    Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v17);
    p_p = mlir::getElementTypeOrSelf(Input);
    __p = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a3 + 8), v11, (uint64_t *)&__p, &p_p)- 16;
    v13 = *(_QWORD *)(v17 + 24);
    v16 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v17);
    v18 = (unint64_t)mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>((mlir::OpBuilder *)(a3 + 8), v13, &v16);
    p_p = (uint64_t)mlir::OpBuilder::create<mlir::mps::BroadcastToOp,mlir::Value &,mlir::mps::ShapeOp>((mlir::OpBuilder *)(a3 + 8), v13, (uint64_t *)&__p, &v18);
    v14 = v17;
    v18 = *(_QWORD *)(v17 - 8) & 0xFFFFFFFFFFFFFFF8;
    v15 = mlir::OpBuilder::create<mlir::mps::TypeConstraintOp,mlir::mps::BroadcastToOp &,mlir::Type>((mlir::UnknownLoc **)(a3 + 8), *(_QWORD *)(v17 + 24), &p_p, (uint64_t *)&v18);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v14, v15);
  }
  return v7;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConstantOp,int>(mlir::mps::ConstantOp *a1, uint64_t a2, unsigned int *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.constant";
    v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ConstantOp::build(a1, (mlir::OpBuilder *)v17, (mlir::OperationState *)*a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.cast";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::CastOp::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::BroadcastToOp,mlir::Value &,mlir::mps::ShapeOp>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.broadcast_to", (const unsigned __int8 *)0x10, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.broadcast_to";
    v17[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::BroadcastToOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4 - 16);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::BroadcastToOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.shape", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.shape";
    v15[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ShapeOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ShapeOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SquareRootOp,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square_root", (const unsigned __int8 *)0xF, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.square_root";
    v15[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SquareRootOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal_square_root", (const unsigned __int8 *)0x1A, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.reciprocal_square_root";
    v15[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalSquareRootOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReciprocalOp,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal", (const unsigned __int8 *)0xE, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.reciprocal";
    v15[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

uint64_t mlir::detail::constant_int_value_binder::match(mlir::detail::constant_int_value_binder *this, mlir::Operation *a2)
{
  uint64_t v4;
  uint64_t result;
  unint64_t v6;
  void *v7;
  BOOL v8;
  BOOL v9;
  BOOL v10;
  void *v11[2];
  _QWORD v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  v4 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  result = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 6) + 32))(*((_QWORD *)a2 + 6), v4);
  if ((_DWORD)result)
  {
    v11[0] = v12;
    v11[1] = (void *)0x100000000;
    mlir::Operation::fold((uint64_t)a2, 0, 0, (uint64_t)v11);
    v6 = *(_QWORD *)v11[0] & 0xFFFFFFFFFFFFFFF8;
    if (v11[0] != v12)
      free(v11[0]);
    if (v6
      && ((v7 = *(void **)(*(_QWORD *)(*((_QWORD *)a2 - 1) & 0xFFFFFFFFFFFFFFF8) + 136),
           v7 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
        ? (v8 = v7 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        : (v8 = 1),
          !v8 ? (v9 = v7 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id) : (v9 = 1),
          !v9 ? (v10 = v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) : (v10 = 1),
          v10))
    {
      return mlir::detail::constant_int_value_binder::match((uint64_t *)this, v6);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::TypeConstraintOp,mlir::mps::BroadcastToOp &,mlir::Type>(mlir::UnknownLoc **a1, uint64_t a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.type_constraint", (const unsigned __int8 *)0x13, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.type_constraint";
    v17[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::TypeConstraintOp::build(a1, (uint64_t)v19, *a3 - 16, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::TypeConstraintOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::`anonymous namespace'::CanonicalizeSwish::~CanonicalizeSwish(mlir::mps::_anonymous_namespace_::CanonicalizeSwish *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeSwish::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  mlir::GenericProgramPoint *v6;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t *v15;
  char v16;
  uint64_t v17;

  v12 = 0;
  v13 = 0;
  v10 = 0;
  v11 = &v13;
  v8 = (uint64_t *)&v11;
  v9 = &v13;
  v17 = a2;
  v5 = *(_QWORD *)(a2 + 48);
  if (*(_UNKNOWN **)(v5 + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id
    && (*(_BYTE *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    v16 = 1;
    v14 = &v16;
    v15 = &v17;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t ***)&v8, (uint64_t)&v14);
    if (v16)
    {
LABEL_10:
      v10 = v17;
      v14 = (char *)v13;
      v6 = mlir::OpBuilder::create<mlir::mps::SwishOp,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v14);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, a2, v6);
      return 1;
    }
    v5 = *(_QWORD *)(a2 + 48);
  }
  v12 = 0;
  v13 = 0;
  v10 = 0;
  v11 = &v13;
  v8 = &v13;
  v9 = (uint64_t *)&v11;
  v17 = a2;
  if (*(_UNKNOWN **)(v5 + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id
    && (*(_BYTE *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    v16 = 1;
    v14 = &v16;
    v15 = &v17;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *> & *)#1},0ul,1ul>(&v8, (uint64_t)&v14);
    if (v16)
      goto LABEL_10;
  }
  return 0;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t **v4;
  uint64_t result;
  char v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  char v11;
  uint64_t **v12;
  uint64_t *v13;
  BOOL v14;
  uint64_t v15;

  v4 = *a1;
  v15 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::SigmoidOp,void>::id
      || (*(_BYTE *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 1)
    {
      goto LABEL_7;
    }
    v7 = *(_QWORD *)(*(_QWORD *)(result + 72) + 24);
    v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        v6 = 0;
        goto LABEL_8;
      }
    }
    else
    {
      **v4 = v7;
    }
    v4[1] = (uint64_t *)result;
    v6 = 1;
  }
LABEL_8:
  v9 = *(_BYTE **)a2;
  v10 = *(_QWORD *)(a2 + 8);
  v11 = v6 & (**(_BYTE **)a2 != 0);
  if (!result)
    v11 = 0;
  *v9 = v11;
  v12 = a1[1];
  v13 = *(uint64_t **)(*(_QWORD *)(*(_QWORD *)v10 + 72) + 56);
  if (*v12)
  {
    v14 = *v12 == v13;
  }
  else
  {
    *v12 = v13;
    v9 = *(_BYTE **)a2;
    v11 = **(_BYTE **)a2 != 0;
    v14 = 1;
  }
  *v9 = v14 & v11;
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SwishOp,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.swish", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.swish";
    v15[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SwishOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SigmoidOp,mlir::detail::any_value_binder> *> & *)#1},0ul,1ul>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t **v7;
  uint64_t result;
  char v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;

  v3 = *(_QWORD *)(**(_QWORD **)(a2 + 8) + 72);
  v4 = *(_QWORD *)(v3 + 24);
  v5 = **a1;
  if (v5)
  {
    v6 = v5 == v4;
  }
  else
  {
    **a1 = v4;
    v3 = *(_QWORD *)(**(_QWORD **)(a2 + 8) + 72);
    v6 = 1;
  }
  if (!**(_BYTE **)a2)
    v6 = 0;
  **(_BYTE **)a2 = v6;
  v7 = (uint64_t **)a1[1];
  v13 = *(_QWORD *)(v3 + 56);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v13);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::SigmoidOp,void>::id
      || (*(_BYTE *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 1)
    {
      goto LABEL_12;
    }
    v10 = *(_QWORD *)(*(_QWORD *)(result + 72) + 24);
    v11 = **v7;
    if (v11)
    {
      if (v11 != v10)
      {
LABEL_12:
        v9 = 0;
        goto LABEL_13;
      }
    }
    else
    {
      **v7 = v10;
    }
    v7[1] = (uint64_t *)result;
    v9 = 1;
  }
LABEL_13:
  v12 = v9 & (**(_BYTE **)a2 != 0);
  if (!result)
    v12 = 0;
  **(_BYTE **)a2 = v12;
  return result;
}

void mlir::mps::`anonymous namespace'::CanonicalizeBatchNorm::~CanonicalizeBatchNorm(mlir::mps::_anonymous_namespace_::CanonicalizeBatchNorm *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeBatchNorm::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  mlir::GenericProgramPoint *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __int128 *v14;
  __int128 v15;
  __int128 *v16;
  __int128 v17;
  uint64_t v18;
  mlir::GenericProgramPoint *v19;
  unsigned int WeightsLayout;
  unsigned int StorageType;
  unsigned int PaddingStyle;
  uint64_t Rewriter;
  uint64_t InputAttributeNames;
  uint64_t Strides;
  void *Groups;
  mlir::GenericProgramPoint *v27;
  mlir::GenericProgramPoint *v28;
  mlir::GenericProgramPoint *v29;
  uint64_t v30;
  mlir::GenericProgramPoint *v31;
  mlir::GenericProgramPoint *v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD v35[5];
  uint64_t v36;
  _QWORD v37[2];
  uint64_t v38;
  void *v39;
  mlir::GenericProgramPoint *v40;
  mlir::GenericProgramPoint *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  __int128 v46;
  _OWORD v47[3];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  v44 = 0;
  v45 = a2;
  v3 = *(_QWORD *)(a2 + 24);
  v42 = 0;
  v43 = 0;
  v40 = 0;
  v41 = 0;
  v38 = 0;
  v39 = 0;
  v37[0] = &v44;
  v37[1] = &v43;
  v35[0] = v37;
  v35[1] = &v42;
  v35[2] = &v41;
  v35[3] = &v40;
  v35[4] = &v39;
  v36 = 0;
  *(_QWORD *)&v50 = a2;
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::NormalizationOp,void>::id)
    return 0;
  if ((*(_BYTE *)(a2 + 46) & 0x80) == 0)
    return 0;
  if (*(_DWORD *)(a2 + 68) != 5)
    return 0;
  LOBYTE(v48) = 1;
  *(_QWORD *)&v46 = &v48;
  *((_QWORD *)&v46 + 1) = &v50;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::NormalizationOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> & *)#1},0ul,1ul,2ul,3ul,4ul>((uint64_t)v35, (uint64_t)&v46);
  if (!(_BYTE)v48)
    return 0;
  v36 = v50;
  v34 = v38;
  if (mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v34) != (void *)1)
    return 0;
  if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v34) == 1)
  {
    v33 = v42;
    v5 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v33);
    v46 = xmmword_1812408A0;
    v47[0] = unk_1812408B0;
    if (!mlir::mps::matchShape<mlir::Value>(v5, &v46, 4, -1))
      return 0;
    v32 = v41;
    v6 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v32);
    v50 = xmmword_1812408A0;
    v51 = unk_1812408B0;
    if (!mlir::mps::matchShape<mlir::Value>(v6, &v50, 4, -1))
      return 0;
    v31 = v40;
    v7 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v31);
    v48 = xmmword_1812408A0;
    v49 = unk_1812408B0;
    if ((mlir::mps::matchShape<mlir::Value>(v7, &v48, 4, -1) & 1) == 0)
      return 0;
  }
  if (!mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v34))
  {
    v33 = v42;
    v10 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v33);
    v46 = xmmword_1812408E0;
    v47[0] = unk_1812408F0;
    if (!mlir::mps::matchShape<mlir::Value>(v10, &v46, 4, -1))
      return 0;
    v32 = v41;
    v11 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v32);
    v50 = xmmword_1812408E0;
    v51 = unk_1812408F0;
    if (!mlir::mps::matchShape<mlir::Value>(v11, &v50, 4, -1))
      return 0;
    v31 = v40;
    v12 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v31);
    v48 = xmmword_1812408E0;
    v49 = unk_1812408F0;
    if ((mlir::mps::matchShape<mlir::Value>(v12, &v48, 4, -1) & 1) == 0)
      return 0;
  }
  mlir::mps::InstanceNormOp::getEpsilon((mlir::mps::InstanceNormOp *)&v45, (uint64_t)&v46);
  LODWORD(v50) = llvm::APFloat::convertToFloat((void **)&v46);
  v8 = mlir::OpBuilder::create<mlir::mps::ConstantOp,float>(a3 + 1, v3, (float *)&v50);
  *(_QWORD *)&v48 = (char *)v8 - 16;
  v9 = (void *)*((_QWORD *)&v46 + 1);
  if (llvm::APFloatBase::PPCDoubleDouble(v8) == v9)
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)((char *)&v46 + 8));
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)((char *)&v46 + 8));
  *(_QWORD *)&v46 = mlir::getElementTypeOrSelf((uint64_t)v41 - 16);
  *(_QWORD *)&v48 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 1, v3, (uint64_t *)&v48, (uint64_t *)&v46)- 16;
  *(_QWORD *)&v46 = v41;
  v33 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v34)
    || mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v34) != 3)
  {
    if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v34)
      || mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v34) != 2)
    {
      goto LABEL_27;
    }
    v14 = &xmmword_1812408C0;
  }
  else
  {
    v14 = &xmmword_1812408A0;
  }
  v15 = v14[1];
  v50 = *v14;
  v51 = v15;
  llvm::SmallVector<long long,6u>::SmallVector(&v46, &v50, 4);
  v33 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>((mlir::Builder *)(a3 + 1), v3, &v33, (uint64_t)&v46)- 16;
  if ((_OWORD *)v46 != v47)
    free((void *)v46);
LABEL_27:
  v32 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 1, v3, &v33, (uint64_t *)&v48);
  v31 = mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::mps::AddOp &>((mlir::OpBuilder *)(a3 + 1), v3, &v32);
  *(_QWORD *)&v46 = v40;
  v30 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  if (!mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v34)
    && mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v34) == 3)
  {
    v16 = &xmmword_1812408A0;
    goto LABEL_33;
  }
  if (!mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v34)
    && mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v34) == 2)
  {
    v16 = &xmmword_1812408C0;
LABEL_33:
    v17 = v16[1];
    v50 = *v16;
    v51 = v17;
    llvm::SmallVector<long long,6u>::SmallVector(&v46, &v50, 4);
    v30 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>((mlir::Builder *)(a3 + 1), v3, &v30, (uint64_t)&v46)- 16;
    if ((_OWORD *)v46 != v47)
      free((void *)v46);
  }
  *(_QWORD *)&v50 = (char *)mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::ReciprocalSquareRootOp &>(a3 + 1, v3, &v30, &v31)- 16;
  *(_QWORD *)&v46 = mlir::getElementTypeOrSelf(v43 - 16);
  v29 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 1, v3, (uint64_t *)&v50, (uint64_t *)&v46);
  *(_QWORD *)&v46 = v43;
  v28 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::ConstantOp,mlir::mps::CastOp &>(a3 + 1, v3, &v46, &v29);
  *(_QWORD *)&v46 = v44;
  Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v34);
  Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v34);
  InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v34);
  Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v34);
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v34);
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v34);
  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v34);
  v27 = mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value,mlir::mps::MultiplyOp &,unsigned long long,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle,mlir::mps::TensorDataLayout,mlir::mps::TensorDataLayout>((mlir::Builder *)(a3 + 1), v3, (uint64_t *)&v46, &v28, (uint64_t *)&Groups, &Strides, &InputAttributeNames, &Rewriter, &PaddingStyle, &StorageType, &WeightsLayout);
  if (!mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v34))
  {
    *(_QWORD *)&v46 = v47;
    v47[0] = xmmword_1812408E0;
    v47[1] = unk_1812408F0;
    *((_QWORD *)&v46 + 1) = 0x600000004;
    *(_QWORD *)&v50 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>((mlir::Builder *)(a3 + 1), v3, (uint64_t *)&v50, (uint64_t)&v46)- 16;
    if ((_OWORD *)v46 != v47)
      free((void *)v46);
  }
  Strides = v42;
  Groups = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::ReciprocalSquareRootOp &>(a3 + 1, v3, (uint64_t *)&v50, &Strides);
  *(_QWORD *)&v46 = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::mps::Conv2DOp &,mlir::mps::MultiplyOp>(a3 + 1, v3, &v27, &Groups);
  v18 = v45;
  Groups = v39;
  v19 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::SubtractOp &,mlir::mps::ConstantOp>(a3 + 1, *(_QWORD *)(v45 + 24), &v46, &Groups);
  (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, v18, v19);
  return 1;
}

uint64_t mlir::mps::matchShape<mlir::Value>(uint64_t a1, const void *a2, uint64_t a3, int a4)
{
  void *v4;
  unint64_t v5;
  int v6;
  uint64_t Value;
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;

  v5 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!v5)
    goto LABEL_5;
  v4 = *(void **)(*(_QWORD *)v5 + 136);
  if (v4 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v5 = 0;
  v17 = v5;
  if (v4 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v17);
    v13 = v12;
    v14 = (const void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v17);
    if (v15 == a3 && !memcmp(v14, a2, 8 * a3))
    {
      v6 = 0;
      LODWORD(v4) = 1;
      return (v4 | v6) & 1;
    }
    if (a4 < 1 || (_DWORD)v13 == a4)
    {
      if (!v13)
      {
LABEL_17:
        LODWORD(v4) = 0;
        v6 = 1;
        return (v4 | v6) & 1;
      }
      while (1)
      {
        v16 = *((_QWORD *)a2 + v13 - 1);
        if (v16 != -1 && v16 != *(_QWORD *)(Value - 8 + 8 * v13))
          break;
        if (!--v13)
          goto LABEL_17;
      }
    }
    LODWORD(v4) = 0;
    v6 = 0;
  }
  else
  {
LABEL_5:
    v6 = 1;
  }
  return (v4 | v6) & 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConstantOp,float>(mlir::Float32Type **a1, uint64_t a2, float *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::OperationState *v9;
  mlir::GenericProgramPoint *v10;
  mlir::GenericProgramPoint *v11;
  uint64_t v13;
  const char *v14;
  __int16 v15;
  uint64_t v16[4];
  __int16 v17;
  _QWORD v18[39];

  v18[38] = *MEMORY[0x1E0C80C00];
  v13 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v13);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    v17 = 1283;
    v16[2] = (uint64_t)"mps.constant";
    v16[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v15 = 259;
    llvm::operator+(v16, (uint64_t *)&v14, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::mps::ConstantOp::build(a1, (mlir::OpBuilder *)v18, v9, *a3);
  v10 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((_QWORD *)v10 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
    v11 = v10;
  else
    v11 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v11;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  uint64_t v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.reshape";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ReshapeOp::build(a1, v19, *a3, *(_QWORD *)a4, (uint64_t *)*(unsigned int *)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::mps::AddOp &>(mlir::OpBuilder *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal_square_root", (const unsigned __int8 *)0x1A, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.reciprocal_square_root";
    v15[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3 - 16);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalSquareRootOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::ReciprocalSquareRootOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.multiply";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::ConstantOp,mlir::mps::CastOp &>(mlir::Float32Type **a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.multiply";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value,mlir::mps::MultiplyOp &,unsigned long long,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle,mlir::mps::TensorDataLayout,mlir::mps::TensorDataLayout>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, _QWORD *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, unsigned int *a9, unsigned int *a10, unsigned int *a11)
{
  uint64_t *Context;
  uint64_t v20;
  char v21;
  mlir::GenericProgramPoint *v22;
  mlir::GenericProgramPoint *v23;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  uint64_t v28[4];
  __int16 v29;
  _QWORD v30[40];

  v30[38] = *MEMORY[0x1E0C80C00];
  v25 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  v20 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d", (const unsigned __int8 *)0xB, Context);
  if (!v21)
  {
    v29 = 1283;
    v28[2] = (uint64_t)"mps.conv_2d";
    v28[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v20);
  mlir::mps::Conv2DOp::build(a1, (uint64_t)v30, *a3, *a4 - 16, *a5, *a6, *a7, *a8, *a9, *a10, *a11);
  v22 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((_QWORD *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id)
    v23 = v22;
  else
    v23 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::mps::Conv2DOp &,mlir::mps::MultiplyOp>(mlir::Float32Type **a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.subtract", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.subtract";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::NormalizationOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> & *)#1},0ul,1ul,2ul,3ul,4ul>(uint64_t a1, uint64_t a2)
{
  char v4;
  char v5;
  uint64_t *v6;
  uint64_t DefiningOp;
  char v8;
  BOOL v9;
  char v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;
  char v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;
  char v18;
  uint64_t *v19;
  uint64_t result;
  char v21;
  char v22;
  uint64_t v23;

  v4 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(**(_QWORD **)(a2 + 8), 0, *(uint64_t ***)a1);
  if (**(_BYTE **)a2)
    v5 = v4;
  else
    v5 = 0;
  **(_BYTE **)a2 = v5;
  v6 = *(uint64_t **)(a1 + 8);
  v23 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 56);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v23);
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (*v6 ? (v9 = *v6 == DefiningOp) : (v9 = 1), v9))
    {
      *v6 = DefiningOp;
      v8 = 1;
    }
    else
    {
      v8 = 0;
    }
  }
  v10 = v8 & (**(_BYTE **)a2 != 0);
  if (!DefiningOp)
    v10 = 0;
  **(_BYTE **)a2 = v10;
  v11 = *(uint64_t **)(a1 + 16);
  v23 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 88);
  v12 = mlir::Value::getDefiningOp((mlir::Value *)&v23);
  if (v12)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v11 || *v11 == v12))
    {
      *v11 = v12;
      v13 = 1;
    }
    else
    {
      v13 = 0;
    }
  }
  v14 = v13 & (**(_BYTE **)a2 != 0);
  if (!v12)
    v14 = 0;
  **(_BYTE **)a2 = v14;
  v15 = *(uint64_t **)(a1 + 24);
  v23 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 120);
  v16 = mlir::Value::getDefiningOp((mlir::Value *)&v23);
  if (v16)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(v16 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v15 || *v15 == v16))
    {
      *v15 = v16;
      v17 = 1;
    }
    else
    {
      v17 = 0;
    }
  }
  v18 = v17 & (**(_BYTE **)a2 != 0);
  if (!v16)
    v18 = 0;
  **(_BYTE **)a2 = v18;
  v19 = *(uint64_t **)(a1 + 32);
  v23 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 152);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v23);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v19 || *v19 == result))
    {
      *v19 = result;
      v21 = 1;
    }
    else
    {
      v21 = 0;
    }
  }
  v22 = v21 & (**(_BYTE **)a2 != 0);
  if (!result)
    v22 = 0;
  **(_BYTE **)a2 = v22;
  return result;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  uint64_t DefiningOp;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v14;

  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v14);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
      || (*(_BYTE *)(DefiningOp + 46) & 0x80) == 0
      || *(_DWORD *)(DefiningOp + 68) != 2)
    {
      goto LABEL_15;
    }
    v7 = *(_QWORD *)(DefiningOp + 72);
    v8 = *(_QWORD *)(v7 + 24);
    v9 = **a3;
    if (v9)
    {
      v10 = v9 == v8;
    }
    else
    {
      **a3 = v8;
      v7 = *(_QWORD *)(DefiningOp + 72);
      v10 = 1;
    }
    if ((v11 = a3[1], v14 = *(_QWORD *)(v7 + 56), (v12 = mlir::Value::getDefiningOp((mlir::Value *)&v14)) != 0)
      && *(_UNKNOWN **)(*(_QWORD *)(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v11 || *v11 == v12)
      && (*v11 = v12, v10))
    {
      a3[2] = (uint64_t *)v6;
      v5 = 1;
    }
    else
    {
LABEL_15:
      v5 = 0;
    }
  }
  return (v6 != 0) & v5;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::SubtractOp &,mlir::mps::ConstantOp>(mlir::Float32Type **a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.add";
    v17[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::`anonymous namespace'::CanonicalizeBatchNormInference::~CanonicalizeBatchNormInference(mlir::mps::_anonymous_namespace_::CanonicalizeBatchNormInference *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeBatchNormInference::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  mlir::GenericProgramPoint *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __int128 *v14;
  __int128 v15;
  __int128 *v16;
  __int128 v17;
  mlir::GenericProgramPoint *v18;
  uint64_t v19;
  mlir::GenericProgramPoint *v20;
  unsigned int WeightsLayout;
  unsigned int StorageType;
  unsigned int PaddingStyle;
  uint64_t Rewriter;
  mlir::GenericProgramPoint *InputAttributeNames;
  mlir::GenericProgramPoint *Strides;
  char *Groups;
  mlir::GenericProgramPoint *v28;
  mlir::GenericProgramPoint *v29;
  mlir::GenericProgramPoint *v30;
  uint64_t v31;
  mlir::GenericProgramPoint *v32;
  mlir::GenericProgramPoint *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36[5];
  uint64_t v37;
  _QWORD v38[3];
  _QWORD v39[2];
  uint64_t v40;
  char *v41;
  mlir::GenericProgramPoint *v42;
  mlir::GenericProgramPoint *v43;
  mlir::GenericProgramPoint *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v47 = 0;
  v48 = a2;
  v3 = *(_QWORD *)(a2 + 24);
  v45 = 0;
  v46 = 0;
  v43 = 0;
  v44 = 0;
  v41 = 0;
  v42 = 0;
  v39[0] = &v47;
  v39[1] = &v46;
  v40 = 0;
  v38[1] = &v41;
  v38[2] = 0;
  v36[0] = (uint64_t)v38;
  v36[1] = (uint64_t)&v45;
  v36[2] = (uint64_t)&v44;
  v36[3] = (uint64_t)&v43;
  v36[4] = (uint64_t)&v42;
  v37 = 0;
  v38[0] = v39;
  *(_QWORD *)&v54 = a2;
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::NormalizationOp,void>::id)
    return 0;
  if ((*(_BYTE *)(a2 + 46) & 0x80) == 0)
    return 0;
  if (*(_DWORD *)(a2 + 68) != 5)
    return 0;
  LOBYTE(v52) = 1;
  *(_QWORD *)&v49 = &v52;
  *((_QWORD *)&v49 + 1) = &v54;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BiasAddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::NormalizationOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BiasAddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BiasAddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> & *)#1},0ul,1ul,2ul,3ul,4ul>(v36, (uint64_t)&v49);
  if (!(_BYTE)v52)
    return 0;
  v37 = v54;
  v35 = v40;
  if (mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v35) != (void *)1)
    return 0;
  if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35) == 1)
  {
    v34 = v45;
    v5 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v34);
    v49 = xmmword_1812408A0;
    v50 = unk_1812408B0;
    if (!mlir::mps::matchShape<mlir::Value>(v5, &v49, 4, -1))
      return 0;
    v33 = v44;
    v6 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v33);
    v54 = xmmword_1812408A0;
    v55 = unk_1812408B0;
    if (!mlir::mps::matchShape<mlir::Value>(v6, &v54, 4, -1))
      return 0;
    v32 = v43;
    v7 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v32);
    v52 = xmmword_1812408A0;
    v53 = unk_1812408B0;
    if ((mlir::mps::matchShape<mlir::Value>(v7, &v52, 4, -1) & 1) == 0)
      return 0;
  }
  if (!mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35))
  {
    v34 = v45;
    v10 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v34);
    v49 = xmmword_1812408E0;
    v50 = unk_1812408F0;
    if (!mlir::mps::matchShape<mlir::Value>(v10, &v49, 4, -1))
      return 0;
    v33 = v44;
    v11 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v33);
    v54 = xmmword_1812408E0;
    v55 = unk_1812408F0;
    if (!mlir::mps::matchShape<mlir::Value>(v11, &v54, 4, -1))
      return 0;
    v32 = v43;
    v12 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v32);
    v52 = xmmword_1812408E0;
    v53 = unk_1812408F0;
    if ((mlir::mps::matchShape<mlir::Value>(v12, &v52, 4, -1) & 1) == 0)
      return 0;
  }
  mlir::mps::InstanceNormOp::getEpsilon((mlir::mps::InstanceNormOp *)&v48, (uint64_t)&v49);
  LODWORD(v54) = llvm::APFloat::convertToFloat((void **)&v49);
  v8 = mlir::OpBuilder::create<mlir::mps::ConstantOp,float>(a3 + 1, v3, (float *)&v54);
  *(_QWORD *)&v52 = (char *)v8 - 16;
  v9 = (void *)*((_QWORD *)&v49 + 1);
  if (llvm::APFloatBase::PPCDoubleDouble(v8) == v9)
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)((char *)&v49 + 8));
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)((char *)&v49 + 8));
  *(_QWORD *)&v49 = mlir::getElementTypeOrSelf((uint64_t)v44 - 16);
  *(_QWORD *)&v52 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 1, v3, (uint64_t *)&v52, (uint64_t *)&v49)- 16;
  *(_QWORD *)&v49 = v44;
  v34 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
  if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35)
    || mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v35) != 3)
  {
    if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35)
      || mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v35) != 2)
    {
      goto LABEL_26;
    }
    v14 = &xmmword_1812408C0;
  }
  else
  {
    v14 = &xmmword_1812408A0;
  }
  v15 = v14[1];
  v54 = *v14;
  v55 = v15;
  llvm::SmallVector<long long,6u>::SmallVector(&v49, &v54, 4);
  v34 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>((mlir::Builder *)(a3 + 1), v3, &v34, (uint64_t)&v49)- 16;
  if ((__int128 *)v49 != &v50)
    free((void *)v49);
LABEL_26:
  v33 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 1, v3, &v34, (uint64_t *)&v52);
  v32 = mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,mlir::mps::AddOp &>((mlir::OpBuilder *)(a3 + 1), v3, &v33);
  *(_QWORD *)&v49 = v43;
  v31 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
  if (!mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35)
    && mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v35) == 3)
  {
    v16 = &xmmword_1812408A0;
    goto LABEL_32;
  }
  if (!mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35)
    && mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v35) == 2)
  {
    v16 = &xmmword_1812408C0;
LABEL_32:
    v17 = v16[1];
    v54 = *v16;
    v55 = v17;
    llvm::SmallVector<long long,6u>::SmallVector(&v49, &v54, 4);
    v31 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>((mlir::Builder *)(a3 + 1), v3, &v31, (uint64_t)&v49)- 16;
    if ((__int128 *)v49 != &v50)
      free((void *)v49);
  }
  *(_QWORD *)&v54 = (char *)mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::ReciprocalSquareRootOp &>(a3 + 1, v3, &v31, &v32)- 16;
  *(_QWORD *)&v49 = mlir::getElementTypeOrSelf(v46 - 16);
  v30 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 1, v3, (uint64_t *)&v54, (uint64_t *)&v49);
  *(_QWORD *)&v49 = v46;
  v29 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::ConstantOp,mlir::mps::CastOp &>(a3 + 1, v3, &v49, &v30);
  *(_QWORD *)&v49 = v47;
  Groups = (char *)mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v35);
  Strides = (mlir::GenericProgramPoint *)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v35);
  InputAttributeNames = (mlir::GenericProgramPoint *)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v35);
  Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v35);
  PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v35);
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35);
  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v35);
  v18 = mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value,mlir::mps::MultiplyOp &,unsigned long long,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::DenseIntElementsAttr,mlir::mps::PaddingStyle,mlir::mps::TensorDataLayout,mlir::mps::TensorDataLayout>((mlir::Builder *)(a3 + 1), v3, (uint64_t *)&v49, &v29, (uint64_t *)&Groups, (uint64_t *)&Strides, (uint64_t *)&InputAttributeNames, &Rewriter, &PaddingStyle, &StorageType, &WeightsLayout);
  Groups = v41;
  v28 = v18;
  if (!mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35))
  {
    *(_QWORD *)&v49 = &v50;
    v50 = xmmword_1812408E0;
    v51 = unk_1812408F0;
    *((_QWORD *)&v49 + 1) = 0x600000004;
    *(_QWORD *)&v54 = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>((mlir::Builder *)(a3 + 1), v3, (uint64_t *)&v54, (uint64_t)&v49)- 16;
    if ((__int128 *)v49 != &v50)
      free((void *)v49);
    *(_QWORD *)&v49 = &v50;
    v50 = xmmword_1812408E0;
    v51 = unk_1812408F0;
    *((_QWORD *)&v49 + 1) = 0x600000004;
    Groups = (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>((mlir::Builder *)(a3 + 1), v3, (uint64_t *)&Groups, (uint64_t)&v49)- 16;
    if ((__int128 *)v49 != &v50)
      free((void *)v49);
  }
  Rewriter = v45;
  InputAttributeNames = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::mps::ConstantOp,mlir::Value &>(a3 + 1, v3, &Rewriter, (uint64_t *)&Groups);
  Strides = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::ReciprocalSquareRootOp &>(a3 + 1, v3, (uint64_t *)&v54, &InputAttributeNames);
  *(_QWORD *)&v49 = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::mps::Conv2DOp &,mlir::mps::MultiplyOp>(a3 + 1, v3, &v28, &Strides);
  v19 = v48;
  Strides = v42;
  v20 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::SubtractOp &,mlir::mps::ConstantOp>(a3 + 1, *(_QWORD *)(v48 + 24), &v49, &Strides);
  (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, v19, v20);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::mps::ConstantOp,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.subtract", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.subtract";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3 - 16, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BiasAddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::NormalizationOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BiasAddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BiasAddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>*> & *)#1},0ul,1ul,2ul,3ul,4ul>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t DefiningOp;
  int v6;
  uint64_t v7;
  int v8;
  _QWORD *v9;
  uint64_t v10;
  _BOOL4 v11;
  char v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;
  char v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;
  char v20;
  uint64_t *v21;
  uint64_t v22;
  char v23;
  char v24;
  uint64_t *v25;
  uint64_t result;
  char v27;
  char v28;
  uint64_t v29;

  v4 = *a1;
  v29 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  v7 = DefiningOp;
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::BiasAddOp,void>::id
      && (*(_BYTE *)(DefiningOp + 46) & 0x80) != 0
      && *(_DWORD *)(DefiningOp + 68) == 2
      && ((v8 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::Conv2DOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(DefiningOp, 0, *(uint64_t ***)v4), v9 = *(_QWORD **)(v4 + 8), v10 = *(_QWORD *)(*(_QWORD *)(v7 + 72) + 56), !*v9)? (*v9 = v10, v11 = 1): (v11 = *v9 == v10), v6 = v8 & v11, v6 == 1))
    {
      *(_QWORD *)(v4 + 16) = v7;
    }
    else
    {
      LOBYTE(v6) = 0;
    }
  }
  v12 = v6 & (**(_BYTE **)a2 != 0);
  if (!v7)
    v12 = 0;
  **(_BYTE **)a2 = v12;
  v13 = (uint64_t *)a1[1];
  v29 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 56);
  v14 = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  if (v14)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(v14 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v13 || *v13 == v14))
    {
      *v13 = v14;
      v15 = 1;
    }
    else
    {
      v15 = 0;
    }
  }
  v16 = v15 & (**(_BYTE **)a2 != 0);
  if (!v14)
    v16 = 0;
  **(_BYTE **)a2 = v16;
  v17 = (uint64_t *)a1[2];
  v29 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 88);
  v18 = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  if (v18)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(v18 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v17 || *v17 == v18))
    {
      *v17 = v18;
      v19 = 1;
    }
    else
    {
      v19 = 0;
    }
  }
  v20 = v19 & (**(_BYTE **)a2 != 0);
  if (!v18)
    v20 = 0;
  **(_BYTE **)a2 = v20;
  v21 = (uint64_t *)a1[3];
  v29 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 120);
  v22 = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  if (v22)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(v22 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v21 || *v21 == v22))
    {
      *v21 = v22;
      v23 = 1;
    }
    else
    {
      v23 = 0;
    }
  }
  v24 = v23 & (**(_BYTE **)a2 != 0);
  if (!v22)
    v24 = 0;
  **(_BYTE **)a2 = v24;
  v25 = (uint64_t *)a1[4];
  v29 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 152);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v25 || *v25 == result))
    {
      *v25 = result;
      v27 = 1;
    }
    else
    {
      v27 = 0;
    }
  }
  v28 = v27 & (**(_BYTE **)a2 != 0);
  if (!result)
    v28 = 0;
  **(_BYTE **)a2 = v28;
  return result;
}

void mlir::mps::`anonymous namespace'::CanonicalizeTranspose::~CanonicalizeTranspose(mlir::mps::_anonymous_namespace_::CanonicalizeTranspose *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeTranspose::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t *v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t Filter;
  uint64_t v16;
  uint64_t Bias;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  int64x2_t *v22;
  unint64_t v23;
  uint64_t v24;
  BOOL v26;
  int64x2_t *v27;
  unint64_t v28;
  uint64_t v29;
  int64x2_t *v30;
  unint64_t v31;
  int64x2_t v32;
  int64x2_t *v33;
  int64x2_t v34;
  int64x2_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  _QWORD *v44;
  _QWORD *v45;
  unint64_t v46;
  unint64_t *v47;
  _QWORD *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t ArgAttrsAttr;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t *v58;
  unint64_t v59;
  uint64_t v60;
  int64x2_t *v61;
  int64x2_t v62;
  int64x2_t v63;
  uint64_t v64;
  int64x2_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int64x2_t v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  int64x2_t *v78;
  int64x2_t v79;
  uint64_t v80;
  int64x2_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t IntegerType;
  _QWORD *v88;
  _QWORD *v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  _QWORD *v93;
  _QWORD *v94;
  unint64_t v95;
  unint64_t *v96;
  _QWORD *v97;
  unint64_t v98;
  uint64_t v99;
  uint64_t v100;
  mlir::GenericProgramPoint *v101;
  _QWORD v102[2];
  uint64_t v103;
  unsigned __int8 v104;
  uint64_t Input;
  unint64_t v106;
  uint64_t *v107;
  _QWORD v108[2];
  uint64_t v109;
  void *v110;
  uint64_t v111;
  _BYTE v112[32];
  void *v113[2];
  uint64_t v114;
  void *v115[2];
  uint64_t v116;
  mlir::GenericProgramPoint *v117;
  uint64_t *v118;
  uint64_t v119;
  _QWORD v120[6];

  v120[4] = *MEMORY[0x1E0C80C00];
  v103 = a2;
  v4 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v103) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4)
    goto LABEL_10;
  v5 = *v4;
  v6 = mlir::TypeID::get<mlir::ShapedType>();
  v7 = *(unsigned int *)(v5 + 16);
  if (!(_DWORD)v7)
    goto LABEL_10;
  v8 = *(_QWORD **)(v5 + 8);
  v9 = &v8[2 * v7];
  do
  {
    v10 = v7 >> 1;
    v11 = &v8[2 * (v7 >> 1)];
    v13 = *v11;
    v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6)
      v8 = v12;
    else
      v7 = v10;
  }
  while (v7);
  if (v8 != v9 && *v8 == v6)
    v14 = v8[1];
  else
LABEL_10:
    v14 = 0;
  v102[0] = v4;
  v102[1] = v14;
  v115[0] = &v116;
  v115[1] = (void *)0x100000000;
  v113[0] = &v114;
  v113[1] = (void *)0x100000000;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v102)
    || (Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v103),
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v102),
        !mlir::getPositiveAxes(Filter, v16, (uint64_t)v115, 0, 0, 0))
    || (Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v103),
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v102),
        !mlir::getPositiveAxes(Bias, v18, (uint64_t)v113, 0, 0, 0)))
  {
    v24 = 0;
    goto LABEL_19;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v102);
  v110 = v112;
  v111 = 0x400000000;
  if (!v19)
  {
    v26 = 1;
    v27 = (int64x2_t *)v112;
    v22 = (int64x2_t *)v112;
    goto LABEL_36;
  }
  v20 = v19;
  if (v19 < 5)
  {
    v21 = 0;
    v22 = (int64x2_t *)v112;
    v23 = v19;
    goto LABEL_27;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v110, v112, v19, 8);
  v21 = v111;
  v22 = (int64x2_t *)v110;
  v23 = v20 - v111;
  if (v20 != v111)
LABEL_27:
    bzero((char *)v22 + 8 * v21, 8 * v23);
  LODWORD(v111) = v20;
  v27 = (int64x2_t *)((char *)v22 + 8 * v20);
  v26 = (_DWORD)v20 == 0;
  if ((_DWORD)v20)
  {
    v28 = (v20 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v28 >= 3)
    {
      v31 = v28 + 1;
      v29 = (v28 + 1) & 0x3FFFFFFFFFFFFFFCLL;
      v30 = (int64x2_t *)((char *)v22 + 8 * v29);
      v32 = (int64x2_t)xmmword_181233120;
      v33 = v22 + 1;
      v34 = vdupq_n_s64(2uLL);
      v35 = vdupq_n_s64(4uLL);
      v36 = v29;
      do
      {
        v33[-1] = v32;
        *v33 = vaddq_s64(v32, v34);
        v32 = vaddq_s64(v32, v35);
        v33 += 2;
        v36 -= 4;
      }
      while (v36);
      if (v31 == v29)
        goto LABEL_36;
    }
    else
    {
      v29 = 0;
      v30 = v22;
    }
    do
    {
      v30->i64[0] = v29;
      v30 = (int64x2_t *)((char *)v30 + 8);
      ++v29;
    }
    while (v30 != v27);
  }
  else
  {
    v26 = 1;
  }
LABEL_36:
  v37 = *(_QWORD *)v115[0];
  v38 = *(_QWORD *)v113[0];
  v39 = v22->i64[v37];
  v22->i64[v37] = v22->i64[v38];
  v22->i64[v38] = v39;
  v109 = v103;
  v40 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v109) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v40)
    goto LABEL_45;
  v41 = *v40;
  v42 = mlir::TypeID::get<mlir::ShapedType>();
  v43 = *(unsigned int *)(v41 + 16);
  if (!(_DWORD)v43)
    goto LABEL_45;
  v44 = *(_QWORD **)(v41 + 8);
  v45 = &v44[2 * v43];
  do
  {
    v46 = v43 >> 1;
    v47 = &v44[2 * (v43 >> 1)];
    v49 = *v47;
    v48 = v47 + 2;
    v43 += ~(v43 >> 1);
    if (v49 < v42)
      v44 = v48;
    else
      v43 = v46;
  }
  while (v43);
  if (v44 != v45 && *v44 == v42)
    v50 = v44[1];
  else
LABEL_45:
    v50 = 0;
  v108[0] = v40;
  v108[1] = v50;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v108);
  v52 = v51;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v108);
  v54 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v108);
  if (!v55)
    goto LABEL_57;
  v56 = (v55 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v56 >= 3)
  {
    v59 = v56 + 1;
    v60 = (v56 + 1) & 0x3FFFFFFFFFFFFFFCLL;
    v58 = (uint64_t *)(v54 + 8 * v60);
    v61 = (int64x2_t *)(v54 + 16);
    v62 = 0uLL;
    v63 = vdupq_n_s64(0x8000000000000000);
    v64 = v60;
    v65 = 0uLL;
    do
    {
      v62 = vsubq_s64(v62, vceqq_s64(v61[-1], v63));
      v65 = vsubq_s64(v65, vceqq_s64(*v61, v63));
      v61 += 2;
      v64 -= 4;
    }
    while (v64);
    v57 = vaddvq_s64(vaddq_s64(v65, v62));
    if (v59 == v60)
      goto LABEL_55;
  }
  else
  {
    v57 = 0;
    v58 = (uint64_t *)v54;
  }
  do
  {
    v66 = *v58++;
    if (v66 == 0x8000000000000000)
      ++v57;
  }
  while (v58 != (uint64_t *)(v54 + 8 * v55));
LABEL_55:
  if (v57 <= 1)
  {
LABEL_57:
    if (v26)
    {
LABEL_58:
      v118 = v120;
      v119 = 0x400000000;
      if (v52)
      {
        if (v52 < 5)
        {
          v67 = 0;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v118, v120, v52, 8);
          v67 = v119;
        }
        if (v52 != v67)
          bzero(&v118[v67], 8 * (v52 - v67));
        LODWORD(v119) = v52;
      }
      if (!v26)
      {
        v84 = v118;
        do
        {
          v85 = v22->i64[0];
          v22 = (int64x2_t *)((char *)v22 + 8);
          v86 = *(_QWORD *)(ArgAttrsAttr + 8 * v85);
          if (v86 == 0x8000000000000000)
            v86 = -1;
          *v84++ = v86;
        }
        while (v22 != v27);
      }
      v117 = (mlir::GenericProgramPoint *)v52;
      IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 8), 0x40u, 1);
      v88 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v117, 1, IntegerType, 0);
      v89 = v88;
      if (!v88)
        goto LABEL_97;
      v90 = *v88;
      v91 = mlir::TypeID::get<mlir::ShapedType>();
      v92 = *(unsigned int *)(v90 + 16);
      if (!(_DWORD)v92)
        goto LABEL_97;
      v93 = *(_QWORD **)(v90 + 8);
      v94 = &v93[2 * v92];
      do
      {
        v95 = v92 >> 1;
        v96 = &v93[2 * (v92 >> 1)];
        v98 = *v96;
        v97 = v96 + 2;
        v92 += ~(v92 >> 1);
        if (v98 < v91)
          v93 = v97;
        else
          v92 = v95;
      }
      while (v92);
      if (v93 != v94 && *v93 == v91)
        v99 = v93[1];
      else
LABEL_97:
        v99 = 0;
      v107 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v89, v99, v118, 8 * v119, 8, 1, 1);
      v117 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(v109 + 24), &v107);
      v100 = v109;
      v106 = *(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v109) + 8) & 0xFFFFFFFFFFFFFFF8;
      Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v109);
      v104 = 0;
      v101 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Type,mlir::Value,mlir::mps::ConstantOp &,BOOL>((mlir::UnitAttr **)(a3 + 8), *(_QWORD *)(v100 + 24), (uint64_t *)&v106, &Input, &v117, &v104);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v100, v101);
      if (v118 != v120)
        free(v118);
      v24 = 1;
      goto LABEL_101;
    }
    v68 = 0;
    v69 = 0;
    v70 = 0;
    v71 = vdupq_n_s64(1uLL);
    v72 = (uint64_t *)v22;
    while (1)
    {
      if (*v72 > v69)
        v69 = *v72;
      if (v70 == v69)
        break;
      ++v70;
LABEL_63:
      if (++v72 == (uint64_t *)v27)
        goto LABEL_58;
    }
    v73 = ArgAttrsAttr + 8 * v68;
    v74 = ArgAttrsAttr + 8 * v70;
    if (v73 == v74 + 8)
    {
LABEL_78:
      v69 = ++v70;
      v68 = v70;
      goto LABEL_63;
    }
    v75 = (v70 - v68) & 0x1FFFFFFFFFFFFFFFLL;
    if (v75 >= 3)
    {
      v77 = v75 + 1;
      v73 += 8 * (v77 & 0x3FFFFFFFFFFFFFFCLL);
      v78 = (int64x2_t *)(ArgAttrsAttr + 16 + 8 * v68);
      v79 = 0uLL;
      v80 = v77 & 0x3FFFFFFFFFFFFFFCLL;
      v81 = 0uLL;
      do
      {
        v79 = vsubq_s64(v79, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(v78[-1], v71)));
        v81 = vsubq_s64(v81, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(*v78, v71)));
        v78 += 2;
        v80 -= 4;
      }
      while (v80);
      v76 = vaddvq_s64(vaddq_s64(v81, v79));
      if (v77 == (v77 & 0x3FFFFFFFFFFFFFFCLL))
        goto LABEL_77;
    }
    else
    {
      v76 = 0;
    }
    v82 = v73 - 8;
    do
    {
      v83 = *(_QWORD *)(v82 + 8);
      v82 += 8;
      if (v83 != 1)
        ++v76;
    }
    while (v82 != v74);
LABEL_77:
    if (v76 > 1)
      goto LABEL_56;
    goto LABEL_78;
  }
LABEL_56:
  v24 = 0;
LABEL_101:
  if (v110 != v112)
    free(v110);
LABEL_19:
  if (v113[0] != &v114)
    free(v113[0]);
  if (v115[0] != &v116)
    free(v115[0]);
  return v24;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Type,mlir::Value,mlir::mps::ConstantOp &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, _QWORD *a5, unsigned __int8 *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.reshape";
    v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::ReshapeOp::build(a1, (uint64_t)v23, *a3, *a4, *a5 - 16, *a6);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::mps::`anonymous namespace'::CanonicalizePermute::~CanonicalizePermute(mlir::mps::_anonymous_namespace_::CanonicalizePermute *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizePermute::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t *v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t Filter;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  unint64_t v25;
  unint64_t *v26;
  _QWORD *v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t ArgAttrsAttr;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t *v37;
  unint64_t v38;
  uint64_t v39;
  int64x2_t *v40;
  int64x2_t v41;
  int64x2_t v42;
  uint64_t v43;
  int64x2_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int64x2_t v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  int64x2_t *v58;
  int64x2_t v59;
  uint64_t v60;
  int64x2_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t IntegerType;
  _QWORD *v71;
  _QWORD *v72;
  uint64_t v73;
  unint64_t v74;
  unint64_t v75;
  _QWORD *v76;
  _QWORD *v77;
  unint64_t v78;
  unint64_t *v79;
  _QWORD *v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  mlir::GenericProgramPoint *v84;
  _QWORD v85[2];
  uint64_t v86;
  unsigned __int8 v87;
  uint64_t Input;
  unint64_t v89;
  uint64_t *v90;
  _QWORD v91[2];
  uint64_t v92;
  void *v93;
  uint64_t v94;
  _BYTE v95[32];
  mlir::GenericProgramPoint *v96;
  void *v97;
  uint64_t v98;
  _QWORD v99[5];

  v99[4] = *MEMORY[0x1E0C80C00];
  v86 = a2;
  v4 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v86) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4)
    goto LABEL_10;
  v5 = *v4;
  v6 = mlir::TypeID::get<mlir::ShapedType>();
  v7 = *(unsigned int *)(v5 + 16);
  if (!(_DWORD)v7)
    goto LABEL_10;
  v8 = *(_QWORD **)(v5 + 8);
  v9 = &v8[2 * v7];
  do
  {
    v10 = v7 >> 1;
    v11 = &v8[2 * (v7 >> 1)];
    v13 = *v11;
    v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6)
      v8 = v12;
    else
      v7 = v10;
  }
  while (v7);
  if (v8 != v9 && *v8 == v6)
    v14 = v8[1];
  else
LABEL_10:
    v14 = 0;
  v85[0] = v4;
  v85[1] = v14;
  if (*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v86) + 8) >= 8uLL)
    mlir::TypeID::get<mlir::ShapedType>();
  v93 = v95;
  v94 = 0x400000000;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v85))
    goto LABEL_35;
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v86);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v85);
  if (!mlir::getPositiveAxes(Filter, v16, (uint64_t)&v93, 0, 0, 0))
    goto LABEL_35;
  v17 = (uint64_t *)v93;
  v18 = v94;
  v92 = v86;
  v19 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v92) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v19)
    goto LABEL_24;
  v20 = *v19;
  v21 = mlir::TypeID::get<mlir::ShapedType>();
  v22 = *(unsigned int *)(v20 + 16);
  if (!(_DWORD)v22)
    goto LABEL_24;
  v23 = *(_QWORD **)(v20 + 8);
  v24 = &v23[2 * v22];
  do
  {
    v25 = v22 >> 1;
    v26 = &v23[2 * (v22 >> 1)];
    v28 = *v26;
    v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21)
      v23 = v27;
    else
      v22 = v25;
  }
  while (v22);
  if (v23 != v24 && *v23 == v21)
    v29 = v23[1];
  else
LABEL_24:
    v29 = 0;
  v91[0] = v19;
  v91[1] = v29;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v91);
  v31 = v30;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v91);
  v33 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v91);
  if (v34)
  {
    v35 = (v34 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v35 >= 3)
    {
      v38 = v35 + 1;
      v39 = (v35 + 1) & 0x3FFFFFFFFFFFFFFCLL;
      v37 = (uint64_t *)(v33 + 8 * v39);
      v40 = (int64x2_t *)(v33 + 16);
      v41 = 0uLL;
      v42 = vdupq_n_s64(0x8000000000000000);
      v43 = v39;
      v44 = 0uLL;
      do
      {
        v41 = vsubq_s64(v41, vceqq_s64(v40[-1], v42));
        v44 = vsubq_s64(v44, vceqq_s64(*v40, v42));
        v40 += 2;
        v43 -= 4;
      }
      while (v43);
      v36 = vaddvq_s64(vaddq_s64(v44, v41));
      if (v38 == v39)
        goto LABEL_34;
    }
    else
    {
      v36 = 0;
      v37 = (uint64_t *)v33;
    }
    do
    {
      v45 = *v37++;
      if (v45 == 0x8000000000000000)
        ++v36;
    }
    while (v37 != (uint64_t *)(v33 + 8 * v34));
LABEL_34:
    if (v36 > 1)
    {
LABEL_35:
      v46 = 0;
      goto LABEL_36;
    }
  }
  if ((_DWORD)v18)
  {
    v48 = 0;
    v49 = 0;
    v50 = 0;
    v51 = vdupq_n_s64(1uLL);
    v52 = v17;
    while (1)
    {
      if (*v52 > v49)
        v49 = *v52;
      if (v50 == v49)
        break;
      ++v50;
LABEL_42:
      if (++v52 == &v17[v18])
        goto LABEL_58;
    }
    v53 = ArgAttrsAttr + 8 * v48;
    v54 = ArgAttrsAttr + 8 * v50;
    if (v53 == v54 + 8)
    {
LABEL_57:
      v49 = ++v50;
      v48 = v50;
      goto LABEL_42;
    }
    v55 = (v50 - v48) & 0x1FFFFFFFFFFFFFFFLL;
    if (v55 >= 3)
    {
      v57 = v55 + 1;
      v53 += 8 * (v57 & 0x3FFFFFFFFFFFFFFCLL);
      v58 = (int64x2_t *)(ArgAttrsAttr + 16 + 8 * v48);
      v59 = 0uLL;
      v60 = v57 & 0x3FFFFFFFFFFFFFFCLL;
      v61 = 0uLL;
      do
      {
        v59 = vsubq_s64(v59, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(v58[-1], v51)));
        v61 = vsubq_s64(v61, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(*v58, v51)));
        v58 += 2;
        v60 -= 4;
      }
      while (v60);
      v56 = vaddvq_s64(vaddq_s64(v61, v59));
      if (v57 == (v57 & 0x3FFFFFFFFFFFFFFCLL))
        goto LABEL_56;
    }
    else
    {
      v56 = 0;
    }
    v62 = v53 - 8;
    do
    {
      v63 = *(_QWORD *)(v62 + 8);
      v62 += 8;
      if (v63 != 1)
        ++v56;
    }
    while (v62 != v54);
LABEL_56:
    if (v56 > 1)
      goto LABEL_35;
    goto LABEL_57;
  }
LABEL_58:
  v97 = v99;
  v98 = 0x400000000;
  if (v31)
  {
    if (v31 < 5)
    {
      v64 = 0;
      v65 = v31;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v97, v99, v31, 8);
      v64 = v98;
      v65 = v31 - v98;
      if (v31 == v98)
        goto LABEL_65;
    }
    bzero((char *)v97 + 8 * v64, 8 * v65);
LABEL_65:
    LODWORD(v98) = v31;
  }
  if ((_DWORD)v18)
  {
    v66 = (uint64_t *)v97;
    v67 = 8 * v18;
    do
    {
      v68 = *v17++;
      v69 = *(_QWORD *)(ArgAttrsAttr + 8 * v68);
      if (v69 == 0x8000000000000000)
        v69 = -1;
      *v66++ = v69;
      v67 -= 8;
    }
    while (v67);
  }
  v96 = (mlir::GenericProgramPoint *)v31;
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 8), 0x40u, 1);
  v71 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v96, 1, IntegerType, 0);
  v72 = v71;
  if (!v71)
    goto LABEL_80;
  v73 = *v71;
  v74 = mlir::TypeID::get<mlir::ShapedType>();
  v75 = *(unsigned int *)(v73 + 16);
  if (!(_DWORD)v75)
    goto LABEL_80;
  v76 = *(_QWORD **)(v73 + 8);
  v77 = &v76[2 * v75];
  do
  {
    v78 = v75 >> 1;
    v79 = &v76[2 * (v75 >> 1)];
    v81 = *v79;
    v80 = v79 + 2;
    v75 += ~(v75 >> 1);
    if (v81 < v74)
      v76 = v80;
    else
      v75 = v78;
  }
  while (v75);
  if (v76 != v77 && *v76 == v74)
    v82 = v76[1];
  else
LABEL_80:
    v82 = 0;
  v90 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v72, v82, v97, 8 * v98, 8, 1, 1);
  v96 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(v92 + 24), &v90);
  v83 = v92;
  v89 = *(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v92) + 8) & 0xFFFFFFFFFFFFFFF8;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v92);
  v87 = 0;
  v84 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Type,mlir::Value,mlir::mps::ConstantOp &,BOOL>((mlir::UnitAttr **)(a3 + 8), *(_QWORD *)(v83 + 24), (uint64_t *)&v89, &Input, &v96, &v87);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v83, v84);
  if (v97 != v99)
    free(v97);
  v46 = 1;
LABEL_36:
  if (v93 != v95)
    free(v93);
  return v46;
}

void mlir::mps::`anonymous namespace'::CanonicalizeIdentity::~CanonicalizeIdentity(mlir::mps::_anonymous_namespace_::CanonicalizeIdentity *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::IdentityOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::IdentityOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::IdentityOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeIdentity::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *Input;
  uint64_t DefiningOp;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v9 = a2;
  Input = (_QWORD *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v9);
  if (*Input && !*(_QWORD *)*Input)
  {
    v10 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v9);
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v10);
    if (!DefiningOp)
      return DefiningOp;
    v7 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(DefiningOp + 48) + 32))(*(_QWORD *)(DefiningOp + 48), v7))
    {
      v8 = v9;
      v10 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v9);
      DefiningOp = 1;
      (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(_QWORD *)a3 + 24))(a3, v8, &v10, 1);
      return DefiningOp;
    }
  }
  return 0;
}

void mlir::mps::`anonymous namespace'::CanonicalizeConcat::~CanonicalizeConcat(mlir::mps::_anonymous_namespace_::CanonicalizeConcat *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ConcatOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ConcatOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ConcatOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeConcat::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::UnitAttr **a3)
{
  uint64_t Axis;
  unint64_t matched;
  char v6;
  unint64_t v7;
  uint64_t Values;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t *v20;
  _QWORD *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  mlir::GenericProgramPoint *v35;
  BOOL InferredResultTypes;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  _BYTE v42[32];
  void *v43;
  uint64_t v44;
  _QWORD v45[5];

  v45[4] = *MEMORY[0x1E0C80C00];
  v39 = a2;
  Axis = mlir::mps::ConcatOp::getAxis((mlir::mps::ConcatOp *)&v39);
  matched = mlir::matchConstantWithIntValue<long long>(Axis);
  if (!v6)
    return 0;
  v7 = matched;
  Values = mlir::mps::ConcatOp::getValues((mlir::mps::ConcatOp *)&v39);
  v43 = v45;
  v44 = 0x400000000;
  if (v9)
  {
    v10 = Values;
    v11 = v9;
    for (i = 0; i != v11; ++i)
    {
      v13 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(v10 + 32 * i + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v13)
        goto LABEL_15;
      v14 = *v13;
      v15 = mlir::TypeID::get<mlir::ShapedType>();
      v16 = *(unsigned int *)(v14 + 16);
      if (!(_DWORD)v16)
        goto LABEL_15;
      v17 = *(_QWORD **)(v14 + 8);
      v18 = &v17[2 * v16];
      do
      {
        v19 = v16 >> 1;
        v20 = &v17[2 * (v16 >> 1)];
        v22 = *v20;
        v21 = v20 + 2;
        v16 += ~(v16 >> 1);
        if (v22 < v15)
          v17 = v21;
        else
          v16 = v19;
      }
      while (v16);
      if (v17 != v18 && *v17 == v15)
        v23 = v17[1];
      else
LABEL_15:
        v23 = 0;
      v40 = v13;
      v41 = v23;
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v40))
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v40);
        if (v24)
        {
          v25 = v7;
          if ((v7 & 0x8000000000000000) != 0)
          {
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v40);
            v25 = v26 + v7;
          }
          if (!*(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v40) + 8 * v25))
          {
            v27 = v44;
            if (v44 >= (unint64_t)HIDWORD(v44))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 8);
              v27 = v44;
            }
            *((_QWORD *)v43 + v27) = i;
            LODWORD(v44) = v44 + 1;
          }
        }
      }
    }
    v28 = 0;
    if ((_DWORD)v44 && v11 != v44)
    {
      v29 = 0;
      v30 = 0;
      v40 = v42;
      v41 = 0x400000000;
      v31 = v43;
      v32 = (uint64_t *)(v10 + 24);
      do
      {
        if (v30 == *v31)
        {
          ++v31;
        }
        else
        {
          v33 = *v32;
          if (v29 >= HIDWORD(v41))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v42, v29 + 1, 8);
            v29 = v41;
          }
          *((_QWORD *)v40 + v29) = v33;
          v29 = v41 + 1;
          LODWORD(v41) = v41 + 1;
        }
        ++v30;
        v32 += 4;
      }
      while (v11 != v30);
      v34 = v39;
      v38 = mlir::mps::ConcatOp::getAxis((mlir::mps::ConcatOp *)&v39);
      InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v39);
      v35 = mlir::OpBuilder::create<mlir::mps::ConcatOp,llvm::SmallVector<mlir::Value,4u> &,mlir::Value,BOOL>(a3 + 1, *(_QWORD *)(v34 + 24), (uint64_t)&v40, &v38, (unsigned __int8 *)&InferredResultTypes);
      (*((void (**)(mlir::UnitAttr **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, v34, v35);
      if (v40 != v42)
        free(v40);
      v28 = 1;
    }
  }
  else
  {
    v28 = 0;
  }
  if (v43 != v45)
    free(v43);
  return v28;
}

unint64_t mlir::matchConstantWithIntValue<long long>(uint64_t a1)
{
  uint64_t DefiningOp;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  unint64_t SingleInt;
  unint64_t v8;
  uint64_t v9;
  uint64_t v11;
  void *v12[2];
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  v11 = a1;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (!DefiningOp)
    goto LABEL_10;
  v2 = DefiningOp;
  v3 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v2 + 48) + 32))(*(_QWORD *)(v2 + 48), v3))
    goto LABEL_10;
  v12[0] = v13;
  v12[1] = (void *)0x100000000;
  mlir::Operation::fold(v2, 0, 0, (uint64_t)v12);
  v5 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v12[0] & 0xFFFFFFFFFFFFFFF8));
  v6 = v5 ? v4 : 0;
  if (v12[0] != v13)
    free(v12[0]);
  if (v5)
  {
    SingleInt = mlir::getSingleIntValue<long long>((uint64_t)v5, v6);
    v8 = SingleInt & 0xFFFFFFFFFFFFFF00;
    v9 = SingleInt;
  }
  else
  {
LABEL_10:
    v9 = 0;
    v8 = 0;
  }
  return v8 | v9;
}

unint64_t mlir::getSingleIntValue<long long>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t *ArgAttrsAttr;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _QWORD v9[2];
  _QWORD v10[2];
  uint64_t v11;
  uint64_t v12;

  v11 = a1;
  v12 = a2;
  v10[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v11);
  v10[1] = v2;
  ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v10);
  if (mlir::ShapedType::getNumElements(ArgAttrsAttr, v4) == 1
    && (v9[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v11),
        v9[1] = v5,
        *(_UNKNOWN **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v9) + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id))
  {
    v9[0] = 0;
    mlir::copyElementsAttrData<long long>(v11, v12, (uint64_t)v9, 1);
    v7 = v9[0] & 0xFFFFFFFFFFFFFF00;
    v6 = LOBYTE(v9[0]);
  }
  else
  {
    v6 = 0;
    v7 = 0;
  }
  return v7 | v6;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConcatOp,llvm::SmallVector<mlir::Value,4u> &,mlir::Value,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  _QWORD v22[39];

  v22[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.concat", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.concat";
    v19[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v22);
    llvm::report_fatal_error((llvm::Twine *)v22, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v11);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::mps::ConcatOp::build(a1, (uint64_t)v22, v21[0], v21[1], *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v22);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConcatOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v14;
}

void mlir::mps::`anonymous namespace'::CanonicalizeOpsWith0Dims::~CanonicalizeOpsWith0Dims(mlir::mps::_anonymous_namespace_::CanonicalizeOpsWith0Dims *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeOpsWith0Dims::matchAndRewrite(mlir::mps::_anonymous_namespace_::CanonicalizeOpsWith0Dims *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  uint64_t v5;
  uint64_t Values;
  unsigned __int16 *v7;
  int v8;
  int v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  int v15;
  uint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char v21;
  uint64_t i;
  uint64_t NextResultAtOffset;
  uint64_t *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  unint64_t v30;
  unint64_t *v31;
  _QWORD *v32;
  unint64_t v33;
  uint64_t v34;
  _QWORD *ArgAttrsAttr;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t *v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t *v46;
  mlir::GenericProgramPoint *v47;
  mlir::Operation *v48;
  uint64_t InterfaceFor;
  mlir::Operation *v50;
  void *v51;
  uint64_t v52;
  _QWORD v53[22];

  v53[20] = *MEMORY[0x1E0C80C00];
  v50 = a2;
  v5 = *((_QWORD *)a2 + 6);
  if (*(_UNKNOWN **)(v5 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v51 = *(void **)(v5 + 8);
    Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v51);
  }
  else
  {
    Values = *(_QWORD *)(v5 + 24);
  }
  if (*(_QWORD *)(Values + 16) != 3
    || ((v7 = *(unsigned __int16 **)(Values + 8), v8 = *v7, v9 = *((unsigned __int8 *)v7 + 2), v8 == 28781)
      ? (v10 = v9 == 115)
      : (v10 = 0),
        !v10))
  {
    v11 = *((_QWORD *)a2 + 6);
    if (*(_UNKNOWN **)(v11 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      v51 = *(void **)(v11 + 8);
      v12 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v51);
    }
    else
    {
      v12 = *(_QWORD *)(v11 + 24);
    }
    if (*(_QWORD *)(v12 + 16) != 4 || **(_DWORD **)(v12 + 8) != 2020831341)
      return 0;
  }
  v13 = mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>>();
  if (((*(uint64_t (**)(_QWORD, void *))(**((_QWORD **)a2 + 6) + 32))(*((_QWORD *)a2 + 6), v13) & 1) != 0)
    return 0;
  v14 = mlir::TypeID::get<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>>();
  if (((*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)a2 + 6) + 32))(*((_QWORD *)a2 + 6), v14) & 1) != 0
    || *(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
  {
    return 0;
  }
  if (!mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a2))
  {
    v48 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v48 = a2;
  InterfaceFor = mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a2);
  if (!a2)
    return 0;
  v51 = v53;
  v52 = 0x400000000;
  mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v48, (uint64_t)&v51);
  v15 = v52;
  if (v51 != v53)
    free(v51);
  if (v15)
    return 0;
  v17 = *((unsigned int *)a2 + 9);
  v18 = (char *)a2 - 16;
  if ((_DWORD)v17)
    v19 = (char *)a2 - 16;
  else
    v19 = 0;
  v51 = v19;
  v52 = v17;
    return mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>((uint64_t)a3, (uint64_t *)&v50, "failed: all the operands are expected to return ShapedTypes");
  v20 = *((unsigned int *)a2 + 9);
  if (!(_DWORD)v20)
    v18 = 0;
  v21 = 0;
  if ((_DWORD)v20)
  {
    for (i = 0; i != v20; ++i)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v18, i);
      v24 = (uint64_t *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v24)
        goto LABEL_45;
      v25 = *v24;
      v26 = mlir::TypeID::get<mlir::ShapedType>();
      v27 = *(unsigned int *)(v25 + 16);
      if (!(_DWORD)v27)
        goto LABEL_45;
      v28 = *(_QWORD **)(v25 + 8);
      v29 = &v28[2 * v27];
      do
      {
        v30 = v27 >> 1;
        v31 = &v28[2 * (v27 >> 1)];
        v33 = *v31;
        v32 = v31 + 2;
        v27 += ~(v27 >> 1);
        if (v33 < v26)
          v28 = v32;
        else
          v27 = v30;
      }
      while (v27);
      if (v28 != v29 && *v28 == v26)
        v34 = v28[1];
      else
LABEL_45:
        v34 = 0;
      v51 = v24;
      v52 = v34;
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v51))
      {
        ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v51);
        if (v36)
        {
          v37 = 8 * v36;
          while (*ArgAttrsAttr)
          {
            ++ArgAttrsAttr;
            v37 -= 8;
            if (!v37)
              goto LABEL_35;
          }
          v38 = *((_QWORD *)a2 + 3);
          v46 = (uint64_t *)mlir::DenseElementsAttr::get((uint64_t)v51, v52, 0, 0);
          v47 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::MemRefType &,mlir::mps::MPSBufferTensorAttr &>((mlir::PatternRewriter *)((char *)a3 + 8), v38, (uint64_t *)&v51, &v46);
          v39 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v47);
          v40 = *(uint64_t **)NextResultAtOffset;
          if (*(_QWORD *)NextResultAtOffset)
          {
            v41 = (uint64_t *)v39;
            do
            {
              v42 = (uint64_t *)*v40;
              v43 = v40[2];
              (*(void (**)(mlir::PatternRewriter *, uint64_t))(*(_QWORD *)a3 + 72))(a3, v43);
              v44 = (uint64_t *)v40[1];
              if (v44)
              {
                *v44 = *v40;
                if (*v40)
                  *(_QWORD *)(*v40 + 8) = v40[1];
              }
              v40[3] = (uint64_t)v41;
              v40[1] = (uint64_t)v41;
              v45 = *v41;
              *v40 = *v41;
              if (v45)
                *(_QWORD *)(v45 + 8) = v40;
              *v41 = (uint64_t)v40;
              (*(void (**)(mlir::PatternRewriter *, uint64_t))(*(_QWORD *)a3 + 80))(a3, v43);
              v40 = v42;
            }
            while (v42);
          }
          v21 = 1;
        }
      }
LABEL_35:
      ;
    }
  }
  return v21 & 1;
}

uint64_t llvm::any_of<mlir::ResultRange,mlir::mps::`anonymous namespace'::CanonicalizeOpsWith0Dims::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::ResultRange)#1}>(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;

  v1 = a1[1];
  if (!v1)
    return 0;
  v2 = 0;
  v3 = *a1;
  while (1)
  {
    v4 = *(_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v3, v2) + 8) & 0xFFFFFFFFFFFFFFF8);
    v5 = mlir::TypeID::get<mlir::ShapedType>();
    v6 = *(unsigned int *)(v4 + 16);
    if (!(_DWORD)v6)
      break;
    v7 = *(_QWORD **)(v4 + 8);
    v8 = &v7[2 * v6];
    do
    {
      v9 = v6 >> 1;
      v10 = &v7[2 * (v6 >> 1)];
      v12 = *v10;
      v11 = v10 + 2;
      v6 += ~(v6 >> 1);
      if (v12 < v5)
        v7 = v11;
      else
        v6 = v9;
    }
    while (v6);
    if (v7 == v8 || *v7 != v5 || !v7[1])
      break;
    if (++v2 == v1)
      return 0;
  }
  return 1;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(uint64_t a1, uint64_t *a2, _BYTE *a3)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  _BYTE *v7;
  char v8;
  char v9;
  _QWORD *v10;

  v3 = 1;
  v9 = 1;
  if (*a3)
  {
    v7 = a3;
    v3 = 3;
  }
  v8 = v3;
  v4 = *a2;
  v10 = &v7;
  v5 = *(_QWORD *)(a1 + 16);
  if (!v5)
    return 0;
  result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v5 + 64))(v5, *(_QWORD *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  return result;
}

void *mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>>()
{
  unsigned __int8 v0;
  void **p_vtable;
  int v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v0 & 1) == 0)
  {
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    if (v3)
    {
      v11 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasRecursiveMemoryEffects<Empty>]";
      v12 = 97;
      v4 = llvm::StringRef::find((uint64_t *)&v11, "DesiredTypeName = ", 0x12uLL, 0);
      if (v12 >= v4)
        v5 = v4;
      else
        v5 = v12;
      v6 = &v11[v5];
      v7 = v12 - v5;
      if (v12 - v5 >= 0x12)
        v8 = 18;
      else
        v8 = v12 - v5;
      v9 = v7 - v8;
      if (v9 >= v9 - 1)
        v10 = v9 - 1;
      else
        v10 = v9;
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasRecursiveMemoryEffects<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasRecursiveMemoryEffects>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v6[v8], v10);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    }
  }
  return p_vtable[502];
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::Operation *&>(mlir::Operation *&,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

void mlir::mps::`anonymous namespace'::CastToFFT::~CastToFFT(mlir::mps::_anonymous_namespace_::CastToFFT *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::FastFourierTransformOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::FastFourierTransformOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::FastFourierTransformOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CastToFFT::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t ElementTypeOrSelf;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t result;
  mlir::GenericProgramPoint *v12;
  BOOL InferredResultTypes;
  unsigned int Layout;
  uint64_t v15;
  uint64_t **v16[2];
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23[4];
  __int16 v24;
  uint64_t *v25;

  v21 = 0;
  v22 = a2;
  v19 = &v21;
  v20 = 0;
  v17 = 0;
  v18 = 0;
  v16[0] = &v19;
  v16[1] = (uint64_t **)&v18;
  v25 = (uint64_t *)a2;
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::FastFourierTransformOp,void>::id
    || (*(_BYTE *)(a2 + 46) & 0x80) == 0
    || *(_DWORD *)(a2 + 68) != 2
    || (LOBYTE(v15) = 1,
        v23[0] = (uint64_t)&v15,
        v23[1] = (uint64_t)&v25,
        mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::CastOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::FastFourierTransformOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::CastOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::CastOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(v16, (uint64_t)v23), !(_BYTE)v15))
  {
    v9 = "could not detect cast -> fft op pattern";
    goto LABEL_12;
  }
  v17 = (uint64_t)v25;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v21 + 8) & 0xFFFFFFFFFFFFFFF8));
  v23[0] = v20;
  v6 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v23);
  v7 = mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(v6 + 8) & 0xFFFFFFFFFFFFFFF8));
  if (*(_UNKNOWN **)(*(_QWORD *)v7 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    v8 = v7;
  else
    v8 = 0;
  v15 = v8;
  if (v8)
  {
    if (ElementTypeOrSelf == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v15))
    {
      v23[0] = v21;
      v25 = (uint64_t *)v18;
      Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v22);
      InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v22);
      v12 = mlir::OpBuilder::create<mlir::mps::FastFourierTransformOp,mlir::Value,mlir::Value,mlir::mps::FFTScalingMode,BOOL>((mlir::UnitAttr **)(a3 + 8), *(_QWORD *)(a2 + 24), v23, (uint64_t *)&v25, &Layout, (unsigned __int8 *)&InferredResultTypes);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, a2, v12);
      return 1;
    }
    v9 = "underlying element-types must match in order to produce exactly the same output";
LABEL_12:
    v23[0] = (uint64_t)v9;
    v24 = 259;
    v25 = v23;
    v10 = *(_QWORD *)(a3 + 16);
    if (v10)
      goto LABEL_13;
    return 0;
  }
  v23[0] = (uint64_t)"cannot apply pattern unless output of cast is complex";
  v24 = 259;
  v25 = v23;
  v10 = *(_QWORD *)(a3 + 16);
  if (!v10)
    return 0;
LABEL_13:
  result = mlir::RewriterBase::Listener::classof(v10);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(_QWORD *)v10 + 64))(v10, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FastFourierTransformOp &>(mlir::mps::FastFourierTransformOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v25);
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::CastOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::FastFourierTransformOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::CastOp,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::CastOp,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t **v4;
  uint64_t result;
  char v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  char v11;
  uint64_t **v12;
  uint64_t *v13;
  BOOL v14;
  uint64_t v15;

  v4 = *a1;
  v15 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id
      || (*(_BYTE *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 1)
    {
      goto LABEL_7;
    }
    v7 = *(_QWORD *)(*(_QWORD *)(result + 72) + 24);
    v8 = **v4;
    if (v8)
    {
      if (v8 != v7)
      {
LABEL_7:
        v6 = 0;
        goto LABEL_8;
      }
    }
    else
    {
      **v4 = v7;
    }
    v4[1] = (uint64_t *)result;
    v6 = 1;
  }
LABEL_8:
  v9 = *(_BYTE **)a2;
  v10 = *(_QWORD *)(a2 + 8);
  v11 = v6 & (**(_BYTE **)a2 != 0);
  if (!result)
    v11 = 0;
  *v9 = v11;
  v12 = a1[1];
  v13 = *(uint64_t **)(*(_QWORD *)(*(_QWORD *)v10 + 72) + 56);
  if (*v12)
  {
    v14 = *v12 == v13;
  }
  else
  {
    *v12 = v13;
    v9 = *(_BYTE **)a2;
    v11 = **(_BYTE **)a2 != 0;
    v14 = 1;
  }
  *v9 = v14 & v11;
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::FastFourierTransformOp &>(mlir::mps::FastFourierTransformOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::FastFourierTransformOp,mlir::Value,mlir::Value,mlir::mps::FFTScalingMode,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned int *a5, unsigned __int8 *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.fast_fourier_transform", (const unsigned __int8 *)0x1A, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.fast_fourier_transform";
    v21[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::FastFourierTransformOp::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::FastFourierTransformOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

_QWORD *mlir::mps::`anonymous namespace'::CanonicalizeMatMulExpandSqueezeBinary<mlir::mps::AddOp>::~CanonicalizeMatMulExpandSqueezeBinary(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::CanonicalizeMatMulExpandSqueezeBinary<mlir::mps::AddOp>::~CanonicalizeMatMulExpandSqueezeBinary(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeMatMulExpandSqueezeBinary<mlir::mps::AddOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t SingleSqueezeIndex;
  char v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t v18;
  _BOOL4 IsNegated;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t SingleExpandedIndex;
  char v24;
  char *v25;
  uint64_t v26;
  uint64_t result;
  uint64_t v28;
  uint64_t v29;
  mlir::GenericProgramPoint *v30;
  mlir::Operation *v31;
  BOOL TransposeRhs;
  mlir::Operation *v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD v37[2];
  _QWORD v38[2];
  uint64_t v39;
  uint64_t v40;
  _QWORD v41[2];
  uint64_t v42;
  uint64_t v43;
  _QWORD v44[2];
  mlir::Operation *v45;
  _QWORD v46[2];
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD v52[4];
  __int16 v53;
  _QWORD *Input;

  v50 = 0;
  v51 = a2;
  v48 = 0;
  v49 = 0;
  v46[0] = &v50;
  v46[1] = &v49;
  v47 = 0;
  v44[0] = v46;
  v44[1] = &v48;
  v45 = 0;
  v42 = 0;
  v43 = 0;
  v41[0] = v44;
  v41[1] = &v43;
  v39 = 0;
  v40 = 0;
  v38[0] = v41;
  v38[1] = &v40;
  v37[0] = a2;
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
    return 0;
  if ((*(_BYTE *)(a2 + 46) & 0x80) == 0)
    return 0;
  if (*(_DWORD *)(a2 + 68) != 2)
    return 0;
  LOBYTE(Input) = 1;
  v52[0] = &Input;
  v52[1] = v37;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t)v38, (uint64_t)v52);
  if (!(_BYTE)Input)
    return 0;
  v39 = v37[0];
  if (!v6)
    return 0;
  v7 = SingleSqueezeIndex;
  v52[0] = v47;
  v8 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v52) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8)
    goto LABEL_15;
  v9 = *v8;
  v10 = mlir::TypeID::get<mlir::ShapedType>();
  v11 = *(unsigned int *)(v9 + 16);
  if (!(_DWORD)v11)
    goto LABEL_15;
  v12 = *(_QWORD **)(v9 + 8);
  v13 = &v12[2 * v11];
  do
  {
    v14 = v11 >> 1;
    v15 = &v12[2 * (v11 >> 1)];
    v17 = *v15;
    v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10)
      v12 = v16;
    else
      v11 = v14;
  }
  while (v11);
  if (v12 != v13 && *v12 == v10)
    v18 = v12[1];
  else
LABEL_15:
    v18 = 0;
  v37[0] = v8;
  v37[1] = v18;
  v52[0] = v45;
  IsNegated = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)v52);
  v20 = 1;
  if (IsNegated)
    v20 = 2;
  v21 = v20 + v7;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v37);
  if (v21 >= v22)
  {
    v52[0] = "cannot apply pattern if the squeeze is applied to the last two dimensions";
    v53 = 259;
    Input = v52;
    v26 = *(_QWORD *)(a3 + 16);
    if (v26)
      goto LABEL_24;
    return 0;
  }
  if (!v24)
    return 0;
  if (SingleExpandedIndex != v7)
  {
    v52[0] = "squeezed dimension and expanded dimension did not match";
    v53 = 259;
    Input = v52;
    v26 = *(_QWORD *)(a3 + 16);
    if (!v26)
      return 0;
LABEL_24:
    result = mlir::RewriterBase::Listener::classof(v26);
    if ((_DWORD)result)
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v26 + 64))(v26, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &Input);
    return result;
  }
  if (v7)
  {
    v25 = "cannot apply squeeze->matmul->add->expand pattern if the expand/squeeze dimension is not 0";
  }
  else
  {
    if (mlir::Operation::hasOneUse(v45))
    {
      v28 = *(_QWORD *)(v51 + 24);
      v36 = v47;
      Input = (_QWORD *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
      v35 = v48;
      v33 = v45;
      v34 = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v33);
      v31 = v45;
      TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v31);
      v52[0] = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value,mlir::Value,BOOL,BOOL>((mlir::BoolAttr **)(a3 + 8), v28, (uint64_t *)&Input, &v35, (unsigned __int8 *)&v34, (unsigned __int8 *)&TransposeRhs);
      v29 = *(_QWORD *)(v51 + 24);
      v36 = v42;
      Input = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v36);
      v30 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::MultiplyOp &,mlir::Value>((mlir::Float32Type **)(a3 + 8), v29, v52, (uint64_t *)&Input);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v51, v30);
      return 1;
    }
    v25 = "pattern should not be applied if matmul ops have more than one use";
  }
  return mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(a3, &v51, v25);
}

unint64_t mlir::mps::`anonymous namespace'::`anonymous namespace'::getSingleSqueezeIndex(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t ArgAttrsAttr;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  BOOL v42;
  _QWORD v43[2];
  _QWORD v44[2];
  uint64_t v45;
  _QWORD v46[2];
  _QWORD v47[4];
  __int16 v48;

  v45 = a1;
  v3 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3)
    goto LABEL_10;
  v4 = *v3;
  v5 = mlir::TypeID::get<mlir::ShapedType>();
  v6 = *(unsigned int *)(v4 + 16);
  if (!(_DWORD)v6)
    goto LABEL_10;
  v7 = *(_QWORD **)(v4 + 8);
  v8 = &v7[2 * v6];
  do
  {
    v9 = v6 >> 1;
    v10 = &v7[2 * (v6 >> 1)];
    v12 = *v10;
    v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5)
      v7 = v11;
    else
      v6 = v9;
  }
  while (v6);
  if (v7 != v8 && *v7 == v5)
    v13 = v7[1];
  else
LABEL_10:
    v13 = 0;
  v44[0] = v3;
  v44[1] = v13;
  v14 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14)
    goto LABEL_20;
  v15 = *v14;
  v16 = mlir::TypeID::get<mlir::ShapedType>();
  v17 = *(unsigned int *)(v15 + 16);
  if (!(_DWORD)v17)
    goto LABEL_20;
  v18 = *(_QWORD **)(v15 + 8);
  v19 = &v18[2 * v17];
  do
  {
    v20 = v17 >> 1;
    v21 = &v18[2 * (v17 >> 1)];
    v23 = *v21;
    v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16)
      v18 = v22;
    else
      v17 = v20;
  }
  while (v17);
  if (v18 != v19 && *v18 == v16)
    v24 = v18[1];
  else
LABEL_20:
    v24 = 0;
  v43[0] = v14;
  v43[1] = v24;
  v47[0] = v14;
  v47[1] = v24;
  v46[0] = v3;
  v46[1] = v13;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v46)
    || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v47)
    || (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47),
        v26 = v25,
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v46),
        v26 <= v27)
    && (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47), v28 >= 2))
  {
    v29 = "the pattern did not define a valid squeeze operation";
LABEL_26:
    v47[0] = v29;
    v48 = 259;
    v30 = v45;
    v46[0] = v47;
    v31 = *(_QWORD *)(a2 + 16);
    if (v31 && mlir::RewriterBase::Listener::classof(v31))
      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v31 + 64))(v31, *(_QWORD *)(v30 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v46);
    v32 = 0;
    v33 = 0;
    return v33 | v32;
  }
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v43);
  v36 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v44);
  if (v37)
  {
    v38 = 0;
    v39 = 0;
    v32 = -1;
    while (1)
    {
      v40 = *(_QWORD *)(ArgAttrsAttr + 8 * v38);
      v41 = *(_QWORD *)(v36 + 8 * v39);
      if (v40 != v41)
      {
        if (v40 != 1)
          break;
        ++v38;
        v42 = *(_QWORD *)(ArgAttrsAttr + 8 * v38) == v41 && v32 == -1;
        v32 = v39;
        if (!v42)
          break;
      }
      ++v38;
      if (v37 == ++v39)
        goto LABEL_44;
    }
    v29 = "cannot detect a squeeze over a single dimension";
    goto LABEL_26;
  }
  v32 = -1;
LABEL_44:
  v33 = v32 & 0xFFFFFFFFFFFFFF00;
  v32 = v32;
  return v33 | v32;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(uint64_t a1, uint64_t *a2, _BYTE *a3)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  _BYTE *v7;
  char v8;
  char v9;
  _QWORD *v10;

  v3 = 1;
  v9 = 1;
  if (*a3)
  {
    v7 = a3;
    v3 = 3;
  }
  v8 = v3;
  v4 = *a2;
  v10 = &v7;
  v5 = *(_QWORD *)(a1 + 16);
  if (!v5)
    return 0;
  result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v5 + 64))(v5, *(_QWORD *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  return result;
}

unint64_t mlir::mps::`anonymous namespace'::`anonymous namespace'::getSingleExpandedIndex(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t ArgAttrsAttr;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  BOOL v42;
  _QWORD v43[2];
  _QWORD v44[2];
  uint64_t v45;
  _QWORD v46[2];
  _QWORD v47[4];
  __int16 v48;

  v45 = a1;
  v3 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3)
    goto LABEL_10;
  v4 = *v3;
  v5 = mlir::TypeID::get<mlir::ShapedType>();
  v6 = *(unsigned int *)(v4 + 16);
  if (!(_DWORD)v6)
    goto LABEL_10;
  v7 = *(_QWORD **)(v4 + 8);
  v8 = &v7[2 * v6];
  do
  {
    v9 = v6 >> 1;
    v10 = &v7[2 * (v6 >> 1)];
    v12 = *v10;
    v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5)
      v7 = v11;
    else
      v6 = v9;
  }
  while (v6);
  if (v7 != v8 && *v7 == v5)
    v13 = v7[1];
  else
LABEL_10:
    v13 = 0;
  v44[0] = v3;
  v44[1] = v13;
  v14 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14)
    goto LABEL_20;
  v15 = *v14;
  v16 = mlir::TypeID::get<mlir::ShapedType>();
  v17 = *(unsigned int *)(v15 + 16);
  if (!(_DWORD)v17)
    goto LABEL_20;
  v18 = *(_QWORD **)(v15 + 8);
  v19 = &v18[2 * v17];
  do
  {
    v20 = v17 >> 1;
    v21 = &v18[2 * (v17 >> 1)];
    v23 = *v21;
    v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16)
      v18 = v22;
    else
      v17 = v20;
  }
  while (v17);
  if (v18 != v19 && *v18 == v16)
    v24 = v18[1];
  else
LABEL_20:
    v24 = 0;
  v43[0] = v14;
  v43[1] = v24;
  v47[0] = v3;
  v47[1] = v13;
  v46[0] = v14;
  v46[1] = v24;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v46)
    || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v47)
    || (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47),
        v26 = v25,
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v46),
        v26 <= v27)
    && (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47), v28 >= 2))
  {
    v29 = "the pattern did not define a valid expand operation";
LABEL_26:
    v47[0] = v29;
    v48 = 259;
    v30 = v45;
    v46[0] = v47;
    v31 = *(_QWORD *)(a2 + 16);
    if (v31 && mlir::RewriterBase::Listener::classof(v31))
      (*(void (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v31 + 64))(v31, *(_QWORD *)(v30 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v46);
    v32 = 0;
    v33 = 0;
    return v33 | v32;
  }
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v44);
  v36 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v43);
  if (v37)
  {
    v38 = 0;
    v39 = 0;
    v32 = -1;
    while (1)
    {
      v40 = *(_QWORD *)(ArgAttrsAttr + 8 * v38);
      v41 = *(_QWORD *)(v36 + 8 * v39);
      if (v40 != v41)
      {
        if (v40 != 1)
          break;
        ++v38;
        v42 = *(_QWORD *)(ArgAttrsAttr + 8 * v38) == v41 && v32 == -1;
        v32 = v39;
        if (!v42)
          break;
      }
      ++v38;
      if (v37 == ++v39)
        goto LABEL_44;
    }
    v29 = "cannot detect a squeeze over a single dimension";
    goto LABEL_26;
  }
  v32 = -1;
LABEL_44:
  v33 = v32 & 0xFFFFFFFFFFFFFF00;
  v32 = v32;
  return v33 | v32;
}

BOOL mlir::Operation::hasOneUse(mlir::Operation *this)
{
  uint64_t v1;
  char *v2;
  uint64_t v3;
  _OWORD v5[2];
  uint64_t v6;
  uint64_t v7;
  _OWORD v8[2];
  uint64_t v9;

  v1 = *((unsigned int *)this + 9);
  v2 = (char *)this - 16;
  if (!(_DWORD)v1)
    v2 = 0;
  *(_QWORD *)&v8[0] = v2;
  *((_QWORD *)&v8[0] + 1) = v1;
  mlir::ResultRange::getUses((uint64_t *)v8, (uint64_t *)v5);
  v3 = v7;
  if (v6 == v7)
    return 0;
  v8[0] = v5[0];
  v8[1] = v5[1];
  v9 = v6;
  mlir::ResultRange::UseIterator::operator++((uint64_t *)v8);
  return v9 == v3;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t result;
  BOOL v6;
  uint64_t v7;
  int v8;
  BOOL *v9;
  BOOL v10;
  _QWORD *v11;
  uint64_t v12;
  BOOL v13;
  _QWORD v14[2];
  unsigned __int8 v15;
  uint64_t v16;

  v4 = *(uint64_t **)a1;
  v14[0] = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)v14);
  v7 = result;
  if (result)
  {
    v16 = result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id
      && (*(_BYTE *)(result + 46) & 0x80) != 0
      && *(_DWORD *)(result + 68) == 2)
    {
      v15 = 1;
      v14[0] = &v15;
      v14[1] = &v16;
      result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(v4, (uint64_t)v14);
      v8 = v15;
      if (v15)
        v4[2] = v16;
      v6 = v8 != 0;
    }
    else
    {
      v6 = 0;
    }
  }
  v9 = *(BOOL **)a2;
  v10 = v6 && **(_BYTE **)a2 != 0;
  if (!v7)
    v10 = 0;
  *v9 = v10;
  v11 = *(_QWORD **)(a1 + 8);
  v12 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 56);
  if (*v11)
  {
    v13 = *v11 == v12;
  }
  else
  {
    *v11 = v12;
    v9 = *(BOOL **)a2;
    v10 = **(_BYTE **)a2 != 0;
    v13 = 1;
  }
  *v9 = v13 && v10;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  BOOL v6;
  uint64_t v7;
  int v8;
  BOOL *v9;
  BOOL v10;
  _QWORD *v11;
  uint64_t v12;
  BOOL v13;
  _QWORD v14[2];
  unsigned __int8 v15;
  uint64_t v16;

  v4 = *a1;
  v14[0] = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)v14);
  v7 = result;
  if (result)
  {
    v16 = result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id
      && (*(_BYTE *)(result + 46) & 0x80) != 0
      && *(_DWORD *)(result + 68) == 2)
    {
      v15 = 1;
      v14[0] = &v15;
      v14[1] = &v16;
      result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t ***)v4, (uint64_t)v14);
      v8 = v15;
      if (v15)
        *(_QWORD *)(v4 + 16) = v16;
      v6 = v8 != 0;
    }
    else
    {
      v6 = 0;
    }
  }
  v9 = *(BOOL **)a2;
  v10 = v6 && **(_BYTE **)a2 != 0;
  if (!v7)
    v10 = 0;
  *v9 = v10;
  v11 = (_QWORD *)a1[1];
  v12 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 56);
  if (*v11)
  {
    v13 = *v11 == v12;
  }
  else
  {
    *v11 = v12;
    v9 = *(BOOL **)a2;
    v10 = **(_BYTE **)a2 != 0;
    v13 = 1;
  }
  *v9 = v13 && v10;
  return result;
}

_QWORD *mlir::mps::`anonymous namespace'::CanonicalizeMatMulExpandSqueezeUnary<mlir::mps::ReluOp>::~CanonicalizeMatMulExpandSqueezeUnary(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::CanonicalizeMatMulExpandSqueezeUnary<mlir::mps::ReluOp>::~CanonicalizeMatMulExpandSqueezeUnary(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeMatMulExpandSqueezeUnary<mlir::mps::ReluOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t SingleSqueezeIndex;
  char v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t v18;
  _BOOL4 IsNegated;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t SingleExpandedIndex;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t result;
  uint64_t v29;
  uint64_t v30;
  mlir::GenericProgramPoint *v31;
  uint64_t v32;
  BOOL TransposeRhs;
  uint64_t v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD v38[2];
  _QWORD v39[2];
  uint64_t v40;
  uint64_t v41;
  _QWORD v42[2];
  _QWORD v43[2];
  uint64_t v44;
  _QWORD v45[2];
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _OWORD v51[2];
  uint64_t v52;
  uint64_t v53;
  _OWORD v54[2];
  uint64_t v55;

  v49 = 0;
  v50 = a2;
  v47 = 0;
  v48 = 0;
  v45[0] = &v49;
  v45[1] = &v48;
  v46 = 0;
  v43[0] = v45;
  v43[1] = &v47;
  v44 = 0;
  v42[0] = v43;
  v42[1] = 0;
  v40 = 0;
  v41 = 0;
  v39[0] = v42;
  v39[1] = &v41;
  *(_QWORD *)&v54[0] = a2;
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
    return 0;
  if ((*(_BYTE *)(a2 + 46) & 0x80) == 0)
    return 0;
  if (*(_DWORD *)(a2 + 68) != 2)
    return 0;
  LOBYTE(v38[0]) = 1;
  *(_QWORD *)&v51[0] = v38;
  *((_QWORD *)&v51[0] + 1) = v54;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReluOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReluOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReluOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t)v39, (uint64_t)v51);
  if (!LOBYTE(v38[0]))
    return 0;
  v40 = *(_QWORD *)&v54[0];
  if (!v6)
    return 0;
  v7 = SingleSqueezeIndex;
  *(_QWORD *)&v51[0] = v46;
  v8 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)v51) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8)
    goto LABEL_15;
  v9 = *v8;
  v10 = mlir::TypeID::get<mlir::ShapedType>();
  v11 = *(unsigned int *)(v9 + 16);
  if (!(_DWORD)v11)
    goto LABEL_15;
  v12 = *(_QWORD **)(v9 + 8);
  v13 = &v12[2 * v11];
  do
  {
    v14 = v11 >> 1;
    v15 = &v12[2 * (v11 >> 1)];
    v17 = *v15;
    v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10)
      v12 = v16;
    else
      v11 = v14;
  }
  while (v11);
  if (v12 != v13 && *v12 == v10)
    v18 = v12[1];
  else
LABEL_15:
    v18 = 0;
  v38[0] = v8;
  v38[1] = v18;
  *(_QWORD *)&v51[0] = v44;
  IsNegated = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)v51);
  v20 = 1;
  if (IsNegated)
    v20 = 2;
  v21 = v20 + v7;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v38);
  if (v21 >= v22)
  {
    *(_QWORD *)&v51[0] = "cannot apply pattern if the squeeze is applied to the last two dimensions";
    LOWORD(v52) = 259;
    *(_QWORD *)&v54[0] = v51;
    v29 = *(_QWORD *)(a3 + 16);
    if (!v29)
      return 0;
  }
  else
  {
    if (!v24)
      return 0;
    if (SingleExpandedIndex == v7)
    {
      v25 = *(unsigned int *)(v44 + 36);
      v26 = v44 - 16;
      if (!(_DWORD)v25)
        v26 = 0;
      *(_QWORD *)&v54[0] = v26;
      *((_QWORD *)&v54[0] + 1) = v25;
      mlir::ResultRange::getUses((uint64_t *)v54, (uint64_t *)v51);
      v27 = v53;
      if (v52 == v53)
        return mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(a3, &v50, "pattern should not be applied if matmul ops have more than one use");
      v54[0] = v51[0];
      v54[1] = v51[1];
      v55 = v52;
      mlir::ResultRange::UseIterator::operator++((uint64_t *)v54);
      if (v55 != v27)
        return mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(a3, &v50, "pattern should not be applied if matmul ops have more than one use");
      v30 = *(_QWORD *)(a2 + 24);
      v37 = v46;
      *(_QWORD *)&v54[0] = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
      v36 = v47;
      v34 = v44;
      v35 = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v34);
      v32 = v44;
      TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v32);
      *(_QWORD *)&v51[0] = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value,mlir::Value,BOOL,BOOL>((mlir::BoolAttr **)(a3 + 8), v30, (uint64_t *)v54, &v36, (unsigned __int8 *)&v35, (unsigned __int8 *)&TransposeRhs);
      v31 = mlir::OpBuilder::create<mlir::mps::ReluOp,mlir::mps::MatMulOp &>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), v51);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, a2, v31);
      return 1;
    }
    *(_QWORD *)&v51[0] = "squeezed dimension and expanded dimension did not match";
    LOWORD(v52) = 259;
    *(_QWORD *)&v54[0] = v51;
    v29 = *(_QWORD *)(a3 + 16);
    if (!v29)
      return 0;
  }
  result = mlir::RewriterBase::Listener::classof(v29);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _OWORD *))(*(_QWORD *)v29 + 64))(v29, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::ReshapeOp &>(mlir::mps::ReshapeOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v54);
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReluOp,mlir::mps::MatMulOp &>(mlir::OpBuilder *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.relu", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.relu";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3 - 16);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReluOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReluOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReluOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReluOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t result;
  BOOL v6;
  uint64_t v7;
  int v8;
  BOOL *v9;
  BOOL v10;
  _QWORD *v11;
  uint64_t v12;
  BOOL v13;
  _QWORD v14[2];
  unsigned __int8 v15;
  uint64_t v16;

  v4 = *(uint64_t **)a1;
  v14[0] = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)v14);
  v7 = result;
  if (result)
  {
    v16 = result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReluOp,void>::id
      && (*(_BYTE *)(result + 46) & 0x80) != 0
      && *(_DWORD *)(result + 68) == 1)
    {
      v15 = 1;
      v14[0] = &v15;
      v14[1] = &v16;
      result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReluOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *> & *)#1},0ul>(v4, (uint64_t)v14);
      v8 = v15;
      if (v15)
        v4[1] = v16;
      v6 = v8 != 0;
    }
    else
    {
      v6 = 0;
    }
  }
  v9 = *(BOOL **)a2;
  v10 = v6 && **(_BYTE **)a2 != 0;
  if (!v7)
    v10 = 0;
  *v9 = v10;
  v11 = *(_QWORD **)(a1 + 8);
  v12 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 56);
  if (*v11)
  {
    v13 = *v11 == v12;
  }
  else
  {
    *v11 = v12;
    v9 = *(BOOL **)a2;
    v10 = **(_BYTE **)a2 != 0;
    v13 = 1;
  }
  *v9 = v13 && v10;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReluOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *> & *)#1},0ul>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;
  BOOL v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  _QWORD v9[2];
  unsigned __int8 v10;
  uint64_t v11;

  v3 = *a1;
  v9[0] = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)v9);
  v6 = result;
  if (result)
  {
    v11 = result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id
      && (*(_BYTE *)(result + 46) & 0x80) != 0
      && *(_DWORD *)(result + 68) == 2)
    {
      v10 = 1;
      v9[0] = &v10;
      v9[1] = &v11;
      result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t ***)v3, (uint64_t)v9);
      v7 = v10;
      if (v10)
        *(_QWORD *)(v3 + 16) = v11;
      v5 = v7 != 0;
    }
    else
    {
      v5 = 0;
    }
  }
  v8 = v5 && **(_BYTE **)a2 != 0;
  if (!v6)
    v8 = 0;
  **(_BYTE **)a2 = v8;
  return result;
}

void mlir::mps::`anonymous namespace'::CanonicalizeSoftMax::~CanonicalizeSoftMax(mlir::mps::_anonymous_namespace_::CanonicalizeSoftMax *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeSoftMax::matchAndRewrite(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _BOOL4 InferredResultTypes;
  BOOL v17;
  mlir::GenericProgramPoint *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  _QWORD v24[2];
  uint64_t v25;
  _QWORD v26[2];
  uint64_t v27;
  uint64_t v28;
  _QWORD v29[2];
  _QWORD v30[3];
  _QWORD v31[2];
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35[4];
  __int16 v36;
  uint64_t *v37;

  v33 = 0;
  v34 = 0;
  v31[0] = &v34;
  v31[1] = &v33;
  v32 = 0;
  v30[0] = &v34;
  v30[1] = v31;
  v30[2] = 0;
  v29[0] = v30;
  v29[1] = 0;
  v27 = 0;
  v28 = 0;
  v26[0] = v29;
  v26[1] = &v28;
  v24[0] = v29;
  v24[1] = v26;
  v25 = 0;
  v22 = (uint64_t *)a2;
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id
    && (*(_BYTE *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 2)
  {
    LOBYTE(v37) = 1;
    v35[0] = (uint64_t)&v37;
    v35[1] = (uint64_t)&v22;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DivideOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder> *> & *)#1},0ul,1ul>((uint64_t)v24, (uint64_t)v35);
    if ((_BYTE)v37)
    {
      v25 = (uint64_t)v22;
      v5 = (uint64_t *)(*(_QWORD *)(v34 + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v5)
        goto LABEL_14;
      v6 = *v5;
      v7 = mlir::TypeID::get<mlir::ShapedType>();
      v8 = *(unsigned int *)(v6 + 16);
      if (!(_DWORD)v8)
        goto LABEL_14;
      v9 = *(_QWORD **)(v6 + 8);
      v10 = &v9[2 * v8];
      do
      {
        v11 = v8 >> 1;
        v12 = &v9[2 * (v8 >> 1)];
        v14 = *v12;
        v13 = v12 + 2;
        v8 += ~(v8 >> 1);
        if (v14 < v7)
          v9 = v13;
        else
          v8 = v11;
      }
      while (v8);
      if (v9 != v10 && *v9 == v7)
        v15 = v9[1];
      else
LABEL_14:
        v15 = 0;
      v22 = v5;
      v23 = v15;
      if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v22) & 1) != 0)
      {
        {
          return 0;
        }
        v35[0] = v32;
        InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)v35);
        v35[0] = v27;
        v17 = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)v35);
        if (InferredResultTypes && v17)
        {
          v35[0] = v34;
          v37 = v33;
          v18 = mlir::OpBuilder::create<mlir::mps::SoftmaxOp,mlir::Value,mlir::Value>((mlir::OpBuilder *)(a3 + 1), *(_QWORD *)(a2 + 24), v35, (uint64_t *)&v37);
          (*(void (**)(_QWORD *, uint64_t, mlir::GenericProgramPoint *))(*a3 + 32))(a3, a2, v18);
          return 1;
        }
        v35[0] = (uint64_t)"failed: reductions must keep dimensions to represent a softmax op";
        v36 = 259;
        v37 = v35;
        v21 = a3[2];
        if (!v21)
          return 0;
        goto LABEL_26;
      }
      v35[0] = (uint64_t)"failed: input is unranked";
      v36 = 259;
      v37 = v35;
      v21 = a3[2];
      if (v21)
      {
LABEL_26:
        result = mlir::RewriterBase::Listener::classof(v21);
        if ((_DWORD)result)
          return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(_QWORD *)v21 + 64))(v21, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DivideOp &>(mlir::mps::DivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v37);
        return result;
      }
      return 0;
    }
  }
  v35[0] = (uint64_t)"failed: pattern did not match";
  v36 = 259;
  v22 = v35;
  v20 = a3[2];
  if (!v20)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v20);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(_QWORD *)v20 + 64))(v20, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DivideOp &>(mlir::mps::DivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v22);
  return result;
}

BOOL mlir::mps::`anonymous namespace'::CanonicalizeSoftMax::verifyFastestRunningIndex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char matched;
  _BOOL8 v4;
  void *v5;
  uint64_t v6;
  _QWORD v8[2];
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v8[0] = a2;
  v8[1] = a3;
  v9 = v11;
  v10 = 0x600000000;
  matched = mlir::matchConstantWithIntVector<long long>(a1, (uint64_t)&v9);
  v4 = 0;
  v5 = v9;
  if (matched && (_DWORD)v10 == 1)
  {
    if (*(_QWORD *)v9 != -1)
    {
      if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v8) & 1) != 0)
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v8);
        v5 = v9;
        v4 = *(_QWORD *)v9 == v6 - 1;
        if (v9 == v11)
          return v4;
      }
      else
      {
        v4 = 0;
        v5 = v9;
        if (v9 == v11)
          return v4;
      }
      goto LABEL_9;
    }
    v4 = 1;
  }
  if (v9 != v11)
LABEL_9:
    free(v5);
  return v4;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DivideOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder> *> & *)#1},0ul,1ul>(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t DefiningOp;
  BOOL v6;
  uint64_t v7;
  int v8;
  BOOL v9;
  uint64_t v10;
  uint64_t result;
  BOOL v12;
  uint64_t v13;
  int v14;
  BOOL v15;
  unsigned __int8 *v16;
  uint64_t *v17;
  unsigned __int8 v18;
  uint64_t v19;

  v4 = *(uint64_t **)a1;
  v16 = *(unsigned __int8 **)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v16);
  v7 = DefiningOp;
  if (DefiningOp)
  {
    v19 = DefiningOp;
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExponentOp,void>::id
      && (*(_BYTE *)(DefiningOp + 46) & 0x80) != 0
      && *(_DWORD *)(DefiningOp + 68) == 1)
    {
      v18 = 1;
      v16 = &v18;
      v17 = &v19;
      mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>> *> & *)#1},0ul>(v4, (uint64_t)&v16);
      v8 = v18;
      if (v18)
        v4[1] = v19;
      v6 = v8 != 0;
    }
    else
    {
      v6 = 0;
    }
  }
  v9 = v6 && **(_BYTE **)a2 != 0;
  if (!v7)
    v9 = 0;
  **(_BYTE **)a2 = v9;
  v10 = *(_QWORD *)(a1 + 8);
  v16 = *(unsigned __int8 **)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 56);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v16);
  v13 = result;
  if (result)
  {
    v19 = result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id
      && (*(_BYTE *)(result + 46) & 0x80) != 0
      && *(_DWORD *)(result + 68) == 2)
    {
      v18 = 1;
      v16 = &v18;
      v17 = &v19;
      result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(v10, (uint64_t)&v16);
      v14 = v18;
      if (v18)
        *(_QWORD *)(v10 + 16) = v19;
      v12 = v14 != 0;
    }
    else
    {
      v12 = 0;
    }
  }
  v15 = v12 && **(_BYTE **)a2 != 0;
  if (!v13)
    v15 = 0;
  **(_BYTE **)a2 = v15;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>> *> & *)#1},0ul>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;
  BOOL v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  _QWORD v9[2];
  unsigned __int8 v10;
  uint64_t v11;

  v3 = *a1;
  v9[0] = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)v9);
  v6 = result;
  if (result)
  {
    v11 = result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id
      && (*(_BYTE *)(result + 46) & 0x80) != 0
      && *(_DWORD *)(result + 68) == 2)
    {
      v10 = 1;
      v9[0] = &v10;
      v9[1] = &v11;
      result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *> & *)#1},0ul,1ul>((uint64_t **)v3, (uint64_t)v9);
      v7 = v10;
      if (v10)
        *(_QWORD *)(v3 + 16) = v11;
      v5 = v7 != 0;
    }
    else
    {
      v5 = 0;
    }
  }
  v8 = v5 && **(_BYTE **)a2 != 0;
  if (!v6)
    v8 = 0;
  **(_BYTE **)a2 = v8;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *> & *)#1},0ul,1ul>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t **v7;
  uint64_t result;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BOOL4 v13;
  uint64_t *v14;
  uint64_t v15;
  _BOOL4 v16;
  char v17;
  uint64_t v18;

  v3 = *(_QWORD *)(**(_QWORD **)(a2 + 8) + 72);
  v4 = *(_QWORD *)(v3 + 24);
  v5 = **a1;
  if (v5)
  {
    v6 = v5 == v4;
  }
  else
  {
    **a1 = v4;
    v3 = *(_QWORD *)(**(_QWORD **)(a2 + 8) + 72);
    v6 = 1;
  }
  if (!**(_BYTE **)a2)
    v6 = 0;
  **(_BYTE **)a2 = v6;
  v7 = (uint64_t **)a1[1];
  v18 = *(_QWORD *)(v3 + 56);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v18);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::ReductionMaxOp,void>::id
      || (*(_BYTE *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 2)
    {
      goto LABEL_19;
    }
    v10 = *(_QWORD *)(result + 72);
    v11 = *(_QWORD *)(v10 + 24);
    v12 = **v7;
    if (v12)
    {
      v13 = v12 == v11;
    }
    else
    {
      **v7 = v11;
      v10 = *(_QWORD *)(result + 72);
      v13 = 1;
    }
    v14 = v7[1];
    v15 = *(_QWORD *)(v10 + 56);
    if (*v14)
    {
      v16 = *v14 == v15;
    }
    else
    {
      *v14 = v15;
      v16 = 1;
    }
    v9 = v13 && v16;
    if (v9 == 1)
      v7[2] = (uint64_t *)result;
    else
LABEL_19:
      LOBYTE(v9) = 0;
  }
  v17 = v9 & (**(_BYTE **)a2 != 0);
  if (!result)
    v17 = 0;
  **(_BYTE **)a2 = v17;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionSumOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t result;
  BOOL v6;
  uint64_t v7;
  int v8;
  BOOL *v9;
  BOOL v10;
  _QWORD *v11;
  uint64_t v12;
  BOOL v13;
  _QWORD v14[2];
  unsigned __int8 v15;
  uint64_t v16;

  v4 = *(uint64_t **)a1;
  v14[0] = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)v14);
  v7 = result;
  if (result)
  {
    v16 = result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExponentOp,void>::id
      && (*(_BYTE *)(result + 46) & 0x80) != 0
      && *(_DWORD *)(result + 68) == 1)
    {
      v15 = 1;
      v14[0] = &v15;
      v14[1] = &v16;
      result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ExponentOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SubtractOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReductionMaxOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>> *> & *)#1},0ul>(v4, (uint64_t)v14);
      v8 = v15;
      if (v15)
        v4[1] = v16;
      v6 = v8 != 0;
    }
    else
    {
      v6 = 0;
    }
  }
  v9 = *(BOOL **)a2;
  v10 = v6 && **(_BYTE **)a2 != 0;
  if (!v7)
    v10 = 0;
  *v9 = v10;
  v11 = *(_QWORD **)(a1 + 8);
  v12 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 56);
  if (*v11)
  {
    v13 = *v11 == v12;
  }
  else
  {
    *v11 = v12;
    v9 = *(BOOL **)a2;
    v10 = **(_BYTE **)a2 != 0;
    v13 = 1;
  }
  *v9 = v13 && v10;
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::DivideOp &>(mlir::mps::DivideOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

uint64_t mlir::matchConstantWithIntVector<long long>(uint64_t a1, uint64_t a2)
{
  uint64_t DefiningOp;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[2];
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16[2];
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v14 = 0;
  if (!a1)
    return 0;
  v15 = a1;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (!DefiningOp)
    return 0;
  v4 = DefiningOp;
  v5 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 48) + 32))(*(_QWORD *)(v4 + 48), v5))
    return 0;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  mlir::Operation::fold(v4, 0, 0, (uint64_t)v16);
  v6 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v16[0] & 0xFFFFFFFFFFFFFFF8));
  v8 = v6;
  if (v6)
  {
    v13 = v6;
    v14 = v7;
  }
  if (v16[0] != v17)
    free(v16[0]);
  if (!v8)
    return 0;
  v12[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v13);
  v12[1] = v9;
  if (*(_UNKNOWN **)(*(_QWORD *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v12) + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
    return 0;
  v10 = 1;
  mlir::getIntValues<long long>((uint64_t)v13, v14, a2, 1);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SoftmaxOp,mlir::Value,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softmax", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.softmax";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::SoftmaxOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SoftmaxOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::`anonymous namespace'::CanonicalizeTileAsBroadcast::~CanonicalizeTileAsBroadcast(mlir::mps::_anonymous_namespace_::CanonicalizeTileAsBroadcast *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::TileOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::TileOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::TileOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeTileAsBroadcast::matchAndRewrite(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t *v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t DefiningOp;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t ArgAttrsAttr;
  uint64_t v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v34;
  mlir::GenericProgramPoint *v35;
  const char *v36;
  uint64_t v37;
  _QWORD v38[2];
  uint64_t v39;
  _QWORD v40[4];
  __int16 v41;
  _QWORD *Input;
  void *Filter;
  uint64_t v44;
  _BYTE v45[32];
  void *v46;
  uint64_t v47;
  _WORD v48[16];
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v39 = a2;
  v4 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4)
    goto LABEL_10;
  v5 = *v4;
  v6 = mlir::TypeID::get<mlir::ShapedType>();
  v7 = *(unsigned int *)(v5 + 16);
  if (!(_DWORD)v7)
    goto LABEL_10;
  v8 = *(_QWORD **)(v5 + 8);
  v9 = &v8[2 * v7];
  do
  {
    v10 = v7 >> 1;
    v11 = &v8[2 * (v7 >> 1)];
    v13 = *v11;
    v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6)
      v8 = v12;
    else
      v7 = v10;
  }
  while (v7);
  if (v8 != v9 && *v8 == v6)
    v14 = v8[1];
  else
LABEL_10:
    v14 = 0;
  v38[0] = v4;
  v38[1] = v14;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v38) & 1) == 0)
  {
    v30 = "failed: input must be a ranked shaped type";
    goto LABEL_33;
  }
  Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Filter);
  if (!DefiningOp)
    goto LABEL_32;
  v16 = DefiningOp;
  v17 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v16 + 48) + 32))(*(_QWORD *)(v16 + 48), v17))
    goto LABEL_32;
  v46 = v48;
  v47 = 0x100000000;
  mlir::Operation::fold(v16, 0, 0, (uint64_t)&v46);
  v19 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v46 & 0xFFFFFFFFFFFFFFF8));
  if (v19)
    v20 = v18;
  else
    v20 = 0;
  if (v46 != v48)
    free(v46);
  if (!v19)
  {
LABEL_32:
    v30 = "failed: multipliers must be constant to rewrite Tile as a broadcast op";
LABEL_33:
    v46 = v30;
    v48[8] = 259;
    v31 = v39;
    Filter = &v46;
    v32 = a3[2];
    if (v32)
    {
      if (mlir::RewriterBase::Listener::classof(v32))
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void **))(*(_QWORD *)v32 + 64))(v32, *(_QWORD *)(v31 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TileOp &>(mlir::mps::TileOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &Filter);
      else
        return 0;
    }
    return v32;
  }
  v46 = v48;
  v47 = 0x400000000;
  mlir::getIntValues<long long>((uint64_t)v19, v20, (uint64_t)&v46, 1);
  Filter = v45;
  v44 = 0x400000000;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v38);
  if (!v22 || !(_DWORD)v47)
  {
LABEL_39:
    v40[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,llvm::SmallVector<long long,4u> &>((mlir::Builder *)(a3 + 1), *(_QWORD *)(v39 + 24), (uint64_t)&Filter);
    v34 = v39;
    Input = (_QWORD *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
    v35 = mlir::OpBuilder::create<mlir::mps::BroadcastToOp,mlir::Value &,mlir::mps::ShapeOp>((mlir::OpBuilder *)(a3 + 1), *(_QWORD *)(v34 + 24), (uint64_t *)&Input, v40);
    (*(void (**)(_QWORD *, uint64_t, mlir::GenericProgramPoint *))(*a3 + 32))(a3, v34, v35);
    v32 = 1;
    goto LABEL_40;
  }
  v23 = (uint64_t *)ArgAttrsAttr;
  v24 = (uint64_t *)v46;
  v25 = 8 * v47 - 8;
  v26 = 8 * v22 - 8;
  while (1)
  {
    v27 = *v23;
    if (*v24 != 1)
      break;
    v28 = v44;
    if (v44 < (unint64_t)HIDWORD(v44))
      goto LABEL_25;
LABEL_30:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&Filter, v45, v28 + 1, 8);
    v28 = v44;
LABEL_25:
    *((_QWORD *)Filter + v28) = v27;
    LODWORD(v44) = v44 + 1;
    if (v26)
    {
      ++v23;
      ++v24;
      v29 = v25;
      v25 -= 8;
      v26 -= 8;
      if (v29)
        continue;
    }
    goto LABEL_39;
  }
  if (v27 == 1)
  {
    v28 = v44;
    v27 = *v24;
    if (v44 < (unint64_t)HIDWORD(v44))
      goto LABEL_25;
    goto LABEL_30;
  }
  if (v27 == 0x8000000000000000)
    v36 = "failed: cannot apply pattern for tile operations along a dynamic dimension of the input";
  else
    v36 = "failed: multipliers need to be applied to a dimension size 1";
  v40[0] = v36;
  v41 = 259;
  v37 = v39;
  Input = v40;
  v32 = a3[2];
  if (v32)
  {
    if (mlir::RewriterBase::Listener::classof(v32))
      v32 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v32 + 64))(v32, *(_QWORD *)(v37 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TileOp &>(mlir::mps::TileOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &Input);
    else
      v32 = 0;
  }
LABEL_40:
  if (Filter != v45)
    free(Filter);
  if (v46 != v48)
    free(v46);
  return v32;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConstantOp,llvm::SmallVector<long long,4u> &>(mlir::Builder *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.constant";
    v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ConstantOp::build(a1, (uint64_t)v17, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::TileOp &>(mlir::mps::TileOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

void mlir::mps::`anonymous namespace'::CanonicalizeTensorFromElements::~CanonicalizeTensorFromElements(mlir::mps::_anonymous_namespace_::CanonicalizeTensorFromElements *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::FromElementsOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::FromElementsOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::FromElementsOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeTensorFromElements::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  uint64_t v6;
  unint64_t v7;
  uint64_t *Value;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  mlir::GenericProgramPoint *v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;

  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::tensor::FromElementsOp,void>::id)
    return 0;
  if ((*(_BYTE *)(a2 + 46) & 0x80) == 0)
    return 0;
  if (*(_DWORD *)(a2 + 68) != 1)
    return 0;
  v17 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v17);
  if (!DefiningOp
    || *(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::tensor::ExtractOp,void>::id
    || (*(_BYTE *)(DefiningOp + 46) & 0x80) == 0
    || *(_DWORD *)(DefiningOp + 68) != 1)
  {
    return 0;
  }
  v6 = *(_QWORD *)(*(_QWORD *)(DefiningOp + 72) + 24);
  v7 = *(_QWORD *)(v6 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(_QWORD *)v7 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v7 = 0;
  v17 = v7;
  if (!v7)
    return 0;
  Value = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v17);
  if (mlir::ShapedType::getNumElements(Value, v9) != 1)
    return 0;
  v10 = *(_QWORD *)(a2 + 24);
  v11 = 1;
  LODWORD(v15) = 1;
  v12 = mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((mlir::mps::ConstantOp *)(a3 + 8), v10, (unsigned int *)&v15);
  v15 = v6;
  v16 = (uint64_t)v12 - 16;
  v13 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value&>((mlir::UnitAttr **)(a3 + 8), *(_QWORD *)(a2 + 24), &v15, &v16);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, a2, v13);
  return v11;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value&>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.reshape";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ReshapeOp::build(a1, (uint64_t)v19, *a3, *a4, 0);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

_QWORD *mlir::mps::`anonymous namespace'::FuseBinaryWithConstants<mlir::mps::AddOp,true>::~FuseBinaryWithConstants(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::FuseBinaryWithConstants<mlir::mps::AddOp,true>::~FuseBinaryWithConstants(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::mps::`anonymous namespace'::FuseBinaryWithConstants<mlir::mps::AddOp,true>::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  uint64_t v3;
  int v7;
  uint64_t result;
  uint64_t v9;
  int v10;
  _QWORD *Value;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  void *v16;
  mlir::GenericProgramPoint *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22[2];
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25[2];
  uint64_t v26;
  uint64_t v27;
  void *v28;
  void *v29;
  uint64_t v30;
  _QWORD v31[2];

  v31[1] = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 24);
  v27 = 0;
  v28 = 0;
  v25[0] = &v27;
  v25[1] = (uint64_t *)&v28;
  v26 = 0;
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id
    || (*(_BYTE *)(a2 + 46) & 0x80) == 0
    || *(_DWORD *)(a2 + 68) != 2)
  {
    return 0;
  }
  v7 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(a2, 0, v25);
  v29 = *(void **)(*(_QWORD *)(a2 + 72) + 56);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  if (!result)
    return result;
  v9 = result;
  v10 = *(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      ? v7
      : 0;
  if (v10 != 1)
    return 0;
  v29 = v28;
  Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v29);
  v13 = v12;
  v22[0] = v9;
  v14 = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)v22);
    return 0;
  if (!*(_BYTE *)(a1 + 96))
  {
    v24 = v26;
    v18 = *(_QWORD **)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v24);
    if (!v18 || *v18)
    {
      v23 = v9;
      v29 = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v23);
      v30 = v19;
      if (mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v29))
      {
        v21 = v28;
        v22[0] = (uint64_t)mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v21);
        v22[1] = v20;
        if ((mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v22) & 1) == 0)
          return 0;
      }
    }
  }
  v22[0] = (uint64_t)v28;
  v24 = v9;
  v29 = v31;
  v30 = 0x100000000;
  mlir::OpBuilder::createOrFold<mlir::mps::AddOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp>((uint64_t)(a3 + 1), (uint64_t)&v29, v3, v22, &v24);
  v16 = *(void **)v29;
  if (v29 != v31)
    free(v29);
  v29 = v16;
  v22[0] = v27;
  v17 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 1, *(_QWORD *)(a2 + 24), v22, (uint64_t *)&v29);
  (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, a2, v17);
  return 1;
}

uint64_t mlir::mps::`anonymous namespace'::isBroadcastOnSameAxis(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  _BOOL8 v8;
  uint64_t v10;
  uint64_t ArgAttrsAttr;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t NumElements;
  uint64_t v17;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t ArgOperands;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;

  v7 = a1;
  v38 = *MEMORY[0x1E0C80C00];
  if (mlir::ElementsAttr::getNumElements(a1, a2) == 1 || mlir::ElementsAttr::getNumElements(a3, a4) == 1)
    return 1;
  v32 = &v34;
  v34 = v7;
  v35 = a2;
  v36 = a3;
  v37 = a4;
  v33 = 0x200000002;
  ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v34);
  v31 = v10;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
  if (v12 >= 1)
  {
    v13 = (uint64_t *)ArgAttrsAttr;
    v14 = -v12;
    do
    {
      v15 = *v13;
      NumElements = mlir::ElementsAttr::getNumElements(v34, v35);
      v17 = *v13++;
      v7 = v17;
      if (v15 != NumElements && v7 != 1)
        goto LABEL_28;
      if (v7 == mlir::ElementsAttr::getNumElements(v34, v35))
        a3 = v14;
      v19 = __CFADD__(v14++, 1);
    }
    while (!v19);
  }
  ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v36);
  v31 = v20;
  v21 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&ArgOperands);
  if (v22 >= 1)
  {
    v23 = (uint64_t *)v21;
    v24 = -v22;
    while (1)
    {
      v25 = *v23;
      v26 = mlir::ElementsAttr::getNumElements(v36, v37);
      v28 = *v23++;
      v27 = v28;
      if (v25 != v26 && v27 != 1)
        break;
      if (v27 == mlir::ElementsAttr::getNumElements(v36, v37))
        v7 = v24;
      v19 = __CFADD__(v24++, 1);
      if (v19)
        goto LABEL_29;
    }
LABEL_28:
    v8 = 0;
    goto LABEL_30;
  }
LABEL_29:
  v8 = a3 == v7;
LABEL_30:
  if (v32 != &v34)
    free(v32);
  return v8;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::AddOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  uint64_t DefiningOp;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v14;

  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v14);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id
      || (*(_BYTE *)(DefiningOp + 46) & 0x80) == 0
      || *(_DWORD *)(DefiningOp + 68) != 2)
    {
      goto LABEL_15;
    }
    v7 = *(_QWORD *)(DefiningOp + 72);
    v8 = *(_QWORD *)(v7 + 24);
    v9 = **a3;
    if (v9)
    {
      v10 = v9 == v8;
    }
    else
    {
      **a3 = v8;
      v7 = *(_QWORD *)(DefiningOp + 72);
      v10 = 1;
    }
    if ((v11 = a3[1], v14 = *(_QWORD *)(v7 + 56), (v12 = mlir::Value::getDefiningOp((mlir::Value *)&v14)) != 0)
      && *(_UNKNOWN **)(*(_QWORD *)(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v11 || *v11 == v12)
      && (*v11 = v12, v10))
    {
      a3[2] = (uint64_t *)v6;
      v5 = 1;
    }
    else
    {
LABEL_15:
      v5 = 0;
    }
  }
  return (v6 != 0) & v5;
}

void mlir::OpBuilder::createOrFold<mlir::mps::AddOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp>(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  const mlir::OperationState *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x1E0C80C00];
  v20 = a3;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.add";
    v23[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a3, v11);
  mlir::mps::ATan2Op::build((mlir::Float32Type **)a1, (uint64_t)v25, *a4 - 16, *a5 - 16);
  v14 = (mlir::GenericProgramPoint *)mlir::Operation::create((mlir::Operation *)v25, v13);
  v15 = *(_QWORD *)(a1 + 16);
  if (v15)
  {
    v16 = *(uint64_t **)(a1 + 24);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v15 + 32, (uint64_t)v14);
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
    v17 = *v16;
    *v18 = *v16;
    v18[1] = (uint64_t)v16;
    *(_QWORD *)(v17 + 8) = v18;
    *v16 = (uint64_t)v18;
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
  }
  if (mlir::OpBuilder::tryFold((_QWORD *)a1, (uint64_t)v14, a2))
  {
    mlir::Operation::erase(v14);
  }
  else
  {
    v19 = *(_QWORD *)(a1 + 8);
    if (v19)
      (*(void (**)(uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)v19 + 16))(v19, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
}

_QWORD *mlir::mps::`anonymous namespace'::FuseBinaryWithConstants<mlir::mps::MultiplyOp,true>::~FuseBinaryWithConstants(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::FuseBinaryWithConstants<mlir::mps::MultiplyOp,true>::~FuseBinaryWithConstants(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::mps::`anonymous namespace'::FuseBinaryWithConstants<mlir::mps::MultiplyOp,true>::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  uint64_t v3;
  int v7;
  uint64_t result;
  uint64_t v9;
  int v10;
  _QWORD *Value;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  void *v16;
  mlir::GenericProgramPoint *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22[2];
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25[2];
  uint64_t v26;
  uint64_t v27;
  void *v28;
  void *v29;
  uint64_t v30;
  _QWORD v31[2];

  v31[1] = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 24);
  v27 = 0;
  v28 = 0;
  v25[0] = &v27;
  v25[1] = (uint64_t *)&v28;
  v26 = 0;
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id
    || (*(_BYTE *)(a2 + 46) & 0x80) == 0
    || *(_DWORD *)(a2 + 68) != 2)
  {
    return 0;
  }
  v7 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(a2, 0, v25);
  v29 = *(void **)(*(_QWORD *)(a2 + 72) + 56);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v29);
  if (!result)
    return result;
  v9 = result;
  v10 = *(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      ? v7
      : 0;
  if (v10 != 1)
    return 0;
  v29 = v28;
  Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v29);
  v13 = v12;
  v22[0] = v9;
  v14 = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)v22);
    return 0;
  if (!*(_BYTE *)(a1 + 96))
  {
    v24 = v26;
    v18 = *(_QWORD **)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v24);
    if (!v18 || *v18)
    {
      v23 = v9;
      v29 = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v23);
      v30 = v19;
      if (mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v29))
      {
        v21 = v28;
        v22[0] = (uint64_t)mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v21);
        v22[1] = v20;
        if ((mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v22) & 1) == 0)
          return 0;
      }
    }
  }
  v22[0] = (uint64_t)v28;
  v24 = v9;
  v29 = v31;
  v30 = 0x100000000;
  mlir::OpBuilder::createOrFold<mlir::mps::MultiplyOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp>((uint64_t)(a3 + 1), (uint64_t)&v29, v3, v22, &v24);
  v16 = *(void **)v29;
  if (v29 != v31)
    free(v29);
  v29 = v16;
  v22[0] = v27;
  v17 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(a3 + 1, *(_QWORD *)(a2 + 24), v22, (uint64_t *)&v29);
  (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, a2, v17);
  return 1;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MultiplyOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  uint64_t DefiningOp;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v14;

  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v14);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id
      || (*(_BYTE *)(DefiningOp + 46) & 0x80) == 0
      || *(_DWORD *)(DefiningOp + 68) != 2)
    {
      goto LABEL_15;
    }
    v7 = *(_QWORD *)(DefiningOp + 72);
    v8 = *(_QWORD *)(v7 + 24);
    v9 = **a3;
    if (v9)
    {
      v10 = v9 == v8;
    }
    else
    {
      **a3 = v8;
      v7 = *(_QWORD *)(DefiningOp + 72);
      v10 = 1;
    }
    if ((v11 = a3[1], v14 = *(_QWORD *)(v7 + 56), (v12 = mlir::Value::getDefiningOp((mlir::Value *)&v14)) != 0)
      && *(_UNKNOWN **)(*(_QWORD *)(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v11 || *v11 == v12)
      && (*v11 = v12, v10))
    {
      a3[2] = (uint64_t *)v6;
      v5 = 1;
    }
    else
    {
LABEL_15:
      v5 = 0;
    }
  }
  return (v6 != 0) & v5;
}

void mlir::OpBuilder::createOrFold<mlir::mps::MultiplyOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp>(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  const mlir::OperationState *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x1E0C80C00];
  v20 = a3;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.multiply";
    v23[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a3, v11);
  mlir::mps::ATan2Op::build((mlir::Float32Type **)a1, (uint64_t)v25, *a4 - 16, *a5 - 16);
  v14 = (mlir::GenericProgramPoint *)mlir::Operation::create((mlir::Operation *)v25, v13);
  v15 = *(_QWORD *)(a1 + 16);
  if (v15)
  {
    v16 = *(uint64_t **)(a1 + 24);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v15 + 32, (uint64_t)v14);
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
    v17 = *v16;
    *v18 = *v16;
    v18[1] = (uint64_t)v16;
    *(_QWORD *)(v17 + 8) = v18;
    *v16 = (uint64_t)v18;
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
  }
  if (mlir::OpBuilder::tryFold((_QWORD *)a1, (uint64_t)v14, a2))
  {
    mlir::Operation::erase(v14);
  }
  else
  {
    v19 = *(_QWORD *)(a1 + 8);
    if (v19)
      (*(void (**)(uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)v19 + 16))(v19, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
}

void mlir::mps::`anonymous namespace'::CanonicalizeSparseMatMul::~CanonicalizeSparseMatMul(mlir::mps::_anonymous_namespace_::CanonicalizeSparseMatMul *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeSparseMatMul::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DefiningOp;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  int v26;
  int32x4_t *v27;
  unint64_t v28;
  char *v29;
  uint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  int32x4_t *v33;
  int32x4_t *v34;
  uint64_t v35;
  int32x4_t v36;
  int32x4_t v37;
  int32x4_t v38;
  int32x4_t v39;
  uint64_t v40;
  uint64_t v41;
  mlir::GenericProgramPoint *v42;
  mlir::GenericProgramPoint *v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  _QWORD *v47;
  _QWORD *v48;
  unint64_t v49;
  unint64_t *v50;
  _QWORD *v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t ArgAttrsAttr;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  int v59;
  int32x4_t *v60;
  unint64_t v61;
  char *v62;
  uint64_t *v63;
  unint64_t v64;
  uint64_t v65;
  int32x4_t *v66;
  int32x4_t *v67;
  uint64_t v68;
  int32x4_t v69;
  int32x4_t v70;
  int32x4_t v71;
  int32x4_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unsigned int StorageType;
  BOOL v78;
  BOOL TransposeRhs;
  uint64_t v80;
  uint64_t Filter;
  uint64_t v82;
  mlir::GenericProgramPoint *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  char *Input;
  uint64_t v90;
  _QWORD v91[2];

  v91[1] = *MEMORY[0x1E0C80C00];
  v76 = a2;
  Input = (char *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v76);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&Input);
  if (!DefiningOp
    || *(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MaterializeSparseTensorOp,void>::id)
  {
    Input = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v76);
    result = mlir::Value::getDefiningOp((mlir::Value *)&Input);
    if (!result)
      return result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MaterializeSparseTensorOp,void>::id)
      return 0;
    v88 = v76;
    Input = (char *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v88);
    v8 = mlir::Value::getDefiningOp((mlir::Value *)&Input);
    if (v8)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)(v8 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MaterializeSparseTensorOp,void>::id)
        v9 = v8;
      else
        v9 = 0;
    }
    else
    {
      v9 = 0;
    }
    v87 = v9;
    v86 = *(_QWORD *)(mlir::memref::LoadOp::getIndices((mlir::memref::LoadOp *)&v87) + 24);
    v85 = *(_QWORD *)(mlir::memref::LoadOp::getIndices((mlir::memref::LoadOp *)&v87) + 56);
    v43 = (mlir::GenericProgramPoint *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v87) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v43)
      goto LABEL_47;
    v44 = *(_QWORD *)v43;
    v45 = mlir::TypeID::get<mlir::ShapedType>();
    v46 = *(unsigned int *)(v44 + 16);
    if (!(_DWORD)v46)
      goto LABEL_47;
    v47 = *(_QWORD **)(v44 + 8);
    v48 = &v47[2 * v46];
    do
    {
      v49 = v46 >> 1;
      v50 = &v47[2 * (v46 >> 1)];
      v52 = *v50;
      v51 = v50 + 2;
      v46 += ~(v46 >> 1);
      if (v52 < v45)
        v47 = v51;
      else
        v46 = v49;
    }
    while (v46);
    if (v47 != v48 && *v47 == v45)
      v53 = v47[1];
    else
LABEL_47:
      v53 = 0;
    v83 = v43;
    v84 = v53;
    ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v83);
    v56 = v54;
    Input = (char *)v91;
    v90 = 0x200000000;
    v57 = 8 * v54;
    if ((unint64_t)(8 * v54) < 0x11)
    {
      v58 = 0;
      v59 = 0;
      if (!v54)
      {
LABEL_59:
        LODWORD(v90) = v59 + (v57 >> 3);
        v83 = mlir::OpBuilder::create<mlir::mps::ConstantOp,llvm::SmallVector<int,2u> &>((mlir::Builder *)(a3 + 8), *(_QWORD *)(v88 + 24), (uint64_t)&Input);
        v74 = *(_QWORD *)(v88 + 24);
        Filter = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v87);
        v80 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v88);
        TransposeRhs = !mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v88);
        v78 = !mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v88);
        StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v87);
        v82 = (uint64_t)mlir::OpBuilder::create<mlir::mpsx::SparseDenseMatMulOp,mlir::Value,mlir::Value&,mlir::Value&,mlir::mps::ConstantOp &,mlir::Value,BOOL,BOOL,mlir::mps::SparseTensorStorage>((mlir::BoolAttr **)(a3 + 8), v74, &Filter, &v86, &v85, &v83, &v80, (unsigned __int8 *)&TransposeRhs, (unsigned __int8 *)&v78, &StorageType)- 16;
        v75 = *(_QWORD *)(v88 + 24);
        LODWORD(v80) = -1;
        StorageType = -2;
        Filter = (uint64_t)mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int,int>((mlir::mps::ConstantOp *)(a3 + 8), v75, &v82, (unsigned int *)&v80, &StorageType)- 16;
        (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(_QWORD *)a3 + 24))(a3, v88, &Filter, 1);
        goto LABEL_60;
      }
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&Input, v91, (8 * v54) >> 3, 4);
      v58 = v90;
      v59 = v90;
      if (!v56)
        goto LABEL_59;
    }
    v60 = (int32x4_t *)&Input[4 * v58];
    v61 = (v56 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v61 >= 7)
    {
      v64 = v61 + 1;
      v65 = (v61 + 1) & 0x3FFFFFFFFFFFFFF8;
      v62 = &v60->i8[4 * v65];
      v63 = (uint64_t *)(ArgAttrsAttr + 8 * v65);
      v66 = (int32x4_t *)(ArgAttrsAttr + 32);
      v67 = v60 + 1;
      v68 = v65;
      do
      {
        v70 = v66[-2];
        v69 = v66[-1];
        v72 = *v66;
        v71 = v66[1];
        v66 += 4;
        v67[-1] = vuzp1q_s32(v70, v69);
        *v67 = vuzp1q_s32(v72, v71);
        v67 += 2;
        v68 -= 8;
      }
      while (v68);
      if (v64 == v65)
        goto LABEL_58;
    }
    else
    {
      v62 = (char *)v60;
      v63 = (uint64_t *)ArgAttrsAttr;
    }
    do
    {
      v73 = *v63++;
      *(_DWORD *)v62 = v73;
      v62 += 4;
    }
    while (v63 != (uint64_t *)(ArgAttrsAttr + v57));
LABEL_58:
    v59 = v90;
    goto LABEL_59;
  }
  v88 = v76;
  Input = (char *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v88);
  v6 = mlir::Value::getDefiningOp((mlir::Value *)&Input);
  if (v6)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(v6 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MaterializeSparseTensorOp,void>::id)
      v7 = v6;
    else
      v7 = 0;
  }
  else
  {
    v7 = 0;
  }
  v87 = v7;
  v86 = *(_QWORD *)(mlir::memref::LoadOp::getIndices((mlir::memref::LoadOp *)&v87) + 24);
  v85 = *(_QWORD *)(mlir::memref::LoadOp::getIndices((mlir::memref::LoadOp *)&v87) + 56);
  v10 = (mlir::GenericProgramPoint *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v87) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10)
    goto LABEL_24;
  v11 = *(_QWORD *)v10;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_24;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_24:
    v20 = 0;
  v83 = v10;
  v84 = v20;
  v22 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v83);
  v23 = v21;
  Input = (char *)v91;
  v90 = 0x200000000;
  v24 = 8 * v21;
  if ((unint64_t)(8 * v21) >= 0x11)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&Input, v91, (8 * v21) >> 3, 4);
    v25 = v90;
    v26 = v90;
    if (!v23)
      goto LABEL_36;
LABEL_29:
    v27 = (int32x4_t *)&Input[4 * v25];
    v28 = (v23 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v28 >= 7)
    {
      v31 = v28 + 1;
      v32 = (v28 + 1) & 0x3FFFFFFFFFFFFFF8;
      v29 = &v27->i8[4 * v32];
      v30 = (uint64_t *)(v22 + 8 * v32);
      v33 = (int32x4_t *)(v22 + 32);
      v34 = v27 + 1;
      v35 = v32;
      do
      {
        v37 = v33[-2];
        v36 = v33[-1];
        v39 = *v33;
        v38 = v33[1];
        v33 += 4;
        v34[-1] = vuzp1q_s32(v37, v36);
        *v34 = vuzp1q_s32(v39, v38);
        v34 += 2;
        v35 -= 8;
      }
      while (v35);
      if (v31 == v32)
        goto LABEL_35;
    }
    else
    {
      v29 = (char *)v27;
      v30 = (uint64_t *)v22;
    }
    do
    {
      v40 = *v30++;
      *(_DWORD *)v29 = v40;
      v29 += 4;
    }
    while (v30 != (uint64_t *)(v22 + v24));
LABEL_35:
    v26 = v90;
    goto LABEL_36;
  }
  v25 = 0;
  v26 = 0;
  if (v21)
    goto LABEL_29;
LABEL_36:
  LODWORD(v90) = v26 + (v24 >> 3);
  v83 = mlir::OpBuilder::create<mlir::mps::ConstantOp,llvm::SmallVector<int,2u> &>((mlir::Builder *)(a3 + 8), *(_QWORD *)(v88 + 24), (uint64_t)&Input);
  v41 = v88;
  v82 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v87);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v88);
  LOBYTE(StorageType) = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v88);
  TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v88);
  LODWORD(v80) = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v87);
  v42 = mlir::OpBuilder::create<mlir::mpsx::SparseDenseMatMulOp,mlir::Value,mlir::Value&,mlir::Value&,mlir::mps::ConstantOp &,mlir::Value,BOOL,BOOL,mlir::mps::SparseTensorStorage>((mlir::BoolAttr **)(a3 + 8), *(_QWORD *)(v41 + 24), &v82, &v86, &v85, &v83, &Filter, (unsigned __int8 *)&StorageType, (unsigned __int8 *)&TransposeRhs, (unsigned int *)&v80);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v41, v42);
LABEL_60:
  if (Input != (char *)v91)
    free(Input);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConstantOp,llvm::SmallVector<int,2u> &>(mlir::Builder *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.constant";
    v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ConstantOp::build(a1, (uint64_t)v17, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::SparseDenseMatMulOp,mlir::Value,mlir::Value&,mlir::Value&,mlir::mps::ConstantOp &,mlir::Value,BOOL,BOOL,mlir::mps::SparseTensorStorage>(mlir::BoolAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, _QWORD *a6, uint64_t *a7, unsigned __int8 *a8, unsigned __int8 *a9, unsigned int *a10)
{
  uint64_t *Context;
  uint64_t v19;
  char v20;
  mlir::GenericProgramPoint *v21;
  mlir::GenericProgramPoint *v22;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  uint64_t v27[4];
  __int16 v28;
  _QWORD v29[40];

  v29[38] = *MEMORY[0x1E0C80C00];
  v24 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.sparse_dense_matmul", (const unsigned __int8 *)0x18, Context);
  if (!v20)
  {
    v28 = 1283;
    v27[2] = (uint64_t)"mpsx.sparse_dense_matmul";
    v27[3] = 24;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v19);
  mlir::mpsx::SparseDenseMatMulOp::build(a1, (uint64_t)v29, *a3, *a4, *a5, *a6 - 16, *a7, (mlir::MLIRContext *)*a8, *a9, *a10);
  v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((_QWORD *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::SparseDenseMatMulOp,void>::id)
    v22 = v21;
  else
    v22 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v22;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,int,int>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  uint64_t v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.transpose";
    v19[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::TransposeOp::build(a1, v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::mps::`anonymous namespace'::CanonicalizeSDPA::~CanonicalizeSDPA(mlir::mps::_anonymous_namespace_::CanonicalizeSDPA *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeSDPA::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::UnknownLoc **a3)
{
  _QWORD *Value;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t *v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  int ArgOperands;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v24;
  uint64_t v25;
  int v26;
  const char *v27;
  uint64_t v28;
  uint64_t DefiningOp;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t *v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  _QWORD *ArgAttrsAttr;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t ElementTypeOrSelf;
  uint64_t v61[2];
  _QWORD v62[2];
  uint64_t v63;
  uint64_t v64[2];
  uint64_t v65;
  _QWORD v66[2];
  char *v67;
  _QWORD v68[2];
  char v69;
  char v70;
  _QWORD v71[2];
  char v72;
  char v73;
  _QWORD v74[2];
  _QWORD *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  _QWORD *v83;
  _QWORD v84[4];
  __int16 v85;
  char *v86;
  uint64_t v87;
  _WORD v88[16];
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  v81 = 0;
  v82 = a2;
  v79 = 0;
  v80 = 0;
  v77 = 0;
  v78 = 0;
  v75 = 0;
  v76 = 0;
  v74[0] = &v81;
  v74[1] = &v80;
  v71[0] = v74;
  v71[1] = &v77;
  v72 = 0;
  v73 = 0;
  v68[0] = v71;
  v68[1] = &v79;
  v69 = 0;
  v70 = 0;
  v66[0] = v68;
  v66[1] = &v76;
  v67 = 0;
  v64[0] = (uint64_t)v66;
  v64[1] = (uint64_t)&v78;
  v65 = 0;
  v84[0] = a2;
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id)
    return 0;
  if ((*(_BYTE *)(a2 + 46) & 0x80) == 0)
    return 0;
  if (*(_DWORD *)(a2 + 68) != 2)
    return 0;
  LOBYTE(v62[0]) = 1;
  v86 = (char *)v62;
  v87 = (uint64_t)v84;
  mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(v64, (uint64_t)&v86);
  if (!LOBYTE(v62[0]))
    return 0;
  v65 = v84[0];
  v63 = v76;
  Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v63);
  v6 = v5;
  if (mlir::ElementsAttr::getNumElements((uint64_t)Value, v5) != 1)
  {
    v86 = "failed: softmax must be applied to a single axis";
    v88[8] = 259;
    v21 = v82;
    v84[0] = &v86;
    v22 = (uint64_t)a3[2];
    if (!v22)
      return v22;
    if (mlir::RewriterBase::Listener::classof(v22))
      return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v22 + 64))(v22, *(_QWORD *)(v21 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v84);
    return 0;
  }
  v86 = v67;
  v7 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v86) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v7)
    goto LABEL_15;
  v8 = *v7;
  v9 = mlir::TypeID::get<mlir::ShapedType>();
  v10 = *(unsigned int *)(v8 + 16);
  if (!(_DWORD)v10)
    goto LABEL_15;
  v11 = *(_QWORD **)(v8 + 8);
  v12 = &v11[2 * v10];
  do
  {
    v13 = v10 >> 1;
    v14 = &v11[2 * (v10 >> 1)];
    v16 = *v14;
    v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9)
      v11 = v15;
    else
      v10 = v13;
  }
  while (v10);
  if (v11 != v12 && *v11 == v9)
    v17 = v11[1];
  else
LABEL_15:
    v17 = 0;
  v62[0] = v7;
  v62[1] = v17;
  ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v62);
  if (ArgOperands)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v62);
    v20 = v19;
  }
  else
  {
    v20 = 0;
  }
  v86 = (char *)v88;
  v87 = 0x400000000;
  mlir::getIntValues<long long>((uint64_t)Value, v6, (uint64_t)&v86, 1);
  if ((_DWORD)v87)
  {
    v24 = v86;
    v25 = 8 * v87;
    while (1)
    {
      v26 = *(_QWORD *)v24 == -1 ? 1 : ArgOperands;
      if (v26 != 1 || ArgOperands && (*(_QWORD *)v24 + v20) % v20 != v20 - 1)
        break;
      v24 += 8;
      v25 -= 8;
      if (!v25)
        goto LABEL_34;
    }
    v27 = "failed: softmax axis should be -1 or equal to inputRank - 1";
LABEL_63:
    v84[0] = v27;
    v85 = 259;
    v49 = v82;
    v61[0] = (uint64_t)v84;
    v22 = (uint64_t)a3[2];
    if (!v22)
      goto LABEL_78;
    if (mlir::RewriterBase::Listener::classof(v22))
    {
      v48 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v22 + 64))(v22, *(_QWORD *)(v49 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v61);
      goto LABEL_66;
    }
    goto LABEL_77;
  }
LABEL_34:
  v28 = v77;
  if (!v77)
    goto LABEL_56;
  v84[0] = v77;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v84);
  if (!DefiningOp
    || (v30 = DefiningOp,
        v31 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        ((*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v30 + 48) + 32))(*(_QWORD *)(v30 + 48), v31) & 1) == 0))
  {
    v27 = "failed: the value for scale must be a constant";
    goto LABEL_63;
  }
  v32 = (uint64_t *)(*(_QWORD *)(v28 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v32)
    goto LABEL_46;
  v33 = *v32;
  v34 = mlir::TypeID::get<mlir::ShapedType>();
  v35 = *(unsigned int *)(v33 + 16);
  if (!(_DWORD)v35)
    goto LABEL_46;
  v36 = *(_QWORD **)(v33 + 8);
  v37 = &v36[2 * v35];
  do
  {
    v38 = v35 >> 1;
    v39 = &v36[2 * (v35 >> 1)];
    v41 = *v39;
    v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34)
      v36 = v40;
    else
      v35 = v38;
  }
  while (v35);
  if (v36 != v37 && *v36 == v34)
    v42 = v36[1];
  else
LABEL_46:
    v42 = 0;
  v61[0] = (uint64_t)v32;
  v61[1] = v42;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v61)
    || (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v61), v43 >= 2))
  {
    v44 = "failed: scale should have rank 0 or 1";
LABEL_61:
    v48 = mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>((uint64_t)a3, &v82, v44);
LABEL_66:
    v22 = v48;
    goto LABEL_78;
  }
  ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v61);
  if (v46)
  {
    v47 = 8 * v46;
    while (*ArgAttrsAttr == 1)
    {
      ++ArgAttrsAttr;
      v47 -= 8;
      if (!v47)
        goto LABEL_56;
    }
    v85 = 259;
    v55 = v82;
    v83 = v84;
    v84[0] = "failed: scale should be scalar";
    v22 = (uint64_t)a3[2];
    if (!v22)
      goto LABEL_78;
    if (mlir::RewriterBase::Listener::classof(v22))
    {
      v48 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v22 + 64))(v22, *(_QWORD *)(v55 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v83);
      goto LABEL_66;
    }
  }
  else
  {
LABEL_56:
    v83 = v75;
    if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v83)
      || !mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v83))
    {
      v27 = "failed: Transpose of LHS and RHS when matrix multiplying query and key should be false and true respectively";
      goto LABEL_63;
    }
    v84[0] = v65;
    if (mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)v84)
      || mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)v84))
    {
      v44 = "failed: Transpose of LHS and RHS when matrix multiplying softmax and value should be false and false respectively";
      goto LABEL_61;
    }
    v61[0] = v77;
    if (!v77)
    {
      v50 = *(_QWORD *)(v82 + 24);
      LODWORD(ElementTypeOrSelf) = 1;
      v61[0] = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((mlir::mps::ConstantOp *)(a3 + 1), v50, (unsigned int *)&ElementTypeOrSelf)- 16;
      v51 = *(_QWORD *)(v82 + 24);
      ElementTypeOrSelf = mlir::getElementTypeOrSelf(v81);
      v61[0] = (uint64_t)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 1, v51, v61, &ElementTypeOrSelf)- 16;
    }
    ElementTypeOrSelf = v79;
    if (!v79)
    {
      v52 = *(_QWORD *)(v82 + 24);
      LODWORD(v59) = 0;
      ElementTypeOrSelf = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((mlir::mps::ConstantOp *)(a3 + 1), v52, (unsigned int *)&v59)- 16;
      v53 = *(_QWORD *)(v82 + 24);
      v59 = (uint64_t *)mlir::getElementTypeOrSelf(v81);
      ElementTypeOrSelf = (uint64_t)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 1, v53, &ElementTypeOrSelf, (uint64_t *)&v59)- 16;
    }
    v54 = *(_QWORD *)(v82 + 24);
    v57 = v80;
    v58 = v81;
    v56 = v78;
    v59 = (uint64_t *)mlir::OpBuilder::create<mlir::mpsx::ScaledDotProductAttentionOp,mlir::Value,mlir::Value,mlir::Value,mlir::Value&,mlir::Value&>(a3 + 1, v54, &v58, &v57, &v56, &ElementTypeOrSelf, v61);
    if (mlir::mpsx::ScaledDotProductAttentionOp::verify(&v59))
    {
      (*((void (**)(mlir::UnknownLoc **, uint64_t, uint64_t *))*a3 + 4))(a3, v82, v59);
      v22 = 1;
      goto LABEL_78;
    }
  }
LABEL_77:
  v22 = 0;
LABEL_78:
  if (v86 != (char *)v88)
    free(v86);
  return v22;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(uint64_t a1, uint64_t *a2, _BYTE *a3)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  _BYTE *v7;
  char v8;
  char v9;
  _QWORD *v10;

  v3 = 1;
  v9 = 1;
  if (*a3)
  {
    v7 = a3;
    v3 = 3;
  }
  v8 = v3;
  v4 = *a2;
  v10 = &v7;
  v5 = *(_QWORD *)(a1 + 16);
  if (!v5)
    return 0;
  result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v5 + 64))(v5, *(_QWORD *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::ScaledDotProductAttentionOp,mlir::Value,mlir::Value,mlir::Value,mlir::Value&,mlir::Value&>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t *Context;
  uint64_t v15;
  char v16;
  mlir::GenericProgramPoint *v17;
  mlir::GenericProgramPoint *v18;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.sdpa", (const unsigned __int8 *)9, Context);
  if (!v16)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mpsx.sdpa";
    v23[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::mpsx::ScaledDotProductAttentionOp::build(a1, (uint64_t)v25, *a3, *a4, *a5, *a6, *a7);
  v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((_QWORD *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::ScaledDotProductAttentionOp,void>::id)
    v18 = v17;
  else
    v18 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  BOOL v6;
  uint64_t v7;
  int v8;
  BOOL *v9;
  BOOL v10;
  _QWORD *v11;
  uint64_t v12;
  BOOL v13;
  _QWORD v14[2];
  unsigned __int8 v15;
  uint64_t v16;

  v4 = *a1;
  v14[0] = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)v14);
  v7 = result;
  if (result)
  {
    v16 = result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SoftmaxOp,void>::id
      && (*(_BYTE *)(result + 46) & 0x80) != 0
      && *(_DWORD *)(result + 68) == 2)
    {
      v15 = 1;
      v14[0] = &v15;
      v14[1] = &v16;
      result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul>(v4, (uint64_t)v14);
      v8 = v15;
      if (v15)
        *(_QWORD *)(v4 + 16) = v16;
      v6 = v8 != 0;
    }
    else
    {
      v6 = 0;
    }
  }
  v9 = *(BOOL **)a2;
  v10 = v6 && **(_BYTE **)a2 != 0;
  if (!v7)
    v10 = 0;
  *v9 = v10;
  v11 = (_QWORD *)a1[1];
  v12 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 56);
  if (*v11)
  {
    v13 = *v11 == v12;
  }
  else
  {
    *v11 = v12;
    v9 = *(BOOL **)a2;
    v10 = **(_BYTE **)a2 != 0;
    v13 = 1;
  }
  *v9 = v13 && v10;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::SoftmaxOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder> *,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp> *> & *)#1},0ul,1ul>(uint64_t a1, uint64_t a2)
{
  uint64_t **v4;
  uint64_t DefiningOp;
  char v6;
  uint64_t *v7;
  uint64_t result;
  char v9;
  char v10;
  uint64_t v11;

  v4 = *(uint64_t ***)a1;
  v11 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (DefiningOp)
    LOBYTE(DefiningOp) = mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(v4, DefiningOp);
  if (**(_BYTE **)a2)
    v6 = DefiningOp;
  else
    v6 = 0;
  **(_BYTE **)a2 = v6;
  v7 = *(uint64_t **)(a1 + 8);
  v11 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 56);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v7 || *v7 == result))
    {
      *v7 = result;
      v9 = 1;
    }
    else
    {
      v9 = 0;
    }
  }
  v10 = v9 & (**(_BYTE **)a2 != 0);
  if (!result)
    v10 = 0;
  **(_BYTE **)a2 = v10;
  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::AddOp,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(uint64_t **a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t result;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t DefiningOp;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  _BOOL4 v17;
  uint64_t v18;

  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id)
  {
    if ((mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match((_QWORD **)*a1, a2) & 1) == 0)
    {
      if (*(_DWORD *)(a2 + 36))
      {
        v4 = a1[1];
        v5 = a2 - 16;
        if (*v4)
          return *v4 == v5;
        *v4 = v5;
        return 1;
      }
      return 0;
    }
    return 1;
  }
  v7 = *a1;
  v8 = a1[1];
  v18 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v18);
  if (DefiningOp)
    LOBYTE(DefiningOp) = mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match((_QWORD **)v7, DefiningOp);
  v10 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56);
  if (*v8)
  {
    if ((DefiningOp & (*v8 == v10)) != 0)
      goto LABEL_20;
  }
  else
  {
    *v8 = v10;
    if ((DefiningOp & 1) != 0)
    {
LABEL_20:
      if (!*((_BYTE *)a1 + 24))
        *((_BYTE *)a1 + 24) = 1;
      a1[2] = (uint64_t *)a2;
      return 1;
    }
  }
  *a1[1] = 0;
  v11 = *a1;
  v12 = **a1;
  **(_QWORD **)v12 = 0;
  **(_QWORD **)(v12 + 8) = 0;
  *(_QWORD *)(v12 + 16) = 0;
  *(_QWORD *)v11[1] = 0;
  if (*((_BYTE *)v11 + 24))
    *((_BYTE *)v11 + 24) = 0;
  v14 = *a1;
  v13 = a1[1];
  v15 = *(_QWORD *)(a2 + 72);
  v16 = *(_QWORD *)(v15 + 24);
  if (*v13)
  {
    v17 = *v13 == v16;
  }
  else
  {
    *v13 = v16;
    v15 = *(_QWORD *)(a2 + 72);
    v17 = 1;
  }
  v18 = *(_QWORD *)(v15 + 56);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v18);
  if (result)
  {
    if ((v17 & mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match((_QWORD **)v14, result)) != 1)return 0;
    goto LABEL_20;
  }
  return result;
}

uint64_t mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(_QWORD **a1, uint64_t a2)
{
  void *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _BOOL4 v8;
  int v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v13;
  uint64_t v14;
  _BOOL4 v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD v18[2];
  int8x16_t v19;
  int8x16_t v20;
  unsigned __int8 v21;
  _QWORD *v22;

  v22 = (_QWORD *)a2;
  v3 = *(void **)(*(_QWORD *)(a2 + 48) + 16);
  if (v3 == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id)
  {
    v9 = 1;
    v21 = 1;
    v20 = *(int8x16_t *)a1;
    v19.i64[0] = (uint64_t)&v21;
    v19.i64[1] = (uint64_t)&v22;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>((uint64_t ***)&v20, (uint64_t)&v19);
    if (v21)
      goto LABEL_9;
    v21 = 1;
    *a1[1] = 0;
    v10 = (uint64_t)*a1;
    *(_QWORD *)**a1 = 0;
    **(_QWORD **)(v10 + 8) = 0;
    *(_QWORD *)(v10 + 16) = 0;
    v19 = vextq_s8(*(int8x16_t *)a1, *(int8x16_t *)a1, 8uLL);
    v18[0] = &v21;
    v18[1] = &v22;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *> & *)#2},0ul,1ul>((uint64_t **)&v19, (uint64_t)v18);
    v9 = v21;
    if (v21)
    {
LABEL_9:
      v11 = v22;
      if (!*((_BYTE *)a1 + 24))
        *((_BYTE *)a1 + 24) = 1;
      a1[2] = v11;
    }
    return v9 != 0;
  }
  else
  {
    if (v3 != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id
      || (*(_BYTE *)(a2 + 46) & 0x80) == 0
      || *(_DWORD *)(a2 + 68) != 2)
    {
      goto LABEL_19;
    }
    v4 = (uint64_t)*a1;
    v5 = (_QWORD *)**a1;
    v6 = *(_QWORD *)(a2 + 72);
    v7 = *(_QWORD *)(v6 + 24);
    if (*v5)
    {
      v8 = *v5 == v7;
    }
    else
    {
      *v5 = v7;
      v6 = *(_QWORD *)(a2 + 72);
      v8 = 1;
    }
    v13 = *(_QWORD **)(v4 + 8);
    v14 = *(_QWORD *)(v6 + 56);
    if (*v13)
    {
      v15 = *v13 == v14;
    }
    else
    {
      *v13 = v14;
      v15 = 1;
    }
    if (v8 && v15)
    {
      *(_QWORD *)(v4 + 16) = a2;
    }
    else
    {
LABEL_19:
      if (!*(_DWORD *)(a2 + 36))
        return 0;
      v16 = a1[1];
      v17 = a2 - 16;
      if (*v16)
        return *v16 == v17;
      *v16 = v17;
    }
    return 1;
  }
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*> & *)#1},0ul,1ul>(uint64_t ***a1, uint64_t a2)
{
  uint64_t **v4;
  uint64_t result;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  uint64_t *v11;
  uint64_t v12;
  _BOOL4 v13;
  _BYTE *v14;
  uint64_t v15;
  char v16;
  uint64_t **v17;
  uint64_t *v18;
  BOOL v19;
  uint64_t v20;

  v4 = *a1;
  v20 = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v20);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id
      || (*(_BYTE *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 2)
    {
      goto LABEL_14;
    }
    v7 = *(_QWORD *)(result + 72);
    v8 = *(_QWORD *)(v7 + 24);
    v9 = **v4;
    if (v9)
    {
      v10 = v9 == v8;
    }
    else
    {
      **v4 = v8;
      v7 = *(_QWORD *)(result + 72);
      v10 = 1;
    }
    v11 = v4[1];
    v12 = *(_QWORD *)(v7 + 56);
    if (*v11)
    {
      v13 = *v11 == v12;
    }
    else
    {
      *v11 = v12;
      v13 = 1;
    }
    if (v10 && v13)
    {
      v4[2] = (uint64_t *)result;
      v6 = 1;
    }
    else
    {
LABEL_14:
      v6 = 0;
    }
  }
  v14 = *(_BYTE **)a2;
  v15 = *(_QWORD *)(a2 + 8);
  v16 = v6 & (**(_BYTE **)a2 != 0);
  if (!result)
    v16 = 0;
  *v14 = v16;
  v17 = a1[1];
  v18 = *(uint64_t **)(*(_QWORD *)(*(_QWORD *)v15 + 72) + 56);
  if (*v17)
  {
    v19 = *v17 == v18;
  }
  else
  {
    *v17 = v18;
    v14 = *(_BYTE **)a2;
    v16 = **(_BYTE **)a2 != 0;
    v19 = 1;
  }
  *v14 = v19 & v16;
  return result;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *> &,mlir::detail::RecursivePatternMatcherOptionalBinaryCommutative<mlir::mps::MultiplyOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::MatMulOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *> & *)#2},0ul,1ul>(uint64_t **a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t **v7;
  uint64_t result;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BOOL4 v13;
  uint64_t *v14;
  uint64_t v15;
  _BOOL4 v16;
  char v17;
  uint64_t v18;

  v3 = *(_QWORD *)(**(_QWORD **)(a2 + 8) + 72);
  v4 = *(_QWORD *)(v3 + 24);
  v5 = **a1;
  if (v5)
  {
    v6 = v5 == v4;
  }
  else
  {
    **a1 = v4;
    v3 = *(_QWORD *)(**(_QWORD **)(a2 + 8) + 72);
    v6 = 1;
  }
  if (!**(_BYTE **)a2)
    v6 = 0;
  **(_BYTE **)a2 = v6;
  v7 = (uint64_t **)a1[1];
  v18 = *(_QWORD *)(v3 + 56);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v18);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id
      || (*(_BYTE *)(result + 46) & 0x80) == 0
      || *(_DWORD *)(result + 68) != 2)
    {
      goto LABEL_19;
    }
    v10 = *(_QWORD *)(result + 72);
    v11 = *(_QWORD *)(v10 + 24);
    v12 = **v7;
    if (v12)
    {
      v13 = v12 == v11;
    }
    else
    {
      **v7 = v11;
      v10 = *(_QWORD *)(result + 72);
      v13 = 1;
    }
    v14 = v7[1];
    v15 = *(_QWORD *)(v10 + 56);
    if (*v14)
    {
      v16 = *v14 == v15;
    }
    else
    {
      *v14 = v15;
      v16 = 1;
    }
    v9 = v13 && v16;
    if (v9 == 1)
      v7[2] = (uint64_t *)result;
    else
LABEL_19:
      LOBYTE(v9) = 0;
  }
  v17 = v9 & (**(_BYTE **)a2 != 0);
  if (!result)
    v17 = 0;
  **(_BYTE **)a2 = v17;
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::MatMulOp &>(mlir::mps::MatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

void mlir::mps::`anonymous namespace'::CanonicalizeQuantizedMatMulExpandSqueeze::~CanonicalizeQuantizedMatMulExpandSqueeze(mlir::mps::_anonymous_namespace_::CanonicalizeQuantizedMatMulExpandSqueeze *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mpsx::QuantizedMatMulOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mpsx::QuantizedMatMulOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mpsx::QuantizedMatMulOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeQuantizedMatMulExpandSqueeze::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;
  void *v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  unint64_t SingleSqueezeIndex;
  char v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  unint64_t v24;
  unint64_t *v25;
  _QWORD *v26;
  unint64_t v27;
  uint64_t v28;
  _BOOL4 TransposeLhs;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t SingleExpandedIndex;
  char v34;
  mlir::Operation *v35;
  mlir::GenericProgramPoint *v36;
  mlir::Operation *v37;
  uint64_t v38;
  BOOL TransposeRhs;
  BOOL v40;
  uint64_t OutputType;
  uint64_t BiquantWeightsZeroPoint;
  uint64_t BiquantWeightsScale;
  uint64_t WeightsPaletteLut;
  uint64_t v45;
  uint64_t WeightsQuantParamsAxisAttr;
  uint64_t WeightsMin;
  uint64_t WeightsZeroPoint;
  uint64_t WeightsScale;
  uint64_t InputQuantParamsAxisAttr;
  uint64_t InputMin;
  uint64_t v52;
  uint64_t Weights;
  uint64_t Input;
  mlir::Operation *v55;
  _OWORD v56[2];
  uint64_t v57;
  uint64_t v58;
  _OWORD v59[2];
  uint64_t v60;
  _OWORD *InputZeroPoint;

  v55 = a2;
  Input = mlir::mpsx::QuantizedMatMulOp::getInput(&v55);
  Weights = mlir::mpsx::QuantizedMatMulOp::getWeights(&v55);
  result = mlir::Value::getDefiningOp((mlir::Value *)&Input);
  if (result)
  {
    v5 = result;
    v6 = *(void **)(*(_QWORD *)(result + 48) + 16);
    v7 = v6 == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id;
    if (v6 == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
      v8 = result;
    else
      v8 = 0;
    v52 = v8;
    if (!v7)
      return 0;
    v9 = *((unsigned int *)v55 + 9);
    v10 = (char *)v55 - 16;
    if (!(_DWORD)v9)
      v10 = 0;
    *(_QWORD *)&v59[0] = v10;
    *((_QWORD *)&v59[0] + 1) = v9;
    mlir::ResultRange::getUses((uint64_t *)v59, (uint64_t *)v56);
    v11 = v58;
    if (v57 == v58)
      return 0;
    v59[0] = v56[0];
    v59[1] = v56[1];
    v60 = v57;
    mlir::ResultRange::UseIterator::operator++((uint64_t *)v59);
    if (v60 != v11)
      return 0;
    v12 = *((unsigned int *)v55 + 9);
    v13 = (char *)v55 - 16;
    if (!(_DWORD)v12)
      v13 = 0;
    *(_QWORD *)&v59[0] = v13;
    *((_QWORD *)&v59[0] + 1) = v12;
    mlir::ResultRange::getUses((uint64_t *)v59, (uint64_t *)v56);
    result = 0;
    v14 = *(_QWORD *)(v57 + 16);
    if (v14)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)(v14 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
      {
        if (!v16)
          return 0;
        v17 = SingleSqueezeIndex;
        v18 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v52) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v18)
          goto LABEL_26;
        v19 = *v18;
        v20 = mlir::TypeID::get<mlir::ShapedType>();
        v21 = *(unsigned int *)(v19 + 16);
        if (!(_DWORD)v21)
          goto LABEL_26;
        v22 = *(_QWORD **)(v19 + 8);
        v23 = &v22[2 * v21];
        do
        {
          v24 = v21 >> 1;
          v25 = &v22[2 * (v21 >> 1)];
          v27 = *v25;
          v26 = v25 + 2;
          v21 += ~(v21 >> 1);
          if (v27 < v20)
            v22 = v26;
          else
            v21 = v24;
        }
        while (v21);
        if (v22 != v23 && *v22 == v20)
          v28 = v22[1];
        else
LABEL_26:
          v28 = 0;
        *(_QWORD *)&v59[0] = v18;
        *((_QWORD *)&v59[0] + 1) = v28;
        TransposeLhs = mlir::mpsx::QuantizedMatMulOp::getTransposeLhs(&v55);
        v30 = 1;
        if (TransposeLhs)
          v30 = 2;
        v31 = v30 + v17;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v59);
        if (v31 < v32)
        {
          if (v34)
          {
            if (SingleExpandedIndex != v17)
              return mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::QuantizedMatMulOp &>(a3, (uint64_t *)&v55, "squeezed dimension and expanded dimension did not match");
            *(_QWORD *)&v56[0] = mlir::mpsx::QuantizedMatMulOp::getInputScale(&v55);
            InputZeroPoint = (_OWORD *)mlir::mpsx::QuantizedMatMulOp::getInputZeroPoint(&v55);
            InputMin = mlir::mpsx::QuantizedMatMulOp::getInputMin(&v55);
            InputQuantParamsAxisAttr = mlir::mpsx::QuantizedMatMulOp::getInputQuantParamsAxisAttr(&v55);
            WeightsScale = mlir::mpsx::QuantizedMatMulOp::getWeightsScale(&v55);
            WeightsZeroPoint = mlir::mpsx::QuantizedMatMulOp::getWeightsZeroPoint(&v55);
            WeightsMin = mlir::mpsx::QuantizedMatMulOp::getWeightsMin(&v55);
            WeightsQuantParamsAxisAttr = mlir::mpsx::QuantizedMatMulOp::getWeightsQuantParamsAxisAttr(&v55);
            v35 = v55;
            v45 = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v52);
            WeightsPaletteLut = mlir::mpsx::QuantizedMatMulOp::getWeightsPaletteLut(&v55);
            BiquantWeightsScale = mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsScale(&v55);
            BiquantWeightsZeroPoint = mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsZeroPoint(&v55);
            OutputType = mlir::mpsx::QuantizedMatMulOp::getOutputType(&v55);
            v40 = mlir::mpsx::QuantizedMatMulOp::getTransposeLhs(&v55);
            TransposeRhs = mlir::mpsx::QuantizedMatMulOp::getTransposeRhs(&v55);
            v36 = mlir::OpBuilder::create<mlir::mpsx::QuantizedMatMulOp,mlir::Value,mlir::Value&,mlir::Value&,mlir::Value&,mlir::IntegerAttr &,mlir::Value&,mlir::Value&,mlir::Value&,mlir::Value&,mlir::IntegerAttr &,mlir::Value,mlir::detail::TypedValue<mlir::RankedTensorType>,mlir::detail::TypedValue<mlir::RankedTensorType>,mlir::Type,BOOL,BOOL>((mlir::MLIRContext **)(a3 + 8), *((_QWORD *)v35 + 3), &v45, (uint64_t *)v56, (uint64_t *)&InputZeroPoint, &InputMin, &InputQuantParamsAxisAttr, &Weights, &WeightsScale, &WeightsZeroPoint, &WeightsMin, &WeightsQuantParamsAxisAttr, &WeightsPaletteLut, &BiquantWeightsScale, &BiquantWeightsZeroPoint, &OutputType, (unsigned __int8 *)&v40, (unsigned __int8 *)&TransposeRhs);
            (*(void (**)(uint64_t, mlir::Operation *, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v35, v36);
            return 1;
          }
          return 0;
        }
        *(_QWORD *)&v56[0] = "cannot apply pattern if the squeeze is applied to the last two dimensions";
        LOWORD(v57) = 259;
        v37 = v55;
        InputZeroPoint = v56;
        v38 = *(_QWORD *)(a3 + 16);
        if (!v38)
          return 0;
        result = mlir::RewriterBase::Listener::classof(v38);
        if ((_DWORD)result)
          return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _OWORD **))(*(_QWORD *)v38 + 64))(v38, *((_QWORD *)v37 + 3), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::QuantizedMatMulOp &>(mlir::mpsx::QuantizedMatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &InputZeroPoint);
      }
    }
  }
  return result;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::QuantizedMatMulOp &>(uint64_t a1, uint64_t *a2, _BYTE *a3)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  _BYTE *v7;
  char v8;
  char v9;
  _QWORD *v10;

  v3 = 1;
  v9 = 1;
  if (*a3)
  {
    v7 = a3;
    v3 = 3;
  }
  v8 = v3;
  v4 = *a2;
  v10 = &v7;
  v5 = *(_QWORD *)(a1 + 16);
  if (!v5)
    return 0;
  result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD **))(*(_QWORD *)v5 + 64))(v5, *(_QWORD *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::QuantizedMatMulOp &>(mlir::mpsx::QuantizedMatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v10);
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::QuantizedMatMulOp &>(mlir::mpsx::QuantizedMatMulOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::QuantizedMatMulOp,mlir::Value,mlir::Value&,mlir::Value&,mlir::Value&,mlir::IntegerAttr &,mlir::Value&,mlir::Value&,mlir::Value&,mlir::Value&,mlir::IntegerAttr &,mlir::Value,mlir::detail::TypedValue<mlir::RankedTensorType>,mlir::detail::TypedValue<mlir::RankedTensorType>,mlir::Type,BOOL,BOOL>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, uint64_t *a12, uint64_t *a13, uint64_t *a14, uint64_t *a15, uint64_t *a16, unsigned __int8 *a17, unsigned __int8 *a18)
{
  uint64_t *Context;
  uint64_t v27;
  char v28;
  mlir::GenericProgramPoint *v29;
  mlir::GenericProgramPoint *v30;
  uint64_t v32;
  const char *v33;
  __int16 v34;
  uint64_t v35[4];
  __int16 v36;
  _QWORD v37[40];

  v37[38] = *MEMORY[0x1E0C80C00];
  v32 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v32);
  v27 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.quantized_matmul", (const unsigned __int8 *)0x15, Context);
  if (!v28)
  {
    v36 = 1283;
    v35[2] = (uint64_t)"mpsx.quantized_matmul";
    v35[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v34 = 259;
    llvm::operator+(v35, (uint64_t *)&v33, (uint64_t)v37);
    llvm::report_fatal_error((llvm::Twine *)v37, 1);
  }
  mlir::OperationState::OperationState(v37, a2, v27);
  mlir::mpsx::QuantizedMatMulOp::build(a1, (uint64_t)v37, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12, *a13, *a14, *a15, *a16, *a17, *a18);
  v29 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v37);
  if (*(_UNKNOWN **)(*((_QWORD *)v29 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::QuantizedMatMulOp,void>::id)
    v30 = v29;
  else
    v30 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v37);
  return v30;
}

void mlir::mps::`anonymous namespace'::CanonicalizeSDPAWithGQA::~CanonicalizeSDPAWithGQA(mlir::mps::_anonymous_namespace_::CanonicalizeSDPAWithGQA *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mpsx::ScaledDotProductAttentionOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mpsx::ScaledDotProductAttentionOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mpsx::ScaledDotProductAttentionOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeSDPAWithGQA::matchAndRewrite(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t *v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  unint64_t v44;
  unint64_t *v45;
  _QWORD *v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  unint64_t v55;
  unint64_t *v56;
  _QWORD *v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  _QWORD *v64;
  _QWORD *v65;
  unint64_t v66;
  unint64_t *v67;
  _QWORD *v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t *v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  _QWORD *v75;
  _QWORD *v76;
  unint64_t v77;
  unint64_t *v78;
  _QWORD *v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t *v82;
  uint64_t v83;
  unint64_t v84;
  unint64_t v85;
  _QWORD *v86;
  _QWORD *v87;
  unint64_t v88;
  unint64_t *v89;
  _QWORD *v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  uint64_t v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t Input;
  mlir::GenericProgramPoint *v101;
  uint64_t result;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  _QWORD v111[2];
  uint64_t v112;
  _QWORD v113[2];
  uint64_t v114;
  uint64_t v115[2];
  uint64_t v116;
  uint64_t v117;
  _QWORD v118[5];
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  _QWORD v123[2];
  uint64_t v124;
  uint64_t v125;
  _QWORD v126[2];
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  _QWORD v130[2];
  uint64_t v131;
  uint64_t v132;
  _QWORD v133[2];
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  const char *v138;
  uint64_t *v139;
  __int16 v140;

  v4 = a2;
  v136 = 0;
  v137 = a2;
  v134 = 0;
  v135 = 0;
  v133[0] = &v136;
  v133[1] = &v135;
  v131 = 0;
  v132 = 0;
  v130[0] = v133;
  v130[1] = &v132;
  v128 = 0;
  v129 = 0;
  v126[0] = &v129;
  v126[1] = &v128;
  v127 = 0;
  v125 = 0;
  v123[0] = v126;
  v123[1] = &v125;
  v124 = 0;
  v121 = 0;
  v122 = 0;
  v119 = 0;
  v120 = 0;
  v118[0] = &v120;
  v118[1] = v130;
  v118[2] = v123;
  v118[3] = &v122;
  v118[4] = &v121;
  v115[0] = a2;
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::ScaledDotProductAttentionOp,void>::id
    && (*(_BYTE *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 5)
  {
    LOBYTE(v113[0]) = 1;
    v138 = (const char *)v113;
    v139 = v115;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mpsx::ScaledDotProductAttentionOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> & *)#1},0ul,1ul,2ul,3ul,4ul>((uint64_t)v118, (uint64_t)&v138);
    if (LOBYTE(v113[0]))
    {
      v119 = v115[0];
      v138 = a3;
      v139 = &v137;
      v117 = v134;
      v5 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v117) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v5)
        goto LABEL_14;
      v6 = *v5;
      v7 = mlir::TypeID::get<mlir::ShapedType>();
      v8 = *(unsigned int *)(v6 + 16);
      if (!(_DWORD)v8)
        goto LABEL_14;
      v9 = *(_QWORD **)(v6 + 8);
      v10 = &v9[2 * v8];
      do
      {
        v11 = v8 >> 1;
        v12 = &v9[2 * (v8 >> 1)];
        v14 = *v12;
        v13 = v12 + 2;
        v8 += ~(v8 >> 1);
        if (v14 < v7)
          v9 = v13;
        else
          v8 = v11;
      }
      while (v8);
      if (v9 != v10 && *v9 == v7)
        v15 = v9[1];
      else
LABEL_14:
        v15 = 0;
      v16 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v117) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v16)
        goto LABEL_24;
      v17 = *v16;
      v18 = mlir::TypeID::get<mlir::ShapedType>();
      v19 = *(unsigned int *)(v17 + 16);
      if (!(_DWORD)v19)
        goto LABEL_24;
      v20 = *(_QWORD **)(v17 + 8);
      v21 = &v20[2 * v19];
      do
      {
        v22 = v19 >> 1;
        v23 = &v20[2 * (v19 >> 1)];
        v25 = *v23;
        v24 = v23 + 2;
        v19 += ~(v19 >> 1);
        if (v25 < v18)
          v20 = v24;
        else
          v19 = v22;
      }
      while (v19);
      if (v20 != v21 && *v20 == v18)
        v26 = v20[1];
      else
LABEL_24:
        v26 = 0;
      {
        v116 = v127;
        v27 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v116) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v27)
          goto LABEL_35;
        v28 = *v27;
        v29 = mlir::TypeID::get<mlir::ShapedType>();
        v30 = *(unsigned int *)(v28 + 16);
        if (!(_DWORD)v30)
          goto LABEL_35;
        v31 = *(_QWORD **)(v28 + 8);
        v32 = &v31[2 * v30];
        do
        {
          v33 = v30 >> 1;
          v34 = &v31[2 * (v30 >> 1)];
          v36 = *v34;
          v35 = v34 + 2;
          v30 += ~(v30 >> 1);
          if (v36 < v29)
            v31 = v35;
          else
            v30 = v33;
        }
        while (v30);
        if (v31 != v32 && *v31 == v29)
          v37 = v31[1];
        else
LABEL_35:
          v37 = 0;
        v38 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v116) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v38)
          goto LABEL_45;
        v39 = *v38;
        v40 = mlir::TypeID::get<mlir::ShapedType>();
        v41 = *(unsigned int *)(v39 + 16);
        if (!(_DWORD)v41)
          goto LABEL_45;
        v42 = *(_QWORD **)(v39 + 8);
        v43 = &v42[2 * v41];
        do
        {
          v44 = v41 >> 1;
          v45 = &v42[2 * (v41 >> 1)];
          v47 = *v45;
          v46 = v45 + 2;
          v41 += ~(v41 >> 1);
          if (v47 < v40)
            v42 = v46;
          else
            v41 = v44;
        }
        while (v41);
        if (v42 != v43 && *v42 == v40)
          v48 = v42[1];
        else
LABEL_45:
          v48 = 0;
        {
          v115[0] = (uint64_t)a3;
          v115[1] = (uint64_t)&v137;
          v114 = v131;
          v49 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v114) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v49)
            goto LABEL_56;
          v50 = *v49;
          v51 = mlir::TypeID::get<mlir::ShapedType>();
          v52 = *(unsigned int *)(v50 + 16);
          if (!(_DWORD)v52)
            goto LABEL_56;
          v53 = *(_QWORD **)(v50 + 8);
          v54 = &v53[2 * v52];
          do
          {
            v55 = v52 >> 1;
            v56 = &v53[2 * (v52 >> 1)];
            v58 = *v56;
            v57 = v56 + 2;
            v52 += ~(v52 >> 1);
            if (v58 < v51)
              v53 = v57;
            else
              v52 = v55;
          }
          while (v52);
          if (v53 != v54 && *v53 == v51)
            v59 = v53[1];
          else
LABEL_56:
            v59 = 0;
          v113[0] = v49;
          v113[1] = v59;
          v60 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v114) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v60)
            goto LABEL_66;
          v61 = *v60;
          v62 = mlir::TypeID::get<mlir::ShapedType>();
          v63 = *(unsigned int *)(v61 + 16);
          if (!(_DWORD)v63)
            goto LABEL_66;
          v64 = *(_QWORD **)(v61 + 8);
          v65 = &v64[2 * v63];
          do
          {
            v66 = v63 >> 1;
            v67 = &v64[2 * (v63 >> 1)];
            v69 = *v67;
            v68 = v67 + 2;
            v63 += ~(v63 >> 1);
            if (v69 < v62)
              v64 = v68;
            else
              v63 = v66;
          }
          while (v63);
          if (v64 != v65 && *v64 == v62)
            v70 = v64[1];
          else
LABEL_66:
            v70 = 0;
          {
            v112 = v124;
            v71 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v112) + 8) & 0xFFFFFFFFFFFFFFF8);
            if (!v71)
              goto LABEL_77;
            v72 = *v71;
            v73 = mlir::TypeID::get<mlir::ShapedType>();
            v74 = *(unsigned int *)(v72 + 16);
            if (!(_DWORD)v74)
              goto LABEL_77;
            v75 = *(_QWORD **)(v72 + 8);
            v76 = &v75[2 * v74];
            do
            {
              v77 = v74 >> 1;
              v78 = &v75[2 * (v74 >> 1)];
              v80 = *v78;
              v79 = v78 + 2;
              v74 += ~(v74 >> 1);
              if (v80 < v73)
                v75 = v79;
              else
                v74 = v77;
            }
            while (v74);
            if (v75 != v76 && *v75 == v73)
              v81 = v75[1];
            else
LABEL_77:
              v81 = 0;
            v111[0] = v71;
            v111[1] = v81;
            v82 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v112) + 8) & 0xFFFFFFFFFFFFFFF8);
            if (!v82)
              goto LABEL_87;
            v83 = *v82;
            v84 = mlir::TypeID::get<mlir::ShapedType>();
            v85 = *(unsigned int *)(v83 + 16);
            if (!(_DWORD)v85)
              goto LABEL_87;
            v86 = *(_QWORD **)(v83 + 8);
            v87 = &v86[2 * v85];
            do
            {
              v88 = v85 >> 1;
              v89 = &v86[2 * (v85 >> 1)];
              v91 = *v89;
              v90 = v89 + 2;
              v85 += ~(v85 >> 1);
              if (v91 < v84)
                v86 = v90;
              else
                v85 = v88;
            }
            while (v85);
            if (v86 != v87 && *v86 == v84)
              v92 = v86[1];
            else
LABEL_87:
              v92 = 0;
            {
              v93 = *(_QWORD *)(v137 + 24);
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v113);
              LODWORD(v109) = v94 - 3;
              v110 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((mlir::mps::ConstantOp *)(a3 + 8), v93, (unsigned int *)&v109)- 16;
              v95 = *(_QWORD *)(v137 + 24);
              mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v111);
              LODWORD(v108) = v96 - 3;
              v109 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((mlir::mps::ConstantOp *)(a3 + 8), v95, (unsigned int *)&v108)- 16;
              v97 = *(_QWORD *)(v137 + 24);
              v107 = v136;
              v108 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::Value&>((mlir::OpBuilder *)(a3 + 8), v97, &v107, &v110)- 16;
              v98 = *(_QWORD *)(v137 + 24);
              v106 = v129;
              v107 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::Value&>((mlir::OpBuilder *)(a3 + 8), v98, &v106, &v109)- 16;
              v99 = v137;
              Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v137);
              v105 = v122;
              v106 = Input;
              v104 = v121;
              v101 = mlir::OpBuilder::create<mlir::mpsx::ScaledDotProductAttentionOp,mlir::Value,mlir::Value,mlir::Value,mlir::Value&,mlir::Value&>((mlir::Float32Type **)a3 + 1, *(_QWORD *)(v99 + 24), &v106, &v108, &v107, &v105, &v104);
              (*(void (**)(char *, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v99, v101);
              return 1;
            }
          }
        }
      }
      return 0;
    }
    v4 = v137;
  }
  v138 = "failed: root pattern did not match";
  v140 = 259;
  v115[0] = (uint64_t)&v138;
  v103 = *((_QWORD *)a3 + 2);
  if (!v103)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v103);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v103 + 64))(v103, *(_QWORD *)(v4 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::ScaledDotProductAttentionOp &>(mlir::mpsx::ScaledDotProductAttentionOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v115);
  return result;
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeSDPAWithGQA::matchAndRewrite(mlir::mpsx::ScaledDotProductAttentionOp,mlir::PatternRewriter &)const::{lambda(mlir::ShapedType,mlir::ShapedType)#1}::operator()(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t ArgAttrsAttr;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  const char *v21;
  uint64_t v22;
  _QWORD v24[2];
  _QWORD v25[2];
  const char *v26;
  __int16 v27;
  const char **v28;
  void *v29;
  uint64_t v30;
  _QWORD v31[7];

  v31[6] = *MEMORY[0x1E0C80C00];
  v25[0] = a2;
  v25[1] = a3;
  v24[0] = a4;
  v24[1] = a5;
  v29 = v31;
  v30 = 0x600000000;
  ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v25);
  v8 = v7;
  v9 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v24);
  if (v8 && v10)
  {
    v11 = v9;
    v12 = 0;
    v13 = 8 * v10 - 8;
    v14 = 8 * v8 - 8;
    do
    {
      if (*(_QWORD *)(ArgAttrsAttr + 8 * v12) != *(_QWORD *)(v11 + 8 * v12))
      {
        v15 = v30;
        if (v30 >= (unint64_t)HIDWORD(v30))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v29, v31, v30 + 1, 8);
          v15 = v30;
        }
        *((_QWORD *)v29 + v15) = v12;
        LODWORD(v30) = v30 + 1;
      }
      if (!v14)
        break;
      ++v12;
      v16 = v13;
      v13 -= 8;
      v14 -= 8;
    }
    while (v16);
  }
  if ((_DWORD)v30 == 1)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v25);
    if (v17 - 3 == *(_QWORD *)v29)
    {
      v18 = 1;
      goto LABEL_19;
    }
    v19 = *a1;
    v20 = (uint64_t *)a1[1];
    v21 = "failed: pattern can be applied only if the broadcasting dimension is the head dimension";
  }
  else
  {
    v19 = *a1;
    v20 = (uint64_t *)a1[1];
    v21 = "failed: pattern can match only a single broadcasting dimension";
  }
  v26 = v21;
  v27 = 259;
  v22 = *v20;
  v28 = &v26;
  v18 = *(_QWORD *)(v19 + 16);
  if (v18)
  {
    if (mlir::RewriterBase::Listener::classof(*(_QWORD *)(v19 + 16)))
      v18 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), const char ***))(*(_QWORD *)v18 + 64))(v18, *(_QWORD *)(v22 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::ScaledDotProductAttentionOp &>(mlir::mpsx::ScaledDotProductAttentionOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v28);
    else
      v18 = 0;
  }
LABEL_19:
  if (v29 != v31)
    free(v29);
  return v18;
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeSDPAWithGQA::matchAndRewrite(mlir::mpsx::ScaledDotProductAttentionOp,mlir::PatternRewriter &)const::{lambda(mlir::ShapedType,mlir::ShapedType)#2}::operator()(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[2];
  _QWORD v19[2];
  const char *v20;
  __int16 v21;
  const char **v22;

  v19[0] = a2;
  v19[1] = a3;
  v18[0] = a4;
  v18[1] = a5;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v19);
  v7 = v6;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v18);
  if (v7 > 4 || v8 >= 4)
  {
    v10 = v8;
    v11 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v19)
                    + 8 * (v7 - 4));
    v12 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v19)
                    + 8 * (v7 - 3))
        * v11;
    if (v12 == *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v18)
                          + 8 * (v10 - 3)))
      return 1;
  }
  v14 = *a1;
  v15 = (uint64_t *)a1[1];
  v20 = "failed: reshape does not concatenate groups";
  v21 = 259;
  v16 = *v15;
  v22 = &v20;
  v17 = *(_QWORD *)(v14 + 16);
  if (!v17)
    return 0;
  result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(v14 + 16));
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), const char ***))(*(_QWORD *)v17 + 64))(v17, *(_QWORD *)(v16 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::ScaledDotProductAttentionOp &>(mlir::mpsx::ScaledDotProductAttentionOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v22);
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::Value,mlir::Value&>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.squeeze", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.squeeze";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::SqueezeOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SqueezeOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

uint64_t mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mpsx::ScaledDotProductAttentionOp,mlir::detail::any_value_binder,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>> *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> & *)#1},0ul,1ul,2ul,3ul,4ul>(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  char v8;
  uint64_t *v9;
  char v10;
  uint64_t result;
  BOOL *v12;
  uint64_t v13;
  BOOL v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  BOOL v19;
  _QWORD *v20;
  uint64_t v21;
  BOOL v22;

  v4 = *(_QWORD **)a1;
  v5 = **(_QWORD **)(a2 + 8);
  v6 = *(_QWORD *)(*(_QWORD *)(v5 + 72) + 24);
  if (*v4)
  {
    v7 = *v4 == v6;
  }
  else
  {
    *v4 = v6;
    v5 = **(_QWORD **)(a2 + 8);
    v7 = 1;
  }
  if (!**(_BYTE **)a2)
    v7 = 0;
  **(_BYTE **)a2 = v7;
  v8 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(v5, 1u, *(_QWORD *)(a1 + 8));
  v9 = *(uint64_t **)(a2 + 8);
  if (**(_BYTE **)a2)
    v10 = v8;
  else
    v10 = 0;
  **(_BYTE **)a2 = v10;
  result = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(*v9, 2u, *(_QWORD *)(a1 + 16));
  v12 = *(BOOL **)a2;
  v13 = *(_QWORD *)(a2 + 8);
  if (**(_BYTE **)a2)
    v14 = result;
  else
    v14 = 0;
  *v12 = v14;
  v15 = *(_QWORD **)(a1 + 24);
  v16 = *(_QWORD *)(*(_QWORD *)v13 + 72);
  v17 = *(_QWORD *)(v16 + 120);
  if (*v15)
  {
    v18 = *v15 == v17;
  }
  else
  {
    *v15 = v17;
    v12 = *(BOOL **)a2;
    v16 = *(_QWORD *)(**(_QWORD **)(a2 + 8) + 72);
    v14 = **(_BYTE **)a2 != 0;
    v18 = 1;
  }
  v19 = v18 && v14;
  *v12 = v19;
  v20 = *(_QWORD **)(a1 + 32);
  v21 = *(_QWORD *)(v16 + 152);
  if (*v20)
  {
    v22 = *v20 == v21;
  }
  else
  {
    *v20 = v21;
    v12 = *(BOOL **)a2;
    v19 = **(_BYTE **)a2 != 0;
    v22 = 1;
  }
  *v12 = v22 && v19;
  return result;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::ReshapeOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t DefiningOp;
  char v5;
  uint64_t v6;
  int v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v11;

  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v11);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id
      && (*(_BYTE *)(DefiningOp + 46) & 0x80) != 0
      && *(_DWORD *)(DefiningOp + 68) == 2
      && (v7 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(DefiningOp, 0, *(uint64_t ***)a3), v8 = *(uint64_t **)(a3 + 8), v11 = *(_QWORD *)(*(_QWORD *)(v6 + 72) + 56), (v9 = mlir::Value::getDefiningOp((mlir::Value *)&v11)) != 0)&& *(_UNKNOWN **)(*(_QWORD *)(v9 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id&& (!*v8 || *v8 == v9)&& (*v8 = v9, v7))
    {
      *(_QWORD *)(a3 + 16) = v6;
      v5 = 1;
    }
    else
    {
      v5 = 0;
    }
  }
  return (v6 != 0) & v5;
}

uint64_t mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::BroadcastToOp,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  uint64_t DefiningOp;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v14;

  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 32 * a2 + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v14);
  v6 = DefiningOp;
  if (DefiningOp)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::mps::BroadcastToOp,void>::id
      || (*(_BYTE *)(DefiningOp + 46) & 0x80) == 0
      || *(_DWORD *)(DefiningOp + 68) != 2)
    {
      goto LABEL_15;
    }
    v7 = *(_QWORD *)(DefiningOp + 72);
    v8 = *(_QWORD *)(v7 + 24);
    v9 = **a3;
    if (v9)
    {
      v10 = v9 == v8;
    }
    else
    {
      **a3 = v8;
      v7 = *(_QWORD *)(DefiningOp + 72);
      v10 = 1;
    }
    if ((v11 = a3[1], v14 = *(_QWORD *)(v7 + 56), (v12 = mlir::Value::getDefiningOp((mlir::Value *)&v14)) != 0)
      && *(_UNKNOWN **)(*(_QWORD *)(v12 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id
      && (!*v11 || *v11 == v12)
      && (*v11 = v12, v10))
    {
      a3[2] = (uint64_t *)v6;
      v5 = 1;
    }
    else
    {
LABEL_15:
      v5 = 0;
    }
  }
  return (v6 != 0) & v5;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mpsx::ScaledDotProductAttentionOp &>(mlir::mpsx::ScaledDotProductAttentionOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

void mlir::mps::`anonymous namespace'::CanonicalizeQuantizedGather::~CanonicalizeQuantizedGather(mlir::mps::_anonymous_namespace_::CanonicalizeQuantizedGather *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::GatherOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::GatherOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::GatherOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeQuantizedGather::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t SparseShape;
  uint64_t Bias;
  uint64_t Input;
  uint64_t Filter;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t *v16;
  _QWORD *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  unint64_t v37;
  unint64_t *v38;
  _QWORD *v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  unint64_t v48;
  unint64_t *v49;
  _QWORD *v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t result;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  BOOL v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  mlir::GenericProgramPoint *v64;
  BOOL InferredResultTypes;
  unsigned int Count;
  uint64_t FunctionType;
  void *v68;
  char v69;
  void *v70[2];
  char v71;
  void *v72[2];
  char v73;
  void *__p[2];
  char v75;
  uint64_t v76[2];
  _QWORD v77[2];
  _QWORD v78[2];
  _QWORD v79[2];
  _QWORD v80[2];
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87[3];
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  _QWORD v91[4];
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98[4];
  __int16 v99;
  uint64_t *v100;

  v96 = 0;
  v97 = a2;
  v94 = 0;
  v95 = 0;
  v91[0] = &v96;
  v91[1] = &v95;
  v91[2] = &v94;
  v91[3] = &v93;
  v92 = 0;
  v93 = 0;
  v89 = 0;
  v90 = 0;
  v87[0] = (uint64_t)v91;
  v87[1] = (uint64_t)&v90;
  v87[2] = (uint64_t)&v89;
  v88 = 0;
  v80[0] = a2;
  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::GatherOp,void>::id
    && (*(_BYTE *)(a2 + 46) & 0x80) != 0
    && *(_DWORD *)(a2 + 68) == 3)
  {
    LOBYTE(v79[0]) = 1;
    v98[0] = (uint64_t)v79;
    v98[1] = (uint64_t)v80;
    mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::GatherOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> & *)#1},0ul,1ul,2ul>(v87, (uint64_t)v98);
    if (LOBYTE(v79[0]))
    {
      v88 = v80[0];
      v85 = v80[0];
      v86 = v92;
      SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v86);
      v84 = SparseShape;
      Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v86);
      v83 = Bias;
      Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v86);
      v82 = Input;
      Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v86);
      v81 = Filter;
      v9 = (uint64_t *)(*(_QWORD *)(Input + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v9)
        goto LABEL_14;
      v10 = *v9;
      v11 = mlir::TypeID::get<mlir::ShapedType>();
      v12 = *(unsigned int *)(v10 + 16);
      if (!(_DWORD)v12)
        goto LABEL_14;
      v13 = *(_QWORD **)(v10 + 8);
      v14 = &v13[2 * v12];
      do
      {
        v15 = v12 >> 1;
        v16 = &v13[2 * (v12 >> 1)];
        v18 = *v16;
        v17 = v16 + 2;
        v12 += ~(v12 >> 1);
        if (v18 < v11)
          v13 = v17;
        else
          v12 = v15;
      }
      while (v12);
      if (v13 != v14 && *v13 == v11)
        v19 = v13[1];
      else
LABEL_14:
        v19 = 0;
      v80[0] = v9;
      v80[1] = v19;
      v20 = (uint64_t *)(*(_QWORD *)(Filter + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v20)
        goto LABEL_24;
      v21 = *v20;
      v22 = mlir::TypeID::get<mlir::ShapedType>();
      v23 = *(unsigned int *)(v21 + 16);
      if (!(_DWORD)v23)
        goto LABEL_24;
      v24 = *(_QWORD **)(v21 + 8);
      v25 = &v24[2 * v23];
      do
      {
        v26 = v23 >> 1;
        v27 = &v24[2 * (v23 >> 1)];
        v29 = *v27;
        v28 = v27 + 2;
        v23 += ~(v23 >> 1);
        if (v29 < v22)
          v24 = v28;
        else
          v23 = v26;
      }
      while (v23);
      if (v24 != v25 && *v24 == v22)
        v30 = v24[1];
      else
LABEL_24:
        v30 = 0;
      v79[0] = v20;
      v79[1] = v30;
      v31 = (uint64_t *)(*(_QWORD *)(SparseShape + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v31)
        goto LABEL_34;
      v32 = *v31;
      v33 = mlir::TypeID::get<mlir::ShapedType>();
      v34 = *(unsigned int *)(v32 + 16);
      if (!(_DWORD)v34)
        goto LABEL_34;
      v35 = *(_QWORD **)(v32 + 8);
      v36 = &v35[2 * v34];
      do
      {
        v37 = v34 >> 1;
        v38 = &v35[2 * (v34 >> 1)];
        v40 = *v38;
        v39 = v38 + 2;
        v34 += ~(v34 >> 1);
        if (v40 < v33)
          v35 = v39;
        else
          v34 = v37;
      }
      while (v34);
      if (v35 != v36 && *v35 == v33)
        v41 = v35[1];
      else
LABEL_34:
        v41 = 0;
      v78[0] = v31;
      v78[1] = v41;
      v42 = (uint64_t *)(*(_QWORD *)(Bias + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v42)
        goto LABEL_44;
      v43 = *v42;
      v44 = mlir::TypeID::get<mlir::ShapedType>();
      v45 = *(unsigned int *)(v43 + 16);
      if (!(_DWORD)v45)
        goto LABEL_44;
      v46 = *(_QWORD **)(v43 + 8);
      v47 = &v46[2 * v45];
      do
      {
        v48 = v45 >> 1;
        v49 = &v46[2 * (v45 >> 1)];
        v51 = *v49;
        v50 = v49 + 2;
        v45 += ~(v45 >> 1);
        if (v51 < v44)
          v46 = v50;
        else
          v45 = v48;
      }
      while (v45);
      if (v46 != v47 && *v46 == v44)
        v52 = v46[1];
      else
LABEL_44:
        v52 = 0;
      v77[0] = v42;
      v77[1] = v52;
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v80))
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v80);
        v54 = v53 & ~(v53 >> 63);
      }
      else
      {
        v54 = 0;
      }
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v79))
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v79);
        if (v54 <= v57)
          v54 = v57;
      }
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v78))
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v78);
        if (v54 <= v58)
          v54 = v58;
      }
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v77))
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v77);
        if (v54 <= v59)
          v54 = v59;
      }
      v76[0] = a3;
      v76[1] = (uint64_t)&v97;
      v75 = 5;
      strcpy((char *)__p, "input");
      {
        v60 = 1;
        if (v75 < 0)
          goto LABEL_69;
        goto LABEL_66;
      }
      v73 = 5;
      strcpy((char *)v72, "scale");
      {
        v71 = 9;
        strcpy((char *)v70, "zeroPoint");
        {
          v69 = 3;
          LODWORD(v68) = 7235949;
          if ((v71 & 0x80000000) == 0)
            goto LABEL_64;
        }
        else
        {
          v60 = 1;
          if ((v71 & 0x80000000) == 0)
          {
LABEL_64:
            if ((v73 & 0x80000000) == 0)
              goto LABEL_65;
            goto LABEL_77;
          }
        }
        operator delete(v70[0]);
        if (v73 < 0)
        {
LABEL_77:
          operator delete(v72[0]);
          if (v75 < 0)
            goto LABEL_69;
LABEL_66:
          if (v60)
            return 0;
          goto LABEL_70;
        }
      }
      else
      {
        v60 = 1;
        if (v73 < 0)
          goto LABEL_77;
      }
LABEL_65:
      if ((v75 & 0x80000000) == 0)
        goto LABEL_66;
LABEL_69:
      operator delete(__p[0]);
      if (v60)
        return 0;
LABEL_70:
      if ((mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v86) & 0xFF00000000) == 0)
      {
        v63 = v97;
        v98[0] = v90;
        v100 = (uint64_t *)v89;
        FunctionType = mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v86);
        Count = mlir::pdl_interp::CheckOperandCountOp::getCount((mlir::pdl_interp::CheckOperandCountOp *)&v85);
        InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v85);
        v64 = mlir::OpBuilder::create<mlir::mpsx::QuantizedGatherOp,mlir::Value &,mlir::Value,mlir::Value,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Type,unsigned int,BOOL>((mlir::MLIRContext **)(a3 + 8), *(_QWORD *)(v63 + 24), &v82, v98, (uint64_t *)&v100, &v81, &v83, &v84, &FunctionType, &Count, (char *)&InferredResultTypes);
        (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v63, v64);
        return 1;
      }
      v98[0] = (uint64_t)"can't fuse the dequantize op which has the broadcast axis";
      v99 = 259;
      v61 = v97;
      v100 = v98;
      v62 = *(_QWORD *)(a3 + 16);
      if (v62)
      {
        result = mlir::RewriterBase::Listener::classof(v62);
        if ((_DWORD)result)
          return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t **))(*(_QWORD *)v62 + 64))(v62, *(_QWORD *)(v61 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v100);
        return result;
      }
      return 0;
    }
  }
  v98[0] = (uint64_t)"failed: root pattern did not match";
  v99 = 259;
  v80[0] = v98;
  v55 = *(_QWORD *)(a3 + 16);
  if (!v55)
    return 0;
  result = mlir::RewriterBase::Listener::classof(v55);
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), _QWORD *))(*(_QWORD *)v55 + 64))(v55, *(_QWORD *)(a2 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v80);
  return result;
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeQuantizedGather::matchAndRewrite(mlir::mps::GatherOp,mlir::PatternRewriter &)const::{lambda(mlir::ShapedType const&,long long,mlir::Value &,std::string)#1}::operator()(uint64_t *a1, mlir::CallOpInterface *this, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t DefiningOp;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  const void *ArgAttrsAttr;
  uint64_t v17;
  uint64_t j;
  void *v19;
  uint64_t v20;
  uint64_t OperandRange;
  uint64_t *v22;
  uint64_t v23;
  void *v24;
  void *v25;
  uint64_t v26;
  uint64_t *v27;
  std::string *v28;
  std::string::size_type v29;
  std::string *v30;
  std::string::size_type size;
  std::string *v32;
  std::string::size_type v33;
  uint64_t v34;
  uint64_t v35;
  std::string::size_type v36;
  uint64_t IntegerType;
  _QWORD *v38;
  _QWORD *v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  _QWORD *v43;
  _QWORD *v44;
  unint64_t v45;
  unint64_t *v46;
  _QWORD *v47;
  unint64_t v48;
  uint64_t v49;
  unsigned int v51;
  uint64_t i;
  void *v53;
  uint64_t v54;
  uint64_t *v55;
  std::string *v56;
  std::string::size_type v57;
  std::string v58;
  std::string v59;
  void *__p[2];
  std::string::size_type v61;
  void **v62;
  void *v63;
  uint64_t v64;
  _BYTE v65[16];
  __int16 v66;
  std::string v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  if (!mlir::CallOpInterface::getArgOperands(this))
    return 1;
  mlir::CallableOpInterface::getArgAttrsAttr(this);
  if (a3 <= v8)
  {
    if (a3 >= v8)
      return 1;
    v26 = *a1;
    v27 = (uint64_t *)a1[1];
    std::operator+<char>();
    v28 = std::string::append(&v59, " tensor to ");
    v29 = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v67.__r_.__value_.__l.__data_ = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    v67.__r_.__value_.__r.__words[2] = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v58, a3);
    if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v30 = &v58;
    else
      v30 = (std::string *)v58.__r_.__value_.__r.__words[0];
    if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v58.__r_.__value_.__r.__words[2]);
    else
      size = v58.__r_.__value_.__l.__size_;
    v32 = std::string::append(&v67, (const std::string::value_type *)v30, size);
    v33 = v32->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v61 = v33;
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    v66 = 260;
    v63 = __p;
    v34 = *v27;
    v62 = &v63;
    v35 = *(_QWORD *)(v26 + 16);
    if (v35)
    {
      if (!mlir::RewriterBase::Listener::classof(v35))
      {
        v35 = 0;
        if ((SHIBYTE(v61) & 0x80000000) == 0)
        {
LABEL_29:
          if ((SHIBYTE(v58.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_30;
          goto LABEL_55;
        }
LABEL_54:
        operator delete(__p[0]);
        if ((SHIBYTE(v58.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_30:
          if ((SHIBYTE(v67.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_31;
          goto LABEL_56;
        }
LABEL_55:
        operator delete(v58.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v67.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_31:
          if ((SHIBYTE(v59.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            return v35;
LABEL_57:
          v53 = (void *)v59.__r_.__value_.__r.__words[0];
LABEL_58:
          operator delete(v53);
          return v35;
        }
LABEL_56:
        operator delete(v67.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v59.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          return v35;
        goto LABEL_57;
      }
      v35 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), void ***))(*(_QWORD *)v35 + 64))(v35, *(_QWORD *)(v34 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v62);
    }
    if ((SHIBYTE(v61) & 0x80000000) == 0)
      goto LABEL_29;
    goto LABEL_54;
  }
  v9 = v8;
  v59.__r_.__value_.__r.__words[0] = mlir::MemoryMapperInterface::getOperandRange(this);
  if (*(_UNKNOWN **)(*(_QWORD *)v59.__r_.__value_.__l.__data_ + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    || mlir::Type::isInteger((mlir::Type *)&v59, 1)
    || mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v59) > 7)
  {
    v63 = v65;
    v64 = 0x400000000;
    v36 = a3 - v9;
    if (v36)
    {
      v51 = 0;
      for (i = 0; i != v36; ++i)
      {
        if (v51 >= HIDWORD(v64))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v65, v51 + 1, 4);
          v51 = v64;
        }
        *((_DWORD *)v63 + v51) = i;
        v51 = v64 + 1;
        LODWORD(v64) = v64 + 1;
      }
    }
    v67.__r_.__value_.__r.__words[0] = v36;
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(*a1 + 8), 0x20u, 1);
    v38 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v67, 1, IntegerType, 0);
    v39 = v38;
    if (!v38)
      goto LABEL_43;
    v40 = *v38;
    v41 = mlir::TypeID::get<mlir::ShapedType>();
    v42 = *(unsigned int *)(v40 + 16);
    if (!(_DWORD)v42)
      goto LABEL_43;
    v43 = *(_QWORD **)(v40 + 8);
    v44 = &v43[2 * v42];
    do
    {
      v45 = v42 >> 1;
      v46 = &v43[2 * (v42 >> 1)];
      v48 = *v46;
      v47 = v46 + 2;
      v42 += ~(v42 >> 1);
      if (v48 < v41)
        v43 = v47;
      else
        v42 = v45;
    }
    while (v42);
    if (v43 != v44 && *v43 == v41)
      v49 = v43[1];
    else
LABEL_43:
      v49 = 0;
    __p[0] = (void *)mlir::DenseElementsAttr::getFromRawBuffer(v39, v49, v63, 4 * v64, 4, 1, 1);
    v67.__r_.__value_.__r.__words[0] = (std::string::size_type)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(*a1 + 8), *(_QWORD *)(*(_QWORD *)a1[1] + 24), (uint64_t **)__p)- 16;
    *a4 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(*a1 + 8), *(_QWORD *)(*(_QWORD *)a1[1] + 24), a4, (uint64_t *)&v67)- 16;
    v25 = v63;
    if (v63 == v65)
      return 1;
LABEL_45:
    free(v25);
    return 1;
  }
  __p[0] = (void *)*a4;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)__p);
  if (DefiningOp)
  {
    v11 = DefiningOp;
    v12 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v11 + 48) + 32))(*(_QWORD *)(v11 + 48), v12))
    {
      v63 = v65;
      v64 = 0x100000000;
      mlir::Operation::fold(v11, 0, 0, (uint64_t)&v63);
      v14 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v63 & 0xFFFFFFFFFFFFFFF8));
      if (v14)
        v15 = v13;
      else
        v15 = 0;
      if (v63 != v65)
        free(v63);
      if (v14)
      {
        ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr(this);
        llvm::SmallVector<mlir::Value,4u>::SmallVector(&v63, ArgAttrsAttr, v17);
        for (j = a3 - v9; j; --j)
        {
          __p[0] = (void *)1;
          llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v63, (uint64_t)v63, (uint64_t *)__p);
        }
        v19 = v63;
        v20 = v64;
        OperandRange = mlir::MemoryMapperInterface::getOperandRange(this);
        v67.__r_.__value_.__r.__words[0] = mlir::RankedTensorType::get((uint64_t)v19, v20, OperandRange, 0);
        v22 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v67);
        __p[0] = mlir::reshapeElementsAttr((uint64_t)v14, v15, (uint64_t)v22, v23);
        __p[1] = v24;
        *a4 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ElementsAttr &>((mlir::OpBuilder *)(*a1 + 8), *(_QWORD *)(*(_QWORD *)a1[1] + 24), (uint64_t)__p)- 16;
        v25 = v63;
        if (v63 == v65)
          return 1;
        goto LABEL_45;
      }
    }
  }
  v54 = *a1;
  v55 = (uint64_t *)a1[1];
  std::operator+<char>();
  v56 = std::string::append(&v67, ", because it is not a constant");
  v57 = v56->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
  v61 = v57;
  v56->__r_.__value_.__l.__size_ = 0;
  v56->__r_.__value_.__r.__words[2] = 0;
  v56->__r_.__value_.__r.__words[0] = 0;
  v66 = 260;
  v63 = __p;
  v35 = mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(v54, v55, (uint64_t)&v63);
  if (SHIBYTE(v61) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0)
  {
    v53 = (void *)v67.__r_.__value_.__r.__words[0];
    goto LABEL_58;
  }
  return v35;
}

uint64_t **mlir::detail::enumerateImpl<std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::GatherOp,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder> *,mlir::detail::any_value_binder*,mlir::detail::any_value_binder*> & *)#1},0ul,1ul,2ul>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t **result;
  BOOL v6;
  uint64_t **v7;
  int v8;
  BOOL *v9;
  BOOL v10;
  BOOL v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  BOOL v16;
  _QWORD *v17;
  uint64_t v18;
  BOOL v19;
  _QWORD v20[2];
  unsigned __int8 v21;
  uint64_t **v22;

  v4 = *a1;
  v20[0] = *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(a2 + 8) + 72) + 24);
  result = (uint64_t **)mlir::Value::getDefiningOp((mlir::Value *)v20);
  v7 = result;
  if (result)
  {
    v22 = result;
    if ((_UNKNOWN *)result[6][2] == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id
      && (*((_BYTE *)result + 46) & 0x80) != 0
      && *((_DWORD *)result + 17) == 4)
    {
      v21 = 1;
      v20[0] = &v21;
      v20[1] = &v22;
      result = mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> & *)#1},0ul,1ul,2ul,3ul>((uint64_t **)v4, (uint64_t)v20);
      v8 = v21;
      if (v21)
        *(_QWORD *)(v4 + 32) = v22;
      v6 = v8 != 0;
    }
    else
    {
      v6 = 0;
    }
  }
  v9 = *(BOOL **)a2;
  v10 = v6 && **(_BYTE **)a2 != 0;
  if (v7)
    v11 = v10;
  else
    v11 = 0;
  *v9 = v11;
  v12 = (_QWORD *)a1[1];
  v13 = *(_QWORD *)(**(_QWORD **)(a2 + 8) + 72);
  v14 = *(_QWORD *)(v13 + 56);
  if (*v12)
  {
    v15 = *v12 == v14;
  }
  else
  {
    *v12 = v14;
    v9 = *(BOOL **)a2;
    v13 = *(_QWORD *)(**(_QWORD **)(a2 + 8) + 72);
    v11 = **(_BYTE **)a2 != 0;
    v15 = 1;
  }
  v16 = v15 && v11;
  *v9 = v16;
  v17 = (_QWORD *)a1[2];
  v18 = *(_QWORD *)(v13 + 88);
  if (*v17)
  {
    v19 = *v17 == v18;
  }
  else
  {
    *v17 = v18;
    v9 = *(BOOL **)a2;
    v16 = **(_BYTE **)a2 != 0;
    v19 = 1;
  }
  *v9 = v19 && v16;
  return result;
}

uint64_t **mlir::detail::enumerateImpl<std::tuple<mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> &,mlir::detail::RecursivePatternMatcherBinder<mlir::mps::DequantizeOp,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder,mlir::detail::any_value_binder>::match(mlir::Operation *)::{lambda(unsigned long,std::tuple<mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *,mlir::detail::any_value_binder *> & *)#1},0ul,1ul,2ul,3ul>(uint64_t **result, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  BOOL *v6;
  uint64_t *v7;
  uint64_t v8;
  BOOL v9;
  BOOL v10;
  uint64_t *v11;
  uint64_t v12;
  BOOL v13;
  BOOL v14;
  uint64_t *v15;
  uint64_t v16;
  BOOL v17;

  v2 = *(_QWORD **)(**(_QWORD **)(a2 + 8) + 72);
  v3 = v2[3];
  v4 = **result;
  if (v4)
  {
    v5 = v4 == v3;
  }
  else
  {
    **result = v3;
    v2 = *(_QWORD **)(**(_QWORD **)(a2 + 8) + 72);
    v5 = 1;
  }
  v6 = *(BOOL **)a2;
  if (!**(_BYTE **)a2)
    v5 = 0;
  *v6 = v5;
  v7 = result[1];
  v8 = v2[7];
  if (*v7)
  {
    v9 = *v7 == v8;
  }
  else
  {
    *v7 = v8;
    v6 = *(BOOL **)a2;
    v2 = *(_QWORD **)(**(_QWORD **)(a2 + 8) + 72);
    v5 = **(_BYTE **)a2 != 0;
    v9 = 1;
  }
  v10 = v9 && v5;
  *v6 = v10;
  v11 = result[2];
  v12 = v2[11];
  if (*v11)
  {
    v13 = *v11 == v12;
  }
  else
  {
    *v11 = v12;
    v6 = *(BOOL **)a2;
    v2 = *(_QWORD **)(**(_QWORD **)(a2 + 8) + 72);
    v10 = **(_BYTE **)a2 != 0;
    v13 = 1;
  }
  v14 = v13 && v10;
  *v6 = v14;
  v15 = result[3];
  v16 = v2[15];
  if (*v15)
  {
    v17 = *v15 == v16;
  }
  else
  {
    *v15 = v16;
    v6 = *(BOOL **)a2;
    v14 = **(_BYTE **)a2 != 0;
    v17 = 1;
  }
  *v6 = v17 && v14;
  return result;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;

  v3 = *a2;
  v6 = a3;
  v4 = *(_QWORD *)(a1 + 16);
  if (!v4)
    return 0;
  result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(_QWORD *)v4 + 64))(v4, *(_QWORD *)(v3 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v6);
  return result;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::mps::GatherOp &>(mlir::mps::GatherOp &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>(const void ****a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, *a1);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ElementsAttr &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.constant";
    v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ConstantOp::build((uint64_t)a1, (uint64_t)v17, *(_QWORD **)a3, *(_QWORD *)(a3 + 8));
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.expand_dims", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.expand_dims";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ExpandDimsOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::QuantizedGatherOp,mlir::Value &,mlir::Value,mlir::Value,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Type,unsigned int,BOOL>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, unsigned int *a10, char *a11)
{
  uint64_t *Context;
  uint64_t v20;
  char v21;
  mlir::GenericProgramPoint *v22;
  mlir::GenericProgramPoint *v23;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  uint64_t v28[4];
  __int16 v29;
  _QWORD v30[40];

  v30[38] = *MEMORY[0x1E0C80C00];
  v25 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  v20 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.quantized_gather", (const unsigned __int8 *)0x15, Context);
  if (!v21)
  {
    v29 = 1283;
    v28[2] = (uint64_t)"mpsx.quantized_gather";
    v28[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v20);
  mlir::mpsx::QuantizedGatherOp::build(a1, (uint64_t)v30, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11);
  v22 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((_QWORD *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::QuantizedGatherOp,void>::id)
    v23 = v22;
  else
    v23 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

void mlir::mps::`anonymous namespace'::CanonicalizeMatMulTransposeConstantRHS::~CanonicalizeMatMulTransposeConstantRHS(mlir::mps::_anonymous_namespace_::CanonicalizeMatMulTransposeConstantRHS *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeMatMulTransposeConstantRHS::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *Filter;
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *ArgAttrsAttr;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t DefiningOp;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  mlir::GenericProgramPoint *v27;
  unsigned __int8 v29;
  uint64_t Input;
  unsigned int v31;
  _QWORD v32[2];
  _QWORD *v33;
  uint64_t v34;
  void *v35[2];
  _QWORD v36[2];

  v36[1] = *MEMORY[0x1E0C80C00];
  v34 = a2;
  Filter = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v34);
  v33 = Filter;
  v5 = (uint64_t *)(Filter[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v32[0] = v5;
  v32[1] = v15;
  if (!*Filter
    || *(_QWORD *)*Filter
    || mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v34)
    || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v32))
  {
    return 0;
  }
  ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
  if (v17)
  {
    v18 = 8 * v17;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v18 -= 8;
      if (!v18)
        goto LABEL_19;
    }
    return 0;
  }
LABEL_19:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
  if (v19 < 2)
    return 0;
  v35[0] = Filter;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v35);
  if (!DefiningOp)
    return 0;
  v21 = DefiningOp;
  v22 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v21 + 48) + 32))(*(_QWORD *)(v21 + 48), v22))
    return 0;
  v23 = *(_QWORD *)(v34 + 24);
  LODWORD(Input) = -1;
  v31 = -2;
  v35[0] = v36;
  v35[1] = (void *)0x100000000;
  mlir::OpBuilder::createOrFold<mlir::mps::TransposeOp,mlir::Value &,int,int>((mlir::mps::ConstantOp *)(a3 + 8), (uint64_t)v35, v23, (uint64_t *)&v33, (unsigned int *)&Input, &v31);
  v24 = *(void **)v35[0];
  if (v35[0] != v36)
    free(v35[0]);
  v35[0] = v24;
  v25 = v34;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v34);
  LOBYTE(v31) = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v34);
  v26 = 1;
  v29 = 1;
  v27 = mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value,mlir::Value,BOOL,BOOL>((mlir::BoolAttr **)(a3 + 8), *(_QWORD *)(v25 + 24), &Input, (uint64_t *)v35, (unsigned __int8 *)&v31, &v29);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v25, v27);
  return v26;
}

void mlir::OpBuilder::createOrFold<mlir::mps::TransposeOp,mlir::Value &,int,int>(mlir::mps::ConstantOp *a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int *a5, unsigned int *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  const mlir::OperationState *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  __int16 v24;
  uint64_t v25[4];
  __int16 v26;
  uint64_t v27[39];

  v27[38] = *MEMORY[0x1E0C80C00];
  v22 = a3;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v22);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, Context);
  if (!v14)
  {
    v26 = 1283;
    v25[2] = (uint64_t)"mps.transpose";
    v25[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v24 = 259;
    llvm::operator+(v25, (uint64_t *)&v23, (uint64_t)v27);
    llvm::report_fatal_error((llvm::Twine *)v27, 1);
  }
  mlir::OperationState::OperationState(v27, a3, v13);
  mlir::mps::TransposeOp::build(a1, v27, *a4, *a5, *a6);
  v16 = (mlir::GenericProgramPoint *)mlir::Operation::create((mlir::Operation *)v27, v15);
  v17 = *((_QWORD *)a1 + 2);
  if (v17)
  {
    v18 = (uint64_t *)*((_QWORD *)a1 + 3);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v17 + 32, (uint64_t)v16);
    mlir::GenericProgramPoint::~GenericProgramPoint(v16);
    v19 = *v18;
    *v20 = *v18;
    v20[1] = (uint64_t)v18;
    *(_QWORD *)(v19 + 8) = v20;
    *v18 = (uint64_t)v20;
    mlir::GenericProgramPoint::~GenericProgramPoint(v16);
  }
  if (mlir::OpBuilder::tryFold(a1, (uint64_t)v16, a2))
  {
    mlir::Operation::erase(v16);
  }
  else
  {
    v21 = *((_QWORD *)a1 + 1);
    if (v21)
      (*(void (**)(uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)v21 + 16))(v21, v16);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v27);
}

_QWORD *mlir::mps::`anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::Conv2DOp>::~CanonicalizeNCHWConv2DConstWeightsToHWIO(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::Conv2DOp>::~CanonicalizeNCHWConv2DConstWeightsToHWIO(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::Conv2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *Filter;
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t result;
  _QWORD *ArgAttrsAttr;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t InterfaceFor;
  _QWORD v24[2];
  _QWORD v25[2];
  uint64_t v26;

  v26 = a2;
  Filter = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v26);
  v5 = (uint64_t *)(Filter[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v25[0] = v5;
  v25[1] = v15;
  if (!*Filter || *(_QWORD *)*Filter)
    return 0;
  result = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v25);
  if ((_DWORD)result)
  {
    ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v25);
    if (v18)
    {
      v19 = 8 * v18;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v19 -= 8;
        if (!v19)
          goto LABEL_20;
      }
      return 0;
    }
LABEL_20:
    if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v26)
      || mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v26) != 2)
    {
      return 0;
    }
    v24[0] = Filter;
    result = mlir::Value::getDefiningOp((mlir::Value *)v24);
    if (result)
    {
      v20 = result;
      v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      result = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v20 + 48) + 32))(*(_QWORD *)(v20 + 48), v21);
      if ((_DWORD)result)
      {
        v22 = v26;
        if (v26)
          InterfaceFor = mlir::OpInterface<mlir::ConvertOpLayoutInterface,mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits>::getInterfaceFor(v26);
        else
          InterfaceFor = 0;
        v24[0] = v22;
        v24[1] = InterfaceFor;
        return mlir::ConvertOpLayoutInterface::convertLayout((uint64_t)v24, 0, 2, a3);
      }
    }
  }
  return result;
}

_QWORD *mlir::mps::`anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::Conv2DDataGradientOp>::~CanonicalizeNCHWConv2DConstWeightsToHWIO(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::Conv2DDataGradientOp>::~CanonicalizeNCHWConv2DConstWeightsToHWIO(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::Conv2DDataGradientOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::Conv2DDataGradientOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::Conv2DDataGradientOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::Conv2DDataGradientOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *Filter;
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t result;
  _QWORD *ArgAttrsAttr;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t InterfaceFor;
  _QWORD v24[2];
  _QWORD v25[2];
  uint64_t v26;

  v26 = a2;
  Filter = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v26);
  v5 = (uint64_t *)(Filter[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v25[0] = v5;
  v25[1] = v15;
  if (!*Filter || *(_QWORD *)*Filter)
    return 0;
  result = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v25);
  if ((_DWORD)result)
  {
    ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v25);
    if (v18)
    {
      v19 = 8 * v18;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v19 -= 8;
        if (!v19)
          goto LABEL_20;
      }
      return 0;
    }
LABEL_20:
    if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v26)
      || mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v26) != 2)
    {
      return 0;
    }
    v24[0] = Filter;
    result = mlir::Value::getDefiningOp((mlir::Value *)v24);
    if (result)
    {
      v20 = result;
      v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      result = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v20 + 48) + 32))(*(_QWORD *)(v20 + 48), v21);
      if ((_DWORD)result)
      {
        v22 = v26;
        if (v26)
          InterfaceFor = mlir::OpInterface<mlir::ConvertOpLayoutInterface,mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits>::getInterfaceFor(v26);
        else
          InterfaceFor = 0;
        v24[0] = v22;
        v24[1] = InterfaceFor;
        return mlir::ConvertOpLayoutInterface::convertLayout((uint64_t)v24, 0, 2, a3);
      }
    }
  }
  return result;
}

_QWORD *mlir::mps::`anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::DepthwiseConv2DOp>::~CanonicalizeNCHWConv2DConstWeightsToHWIO(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::DepthwiseConv2DOp>::~CanonicalizeNCHWConv2DConstWeightsToHWIO(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeNCHWConv2DConstWeightsToHWIO<mlir::mps::DepthwiseConv2DOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *Filter;
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t result;
  _QWORD *ArgAttrsAttr;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t InterfaceFor;
  _QWORD v24[2];
  _QWORD v25[2];
  uint64_t v26;

  v26 = a2;
  Filter = (_QWORD *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v26);
  v5 = (uint64_t *)(Filter[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_10;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_10:
    v15 = 0;
  v25[0] = v5;
  v25[1] = v15;
  if (!*Filter || *(_QWORD *)*Filter)
    return 0;
  result = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v25);
  if ((_DWORD)result)
  {
    ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v25);
    if (v18)
    {
      v19 = 8 * v18;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v19 -= 8;
        if (!v19)
          goto LABEL_20;
      }
      return 0;
    }
LABEL_20:
    if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v26)
      || mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v26) != 2)
    {
      return 0;
    }
    v24[0] = Filter;
    result = mlir::Value::getDefiningOp((mlir::Value *)v24);
    if (result)
    {
      v20 = result;
      v21 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      result = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v20 + 48) + 32))(*(_QWORD *)(v20 + 48), v21);
      if ((_DWORD)result)
      {
        v22 = v26;
        if (v26)
          InterfaceFor = mlir::OpInterface<mlir::ConvertOpLayoutInterface,mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits>::getInterfaceFor(v26);
        else
          InterfaceFor = 0;
        v24[0] = v22;
        v24[1] = InterfaceFor;
        return mlir::ConvertOpLayoutInterface::convertLayout((uint64_t)v24, 0, 2, a3);
      }
    }
  }
  return result;
}

uint64_t mlir::mps::createConstantsConversionPass@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _BYTE *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;

  v4 = operator new(0x560uLL);
  *(_QWORD *)v5 = off_1E0E4A5C8;
  *(_DWORD *)(v5 + 472) = *(_DWORD *)a1;
  v6 = *(_QWORD *)(v5 + 936);
  if (!v6)
    goto LABEL_5;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 48))(v6, a1);
  v4[1088] = *(_BYTE *)(a1 + 4);
  v7 = *((_QWORD *)v4 + 143);
  if (!v7)
    goto LABEL_5;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 48))(v7, a1 + 4);
  v9 = *(_BYTE *)(a1 + 5);
  v8 = a1 + 5;
  v4[1296] = v9;
  v10 = *((_QWORD *)v4 + 169);
  if (v10)
  {
    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v10 + 48))(v10, v8);
    *a2 = v4;
  }
  else
  {
LABEL_5:
    v12 = std::__throw_bad_function_call[abi:nn180100]();
  }
  return result;
}

uint64_t mlir::mps::MPSConstantsConversionBase<mlir::mps::`anonymous namespace'::ConstantsConversionPass>::MPSConstantsConversionBase(uint64_t a1)
{
  _QWORD *v2;
  int v4;
  int *v5;
  __int128 v6;
  __n128 v7;
  _QWORD v8[2];
  int v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  int v14;
  const char *v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  int v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  int v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 16) = "builtin.module";
  *(_QWORD *)(a1 + 24) = 14;
  *(_BYTE *)(a1 + 32) = 1;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  v2 = (_QWORD *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = a1 + 200;
  *(_QWORD *)(a1 + 192) = 0x400000000;
  *(_QWORD *)(a1 + 232) = a1 + 248;
  *(_QWORD *)(a1 + 240) = 0x400000000;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0x1000000000;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_QWORD *)(a1 + 336) = 0;
  *(_QWORD *)a1 = off_1E0E4BBE8;
  *(_QWORD *)&v6 = "The type of conversion to apply to the constant attributes.";
  *((_QWORD *)&v6 + 1) = 59;
  v4 = 0;
  v5 = &v4;
  v7.n128_u64[0] = (unint64_t)v8;
  v8[0] = "none";
  v8[1] = 4;
  v9 = 0;
  v10 = "The constant attribute type is not changed.";
  v11 = 43;
  v12 = "dense";
  v13 = 5;
  v14 = 1;
  v15 = "The constant attribute type is converted to DenseElementsAttr.";
  v16 = 62;
  v17 = "buffer-tensors";
  v18 = 14;
  v20 = "The constant attribute type is converted to MPSBufferTensorAttr with each attribute backed by its own resource blob.";
  v21 = 116;
  v22 = "coalesced-buffer-tensors";
  v23 = 24;
  v19 = 2;
  v24 = 3;
  v25 = "The constant attribute type is converted to MPSBufferTensorAttr with all attributes coalesced and backed by a si"
        "ngle resource blob.";
  v26 = 131;
  v7.n128_u64[1] = 0x400000004;
  mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::Option<llvm::cl::desc,llvm::cl::initializer<mlir::mps::ConstantAttributeConversionType>,llvm::cl::ValuesClass>((_QWORD *)(a1 + 344), (_QWORD *)(a1 + 152), (uint64_t)"conversion-type", 15, &v6, &v5, (uint64_t *)&v7);
  *(_QWORD *)(a1 + 344) = off_1E0E4C0E0;
  *(_QWORD *)(a1 + 944) = &unk_1E0E4C160;
  if ((_QWORD *)v7.n128_u64[0] != v8)
    free((void *)v7.n128_u64[0]);
  v7.n128_u64[0] = (unint64_t)"Cast all constants attributes to the same ElementType than the op.";
  v7.n128_u64[1] = 66;
  LOBYTE(v5) = 0;
  *(_QWORD *)&v6 = &v5;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 960), v2, (uint64_t)"cast-to-op-type", 15, &v7, (_BYTE **)&v6);
  *(_QWORD *)(a1 + 960) = &off_1E0E4C320;
  *(_QWORD *)(a1 + 1152) = &unk_1E0E4C3A0;
  v7.n128_u64[0] = (unint64_t)"Perform clipping to range of values of the output type before casting.";
  v7.n128_u64[1] = 70;
  LOBYTE(v5) = 0;
  *(_QWORD *)&v6 = &v5;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 1168), v2, (uint64_t)"clip-to-limits", 14, &v7, (_BYTE **)&v6);
  *(_QWORD *)(a1 + 1168) = &off_1E0E4C320;
  *(_QWORD *)(a1 + 1360) = &unk_1E0E4C3A0;
  return a1;
}

void mlir::mps::`anonymous namespace'::ConstantsConversionPass::~ConstantsConversionPass(mlir::mps::_anonymous_namespace_::ConstantsConversionPass *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;
  mlir::mps::_anonymous_namespace_::ConstantsConversionPass *v7;
  uint64_t v8;
  void *v9;
  char *v10;
  mlir::mps::_anonymous_namespace_::ConstantsConversionPass *v11;
  uint64_t v12;
  char *v13;
  void *v14;
  char *v15;

  *(_QWORD *)this = off_1E0E4BBE8;
  *((_QWORD *)this + 146) = &unk_1E0E23520;
  v2 = (char *)this + 1328;
  v3 = (char *)*((_QWORD *)this + 169);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)this + 146) = &unk_1E0E23930;
  v5 = (void *)*((_QWORD *)this + 158);
  if (v5 != *((void **)this + 157))
    free(v5);
  v6 = (char *)*((_QWORD *)this + 154);
  if (v6 != (char *)this + 1248)
    free(v6);
  *((_QWORD *)this + 120) = &unk_1E0E23520;
  v7 = (mlir::mps::_anonymous_namespace_::ConstantsConversionPass *)*((_QWORD *)this + 143);
  if (v7 == (mlir::mps::_anonymous_namespace_::ConstantsConversionPass *)((char *)this + 1120))
  {
    v8 = 4;
    v7 = (mlir::mps::_anonymous_namespace_::ConstantsConversionPass *)((char *)this + 1120);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_15:
  *((_QWORD *)this + 120) = &unk_1E0E23930;
  v9 = (void *)*((_QWORD *)this + 132);
  if (v9 != *((void **)this + 131))
    free(v9);
  v10 = (char *)*((_QWORD *)this + 128);
  if (v10 != (char *)this + 1040)
    free(v10);
  *((_QWORD *)this + 43) = off_1E0E232B0;
  v11 = (mlir::mps::_anonymous_namespace_::ConstantsConversionPass *)*((_QWORD *)this + 117);
  if (v11 == (mlir::mps::_anonymous_namespace_::ConstantsConversionPass *)((char *)this + 912))
  {
    v12 = 4;
    v11 = (mlir::mps::_anonymous_namespace_::ConstantsConversionPass *)((char *)this + 912);
  }
  else
  {
    if (!v11)
      goto LABEL_24;
    v12 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v11 + 8 * v12))();
LABEL_24:
  *((_QWORD *)this + 62) = &off_1E0E23A18;
  v13 = (char *)*((_QWORD *)this + 64);
  if (v13 != (char *)this + 528)
    free(v13);
  *((_QWORD *)this + 43) = &unk_1E0E23930;
  v14 = (void *)*((_QWORD *)this + 55);
  if (v14 != *((void **)this + 54))
    free(v14);
  v15 = (char *)*((_QWORD *)this + 51);
  if (v15 != (char *)this + 424)
    free(v15);
  mlir::Pass::~Pass(this);
}

{
  void *v1;

  operator delete(v1);
}

const char *mlir::mps::MPSConstantsConversionBase<mlir::mps::`anonymous namespace'::ConstantsConversionPass>::getName()
{
  return "MPSConstantsConversion";
}

const char *mlir::mps::MPSConstantsConversionBase<mlir::mps::`anonymous namespace'::ConstantsConversionPass>::getArgument()
{
  return "mps-constants-conversion";
}

const char *mlir::mps::MPSConstantsConversionBase<mlir::mps::`anonymous namespace'::ConstantsConversionPass>::getDescription()
{
  return "Convert attributes of mps.Constant op between dense / Buffer Tensor.";
}

void mlir::mps::`anonymous namespace'::ConstantsConversionPass::runOnOperation(mlir::mps::_anonymous_namespace_::ConstantsConversionPass *this)
{
  mlir::mps::_anonymous_namespace_::ConstantsConversionPass *v1;
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  char v5;
  char v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  void *v16;
  unsigned int *v17;
  char v18;
  char v19;
  unint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  unint64_t v26;
  unint64_t v27;
  char *v28;
  void *v29;
  char *v30;
  int64_t v31;
  int64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  char *v37;
  int64_t v38;
  int64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char *v43;
  char *v44;
  char *v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  mlir::Region **v60;
  char *v61;
  char *v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  char *v67;
  char *v68;
  uint64_t v69;
  __int128 v70;
  __int128 v71;
  uint64_t v72;
  char *v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  mlir::Region **v77;
  unsigned int v78;
  uint64_t v79;
  mlir::GenericProgramPoint **v80;
  uint64_t **v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t **v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t *v87;
  mlir::GenericProgramPoint *v88;
  uint64_t v89;
  mlir::mps::_anonymous_namespace_::ConstantsConversionPass *v90;
  unint64_t v91;
  void **v92;
  _QWORD v93[2];
  uint64_t v94;
  uint64_t v95;
  void *v96;
  void **v97;
  void **p_Context;
  void *Context;
  void *__p[2];
  __int128 v101;
  _BYTE *v102;
  uint64_t v103;
  _BYTE v104[48];
  uint64_t v105;
  uint64_t v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  void *v114;
  uint64_t v115;
  _BYTE v116[80];
  char *v117;
  __int128 v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;

  v1 = this;
  v122 = *MEMORY[0x1E0C80C00];
  v2 = (unsigned int *)(*((_QWORD *)this + 5) & 0xFFFFFFFFFFFFFFF8);
  if (*((_DWORD *)this + 118) <= 2u)
  {
    Context = (void *)mlir::Attribute::getContext((mlir::Attribute *)(v2 + 6));
    *(_OWORD *)__p = 0u;
    v101 = 0u;
    v102 = v104;
    v103 = 0x600000000;
    v105 = 0;
    v106 = 0;
    v107 = 0;
    v108 = 0;
    v109 = 0;
    v110 = 0x2800000000;
    v111 = 0;
    v112 = 0;
    v113 = 0x2800000000;
    v3 = (unsigned int *)operator new(0x68uLL);
    v4 = *((_DWORD *)v1 + 118);
    v5 = *((_BYTE *)v1 + 1088);
    v6 = *((_BYTE *)v1 + 1296);
    mlir::PatternBenefit::PatternBenefit(&v117, 1);
    mlir::Pattern::Pattern((uint64_t)(v3 + 2), (uint64_t)"mps.constant", 12, (__int16)v117, (uint64_t)Context, 0, 0);
    *(_QWORD *)v3 = off_1E0E48FD0;
    v3[24] = v4;
    *((_BYTE *)v3 + 100) = v5;
    *((_BYTE *)v3 + 101) = v6;
    if (!*((_QWORD *)v3 + 9))
    {
      v117 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::ConvertConstant]";
      *(_QWORD *)&v118 = 99;
      v7 = llvm::StringRef::find((uint64_t *)&v117, "DesiredTypeName = ", 0x12uLL, 0);
      if ((unint64_t)v118 >= v7)
        v8 = v7;
      else
        v8 = v118;
      v9 = &v117[v8];
      v10 = v118 - v8;
      if ((unint64_t)(v118 - v8) >= 0x12)
        v11 = 18;
      else
        v11 = v118 - v8;
      v12 = &v9[v11];
      v13 = v10 - v11;
      if (v13 >= v13 - 1)
        --v13;
      *((_QWORD *)v3 + 8) = v12;
      *((_QWORD *)v3 + 9) = v13;
    }
    v14 = v3[22];
    if (v14 > v3[23])
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v3 + 20), v3 + 24, v14, 16);
      LODWORD(v14) = v3[22];
    }
    v3[22] = v14;
    v15 = (char *)__p[1];
    if (__p[1] < (void *)v101)
    {
      *(_QWORD *)__p[1] = v3;
      v16 = v15 + 8;
      goto LABEL_65;
    }
    v30 = (char *)__p[0];
    v31 = (char *)__p[1] - (char *)__p[0];
    v32 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v33 = v32 + 1;
    if (!((unint64_t)(v32 + 1) >> 61))
    {
      v34 = v101 - (unint64_t)__p[0];
      if ((uint64_t)(v101 - (unint64_t)__p[0]) >> 2 > v33)
        v33 = v34 >> 2;
      if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8)
        v35 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v35 = v33;
      if (!v35)
      {
        v36 = 0;
        goto LABEL_50;
      }
      if (!(v35 >> 61))
      {
        v36 = (char *)operator new(8 * v35);
LABEL_50:
        v44 = &v36[8 * v32];
        v45 = &v36[8 * v35];
        *(_QWORD *)v44 = v3;
        v16 = v44 + 8;
        if (v15 == v30)
        {
          __p[0] = &v36[8 * v32];
          __p[1] = v44 + 8;
          *(_QWORD *)&v101 = v45;
        }
        else
        {
          v46 = v15 - v30 - 8;
          if (v46 < 0x78
            || &v15[-(v46 & 0xFFFFFFFFFFFFFFF8) - 8] < v44 && &v36[v31 - (v46 & 0xFFFFFFFFFFFFFFF8) - 8] < v15)
          {
            goto LABEL_109;
          }
          v47 = (v46 >> 3) + 1;
          v48 = 8 * (v47 & 0x3FFFFFFFFFFFFFFCLL);
          v49 = &v15[-v48];
          v44 -= v48;
          v50 = &v36[8 * v32 - 16];
          v51 = v15 - 16;
          v52 = v47 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v54 = *((_OWORD *)v51 - 1);
            v53 = *(_OWORD *)v51;
            *((_OWORD *)v51 - 1) = 0uLL;
            *(_OWORD *)v51 = 0uLL;
            *((_OWORD *)v50 - 1) = v54;
            *(_OWORD *)v50 = v53;
            v50 -= 32;
            v51 -= 32;
            v52 -= 4;
          }
          while (v52);
          v15 = v49;
          if (v47 != (v47 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_109:
            do
            {
              v55 = *((_QWORD *)v15 - 1);
              v15 -= 8;
              *(_QWORD *)v15 = 0;
              *((_QWORD *)v44 - 1) = v55;
              v44 -= 8;
            }
            while (v15 != v30);
          }
          v15 = (char *)__p[0];
          v56 = (char *)__p[1];
          __p[0] = v44;
          __p[1] = v16;
          *(_QWORD *)&v101 = v45;
          while (v56 != v15)
          {
            v58 = *((_QWORD *)v56 - 1);
            v56 -= 8;
            v57 = v58;
            *(_QWORD *)v56 = 0;
            if (v58)
              (*(void (**)(uint64_t))(*(_QWORD *)v57 + 8))(v57);
          }
        }
        if (v15)
          operator delete(v15);
LABEL_65:
        __p[1] = v16;
        mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(&v114, &Context, 0, 0, 0, 0);
        v59 = v2[11];
        if ((v59 & 0x7FFFFF) != 0)
        {
          v60 = (mlir::Region **)((((unint64_t)&v2[4 * ((v59 >> 23) & 1) + 16]
                                  + ((v59 >> 21) & 0x7F8)) & 0xFFFFFFFFFFFFFFF8)
                                + 32 * v2[10]);
          LOBYTE(v96) = 0;
          LOWORD(v117) = 256;
          *(_DWORD *)((char *)&v117 + 2) = 0;
          HIWORD(v117) = 0;
          v118 = xmmword_181233220;
          v120 = 0;
          v121 = 0;
          v119 = 0;
          mlir::applyPatternsAndFoldGreedily(v60, (const mlir::FrozenRewritePatternSet *)&v114, (__int128 *)&v117, (BOOL *)&v96);
        }
        mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)&v114);
        mlir::PDLPatternModule::~PDLPatternModule((mlir::PDLPatternModule *)((char *)&v101 + 8));
      }
LABEL_106:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_105:
    abort();
  }
  if (*((_BYTE *)this + 1088))
  {
    Context = (void *)mlir::Attribute::getContext((mlir::Attribute *)(v2 + 6));
    *(_OWORD *)__p = 0u;
    v101 = 0u;
    v102 = v104;
    v103 = 0x600000000;
    v105 = 0;
    v106 = 0;
    v107 = 0;
    v108 = 0;
    v109 = 0;
    v110 = 0x2800000000;
    v111 = 0;
    v112 = 0;
    v113 = 0x2800000000;
    v17 = (unsigned int *)operator new(0x68uLL);
    v18 = *((_BYTE *)v1 + 1088);
    v19 = *((_BYTE *)v1 + 1296);
    mlir::PatternBenefit::PatternBenefit(&v117, 1);
    mlir::Pattern::Pattern((uint64_t)(v17 + 2), (uint64_t)"mps.constant", 12, (__int16)v117, (uint64_t)Context, 0, 0);
    *(_QWORD *)v17 = off_1E0E48FD0;
    v17[24] = 0;
    *((_BYTE *)v17 + 100) = v18;
    *((_BYTE *)v17 + 101) = v19;
    if (!*((_QWORD *)v17 + 9))
    {
      v117 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::ConvertConstant]";
      *(_QWORD *)&v118 = 99;
      v20 = llvm::StringRef::find((uint64_t *)&v117, "DesiredTypeName = ", 0x12uLL, 0);
      if ((unint64_t)v118 >= v20)
        v21 = v20;
      else
        v21 = v118;
      v22 = &v117[v21];
      v23 = v118 - v21;
      if ((unint64_t)(v118 - v21) >= 0x12)
        v24 = 18;
      else
        v24 = v118 - v21;
      v25 = &v22[v24];
      v26 = v23 - v24;
      if (v26 >= v26 - 1)
        --v26;
      *((_QWORD *)v17 + 8) = v25;
      *((_QWORD *)v17 + 9) = v26;
    }
    v27 = v17[22];
    if (v27 > v17[23])
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v17 + 20), v17 + 24, v27, 16);
      LODWORD(v27) = v17[22];
    }
    v17[22] = v27;
    v28 = (char *)__p[1];
    if (__p[1] >= (void *)v101)
    {
      v37 = (char *)__p[0];
      v38 = (char *)__p[1] - (char *)__p[0];
      v39 = ((char *)__p[1] - (char *)__p[0]) >> 3;
      v40 = v39 + 1;
      if ((unint64_t)(v39 + 1) >> 61)
        goto LABEL_105;
      v41 = v101 - (unint64_t)__p[0];
      if ((uint64_t)(v101 - (unint64_t)__p[0]) >> 2 > v40)
        v40 = v41 >> 2;
      if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8)
        v42 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v42 = v40;
      if (v42)
      {
        if (v42 >> 61)
          goto LABEL_106;
        v43 = (char *)operator new(8 * v42);
      }
      else
      {
        v43 = 0;
      }
      v61 = &v43[8 * v39];
      v62 = &v43[8 * v42];
      *(_QWORD *)v61 = v17;
      v29 = v61 + 8;
      if (v28 == v37)
      {
        __p[0] = &v43[8 * v39];
        __p[1] = v61 + 8;
        *(_QWORD *)&v101 = v62;
      }
      else
      {
        v63 = v28 - v37 - 8;
        if (v63 < 0x78
          || &v28[-(v63 & 0xFFFFFFFFFFFFFFF8) - 8] < v61 && &v43[v38 - (v63 & 0xFFFFFFFFFFFFFFF8) - 8] < v28)
        {
          goto LABEL_110;
        }
        v64 = (v63 >> 3) + 1;
        v65 = 8 * (v64 & 0x3FFFFFFFFFFFFFFCLL);
        v66 = &v28[-v65];
        v61 -= v65;
        v67 = &v43[8 * v39 - 16];
        v68 = v28 - 16;
        v69 = v64 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v71 = *((_OWORD *)v68 - 1);
          v70 = *(_OWORD *)v68;
          *((_OWORD *)v68 - 1) = 0uLL;
          *(_OWORD *)v68 = 0uLL;
          *((_OWORD *)v67 - 1) = v71;
          *(_OWORD *)v67 = v70;
          v67 -= 32;
          v68 -= 32;
          v69 -= 4;
        }
        while (v69);
        v28 = v66;
        if (v64 != (v64 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_110:
          do
          {
            v72 = *((_QWORD *)v28 - 1);
            v28 -= 8;
            *(_QWORD *)v28 = 0;
            *((_QWORD *)v61 - 1) = v72;
            v61 -= 8;
          }
          while (v28 != v37);
        }
        v28 = (char *)__p[0];
        v73 = (char *)__p[1];
        __p[0] = v61;
        __p[1] = v29;
        *(_QWORD *)&v101 = v62;
        while (v73 != v28)
        {
          v75 = *((_QWORD *)v73 - 1);
          v73 -= 8;
          v74 = v75;
          *(_QWORD *)v73 = 0;
          if (v75)
            (*(void (**)(uint64_t))(*(_QWORD *)v74 + 8))(v74);
        }
      }
      if (v28)
        operator delete(v28);
    }
    else
    {
      *(_QWORD *)__p[1] = v17;
      v29 = v28 + 8;
    }
    __p[1] = v29;
    mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(&v114, &Context, 0, 0, 0, 0);
    v76 = v2[11];
    if ((v76 & 0x7FFFFF) != 0)
    {
      v77 = (mlir::Region **)((((unint64_t)&v2[4 * ((v76 >> 23) & 1) + 16] + ((v76 >> 21) & 0x7F8)) & 0xFFFFFFFFFFFFFFF8)
                            + 32 * v2[10]);
      LOBYTE(v96) = 0;
      LOWORD(v117) = 256;
      *(_DWORD *)((char *)&v117 + 2) = 0;
      HIWORD(v117) = 0;
      v118 = xmmword_181233220;
      v120 = 0;
      v121 = 0;
      v119 = 0;
      mlir::applyPatternsAndFoldGreedily(v77, (const mlir::FrozenRewritePatternSet *)&v114, (__int128 *)&v117, (BOOL *)&v96);
    }
    mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)&v114);
    mlir::PDLPatternModule::~PDLPatternModule((mlir::PDLPatternModule *)((char *)&v101 + 8));
  }
  v117 = (char *)&v118 + 8;
  *(_QWORD *)&v118 = 0xA00000000;
  v114 = v116;
  v115 = 0xA00000000;
  Context = &__p[1];
  __p[0] = (void *)0xA00000000;
  v96 = &v117;
  v97 = &v114;
  p_Context = &Context;
  v92 = &v96;
  mlir::detail::walk<mlir::ForwardIterator>((mlir::ForwardIterator *)v2, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_3mps12_GLOBAL__N_123ConstantsConversionPass31convertToCoalescedBufferTensorsENS1_8ModuleOpEEUlNSB_10ConstantOpEE_SF_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESO_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)&v92, 1);
  v78 = v118;
  if (v118 >= 2)
  {
    v90 = v1;
    mlir::mps::getBufferTensorAttrs((mlir::Attribute *)v114, v115, (const void **)Context, LODWORD(__p[0]), (uint64_t)&v96);
    v79 = mlir::Attribute::getContext((mlir::Attribute *)(v2 + 6));
    v94 = 0;
    v95 = 0;
    v93[0] = v79;
    v93[1] = 0;
    v92 = (void **)off_1E0E25938;
    if ((_DWORD)v118 && (_DWORD)v97)
    {
      v80 = (mlir::GenericProgramPoint **)v117;
      v81 = (uint64_t **)v96;
      v82 = 8 * v97 - 8;
      v83 = 8 * v118 - 8;
      v84 = (uint64_t **)v117;
      do
      {
        v85 = *((_QWORD *)*v80 + 2);
        mlir::GenericProgramPoint::~GenericProgramPoint(*v80);
        v94 = v85;
        v95 = v86;
        v87 = *v84++;
        v91 = *(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)v80) + 8) & 0xFFFFFFFFFFFFFFF8;
        v88 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::MemRefType &,mlir::mps::MPSBufferTensorAttr &>((mlir::OpBuilder *)v93, v87[3], (uint64_t *)&v91, v81);
        ((void (*)(mlir::RewriterBase *, mlir::Operation *, mlir::Operation *))v92[4])((mlir::RewriterBase *)&v92, (mlir::Operation *)v87, v88);
        if (!v83)
          break;
        ++v81;
        v89 = v82;
        v82 -= 8;
        v83 -= 8;
        v80 = (mlir::GenericProgramPoint **)v84;
      }
      while (v89);
    }
    mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v92);
    if (v96 != &p_Context)
      free(v96);
    v1 = v90;
  }
  if (Context != &__p[1])
    free(Context);
  if (v114 != v116)
    free(v114);
  if (v117 != (char *)&v118 + 8)
    free(v117);
  if (v78 <= 1)
    *((_QWORD *)v1 + 5) |= 4uLL;
}

_QWORD *mlir::mps::MPSConstantsConversionBase<mlir::mps::`anonymous namespace'::ConstantsConversionPass>::clonePass@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  char *v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *result;
  int v8;
  int *v9;
  __int128 v10;
  __n128 v11;
  _QWORD v12[2];
  int v13;
  const char *v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  int v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  int v23;
  const char *v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  int v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v4 = (char *)operator new(0x560uLL);
  v5 = *(_QWORD *)(a1 + 8);
  *((_OWORD *)v4 + 1) = *(_OWORD *)(a1 + 16);
  *((_QWORD *)v4 + 4) = *(_QWORD *)(a1 + 32);
  v4[40] = 0;
  v4[120] = 0;
  v6 = v4 + 152;
  *((_OWORD *)v4 + 8) = 0u;
  *((_OWORD *)v4 + 9) = 0u;
  *((_OWORD *)v4 + 10) = 0u;
  *((_QWORD *)v4 + 22) = 0;
  *((_QWORD *)v4 + 23) = v4 + 200;
  *((_QWORD *)v4 + 24) = 0x400000000;
  *((_QWORD *)v4 + 29) = v4 + 248;
  *((_QWORD *)v4 + 30) = 0x400000000;
  *((_QWORD *)v4 + 35) = 0;
  *((_QWORD *)v4 + 36) = 0;
  *((_DWORD *)v4 + 74) = 0;
  *((_DWORD *)v4 + 75) = 16;
  *((_OWORD *)v4 + 19) = 0u;
  *((_OWORD *)v4 + 20) = 0u;
  *((_QWORD *)v4 + 42) = 0;
  *(_QWORD *)v4 = off_1E0E4BBE8;
  *((_QWORD *)v4 + 1) = v5;
  *(_QWORD *)&v10 = "The type of conversion to apply to the constant attributes.";
  *((_QWORD *)&v10 + 1) = 59;
  v8 = 0;
  v9 = &v8;
  v11.n128_u64[0] = (unint64_t)v12;
  v12[0] = "none";
  v12[1] = 4;
  v13 = 0;
  v14 = "The constant attribute type is not changed.";
  v15 = 43;
  v16 = "dense";
  v17 = 5;
  v18 = 1;
  v19 = "The constant attribute type is converted to DenseElementsAttr.";
  v20 = 62;
  v21 = "buffer-tensors";
  v22 = 14;
  v24 = "The constant attribute type is converted to MPSBufferTensorAttr with each attribute backed by its own resource blob.";
  v25 = 116;
  v26 = "coalesced-buffer-tensors";
  v27 = 24;
  v23 = 2;
  v28 = 3;
  v29 = "The constant attribute type is converted to MPSBufferTensorAttr with all attributes coalesced and backed by a si"
        "ngle resource blob.";
  v30 = 131;
  v11.n128_u64[1] = 0x400000004;
  mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::Option<llvm::cl::desc,llvm::cl::initializer<mlir::mps::ConstantAttributeConversionType>,llvm::cl::ValuesClass>((_QWORD *)v4 + 43, (_QWORD *)v4 + 19, (uint64_t)"conversion-type", 15, &v10, &v9, (uint64_t *)&v11);
  *((_QWORD *)v4 + 43) = off_1E0E4C0E0;
  *((_QWORD *)v4 + 118) = &unk_1E0E4C160;
  if ((_QWORD *)v11.n128_u64[0] != v12)
    free((void *)v11.n128_u64[0]);
  v11.n128_u64[0] = (unint64_t)"Cast all constants attributes to the same ElementType than the op.";
  v11.n128_u64[1] = 66;
  LOBYTE(v9) = 0;
  *(_QWORD *)&v10 = &v9;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)v4 + 120, v6, (uint64_t)"cast-to-op-type", 15, &v11, (_BYTE **)&v10);
  *((_QWORD *)v4 + 120) = &off_1E0E4C320;
  *((_QWORD *)v4 + 144) = &unk_1E0E4C3A0;
  v11.n128_u64[0] = (unint64_t)"Perform clipping to range of values of the output type before casting.";
  v11.n128_u64[1] = 70;
  LOBYTE(v9) = 0;
  *(_QWORD *)&v10 = &v9;
  result = mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)v4 + 146, v6, (uint64_t)"clip-to-limits", 14, &v11, (_BYTE **)&v10);
  *((_QWORD *)v4 + 146) = &off_1E0E4C320;
  *((_QWORD *)v4 + 170) = &unk_1E0E4C3A0;
  *(_QWORD *)v4 = off_1E0E4A5C8;
  *a2 = v4;
  return result;
}

_QWORD *mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::Option<llvm::cl::desc,llvm::cl::initializer<mlir::mps::ConstantAttributeConversionType>,llvm::cl::ValuesClass>(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4, _OWORD *a5, _DWORD **a6, uint64_t *a7)
{
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t *v21;
  char *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t *v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  const void **v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  _QWORD v36[2];
  _QWORD v37[3];
  _QWORD *v38;
  const void *v39[3];
  const void **v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v36[0] = a3;
  v36[1] = a4;
  v39[0] = a2;
  v9 = llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<mlir::mps::ConstantAttributeConversionType>,llvm::cl::ValuesClass>((uint64_t)a1, (uint64_t)v36, v39, a5, a6, a7);
  v10 = v9 + 600;
  *(_BYTE *)(v9 + 608) = 0;
  *(_QWORD *)v9 = off_1E0E4DE88;
  *(_QWORD *)(v9 + 600) = &unk_1E0E4DF08;
  v12 = (uint64_t *)a2[21];
  v11 = a2[22];
  v13 = v12;
  if ((unint64_t)v12 >= v11)
  {
    v15 = (uint64_t *)a2[20];
    v16 = v12 - v15;
    v17 = v16 + 1;
    if ((unint64_t)(v16 + 1) >> 61)
      abort();
    v18 = v11 - (_QWORD)v15;
    if (v18 >> 2 > v17)
      v17 = v18 >> 2;
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
      v19 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v19 = v17;
    if (v19)
    {
      if (v19 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v20 = (char *)operator new(8 * v19);
    }
    else
    {
      v20 = 0;
    }
    v21 = (uint64_t *)&v20[8 * v16];
    v22 = &v20[8 * v19];
    *v21 = v10;
    v14 = v21 + 1;
    if (v12 != v15)
    {
      v23 = (char *)v12 - (char *)v15 - 8;
      if (v23 < 0x58)
        goto LABEL_38;
      if ((unint64_t)((char *)v15 - v20) < 0x20)
        goto LABEL_38;
      v24 = (v23 >> 3) + 1;
      v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
      v13 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
      v21 = (uint64_t *)((char *)v21 - v25);
      v26 = &v20[8 * v16 - 16];
      v27 = v12 - 2;
      v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v29 = *(_OWORD *)v27;
        *((_OWORD *)v26 - 1) = *((_OWORD *)v27 - 1);
        *(_OWORD *)v26 = v29;
        v26 -= 32;
        v27 -= 4;
        v28 -= 4;
      }
      while (v28);
      if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_38:
        do
        {
          v30 = *--v13;
          *--v21 = v30;
        }
        while (v13 != v15);
      }
      v13 = (uint64_t *)a2[20];
    }
    a2[20] = v21;
    a2[21] = v14;
    a2[22] = v22;
    if (v13)
      operator delete(v13);
  }
  else
  {
    *v12 = v10;
    v14 = v12 + 1;
  }
  a2[21] = v14;
  v37[0] = off_1E0E51398;
  v37[1] = a1;
  v38 = v37;
  v39[0] = off_1E0E51398;
  v40 = v39;
  v39[1] = a1;
  std::__function::__value_func<void ()(long long const&)>::swap[abi:nn180100](v39, a1 + 71);
  v31 = v40;
  if (v40 == v39)
  {
    v32 = 4;
    v31 = v39;
  }
  else
  {
    if (!v40)
      goto LABEL_28;
    v32 = 5;
  }
  (*((void (**)(void))*v31 + v32))();
LABEL_28:
  v33 = v38;
  if (v38 == v37)
  {
    v34 = 4;
    v33 = v37;
    goto LABEL_32;
  }
  if (v38)
  {
    v34 = 5;
LABEL_32:
    (*(void (**)(void))(*v33 + 8 * v34))();
  }
  return a1;
}

uint64_t llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::handleOccurrence(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  int v12;

  v12 = 0;
  v8 = llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::parse(a1 + 152, (_QWORD *)a1, a3, a4, a5, a6, &v12);
  if ((v8 & 1) != 0)
    return v8;
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  v9 = *(_QWORD *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(_QWORD *)v9 + 48))(v9, &v12);
    return v8;
  }
  v11 = std::__throw_bad_function_call[abi:nn180100]();
  return llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::getValueExpectedFlagDefault(v11);
}

uint64_t llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::getValueExpectedFlagDefault(uint64_t a1)
{
  if (*(_QWORD *)(*(_QWORD *)(a1 + 160) + 24))
    return 2;
  else
    return 3;
}

_QWORD *mlir::Pass::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;

  *a1 = off_1E0E232B0;
  v2 = a1 + 71;
  v3 = (_QWORD *)a1[74];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  a1[19] = &off_1E0E23A18;
  v5 = (_QWORD *)a1[21];
  if (v5 != a1 + 23)
    free(v5);
  *a1 = &unk_1E0E23930;
  v6 = (void *)a1[12];
  if (v6 != (void *)a1[11])
    free(v6);
  v7 = (_QWORD *)a1[8];
  if (v7 != a1 + 10)
    free(v7);
  return a1;
}

void mlir::Pass::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;
  char *v5;
  void *v6;
  char *v7;

  *(_QWORD *)__p = off_1E0E232B0;
  v2 = __p + 568;
  v3 = (char *)*((_QWORD *)__p + 74);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)__p + 19) = &off_1E0E23A18;
  v5 = (char *)*((_QWORD *)__p + 21);
  if (v5 != __p + 184)
    free(v5);
  *(_QWORD *)__p = &unk_1E0E23930;
  v6 = (void *)*((_QWORD *)__p + 12);
  if (v6 != *((void **)__p + 11))
    free(v6);
  v7 = (char *)*((_QWORD *)__p + 8);
  if (v7 != __p + 80)
    free(v7);
  operator delete(__p);
}

unint64_t llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::getOptionWidth(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::printOptionInfo(uint64_t a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::generic_parser_base *)(a1 + 152), (const llvm::cl::Option *)a1, a2);
}

llvm::raw_ostream *llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::printOptionValue(llvm::raw_ostream *result, int a2, char a3)
{
  int v3;
  uint64_t (**v4)();
  int v5;
  char v6;

  if ((a3 & 1) != 0 || !*((_BYTE *)result + 148) || *((_DWORD *)result + 36) != *((_DWORD *)result + 32))
  {
    v3 = *((_DWORD *)result + 32);
    v4 = &off_1E0E22EC8;
    v6 = 1;
    v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  return result;
}

uint64_t llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::setDefault(uint64_t result)
{
  int v1;

  v1 = *(unsigned __int8 *)(result + 148);
  if (*(_BYTE *)(result + 148))
    v1 = *(_DWORD *)(result + 144);
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::getExtraOptionNames(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;

  if (!*(_QWORD *)(*(_QWORD *)(a1 + 160) + 24))
  {
    v3 = a1 + 152;
    v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 152) + 16))(a1 + 152);
    if (v4)
    {
      v5 = v4;
      v6 = 0;
      do
      {
        v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 24))(v3, v6);
        v9 = v8;
        v10 = *(unsigned int *)(a2 + 8);
        if (v10 >= *(unsigned int *)(a2 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v10 + 1, 16);
          v10 = *(unsigned int *)(a2 + 8);
        }
        v11 = (uint64_t *)(*(_QWORD *)a2 + 16 * v10);
        *v11 = v7;
        v11[1] = v9;
        ++*(_DWORD *)(a2 + 8);
        v6 = (v6 + 1);
      }
      while (v5 != (_DWORD)v6);
    }
  }
}

llvm::raw_ostream *mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::print(uint64_t a1, llvm::raw_ostream *this)
{
  const void *v4;
  size_t v5;
  _BYTE *v6;
  llvm::raw_ostream *v7;
  _BYTE *v8;
  uint64_t v9;
  const char *v10;
  size_t v11;
  llvm::raw_ostream *result;

  v4 = *(const void **)(a1 + 16);
  v5 = *(_QWORD *)(a1 + 24);
  v6 = (_BYTE *)*((_QWORD *)this + 4);
  if (v5 <= *((_QWORD *)this + 3) - (_QWORD)v6)
  {
    if (v5)
    {
      memcpy(v6, v4, v5);
      v6 = (_BYTE *)(*((_QWORD *)this + 4) + v5);
      *((_QWORD *)this + 4) = v6;
    }
    v7 = this;
  }
  else
  {
    v7 = llvm::raw_ostream::write(this, (const char *)v4, v5);
    v6 = (_BYTE *)*((_QWORD *)v7 + 4);
  }
  if ((unint64_t)v6 >= *((_QWORD *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 61);
  }
  else
  {
    *((_QWORD *)v7 + 4) = v6 + 1;
    *v6 = 61;
  }
  v8 = (_BYTE *)(*(_QWORD *)(a1 + 168) + 44);
  v9 = 48 * *(unsigned int *)(a1 + 176);
  while (1)
  {
    v9 -= 48;
    if (*v8)
    {
      if (*((_DWORD *)v8 - 1) == *(_DWORD *)(a1 + 128))
        break;
    }
    v8 += 48;
  }
  v10 = *(const char **)(v8 - 44);
  v11 = *(_QWORD *)(v8 - 36);
  result = (llvm::raw_ostream *)*((_QWORD *)this + 4);
  if (v11 > *((_QWORD *)this + 3) - (_QWORD)result)
    return llvm::raw_ostream::write(this, v10, *(_QWORD *)(v8 - 36));
  if (v11)
  {
    result = (llvm::raw_ostream *)memcpy(result, v10, v11);
    *((_QWORD *)this + 4) += v11;
  }
  return result;
}

uint64_t mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::copyValueFrom(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 128) = *(_DWORD *)(a2 - 472);
  *(_BYTE *)(result + 608) = *(_BYTE *)(a2 + 8);
  return result;
}

void `non-virtual thunk to'mlir::Pass::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;

  v2 = (_QWORD *)(a1 - 600);
  *(_QWORD *)(a1 - 600) = off_1E0E232B0;
  v3 = (_QWORD *)(a1 - 32);
  v4 = *(_QWORD **)(a1 - 8);
  if (v4 == v3)
  {
    v5 = 4;
    v4 = v3;
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  *(_QWORD *)(a1 - 448) = &off_1E0E23A18;
  v6 = *(void **)(a1 - 432);
  if (v6 != (void *)(a1 - 416))
    free(v6);
  *v2 = &unk_1E0E23930;
  v7 = *(void **)(a1 - 504);
  if (v7 != *(void **)(a1 - 512))
    free(v7);
  v8 = *(void **)(a1 - 536);
  if (v8 != (void *)(a1 - 520))
    free(v8);
}

{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;

  v2 = (_QWORD *)(a1 - 600);
  *(_QWORD *)(a1 - 600) = off_1E0E232B0;
  v3 = (_QWORD *)(a1 - 32);
  v4 = *(_QWORD **)(a1 - 8);
  if (v4 == v3)
  {
    v5 = 4;
    v4 = v3;
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  *(_QWORD *)(a1 - 448) = &off_1E0E23A18;
  v6 = *(void **)(a1 - 432);
  if (v6 != (void *)(a1 - 416))
    free(v6);
  *v2 = &unk_1E0E23930;
  v7 = *(void **)(a1 - 504);
  if (v7 != *(void **)(a1 - 512))
    free(v7);
  v8 = *(void **)(a1 - 536);
  if (v8 != (void *)(a1 - 520))
    free(v8);
  operator delete(v2);
}

llvm::raw_ostream *`non-virtual thunk to'mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::print(uint64_t a1, llvm::raw_ostream *a2)
{
  return mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::print(a1 - 600, a2);
}

uint64_t `non-virtual thunk to'mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::getOption(uint64_t a1)
{
  return a1 - 600;
}

uint64_t `non-virtual thunk to'mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::copyValueFrom(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result - 472) = *(_DWORD *)(a2 - 472);
  *(_BYTE *)(result + 8) = *(_BYTE *)(a2 + 8);
  return result;
}

uint64_t llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<mlir::mps::ConstantAttributeConversionType>,llvm::cl::ValuesClass>(uint64_t a1, uint64_t a2, const void **a3, _OWORD *a4, _DWORD **a5, uint64_t *a6)
{
  void *v12;
  uint64_t v13;
  uint64_t *GeneralCategory;
  uint64_t v15;

  *(_QWORD *)a1 = &unk_1E0E23930;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  v12 = (void *)(a1 + 80);
  *(_QWORD *)(a1 + 64) = a1 + 80;
  v13 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(_QWORD *)(a1 + 72) = 0x100000000;
  *(_QWORD *)(a1 + 88) = a1 + 120;
  *(_QWORD *)(a1 + 96) = a1 + 120;
  *(_QWORD *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  v15 = *(unsigned int *)(a1 + 72);
  if (v15 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v13, v12, v15 + 1, 8);
    LODWORD(v15) = *(_DWORD *)(a1 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v15) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = &off_1E0E22EC8;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)a1 = off_1E0E232B0;
  *(_QWORD *)(a1 + 160) = a1;
  *(_QWORD *)(a1 + 168) = a1 + 184;
  *(_QWORD *)(a1 + 176) = 0x800000000;
  *(_QWORD *)(a1 + 152) = &off_1E0E4DDE8;
  *(_QWORD *)(a1 + 568) = off_1E0E4F918;
  *(_QWORD *)(a1 + 592) = a1 + 568;
  llvm::cl::apply<llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<mlir::mps::ConstantAttributeConversionType>,llvm::cl::ValuesClass>(a1, a2, a3, a4, a5, a6);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

_QWORD *mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;

  *a1 = off_1E0E232B0;
  v2 = a1 + 71;
  v3 = (_QWORD *)a1[74];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  a1[19] = &off_1E0E23A18;
  v5 = (_QWORD *)a1[21];
  if (v5 != a1 + 23)
    free(v5);
  *a1 = &unk_1E0E23930;
  v6 = (void *)a1[12];
  if (v6 != (void *)a1[11])
    free(v6);
  v7 = (_QWORD *)a1[8];
  if (v7 != a1 + 10)
    free(v7);
  return a1;
}

void mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;
  char *v5;
  void *v6;
  char *v7;

  *(_QWORD *)__p = off_1E0E232B0;
  v2 = __p + 568;
  v3 = (char *)*((_QWORD *)__p + 74);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)__p + 19) = &off_1E0E23A18;
  v5 = (char *)*((_QWORD *)__p + 21);
  if (v5 != __p + 184)
    free(v5);
  *(_QWORD *)__p = &unk_1E0E23930;
  v6 = (void *)*((_QWORD *)__p + 12);
  if (v6 != *((void **)__p + 11))
    free(v6);
  v7 = (char *)*((_QWORD *)__p + 8);
  if (v7 != __p + 80)
    free(v7);
  operator delete(__p);
}

void `non-virtual thunk to'mlir::detail::PassOptions::Option<mlir::mps::ConstantAttributeConversionType,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~Option(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;

  v2 = (_QWORD *)(a1 - 600);
  *(_QWORD *)(a1 - 600) = off_1E0E232B0;
  v3 = (_QWORD *)(a1 - 32);
  v4 = *(_QWORD **)(a1 - 8);
  if (v4 == v3)
  {
    v5 = 4;
    v4 = v3;
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  *(_QWORD *)(a1 - 448) = &off_1E0E23A18;
  v6 = *(void **)(a1 - 432);
  if (v6 != (void *)(a1 - 416))
    free(v6);
  *v2 = &unk_1E0E23930;
  v7 = *(void **)(a1 - 504);
  if (v7 != *(void **)(a1 - 512))
    free(v7);
  v8 = *(void **)(a1 - 536);
  if (v8 != (void *)(a1 - 520))
    free(v8);
}

{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;

  v2 = (_QWORD *)(a1 - 600);
  *(_QWORD *)(a1 - 600) = off_1E0E232B0;
  v3 = (_QWORD *)(a1 - 32);
  v4 = *(_QWORD **)(a1 - 8);
  if (v4 == v3)
  {
    v5 = 4;
    v4 = v3;
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  *(_QWORD *)(a1 - 448) = &off_1E0E23A18;
  v6 = *(void **)(a1 - 432);
  if (v6 != (void *)(a1 - 416))
    free(v6);
  *v2 = &unk_1E0E23930;
  v7 = *(void **)(a1 - 504);
  if (v7 != *(void **)(a1 - 512))
    free(v7);
  v8 = *(void **)(a1 - 536);
  if (v8 != (void *)(a1 - 520))
    free(v8);
  operator delete(v2);
}

void llvm::cl::apply<llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<mlir::mps::ConstantAttributeConversionType>,llvm::cl::ValuesClass>(uint64_t a1, uint64_t a2, const void **a3, _OWORD *a4, _DWORD **a5, uint64_t *a6)
{
  const void *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;

  llvm::cl::Option::setArgStr(a1, *(int8x16_t **)a2, *(const unsigned __int8 **)(a2 + 8));
  v11 = *a3;
  v12 = *(_QWORD *)(a1 + 96);
  if (v12 != *(_QWORD *)(a1 + 88))
  {
LABEL_2:
    llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(a1 + 88), v11);
    goto LABEL_3;
  }
  v13 = *(unsigned int *)(a1 + 108);
  if (!(_DWORD)v13)
  {
LABEL_12:
    if (v13 < *(_DWORD *)(a1 + 104))
    {
      *(_DWORD *)(a1 + 108) = v13 + 1;
      *(_QWORD *)(v12 + 8 * v13) = v11;
      goto LABEL_3;
    }
    goto LABEL_2;
  }
  v14 = 0;
  v15 = 8 * v13;
  v16 = *(_QWORD **)(a1 + 96);
  while ((const void *)*v16 != v11)
  {
    if (*v16 == -2)
      v14 = v16;
    ++v16;
    v15 -= 8;
    if (!v15)
    {
      if (!v14)
        goto LABEL_12;
      *v14 = v11;
      --*(_DWORD *)(a1 + 112);
      break;
    }
  }
LABEL_3:
  *(_OWORD *)(a1 + 32) = *a4;
  llvm::cl::apply<llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>,llvm::cl::initializer<mlir::mps::ConstantAttributeConversionType>,llvm::cl::ValuesClass>(a1, a5, a6);
}

_QWORD *llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~opt(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;

  *a1 = off_1E0E232B0;
  v2 = a1 + 71;
  v3 = (_QWORD *)a1[74];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  a1[19] = &off_1E0E23A18;
  v5 = (_QWORD *)a1[21];
  if (v5 != a1 + 23)
    free(v5);
  *a1 = &unk_1E0E23930;
  v6 = (void *)a1[12];
  if (v6 != (void *)a1[11])
    free(v6);
  v7 = (_QWORD *)a1[8];
  if (v7 != a1 + 10)
    free(v7);
  return a1;
}

void llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::~opt(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;
  char *v5;
  void *v6;
  char *v7;

  *(_QWORD *)__p = off_1E0E232B0;
  v2 = __p + 568;
  v3 = (char *)*((_QWORD *)__p + 74);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)__p + 19) = &off_1E0E23A18;
  v5 = (char *)*((_QWORD *)__p + 21);
  if (v5 != __p + 184)
    free(v5);
  *(_QWORD *)__p = &unk_1E0E23930;
  v6 = (void *)*((_QWORD *)__p + 12);
  if (v6 != *((void **)__p + 11))
    free(v6);
  v7 = (char *)*((_QWORD *)__p + 8);
  if (v7 != __p + 80)
    free(v7);
  operator delete(__p);
}

BOOL llvm::cl::OptionValueCopy<mlir::mps::ConstantAttributeConversionType>::compare(uint64_t a1, uint64_t a2)
{
  return *(_BYTE *)(a2 + 12) && *(_BYTE *)(a1 + 12) && *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
}

_QWORD *mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>::~GenericOptionParser(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E0E23A18;
  v2 = (_QWORD *)a1[2];
  if (v2 != a1 + 4)
    free(v2);
  return a1;
}

void mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>::~GenericOptionParser(_QWORD *__p)
{
  _QWORD *v2;

  *__p = &off_1E0E23A18;
  v2 = (_QWORD *)__p[2];
  if (v2 != __p + 4)
    free(v2);
  operator delete(__p);
}

uint64_t llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::getNumOptions(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::getOption(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * a2);
}

uint64_t llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::getDescription(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::getOptionValue(uint64_t a1, unsigned int a2)
{
  return *(_QWORD *)(a1 + 16) + 48 * a2 + 32;
}

_QWORD *llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::~parser(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_1E0E23A18;
  v2 = (_QWORD *)a1[2];
  if (v2 != a1 + 4)
    free(v2);
  return a1;
}

void llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::~parser(_QWORD *__p)
{
  _QWORD *v2;

  *__p = &off_1E0E23A18;
  v2 = (_QWORD *)__p[2];
  if (v2 != __p + 4)
    free(v2);
  operator delete(__p);
}

_QWORD *std::__function::__func<llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::{lambda(mlir::mps::ConstantAttributeConversionType const&)#1},std::allocator<llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::{lambda(mlir::mps::ConstantAttributeConversionType const&)#1}>,void ()(mlir::mps::ConstantAttributeConversionType const&)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = off_1E0E4F918;
  return result;
}

void std::__function::__func<llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::{lambda(mlir::mps::ConstantAttributeConversionType const&)#1},std::allocator<llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>::{lambda(mlir::mps::ConstantAttributeConversionType const&)#1}>,void ()(mlir::mps::ConstantAttributeConversionType const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = off_1E0E4F918;
}

void llvm::cl::apply<llvm::cl::opt<mlir::mps::ConstantAttributeConversionType,false,mlir::detail::PassOptions::GenericOptionParser<mlir::mps::ConstantAttributeConversionType>>,llvm::cl::initializer<mlir::mps::ConstantAttributeConversionType>,llvm::cl::ValuesClass>(uint64_t a1, _DWORD **a2, uint64_t *a3)
{
  _DWORD *v3;
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int8x16_t *v9;
  const unsigned __int8 *v10;
  __int128 v11;
  int v12;
  char *Address;
  uint64_t v14;
  __int128 v15;
  char v16;
  _QWORD v17[2];
  __int128 v18;
  uint64_t (**v19)();
  int v20;
  char v21;

  v3 = *a2;
  *(_DWORD *)(a1 + 128) = **a2;
  *(_BYTE *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = *v3;
  v4 = *((_DWORD *)a3 + 2);
  if (v4)
  {
    v6 = *a3;
    v7 = *a3 + 40 * v4;
    v8 = a1 + 168;
    do
    {
      v10 = *(const unsigned __int8 **)(v6 + 8);
      v11 = *(_OWORD *)(v6 + 24);
      v12 = *(_DWORD *)(v6 + 16);
      v17[0] = *(_QWORD *)v6;
      v9 = (int8x16_t *)v17[0];
      v17[1] = v10;
      v18 = v11;
      v19 = &off_1E0E22EC8;
      v21 = 1;
      v20 = v12;
      Address = llvm::SmallVectorTemplateBase<llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::OptionInfo,false>::reserveForParamAndGetAddress(v8, (unint64_t)v17, 1);
      v14 = *(_QWORD *)(a1 + 168) + 48 * *(unsigned int *)(a1 + 176);
      v15 = *((_OWORD *)Address + 1);
      *(_OWORD *)v14 = *(_OWORD *)Address;
      *(_OWORD *)(v14 + 16) = v15;
      *(_QWORD *)(v14 + 32) = &off_1E0E23028;
      v16 = Address[44];
      *(_DWORD *)(v14 + 40) = *((_DWORD *)Address + 10);
      *(_BYTE *)(v14 + 44) = v16;
      *(_QWORD *)(v14 + 32) = &off_1E0E22EC8;
      ++*(_DWORD *)(a1 + 176);
      llvm::cl::AddLiteralOption(*(_QWORD *)(a1 + 160), v9, v10);
      v6 += 40;
    }
    while (v6 != v7);
  }
}

char *llvm::SmallVectorTemplateBase<llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::OptionInfo,false>::reserveForParamAndGetAddress(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v8;
  char *v10;
  _OWORD *v11;
  char *v12;
  unsigned int v13;
  char *v14;
  _OWORD *v15;
  __int128 v16;
  int v17;
  int v18;
  uint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  unsigned int v23;
  char *v24;
  char *v25;
  __int128 v26;
  int v27;
  unint64_t v28;
  int v29;
  unint64_t v30;

  v3 = a2;
  v4 = *(unsigned int *)(a1 + 8);
  v5 = v4 + a3;
  if (v5 > *(unsigned int *)(a1 + 12))
  {
    v8 = *(_QWORD *)a1 + 48 * v4;
    if (*(_QWORD *)a1 <= a2 && v8 > a2)
    {
      v19 = (uint64_t)(a2 - *(_QWORD *)a1) >> 4;
      v30 = 0;
      v20 = (char *)(a1 + 16);
      v21 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), v5, 48, &v30);
      v22 = *(char **)a1;
      v23 = *(_DWORD *)(a1 + 8);
      if (v23)
      {
        v24 = &v22[48 * v23];
        v25 = v21;
        do
        {
          v26 = *((_OWORD *)v22 + 1);
          *(_OWORD *)v25 = *(_OWORD *)v22;
          *((_OWORD *)v25 + 1) = v26;
          *((_QWORD *)v25 + 4) = &off_1E0E23028;
          v27 = *((_DWORD *)v22 + 10);
          v25[44] = v22[44];
          *((_DWORD *)v25 + 10) = v27;
          *((_QWORD *)v25 + 4) = &off_1E0E22EC8;
          v22 += 48;
          v25 += 48;
        }
        while (v22 != v24);
        v22 = *(char **)a1;
      }
      v28 = 0xAAAAAAAAAAAAAAABLL * v19;
      v29 = v30;
      if (v22 != v20)
        free(v22);
      *(_QWORD *)a1 = v21;
      *(_DWORD *)(a1 + 12) = v29;
      return &v21[48 * v28];
    }
    else
    {
      v30 = 0;
      v10 = (char *)(a1 + 16);
      v11 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), v5, 48, &v30);
      v12 = *(char **)a1;
      v13 = *(_DWORD *)(a1 + 8);
      if (v13)
      {
        v14 = &v12[48 * v13];
        v15 = v11;
        do
        {
          v16 = *((_OWORD *)v12 + 1);
          *v15 = *(_OWORD *)v12;
          v15[1] = v16;
          *((_QWORD *)v15 + 4) = &off_1E0E23028;
          v17 = *((_DWORD *)v12 + 10);
          *((_BYTE *)v15 + 44) = v12[44];
          *((_DWORD *)v15 + 10) = v17;
          *((_QWORD *)v15 + 4) = &off_1E0E22EC8;
          v12 += 48;
          v15 += 3;
        }
        while (v12 != v14);
        v12 = *(char **)a1;
      }
      v18 = v30;
      if (v12 != v10)
        free(v12);
      *(_QWORD *)a1 = v11;
      *(_DWORD *)(a1 + 12) = v18;
    }
  }
  return (char *)v3;
}

_QWORD *_ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionINS2_3mps31ConstantAttributeConversionTypeENS4_19GenericOptionParserIS7_EEEC1IJN4llvm2cl4descENSD_11initializerIS7_EENSD_11ValuesClassEEEERS4_NSC_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISQ_EEFvRKS7_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1E0E51398;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionINS2_3mps31ConstantAttributeConversionTypeENS4_19GenericOptionParserIS7_EEEC1IJN4llvm2cl4descENSD_11initializerIS7_EENSD_11ValuesClassEEEERS4_NSC_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISQ_EEFvRKS7_EE7__cloneEPNS0_6__baseISV_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1E0E51398;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionINS2_3mps31ConstantAttributeConversionTypeENS4_19GenericOptionParserIS7_EEEC1IJN4llvm2cl4descENSD_11initializerIS7_EENSD_11ValuesClassEEEERS4_NSC_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISQ_EEFvRKS7_EEclESU_(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 8) + 608) = 1;
  return result;
}

uint64_t llvm::cl::parser<mlir::mps::ConstantAttributeConversionType>::parse(uint64_t a1, _QWORD *a2, const void *a3, size_t a4, const void *a5, size_t a6, _DWORD *a7)
{
  uint64_t v8;
  uint64_t v11;
  uint64_t v13;
  uint64_t result;
  llvm::raw_ostream *v15;
  _QWORD v16[4];
  __int16 v17;
  _QWORD v18[4];
  __int16 v19;

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
  if (v8)
    a3 = a5;
  if (v8)
    a4 = a6;
  v11 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v11)
  {
    v13 = *(_QWORD *)(a1 + 16);
    while (1)
    {
      if (*(_QWORD *)(v13 + 8) == a4)
      {
        if (!a4)
          break;
        a1 = memcmp(*(const void **)v13, a3, a4);
        if (!(_DWORD)a1)
          break;
      }
      v13 += 48;
      if (!--v11)
        goto LABEL_14;
    }
    result = 0;
    *a7 = *(_DWORD *)(v13 + 40);
  }
  else
  {
LABEL_14:
    v17 = 1283;
    v16[0] = "Cannot find option named '";
    v16[2] = a3;
    v16[3] = a4;
    v18[0] = v16;
    v18[2] = "'!";
    v19 = 770;
    v15 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
    return llvm::cl::Option::error(a2, (llvm::Twine *)v18, 0, 0, v15);
  }
  return result;
}

void mlir::mps::`anonymous namespace'::ConvertConstant::~ConvertConstant(mlir::mps::_anonymous_namespace_::ConvertConstant *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ConstantOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ConstantOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ConstantOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::ConvertConstant::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t RHS;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t OperandRange;
  uint64_t v22;
  int isCompatibleWithDenseStorage;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unsigned int IntOrFloatBitWidth;
  unint64_t v29;
  unint64_t v30;
  const void *v31;
  _QWORD *v32;
  int v33;
  int v34;
  _QWORD *v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  unint64_t v41;
  unint64_t *v42;
  _QWORD *v43;
  unint64_t v44;
  uint64_t v45;
  int v46;
  _QWORD *v47;
  _QWORD *v48;
  _QWORD *v49;
  _QWORD *v50;
  const void *v51;
  uint64_t NumElements;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  _QWORD *v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  _QWORD *v61;
  _QWORD *v62;
  unint64_t v63;
  unint64_t *v64;
  _QWORD *v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t *v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  _QWORD *v73;
  _QWORD *v74;
  unint64_t v75;
  unint64_t *v76;
  _QWORD *v77;
  unint64_t v78;
  const void *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  const void *ElementsAttrRawData;
  const void *v84;
  _QWORD *v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  _QWORD *v89;
  _QWORD *v90;
  unint64_t v91;
  unint64_t *v92;
  _QWORD *v93;
  unint64_t v94;
  uint64_t v95;
  _QWORD *v96;
  _QWORD *v97;
  uint64_t v98;
  unint64_t v99;
  unint64_t v100;
  _QWORD *v101;
  _QWORD *v102;
  unint64_t v103;
  unint64_t *v104;
  _QWORD *v105;
  unint64_t v106;
  uint64_t *BufferTensorAttr;
  uint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t *v111;
  _QWORD *v112;
  unint64_t v113;
  void *v114;
  uint64_t v115;
  mlir::GenericProgramPoint *v116;
  _QWORD *v117;
  uint64_t v118;
  unint64_t v119;
  unint64_t v120;
  unint64_t *v121;
  _QWORD *v122;
  unint64_t v123;
  uint64_t v124;
  uint64_t v125;
  mlir::GenericProgramPoint *v126;
  char v128;
  unint64_t v129;
  _BYTE *v130;
  uint64_t v131;
  uint64_t v132;
  unint64_t v133;
  uint64_t v134;
  unint64_t v135;
  uint64_t v136;
  uint64_t *v137;
  uint64_t v138;
  unint64_t v139;
  unint64_t v140;
  _QWORD *v141;
  _QWORD *v142;
  unint64_t v143;
  unint64_t *v144;
  _QWORD *v145;
  unint64_t v146;
  void *v147;
  uint64_t v148;
  mlir::GenericProgramPoint *v149;
  void *__p;
  void *v151;
  _QWORD *v152;
  void *v153;
  void *v154;
  _QWORD *v155;
  void *v156;
  void *v157;
  _QWORD *v158;
  void *v159;
  void *v160;
  _QWORD *v161;
  _BYTE v162[32];
  void *v163[10];
  _QWORD *v164;
  uint64_t v165[2];
  _QWORD *Type;
  _QWORD *Value;
  uint64_t v168;
  uint64_t v169;
  _QWORD *v170;
  __int128 v171;
  _QWORD v172[8];

  v172[7] = *MEMORY[0x1E0C80C00];
  v169 = a2;
  Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v169);
  v168 = v5;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&Value);
  v6 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v169) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6)
    goto LABEL_10;
  v7 = *v6;
  v8 = mlir::TypeID::get<mlir::ShapedType>();
  v9 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v9)
    goto LABEL_10;
  v10 = *(_QWORD **)(v7 + 8);
  v11 = &v10[2 * v9];
  do
  {
    v12 = v9 >> 1;
    v13 = &v10[2 * (v9 >> 1)];
    v15 = *v13;
    v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8)
      v10 = v14;
    else
      v9 = v12;
  }
  while (v9);
  if (v10 != v11 && *v10 == v8)
    v16 = v10[1];
  else
LABEL_10:
    v16 = 0;
  v165[0] = (uint64_t)v6;
  v165[1] = v16;
  v164 = Type;
  RHS = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&Type);
  if (RHS != mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v165) && *(_BYTE *)(a1 + 100))
  {
    v18 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&Type);
    v20 = v19;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v165);
    v164 = (_QWORD *)mlir::RankedTensorType::get(v18, v20, OperandRange, 0);
  }
  v22 = mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&v164);
  isCompatibleWithDenseStorage = mlir::isCompatibleWithDenseStorage(v22);
  if ((isCompatibleWithDenseStorage & 1) != 0 || !mlir::DenseElementsAttr::classof((uint64_t)Value))
  {
    if (Type == v164)
    {
      v34 = *(_DWORD *)(a1 + 96);
      if (!v34)
        return 0;
      if (v34 != 2)
      {
        if ((isCompatibleWithDenseStorage & 1) == 0 || mlir::DenseElementsAttr::classof((uint64_t)Value))
          return 0;
LABEL_23:
        if ((mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value) & 1) != 0
          || (v33 = *(_DWORD *)(a1 + 96), v33 == 1))
        {
          isCompatibleWithDenseStorage = 1;
        }
        else
        {
          isCompatibleWithDenseStorage = v33 != 2 && mlir::DenseElementsAttr::classof((uint64_t)Value);
        }
LABEL_33:
        if (Type != v164)
        {
          mlir::mps::CPUNDArray::CPUNDArray(&v170, Value);
          v35 = v164;
          if (!v164)
            goto LABEL_43;
          v36 = *v164;
          v37 = mlir::TypeID::get<mlir::ShapedType>();
          v38 = *(unsigned int *)(v36 + 16);
          if (!(_DWORD)v38)
            goto LABEL_43;
          v39 = *(_QWORD **)(v36 + 8);
          v40 = &v39[2 * v38];
          do
          {
            v41 = v38 >> 1;
            v42 = &v39[2 * (v38 >> 1)];
            v44 = *v42;
            v43 = v42 + 2;
            v38 += ~(v38 >> 1);
            if (v44 < v37)
              v39 = v43;
            else
              v38 = v41;
          }
          while (v38);
          if (v39 != v40 && *v39 == v37)
            v45 = v39[1];
          else
LABEL_43:
            v45 = 0;
          mlir::mps::CPUNDArray::CPUNDArray(v163, v35, v45, 0);
          if (*(_BYTE *)(a1 + 101))
            v46 = 14;
          else
            v46 = 13;
          mlir::mps::CPUNDArrayArithmeticUnaryKernel::CPUNDArrayArithmeticUnaryKernel((uint64_t)v162, v46, 0.0);
          v47 = operator new(8uLL);
          v159 = v47;
          *v47 = &v170;
          v160 = v47 + 1;
          v161 = v47 + 1;
          v48 = operator new(8uLL);
          v156 = v48;
          *v48 = v163;
          v157 = v48 + 1;
          v158 = v48 + 1;
          v49 = operator new(8uLL);
          v153 = v49;
          *v49 = 0;
          v154 = v49 + 1;
          v155 = v49 + 1;
          v50 = operator new(8uLL);
          __p = v50;
          *v50 = 0;
          v151 = v50 + 1;
          v152 = v50 + 1;
          mlir::mps::CPUNDArrayKernel::cpuTilingEngine((uint64_t)v162, (uint64_t *)&v159, (uint64_t **)&v156, (uint64_t)&v153, (uint64_t)&__p, 0, *((uint64_t *)&v171 + 1), (uint64_t)v162);
          if (__p)
          {
            v151 = __p;
            operator delete(__p);
          }
          if (v153)
          {
            v154 = v153;
            operator delete(v153);
          }
          if (v156)
          {
            v157 = v156;
            operator delete(v156);
          }
          if (v159)
          {
            v160 = v159;
            operator delete(v159);
          }
          v51 = v163[5];
          NumElements = mlir::mps::CPUNDArray::getNumElements((mlir::mps::CPUNDArray *)v163);
          v56 = mlir::mps::CPUNDArray::getElementDataSize((mlir::mps::CPUNDArray *)v163) * NumElements;
          v159 = 0;
          v160 = 0;
          v57 = v164;
          if (isCompatibleWithDenseStorage)
          {
            if (!v164)
              goto LABEL_65;
            v58 = *v164;
            v59 = mlir::TypeID::get<mlir::ShapedType>();
            v60 = *(unsigned int *)(v58 + 16);
            if (!(_DWORD)v60)
              goto LABEL_65;
            v61 = *(_QWORD **)(v58 + 8);
            v62 = &v61[2 * v60];
            do
            {
              v63 = v60 >> 1;
              v64 = &v61[2 * (v60 >> 1)];
              v66 = *v64;
              v65 = v64 + 2;
              v60 += ~(v60 >> 1);
              if (v66 < v59)
                v61 = v65;
              else
                v60 = v63;
            }
            while (v60);
            if (v61 != v62 && *v61 == v59)
              v67 = v61[1];
            else
LABEL_65:
              v67 = 0;
            v68 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v57, v67, v51, v56, v53, v54, v55);
            v69 = v68;
            if (!v68)
              goto LABEL_102;
            v70 = *v68;
            v71 = mlir::TypeID::get<mlir::ElementsAttr>();
            v72 = *(unsigned int *)(v70 + 16);
            if (!(_DWORD)v72)
              goto LABEL_102;
            v73 = *(_QWORD **)(v70 + 8);
            v74 = &v73[2 * v72];
            do
            {
              v75 = v72 >> 1;
              v76 = &v73[2 * (v72 >> 1)];
              v78 = *v76;
              v77 = v76 + 2;
              v72 += ~(v72 >> 1);
              if (v78 < v71)
                v73 = v77;
              else
                v72 = v75;
            }
            while (v72);
          }
          else
          {
            BufferTensorAttr = (uint64_t *)mlir::mps::getBufferTensorAttr((uint64_t)v164, v51, (const void *)v56);
            v69 = BufferTensorAttr;
            if (!BufferTensorAttr)
              goto LABEL_102;
            v108 = *BufferTensorAttr;
            v71 = mlir::TypeID::get<mlir::ElementsAttr>();
            v109 = *(unsigned int *)(v108 + 16);
            if (!(_DWORD)v109)
              goto LABEL_102;
            v73 = *(_QWORD **)(v108 + 8);
            v74 = &v73[2 * v109];
            do
            {
              v110 = v109 >> 1;
              v111 = &v73[2 * (v109 >> 1)];
              v113 = *v111;
              v112 = v111 + 2;
              v109 += ~(v109 >> 1);
              if (v113 < v71)
                v73 = v112;
              else
                v109 = v110;
            }
            while (v109);
          }
          if (v73 != v74 && *v73 == v71)
          {
            v114 = (void *)v73[1];
            goto LABEL_103;
          }
LABEL_102:
          v114 = 0;
LABEL_103:
          v159 = v69;
          v160 = v114;
          v115 = v169;
          v116 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(v169 + 24), v165, (_QWORD **)&v159);
          (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v115, v116);
          mlir::mps::CPUNDArray::~CPUNDArray(v163);
          mlir::mps::CPUNDArray::~CPUNDArray((void **)&v170);
          return 1;
        }
        ElementsAttrRawData = (const void *)mlir::getElementsAttrRawData((uint64_t)Value);
        v84 = v79;
        v170 = 0;
        *(_QWORD *)&v171 = 0;
        v85 = Type;
        if (isCompatibleWithDenseStorage)
        {
          if (!Type)
            goto LABEL_84;
          v86 = *Type;
          v87 = mlir::TypeID::get<mlir::ShapedType>();
          v88 = *(unsigned int *)(v86 + 16);
          if (!(_DWORD)v88)
            goto LABEL_84;
          v89 = *(_QWORD **)(v86 + 8);
          v90 = &v89[2 * v88];
          do
          {
            v91 = v88 >> 1;
            v92 = &v89[2 * (v88 >> 1)];
            v94 = *v92;
            v93 = v92 + 2;
            v88 += ~(v88 >> 1);
            if (v94 < v87)
              v89 = v93;
            else
              v88 = v91;
          }
          while (v88);
          if (v89 != v90 && *v89 == v87)
            v95 = v89[1];
          else
LABEL_84:
            v95 = 0;
          v96 = (_QWORD *)mlir::DenseElementsAttr::getFromRawBuffer(v85, v95, ElementsAttrRawData, v84, v80, v81, v82);
          v97 = v96;
          if (!v96)
            goto LABEL_113;
          v98 = *v96;
          v99 = mlir::TypeID::get<mlir::ElementsAttr>();
          v100 = *(unsigned int *)(v98 + 16);
          if (!(_DWORD)v100)
            goto LABEL_113;
          v101 = *(_QWORD **)(v98 + 8);
          v102 = &v101[2 * v100];
          do
          {
            v103 = v100 >> 1;
            v104 = &v101[2 * (v100 >> 1)];
            v106 = *v104;
            v105 = v104 + 2;
            v100 += ~(v100 >> 1);
            if (v106 < v99)
              v101 = v105;
            else
              v100 = v103;
          }
          while (v100);
        }
        else
        {
          v117 = (_QWORD *)mlir::mps::getBufferTensorAttr((uint64_t)Type, ElementsAttrRawData, v79);
          v97 = v117;
          if (!v117)
            goto LABEL_113;
          v118 = *v117;
          v99 = mlir::TypeID::get<mlir::ElementsAttr>();
          v119 = *(unsigned int *)(v118 + 16);
          if (!(_DWORD)v119)
            goto LABEL_113;
          v101 = *(_QWORD **)(v118 + 8);
          v102 = &v101[2 * v119];
          do
          {
            v120 = v119 >> 1;
            v121 = &v101[2 * (v119 >> 1)];
            v123 = *v121;
            v122 = v121 + 2;
            v119 += ~(v119 >> 1);
            if (v123 < v99)
              v101 = v122;
            else
              v119 = v120;
          }
          while (v119);
        }
        if (v101 != v102 && *v101 == v99)
        {
          v124 = v101[1];
          goto LABEL_114;
        }
LABEL_113:
        v124 = 0;
LABEL_114:
        v170 = v97;
        *(_QWORD *)&v171 = v124;
        v125 = v169;
        v126 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(v169 + 24), v165, &v170);
        (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v125, v126);
        return 1;
      }
      if (*(_UNKNOWN **)(*Value + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id
        || (mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value) & 1) != 0)
      {
        return 0;
      }
    }
    if (!isCompatibleWithDenseStorage)
      goto LABEL_33;
    goto LABEL_23;
  }
  if ((mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value) & 1) == 0)
  {
    v24 = mlir::getElementsAttrRawData((uint64_t)Value);
    v26 = v25;
    v27 = mlir::ElementsAttr::getNumElements((uint64_t)Value, v168);
    v170 = (_QWORD *)mlir::AffineBinaryOpExpr::getRHS((mlir::AffineBinaryOpExpr *)&Type);
    IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v170);
    v29 = 8 / IntOrFloatBitWidth;
    if ((_DWORD)v29 * IntOrFloatBitWidth == 8)
    {
      v170 = v172;
      v171 = xmmword_181233150;
      v30 = v27 - 1 + v29;
      if (__CFADD__(v27 - 1, v29))
      {
        v31 = 0;
        v32 = v172;
      }
      else
      {
        v128 = IntOrFloatBitWidth;
        v129 = v30 / v29;
        if (v30 / v29 < 0x29)
        {
          v131 = 0;
          v130 = v172;
        }
        else
        {
          llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v170, v172, v30 / v29, 1);
          v130 = v170;
          v131 = v171;
        }
        if (v129 != v131)
        {
          bzero(&v130[v131], v129 - v131);
          v130 = v170;
        }
        v132 = 0;
        *(_QWORD *)&v171 = v129;
        v133 = v26;
        do
        {
          v134 = v132 * v29;
          v135 = v26 - v132 * v29;
          if (v135 >= v29)
            v135 = v29;
          if (v135)
          {
            v136 = v133 >= v29 ? v29 : v133;
            LODWORD(v135) = *(unsigned __int8 *)(v24 + v134);
            if (v136 != 1)
            {
              LODWORD(v135) = v135 | (*(unsigned __int8 *)(v134 + v24 + 1) << v128);
              if (v136 != 2)
              {
                LODWORD(v135) = v135 | (*(unsigned __int8 *)(v134 + v24 + 2) << (2 * v128));
                if (v136 != 3)
                {
                  LODWORD(v135) = v135 | (*(unsigned __int8 *)(v134 + v24 + 3) << (3 * v128));
                  if (v136 != 4)
                  {
                    LODWORD(v135) = v135 | (*(unsigned __int8 *)(v134 + v24 + 4) << (4 * v128));
                    if (v136 != 5)
                    {
                      LODWORD(v135) = v135 | (*(unsigned __int8 *)(v134 + v24 + 5) << (5 * v128));
                      if (v136 != 6)
                      {
                        LODWORD(v135) = v135 | (*(unsigned __int8 *)(v134 + v24 + 6) << (6 * v128));
                        if (v136 != 7)
                          LODWORD(v135) = v135 | (*(unsigned __int8 *)(v134 + v24 + 7) << (7 * v128));
                      }
                    }
                  }
                }
              }
            }
          }
          *v130++ = v135;
          ++v132;
          v133 -= v29;
          --v129;
        }
        while (v129);
        v32 = v170;
        v31 = (const void *)v171;
      }
      v137 = (uint64_t *)mlir::mps::getBufferTensorAttr((uint64_t)Type, v32, v31);
      v163[0] = v137;
      if (!v137)
        goto LABEL_156;
      v138 = *v137;
      v139 = mlir::TypeID::get<mlir::ElementsAttr>();
      v140 = *(unsigned int *)(v138 + 16);
      if (!(_DWORD)v140)
        goto LABEL_156;
      v141 = *(_QWORD **)(v138 + 8);
      v142 = &v141[2 * v140];
      do
      {
        v143 = v140 >> 1;
        v144 = &v141[2 * (v140 >> 1)];
        v146 = *v144;
        v145 = v144 + 2;
        v140 += ~(v140 >> 1);
        if (v146 < v139)
          v141 = v145;
        else
          v140 = v143;
      }
      while (v140);
      if (v141 != v142 && *v141 == v139)
        v147 = (void *)v141[1];
      else
LABEL_156:
        v147 = 0;
      v163[1] = v147;
      v148 = v169;
      v149 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(v169 + 24), v165, (_QWORD **)v163);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a3 + 32))(a3, v148, v149);
      if (v170 != v172)
        free(v170);
      return 1;
    }
  }
  return 0;
}

uint64_t _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZNS1_3mps12_GLOBAL__N_123ConstantsConversionPass31convertToCoalescedBufferTensorsENS1_8ModuleOpEEUlNSB_10ConstantOpEE_SF_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESO_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t result, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t Type;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18[2];
  uint64_t v19;

  if (a2)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
    {
      v2 = *(uint64_t **)result;
      v19 = a2;
      v18[0] = (uint64_t)mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v19);
      v18[1] = v3;
      result = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v18);
      if ((result & 1) == 0)
      {
        v4 = *v2;
        v5 = v19;
        v6 = *(unsigned int *)(*v2 + 8);
        if (v6 >= *(_DWORD *)(*v2 + 12))
        {
          v15 = v19;
          llvm::SmallVectorBase<unsigned int>::grow_pod(*v2, (void *)(v4 + 16), v6 + 1, 8);
          v5 = v15;
          LODWORD(v6) = *(_DWORD *)(v4 + 8);
        }
        *(_QWORD *)(*(_QWORD *)v4 + 8 * v6) = v5;
        ++*(_DWORD *)(v4 + 8);
        v7 = v2[1];
        Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)v18);
        v9 = *(unsigned int *)(v7 + 8);
        if (v9 >= *(_DWORD *)(v7 + 12))
        {
          v16 = Type;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v7, (void *)(v7 + 16), v9 + 1, 8);
          Type = v16;
          LODWORD(v9) = *(_DWORD *)(v7 + 8);
        }
        *(_QWORD *)(*(_QWORD *)v7 + 8 * v9) = Type;
        ++*(_DWORD *)(v7 + 8);
        v10 = v2[2];
        result = mlir::getElementsAttrRawData(v18[0]);
        v12 = *(unsigned int *)(v10 + 8);
        if (v12 >= *(_DWORD *)(v10 + 12))
        {
          v17 = result;
          v14 = v11;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v10, (void *)(v10 + 16), v12 + 1, 16);
          v11 = v14;
          result = v17;
          LODWORD(v12) = *(_DWORD *)(v10 + 8);
        }
        v13 = (uint64_t *)(*(_QWORD *)v10 + 16 * v12);
        *v13 = result;
        v13[1] = v11;
        ++*(_DWORD *)(v10 + 8);
      }
    }
  }
  return result;
}

_QWORD *mlir::mps::registerConvertOpLayoutExternalModels(mlir::mps *this, mlir::DialectRegistry *a2)
{
  _QWORD *result;
  uint64_t v3;
  _QWORD v4[3];
  _QWORD *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4[0] = &unk_1E0E4FF00;
  v4[1] = mlir::mps::registerConvertOpLayoutExternalModels(mlir::DialectRegistry &)::$_0::__invoke;
  v5 = v4;
  mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(this, v4);
  result = v5;
  if (v5 == v4)
  {
    v3 = 4;
    result = v4;
  }
  else
  {
    if (!v5)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

uint64_t mlir::ConvertOpLayoutInterface::convertLayout(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (**(uint64_t (***)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(a1 + 8))(*(_QWORD *)(a1 + 8), *(_QWORD *)a1, a2, a3, a4);
}

void mlir::mps::registerConvertOpLayoutExternalModels(mlir::DialectRegistry &)::$_0::__invoke(uint64_t *a1)
{
  const char *v2;
  _QWORD *v3;
  char v4;
  _QWORD *v5;
  void *v6;
  uint64_t Values;
  __guard v8;
  _QWORD *v9;
  __guard v10;
  const char *v11;
  _QWORD *v12;
  char v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  __guard v17;
  _QWORD *v18;
  __guard v19;
  const char *v20;
  _QWORD *v21;
  char v22;
  _QWORD *v23;
  void *v24;
  uint64_t v25;
  __guard v26;
  _QWORD *v27;
  __guard v28;
  _QWORD *v29;
  char v30;
  _QWORD *v31;
  void *v32;
  uint64_t v33;
  __guard v34;
  _QWORD *v35;
  __guard v36;
  _QWORD *v37;
  char v38;
  _QWORD *v39;
  void *v40;
  uint64_t v41;
  __guard v42;
  _QWORD *v43;
  __guard v44;
  _QWORD *v45;
  char v46;
  _QWORD *v47;
  void *v48;
  uint64_t v49;
  __guard v50;
  _QWORD *v51;
  __guard v52;
  const char *v53;
  _QWORD *v54;
  char v55;
  _QWORD *v56;
  void *v57;
  uint64_t v58;
  __guard v59;
  _QWORD *v60;
  __guard v61;
  const char *v62;
  _QWORD *v63;
  char v64;
  _QWORD *v65;
  void *v66;
  uint64_t v67;
  __guard v68;
  _QWORD *v69;
  __guard v70;
  const char *v71;
  _QWORD *v72;
  char v73;
  _QWORD *v74;
  void *v75;
  uint64_t v76;
  __guard v77;
  _QWORD *v78;
  __guard v79;
  _QWORD *v80;
  char v81;
  _QWORD *v82;
  void *v83;
  uint64_t v84;
  __guard v85;
  _QWORD *v86;
  __guard v87;
  _QWORD *v88;
  char v89;
  _QWORD *v90;
  void *v91;
  uint64_t v92;
  __guard v93;
  _QWORD *v94;
  __guard v95;
  _QWORD *v96;
  char v97;
  _QWORD *v98;
  void *v99;
  uint64_t v100;
  __guard v101;
  _QWORD *v102;
  __guard v103;
  _QWORD *v104;
  char v105;
  _QWORD *v106;
  void *v107;
  uint64_t v108;
  __guard v109;
  _QWORD *v110;
  __guard v111;
  _QWORD *v112;
  char v113;
  _QWORD *v114;
  void *v115;
  uint64_t v116;
  __guard v117;
  _QWORD *v118;
  __guard v119;
  _QWORD *v120;
  char v121;
  _QWORD *v122;
  void *v123;
  uint64_t v124;
  __guard v125;
  _QWORD *v126;
  __guard v127;
  uint64_t v128;
  const char *v129;
  __int16 v130;
  const char *v131;
  const char *v132;
  uint64_t v133;
  __int16 v134;
  _QWORD v135[5];

  v2 = "mps.conv_2d";
  v3 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d", (const unsigned __int8 *)0xB, a1);
  if (!v4)
    goto LABEL_62;
  v5 = v3;
  v6 = (void *)v3[2];
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v3[1];
    Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    v6 = (void *)v5[2];
  }
  else
  {
    Values = v3[3];
  }
  v8 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(Values, (uint64_t)v6, v8);
  v9 = malloc(8uLL);
  v10 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v5 + 4), v10, v9);
  v11 = "mps.conv_2d_data_gradient";
  v12 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d_data_gradient", (const unsigned __int8 *)0x19, a1);
  if (!v13)
    goto LABEL_63;
  v14 = v12;
  v15 = (void *)v12[2];
  if (v15 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v12[1];
    v16 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    v15 = (void *)v14[2];
  }
  else
  {
    v16 = v12[3];
  }
  v17 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v16, (uint64_t)v15, v17);
  v18 = malloc(8uLL);
  v19 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v14 + 4), v19, v18);
  v20 = "mps.conv_2d_weights_gradient";
  v21 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d_weights_gradient", (const unsigned __int8 *)0x1C, a1);
  if (!v22)
    goto LABEL_64;
  v23 = v21;
  v24 = (void *)v21[2];
  if (v24 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v21[1];
    v25 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    v24 = (void *)v23[2];
  }
  else
  {
    v25 = v21[3];
  }
  v26 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v25, (uint64_t)v24, v26);
  v27 = malloc(8uLL);
  v28 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v23 + 4), v28, v27);
  v2 = "mps.conv_3d";
  v29 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_3d", (const unsigned __int8 *)0xB, a1);
  if (!v30)
  {
LABEL_62:
    v134 = 1283;
    v131 = "Attempting to attach an interface to an unregistered operation ";
    v132 = v2;
    v128 = 11;
    goto LABEL_72;
  }
  v31 = v29;
  v32 = (void *)v29[2];
  if (v32 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v29[1];
    v33 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    v32 = (void *)v31[2];
  }
  else
  {
    v33 = v29[3];
  }
  v34 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v33, (uint64_t)v32, v34);
  v35 = malloc(8uLL);
  v36 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v31 + 4), v36, v35);
  v11 = "mps.conv_3d_data_gradient";
  v37 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_3d_data_gradient", (const unsigned __int8 *)0x19, a1);
  if (!v38)
  {
LABEL_63:
    v134 = 1283;
    v131 = "Attempting to attach an interface to an unregistered operation ";
    v132 = v11;
    v128 = 25;
    goto LABEL_72;
  }
  v39 = v37;
  v40 = (void *)v37[2];
  if (v40 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v37[1];
    v41 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    v40 = (void *)v39[2];
  }
  else
  {
    v41 = v37[3];
  }
  v42 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v41, (uint64_t)v40, v42);
  v43 = malloc(8uLL);
  v44 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v39 + 4), v44, v43);
  v20 = "mps.conv_3d_weights_gradient";
  v45 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_3d_weights_gradient", (const unsigned __int8 *)0x1C, a1);
  if (!v46)
  {
LABEL_64:
    v134 = 1283;
    v131 = "Attempting to attach an interface to an unregistered operation ";
    v132 = v20;
    v128 = 28;
    goto LABEL_72;
  }
  v47 = v45;
  v48 = (void *)v45[2];
  if (v48 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v45[1];
    v49 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    v48 = (void *)v47[2];
  }
  else
  {
    v49 = v45[3];
  }
  v50 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v49, (uint64_t)v48, v50);
  v51 = malloc(8uLL);
  v52 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v47 + 4), v52, v51);
  v53 = "mps.depthwise_conv_2d";
  v54 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_2d", (const unsigned __int8 *)0x15, a1);
  if (!v55)
    goto LABEL_65;
  v56 = v54;
  v57 = (void *)v54[2];
  if (v57 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v54[1];
    v58 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    v57 = (void *)v56[2];
  }
  else
  {
    v58 = v54[3];
  }
  v59 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v58, (uint64_t)v57, v59);
  v60 = malloc(8uLL);
  v61 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v56 + 4), v61, v60);
  v62 = "mps.depthwise_conv_2d_data_gradient";
  v63 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_2d_data_gradient", (const unsigned __int8 *)0x23, a1);
  if (!v64)
    goto LABEL_66;
  v65 = v63;
  v66 = (void *)v63[2];
  if (v66 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v63[1];
    v67 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    v66 = (void *)v65[2];
  }
  else
  {
    v67 = v63[3];
  }
  v68 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v67, (uint64_t)v66, v68);
  v69 = malloc(8uLL);
  v70 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v65 + 4), v70, v69);
  v71 = "mps.depthwise_conv_2d_weights_gradient";
  v72 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_2d_weights_gradient", (const unsigned __int8 *)0x26, a1);
  if (!v73)
    goto LABEL_67;
  v74 = v72;
  v75 = (void *)v72[2];
  if (v75 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v72[1];
    v76 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    v75 = (void *)v74[2];
  }
  else
  {
    v76 = v72[3];
  }
  v77 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v76, (uint64_t)v75, v77);
  v78 = malloc(8uLL);
  v79 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v74 + 4), v79, v78);
  v53 = "mps.depthwise_conv_3d";
  v80 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d", (const unsigned __int8 *)0x15, a1);
  if (!v81)
  {
LABEL_65:
    v134 = 1283;
    v131 = "Attempting to attach an interface to an unregistered operation ";
    v132 = v53;
    v128 = 21;
    goto LABEL_72;
  }
  v82 = v80;
  v83 = (void *)v80[2];
  if (v83 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v80[1];
    v84 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    v83 = (void *)v82[2];
  }
  else
  {
    v84 = v80[3];
  }
  v85 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v84, (uint64_t)v83, v85);
  v86 = malloc(8uLL);
  v87 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v82 + 4), v87, v86);
  v62 = "mps.depthwise_conv_3d_data_gradient";
  v88 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d_data_gradient", (const unsigned __int8 *)0x23, a1);
  if (!v89)
  {
LABEL_66:
    v134 = 1283;
    v131 = "Attempting to attach an interface to an unregistered operation ";
    v132 = v62;
    v128 = 35;
    goto LABEL_72;
  }
  v90 = v88;
  v91 = (void *)v88[2];
  if (v91 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v88[1];
    v92 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    v91 = (void *)v90[2];
  }
  else
  {
    v92 = v88[3];
  }
  v93 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v92, (uint64_t)v91, v93);
  v94 = malloc(8uLL);
  v95 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v90 + 4), v95, v94);
  v71 = "mps.depthwise_conv_3d_weights_gradient";
  v96 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d_weights_gradient", (const unsigned __int8 *)0x26, a1);
  if (!v97)
  {
LABEL_67:
    v134 = 1283;
    v131 = "Attempting to attach an interface to an unregistered operation ";
    v132 = v71;
    v128 = 38;
    goto LABEL_72;
  }
  v98 = v96;
  v99 = (void *)v96[2];
  if (v99 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v96[1];
    v100 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    v99 = (void *)v98[2];
  }
  else
  {
    v100 = v96[3];
  }
  v101 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v100, (uint64_t)v99, v101);
  v102 = malloc(8uLL);
  v103 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v98 + 4), v103, v102);
  v104 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_average", (const unsigned __int8 *)0x13, a1);
  if (!v105)
  {
    v134 = 1283;
    v131 = "Attempting to attach an interface to an unregistered operation ";
    v132 = "mps.pooling_average";
LABEL_71:
    v128 = 19;
LABEL_72:
    v133 = v128;
    v129 = ".";
    v130 = 259;
    llvm::operator+((uint64_t *)&v131, (uint64_t *)&v129, (uint64_t)v135);
    llvm::report_fatal_error((llvm::Twine *)v135, 1);
  }
  v106 = v104;
  v107 = (void *)v104[2];
  if (v107 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v104[1];
    v108 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    v107 = (void *)v106[2];
  }
  else
  {
    v108 = v104[3];
  }
  v109 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v108, (uint64_t)v107, v109);
  v110 = malloc(8uLL);
  v111 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v106 + 4), v111, v110);
  v112 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_max", (const unsigned __int8 *)0xF, a1);
  if (!v113)
  {
    v134 = 1283;
    v131 = "Attempting to attach an interface to an unregistered operation ";
    v132 = "mps.pooling_max";
    v128 = 15;
    goto LABEL_72;
  }
  v114 = v112;
  v115 = (void *)v112[2];
  if (v115 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v112[1];
    v116 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    v115 = (void *)v114[2];
  }
  else
  {
    v116 = v112[3];
  }
  v117 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v116, (uint64_t)v115, v117);
  v118 = malloc(8uLL);
  v119 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v114 + 4), v119, v118);
  v120 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_l2_norm", (const unsigned __int8 *)0x13, a1);
  if (!v121)
  {
    v134 = 1283;
    v131 = "Attempting to attach an interface to an unregistered operation ";
    v132 = "mps.pooling_l2_norm";
    goto LABEL_71;
  }
  v122 = v120;
  v123 = (void *)v120[2];
  if (v123 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v135[0] = v120[1];
    v124 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v135);
    v123 = (void *)v122[2];
  }
  else
  {
    v124 = v120[3];
  }
  v125 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v124, (uint64_t)v123, v125);
  v126 = malloc(8uLL);
  v127 = mlir::TypeID::get<mlir::ConvertOpLayoutInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v122 + 4), v127, v126);
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv2DOp>>::convertLayout(uint64_t a1, _QWORD *a2, int a3, int a4, uint64_t a5)
{
  int StorageType;
  int WeightsLayout;
  uint64_t result;
  void *v11;
  BOOL v14;
  char v15;
  void **v16;
  _BOOL4 v17;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  __int128 *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t v36;
  mlir::MLIRContext *Context;
  uint64_t v38;
  mlir::MLIRContext *v39;
  uint64_t v40;
  uint64_t Strides;
  uint64_t v42;
  uint64_t InputAttributeNames;
  uint64_t v44;
  uint64_t Rewriter;
  uint64_t v46;
  mlir::GenericProgramPoint *v47;
  __int128 *v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  unint64_t v53;
  __int128 v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  mlir::GenericProgramPoint *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  int32x4_t *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  _QWORD *v83;
  _QWORD *v84;
  unint64_t v85;
  unint64_t *v86;
  _QWORD *v87;
  unint64_t v88;
  uint64_t v89;
  mlir::OpBuilder *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  _QWORD *v102;
  _QWORD *v103;
  unint64_t v104;
  unint64_t *v105;
  _QWORD *v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  mlir::GenericProgramPoint *v110;
  uint64_t v111;
  int32x4_t *v112;
  unint64_t v113;
  int32x4_t *v114;
  char *v115;
  unint64_t v116;
  uint64_t v117;
  int32x4_t *v118;
  int32x4_t *v119;
  uint64_t v120;
  int32x4_t v121;
  int32x4_t v122;
  int32x4_t v123;
  int32x4_t v124;
  uint64_t v125;
  int v126;
  uint64_t *v127;
  _QWORD *v128;
  _QWORD *v129;
  _QWORD *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  mlir::GenericProgramPoint *DefiningOp;
  uint64_t *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char v142;
  _QWORD v143[3];
  void **v144;
  unsigned int *v145;
  unsigned int *v146;
  unsigned int v147;
  unsigned int v148;
  _QWORD *v149;
  uint64_t *v150;
  uint64_t ElementTypeOrSelf;
  _QWORD v152[2];
  uint64_t **v153;
  mlir::GenericProgramPoint *v154;
  void *v155;
  _BYTE v156[24];
  int v157;
  void *__dst;
  uint64_t v159;
  __int128 v160;
  int v161;
  void *v162;
  unsigned int v163;
  int v164;
  __int128 v165;
  mlir::GenericProgramPoint *v166;
  uint64_t v167;
  _BYTE v168[24];
  int32x4_t *v169;
  uint64_t v170;
  _BYTE v171[40];
  uint64_t v172;

  v172 = *MEMORY[0x1E0C80C00];
  v149 = a2;
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v149);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 == 2)
          goto LABEL_9;
        break;
      case 1:
      case 8:
        if (a3 != 1)
          break;
LABEL_9:
        v11 = *(void **)(v149[6] + 16);
        v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
        v15 = v14;
        if (v14)
        {
          LODWORD(v16) = 0;
          v17 = 1;
        }
        else
        {
          v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
          LODWORD(v16) = !v17;
        }
        v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
        v22 = v21;
        v23 = v21;
        if (a3)
          __asm { BR              X10 }
        v24 = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v149);
        v148 = v24;
        if (a4)
          __asm { BR              X10 }
        v147 = v24;
        v142 = v15;
        if (v22 != v23)
          __asm { BR              X10 }
        v25 = &v165;
        v162 = &v165;
        v164 = 5;
        v165 = xmmword_181235170;
        while (2)
        {
          v163 = 4;
          v144 = &v162;
          v145 = &v148;
          v146 = &v147;
          v143[0] = a5;
          v143[1] = &v149;
          v143[2] = &v144;
          v26 = *(_QWORD *)(v149[9] + 24);
          v27 = v149[3];
          v169 = (int32x4_t *)v171;
          memcpy(v171, v25, 0x10uLL);
          v170 = 0x500000004;
          if (v169 != (int32x4_t *)v171)
            free(v169);
          v30 = (uint64_t *)v149[9];
          v31 = (uint64_t *)v30[1];
          if (v31)
          {
            *v31 = *v30;
            if (*v30)
              *(_QWORD *)(*v30 + 8) = v30[1];
          }
          v30[3] = (uint64_t)v28;
          v30[1] = (uint64_t)v28;
          v32 = *v28;
          *v30 = *v28;
          if (v32)
            *(_QWORD *)(v32 + 8) = v30;
          *v28 = (uint64_t)v30;
          v33 = (_QWORD *)v149[9];
          v34 = v33 + 4;
          v35 = (_QWORD *)v33[5];
          if (v35)
          {
            *v35 = *v34;
            if (*v34)
              *(_QWORD *)(*v34 + 8) = v33[5];
          }
          v33[7] = v29;
          v33[5] = v29;
          v36 = *v29;
          v33[4] = *v29;
          if (v36)
            *(_QWORD *)(v36 + 8) = v34;
          *v29 = (uint64_t)v34;
          Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v38 = mlir::mps::TensorDataLayoutAttr::get(Context, v23);
          mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v149, v38);
          v39 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v40 = mlir::mps::TensorDataLayoutAttr::get(v39, v147);
          mlir::mps::Conv2DDataGradientOp::setWeightsLayoutAttr((uint64_t *)&v149, v40);
          Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v149, v42);
          InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v149, v44);
          Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v149, v46);
          v47 = (mlir::GenericProgramPoint *)v149;
          if (v17)
          {
            v16 = v144;
            v48 = &v160;
            __dst = &v160;
            v159 = 0x500000000;
            if (v144 != &__dst)
            {
              v49 = *((_DWORD *)v144 + 2);
              if (!v49)
                goto LABEL_75;
              if (v49 >= 6)
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v160, *((unsigned int *)v144 + 2), 4);
                v52 = *((_DWORD *)v16 + 2);
                if (!v52)
                {
LABEL_74:
                  LODWORD(v159) = v49;
                  v48 = (__int128 *)__dst;
LABEL_75:
                  if (v23 == v22)
                    break;
LABEL_81:
                  switch(v22)
                  {
                    case 0u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x200000001;
                      v54 = xmmword_181240940;
                      goto LABEL_86;
                    case 1u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000003;
                      v54 = xmmword_181240950;
                      goto LABEL_86;
                    case 2u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000000;
                      v54 = xmmword_181240920;
                      goto LABEL_86;
                    case 3u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 1;
                      v54 = xmmword_181240930;
LABEL_86:
                      *(_OWORD *)v156 = v54;
                      v53 = 4;
                      goto LABEL_87;
                    default:
                      *((_DWORD *)v25 + 4) = 4;
                      *v25 = xmmword_181240EA8;
                      continue;
                  }
                }
                v48 = (__int128 *)__dst;
              }
              else
              {
                v52 = *((_DWORD *)v144 + 2);
              }
              memcpy(v48, *v16, 4 * v52);
              goto LABEL_74;
            }
            v49 = 0;
            if (v23 != v22)
              goto LABEL_81;
          }
          else
          {
            v50 = *v145;
            v51 = *v146;
            if (*v145 != (_DWORD)v51)
              __asm { BR              X10 }
            v48 = &v160;
            __dst = &v160;
            v49 = 5;
            HIDWORD(v159) = 5;
            if (v50 <= 3)
            {
              v160 = xmmword_181235170;
              v49 = 4;
            }
            else
            {
              v161 = 4;
              v160 = xmmword_181240EA8;
            }
            LODWORD(v159) = v49;
            v23 = v147;
            v22 = v148;
            if (v147 != v148)
              goto LABEL_81;
          }
          break;
        }
        v155 = &v156[8];
        v53 = 5;
        *(_DWORD *)&v156[4] = 5;
        if (v22 <= 3)
        {
          *(_OWORD *)&v156[8] = xmmword_181235170;
          v53 = 4;
        }
        else
        {
          v157 = 4;
          *(_OWORD *)&v156[8] = xmmword_181240EA8;
        }
        *(_DWORD *)v156 = v53;
LABEL_87:
        v154 = v47;
        v55 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v154);
        v153 = (uint64_t **)v55;
        v56 = (uint64_t *)(*(_QWORD *)(v55 + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v56)
          goto LABEL_96;
        v57 = *v56;
        v58 = mlir::TypeID::get<mlir::ShapedType>();
        v59 = *(unsigned int *)(v57 + 16);
        if (!(_DWORD)v59)
          goto LABEL_96;
        v60 = *(_QWORD **)(v57 + 8);
        v61 = &v60[2 * v59];
        do
        {
          v62 = v59 >> 1;
          v63 = &v60[2 * (v59 >> 1)];
          v65 = *v63;
          v64 = v63 + 2;
          v59 += ~(v59 >> 1);
          if (v65 < v58)
            v60 = v64;
          else
            v59 = v62;
        }
        while (v59);
        if (v60 != v61 && *v60 == v58)
          v66 = v60[1];
        else
LABEL_96:
          v66 = 0;
        v152[0] = v56;
        v152[1] = v66;
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
          goto LABEL_154;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152);
        v169 = (int32x4_t *)v171;
        v170 = 0x500000000;
        v68 = (mlir::GenericProgramPoint *)(int)v67;
        if ((unint64_t)(v67 << 32) >= 0x500000001)
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, (int)v67, 8);
        if (v49)
        {
          v69 = 4 * v49;
          do
          {
            v70 = *(unsigned int *)v48;
            v71 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152) + 8 * v70);
            v72 = v170;
            if (v170 >= (unint64_t)HIDWORD(v170))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, v170 + 1, 8);
              v72 = v170;
            }
            v169->i64[v72] = v71;
            v73 = v170 + 1;
            LODWORD(v170) = v170 + 1;
            v48 = (__int128 *)((char *)v48 + 4);
            v69 -= 4;
          }
          while (v69);
        }
        else
        {
          v73 = v170;
        }
        v166 = (mlir::GenericProgramPoint *)v152[0];
        *(_QWORD *)(v55 + 8) = *(_QWORD *)(v55 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v166, (uint64_t)v169, v73);
        if ((v142 & 1) != 0 || (*((_BYTE *)v154 + 46) & 0x80) == 0 || *((_DWORD *)v154 + 17) != 3)
        {
LABEL_152:
          if (v169 != (int32x4_t *)v171)
            free(v169);
LABEL_154:
          v132 = *((_QWORD *)v154 + 2);
          mlir::GenericProgramPoint::~GenericProgramPoint(v154);
          v134 = *(_QWORD *)(v133 + 8);
          *(_QWORD *)(a5 + 24) = v132;
          *(_QWORD *)(a5 + 32) = v134;
          if ((int32x4_t *)v55 != v169)
          {
            DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v169);
            if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
            {
              v136 = (uint64_t *)v169;
            }
            else
            {
              v137 = *((_QWORD *)DefiningOp + 2);
              mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
              v139 = *(_QWORD *)(v138 + 8);
              *(_QWORD *)(a5 + 24) = v137;
              *(_QWORD *)(a5 + 32) = v139;
              v140 = *((_QWORD *)v154 + 3);
              ElementTypeOrSelf = 0;
              LOBYTE(v150) = 1;
              v166 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v140, (uint64_t *)&v169, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v150);
              v136 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v166);
            }
            mlir::Value::replaceAllUsesExcept(&v153, v136, (uint64_t)DefiningOp);
          }
          if (v155 != &v156[8])
            free(v155);
          if (__dst != &v160)
            free(__dst);
          if (v162 != &v165)
            free(v162);
          return 1;
        }
        ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(_QWORD *)(*((_QWORD *)v154 + 9) + 88));
        if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
        {
          v166 = v68;
          v95 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
          v96 = mlir::IntegerType::get(v95, 0x40u, 1u);
          v97 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v96, 0);
          v98 = v97;
          if (!v97)
            goto LABEL_133;
          v99 = *v97;
          v100 = mlir::TypeID::get<mlir::ShapedType>();
          v101 = *(unsigned int *)(v99 + 16);
          if (!(_DWORD)v101)
            goto LABEL_133;
          v102 = *(_QWORD **)(v99 + 8);
          v103 = &v102[2 * v101];
          do
          {
            v104 = v101 >> 1;
            v105 = &v102[2 * (v101 >> 1)];
            v107 = *v105;
            v106 = v105 + 2;
            v101 += ~(v101 >> 1);
            if (v107 < v100)
              v102 = v106;
            else
              v101 = v104;
          }
          while (v101);
          if (v102 != v103 && *v102 == v100)
            v108 = v102[1];
          else
LABEL_133:
            v108 = 0;
          v109 = *((_QWORD *)v154 + 3);
          v166 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v98, v108, v169, 8 * v170, 8, 1, 1);
          v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v109, (uint64_t **)&v166);
LABEL_146:
          v127 = (uint64_t *)((char *)v110 - 16);
          v128 = (_QWORD *)*((_QWORD *)v154 + 9);
          v129 = v128 + 8;
          v130 = (_QWORD *)v128[9];
          if (v130)
          {
            *v130 = *v129;
            if (*v129)
              *(_QWORD *)(*v129 + 8) = v128[9];
          }
          v128[11] = v127;
          v128[9] = v127;
          v131 = *v127;
          v128[8] = *v127;
          if (v131)
            *(_QWORD *)(v131 + 8) = v129;
          *v127 = (uint64_t)v129;
          goto LABEL_152;
        }
        v74 = v169;
        v75 = v170;
        v166 = v68;
        v76 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
        v77 = mlir::IntegerType::get(v76, 0x20u, 1u);
        v78 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v77, 0);
        v79 = v78;
        if (!v78)
          goto LABEL_120;
        v80 = *v78;
        v81 = mlir::TypeID::get<mlir::ShapedType>();
        v82 = *(unsigned int *)(v80 + 16);
        if (!(_DWORD)v82)
          goto LABEL_120;
        v83 = *(_QWORD **)(v80 + 8);
        v84 = &v83[2 * v82];
        do
        {
          v85 = v82 >> 1;
          v86 = &v83[2 * (v82 >> 1)];
          v88 = *v86;
          v87 = v86 + 2;
          v82 += ~(v82 >> 1);
          if (v88 < v81)
            v83 = v87;
          else
            v82 = v85;
        }
        while (v82);
        if (v83 != v84 && *v83 == v81)
          v89 = v83[1];
        else
LABEL_120:
          v89 = 0;
        v90 = (mlir::OpBuilder *)(a5 + 8);
        v91 = *((_QWORD *)v154 + 3);
        v166 = (mlir::GenericProgramPoint *)v168;
        v167 = 0x500000000;
        v141 = v91;
        if (v75 < 6)
        {
          if (!(_DWORD)v75)
          {
            v126 = 0;
            v94 = (uint64_t *)v168;
            v111 = v141;
LABEL_144:
            LODWORD(v167) = v126 + v75;
            v150 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v79, v89, v94, 4 * (v126 + v75), 4, 1, 1);
            v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v90, v111, &v150);
            if (v166 != (mlir::GenericProgramPoint *)v168)
              free(v166);
            goto LABEL_146;
          }
          v93 = 0;
          v94 = (uint64_t *)v168;
        }
        else
        {
          v92 = v89;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v166, v168, v75, 4);
          v89 = v92;
          v90 = (mlir::OpBuilder *)(a5 + 8);
          v93 = v167;
          v94 = (uint64_t *)v166;
        }
        v111 = v141;
        v112 = (int32x4_t *)((char *)v94 + 4 * v93);
        v113 = (v75 - 1) & 0x1FFFFFFFFFFFFFFFLL;
        if (v113 >= 7)
        {
          v116 = v113 + 1;
          v117 = (v113 + 1) & 0x3FFFFFFFFFFFFFF8;
          v114 = (int32x4_t *)((char *)v112 + 4 * v117);
          v115 = &v74->i8[8 * v117];
          v118 = v74 + 2;
          v119 = v112 + 1;
          v120 = v117;
          do
          {
            v122 = v118[-2];
            v121 = v118[-1];
            v124 = *v118;
            v123 = v118[1];
            v118 += 4;
            v119[-1] = vuzp1q_s32(v122, v121);
            *v119 = vuzp1q_s32(v124, v123);
            v119 += 2;
            v120 -= 8;
          }
          while (v120);
          if (v116 == v117)
            goto LABEL_143;
        }
        else
        {
          v114 = v112;
          v115 = (char *)v74;
        }
        do
        {
          v125 = *(_QWORD *)v115;
          v115 += 8;
          v114->i32[0] = v125;
          v114 = (int32x4_t *)((char *)v114 + 4);
        }
        while (v115 != (char *)v74 + 8 * v75);
LABEL_143:
        v126 = v167;
        goto LABEL_144;
      default:
        break;
    }
  }
  result = 0;
  if (a4)
  {
    switch(WeightsLayout)
    {
      case 2:
      case 9:
        if (a4 == 2)
          goto LABEL_9;
        goto LABEL_40;
      case 3:
      case 10:
        if (a4 == 1)
          goto LABEL_9;
LABEL_40:
        result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv2DOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  __int128 *v8;
  unint64_t v9;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  void *__dst;
  uint64_t v18;
  __int128 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(**(_QWORD **)(a1 + 8) + 24);
  v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    v7 = *v6;
    v8 = &v19;
    __dst = &v19;
    v18 = 0x500000000;
    v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || (_DWORD)v9 == 0)
    {
      v9 = 0;
      goto LABEL_20;
    }
    if (v9 < 6)
    {
      v14 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v19, *(unsigned int *)(v7 + 8), 4);
      v14 = *(_DWORD *)(v7 + 8);
      if (!v14)
      {
LABEL_19:
        LODWORD(v18) = v9;
        v8 = (__int128 *)__dst;
        goto LABEL_20;
      }
      v8 = (__int128 *)__dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v14);
    goto LABEL_19;
  }
  v11 = (unsigned int *)v6[2];
  v12 = *(_DWORD *)v6[1];
  v13 = *v11;
  if (v12 != (_DWORD)v13)
    __asm { BR              X10 }
  v8 = &v19;
  __dst = &v19;
  v9 = 5;
  HIDWORD(v18) = 5;
  if (v12 > 3)
  {
    v20 = 4;
    v19 = xmmword_181240EA8;
  }
  else
  {
    v19 = xmmword_181235170;
    v9 = 4;
  }
  LODWORD(v18) = v9;
LABEL_20:
  if (__dst != &v19)
    free(__dst);
  return v15;
}

uint64_t mlir::mps::`anonymous namespace'::permuteAttr(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  uint64_t v8;
  uint64_t RawStringData;
  char isSplat;
  unint64_t NumElements;
  int v12;
  void **v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t Value;
  uint64_t v25;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  _BYTE v30[80];
  void *v31;
  uint64_t v32;
  _QWORD v33[11];

  v33[10] = *MEMORY[0x1E0C80C00];
  v27 = a1;
  if (mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v27))
    return v27;
  if ((mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&v27, 8, 1, 0) & 1) != 0)
  {
    RawStringData = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&v27);
    isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v27);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v27);
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v27);
    v4 = NumElements;
    v31 = v33;
    v32 = 0xA00000000;
    if (NumElements < 0xB)
    {
      v12 = 0;
      if (!NumElements)
        goto LABEL_14;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v31, v33, NumElements, 8);
      v12 = v32;
    }
    v14 = v31;
    LOBYTE(v13) = isSplat ^ 1;
  }
  else
  {
    v12 = 0;
    RawStringData = 0;
    v13 = &v31;
    v14 = v33;
    v31 = v33;
    v32 = 0xA00000000;
  }
  v15 = 0;
  v16 = &v14[v12];
  do
  {
    if ((v13 & 1) != 0)
      v17 = v15;
    else
      v17 = 0;
    v16[v15++] = *(_QWORD *)(RawStringData + 8 * v17);
  }
  while (v4 != v15);
LABEL_14:
  LODWORD(v32) = v12 + v4;
  v18 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v27);
  v28 = v30;
  v29 = 0xA00000000;
  if (v18)
  {
    v19 = v18;
    if (v18 < 0xB)
    {
      v20 = 0;
      v21 = v18;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v28, v30, v18, 8);
      v20 = v29;
      v21 = v19 - v29;
      if (v19 == v29)
        goto LABEL_20;
    }
    bzero((char *)v28 + 8 * v20, 8 * v21);
LABEL_20:
    LODWORD(v29) = v19;
  }
  if (a3)
  {
    v22 = 0;
    do
    {
      v23 = *a2++;
      memcpy((char *)v28 + v22, (char *)v31 + 8 * v23 * a4, 8 * a4);
      v22 += 8 * a4;
      --a3;
    }
    while (a3);
  }
  Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v27);
  v8 = mlir::DenseElementsAttr::getFromRawBuffer(Value, v25, v28, 8 * v29, 8, 1, 0);
  if (v28 != v30)
    free(v28);
  if (v31 != v33)
    free(v31);
  return v8;
}

uint64_t mlir::mps::`anonymous namespace'::permuteValue(uint64_t a1, uint64_t a2, uint64_t a3, void *__s2, unint64_t a5)
{
  uint64_t v7;
  uint64_t v10;
  int32x4_t *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  int32x4_t *v15;
  unint64_t v16;
  int32x4_t v17;
  int32x4_t *v18;
  int32x4_t v19;
  int32x4_t v20;
  uint64_t v21;
  uint64_t v23[2];
  uint64_t v24;
  int32x4_t *v25;
  uint64_t v26;
  _BYTE v27[16];
  void *v28[2];
  _QWORD v29[2];

  v7 = a3;
  v29[1] = *MEMORY[0x1E0C80C00];
  v23[1] = a5;
  v24 = a3;
  v23[0] = (uint64_t)__s2;
  v25 = (int32x4_t *)v27;
  v26 = 0x400000000;
  if (!a5)
  {
    v11 = (int32x4_t *)v27;
    goto LABEL_16;
  }
  if (a5 < 5)
  {
    v10 = 0;
    v11 = (int32x4_t *)v27;
    v12 = a5;
    goto LABEL_7;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, a5, 4);
  v10 = v26;
  v11 = v25;
  v12 = a5 - v26;
  if (a5 != v26)
LABEL_7:
    bzero((char *)v11 + 4 * v10, 4 * v12);
  LODWORD(v26) = a5;
  if (!(_DWORD)a5)
    goto LABEL_17;
  v13 = (a5 - 1) & 0x3FFFFFFFFFFFFFFFLL;
  if (v13 < 7)
  {
    LODWORD(v14) = 0;
    v15 = v11;
    do
    {
LABEL_14:
      v15->i32[0] = v14;
      v15 = (int32x4_t *)((char *)v15 + 4);
      LODWORD(v14) = v14 + 1;
    }
    while (v15 != (int32x4_t *)((char *)v11 + 4 * a5));
    goto LABEL_15;
  }
  v16 = v13 + 1;
  v14 = (v13 + 1) & 0x7FFFFFFFFFFFFFF8;
  v15 = (int32x4_t *)((char *)v11 + 4 * v14);
  v17 = (int32x4_t)xmmword_181235170;
  v18 = v11 + 1;
  v19.i64[0] = 0x400000004;
  v19.i64[1] = 0x400000004;
  v20.i64[0] = 0x800000008;
  v20.i64[1] = 0x800000008;
  v21 = v14;
  do
  {
    v18[-1] = v17;
    *v18 = vaddq_s32(v17, v19);
    v17 = vaddq_s32(v17, v20);
    v18 += 2;
    v21 -= 8;
  }
  while (v21);
  if (v16 != v14)
    goto LABEL_14;
LABEL_15:
  if (a5 == v26)
  {
LABEL_16:
    if (!memcmp(v11, __s2, 4 * a5))
      goto LABEL_20;
  }
LABEL_17:
  v28[0] = v29;
  v28[1] = (void *)0x100000000;
  mlir::OpBuilder::createOrFold<mlir::mps::PermuteOp,mlir::Value &,llvm::ArrayRef<int> &>((mlir::Builder *)(a1 + 8), (uint64_t)v28, a2, &v24, v23);
  v7 = *(_QWORD *)v28[0];
  if (v28[0] != v29)
    free(v28[0]);
  v11 = v25;
LABEL_20:
  if (v11 != (int32x4_t *)v27)
    free(v11);
  return v7;
}

void mlir::OpBuilder::createOrFold<mlir::mps::PermuteOp,mlir::Value &,llvm::ArrayRef<int> &>(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  const mlir::OperationState *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  uint64_t v25[39];

  v25[38] = *MEMORY[0x1E0C80C00];
  v20 = a3;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.permute", (const unsigned __int8 *)0xB, Context);
  if (!v12)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.permute";
    v23[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a3, v11);
  mlir::mps::PermuteOp::build(a1, v25, *a4, *a5, a5[1]);
  v14 = (mlir::GenericProgramPoint *)mlir::Operation::create((mlir::Operation *)v25, v13);
  v15 = *((_QWORD *)a1 + 2);
  if (v15)
  {
    v16 = (uint64_t *)*((_QWORD *)a1 + 3);
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v15 + 32, (uint64_t)v14);
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
    v17 = *v16;
    *v18 = *v16;
    v18[1] = (uint64_t)v16;
    *(_QWORD *)(v17 + 8) = v18;
    *v16 = (uint64_t)v18;
    mlir::GenericProgramPoint::~GenericProgramPoint(v14);
  }
  if (mlir::OpBuilder::tryFold(a1, (uint64_t)v14, a2))
  {
    mlir::Operation::erase(v14);
  }
  else
  {
    v19 = *((_QWORD *)a1 + 1);
    if (v19)
      (*(void (**)(uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)v19 + 16))(v19, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v10;
  char v11;
  mlir::GenericProgramPoint *v12;
  mlir::GenericProgramPoint *v13;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  uint64_t v18[4];
  __int16 v19;
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v15 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
  v10 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dynamic_shape_cast", (const unsigned __int8 *)0x16, Context);
  if (!v11)
  {
    v19 = 1283;
    v18[2] = (uint64_t)"mps.dynamic_shape_cast";
    v18[3] = 22;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v17 = 259;
    llvm::operator+(v18, (uint64_t *)&v16, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v10);
  mlir::mps::DynamicShapeCastOp::build(a1, (uint64_t)v20, *a3, 0, *a5);
  v12 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v12 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DynamicShapeCastOp,void>::id)
    v13 = v12;
  else
    v13 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v13;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv2DDataGradientOp>>::convertLayout(uint64_t a1, _QWORD *a2, int a3, int a4, uint64_t a5)
{
  int StorageType;
  int WeightsLayout;
  uint64_t result;
  void *v11;
  BOOL v14;
  char v15;
  void **v16;
  _BOOL4 v17;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  __int128 *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t v36;
  mlir::MLIRContext *Context;
  uint64_t v38;
  mlir::MLIRContext *v39;
  uint64_t v40;
  uint64_t Strides;
  uint64_t v42;
  uint64_t InputAttributeNames;
  uint64_t v44;
  uint64_t Rewriter;
  uint64_t v46;
  mlir::GenericProgramPoint *v47;
  __int128 *v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  unint64_t v53;
  __int128 v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  mlir::GenericProgramPoint *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  int32x4_t *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  _QWORD *v83;
  _QWORD *v84;
  unint64_t v85;
  unint64_t *v86;
  _QWORD *v87;
  unint64_t v88;
  uint64_t v89;
  mlir::OpBuilder *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  _QWORD *v102;
  _QWORD *v103;
  unint64_t v104;
  unint64_t *v105;
  _QWORD *v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  mlir::GenericProgramPoint *v110;
  uint64_t v111;
  int32x4_t *v112;
  unint64_t v113;
  int32x4_t *v114;
  char *v115;
  unint64_t v116;
  uint64_t v117;
  int32x4_t *v118;
  int32x4_t *v119;
  uint64_t v120;
  int32x4_t v121;
  int32x4_t v122;
  int32x4_t v123;
  int32x4_t v124;
  uint64_t v125;
  int v126;
  uint64_t *v127;
  _QWORD *v128;
  _QWORD *v129;
  _QWORD *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  mlir::GenericProgramPoint *DefiningOp;
  uint64_t *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char v142;
  _QWORD v143[3];
  void **v144;
  unsigned int *v145;
  unsigned int *v146;
  unsigned int v147;
  unsigned int v148;
  _QWORD *v149;
  uint64_t *v150;
  uint64_t ElementTypeOrSelf;
  _QWORD v152[2];
  uint64_t **v153;
  mlir::GenericProgramPoint *v154;
  void *v155;
  _BYTE v156[24];
  int v157;
  void *__dst;
  uint64_t v159;
  __int128 v160;
  int v161;
  void *v162;
  unsigned int v163;
  int v164;
  __int128 v165;
  mlir::GenericProgramPoint *v166;
  uint64_t v167;
  _BYTE v168[24];
  int32x4_t *v169;
  uint64_t v170;
  _BYTE v171[40];
  uint64_t v172;

  v172 = *MEMORY[0x1E0C80C00];
  v149 = a2;
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v149);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 == 2)
          goto LABEL_9;
        break;
      case 1:
      case 8:
        if (a3 != 1)
          break;
LABEL_9:
        v11 = *(void **)(v149[6] + 16);
        v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
        v15 = v14;
        if (v14)
        {
          LODWORD(v16) = 0;
          v17 = 1;
        }
        else
        {
          v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
          LODWORD(v16) = !v17;
        }
        v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
        v22 = v21;
        v23 = v21;
        if (a3)
          __asm { BR              X10 }
        v24 = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v149);
        v148 = v24;
        if (a4)
          __asm { BR              X10 }
        v147 = v24;
        v142 = v15;
        if (v22 != v23)
          __asm { BR              X10 }
        v25 = &v165;
        v162 = &v165;
        v164 = 5;
        v165 = xmmword_181235170;
        while (2)
        {
          v163 = 4;
          v144 = &v162;
          v145 = &v148;
          v146 = &v147;
          v143[0] = a5;
          v143[1] = &v149;
          v143[2] = &v144;
          v26 = *(_QWORD *)(v149[9] + 24);
          v27 = v149[3];
          v169 = (int32x4_t *)v171;
          memcpy(v171, v25, 0x10uLL);
          v170 = 0x500000004;
          if (v169 != (int32x4_t *)v171)
            free(v169);
          v30 = (uint64_t *)v149[9];
          v31 = (uint64_t *)v30[1];
          if (v31)
          {
            *v31 = *v30;
            if (*v30)
              *(_QWORD *)(*v30 + 8) = v30[1];
          }
          v30[3] = (uint64_t)v28;
          v30[1] = (uint64_t)v28;
          v32 = *v28;
          *v30 = *v28;
          if (v32)
            *(_QWORD *)(v32 + 8) = v30;
          *v28 = (uint64_t)v30;
          v33 = (_QWORD *)v149[9];
          v34 = v33 + 4;
          v35 = (_QWORD *)v33[5];
          if (v35)
          {
            *v35 = *v34;
            if (*v34)
              *(_QWORD *)(*v34 + 8) = v33[5];
          }
          v33[7] = v29;
          v33[5] = v29;
          v36 = *v29;
          v33[4] = *v29;
          if (v36)
            *(_QWORD *)(v36 + 8) = v34;
          *v29 = (uint64_t)v34;
          Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v38 = mlir::mps::TensorDataLayoutAttr::get(Context, v23);
          mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v149, v38);
          v39 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v40 = mlir::mps::TensorDataLayoutAttr::get(v39, v147);
          mlir::mps::Conv2DDataGradientOp::setWeightsLayoutAttr((uint64_t *)&v149, v40);
          Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v149, v42);
          InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v149, v44);
          Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v149, v46);
          v47 = (mlir::GenericProgramPoint *)v149;
          if (v17)
          {
            v16 = v144;
            v48 = &v160;
            __dst = &v160;
            v159 = 0x500000000;
            if (v144 != &__dst)
            {
              v49 = *((_DWORD *)v144 + 2);
              if (!v49)
                goto LABEL_75;
              if (v49 >= 6)
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v160, *((unsigned int *)v144 + 2), 4);
                v52 = *((_DWORD *)v16 + 2);
                if (!v52)
                {
LABEL_74:
                  LODWORD(v159) = v49;
                  v48 = (__int128 *)__dst;
LABEL_75:
                  if (v23 == v22)
                    break;
LABEL_81:
                  switch(v22)
                  {
                    case 0u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x200000001;
                      v54 = xmmword_181240940;
                      goto LABEL_86;
                    case 1u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000003;
                      v54 = xmmword_181240950;
                      goto LABEL_86;
                    case 2u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000000;
                      v54 = xmmword_181240920;
                      goto LABEL_86;
                    case 3u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 1;
                      v54 = xmmword_181240930;
LABEL_86:
                      *(_OWORD *)v156 = v54;
                      v53 = 4;
                      goto LABEL_87;
                    default:
                      *((_DWORD *)v25 + 4) = 4;
                      *v25 = xmmword_181240EA8;
                      continue;
                  }
                }
                v48 = (__int128 *)__dst;
              }
              else
              {
                v52 = *((_DWORD *)v144 + 2);
              }
              memcpy(v48, *v16, 4 * v52);
              goto LABEL_74;
            }
            v49 = 0;
            if (v23 != v22)
              goto LABEL_81;
          }
          else
          {
            v50 = *v145;
            v51 = *v146;
            if (*v145 != (_DWORD)v51)
              __asm { BR              X10 }
            v48 = &v160;
            __dst = &v160;
            v49 = 5;
            HIDWORD(v159) = 5;
            if (v50 <= 3)
            {
              v160 = xmmword_181235170;
              v49 = 4;
            }
            else
            {
              v161 = 4;
              v160 = xmmword_181240EA8;
            }
            LODWORD(v159) = v49;
            v23 = v147;
            v22 = v148;
            if (v147 != v148)
              goto LABEL_81;
          }
          break;
        }
        v155 = &v156[8];
        v53 = 5;
        *(_DWORD *)&v156[4] = 5;
        if (v22 <= 3)
        {
          *(_OWORD *)&v156[8] = xmmword_181235170;
          v53 = 4;
        }
        else
        {
          v157 = 4;
          *(_OWORD *)&v156[8] = xmmword_181240EA8;
        }
        *(_DWORD *)v156 = v53;
LABEL_87:
        v154 = v47;
        v55 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v154);
        v153 = (uint64_t **)v55;
        v56 = (uint64_t *)(*(_QWORD *)(v55 + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v56)
          goto LABEL_96;
        v57 = *v56;
        v58 = mlir::TypeID::get<mlir::ShapedType>();
        v59 = *(unsigned int *)(v57 + 16);
        if (!(_DWORD)v59)
          goto LABEL_96;
        v60 = *(_QWORD **)(v57 + 8);
        v61 = &v60[2 * v59];
        do
        {
          v62 = v59 >> 1;
          v63 = &v60[2 * (v59 >> 1)];
          v65 = *v63;
          v64 = v63 + 2;
          v59 += ~(v59 >> 1);
          if (v65 < v58)
            v60 = v64;
          else
            v59 = v62;
        }
        while (v59);
        if (v60 != v61 && *v60 == v58)
          v66 = v60[1];
        else
LABEL_96:
          v66 = 0;
        v152[0] = v56;
        v152[1] = v66;
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
          goto LABEL_154;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152);
        v169 = (int32x4_t *)v171;
        v170 = 0x500000000;
        v68 = (mlir::GenericProgramPoint *)(int)v67;
        if ((unint64_t)(v67 << 32) >= 0x500000001)
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, (int)v67, 8);
        if (v49)
        {
          v69 = 4 * v49;
          do
          {
            v70 = *(unsigned int *)v48;
            v71 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152) + 8 * v70);
            v72 = v170;
            if (v170 >= (unint64_t)HIDWORD(v170))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, v170 + 1, 8);
              v72 = v170;
            }
            v169->i64[v72] = v71;
            v73 = v170 + 1;
            LODWORD(v170) = v170 + 1;
            v48 = (__int128 *)((char *)v48 + 4);
            v69 -= 4;
          }
          while (v69);
        }
        else
        {
          v73 = v170;
        }
        v166 = (mlir::GenericProgramPoint *)v152[0];
        *(_QWORD *)(v55 + 8) = *(_QWORD *)(v55 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v166, (uint64_t)v169, v73);
        if ((v142 & 1) != 0 || (*((_BYTE *)v154 + 46) & 0x80) == 0 || *((_DWORD *)v154 + 17) != 3)
        {
LABEL_152:
          if (v169 != (int32x4_t *)v171)
            free(v169);
LABEL_154:
          v132 = *((_QWORD *)v154 + 2);
          mlir::GenericProgramPoint::~GenericProgramPoint(v154);
          v134 = *(_QWORD *)(v133 + 8);
          *(_QWORD *)(a5 + 24) = v132;
          *(_QWORD *)(a5 + 32) = v134;
          if ((int32x4_t *)v55 != v169)
          {
            DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v169);
            if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
            {
              v136 = (uint64_t *)v169;
            }
            else
            {
              v137 = *((_QWORD *)DefiningOp + 2);
              mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
              v139 = *(_QWORD *)(v138 + 8);
              *(_QWORD *)(a5 + 24) = v137;
              *(_QWORD *)(a5 + 32) = v139;
              v140 = *((_QWORD *)v154 + 3);
              ElementTypeOrSelf = 0;
              LOBYTE(v150) = 1;
              v166 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v140, (uint64_t *)&v169, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v150);
              v136 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v166);
            }
            mlir::Value::replaceAllUsesExcept(&v153, v136, (uint64_t)DefiningOp);
          }
          if (v155 != &v156[8])
            free(v155);
          if (__dst != &v160)
            free(__dst);
          if (v162 != &v165)
            free(v162);
          return 1;
        }
        ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(_QWORD *)(*((_QWORD *)v154 + 9) + 88));
        if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
        {
          v166 = v68;
          v95 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
          v96 = mlir::IntegerType::get(v95, 0x40u, 1u);
          v97 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v96, 0);
          v98 = v97;
          if (!v97)
            goto LABEL_133;
          v99 = *v97;
          v100 = mlir::TypeID::get<mlir::ShapedType>();
          v101 = *(unsigned int *)(v99 + 16);
          if (!(_DWORD)v101)
            goto LABEL_133;
          v102 = *(_QWORD **)(v99 + 8);
          v103 = &v102[2 * v101];
          do
          {
            v104 = v101 >> 1;
            v105 = &v102[2 * (v101 >> 1)];
            v107 = *v105;
            v106 = v105 + 2;
            v101 += ~(v101 >> 1);
            if (v107 < v100)
              v102 = v106;
            else
              v101 = v104;
          }
          while (v101);
          if (v102 != v103 && *v102 == v100)
            v108 = v102[1];
          else
LABEL_133:
            v108 = 0;
          v109 = *((_QWORD *)v154 + 3);
          v166 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v98, v108, v169, 8 * v170, 8, 1, 1);
          v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v109, (uint64_t **)&v166);
LABEL_146:
          v127 = (uint64_t *)((char *)v110 - 16);
          v128 = (_QWORD *)*((_QWORD *)v154 + 9);
          v129 = v128 + 8;
          v130 = (_QWORD *)v128[9];
          if (v130)
          {
            *v130 = *v129;
            if (*v129)
              *(_QWORD *)(*v129 + 8) = v128[9];
          }
          v128[11] = v127;
          v128[9] = v127;
          v131 = *v127;
          v128[8] = *v127;
          if (v131)
            *(_QWORD *)(v131 + 8) = v129;
          *v127 = (uint64_t)v129;
          goto LABEL_152;
        }
        v74 = v169;
        v75 = v170;
        v166 = v68;
        v76 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
        v77 = mlir::IntegerType::get(v76, 0x20u, 1u);
        v78 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v77, 0);
        v79 = v78;
        if (!v78)
          goto LABEL_120;
        v80 = *v78;
        v81 = mlir::TypeID::get<mlir::ShapedType>();
        v82 = *(unsigned int *)(v80 + 16);
        if (!(_DWORD)v82)
          goto LABEL_120;
        v83 = *(_QWORD **)(v80 + 8);
        v84 = &v83[2 * v82];
        do
        {
          v85 = v82 >> 1;
          v86 = &v83[2 * (v82 >> 1)];
          v88 = *v86;
          v87 = v86 + 2;
          v82 += ~(v82 >> 1);
          if (v88 < v81)
            v83 = v87;
          else
            v82 = v85;
        }
        while (v82);
        if (v83 != v84 && *v83 == v81)
          v89 = v83[1];
        else
LABEL_120:
          v89 = 0;
        v90 = (mlir::OpBuilder *)(a5 + 8);
        v91 = *((_QWORD *)v154 + 3);
        v166 = (mlir::GenericProgramPoint *)v168;
        v167 = 0x500000000;
        v141 = v91;
        if (v75 < 6)
        {
          if (!(_DWORD)v75)
          {
            v126 = 0;
            v94 = (uint64_t *)v168;
            v111 = v141;
LABEL_144:
            LODWORD(v167) = v126 + v75;
            v150 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v79, v89, v94, 4 * (v126 + v75), 4, 1, 1);
            v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v90, v111, &v150);
            if (v166 != (mlir::GenericProgramPoint *)v168)
              free(v166);
            goto LABEL_146;
          }
          v93 = 0;
          v94 = (uint64_t *)v168;
        }
        else
        {
          v92 = v89;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v166, v168, v75, 4);
          v89 = v92;
          v90 = (mlir::OpBuilder *)(a5 + 8);
          v93 = v167;
          v94 = (uint64_t *)v166;
        }
        v111 = v141;
        v112 = (int32x4_t *)((char *)v94 + 4 * v93);
        v113 = (v75 - 1) & 0x1FFFFFFFFFFFFFFFLL;
        if (v113 >= 7)
        {
          v116 = v113 + 1;
          v117 = (v113 + 1) & 0x3FFFFFFFFFFFFFF8;
          v114 = (int32x4_t *)((char *)v112 + 4 * v117);
          v115 = &v74->i8[8 * v117];
          v118 = v74 + 2;
          v119 = v112 + 1;
          v120 = v117;
          do
          {
            v122 = v118[-2];
            v121 = v118[-1];
            v124 = *v118;
            v123 = v118[1];
            v118 += 4;
            v119[-1] = vuzp1q_s32(v122, v121);
            *v119 = vuzp1q_s32(v124, v123);
            v119 += 2;
            v120 -= 8;
          }
          while (v120);
          if (v116 == v117)
            goto LABEL_143;
        }
        else
        {
          v114 = v112;
          v115 = (char *)v74;
        }
        do
        {
          v125 = *(_QWORD *)v115;
          v115 += 8;
          v114->i32[0] = v125;
          v114 = (int32x4_t *)((char *)v114 + 4);
        }
        while (v115 != (char *)v74 + 8 * v75);
LABEL_143:
        v126 = v167;
        goto LABEL_144;
      default:
        break;
    }
  }
  result = 0;
  if (a4)
  {
    switch(WeightsLayout)
    {
      case 2:
      case 9:
        if (a4 == 2)
          goto LABEL_9;
        goto LABEL_40;
      case 3:
      case 10:
        if (a4 == 1)
          goto LABEL_9;
LABEL_40:
        result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv2DDataGradientOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  __int128 *v8;
  unint64_t v9;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  void *__dst;
  uint64_t v18;
  __int128 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(**(_QWORD **)(a1 + 8) + 24);
  v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    v7 = *v6;
    v8 = &v19;
    __dst = &v19;
    v18 = 0x500000000;
    v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || (_DWORD)v9 == 0)
    {
      v9 = 0;
      goto LABEL_20;
    }
    if (v9 < 6)
    {
      v14 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v19, *(unsigned int *)(v7 + 8), 4);
      v14 = *(_DWORD *)(v7 + 8);
      if (!v14)
      {
LABEL_19:
        LODWORD(v18) = v9;
        v8 = (__int128 *)__dst;
        goto LABEL_20;
      }
      v8 = (__int128 *)__dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v14);
    goto LABEL_19;
  }
  v11 = (unsigned int *)v6[2];
  v12 = *(_DWORD *)v6[1];
  v13 = *v11;
  if (v12 != (_DWORD)v13)
    __asm { BR              X10 }
  v8 = &v19;
  __dst = &v19;
  v9 = 5;
  HIDWORD(v18) = 5;
  if (v12 > 3)
  {
    v20 = 4;
    v19 = xmmword_181240EA8;
  }
  else
  {
    v19 = xmmword_181235170;
    v9 = 4;
  }
  LODWORD(v18) = v9;
LABEL_20:
  if (__dst != &v19)
    free(__dst);
  return v15;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv2DWeightsGradientOp>>::convertLayout(uint64_t a1, _QWORD *a2, int a3, int a4, uint64_t a5)
{
  int StorageType;
  int WeightsLayout;
  uint64_t result;
  void *v11;
  BOOL v14;
  char v15;
  void **v16;
  _BOOL4 v17;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  __int128 *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t v36;
  mlir::MLIRContext *Context;
  uint64_t v38;
  mlir::MLIRContext *v39;
  uint64_t v40;
  uint64_t Strides;
  uint64_t v42;
  uint64_t InputAttributeNames;
  uint64_t v44;
  uint64_t Rewriter;
  uint64_t v46;
  mlir::GenericProgramPoint *v47;
  __int128 *v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  unint64_t v53;
  __int128 v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  mlir::GenericProgramPoint *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  int32x4_t *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  _QWORD *v83;
  _QWORD *v84;
  unint64_t v85;
  unint64_t *v86;
  _QWORD *v87;
  unint64_t v88;
  uint64_t v89;
  mlir::OpBuilder *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  _QWORD *v102;
  _QWORD *v103;
  unint64_t v104;
  unint64_t *v105;
  _QWORD *v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  mlir::GenericProgramPoint *v110;
  uint64_t v111;
  int32x4_t *v112;
  unint64_t v113;
  int32x4_t *v114;
  char *v115;
  unint64_t v116;
  uint64_t v117;
  int32x4_t *v118;
  int32x4_t *v119;
  uint64_t v120;
  int32x4_t v121;
  int32x4_t v122;
  int32x4_t v123;
  int32x4_t v124;
  uint64_t v125;
  int v126;
  uint64_t *v127;
  _QWORD *v128;
  _QWORD *v129;
  _QWORD *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  mlir::GenericProgramPoint *DefiningOp;
  uint64_t *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char v142;
  _QWORD v143[3];
  void **v144;
  unsigned int *v145;
  unsigned int *v146;
  unsigned int v147;
  unsigned int v148;
  _QWORD *v149;
  uint64_t *v150;
  uint64_t ElementTypeOrSelf;
  _QWORD v152[2];
  uint64_t **v153;
  mlir::GenericProgramPoint *v154;
  void *v155;
  _BYTE v156[24];
  int v157;
  void *__dst;
  uint64_t v159;
  __int128 v160;
  int v161;
  void *v162;
  unsigned int v163;
  int v164;
  __int128 v165;
  mlir::GenericProgramPoint *v166;
  uint64_t v167;
  _BYTE v168[24];
  int32x4_t *v169;
  uint64_t v170;
  _BYTE v171[40];
  uint64_t v172;

  v172 = *MEMORY[0x1E0C80C00];
  v149 = a2;
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v149);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 == 2)
          goto LABEL_9;
        break;
      case 1:
      case 8:
        if (a3 != 1)
          break;
LABEL_9:
        v11 = *(void **)(v149[6] + 16);
        v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
        v15 = v14;
        if (v14)
        {
          LODWORD(v16) = 0;
          v17 = 1;
        }
        else
        {
          v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
          LODWORD(v16) = !v17;
        }
        v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
        v22 = v21;
        v23 = v21;
        if (a3)
          __asm { BR              X10 }
        v24 = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v149);
        v148 = v24;
        if (a4)
          __asm { BR              X10 }
        v147 = v24;
        v142 = v15;
        if (v22 != v23)
          __asm { BR              X10 }
        v25 = &v165;
        v162 = &v165;
        v164 = 5;
        v165 = xmmword_181235170;
        while (2)
        {
          v163 = 4;
          v144 = &v162;
          v145 = &v148;
          v146 = &v147;
          v143[0] = a5;
          v143[1] = &v149;
          v143[2] = &v144;
          v26 = *(_QWORD *)(v149[9] + 24);
          v27 = v149[3];
          v169 = (int32x4_t *)v171;
          memcpy(v171, v25, 0x10uLL);
          v170 = 0x500000004;
          if (v169 != (int32x4_t *)v171)
            free(v169);
          v30 = (uint64_t *)v149[9];
          v31 = (uint64_t *)v30[1];
          if (v31)
          {
            *v31 = *v30;
            if (*v30)
              *(_QWORD *)(*v30 + 8) = v30[1];
          }
          v30[3] = (uint64_t)v28;
          v30[1] = (uint64_t)v28;
          v32 = *v28;
          *v30 = *v28;
          if (v32)
            *(_QWORD *)(v32 + 8) = v30;
          *v28 = (uint64_t)v30;
          v33 = (_QWORD *)v149[9];
          v34 = v33 + 4;
          v35 = (_QWORD *)v33[5];
          if (v35)
          {
            *v35 = *v34;
            if (*v34)
              *(_QWORD *)(*v34 + 8) = v33[5];
          }
          v33[7] = v29;
          v33[5] = v29;
          v36 = *v29;
          v33[4] = *v29;
          if (v36)
            *(_QWORD *)(v36 + 8) = v34;
          *v29 = (uint64_t)v34;
          Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v38 = mlir::mps::TensorDataLayoutAttr::get(Context, v23);
          mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v149, v38);
          v39 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v40 = mlir::mps::TensorDataLayoutAttr::get(v39, v147);
          mlir::mps::Conv2DDataGradientOp::setWeightsLayoutAttr((uint64_t *)&v149, v40);
          Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v149, v42);
          InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v149, v44);
          Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v149, v46);
          v47 = (mlir::GenericProgramPoint *)v149;
          if (v17)
          {
            v16 = v144;
            v48 = &v160;
            __dst = &v160;
            v159 = 0x500000000;
            if (v144 != &__dst)
            {
              v49 = *((_DWORD *)v144 + 2);
              if (!v49)
                goto LABEL_75;
              if (v49 >= 6)
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v160, *((unsigned int *)v144 + 2), 4);
                v52 = *((_DWORD *)v16 + 2);
                if (!v52)
                {
LABEL_74:
                  LODWORD(v159) = v49;
                  v48 = (__int128 *)__dst;
LABEL_75:
                  if (v23 == v22)
                    break;
LABEL_81:
                  switch(v22)
                  {
                    case 0u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x200000001;
                      v54 = xmmword_181240940;
                      goto LABEL_86;
                    case 1u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000003;
                      v54 = xmmword_181240950;
                      goto LABEL_86;
                    case 2u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000000;
                      v54 = xmmword_181240920;
                      goto LABEL_86;
                    case 3u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 1;
                      v54 = xmmword_181240930;
LABEL_86:
                      *(_OWORD *)v156 = v54;
                      v53 = 4;
                      goto LABEL_87;
                    default:
                      *((_DWORD *)v25 + 4) = 4;
                      *v25 = xmmword_181240EA8;
                      continue;
                  }
                }
                v48 = (__int128 *)__dst;
              }
              else
              {
                v52 = *((_DWORD *)v144 + 2);
              }
              memcpy(v48, *v16, 4 * v52);
              goto LABEL_74;
            }
            v49 = 0;
            if (v23 != v22)
              goto LABEL_81;
          }
          else
          {
            v50 = *v145;
            v51 = *v146;
            if (*v145 != (_DWORD)v51)
              __asm { BR              X10 }
            v48 = &v160;
            __dst = &v160;
            v49 = 5;
            HIDWORD(v159) = 5;
            if (v50 <= 3)
            {
              v160 = xmmword_181235170;
              v49 = 4;
            }
            else
            {
              v161 = 4;
              v160 = xmmword_181240EA8;
            }
            LODWORD(v159) = v49;
            v23 = v147;
            v22 = v148;
            if (v147 != v148)
              goto LABEL_81;
          }
          break;
        }
        v155 = &v156[8];
        v53 = 5;
        *(_DWORD *)&v156[4] = 5;
        if (v22 <= 3)
        {
          *(_OWORD *)&v156[8] = xmmword_181235170;
          v53 = 4;
        }
        else
        {
          v157 = 4;
          *(_OWORD *)&v156[8] = xmmword_181240EA8;
        }
        *(_DWORD *)v156 = v53;
LABEL_87:
        v154 = v47;
        v55 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v154);
        v153 = (uint64_t **)v55;
        v56 = (uint64_t *)(*(_QWORD *)(v55 + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v56)
          goto LABEL_96;
        v57 = *v56;
        v58 = mlir::TypeID::get<mlir::ShapedType>();
        v59 = *(unsigned int *)(v57 + 16);
        if (!(_DWORD)v59)
          goto LABEL_96;
        v60 = *(_QWORD **)(v57 + 8);
        v61 = &v60[2 * v59];
        do
        {
          v62 = v59 >> 1;
          v63 = &v60[2 * (v59 >> 1)];
          v65 = *v63;
          v64 = v63 + 2;
          v59 += ~(v59 >> 1);
          if (v65 < v58)
            v60 = v64;
          else
            v59 = v62;
        }
        while (v59);
        if (v60 != v61 && *v60 == v58)
          v66 = v60[1];
        else
LABEL_96:
          v66 = 0;
        v152[0] = v56;
        v152[1] = v66;
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
          goto LABEL_154;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152);
        v169 = (int32x4_t *)v171;
        v170 = 0x500000000;
        v68 = (mlir::GenericProgramPoint *)(int)v67;
        if ((unint64_t)(v67 << 32) >= 0x500000001)
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, (int)v67, 8);
        if (v49)
        {
          v69 = 4 * v49;
          do
          {
            v70 = *(unsigned int *)v48;
            v71 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152) + 8 * v70);
            v72 = v170;
            if (v170 >= (unint64_t)HIDWORD(v170))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, v170 + 1, 8);
              v72 = v170;
            }
            v169->i64[v72] = v71;
            v73 = v170 + 1;
            LODWORD(v170) = v170 + 1;
            v48 = (__int128 *)((char *)v48 + 4);
            v69 -= 4;
          }
          while (v69);
        }
        else
        {
          v73 = v170;
        }
        v166 = (mlir::GenericProgramPoint *)v152[0];
        *(_QWORD *)(v55 + 8) = *(_QWORD *)(v55 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v166, (uint64_t)v169, v73);
        if ((v142 & 1) != 0 || (*((_BYTE *)v154 + 46) & 0x80) == 0 || *((_DWORD *)v154 + 17) != 3)
        {
LABEL_152:
          if (v169 != (int32x4_t *)v171)
            free(v169);
LABEL_154:
          v132 = *((_QWORD *)v154 + 2);
          mlir::GenericProgramPoint::~GenericProgramPoint(v154);
          v134 = *(_QWORD *)(v133 + 8);
          *(_QWORD *)(a5 + 24) = v132;
          *(_QWORD *)(a5 + 32) = v134;
          if ((int32x4_t *)v55 != v169)
          {
            DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v169);
            if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
            {
              v136 = (uint64_t *)v169;
            }
            else
            {
              v137 = *((_QWORD *)DefiningOp + 2);
              mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
              v139 = *(_QWORD *)(v138 + 8);
              *(_QWORD *)(a5 + 24) = v137;
              *(_QWORD *)(a5 + 32) = v139;
              v140 = *((_QWORD *)v154 + 3);
              ElementTypeOrSelf = 0;
              LOBYTE(v150) = 1;
              v166 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v140, (uint64_t *)&v169, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v150);
              v136 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v166);
            }
            mlir::Value::replaceAllUsesExcept(&v153, v136, (uint64_t)DefiningOp);
          }
          if (v155 != &v156[8])
            free(v155);
          if (__dst != &v160)
            free(__dst);
          if (v162 != &v165)
            free(v162);
          return 1;
        }
        ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(_QWORD *)(*((_QWORD *)v154 + 9) + 88));
        if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
        {
          v166 = v68;
          v95 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
          v96 = mlir::IntegerType::get(v95, 0x40u, 1u);
          v97 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v96, 0);
          v98 = v97;
          if (!v97)
            goto LABEL_133;
          v99 = *v97;
          v100 = mlir::TypeID::get<mlir::ShapedType>();
          v101 = *(unsigned int *)(v99 + 16);
          if (!(_DWORD)v101)
            goto LABEL_133;
          v102 = *(_QWORD **)(v99 + 8);
          v103 = &v102[2 * v101];
          do
          {
            v104 = v101 >> 1;
            v105 = &v102[2 * (v101 >> 1)];
            v107 = *v105;
            v106 = v105 + 2;
            v101 += ~(v101 >> 1);
            if (v107 < v100)
              v102 = v106;
            else
              v101 = v104;
          }
          while (v101);
          if (v102 != v103 && *v102 == v100)
            v108 = v102[1];
          else
LABEL_133:
            v108 = 0;
          v109 = *((_QWORD *)v154 + 3);
          v166 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v98, v108, v169, 8 * v170, 8, 1, 1);
          v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v109, (uint64_t **)&v166);
LABEL_146:
          v127 = (uint64_t *)((char *)v110 - 16);
          v128 = (_QWORD *)*((_QWORD *)v154 + 9);
          v129 = v128 + 8;
          v130 = (_QWORD *)v128[9];
          if (v130)
          {
            *v130 = *v129;
            if (*v129)
              *(_QWORD *)(*v129 + 8) = v128[9];
          }
          v128[11] = v127;
          v128[9] = v127;
          v131 = *v127;
          v128[8] = *v127;
          if (v131)
            *(_QWORD *)(v131 + 8) = v129;
          *v127 = (uint64_t)v129;
          goto LABEL_152;
        }
        v74 = v169;
        v75 = v170;
        v166 = v68;
        v76 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
        v77 = mlir::IntegerType::get(v76, 0x20u, 1u);
        v78 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v77, 0);
        v79 = v78;
        if (!v78)
          goto LABEL_120;
        v80 = *v78;
        v81 = mlir::TypeID::get<mlir::ShapedType>();
        v82 = *(unsigned int *)(v80 + 16);
        if (!(_DWORD)v82)
          goto LABEL_120;
        v83 = *(_QWORD **)(v80 + 8);
        v84 = &v83[2 * v82];
        do
        {
          v85 = v82 >> 1;
          v86 = &v83[2 * (v82 >> 1)];
          v88 = *v86;
          v87 = v86 + 2;
          v82 += ~(v82 >> 1);
          if (v88 < v81)
            v83 = v87;
          else
            v82 = v85;
        }
        while (v82);
        if (v83 != v84 && *v83 == v81)
          v89 = v83[1];
        else
LABEL_120:
          v89 = 0;
        v90 = (mlir::OpBuilder *)(a5 + 8);
        v91 = *((_QWORD *)v154 + 3);
        v166 = (mlir::GenericProgramPoint *)v168;
        v167 = 0x500000000;
        v141 = v91;
        if (v75 < 6)
        {
          if (!(_DWORD)v75)
          {
            v126 = 0;
            v94 = (uint64_t *)v168;
            v111 = v141;
LABEL_144:
            LODWORD(v167) = v126 + v75;
            v150 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v79, v89, v94, 4 * (v126 + v75), 4, 1, 1);
            v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v90, v111, &v150);
            if (v166 != (mlir::GenericProgramPoint *)v168)
              free(v166);
            goto LABEL_146;
          }
          v93 = 0;
          v94 = (uint64_t *)v168;
        }
        else
        {
          v92 = v89;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v166, v168, v75, 4);
          v89 = v92;
          v90 = (mlir::OpBuilder *)(a5 + 8);
          v93 = v167;
          v94 = (uint64_t *)v166;
        }
        v111 = v141;
        v112 = (int32x4_t *)((char *)v94 + 4 * v93);
        v113 = (v75 - 1) & 0x1FFFFFFFFFFFFFFFLL;
        if (v113 >= 7)
        {
          v116 = v113 + 1;
          v117 = (v113 + 1) & 0x3FFFFFFFFFFFFFF8;
          v114 = (int32x4_t *)((char *)v112 + 4 * v117);
          v115 = &v74->i8[8 * v117];
          v118 = v74 + 2;
          v119 = v112 + 1;
          v120 = v117;
          do
          {
            v122 = v118[-2];
            v121 = v118[-1];
            v124 = *v118;
            v123 = v118[1];
            v118 += 4;
            v119[-1] = vuzp1q_s32(v122, v121);
            *v119 = vuzp1q_s32(v124, v123);
            v119 += 2;
            v120 -= 8;
          }
          while (v120);
          if (v116 == v117)
            goto LABEL_143;
        }
        else
        {
          v114 = v112;
          v115 = (char *)v74;
        }
        do
        {
          v125 = *(_QWORD *)v115;
          v115 += 8;
          v114->i32[0] = v125;
          v114 = (int32x4_t *)((char *)v114 + 4);
        }
        while (v115 != (char *)v74 + 8 * v75);
LABEL_143:
        v126 = v167;
        goto LABEL_144;
      default:
        break;
    }
  }
  result = 0;
  if (a4)
  {
    switch(WeightsLayout)
    {
      case 2:
      case 9:
        if (a4 == 2)
          goto LABEL_9;
        goto LABEL_40;
      case 3:
      case 10:
        if (a4 == 1)
          goto LABEL_9;
LABEL_40:
        result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv2DWeightsGradientOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  __int128 *v8;
  unint64_t v9;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  void *__dst;
  uint64_t v18;
  __int128 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(**(_QWORD **)(a1 + 8) + 24);
  v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    v7 = *v6;
    v8 = &v19;
    __dst = &v19;
    v18 = 0x500000000;
    v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || (_DWORD)v9 == 0)
    {
      v9 = 0;
      goto LABEL_20;
    }
    if (v9 < 6)
    {
      v14 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v19, *(unsigned int *)(v7 + 8), 4);
      v14 = *(_DWORD *)(v7 + 8);
      if (!v14)
      {
LABEL_19:
        LODWORD(v18) = v9;
        v8 = (__int128 *)__dst;
        goto LABEL_20;
      }
      v8 = (__int128 *)__dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v14);
    goto LABEL_19;
  }
  v11 = (unsigned int *)v6[2];
  v12 = *(_DWORD *)v6[1];
  v13 = *v11;
  if (v12 != (_DWORD)v13)
    __asm { BR              X10 }
  v8 = &v19;
  __dst = &v19;
  v9 = 5;
  HIDWORD(v18) = 5;
  if (v12 > 3)
  {
    v20 = 4;
    v19 = xmmword_181240EA8;
  }
  else
  {
    v19 = xmmword_181235170;
    v9 = 4;
  }
  LODWORD(v18) = v9;
LABEL_20:
  if (__dst != &v19)
    free(__dst);
  return v15;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv3DOp>>::convertLayout(uint64_t a1, _QWORD *a2, int a3, int a4, uint64_t a5)
{
  int StorageType;
  int WeightsLayout;
  uint64_t result;
  void *v11;
  BOOL v14;
  char v15;
  void **v16;
  _BOOL4 v17;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  __int128 *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t v36;
  mlir::MLIRContext *Context;
  uint64_t v38;
  mlir::MLIRContext *v39;
  uint64_t v40;
  uint64_t Strides;
  uint64_t v42;
  uint64_t InputAttributeNames;
  uint64_t v44;
  uint64_t Rewriter;
  uint64_t v46;
  mlir::GenericProgramPoint *v47;
  __int128 *v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  unint64_t v53;
  __int128 v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  mlir::GenericProgramPoint *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  int32x4_t *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  _QWORD *v83;
  _QWORD *v84;
  unint64_t v85;
  unint64_t *v86;
  _QWORD *v87;
  unint64_t v88;
  uint64_t v89;
  mlir::OpBuilder *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  _QWORD *v102;
  _QWORD *v103;
  unint64_t v104;
  unint64_t *v105;
  _QWORD *v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  mlir::GenericProgramPoint *v110;
  uint64_t v111;
  int32x4_t *v112;
  unint64_t v113;
  int32x4_t *v114;
  char *v115;
  unint64_t v116;
  uint64_t v117;
  int32x4_t *v118;
  int32x4_t *v119;
  uint64_t v120;
  int32x4_t v121;
  int32x4_t v122;
  int32x4_t v123;
  int32x4_t v124;
  uint64_t v125;
  int v126;
  uint64_t *v127;
  _QWORD *v128;
  _QWORD *v129;
  _QWORD *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  mlir::GenericProgramPoint *DefiningOp;
  uint64_t *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char v142;
  _QWORD v143[3];
  void **v144;
  unsigned int *v145;
  unsigned int *v146;
  unsigned int v147;
  unsigned int v148;
  _QWORD *v149;
  uint64_t *v150;
  uint64_t ElementTypeOrSelf;
  _QWORD v152[2];
  uint64_t **v153;
  mlir::GenericProgramPoint *v154;
  void *v155;
  _BYTE v156[24];
  int v157;
  void *__dst;
  uint64_t v159;
  __int128 v160;
  int v161;
  void *v162;
  unsigned int v163;
  int v164;
  __int128 v165;
  mlir::GenericProgramPoint *v166;
  uint64_t v167;
  _BYTE v168[24];
  int32x4_t *v169;
  uint64_t v170;
  _BYTE v171[40];
  uint64_t v172;

  v172 = *MEMORY[0x1E0C80C00];
  v149 = a2;
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v149);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 == 2)
          goto LABEL_9;
        break;
      case 1:
      case 8:
        if (a3 != 1)
          break;
LABEL_9:
        v11 = *(void **)(v149[6] + 16);
        v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
        v15 = v14;
        if (v14)
        {
          LODWORD(v16) = 0;
          v17 = 1;
        }
        else
        {
          v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
          LODWORD(v16) = !v17;
        }
        v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
        v22 = v21;
        v23 = v21;
        if (a3)
          __asm { BR              X10 }
        v24 = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v149);
        v148 = v24;
        if (a4)
          __asm { BR              X10 }
        v147 = v24;
        v142 = v15;
        if (v22 != v23)
          __asm { BR              X10 }
        v25 = &v165;
        v162 = &v165;
        v164 = 5;
        v165 = xmmword_181235170;
        while (2)
        {
          v163 = 4;
          v144 = &v162;
          v145 = &v148;
          v146 = &v147;
          v143[0] = a5;
          v143[1] = &v149;
          v143[2] = &v144;
          v26 = *(_QWORD *)(v149[9] + 24);
          v27 = v149[3];
          v169 = (int32x4_t *)v171;
          memcpy(v171, v25, 0x10uLL);
          v170 = 0x500000004;
          if (v169 != (int32x4_t *)v171)
            free(v169);
          v30 = (uint64_t *)v149[9];
          v31 = (uint64_t *)v30[1];
          if (v31)
          {
            *v31 = *v30;
            if (*v30)
              *(_QWORD *)(*v30 + 8) = v30[1];
          }
          v30[3] = (uint64_t)v28;
          v30[1] = (uint64_t)v28;
          v32 = *v28;
          *v30 = *v28;
          if (v32)
            *(_QWORD *)(v32 + 8) = v30;
          *v28 = (uint64_t)v30;
          v33 = (_QWORD *)v149[9];
          v34 = v33 + 4;
          v35 = (_QWORD *)v33[5];
          if (v35)
          {
            *v35 = *v34;
            if (*v34)
              *(_QWORD *)(*v34 + 8) = v33[5];
          }
          v33[7] = v29;
          v33[5] = v29;
          v36 = *v29;
          v33[4] = *v29;
          if (v36)
            *(_QWORD *)(v36 + 8) = v34;
          *v29 = (uint64_t)v34;
          Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v38 = mlir::mps::TensorDataLayoutAttr::get(Context, v23);
          mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v149, v38);
          v39 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v40 = mlir::mps::TensorDataLayoutAttr::get(v39, v147);
          mlir::mps::Conv2DDataGradientOp::setWeightsLayoutAttr((uint64_t *)&v149, v40);
          Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v149, v42);
          InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v149, v44);
          Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v149, v46);
          v47 = (mlir::GenericProgramPoint *)v149;
          if (v17)
          {
            v16 = v144;
            v48 = &v160;
            __dst = &v160;
            v159 = 0x500000000;
            if (v144 != &__dst)
            {
              v49 = *((_DWORD *)v144 + 2);
              if (!v49)
                goto LABEL_75;
              if (v49 >= 6)
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v160, *((unsigned int *)v144 + 2), 4);
                v52 = *((_DWORD *)v16 + 2);
                if (!v52)
                {
LABEL_74:
                  LODWORD(v159) = v49;
                  v48 = (__int128 *)__dst;
LABEL_75:
                  if (v23 == v22)
                    break;
LABEL_81:
                  switch(v22)
                  {
                    case 0u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x200000001;
                      v54 = xmmword_181240940;
                      goto LABEL_86;
                    case 1u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000003;
                      v54 = xmmword_181240950;
                      goto LABEL_86;
                    case 2u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000000;
                      v54 = xmmword_181240920;
                      goto LABEL_86;
                    case 3u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 1;
                      v54 = xmmword_181240930;
LABEL_86:
                      *(_OWORD *)v156 = v54;
                      v53 = 4;
                      goto LABEL_87;
                    default:
                      *((_DWORD *)v25 + 4) = 4;
                      *v25 = xmmword_181240EA8;
                      continue;
                  }
                }
                v48 = (__int128 *)__dst;
              }
              else
              {
                v52 = *((_DWORD *)v144 + 2);
              }
              memcpy(v48, *v16, 4 * v52);
              goto LABEL_74;
            }
            v49 = 0;
            if (v23 != v22)
              goto LABEL_81;
          }
          else
          {
            v50 = *v145;
            v51 = *v146;
            if (*v145 != (_DWORD)v51)
              __asm { BR              X10 }
            v48 = &v160;
            __dst = &v160;
            v49 = 5;
            HIDWORD(v159) = 5;
            if (v50 <= 3)
            {
              v160 = xmmword_181235170;
              v49 = 4;
            }
            else
            {
              v161 = 4;
              v160 = xmmword_181240EA8;
            }
            LODWORD(v159) = v49;
            v23 = v147;
            v22 = v148;
            if (v147 != v148)
              goto LABEL_81;
          }
          break;
        }
        v155 = &v156[8];
        v53 = 5;
        *(_DWORD *)&v156[4] = 5;
        if (v22 <= 3)
        {
          *(_OWORD *)&v156[8] = xmmword_181235170;
          v53 = 4;
        }
        else
        {
          v157 = 4;
          *(_OWORD *)&v156[8] = xmmword_181240EA8;
        }
        *(_DWORD *)v156 = v53;
LABEL_87:
        v154 = v47;
        v55 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v154);
        v153 = (uint64_t **)v55;
        v56 = (uint64_t *)(*(_QWORD *)(v55 + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v56)
          goto LABEL_96;
        v57 = *v56;
        v58 = mlir::TypeID::get<mlir::ShapedType>();
        v59 = *(unsigned int *)(v57 + 16);
        if (!(_DWORD)v59)
          goto LABEL_96;
        v60 = *(_QWORD **)(v57 + 8);
        v61 = &v60[2 * v59];
        do
        {
          v62 = v59 >> 1;
          v63 = &v60[2 * (v59 >> 1)];
          v65 = *v63;
          v64 = v63 + 2;
          v59 += ~(v59 >> 1);
          if (v65 < v58)
            v60 = v64;
          else
            v59 = v62;
        }
        while (v59);
        if (v60 != v61 && *v60 == v58)
          v66 = v60[1];
        else
LABEL_96:
          v66 = 0;
        v152[0] = v56;
        v152[1] = v66;
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
          goto LABEL_154;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152);
        v169 = (int32x4_t *)v171;
        v170 = 0x500000000;
        v68 = (mlir::GenericProgramPoint *)(int)v67;
        if ((unint64_t)(v67 << 32) >= 0x500000001)
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, (int)v67, 8);
        if (v49)
        {
          v69 = 4 * v49;
          do
          {
            v70 = *(unsigned int *)v48;
            v71 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152) + 8 * v70);
            v72 = v170;
            if (v170 >= (unint64_t)HIDWORD(v170))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, v170 + 1, 8);
              v72 = v170;
            }
            v169->i64[v72] = v71;
            v73 = v170 + 1;
            LODWORD(v170) = v170 + 1;
            v48 = (__int128 *)((char *)v48 + 4);
            v69 -= 4;
          }
          while (v69);
        }
        else
        {
          v73 = v170;
        }
        v166 = (mlir::GenericProgramPoint *)v152[0];
        *(_QWORD *)(v55 + 8) = *(_QWORD *)(v55 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v166, (uint64_t)v169, v73);
        if ((v142 & 1) != 0 || (*((_BYTE *)v154 + 46) & 0x80) == 0 || *((_DWORD *)v154 + 17) != 3)
        {
LABEL_152:
          if (v169 != (int32x4_t *)v171)
            free(v169);
LABEL_154:
          v132 = *((_QWORD *)v154 + 2);
          mlir::GenericProgramPoint::~GenericProgramPoint(v154);
          v134 = *(_QWORD *)(v133 + 8);
          *(_QWORD *)(a5 + 24) = v132;
          *(_QWORD *)(a5 + 32) = v134;
          if ((int32x4_t *)v55 != v169)
          {
            DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v169);
            if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
            {
              v136 = (uint64_t *)v169;
            }
            else
            {
              v137 = *((_QWORD *)DefiningOp + 2);
              mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
              v139 = *(_QWORD *)(v138 + 8);
              *(_QWORD *)(a5 + 24) = v137;
              *(_QWORD *)(a5 + 32) = v139;
              v140 = *((_QWORD *)v154 + 3);
              ElementTypeOrSelf = 0;
              LOBYTE(v150) = 1;
              v166 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v140, (uint64_t *)&v169, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v150);
              v136 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v166);
            }
            mlir::Value::replaceAllUsesExcept(&v153, v136, (uint64_t)DefiningOp);
          }
          if (v155 != &v156[8])
            free(v155);
          if (__dst != &v160)
            free(__dst);
          if (v162 != &v165)
            free(v162);
          return 1;
        }
        ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(_QWORD *)(*((_QWORD *)v154 + 9) + 88));
        if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
        {
          v166 = v68;
          v95 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
          v96 = mlir::IntegerType::get(v95, 0x40u, 1u);
          v97 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v96, 0);
          v98 = v97;
          if (!v97)
            goto LABEL_133;
          v99 = *v97;
          v100 = mlir::TypeID::get<mlir::ShapedType>();
          v101 = *(unsigned int *)(v99 + 16);
          if (!(_DWORD)v101)
            goto LABEL_133;
          v102 = *(_QWORD **)(v99 + 8);
          v103 = &v102[2 * v101];
          do
          {
            v104 = v101 >> 1;
            v105 = &v102[2 * (v101 >> 1)];
            v107 = *v105;
            v106 = v105 + 2;
            v101 += ~(v101 >> 1);
            if (v107 < v100)
              v102 = v106;
            else
              v101 = v104;
          }
          while (v101);
          if (v102 != v103 && *v102 == v100)
            v108 = v102[1];
          else
LABEL_133:
            v108 = 0;
          v109 = *((_QWORD *)v154 + 3);
          v166 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v98, v108, v169, 8 * v170, 8, 1, 1);
          v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v109, (uint64_t **)&v166);
LABEL_146:
          v127 = (uint64_t *)((char *)v110 - 16);
          v128 = (_QWORD *)*((_QWORD *)v154 + 9);
          v129 = v128 + 8;
          v130 = (_QWORD *)v128[9];
          if (v130)
          {
            *v130 = *v129;
            if (*v129)
              *(_QWORD *)(*v129 + 8) = v128[9];
          }
          v128[11] = v127;
          v128[9] = v127;
          v131 = *v127;
          v128[8] = *v127;
          if (v131)
            *(_QWORD *)(v131 + 8) = v129;
          *v127 = (uint64_t)v129;
          goto LABEL_152;
        }
        v74 = v169;
        v75 = v170;
        v166 = v68;
        v76 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
        v77 = mlir::IntegerType::get(v76, 0x20u, 1u);
        v78 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v77, 0);
        v79 = v78;
        if (!v78)
          goto LABEL_120;
        v80 = *v78;
        v81 = mlir::TypeID::get<mlir::ShapedType>();
        v82 = *(unsigned int *)(v80 + 16);
        if (!(_DWORD)v82)
          goto LABEL_120;
        v83 = *(_QWORD **)(v80 + 8);
        v84 = &v83[2 * v82];
        do
        {
          v85 = v82 >> 1;
          v86 = &v83[2 * (v82 >> 1)];
          v88 = *v86;
          v87 = v86 + 2;
          v82 += ~(v82 >> 1);
          if (v88 < v81)
            v83 = v87;
          else
            v82 = v85;
        }
        while (v82);
        if (v83 != v84 && *v83 == v81)
          v89 = v83[1];
        else
LABEL_120:
          v89 = 0;
        v90 = (mlir::OpBuilder *)(a5 + 8);
        v91 = *((_QWORD *)v154 + 3);
        v166 = (mlir::GenericProgramPoint *)v168;
        v167 = 0x500000000;
        v141 = v91;
        if (v75 < 6)
        {
          if (!(_DWORD)v75)
          {
            v126 = 0;
            v94 = (uint64_t *)v168;
            v111 = v141;
LABEL_144:
            LODWORD(v167) = v126 + v75;
            v150 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v79, v89, v94, 4 * (v126 + v75), 4, 1, 1);
            v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v90, v111, &v150);
            if (v166 != (mlir::GenericProgramPoint *)v168)
              free(v166);
            goto LABEL_146;
          }
          v93 = 0;
          v94 = (uint64_t *)v168;
        }
        else
        {
          v92 = v89;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v166, v168, v75, 4);
          v89 = v92;
          v90 = (mlir::OpBuilder *)(a5 + 8);
          v93 = v167;
          v94 = (uint64_t *)v166;
        }
        v111 = v141;
        v112 = (int32x4_t *)((char *)v94 + 4 * v93);
        v113 = (v75 - 1) & 0x1FFFFFFFFFFFFFFFLL;
        if (v113 >= 7)
        {
          v116 = v113 + 1;
          v117 = (v113 + 1) & 0x3FFFFFFFFFFFFFF8;
          v114 = (int32x4_t *)((char *)v112 + 4 * v117);
          v115 = &v74->i8[8 * v117];
          v118 = v74 + 2;
          v119 = v112 + 1;
          v120 = v117;
          do
          {
            v122 = v118[-2];
            v121 = v118[-1];
            v124 = *v118;
            v123 = v118[1];
            v118 += 4;
            v119[-1] = vuzp1q_s32(v122, v121);
            *v119 = vuzp1q_s32(v124, v123);
            v119 += 2;
            v120 -= 8;
          }
          while (v120);
          if (v116 == v117)
            goto LABEL_143;
        }
        else
        {
          v114 = v112;
          v115 = (char *)v74;
        }
        do
        {
          v125 = *(_QWORD *)v115;
          v115 += 8;
          v114->i32[0] = v125;
          v114 = (int32x4_t *)((char *)v114 + 4);
        }
        while (v115 != (char *)v74 + 8 * v75);
LABEL_143:
        v126 = v167;
        goto LABEL_144;
      default:
        break;
    }
  }
  result = 0;
  if (a4)
  {
    switch(WeightsLayout)
    {
      case 2:
      case 9:
        if (a4 == 2)
          goto LABEL_9;
        goto LABEL_40;
      case 3:
      case 10:
        if (a4 == 1)
          goto LABEL_9;
LABEL_40:
        result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv3DOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  __int128 *v8;
  unint64_t v9;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  void *__dst;
  uint64_t v18;
  __int128 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(**(_QWORD **)(a1 + 8) + 24);
  v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    v7 = *v6;
    v8 = &v19;
    __dst = &v19;
    v18 = 0x500000000;
    v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || (_DWORD)v9 == 0)
    {
      v9 = 0;
      goto LABEL_20;
    }
    if (v9 < 6)
    {
      v14 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v19, *(unsigned int *)(v7 + 8), 4);
      v14 = *(_DWORD *)(v7 + 8);
      if (!v14)
      {
LABEL_19:
        LODWORD(v18) = v9;
        v8 = (__int128 *)__dst;
        goto LABEL_20;
      }
      v8 = (__int128 *)__dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v14);
    goto LABEL_19;
  }
  v11 = (unsigned int *)v6[2];
  v12 = *(_DWORD *)v6[1];
  v13 = *v11;
  if (v12 != (_DWORD)v13)
    __asm { BR              X10 }
  v8 = &v19;
  __dst = &v19;
  v9 = 5;
  HIDWORD(v18) = 5;
  if (v12 > 3)
  {
    v20 = 4;
    v19 = xmmword_181240EA8;
  }
  else
  {
    v19 = xmmword_181235170;
    v9 = 4;
  }
  LODWORD(v18) = v9;
LABEL_20:
  if (__dst != &v19)
    free(__dst);
  return v15;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv3DDataGradientOp>>::convertLayout(uint64_t a1, _QWORD *a2, int a3, int a4, uint64_t a5)
{
  int StorageType;
  int WeightsLayout;
  uint64_t result;
  void *v11;
  BOOL v14;
  char v15;
  void **v16;
  _BOOL4 v17;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  __int128 *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t v36;
  mlir::MLIRContext *Context;
  uint64_t v38;
  mlir::MLIRContext *v39;
  uint64_t v40;
  uint64_t Strides;
  uint64_t v42;
  uint64_t InputAttributeNames;
  uint64_t v44;
  uint64_t Rewriter;
  uint64_t v46;
  mlir::GenericProgramPoint *v47;
  __int128 *v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  unint64_t v53;
  __int128 v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  mlir::GenericProgramPoint *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  int32x4_t *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  _QWORD *v83;
  _QWORD *v84;
  unint64_t v85;
  unint64_t *v86;
  _QWORD *v87;
  unint64_t v88;
  uint64_t v89;
  mlir::OpBuilder *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  _QWORD *v102;
  _QWORD *v103;
  unint64_t v104;
  unint64_t *v105;
  _QWORD *v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  mlir::GenericProgramPoint *v110;
  uint64_t v111;
  int32x4_t *v112;
  unint64_t v113;
  int32x4_t *v114;
  char *v115;
  unint64_t v116;
  uint64_t v117;
  int32x4_t *v118;
  int32x4_t *v119;
  uint64_t v120;
  int32x4_t v121;
  int32x4_t v122;
  int32x4_t v123;
  int32x4_t v124;
  uint64_t v125;
  int v126;
  uint64_t *v127;
  _QWORD *v128;
  _QWORD *v129;
  _QWORD *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  mlir::GenericProgramPoint *DefiningOp;
  uint64_t *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char v142;
  _QWORD v143[3];
  void **v144;
  unsigned int *v145;
  unsigned int *v146;
  unsigned int v147;
  unsigned int v148;
  _QWORD *v149;
  uint64_t *v150;
  uint64_t ElementTypeOrSelf;
  _QWORD v152[2];
  uint64_t **v153;
  mlir::GenericProgramPoint *v154;
  void *v155;
  _BYTE v156[24];
  int v157;
  void *__dst;
  uint64_t v159;
  __int128 v160;
  int v161;
  void *v162;
  unsigned int v163;
  int v164;
  __int128 v165;
  mlir::GenericProgramPoint *v166;
  uint64_t v167;
  _BYTE v168[24];
  int32x4_t *v169;
  uint64_t v170;
  _BYTE v171[40];
  uint64_t v172;

  v172 = *MEMORY[0x1E0C80C00];
  v149 = a2;
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v149);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 == 2)
          goto LABEL_9;
        break;
      case 1:
      case 8:
        if (a3 != 1)
          break;
LABEL_9:
        v11 = *(void **)(v149[6] + 16);
        v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
        v15 = v14;
        if (v14)
        {
          LODWORD(v16) = 0;
          v17 = 1;
        }
        else
        {
          v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
          LODWORD(v16) = !v17;
        }
        v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
        v22 = v21;
        v23 = v21;
        if (a3)
          __asm { BR              X10 }
        v24 = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v149);
        v148 = v24;
        if (a4)
          __asm { BR              X10 }
        v147 = v24;
        v142 = v15;
        if (v22 != v23)
          __asm { BR              X10 }
        v25 = &v165;
        v162 = &v165;
        v164 = 5;
        v165 = xmmword_181235170;
        while (2)
        {
          v163 = 4;
          v144 = &v162;
          v145 = &v148;
          v146 = &v147;
          v143[0] = a5;
          v143[1] = &v149;
          v143[2] = &v144;
          v26 = *(_QWORD *)(v149[9] + 24);
          v27 = v149[3];
          v169 = (int32x4_t *)v171;
          memcpy(v171, v25, 0x10uLL);
          v170 = 0x500000004;
          if (v169 != (int32x4_t *)v171)
            free(v169);
          v30 = (uint64_t *)v149[9];
          v31 = (uint64_t *)v30[1];
          if (v31)
          {
            *v31 = *v30;
            if (*v30)
              *(_QWORD *)(*v30 + 8) = v30[1];
          }
          v30[3] = (uint64_t)v28;
          v30[1] = (uint64_t)v28;
          v32 = *v28;
          *v30 = *v28;
          if (v32)
            *(_QWORD *)(v32 + 8) = v30;
          *v28 = (uint64_t)v30;
          v33 = (_QWORD *)v149[9];
          v34 = v33 + 4;
          v35 = (_QWORD *)v33[5];
          if (v35)
          {
            *v35 = *v34;
            if (*v34)
              *(_QWORD *)(*v34 + 8) = v33[5];
          }
          v33[7] = v29;
          v33[5] = v29;
          v36 = *v29;
          v33[4] = *v29;
          if (v36)
            *(_QWORD *)(v36 + 8) = v34;
          *v29 = (uint64_t)v34;
          Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v38 = mlir::mps::TensorDataLayoutAttr::get(Context, v23);
          mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v149, v38);
          v39 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v40 = mlir::mps::TensorDataLayoutAttr::get(v39, v147);
          mlir::mps::Conv2DDataGradientOp::setWeightsLayoutAttr((uint64_t *)&v149, v40);
          Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v149, v42);
          InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v149, v44);
          Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v149, v46);
          v47 = (mlir::GenericProgramPoint *)v149;
          if (v17)
          {
            v16 = v144;
            v48 = &v160;
            __dst = &v160;
            v159 = 0x500000000;
            if (v144 != &__dst)
            {
              v49 = *((_DWORD *)v144 + 2);
              if (!v49)
                goto LABEL_75;
              if (v49 >= 6)
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v160, *((unsigned int *)v144 + 2), 4);
                v52 = *((_DWORD *)v16 + 2);
                if (!v52)
                {
LABEL_74:
                  LODWORD(v159) = v49;
                  v48 = (__int128 *)__dst;
LABEL_75:
                  if (v23 == v22)
                    break;
LABEL_81:
                  switch(v22)
                  {
                    case 0u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x200000001;
                      v54 = xmmword_181240940;
                      goto LABEL_86;
                    case 1u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000003;
                      v54 = xmmword_181240950;
                      goto LABEL_86;
                    case 2u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000000;
                      v54 = xmmword_181240920;
                      goto LABEL_86;
                    case 3u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 1;
                      v54 = xmmword_181240930;
LABEL_86:
                      *(_OWORD *)v156 = v54;
                      v53 = 4;
                      goto LABEL_87;
                    default:
                      *((_DWORD *)v25 + 4) = 4;
                      *v25 = xmmword_181240EA8;
                      continue;
                  }
                }
                v48 = (__int128 *)__dst;
              }
              else
              {
                v52 = *((_DWORD *)v144 + 2);
              }
              memcpy(v48, *v16, 4 * v52);
              goto LABEL_74;
            }
            v49 = 0;
            if (v23 != v22)
              goto LABEL_81;
          }
          else
          {
            v50 = *v145;
            v51 = *v146;
            if (*v145 != (_DWORD)v51)
              __asm { BR              X10 }
            v48 = &v160;
            __dst = &v160;
            v49 = 5;
            HIDWORD(v159) = 5;
            if (v50 <= 3)
            {
              v160 = xmmword_181235170;
              v49 = 4;
            }
            else
            {
              v161 = 4;
              v160 = xmmword_181240EA8;
            }
            LODWORD(v159) = v49;
            v23 = v147;
            v22 = v148;
            if (v147 != v148)
              goto LABEL_81;
          }
          break;
        }
        v155 = &v156[8];
        v53 = 5;
        *(_DWORD *)&v156[4] = 5;
        if (v22 <= 3)
        {
          *(_OWORD *)&v156[8] = xmmword_181235170;
          v53 = 4;
        }
        else
        {
          v157 = 4;
          *(_OWORD *)&v156[8] = xmmword_181240EA8;
        }
        *(_DWORD *)v156 = v53;
LABEL_87:
        v154 = v47;
        v55 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v154);
        v153 = (uint64_t **)v55;
        v56 = (uint64_t *)(*(_QWORD *)(v55 + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v56)
          goto LABEL_96;
        v57 = *v56;
        v58 = mlir::TypeID::get<mlir::ShapedType>();
        v59 = *(unsigned int *)(v57 + 16);
        if (!(_DWORD)v59)
          goto LABEL_96;
        v60 = *(_QWORD **)(v57 + 8);
        v61 = &v60[2 * v59];
        do
        {
          v62 = v59 >> 1;
          v63 = &v60[2 * (v59 >> 1)];
          v65 = *v63;
          v64 = v63 + 2;
          v59 += ~(v59 >> 1);
          if (v65 < v58)
            v60 = v64;
          else
            v59 = v62;
        }
        while (v59);
        if (v60 != v61 && *v60 == v58)
          v66 = v60[1];
        else
LABEL_96:
          v66 = 0;
        v152[0] = v56;
        v152[1] = v66;
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
          goto LABEL_154;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152);
        v169 = (int32x4_t *)v171;
        v170 = 0x500000000;
        v68 = (mlir::GenericProgramPoint *)(int)v67;
        if ((unint64_t)(v67 << 32) >= 0x500000001)
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, (int)v67, 8);
        if (v49)
        {
          v69 = 4 * v49;
          do
          {
            v70 = *(unsigned int *)v48;
            v71 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152) + 8 * v70);
            v72 = v170;
            if (v170 >= (unint64_t)HIDWORD(v170))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, v170 + 1, 8);
              v72 = v170;
            }
            v169->i64[v72] = v71;
            v73 = v170 + 1;
            LODWORD(v170) = v170 + 1;
            v48 = (__int128 *)((char *)v48 + 4);
            v69 -= 4;
          }
          while (v69);
        }
        else
        {
          v73 = v170;
        }
        v166 = (mlir::GenericProgramPoint *)v152[0];
        *(_QWORD *)(v55 + 8) = *(_QWORD *)(v55 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v166, (uint64_t)v169, v73);
        if ((v142 & 1) != 0 || (*((_BYTE *)v154 + 46) & 0x80) == 0 || *((_DWORD *)v154 + 17) != 3)
        {
LABEL_152:
          if (v169 != (int32x4_t *)v171)
            free(v169);
LABEL_154:
          v132 = *((_QWORD *)v154 + 2);
          mlir::GenericProgramPoint::~GenericProgramPoint(v154);
          v134 = *(_QWORD *)(v133 + 8);
          *(_QWORD *)(a5 + 24) = v132;
          *(_QWORD *)(a5 + 32) = v134;
          if ((int32x4_t *)v55 != v169)
          {
            DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v169);
            if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
            {
              v136 = (uint64_t *)v169;
            }
            else
            {
              v137 = *((_QWORD *)DefiningOp + 2);
              mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
              v139 = *(_QWORD *)(v138 + 8);
              *(_QWORD *)(a5 + 24) = v137;
              *(_QWORD *)(a5 + 32) = v139;
              v140 = *((_QWORD *)v154 + 3);
              ElementTypeOrSelf = 0;
              LOBYTE(v150) = 1;
              v166 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v140, (uint64_t *)&v169, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v150);
              v136 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v166);
            }
            mlir::Value::replaceAllUsesExcept(&v153, v136, (uint64_t)DefiningOp);
          }
          if (v155 != &v156[8])
            free(v155);
          if (__dst != &v160)
            free(__dst);
          if (v162 != &v165)
            free(v162);
          return 1;
        }
        ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(_QWORD *)(*((_QWORD *)v154 + 9) + 88));
        if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
        {
          v166 = v68;
          v95 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
          v96 = mlir::IntegerType::get(v95, 0x40u, 1u);
          v97 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v96, 0);
          v98 = v97;
          if (!v97)
            goto LABEL_133;
          v99 = *v97;
          v100 = mlir::TypeID::get<mlir::ShapedType>();
          v101 = *(unsigned int *)(v99 + 16);
          if (!(_DWORD)v101)
            goto LABEL_133;
          v102 = *(_QWORD **)(v99 + 8);
          v103 = &v102[2 * v101];
          do
          {
            v104 = v101 >> 1;
            v105 = &v102[2 * (v101 >> 1)];
            v107 = *v105;
            v106 = v105 + 2;
            v101 += ~(v101 >> 1);
            if (v107 < v100)
              v102 = v106;
            else
              v101 = v104;
          }
          while (v101);
          if (v102 != v103 && *v102 == v100)
            v108 = v102[1];
          else
LABEL_133:
            v108 = 0;
          v109 = *((_QWORD *)v154 + 3);
          v166 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v98, v108, v169, 8 * v170, 8, 1, 1);
          v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v109, (uint64_t **)&v166);
LABEL_146:
          v127 = (uint64_t *)((char *)v110 - 16);
          v128 = (_QWORD *)*((_QWORD *)v154 + 9);
          v129 = v128 + 8;
          v130 = (_QWORD *)v128[9];
          if (v130)
          {
            *v130 = *v129;
            if (*v129)
              *(_QWORD *)(*v129 + 8) = v128[9];
          }
          v128[11] = v127;
          v128[9] = v127;
          v131 = *v127;
          v128[8] = *v127;
          if (v131)
            *(_QWORD *)(v131 + 8) = v129;
          *v127 = (uint64_t)v129;
          goto LABEL_152;
        }
        v74 = v169;
        v75 = v170;
        v166 = v68;
        v76 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
        v77 = mlir::IntegerType::get(v76, 0x20u, 1u);
        v78 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v77, 0);
        v79 = v78;
        if (!v78)
          goto LABEL_120;
        v80 = *v78;
        v81 = mlir::TypeID::get<mlir::ShapedType>();
        v82 = *(unsigned int *)(v80 + 16);
        if (!(_DWORD)v82)
          goto LABEL_120;
        v83 = *(_QWORD **)(v80 + 8);
        v84 = &v83[2 * v82];
        do
        {
          v85 = v82 >> 1;
          v86 = &v83[2 * (v82 >> 1)];
          v88 = *v86;
          v87 = v86 + 2;
          v82 += ~(v82 >> 1);
          if (v88 < v81)
            v83 = v87;
          else
            v82 = v85;
        }
        while (v82);
        if (v83 != v84 && *v83 == v81)
          v89 = v83[1];
        else
LABEL_120:
          v89 = 0;
        v90 = (mlir::OpBuilder *)(a5 + 8);
        v91 = *((_QWORD *)v154 + 3);
        v166 = (mlir::GenericProgramPoint *)v168;
        v167 = 0x500000000;
        v141 = v91;
        if (v75 < 6)
        {
          if (!(_DWORD)v75)
          {
            v126 = 0;
            v94 = (uint64_t *)v168;
            v111 = v141;
LABEL_144:
            LODWORD(v167) = v126 + v75;
            v150 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v79, v89, v94, 4 * (v126 + v75), 4, 1, 1);
            v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v90, v111, &v150);
            if (v166 != (mlir::GenericProgramPoint *)v168)
              free(v166);
            goto LABEL_146;
          }
          v93 = 0;
          v94 = (uint64_t *)v168;
        }
        else
        {
          v92 = v89;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v166, v168, v75, 4);
          v89 = v92;
          v90 = (mlir::OpBuilder *)(a5 + 8);
          v93 = v167;
          v94 = (uint64_t *)v166;
        }
        v111 = v141;
        v112 = (int32x4_t *)((char *)v94 + 4 * v93);
        v113 = (v75 - 1) & 0x1FFFFFFFFFFFFFFFLL;
        if (v113 >= 7)
        {
          v116 = v113 + 1;
          v117 = (v113 + 1) & 0x3FFFFFFFFFFFFFF8;
          v114 = (int32x4_t *)((char *)v112 + 4 * v117);
          v115 = &v74->i8[8 * v117];
          v118 = v74 + 2;
          v119 = v112 + 1;
          v120 = v117;
          do
          {
            v122 = v118[-2];
            v121 = v118[-1];
            v124 = *v118;
            v123 = v118[1];
            v118 += 4;
            v119[-1] = vuzp1q_s32(v122, v121);
            *v119 = vuzp1q_s32(v124, v123);
            v119 += 2;
            v120 -= 8;
          }
          while (v120);
          if (v116 == v117)
            goto LABEL_143;
        }
        else
        {
          v114 = v112;
          v115 = (char *)v74;
        }
        do
        {
          v125 = *(_QWORD *)v115;
          v115 += 8;
          v114->i32[0] = v125;
          v114 = (int32x4_t *)((char *)v114 + 4);
        }
        while (v115 != (char *)v74 + 8 * v75);
LABEL_143:
        v126 = v167;
        goto LABEL_144;
      default:
        break;
    }
  }
  result = 0;
  if (a4)
  {
    switch(WeightsLayout)
    {
      case 2:
      case 9:
        if (a4 == 2)
          goto LABEL_9;
        goto LABEL_40;
      case 3:
      case 10:
        if (a4 == 1)
          goto LABEL_9;
LABEL_40:
        result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv3DDataGradientOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  __int128 *v8;
  unint64_t v9;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  void *__dst;
  uint64_t v18;
  __int128 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(**(_QWORD **)(a1 + 8) + 24);
  v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    v7 = *v6;
    v8 = &v19;
    __dst = &v19;
    v18 = 0x500000000;
    v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || (_DWORD)v9 == 0)
    {
      v9 = 0;
      goto LABEL_20;
    }
    if (v9 < 6)
    {
      v14 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v19, *(unsigned int *)(v7 + 8), 4);
      v14 = *(_DWORD *)(v7 + 8);
      if (!v14)
      {
LABEL_19:
        LODWORD(v18) = v9;
        v8 = (__int128 *)__dst;
        goto LABEL_20;
      }
      v8 = (__int128 *)__dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v14);
    goto LABEL_19;
  }
  v11 = (unsigned int *)v6[2];
  v12 = *(_DWORD *)v6[1];
  v13 = *v11;
  if (v12 != (_DWORD)v13)
    __asm { BR              X10 }
  v8 = &v19;
  __dst = &v19;
  v9 = 5;
  HIDWORD(v18) = 5;
  if (v12 > 3)
  {
    v20 = 4;
    v19 = xmmword_181240EA8;
  }
  else
  {
    v19 = xmmword_181235170;
    v9 = 4;
  }
  LODWORD(v18) = v9;
LABEL_20:
  if (__dst != &v19)
    free(__dst);
  return v15;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv3DWeightsGradientOp>>::convertLayout(uint64_t a1, _QWORD *a2, int a3, int a4, uint64_t a5)
{
  int StorageType;
  int WeightsLayout;
  uint64_t result;
  void *v11;
  BOOL v14;
  char v15;
  void **v16;
  _BOOL4 v17;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  __int128 *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t v36;
  mlir::MLIRContext *Context;
  uint64_t v38;
  mlir::MLIRContext *v39;
  uint64_t v40;
  uint64_t Strides;
  uint64_t v42;
  uint64_t InputAttributeNames;
  uint64_t v44;
  uint64_t Rewriter;
  uint64_t v46;
  mlir::GenericProgramPoint *v47;
  __int128 *v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  unint64_t v53;
  __int128 v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  mlir::GenericProgramPoint *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  int32x4_t *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  _QWORD *v83;
  _QWORD *v84;
  unint64_t v85;
  unint64_t *v86;
  _QWORD *v87;
  unint64_t v88;
  uint64_t v89;
  mlir::OpBuilder *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  _QWORD *v102;
  _QWORD *v103;
  unint64_t v104;
  unint64_t *v105;
  _QWORD *v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  mlir::GenericProgramPoint *v110;
  uint64_t v111;
  int32x4_t *v112;
  unint64_t v113;
  int32x4_t *v114;
  char *v115;
  unint64_t v116;
  uint64_t v117;
  int32x4_t *v118;
  int32x4_t *v119;
  uint64_t v120;
  int32x4_t v121;
  int32x4_t v122;
  int32x4_t v123;
  int32x4_t v124;
  uint64_t v125;
  int v126;
  uint64_t *v127;
  _QWORD *v128;
  _QWORD *v129;
  _QWORD *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  mlir::GenericProgramPoint *DefiningOp;
  uint64_t *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char v142;
  _QWORD v143[3];
  void **v144;
  unsigned int *v145;
  unsigned int *v146;
  unsigned int v147;
  unsigned int v148;
  _QWORD *v149;
  uint64_t *v150;
  uint64_t ElementTypeOrSelf;
  _QWORD v152[2];
  uint64_t **v153;
  mlir::GenericProgramPoint *v154;
  void *v155;
  _BYTE v156[24];
  int v157;
  void *__dst;
  uint64_t v159;
  __int128 v160;
  int v161;
  void *v162;
  unsigned int v163;
  int v164;
  __int128 v165;
  mlir::GenericProgramPoint *v166;
  uint64_t v167;
  _BYTE v168[24];
  int32x4_t *v169;
  uint64_t v170;
  _BYTE v171[40];
  uint64_t v172;

  v172 = *MEMORY[0x1E0C80C00];
  v149 = a2;
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
  WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v149);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 == 2)
          goto LABEL_9;
        break;
      case 1:
      case 8:
        if (a3 != 1)
          break;
LABEL_9:
        v11 = *(void **)(v149[6] + 16);
        v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
        v15 = v14;
        if (v14)
        {
          LODWORD(v16) = 0;
          v17 = 1;
        }
        else
        {
          v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
          LODWORD(v16) = !v17;
        }
        v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
        v22 = v21;
        v23 = v21;
        if (a3)
          __asm { BR              X10 }
        v24 = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v149);
        v148 = v24;
        if (a4)
          __asm { BR              X10 }
        v147 = v24;
        v142 = v15;
        if (v22 != v23)
          __asm { BR              X10 }
        v25 = &v165;
        v162 = &v165;
        v164 = 5;
        v165 = xmmword_181235170;
        while (2)
        {
          v163 = 4;
          v144 = &v162;
          v145 = &v148;
          v146 = &v147;
          v143[0] = a5;
          v143[1] = &v149;
          v143[2] = &v144;
          v26 = *(_QWORD *)(v149[9] + 24);
          v27 = v149[3];
          v169 = (int32x4_t *)v171;
          memcpy(v171, v25, 0x10uLL);
          v170 = 0x500000004;
          if (v169 != (int32x4_t *)v171)
            free(v169);
          v30 = (uint64_t *)v149[9];
          v31 = (uint64_t *)v30[1];
          if (v31)
          {
            *v31 = *v30;
            if (*v30)
              *(_QWORD *)(*v30 + 8) = v30[1];
          }
          v30[3] = (uint64_t)v28;
          v30[1] = (uint64_t)v28;
          v32 = *v28;
          *v30 = *v28;
          if (v32)
            *(_QWORD *)(v32 + 8) = v30;
          *v28 = (uint64_t)v30;
          v33 = (_QWORD *)v149[9];
          v34 = v33 + 4;
          v35 = (_QWORD *)v33[5];
          if (v35)
          {
            *v35 = *v34;
            if (*v34)
              *(_QWORD *)(*v34 + 8) = v33[5];
          }
          v33[7] = v29;
          v33[5] = v29;
          v36 = *v29;
          v33[4] = *v29;
          if (v36)
            *(_QWORD *)(v36 + 8) = v34;
          *v29 = (uint64_t)v34;
          Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v38 = mlir::mps::TensorDataLayoutAttr::get(Context, v23);
          mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v149, v38);
          v39 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v40 = mlir::mps::TensorDataLayoutAttr::get(v39, v147);
          mlir::mps::Conv2DDataGradientOp::setWeightsLayoutAttr((uint64_t *)&v149, v40);
          Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v149, v42);
          InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v149, v44);
          Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v149, v46);
          v47 = (mlir::GenericProgramPoint *)v149;
          if (v17)
          {
            v16 = v144;
            v48 = &v160;
            __dst = &v160;
            v159 = 0x500000000;
            if (v144 != &__dst)
            {
              v49 = *((_DWORD *)v144 + 2);
              if (!v49)
                goto LABEL_75;
              if (v49 >= 6)
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v160, *((unsigned int *)v144 + 2), 4);
                v52 = *((_DWORD *)v16 + 2);
                if (!v52)
                {
LABEL_74:
                  LODWORD(v159) = v49;
                  v48 = (__int128 *)__dst;
LABEL_75:
                  if (v23 == v22)
                    break;
LABEL_81:
                  switch(v22)
                  {
                    case 0u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x200000001;
                      v54 = xmmword_181240940;
                      goto LABEL_86;
                    case 1u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000003;
                      v54 = xmmword_181240950;
                      goto LABEL_86;
                    case 2u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000000;
                      v54 = xmmword_181240920;
                      goto LABEL_86;
                    case 3u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 1;
                      v54 = xmmword_181240930;
LABEL_86:
                      *(_OWORD *)v156 = v54;
                      v53 = 4;
                      goto LABEL_87;
                    default:
                      *((_DWORD *)v25 + 4) = 4;
                      *v25 = xmmword_181240EA8;
                      continue;
                  }
                }
                v48 = (__int128 *)__dst;
              }
              else
              {
                v52 = *((_DWORD *)v144 + 2);
              }
              memcpy(v48, *v16, 4 * v52);
              goto LABEL_74;
            }
            v49 = 0;
            if (v23 != v22)
              goto LABEL_81;
          }
          else
          {
            v50 = *v145;
            v51 = *v146;
            if (*v145 != (_DWORD)v51)
              __asm { BR              X10 }
            v48 = &v160;
            __dst = &v160;
            v49 = 5;
            HIDWORD(v159) = 5;
            if (v50 <= 3)
            {
              v160 = xmmword_181235170;
              v49 = 4;
            }
            else
            {
              v161 = 4;
              v160 = xmmword_181240EA8;
            }
            LODWORD(v159) = v49;
            v23 = v147;
            v22 = v148;
            if (v147 != v148)
              goto LABEL_81;
          }
          break;
        }
        v155 = &v156[8];
        v53 = 5;
        *(_DWORD *)&v156[4] = 5;
        if (v22 <= 3)
        {
          *(_OWORD *)&v156[8] = xmmword_181235170;
          v53 = 4;
        }
        else
        {
          v157 = 4;
          *(_OWORD *)&v156[8] = xmmword_181240EA8;
        }
        *(_DWORD *)v156 = v53;
LABEL_87:
        v154 = v47;
        v55 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v154);
        v153 = (uint64_t **)v55;
        v56 = (uint64_t *)(*(_QWORD *)(v55 + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v56)
          goto LABEL_96;
        v57 = *v56;
        v58 = mlir::TypeID::get<mlir::ShapedType>();
        v59 = *(unsigned int *)(v57 + 16);
        if (!(_DWORD)v59)
          goto LABEL_96;
        v60 = *(_QWORD **)(v57 + 8);
        v61 = &v60[2 * v59];
        do
        {
          v62 = v59 >> 1;
          v63 = &v60[2 * (v59 >> 1)];
          v65 = *v63;
          v64 = v63 + 2;
          v59 += ~(v59 >> 1);
          if (v65 < v58)
            v60 = v64;
          else
            v59 = v62;
        }
        while (v59);
        if (v60 != v61 && *v60 == v58)
          v66 = v60[1];
        else
LABEL_96:
          v66 = 0;
        v152[0] = v56;
        v152[1] = v66;
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
          goto LABEL_154;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152);
        v169 = (int32x4_t *)v171;
        v170 = 0x500000000;
        v68 = (mlir::GenericProgramPoint *)(int)v67;
        if ((unint64_t)(v67 << 32) >= 0x500000001)
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, (int)v67, 8);
        if (v49)
        {
          v69 = 4 * v49;
          do
          {
            v70 = *(unsigned int *)v48;
            v71 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152) + 8 * v70);
            v72 = v170;
            if (v170 >= (unint64_t)HIDWORD(v170))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, v170 + 1, 8);
              v72 = v170;
            }
            v169->i64[v72] = v71;
            v73 = v170 + 1;
            LODWORD(v170) = v170 + 1;
            v48 = (__int128 *)((char *)v48 + 4);
            v69 -= 4;
          }
          while (v69);
        }
        else
        {
          v73 = v170;
        }
        v166 = (mlir::GenericProgramPoint *)v152[0];
        *(_QWORD *)(v55 + 8) = *(_QWORD *)(v55 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v166, (uint64_t)v169, v73);
        if ((v142 & 1) != 0 || (*((_BYTE *)v154 + 46) & 0x80) == 0 || *((_DWORD *)v154 + 17) != 3)
        {
LABEL_152:
          if (v169 != (int32x4_t *)v171)
            free(v169);
LABEL_154:
          v132 = *((_QWORD *)v154 + 2);
          mlir::GenericProgramPoint::~GenericProgramPoint(v154);
          v134 = *(_QWORD *)(v133 + 8);
          *(_QWORD *)(a5 + 24) = v132;
          *(_QWORD *)(a5 + 32) = v134;
          if ((int32x4_t *)v55 != v169)
          {
            DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v169);
            if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
            {
              v136 = (uint64_t *)v169;
            }
            else
            {
              v137 = *((_QWORD *)DefiningOp + 2);
              mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
              v139 = *(_QWORD *)(v138 + 8);
              *(_QWORD *)(a5 + 24) = v137;
              *(_QWORD *)(a5 + 32) = v139;
              v140 = *((_QWORD *)v154 + 3);
              ElementTypeOrSelf = 0;
              LOBYTE(v150) = 1;
              v166 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v140, (uint64_t *)&v169, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v150);
              v136 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v166);
            }
            mlir::Value::replaceAllUsesExcept(&v153, v136, (uint64_t)DefiningOp);
          }
          if (v155 != &v156[8])
            free(v155);
          if (__dst != &v160)
            free(__dst);
          if (v162 != &v165)
            free(v162);
          return 1;
        }
        ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(_QWORD *)(*((_QWORD *)v154 + 9) + 88));
        if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
        {
          v166 = v68;
          v95 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
          v96 = mlir::IntegerType::get(v95, 0x40u, 1u);
          v97 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v96, 0);
          v98 = v97;
          if (!v97)
            goto LABEL_133;
          v99 = *v97;
          v100 = mlir::TypeID::get<mlir::ShapedType>();
          v101 = *(unsigned int *)(v99 + 16);
          if (!(_DWORD)v101)
            goto LABEL_133;
          v102 = *(_QWORD **)(v99 + 8);
          v103 = &v102[2 * v101];
          do
          {
            v104 = v101 >> 1;
            v105 = &v102[2 * (v101 >> 1)];
            v107 = *v105;
            v106 = v105 + 2;
            v101 += ~(v101 >> 1);
            if (v107 < v100)
              v102 = v106;
            else
              v101 = v104;
          }
          while (v101);
          if (v102 != v103 && *v102 == v100)
            v108 = v102[1];
          else
LABEL_133:
            v108 = 0;
          v109 = *((_QWORD *)v154 + 3);
          v166 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v98, v108, v169, 8 * v170, 8, 1, 1);
          v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v109, (uint64_t **)&v166);
LABEL_146:
          v127 = (uint64_t *)((char *)v110 - 16);
          v128 = (_QWORD *)*((_QWORD *)v154 + 9);
          v129 = v128 + 8;
          v130 = (_QWORD *)v128[9];
          if (v130)
          {
            *v130 = *v129;
            if (*v129)
              *(_QWORD *)(*v129 + 8) = v128[9];
          }
          v128[11] = v127;
          v128[9] = v127;
          v131 = *v127;
          v128[8] = *v127;
          if (v131)
            *(_QWORD *)(v131 + 8) = v129;
          *v127 = (uint64_t)v129;
          goto LABEL_152;
        }
        v74 = v169;
        v75 = v170;
        v166 = v68;
        v76 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
        v77 = mlir::IntegerType::get(v76, 0x20u, 1u);
        v78 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v77, 0);
        v79 = v78;
        if (!v78)
          goto LABEL_120;
        v80 = *v78;
        v81 = mlir::TypeID::get<mlir::ShapedType>();
        v82 = *(unsigned int *)(v80 + 16);
        if (!(_DWORD)v82)
          goto LABEL_120;
        v83 = *(_QWORD **)(v80 + 8);
        v84 = &v83[2 * v82];
        do
        {
          v85 = v82 >> 1;
          v86 = &v83[2 * (v82 >> 1)];
          v88 = *v86;
          v87 = v86 + 2;
          v82 += ~(v82 >> 1);
          if (v88 < v81)
            v83 = v87;
          else
            v82 = v85;
        }
        while (v82);
        if (v83 != v84 && *v83 == v81)
          v89 = v83[1];
        else
LABEL_120:
          v89 = 0;
        v90 = (mlir::OpBuilder *)(a5 + 8);
        v91 = *((_QWORD *)v154 + 3);
        v166 = (mlir::GenericProgramPoint *)v168;
        v167 = 0x500000000;
        v141 = v91;
        if (v75 < 6)
        {
          if (!(_DWORD)v75)
          {
            v126 = 0;
            v94 = (uint64_t *)v168;
            v111 = v141;
LABEL_144:
            LODWORD(v167) = v126 + v75;
            v150 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v79, v89, v94, 4 * (v126 + v75), 4, 1, 1);
            v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v90, v111, &v150);
            if (v166 != (mlir::GenericProgramPoint *)v168)
              free(v166);
            goto LABEL_146;
          }
          v93 = 0;
          v94 = (uint64_t *)v168;
        }
        else
        {
          v92 = v89;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v166, v168, v75, 4);
          v89 = v92;
          v90 = (mlir::OpBuilder *)(a5 + 8);
          v93 = v167;
          v94 = (uint64_t *)v166;
        }
        v111 = v141;
        v112 = (int32x4_t *)((char *)v94 + 4 * v93);
        v113 = (v75 - 1) & 0x1FFFFFFFFFFFFFFFLL;
        if (v113 >= 7)
        {
          v116 = v113 + 1;
          v117 = (v113 + 1) & 0x3FFFFFFFFFFFFFF8;
          v114 = (int32x4_t *)((char *)v112 + 4 * v117);
          v115 = &v74->i8[8 * v117];
          v118 = v74 + 2;
          v119 = v112 + 1;
          v120 = v117;
          do
          {
            v122 = v118[-2];
            v121 = v118[-1];
            v124 = *v118;
            v123 = v118[1];
            v118 += 4;
            v119[-1] = vuzp1q_s32(v122, v121);
            *v119 = vuzp1q_s32(v124, v123);
            v119 += 2;
            v120 -= 8;
          }
          while (v120);
          if (v116 == v117)
            goto LABEL_143;
        }
        else
        {
          v114 = v112;
          v115 = (char *)v74;
        }
        do
        {
          v125 = *(_QWORD *)v115;
          v115 += 8;
          v114->i32[0] = v125;
          v114 = (int32x4_t *)((char *)v114 + 4);
        }
        while (v115 != (char *)v74 + 8 * v75);
LABEL_143:
        v126 = v167;
        goto LABEL_144;
      default:
        break;
    }
  }
  result = 0;
  if (a4)
  {
    switch(WeightsLayout)
    {
      case 2:
      case 9:
        if (a4 == 2)
          goto LABEL_9;
        goto LABEL_40;
      case 3:
      case 10:
        if (a4 == 1)
          goto LABEL_9;
LABEL_40:
        result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::Conv3DWeightsGradientOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  __int128 *v8;
  unint64_t v9;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  void *__dst;
  uint64_t v18;
  __int128 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(**(_QWORD **)(a1 + 8) + 24);
  v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    v7 = *v6;
    v8 = &v19;
    __dst = &v19;
    v18 = 0x500000000;
    v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || (_DWORD)v9 == 0)
    {
      v9 = 0;
      goto LABEL_20;
    }
    if (v9 < 6)
    {
      v14 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v19, *(unsigned int *)(v7 + 8), 4);
      v14 = *(_DWORD *)(v7 + 8);
      if (!v14)
      {
LABEL_19:
        LODWORD(v18) = v9;
        v8 = (__int128 *)__dst;
        goto LABEL_20;
      }
      v8 = (__int128 *)__dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v14);
    goto LABEL_19;
  }
  v11 = (unsigned int *)v6[2];
  v12 = *(_DWORD *)v6[1];
  v13 = *v11;
  if (v12 != (_DWORD)v13)
    __asm { BR              X10 }
  v8 = &v19;
  __dst = &v19;
  v9 = 5;
  HIDWORD(v18) = 5;
  if (v12 > 3)
  {
    v20 = 4;
    v19 = xmmword_181240EA8;
  }
  else
  {
    v19 = xmmword_181235170;
    v9 = 4;
  }
  LODWORD(v18) = v9;
LABEL_20:
  if (__dst != &v19)
    free(__dst);
  return v15;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::DepthwiseConv2DOp>>::convertLayout(uint64_t a1, _QWORD *a2, int a3, int a4, uint64_t a5)
{
  int StorageType;
  int PaddingStyle;
  uint64_t result;
  void *v11;
  BOOL v14;
  char v15;
  void **v16;
  _BOOL4 v17;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  __int128 *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t v36;
  mlir::MLIRContext *Context;
  uint64_t v38;
  mlir::MLIRContext *v39;
  uint64_t v40;
  uint64_t Strides;
  uint64_t v42;
  uint64_t InputAttributeNames;
  uint64_t v44;
  uint64_t Rewriter;
  uint64_t v46;
  mlir::GenericProgramPoint *v47;
  __int128 *v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  unint64_t v53;
  __int128 v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  mlir::GenericProgramPoint *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  int32x4_t *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  _QWORD *v83;
  _QWORD *v84;
  unint64_t v85;
  unint64_t *v86;
  _QWORD *v87;
  unint64_t v88;
  uint64_t v89;
  mlir::OpBuilder *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  _QWORD *v102;
  _QWORD *v103;
  unint64_t v104;
  unint64_t *v105;
  _QWORD *v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  mlir::GenericProgramPoint *v110;
  uint64_t v111;
  int32x4_t *v112;
  unint64_t v113;
  int32x4_t *v114;
  char *v115;
  unint64_t v116;
  uint64_t v117;
  int32x4_t *v118;
  int32x4_t *v119;
  uint64_t v120;
  int32x4_t v121;
  int32x4_t v122;
  int32x4_t v123;
  int32x4_t v124;
  uint64_t v125;
  int v126;
  uint64_t *v127;
  _QWORD *v128;
  _QWORD *v129;
  _QWORD *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  mlir::GenericProgramPoint *DefiningOp;
  uint64_t *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char v142;
  _QWORD v143[3];
  void **v144;
  unsigned int *v145;
  unsigned int *v146;
  unsigned int v147;
  unsigned int v148;
  _QWORD *v149;
  uint64_t *v150;
  uint64_t ElementTypeOrSelf;
  _QWORD v152[2];
  uint64_t **v153;
  mlir::GenericProgramPoint *v154;
  void *v155;
  _BYTE v156[24];
  int v157;
  void *__dst;
  uint64_t v159;
  __int128 v160;
  int v161;
  void *v162;
  unsigned int v163;
  int v164;
  __int128 v165;
  mlir::GenericProgramPoint *v166;
  uint64_t v167;
  _BYTE v168[24];
  int32x4_t *v169;
  uint64_t v170;
  _BYTE v171[40];
  uint64_t v172;

  v172 = *MEMORY[0x1E0C80C00];
  v149 = a2;
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
  PaddingStyle = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v149);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 == 2)
          goto LABEL_9;
        break;
      case 1:
      case 8:
        if (a3 != 1)
          break;
LABEL_9:
        v11 = *(void **)(v149[6] + 16);
        v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
        v15 = v14;
        if (v14)
        {
          LODWORD(v16) = 0;
          v17 = 1;
        }
        else
        {
          v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
          LODWORD(v16) = !v17;
        }
        v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
        v22 = v21;
        v23 = v21;
        if (a3)
          __asm { BR              X10 }
        v24 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v149);
        v148 = v24;
        if (a4)
          __asm { BR              X10 }
        v147 = v24;
        v142 = v15;
        if (v22 != v23)
          __asm { BR              X10 }
        v25 = &v165;
        v162 = &v165;
        v164 = 5;
        v165 = xmmword_181235170;
        while (2)
        {
          v163 = 4;
          v144 = &v162;
          v145 = &v148;
          v146 = &v147;
          v143[0] = a5;
          v143[1] = &v149;
          v143[2] = &v144;
          v26 = *(_QWORD *)(v149[9] + 24);
          v27 = v149[3];
          v169 = (int32x4_t *)v171;
          memcpy(v171, v25, 0x10uLL);
          v170 = 0x500000004;
          if (v169 != (int32x4_t *)v171)
            free(v169);
          v30 = (uint64_t *)v149[9];
          v31 = (uint64_t *)v30[1];
          if (v31)
          {
            *v31 = *v30;
            if (*v30)
              *(_QWORD *)(*v30 + 8) = v30[1];
          }
          v30[3] = (uint64_t)v28;
          v30[1] = (uint64_t)v28;
          v32 = *v28;
          *v30 = *v28;
          if (v32)
            *(_QWORD *)(v32 + 8) = v30;
          *v28 = (uint64_t)v30;
          v33 = (_QWORD *)v149[9];
          v34 = v33 + 4;
          v35 = (_QWORD *)v33[5];
          if (v35)
          {
            *v35 = *v34;
            if (*v34)
              *(_QWORD *)(*v34 + 8) = v33[5];
          }
          v33[7] = v29;
          v33[5] = v29;
          v36 = *v29;
          v33[4] = *v29;
          if (v36)
            *(_QWORD *)(v36 + 8) = v34;
          *v29 = (uint64_t)v34;
          Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v38 = mlir::mps::TensorDataLayoutAttr::get(Context, v23);
          mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v149, v38);
          v39 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v40 = mlir::mps::TensorDataLayoutAttr::get(v39, v147);
          mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v149, v40);
          Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v149);
          mlir::mps::DepthwiseConv2DDataGradientOp::setStridesAttr((uint64_t *)&v149, v42);
          InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v149, v44);
          Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v149, v46);
          v47 = (mlir::GenericProgramPoint *)v149;
          if (v17)
          {
            v16 = v144;
            v48 = &v160;
            __dst = &v160;
            v159 = 0x500000000;
            if (v144 != &__dst)
            {
              v49 = *((_DWORD *)v144 + 2);
              if (!v49)
                goto LABEL_75;
              if (v49 >= 6)
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v160, *((unsigned int *)v144 + 2), 4);
                v52 = *((_DWORD *)v16 + 2);
                if (!v52)
                {
LABEL_74:
                  LODWORD(v159) = v49;
                  v48 = (__int128 *)__dst;
LABEL_75:
                  if (v23 == v22)
                    break;
LABEL_81:
                  switch(v22)
                  {
                    case 0u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x200000001;
                      v54 = xmmword_181240940;
                      goto LABEL_86;
                    case 1u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000003;
                      v54 = xmmword_181240950;
                      goto LABEL_86;
                    case 2u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000000;
                      v54 = xmmword_181240920;
                      goto LABEL_86;
                    case 3u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 1;
                      v54 = xmmword_181240930;
LABEL_86:
                      *(_OWORD *)v156 = v54;
                      v53 = 4;
                      goto LABEL_87;
                    default:
                      *((_DWORD *)v25 + 4) = 4;
                      *v25 = xmmword_181240EA8;
                      continue;
                  }
                }
                v48 = (__int128 *)__dst;
              }
              else
              {
                v52 = *((_DWORD *)v144 + 2);
              }
              memcpy(v48, *v16, 4 * v52);
              goto LABEL_74;
            }
            v49 = 0;
            if (v23 != v22)
              goto LABEL_81;
          }
          else
          {
            v50 = *v145;
            v51 = *v146;
            if (*v145 != (_DWORD)v51)
              __asm { BR              X10 }
            v48 = &v160;
            __dst = &v160;
            v49 = 5;
            HIDWORD(v159) = 5;
            if (v50 <= 3)
            {
              v160 = xmmword_181235170;
              v49 = 4;
            }
            else
            {
              v161 = 4;
              v160 = xmmword_181240EA8;
            }
            LODWORD(v159) = v49;
            v23 = v147;
            v22 = v148;
            if (v147 != v148)
              goto LABEL_81;
          }
          break;
        }
        v155 = &v156[8];
        v53 = 5;
        *(_DWORD *)&v156[4] = 5;
        if (v22 <= 3)
        {
          *(_OWORD *)&v156[8] = xmmword_181235170;
          v53 = 4;
        }
        else
        {
          v157 = 4;
          *(_OWORD *)&v156[8] = xmmword_181240EA8;
        }
        *(_DWORD *)v156 = v53;
LABEL_87:
        v154 = v47;
        v55 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v154);
        v153 = (uint64_t **)v55;
        v56 = (uint64_t *)(*(_QWORD *)(v55 + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v56)
          goto LABEL_96;
        v57 = *v56;
        v58 = mlir::TypeID::get<mlir::ShapedType>();
        v59 = *(unsigned int *)(v57 + 16);
        if (!(_DWORD)v59)
          goto LABEL_96;
        v60 = *(_QWORD **)(v57 + 8);
        v61 = &v60[2 * v59];
        do
        {
          v62 = v59 >> 1;
          v63 = &v60[2 * (v59 >> 1)];
          v65 = *v63;
          v64 = v63 + 2;
          v59 += ~(v59 >> 1);
          if (v65 < v58)
            v60 = v64;
          else
            v59 = v62;
        }
        while (v59);
        if (v60 != v61 && *v60 == v58)
          v66 = v60[1];
        else
LABEL_96:
          v66 = 0;
        v152[0] = v56;
        v152[1] = v66;
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
          goto LABEL_154;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152);
        v169 = (int32x4_t *)v171;
        v170 = 0x500000000;
        v68 = (mlir::GenericProgramPoint *)(int)v67;
        if ((unint64_t)(v67 << 32) >= 0x500000001)
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, (int)v67, 8);
        if (v49)
        {
          v69 = 4 * v49;
          do
          {
            v70 = *(unsigned int *)v48;
            v71 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152) + 8 * v70);
            v72 = v170;
            if (v170 >= (unint64_t)HIDWORD(v170))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, v170 + 1, 8);
              v72 = v170;
            }
            v169->i64[v72] = v71;
            v73 = v170 + 1;
            LODWORD(v170) = v170 + 1;
            v48 = (__int128 *)((char *)v48 + 4);
            v69 -= 4;
          }
          while (v69);
        }
        else
        {
          v73 = v170;
        }
        v166 = (mlir::GenericProgramPoint *)v152[0];
        *(_QWORD *)(v55 + 8) = *(_QWORD *)(v55 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v166, (uint64_t)v169, v73);
        if ((v142 & 1) != 0 || (*((_BYTE *)v154 + 46) & 0x80) == 0 || *((_DWORD *)v154 + 17) != 3)
        {
LABEL_152:
          if (v169 != (int32x4_t *)v171)
            free(v169);
LABEL_154:
          v132 = *((_QWORD *)v154 + 2);
          mlir::GenericProgramPoint::~GenericProgramPoint(v154);
          v134 = *(_QWORD *)(v133 + 8);
          *(_QWORD *)(a5 + 24) = v132;
          *(_QWORD *)(a5 + 32) = v134;
          if ((int32x4_t *)v55 != v169)
          {
            DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v169);
            if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
            {
              v136 = (uint64_t *)v169;
            }
            else
            {
              v137 = *((_QWORD *)DefiningOp + 2);
              mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
              v139 = *(_QWORD *)(v138 + 8);
              *(_QWORD *)(a5 + 24) = v137;
              *(_QWORD *)(a5 + 32) = v139;
              v140 = *((_QWORD *)v154 + 3);
              ElementTypeOrSelf = 0;
              LOBYTE(v150) = 1;
              v166 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v140, (uint64_t *)&v169, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v150);
              v136 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v166);
            }
            mlir::Value::replaceAllUsesExcept(&v153, v136, (uint64_t)DefiningOp);
          }
          if (v155 != &v156[8])
            free(v155);
          if (__dst != &v160)
            free(__dst);
          if (v162 != &v165)
            free(v162);
          return 1;
        }
        ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(_QWORD *)(*((_QWORD *)v154 + 9) + 88));
        if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
        {
          v166 = v68;
          v95 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
          v96 = mlir::IntegerType::get(v95, 0x40u, 1u);
          v97 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v96, 0);
          v98 = v97;
          if (!v97)
            goto LABEL_133;
          v99 = *v97;
          v100 = mlir::TypeID::get<mlir::ShapedType>();
          v101 = *(unsigned int *)(v99 + 16);
          if (!(_DWORD)v101)
            goto LABEL_133;
          v102 = *(_QWORD **)(v99 + 8);
          v103 = &v102[2 * v101];
          do
          {
            v104 = v101 >> 1;
            v105 = &v102[2 * (v101 >> 1)];
            v107 = *v105;
            v106 = v105 + 2;
            v101 += ~(v101 >> 1);
            if (v107 < v100)
              v102 = v106;
            else
              v101 = v104;
          }
          while (v101);
          if (v102 != v103 && *v102 == v100)
            v108 = v102[1];
          else
LABEL_133:
            v108 = 0;
          v109 = *((_QWORD *)v154 + 3);
          v166 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v98, v108, v169, 8 * v170, 8, 1, 1);
          v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v109, (uint64_t **)&v166);
LABEL_146:
          v127 = (uint64_t *)((char *)v110 - 16);
          v128 = (_QWORD *)*((_QWORD *)v154 + 9);
          v129 = v128 + 8;
          v130 = (_QWORD *)v128[9];
          if (v130)
          {
            *v130 = *v129;
            if (*v129)
              *(_QWORD *)(*v129 + 8) = v128[9];
          }
          v128[11] = v127;
          v128[9] = v127;
          v131 = *v127;
          v128[8] = *v127;
          if (v131)
            *(_QWORD *)(v131 + 8) = v129;
          *v127 = (uint64_t)v129;
          goto LABEL_152;
        }
        v74 = v169;
        v75 = v170;
        v166 = v68;
        v76 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
        v77 = mlir::IntegerType::get(v76, 0x20u, 1u);
        v78 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v77, 0);
        v79 = v78;
        if (!v78)
          goto LABEL_120;
        v80 = *v78;
        v81 = mlir::TypeID::get<mlir::ShapedType>();
        v82 = *(unsigned int *)(v80 + 16);
        if (!(_DWORD)v82)
          goto LABEL_120;
        v83 = *(_QWORD **)(v80 + 8);
        v84 = &v83[2 * v82];
        do
        {
          v85 = v82 >> 1;
          v86 = &v83[2 * (v82 >> 1)];
          v88 = *v86;
          v87 = v86 + 2;
          v82 += ~(v82 >> 1);
          if (v88 < v81)
            v83 = v87;
          else
            v82 = v85;
        }
        while (v82);
        if (v83 != v84 && *v83 == v81)
          v89 = v83[1];
        else
LABEL_120:
          v89 = 0;
        v90 = (mlir::OpBuilder *)(a5 + 8);
        v91 = *((_QWORD *)v154 + 3);
        v166 = (mlir::GenericProgramPoint *)v168;
        v167 = 0x500000000;
        v141 = v91;
        if (v75 < 6)
        {
          if (!(_DWORD)v75)
          {
            v126 = 0;
            v94 = (uint64_t *)v168;
            v111 = v141;
LABEL_144:
            LODWORD(v167) = v126 + v75;
            v150 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v79, v89, v94, 4 * (v126 + v75), 4, 1, 1);
            v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v90, v111, &v150);
            if (v166 != (mlir::GenericProgramPoint *)v168)
              free(v166);
            goto LABEL_146;
          }
          v93 = 0;
          v94 = (uint64_t *)v168;
        }
        else
        {
          v92 = v89;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v166, v168, v75, 4);
          v89 = v92;
          v90 = (mlir::OpBuilder *)(a5 + 8);
          v93 = v167;
          v94 = (uint64_t *)v166;
        }
        v111 = v141;
        v112 = (int32x4_t *)((char *)v94 + 4 * v93);
        v113 = (v75 - 1) & 0x1FFFFFFFFFFFFFFFLL;
        if (v113 >= 7)
        {
          v116 = v113 + 1;
          v117 = (v113 + 1) & 0x3FFFFFFFFFFFFFF8;
          v114 = (int32x4_t *)((char *)v112 + 4 * v117);
          v115 = &v74->i8[8 * v117];
          v118 = v74 + 2;
          v119 = v112 + 1;
          v120 = v117;
          do
          {
            v122 = v118[-2];
            v121 = v118[-1];
            v124 = *v118;
            v123 = v118[1];
            v118 += 4;
            v119[-1] = vuzp1q_s32(v122, v121);
            *v119 = vuzp1q_s32(v124, v123);
            v119 += 2;
            v120 -= 8;
          }
          while (v120);
          if (v116 == v117)
            goto LABEL_143;
        }
        else
        {
          v114 = v112;
          v115 = (char *)v74;
        }
        do
        {
          v125 = *(_QWORD *)v115;
          v115 += 8;
          v114->i32[0] = v125;
          v114 = (int32x4_t *)((char *)v114 + 4);
        }
        while (v115 != (char *)v74 + 8 * v75);
LABEL_143:
        v126 = v167;
        goto LABEL_144;
      default:
        break;
    }
  }
  result = 0;
  if (a4)
  {
    switch(PaddingStyle)
    {
      case 2:
      case 9:
        if (a4 == 2)
          goto LABEL_9;
        goto LABEL_40;
      case 3:
      case 10:
        if (a4 == 1)
          goto LABEL_9;
LABEL_40:
        result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::DepthwiseConv2DOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  __int128 *v8;
  unint64_t v9;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  void *__dst;
  uint64_t v18;
  __int128 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(**(_QWORD **)(a1 + 8) + 24);
  v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    v7 = *v6;
    v8 = &v19;
    __dst = &v19;
    v18 = 0x500000000;
    v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || (_DWORD)v9 == 0)
    {
      v9 = 0;
      goto LABEL_20;
    }
    if (v9 < 6)
    {
      v14 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v19, *(unsigned int *)(v7 + 8), 4);
      v14 = *(_DWORD *)(v7 + 8);
      if (!v14)
      {
LABEL_19:
        LODWORD(v18) = v9;
        v8 = (__int128 *)__dst;
        goto LABEL_20;
      }
      v8 = (__int128 *)__dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v14);
    goto LABEL_19;
  }
  v11 = (unsigned int *)v6[2];
  v12 = *(_DWORD *)v6[1];
  v13 = *v11;
  if (v12 != (_DWORD)v13)
    __asm { BR              X10 }
  v8 = &v19;
  __dst = &v19;
  v9 = 5;
  HIDWORD(v18) = 5;
  if (v12 > 3)
  {
    v20 = 4;
    v19 = xmmword_181240EA8;
  }
  else
  {
    v19 = xmmword_181235170;
    v9 = 4;
  }
  LODWORD(v18) = v9;
LABEL_20:
  if (__dst != &v19)
    free(__dst);
  return v15;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::DepthwiseConv2DDataGradientOp>>::convertLayout(uint64_t a1, _QWORD *a2, int a3, int a4, uint64_t a5)
{
  int StorageType;
  int PaddingStyle;
  uint64_t result;
  void *v11;
  BOOL v14;
  char v15;
  void **v16;
  _BOOL4 v17;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  __int128 *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t v36;
  mlir::MLIRContext *Context;
  uint64_t v38;
  mlir::MLIRContext *v39;
  uint64_t v40;
  uint64_t Strides;
  uint64_t v42;
  uint64_t InputAttributeNames;
  uint64_t v44;
  uint64_t Rewriter;
  uint64_t v46;
  mlir::GenericProgramPoint *v47;
  __int128 *v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  unint64_t v53;
  __int128 v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  mlir::GenericProgramPoint *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  int32x4_t *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  _QWORD *v83;
  _QWORD *v84;
  unint64_t v85;
  unint64_t *v86;
  _QWORD *v87;
  unint64_t v88;
  uint64_t v89;
  mlir::OpBuilder *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  _QWORD *v102;
  _QWORD *v103;
  unint64_t v104;
  unint64_t *v105;
  _QWORD *v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  mlir::GenericProgramPoint *v110;
  uint64_t v111;
  int32x4_t *v112;
  unint64_t v113;
  int32x4_t *v114;
  char *v115;
  unint64_t v116;
  uint64_t v117;
  int32x4_t *v118;
  int32x4_t *v119;
  uint64_t v120;
  int32x4_t v121;
  int32x4_t v122;
  int32x4_t v123;
  int32x4_t v124;
  uint64_t v125;
  int v126;
  uint64_t *v127;
  _QWORD *v128;
  _QWORD *v129;
  _QWORD *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  mlir::GenericProgramPoint *DefiningOp;
  uint64_t *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char v142;
  _QWORD v143[3];
  void **v144;
  unsigned int *v145;
  unsigned int *v146;
  unsigned int v147;
  unsigned int v148;
  _QWORD *v149;
  uint64_t *v150;
  uint64_t ElementTypeOrSelf;
  _QWORD v152[2];
  uint64_t **v153;
  mlir::GenericProgramPoint *v154;
  void *v155;
  _BYTE v156[24];
  int v157;
  void *__dst;
  uint64_t v159;
  __int128 v160;
  int v161;
  void *v162;
  unsigned int v163;
  int v164;
  __int128 v165;
  mlir::GenericProgramPoint *v166;
  uint64_t v167;
  _BYTE v168[24];
  int32x4_t *v169;
  uint64_t v170;
  _BYTE v171[40];
  uint64_t v172;

  v172 = *MEMORY[0x1E0C80C00];
  v149 = a2;
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
  PaddingStyle = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v149);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 == 2)
          goto LABEL_9;
        break;
      case 1:
      case 8:
        if (a3 != 1)
          break;
LABEL_9:
        v11 = *(void **)(v149[6] + 16);
        v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
        v15 = v14;
        if (v14)
        {
          LODWORD(v16) = 0;
          v17 = 1;
        }
        else
        {
          v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
          LODWORD(v16) = !v17;
        }
        v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
        v22 = v21;
        v23 = v21;
        if (a3)
          __asm { BR              X10 }
        v24 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v149);
        v148 = v24;
        if (a4)
          __asm { BR              X10 }
        v147 = v24;
        v142 = v15;
        if (v22 != v23)
          __asm { BR              X10 }
        v25 = &v165;
        v162 = &v165;
        v164 = 5;
        v165 = xmmword_181235170;
        while (2)
        {
          v163 = 4;
          v144 = &v162;
          v145 = &v148;
          v146 = &v147;
          v143[0] = a5;
          v143[1] = &v149;
          v143[2] = &v144;
          v26 = *(_QWORD *)(v149[9] + 24);
          v27 = v149[3];
          v169 = (int32x4_t *)v171;
          memcpy(v171, v25, 0x10uLL);
          v170 = 0x500000004;
          if (v169 != (int32x4_t *)v171)
            free(v169);
          v30 = (uint64_t *)v149[9];
          v31 = (uint64_t *)v30[1];
          if (v31)
          {
            *v31 = *v30;
            if (*v30)
              *(_QWORD *)(*v30 + 8) = v30[1];
          }
          v30[3] = (uint64_t)v28;
          v30[1] = (uint64_t)v28;
          v32 = *v28;
          *v30 = *v28;
          if (v32)
            *(_QWORD *)(v32 + 8) = v30;
          *v28 = (uint64_t)v30;
          v33 = (_QWORD *)v149[9];
          v34 = v33 + 4;
          v35 = (_QWORD *)v33[5];
          if (v35)
          {
            *v35 = *v34;
            if (*v34)
              *(_QWORD *)(*v34 + 8) = v33[5];
          }
          v33[7] = v29;
          v33[5] = v29;
          v36 = *v29;
          v33[4] = *v29;
          if (v36)
            *(_QWORD *)(v36 + 8) = v34;
          *v29 = (uint64_t)v34;
          Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v38 = mlir::mps::TensorDataLayoutAttr::get(Context, v23);
          mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v149, v38);
          v39 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v40 = mlir::mps::TensorDataLayoutAttr::get(v39, v147);
          mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v149, v40);
          Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v149);
          mlir::mps::DepthwiseConv2DDataGradientOp::setStridesAttr((uint64_t *)&v149, v42);
          InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v149, v44);
          Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v149, v46);
          v47 = (mlir::GenericProgramPoint *)v149;
          if (v17)
          {
            v16 = v144;
            v48 = &v160;
            __dst = &v160;
            v159 = 0x500000000;
            if (v144 != &__dst)
            {
              v49 = *((_DWORD *)v144 + 2);
              if (!v49)
                goto LABEL_75;
              if (v49 >= 6)
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v160, *((unsigned int *)v144 + 2), 4);
                v52 = *((_DWORD *)v16 + 2);
                if (!v52)
                {
LABEL_74:
                  LODWORD(v159) = v49;
                  v48 = (__int128 *)__dst;
LABEL_75:
                  if (v23 == v22)
                    break;
LABEL_81:
                  switch(v22)
                  {
                    case 0u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x200000001;
                      v54 = xmmword_181240940;
                      goto LABEL_86;
                    case 1u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000003;
                      v54 = xmmword_181240950;
                      goto LABEL_86;
                    case 2u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000000;
                      v54 = xmmword_181240920;
                      goto LABEL_86;
                    case 3u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 1;
                      v54 = xmmword_181240930;
LABEL_86:
                      *(_OWORD *)v156 = v54;
                      v53 = 4;
                      goto LABEL_87;
                    default:
                      *((_DWORD *)v25 + 4) = 4;
                      *v25 = xmmword_181240EA8;
                      continue;
                  }
                }
                v48 = (__int128 *)__dst;
              }
              else
              {
                v52 = *((_DWORD *)v144 + 2);
              }
              memcpy(v48, *v16, 4 * v52);
              goto LABEL_74;
            }
            v49 = 0;
            if (v23 != v22)
              goto LABEL_81;
          }
          else
          {
            v50 = *v145;
            v51 = *v146;
            if (*v145 != (_DWORD)v51)
              __asm { BR              X10 }
            v48 = &v160;
            __dst = &v160;
            v49 = 5;
            HIDWORD(v159) = 5;
            if (v50 <= 3)
            {
              v160 = xmmword_181235170;
              v49 = 4;
            }
            else
            {
              v161 = 4;
              v160 = xmmword_181240EA8;
            }
            LODWORD(v159) = v49;
            v23 = v147;
            v22 = v148;
            if (v147 != v148)
              goto LABEL_81;
          }
          break;
        }
        v155 = &v156[8];
        v53 = 5;
        *(_DWORD *)&v156[4] = 5;
        if (v22 <= 3)
        {
          *(_OWORD *)&v156[8] = xmmword_181235170;
          v53 = 4;
        }
        else
        {
          v157 = 4;
          *(_OWORD *)&v156[8] = xmmword_181240EA8;
        }
        *(_DWORD *)v156 = v53;
LABEL_87:
        v154 = v47;
        v55 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v154);
        v153 = (uint64_t **)v55;
        v56 = (uint64_t *)(*(_QWORD *)(v55 + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v56)
          goto LABEL_96;
        v57 = *v56;
        v58 = mlir::TypeID::get<mlir::ShapedType>();
        v59 = *(unsigned int *)(v57 + 16);
        if (!(_DWORD)v59)
          goto LABEL_96;
        v60 = *(_QWORD **)(v57 + 8);
        v61 = &v60[2 * v59];
        do
        {
          v62 = v59 >> 1;
          v63 = &v60[2 * (v59 >> 1)];
          v65 = *v63;
          v64 = v63 + 2;
          v59 += ~(v59 >> 1);
          if (v65 < v58)
            v60 = v64;
          else
            v59 = v62;
        }
        while (v59);
        if (v60 != v61 && *v60 == v58)
          v66 = v60[1];
        else
LABEL_96:
          v66 = 0;
        v152[0] = v56;
        v152[1] = v66;
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
          goto LABEL_154;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152);
        v169 = (int32x4_t *)v171;
        v170 = 0x500000000;
        v68 = (mlir::GenericProgramPoint *)(int)v67;
        if ((unint64_t)(v67 << 32) >= 0x500000001)
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, (int)v67, 8);
        if (v49)
        {
          v69 = 4 * v49;
          do
          {
            v70 = *(unsigned int *)v48;
            v71 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152) + 8 * v70);
            v72 = v170;
            if (v170 >= (unint64_t)HIDWORD(v170))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, v170 + 1, 8);
              v72 = v170;
            }
            v169->i64[v72] = v71;
            v73 = v170 + 1;
            LODWORD(v170) = v170 + 1;
            v48 = (__int128 *)((char *)v48 + 4);
            v69 -= 4;
          }
          while (v69);
        }
        else
        {
          v73 = v170;
        }
        v166 = (mlir::GenericProgramPoint *)v152[0];
        *(_QWORD *)(v55 + 8) = *(_QWORD *)(v55 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v166, (uint64_t)v169, v73);
        if ((v142 & 1) != 0 || (*((_BYTE *)v154 + 46) & 0x80) == 0 || *((_DWORD *)v154 + 17) != 3)
        {
LABEL_152:
          if (v169 != (int32x4_t *)v171)
            free(v169);
LABEL_154:
          v132 = *((_QWORD *)v154 + 2);
          mlir::GenericProgramPoint::~GenericProgramPoint(v154);
          v134 = *(_QWORD *)(v133 + 8);
          *(_QWORD *)(a5 + 24) = v132;
          *(_QWORD *)(a5 + 32) = v134;
          if ((int32x4_t *)v55 != v169)
          {
            DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v169);
            if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
            {
              v136 = (uint64_t *)v169;
            }
            else
            {
              v137 = *((_QWORD *)DefiningOp + 2);
              mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
              v139 = *(_QWORD *)(v138 + 8);
              *(_QWORD *)(a5 + 24) = v137;
              *(_QWORD *)(a5 + 32) = v139;
              v140 = *((_QWORD *)v154 + 3);
              ElementTypeOrSelf = 0;
              LOBYTE(v150) = 1;
              v166 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v140, (uint64_t *)&v169, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v150);
              v136 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v166);
            }
            mlir::Value::replaceAllUsesExcept(&v153, v136, (uint64_t)DefiningOp);
          }
          if (v155 != &v156[8])
            free(v155);
          if (__dst != &v160)
            free(__dst);
          if (v162 != &v165)
            free(v162);
          return 1;
        }
        ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(_QWORD *)(*((_QWORD *)v154 + 9) + 88));
        if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
        {
          v166 = v68;
          v95 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
          v96 = mlir::IntegerType::get(v95, 0x40u, 1u);
          v97 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v96, 0);
          v98 = v97;
          if (!v97)
            goto LABEL_133;
          v99 = *v97;
          v100 = mlir::TypeID::get<mlir::ShapedType>();
          v101 = *(unsigned int *)(v99 + 16);
          if (!(_DWORD)v101)
            goto LABEL_133;
          v102 = *(_QWORD **)(v99 + 8);
          v103 = &v102[2 * v101];
          do
          {
            v104 = v101 >> 1;
            v105 = &v102[2 * (v101 >> 1)];
            v107 = *v105;
            v106 = v105 + 2;
            v101 += ~(v101 >> 1);
            if (v107 < v100)
              v102 = v106;
            else
              v101 = v104;
          }
          while (v101);
          if (v102 != v103 && *v102 == v100)
            v108 = v102[1];
          else
LABEL_133:
            v108 = 0;
          v109 = *((_QWORD *)v154 + 3);
          v166 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v98, v108, v169, 8 * v170, 8, 1, 1);
          v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v109, (uint64_t **)&v166);
LABEL_146:
          v127 = (uint64_t *)((char *)v110 - 16);
          v128 = (_QWORD *)*((_QWORD *)v154 + 9);
          v129 = v128 + 8;
          v130 = (_QWORD *)v128[9];
          if (v130)
          {
            *v130 = *v129;
            if (*v129)
              *(_QWORD *)(*v129 + 8) = v128[9];
          }
          v128[11] = v127;
          v128[9] = v127;
          v131 = *v127;
          v128[8] = *v127;
          if (v131)
            *(_QWORD *)(v131 + 8) = v129;
          *v127 = (uint64_t)v129;
          goto LABEL_152;
        }
        v74 = v169;
        v75 = v170;
        v166 = v68;
        v76 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
        v77 = mlir::IntegerType::get(v76, 0x20u, 1u);
        v78 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v77, 0);
        v79 = v78;
        if (!v78)
          goto LABEL_120;
        v80 = *v78;
        v81 = mlir::TypeID::get<mlir::ShapedType>();
        v82 = *(unsigned int *)(v80 + 16);
        if (!(_DWORD)v82)
          goto LABEL_120;
        v83 = *(_QWORD **)(v80 + 8);
        v84 = &v83[2 * v82];
        do
        {
          v85 = v82 >> 1;
          v86 = &v83[2 * (v82 >> 1)];
          v88 = *v86;
          v87 = v86 + 2;
          v82 += ~(v82 >> 1);
          if (v88 < v81)
            v83 = v87;
          else
            v82 = v85;
        }
        while (v82);
        if (v83 != v84 && *v83 == v81)
          v89 = v83[1];
        else
LABEL_120:
          v89 = 0;
        v90 = (mlir::OpBuilder *)(a5 + 8);
        v91 = *((_QWORD *)v154 + 3);
        v166 = (mlir::GenericProgramPoint *)v168;
        v167 = 0x500000000;
        v141 = v91;
        if (v75 < 6)
        {
          if (!(_DWORD)v75)
          {
            v126 = 0;
            v94 = (uint64_t *)v168;
            v111 = v141;
LABEL_144:
            LODWORD(v167) = v126 + v75;
            v150 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v79, v89, v94, 4 * (v126 + v75), 4, 1, 1);
            v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v90, v111, &v150);
            if (v166 != (mlir::GenericProgramPoint *)v168)
              free(v166);
            goto LABEL_146;
          }
          v93 = 0;
          v94 = (uint64_t *)v168;
        }
        else
        {
          v92 = v89;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v166, v168, v75, 4);
          v89 = v92;
          v90 = (mlir::OpBuilder *)(a5 + 8);
          v93 = v167;
          v94 = (uint64_t *)v166;
        }
        v111 = v141;
        v112 = (int32x4_t *)((char *)v94 + 4 * v93);
        v113 = (v75 - 1) & 0x1FFFFFFFFFFFFFFFLL;
        if (v113 >= 7)
        {
          v116 = v113 + 1;
          v117 = (v113 + 1) & 0x3FFFFFFFFFFFFFF8;
          v114 = (int32x4_t *)((char *)v112 + 4 * v117);
          v115 = &v74->i8[8 * v117];
          v118 = v74 + 2;
          v119 = v112 + 1;
          v120 = v117;
          do
          {
            v122 = v118[-2];
            v121 = v118[-1];
            v124 = *v118;
            v123 = v118[1];
            v118 += 4;
            v119[-1] = vuzp1q_s32(v122, v121);
            *v119 = vuzp1q_s32(v124, v123);
            v119 += 2;
            v120 -= 8;
          }
          while (v120);
          if (v116 == v117)
            goto LABEL_143;
        }
        else
        {
          v114 = v112;
          v115 = (char *)v74;
        }
        do
        {
          v125 = *(_QWORD *)v115;
          v115 += 8;
          v114->i32[0] = v125;
          v114 = (int32x4_t *)((char *)v114 + 4);
        }
        while (v115 != (char *)v74 + 8 * v75);
LABEL_143:
        v126 = v167;
        goto LABEL_144;
      default:
        break;
    }
  }
  result = 0;
  if (a4)
  {
    switch(PaddingStyle)
    {
      case 2:
      case 9:
        if (a4 == 2)
          goto LABEL_9;
        goto LABEL_40;
      case 3:
      case 10:
        if (a4 == 1)
          goto LABEL_9;
LABEL_40:
        result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::DepthwiseConv2DDataGradientOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  __int128 *v8;
  unint64_t v9;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  void *__dst;
  uint64_t v18;
  __int128 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(**(_QWORD **)(a1 + 8) + 24);
  v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    v7 = *v6;
    v8 = &v19;
    __dst = &v19;
    v18 = 0x500000000;
    v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || (_DWORD)v9 == 0)
    {
      v9 = 0;
      goto LABEL_20;
    }
    if (v9 < 6)
    {
      v14 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v19, *(unsigned int *)(v7 + 8), 4);
      v14 = *(_DWORD *)(v7 + 8);
      if (!v14)
      {
LABEL_19:
        LODWORD(v18) = v9;
        v8 = (__int128 *)__dst;
        goto LABEL_20;
      }
      v8 = (__int128 *)__dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v14);
    goto LABEL_19;
  }
  v11 = (unsigned int *)v6[2];
  v12 = *(_DWORD *)v6[1];
  v13 = *v11;
  if (v12 != (_DWORD)v13)
    __asm { BR              X10 }
  v8 = &v19;
  __dst = &v19;
  v9 = 5;
  HIDWORD(v18) = 5;
  if (v12 > 3)
  {
    v20 = 4;
    v19 = xmmword_181240EA8;
  }
  else
  {
    v19 = xmmword_181235170;
    v9 = 4;
  }
  LODWORD(v18) = v9;
LABEL_20:
  if (__dst != &v19)
    free(__dst);
  return v15;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::DepthwiseConv2DWeightsGradientOp>>::convertLayout(uint64_t a1, _QWORD *a2, int a3, int a4, uint64_t a5)
{
  int StorageType;
  int PaddingStyle;
  uint64_t result;
  void *v11;
  BOOL v14;
  char v15;
  void **v16;
  _BOOL4 v17;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  __int128 *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t v36;
  mlir::MLIRContext *Context;
  uint64_t v38;
  mlir::MLIRContext *v39;
  uint64_t v40;
  uint64_t Strides;
  uint64_t v42;
  uint64_t InputAttributeNames;
  uint64_t v44;
  uint64_t Rewriter;
  uint64_t v46;
  mlir::GenericProgramPoint *v47;
  __int128 *v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  unint64_t v53;
  __int128 v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  unint64_t v62;
  unint64_t *v63;
  _QWORD *v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  mlir::GenericProgramPoint *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  int32x4_t *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  _QWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  _QWORD *v83;
  _QWORD *v84;
  unint64_t v85;
  unint64_t *v86;
  _QWORD *v87;
  unint64_t v88;
  uint64_t v89;
  mlir::OpBuilder *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  uint64_t v99;
  unint64_t v100;
  unint64_t v101;
  _QWORD *v102;
  _QWORD *v103;
  unint64_t v104;
  unint64_t *v105;
  _QWORD *v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  mlir::GenericProgramPoint *v110;
  uint64_t v111;
  int32x4_t *v112;
  unint64_t v113;
  int32x4_t *v114;
  char *v115;
  unint64_t v116;
  uint64_t v117;
  int32x4_t *v118;
  int32x4_t *v119;
  uint64_t v120;
  int32x4_t v121;
  int32x4_t v122;
  int32x4_t v123;
  int32x4_t v124;
  uint64_t v125;
  int v126;
  uint64_t *v127;
  _QWORD *v128;
  _QWORD *v129;
  _QWORD *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  mlir::GenericProgramPoint *DefiningOp;
  uint64_t *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char v142;
  _QWORD v143[3];
  void **v144;
  unsigned int *v145;
  unsigned int *v146;
  unsigned int v147;
  unsigned int v148;
  _QWORD *v149;
  uint64_t *v150;
  uint64_t ElementTypeOrSelf;
  _QWORD v152[2];
  uint64_t **v153;
  mlir::GenericProgramPoint *v154;
  void *v155;
  _BYTE v156[24];
  int v157;
  void *__dst;
  uint64_t v159;
  __int128 v160;
  int v161;
  void *v162;
  unsigned int v163;
  int v164;
  __int128 v165;
  mlir::GenericProgramPoint *v166;
  uint64_t v167;
  _BYTE v168[24];
  int32x4_t *v169;
  uint64_t v170;
  _BYTE v171[40];
  uint64_t v172;

  v172 = *MEMORY[0x1E0C80C00];
  v149 = a2;
  StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
  PaddingStyle = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v149);
  if (a3)
  {
    switch(StorageType)
    {
      case 0:
      case 7:
        if (a3 == 2)
          goto LABEL_9;
        break;
      case 1:
      case 8:
        if (a3 != 1)
          break;
LABEL_9:
        v11 = *(void **)(v149[6] + 16);
        v14 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
        v15 = v14;
        if (v14)
        {
          LODWORD(v16) = 0;
          v17 = 1;
        }
        else
        {
          v17 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id
             || v11 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id;
          LODWORD(v16) = !v17;
        }
        v21 = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v149);
        v22 = v21;
        v23 = v21;
        if (a3)
          __asm { BR              X10 }
        v24 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v149);
        v148 = v24;
        if (a4)
          __asm { BR              X10 }
        v147 = v24;
        v142 = v15;
        if (v22 != v23)
          __asm { BR              X10 }
        v25 = &v165;
        v162 = &v165;
        v164 = 5;
        v165 = xmmword_181235170;
        while (2)
        {
          v163 = 4;
          v144 = &v162;
          v145 = &v148;
          v146 = &v147;
          v143[0] = a5;
          v143[1] = &v149;
          v143[2] = &v144;
          v26 = *(_QWORD *)(v149[9] + 24);
          v27 = v149[3];
          v169 = (int32x4_t *)v171;
          memcpy(v171, v25, 0x10uLL);
          v170 = 0x500000004;
          if (v169 != (int32x4_t *)v171)
            free(v169);
          v30 = (uint64_t *)v149[9];
          v31 = (uint64_t *)v30[1];
          if (v31)
          {
            *v31 = *v30;
            if (*v30)
              *(_QWORD *)(*v30 + 8) = v30[1];
          }
          v30[3] = (uint64_t)v28;
          v30[1] = (uint64_t)v28;
          v32 = *v28;
          *v30 = *v28;
          if (v32)
            *(_QWORD *)(v32 + 8) = v30;
          *v28 = (uint64_t)v30;
          v33 = (_QWORD *)v149[9];
          v34 = v33 + 4;
          v35 = (_QWORD *)v33[5];
          if (v35)
          {
            *v35 = *v34;
            if (*v34)
              *(_QWORD *)(*v34 + 8) = v33[5];
          }
          v33[7] = v29;
          v33[5] = v29;
          v36 = *v29;
          v33[4] = *v29;
          if (v36)
            *(_QWORD *)(v36 + 8) = v34;
          *v29 = (uint64_t)v34;
          Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v38 = mlir::mps::TensorDataLayoutAttr::get(Context, v23);
          mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v149, v38);
          v39 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v149 + 3));
          v40 = mlir::mps::TensorDataLayoutAttr::get(v39, v147);
          mlir::mps::Conv2DDataGradientOp::setStridesAttr((uint64_t *)&v149, v40);
          Strides = mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v149);
          mlir::mps::DepthwiseConv2DDataGradientOp::setStridesAttr((uint64_t *)&v149, v42);
          InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr((uint64_t *)&v149, v44);
          Rewriter = mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v149);
          mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr((uint64_t *)&v149, v46);
          v47 = (mlir::GenericProgramPoint *)v149;
          if (v17)
          {
            v16 = v144;
            v48 = &v160;
            __dst = &v160;
            v159 = 0x500000000;
            if (v144 != &__dst)
            {
              v49 = *((_DWORD *)v144 + 2);
              if (!v49)
                goto LABEL_75;
              if (v49 >= 6)
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v160, *((unsigned int *)v144 + 2), 4);
                v52 = *((_DWORD *)v16 + 2);
                if (!v52)
                {
LABEL_74:
                  LODWORD(v159) = v49;
                  v48 = (__int128 *)__dst;
LABEL_75:
                  if (v23 == v22)
                    break;
LABEL_81:
                  switch(v22)
                  {
                    case 0u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x200000001;
                      v54 = xmmword_181240940;
                      goto LABEL_86;
                    case 1u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000003;
                      v54 = xmmword_181240950;
                      goto LABEL_86;
                    case 2u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 0x100000000;
                      v54 = xmmword_181240920;
                      goto LABEL_86;
                    case 3u:
                      v155 = &v156[8];
                      *(_QWORD *)&v156[16] = 1;
                      v54 = xmmword_181240930;
LABEL_86:
                      *(_OWORD *)v156 = v54;
                      v53 = 4;
                      goto LABEL_87;
                    default:
                      *((_DWORD *)v25 + 4) = 4;
                      *v25 = xmmword_181240EA8;
                      continue;
                  }
                }
                v48 = (__int128 *)__dst;
              }
              else
              {
                v52 = *((_DWORD *)v144 + 2);
              }
              memcpy(v48, *v16, 4 * v52);
              goto LABEL_74;
            }
            v49 = 0;
            if (v23 != v22)
              goto LABEL_81;
          }
          else
          {
            v50 = *v145;
            v51 = *v146;
            if (*v145 != (_DWORD)v51)
              __asm { BR              X10 }
            v48 = &v160;
            __dst = &v160;
            v49 = 5;
            HIDWORD(v159) = 5;
            if (v50 <= 3)
            {
              v160 = xmmword_181235170;
              v49 = 4;
            }
            else
            {
              v161 = 4;
              v160 = xmmword_181240EA8;
            }
            LODWORD(v159) = v49;
            v23 = v147;
            v22 = v148;
            if (v147 != v148)
              goto LABEL_81;
          }
          break;
        }
        v155 = &v156[8];
        v53 = 5;
        *(_DWORD *)&v156[4] = 5;
        if (v22 <= 3)
        {
          *(_OWORD *)&v156[8] = xmmword_181235170;
          v53 = 4;
        }
        else
        {
          v157 = 4;
          *(_OWORD *)&v156[8] = xmmword_181240EA8;
        }
        *(_DWORD *)v156 = v53;
LABEL_87:
        v154 = v47;
        v55 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v154);
        v153 = (uint64_t **)v55;
        v56 = (uint64_t *)(*(_QWORD *)(v55 + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v56)
          goto LABEL_96;
        v57 = *v56;
        v58 = mlir::TypeID::get<mlir::ShapedType>();
        v59 = *(unsigned int *)(v57 + 16);
        if (!(_DWORD)v59)
          goto LABEL_96;
        v60 = *(_QWORD **)(v57 + 8);
        v61 = &v60[2 * v59];
        do
        {
          v62 = v59 >> 1;
          v63 = &v60[2 * (v59 >> 1)];
          v65 = *v63;
          v64 = v63 + 2;
          v59 += ~(v59 >> 1);
          if (v65 < v58)
            v60 = v64;
          else
            v59 = v62;
        }
        while (v59);
        if (v60 != v61 && *v60 == v58)
          v66 = v60[1];
        else
LABEL_96:
          v66 = 0;
        v152[0] = v56;
        v152[1] = v66;
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
          goto LABEL_154;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152);
        v169 = (int32x4_t *)v171;
        v170 = 0x500000000;
        v68 = (mlir::GenericProgramPoint *)(int)v67;
        if ((unint64_t)(v67 << 32) >= 0x500000001)
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, (int)v67, 8);
        if (v49)
        {
          v69 = 4 * v49;
          do
          {
            v70 = *(unsigned int *)v48;
            v71 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v152) + 8 * v70);
            v72 = v170;
            if (v170 >= (unint64_t)HIDWORD(v170))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v169, v171, v170 + 1, 8);
              v72 = v170;
            }
            v169->i64[v72] = v71;
            v73 = v170 + 1;
            LODWORD(v170) = v170 + 1;
            v48 = (__int128 *)((char *)v48 + 4);
            v69 -= 4;
          }
          while (v69);
        }
        else
        {
          v73 = v170;
        }
        v166 = (mlir::GenericProgramPoint *)v152[0];
        *(_QWORD *)(v55 + 8) = *(_QWORD *)(v55 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v166, (uint64_t)v169, v73);
        if ((v142 & 1) != 0 || (*((_BYTE *)v154 + 46) & 0x80) == 0 || *((_DWORD *)v154 + 17) != 3)
        {
LABEL_152:
          if (v169 != (int32x4_t *)v171)
            free(v169);
LABEL_154:
          v132 = *((_QWORD *)v154 + 2);
          mlir::GenericProgramPoint::~GenericProgramPoint(v154);
          v134 = *(_QWORD *)(v133 + 8);
          *(_QWORD *)(a5 + 24) = v132;
          *(_QWORD *)(a5 + 32) = v134;
          if ((int32x4_t *)v55 != v169)
          {
            DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v169);
            if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v152))
            {
              v136 = (uint64_t *)v169;
            }
            else
            {
              v137 = *((_QWORD *)DefiningOp + 2);
              mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
              v139 = *(_QWORD *)(v138 + 8);
              *(_QWORD *)(a5 + 24) = v137;
              *(_QWORD *)(a5 + 32) = v139;
              v140 = *((_QWORD *)v154 + 3);
              ElementTypeOrSelf = 0;
              LOBYTE(v150) = 1;
              v166 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>((mlir::UnitAttr **)(a5 + 8), v140, (uint64_t *)&v169, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v150);
              v136 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v166);
            }
            mlir::Value::replaceAllUsesExcept(&v153, v136, (uint64_t)DefiningOp);
          }
          if (v155 != &v156[8])
            free(v155);
          if (__dst != &v160)
            free(__dst);
          if (v162 != &v165)
            free(v162);
          return 1;
        }
        ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(_QWORD *)(*((_QWORD *)v154 + 9) + 88));
        if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
        {
          v166 = v68;
          v95 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
          v96 = mlir::IntegerType::get(v95, 0x40u, 1u);
          v97 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v96, 0);
          v98 = v97;
          if (!v97)
            goto LABEL_133;
          v99 = *v97;
          v100 = mlir::TypeID::get<mlir::ShapedType>();
          v101 = *(unsigned int *)(v99 + 16);
          if (!(_DWORD)v101)
            goto LABEL_133;
          v102 = *(_QWORD **)(v99 + 8);
          v103 = &v102[2 * v101];
          do
          {
            v104 = v101 >> 1;
            v105 = &v102[2 * (v101 >> 1)];
            v107 = *v105;
            v106 = v105 + 2;
            v101 += ~(v101 >> 1);
            if (v107 < v100)
              v102 = v106;
            else
              v101 = v104;
          }
          while (v101);
          if (v102 != v103 && *v102 == v100)
            v108 = v102[1];
          else
LABEL_133:
            v108 = 0;
          v109 = *((_QWORD *)v154 + 3);
          v166 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v98, v108, v169, 8 * v170, 8, 1, 1);
          v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 8), v109, (uint64_t **)&v166);
LABEL_146:
          v127 = (uint64_t *)((char *)v110 - 16);
          v128 = (_QWORD *)*((_QWORD *)v154 + 9);
          v129 = v128 + 8;
          v130 = (_QWORD *)v128[9];
          if (v130)
          {
            *v130 = *v129;
            if (*v129)
              *(_QWORD *)(*v129 + 8) = v128[9];
          }
          v128[11] = v127;
          v128[9] = v127;
          v131 = *v127;
          v128[8] = *v127;
          if (v131)
            *(_QWORD *)(v131 + 8) = v129;
          *v127 = (uint64_t)v129;
          goto LABEL_152;
        }
        v74 = v169;
        v75 = v170;
        v166 = v68;
        v76 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v154 + 24));
        v77 = mlir::IntegerType::get(v76, 0x20u, 1u);
        v78 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v166, 1, v77, 0);
        v79 = v78;
        if (!v78)
          goto LABEL_120;
        v80 = *v78;
        v81 = mlir::TypeID::get<mlir::ShapedType>();
        v82 = *(unsigned int *)(v80 + 16);
        if (!(_DWORD)v82)
          goto LABEL_120;
        v83 = *(_QWORD **)(v80 + 8);
        v84 = &v83[2 * v82];
        do
        {
          v85 = v82 >> 1;
          v86 = &v83[2 * (v82 >> 1)];
          v88 = *v86;
          v87 = v86 + 2;
          v82 += ~(v82 >> 1);
          if (v88 < v81)
            v83 = v87;
          else
            v82 = v85;
        }
        while (v82);
        if (v83 != v84 && *v83 == v81)
          v89 = v83[1];
        else
LABEL_120:
          v89 = 0;
        v90 = (mlir::OpBuilder *)(a5 + 8);
        v91 = *((_QWORD *)v154 + 3);
        v166 = (mlir::GenericProgramPoint *)v168;
        v167 = 0x500000000;
        v141 = v91;
        if (v75 < 6)
        {
          if (!(_DWORD)v75)
          {
            v126 = 0;
            v94 = (uint64_t *)v168;
            v111 = v141;
LABEL_144:
            LODWORD(v167) = v126 + v75;
            v150 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v79, v89, v94, 4 * (v126 + v75), 4, 1, 1);
            v110 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v90, v111, &v150);
            if (v166 != (mlir::GenericProgramPoint *)v168)
              free(v166);
            goto LABEL_146;
          }
          v93 = 0;
          v94 = (uint64_t *)v168;
        }
        else
        {
          v92 = v89;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v166, v168, v75, 4);
          v89 = v92;
          v90 = (mlir::OpBuilder *)(a5 + 8);
          v93 = v167;
          v94 = (uint64_t *)v166;
        }
        v111 = v141;
        v112 = (int32x4_t *)((char *)v94 + 4 * v93);
        v113 = (v75 - 1) & 0x1FFFFFFFFFFFFFFFLL;
        if (v113 >= 7)
        {
          v116 = v113 + 1;
          v117 = (v113 + 1) & 0x3FFFFFFFFFFFFFF8;
          v114 = (int32x4_t *)((char *)v112 + 4 * v117);
          v115 = &v74->i8[8 * v117];
          v118 = v74 + 2;
          v119 = v112 + 1;
          v120 = v117;
          do
          {
            v122 = v118[-2];
            v121 = v118[-1];
            v124 = *v118;
            v123 = v118[1];
            v118 += 4;
            v119[-1] = vuzp1q_s32(v122, v121);
            *v119 = vuzp1q_s32(v124, v123);
            v119 += 2;
            v120 -= 8;
          }
          while (v120);
          if (v116 == v117)
            goto LABEL_143;
        }
        else
        {
          v114 = v112;
          v115 = (char *)v74;
        }
        do
        {
          v125 = *(_QWORD *)v115;
          v115 += 8;
          v114->i32[0] = v125;
          v114 = (int32x4_t *)((char *)v114 + 4);
        }
        while (v115 != (char *)v74 + 8 * v75);
LABEL_143:
        v126 = v167;
        goto LABEL_144;
      default:
        break;
    }
  }
  result = 0;
  if (a4)
  {
    switch(PaddingStyle)
    {
      case 2:
      case 9:
        if (a4 == 2)
          goto LABEL_9;
        goto LABEL_40;
      case 3:
      case 10:
        if (a4 == 1)
          goto LABEL_9;
LABEL_40:
        result = 0;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mlir::mps::`anonymous namespace'::ConvertConvolutionInterface<mlir::mps::DepthwiseConv2DWeightsGradientOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  __int128 *v8;
  unint64_t v9;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  void *__dst;
  uint64_t v18;
  __int128 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(**(_QWORD **)(a1 + 8) + 24);
  v6 = *(uint64_t **)(a1 + 16);
  if (a3)
  {
    v7 = *v6;
    v8 = &v19;
    __dst = &v19;
    v18 = 0x500000000;
    v9 = *(unsigned int *)(v7 + 8);
    if ((void **)v7 == &__dst || (_DWORD)v9 == 0)
    {
      v9 = 0;
      goto LABEL_20;
    }
    if (v9 < 6)
    {
      v14 = *(_DWORD *)(v7 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v19, *(unsigned int *)(v7 + 8), 4);
      v14 = *(_DWORD *)(v7 + 8);
      if (!v14)
      {
LABEL_19:
        LODWORD(v18) = v9;
        v8 = (__int128 *)__dst;
        goto LABEL_20;
      }
      v8 = (__int128 *)__dst;
    }
    memcpy(v8, *(const void **)v7, 4 * v14);
    goto LABEL_19;
  }
  v11 = (unsigned int *)v6[2];
  v12 = *(_DWORD *)v6[1];
  v13 = *v11;
  if (v12 != (_DWORD)v13)
    __asm { BR              X10 }
  v8 = &v19;
  __dst = &v19;
  v9 = 5;
  HIDWORD(v18) = 5;
  if (v12 > 3)
  {
    v20 = 4;
    v19 = xmmword_181240EA8;
  }
  else
  {
    v19 = xmmword_181235170;
    v9 = 4;
  }
  LODWORD(v18) = v9;
LABEL_20:
  if (__dst != &v19)
    free(__dst);
  return v15;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConvertDepthwise3DConvolutionInterface<mlir::mps::DepthwiseConv3DOp>>::convertLayout(uint64_t a1, _QWORD *a2, int a3, uint64_t a4, mlir::UnitAttr **a5)
{
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  unint64_t v25;
  unint64_t *v26;
  _QWORD *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  unint64_t v36;
  unint64_t *v37;
  _QWORD *v38;
  unint64_t v39;
  uint64_t v40;
  void *v41;
  BOOL v44;
  char v45;
  BOOL v46;
  BOOL v47;
  BOOL v48;
  mlir::CallableOpInterface *v49;
  int v50;
  int ArgOperands;
  uint64_t result;
  unsigned int v53;
  int ChannelAxis;
  int PositiveAxis;
  unsigned int v56;
  int v57;
  int v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  uint64_t *v66;
  uint64_t *v67;
  uint64_t *v68;
  uint64_t *v69;
  uint64_t v70;
  _QWORD *v71;
  _QWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t Context;
  uint64_t v76;
  uint64_t v77;
  mlir::GenericProgramPoint *v78;
  char *v79;
  int v80;
  int v81;
  unsigned int v82;
  int v83;
  unsigned int *v84;
  signed int v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  unsigned int v90;
  int v92;
  int v93;
  int v94;
  int v95;
  _QWORD *v96;
  signed int v98;
  uint64_t v99;
  int v100;
  int v101;
  unint64_t v103;
  uint64_t v104;
  uint64_t *v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  _QWORD *v109;
  _QWORD *v110;
  unint64_t v111;
  unint64_t *v112;
  _QWORD *v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  mlir::GenericProgramPoint *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unsigned int v122;
  int32x4_t *v123;
  unint64_t v124;
  uint64_t v125;
  uint64_t v126;
  _QWORD *v127;
  _QWORD *v128;
  uint64_t v129;
  unint64_t v130;
  unint64_t v131;
  _QWORD *v132;
  _QWORD *v133;
  unint64_t v134;
  unint64_t *v135;
  _QWORD *v136;
  unint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t *v142;
  uint64_t v143;
  uint64_t v144;
  _QWORD *v145;
  _QWORD *v146;
  uint64_t v147;
  unint64_t v148;
  unint64_t v149;
  _QWORD *v150;
  _QWORD *v151;
  unint64_t v152;
  unint64_t *v153;
  _QWORD *v154;
  unint64_t v155;
  uint64_t v156;
  uint64_t v157;
  mlir::GenericProgramPoint *v158;
  int32x4_t *v159;
  unint64_t v160;
  int32x4_t *v161;
  char *v162;
  unint64_t v163;
  uint64_t v164;
  int32x4_t *v165;
  int32x4_t *v166;
  uint64_t v167;
  int32x4_t v168;
  int32x4_t v169;
  int32x4_t v170;
  int32x4_t v171;
  uint64_t v172;
  int v173;
  uint64_t *v174;
  _QWORD *v175;
  _QWORD *v176;
  _QWORD *v177;
  uint64_t v178;
  mlir::UnitAttr *v179;
  uint64_t v180;
  mlir::UnitAttr *v181;
  mlir::GenericProgramPoint *DefiningOp;
  uint64_t *v183;
  mlir::UnitAttr *v184;
  uint64_t v185;
  mlir::UnitAttr *v186;
  uint64_t v187;
  uint64_t v188;
  _QWORD v189[3];
  signed int *v190;
  unsigned int *v191;
  signed int *v192;
  unsigned int *v193;
  int *v194;
  int v195;
  signed int v196;
  int v197;
  int v198;
  unsigned int v199;
  _QWORD v200[2];
  _QWORD v201[2];
  _QWORD v202[2];
  _QWORD *v203;
  uint64_t *v204;
  uint64_t ElementTypeOrSelf;
  _QWORD v206[2];
  uint64_t **v207;
  mlir::GenericProgramPoint *v208;
  void *v209;
  uint64_t v210;
  _QWORD v211[3];
  unsigned int *v212;
  uint64_t v213;
  _QWORD v214[3];
  mlir::GenericProgramPoint *v215;
  uint64_t v216;
  _BYTE v217[24];
  int32x4_t *v218;
  uint64_t v219;
  _DWORD v220[10];
  uint64_t v221;

  v221 = *MEMORY[0x1E0C80C00];
  v203 = a2;
  v8 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a2[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8)
    goto LABEL_10;
  v9 = *v8;
  v10 = mlir::TypeID::get<mlir::ShapedType>();
  v11 = *(unsigned int *)(v9 + 16);
  if (!(_DWORD)v11)
    goto LABEL_10;
  v12 = *(_QWORD **)(v9 + 8);
  v13 = &v12[2 * v11];
  do
  {
    v14 = v11 >> 1;
    v15 = &v12[2 * (v11 >> 1)];
    v17 = *v15;
    v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10)
      v12 = v16;
    else
      v11 = v14;
  }
  while (v11);
  if (v12 != v13 && *v12 == v10)
    v18 = v12[1];
  else
LABEL_10:
    v18 = 0;
  v202[0] = v8;
  v202[1] = v18;
  v19 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a2[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v19)
    goto LABEL_20;
  v20 = *v19;
  v21 = mlir::TypeID::get<mlir::ShapedType>();
  v22 = *(unsigned int *)(v20 + 16);
  if (!(_DWORD)v22)
    goto LABEL_20;
  v23 = *(_QWORD **)(v20 + 8);
  v24 = &v23[2 * v22];
  do
  {
    v25 = v22 >> 1;
    v26 = &v23[2 * (v22 >> 1)];
    v28 = *v26;
    v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21)
      v23 = v27;
    else
      v22 = v25;
  }
  while (v22);
  if (v23 != v24 && *v23 == v21)
    v29 = v23[1];
  else
LABEL_20:
    v29 = 0;
  v201[0] = v19;
  v201[1] = v29;
  v30 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v203) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v30)
    goto LABEL_30;
  v31 = *v30;
  v32 = mlir::TypeID::get<mlir::ShapedType>();
  v33 = *(unsigned int *)(v31 + 16);
  if (!(_DWORD)v33)
    goto LABEL_30;
  v34 = *(_QWORD **)(v31 + 8);
  v35 = &v34[2 * v33];
  do
  {
    v36 = v33 >> 1;
    v37 = &v34[2 * (v33 >> 1)];
    v39 = *v37;
    v38 = v37 + 2;
    v33 += ~(v33 >> 1);
    if (v39 < v32)
      v34 = v38;
    else
      v33 = v36;
  }
  while (v33);
  if (v34 != v35 && *v34 == v32)
    v40 = v34[1];
  else
LABEL_30:
    v40 = 0;
  v200[0] = v30;
  v200[1] = v40;
  v41 = *(void **)(v203[6] + 16);
  v44 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
  v45 = v44;
  if (v44
    || (v41 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id
      ? (v46 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id)
      : (v46 = 1),
        !v46 ? (v47 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id) : (v47 = 1),
        !v47 ? (v48 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id) : (v48 = 1),
        v48))
  {
    v199 = 0;
    v49 = (mlir::CallableOpInterface *)v202;
    if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v202) & 1) == 0)
    {
      v49 = (mlir::CallableOpInterface *)v200;
      ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v200);
      result = 0;
      if (!ArgOperands)
        return result;
    }
    v50 = 0;
  }
  else
  {
    v199 = 0;
    v49 = (mlir::CallableOpInterface *)v202;
    if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v202) & 1) == 0)
    {
      v49 = (mlir::CallableOpInterface *)v201;
      if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v201) & 1) == 0)
        return 0;
    }
    v50 = 1;
  }
  mlir::CallableOpInterface::getArgAttrsAttr(v49);
  v199 = v53;
  if (v53 == -1)
    return 0;
  ChannelAxis = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v203);
  PositiveAxis = mlir::getPositiveAxis(ChannelAxis, (int)v199);
  result = 0;
  v56 = v199;
  v197 = PositiveAxis - (v199 != 4);
  v198 = PositiveAxis;
  if (!a3 || (v199 & 0xFFFFFFFE) != 4)
    return result;
  if (v199 == 4)
    v57 = PositiveAxis + 1;
  else
    v57 = PositiveAxis;
  if (a3 == 1)
    v58 = 1;
  else
    v58 = 4;
  if (v57 == v58)
    return 0;
  if (a3 == 1)
    v59 = v199 != 4;
  else
    v59 = v199 - 1;
  if (a3 == 1)
    v60 = 0;
  else
    v60 = 3;
  v195 = v60;
  v196 = v59;
  v190 = (signed int *)&v199;
  v191 = (unsigned int *)&v198;
  v192 = &v196;
  v193 = (unsigned int *)&v197;
  v194 = &v195;
  v189[0] = a5;
  v189[1] = &v203;
  v189[2] = &v190;
  v61 = *(_QWORD *)(v203[9] + 24);
  v62 = v203[3];
  v218 = (int32x4_t *)v220;
  HIDWORD(v219) = 5;
  bzero(v220, 4 * v199);
  v63 = 0;
  v64 = 0;
  LODWORD(v219) = v56;
  do
  {
    if (v64 == PositiveAxis)
      ++v64;
    if (v63 == v59)
      ++v63;
    v220[v63++] = v64++;
  }
  while (v64 != v56 && v63 != v56);
  v220[v59] = PositiveAxis;
  if (v218 != (int32x4_t *)v220)
    free(v218);
  v68 = (uint64_t *)v203[9];
  v69 = (uint64_t *)v68[1];
  if (v69)
  {
    *v69 = *v68;
    if (*v68)
      *(_QWORD *)(*v68 + 8) = v68[1];
  }
  v68[3] = (uint64_t)v66;
  v68[1] = (uint64_t)v66;
  v70 = *v66;
  *v68 = *v66;
  if (v70)
    *(_QWORD *)(v70 + 8) = v68;
  *v66 = (uint64_t)v68;
  v71 = (_QWORD *)v203[9];
  v72 = v71 + 4;
  v73 = (_QWORD *)v71[5];
  if (v73)
  {
    *v73 = *v72;
    if (*v72)
      *(_QWORD *)(*v72 + 8) = v71[5];
  }
  v71[7] = v67;
  v71[5] = v67;
  v74 = *v67;
  v71[4] = *v67;
  if (v74)
    *(_QWORD *)(v74 + 8) = v72;
  *v67 = (uint64_t)v72;
  Context = mlir::Attribute::getContext((mlir::Attribute *)(v203 + 3));
  v76 = mlir::IntegerType::get(Context, 0x20u, 1u);
  v77 = mlir::IntegerAttr::get(v76, v196);
  mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v203, v77);
  v78 = (mlir::GenericProgramPoint *)v203;
  v79 = "cutableConstantDataRequest initWithCoder:]";
  if ((v50 & 1) != 0)
  {
    v80 = 0;
    v81 = 0;
    v82 = *v193;
    v83 = *v194;
    v84 = (unsigned int *)v214;
    v212 = (unsigned int *)v214;
    v214[0] = 0;
    v214[1] = 0;
    v213 = 0x500000004;
    do
    {
      if (v81 == v82)
        ++v81;
      if (v80 == v83)
        ++v80;
      *((_DWORD *)v214 + v80++) = v81++;
    }
    while (v81 != 4 && v80 != 4);
  }
  else
  {
    v86 = *v190;
    v82 = *v191;
    v83 = *v192;
    v84 = (unsigned int *)v214;
    v212 = (unsigned int *)v214;
    v213 = 0x500000000;
    if (!v86)
    {
      *((_DWORD *)v214 + v83) = v82;
      v88 = v213;
      goto LABEL_143;
    }
    if (v86 < 6)
    {
      v87 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v86, 4);
      v79 = "-[MPSGraphExecutableConstantDataRequest initWithCoder:]" + 13;
      v87 = v213;
      v84 = v212;
    }
    if (v86 != v87)
    {
      bzero(&v84[v87], 4 * (v86 - v87));
      v79 = "-[MPSGraphExecutableConstantDataRequest initWithCoder:]" + 13;
    }
    v89 = 0;
    v90 = 0;
    LODWORD(v213) = v86;
    do
    {
      if (v90 == v82)
        ++v90;
      if (v89 == v83)
        ++v89;
      v84[v89++] = v90++;
    }
    while (v90 != v86 && v89 != v86);
  }
  v84[v83] = v82;
  v88 = v213;
  if ((v50 & 1) != 0)
  {
    v92 = 0;
    v93 = 0;
    v94 = v195;
    v95 = v197;
    v96 = v211;
    v209 = v211;
    v211[0] = 0;
    v211[1] = 0;
    v210 = 0x500000004;
    do
    {
      if (v93 == v94)
        ++v93;
      if (v92 == v95)
        ++v92;
      *((_DWORD *)v211 + v92++) = v93++;
    }
    while (v93 != 4 && v92 != 4);
    goto LABEL_159;
  }
LABEL_143:
  v95 = v198;
  v98 = v199;
  v94 = v196;
  v96 = v211;
  v209 = v211;
  v210 = *((_QWORD *)v79 + 422);
  if (v199)
  {
    if (v199 < 6)
    {
      v99 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, v211, (int)v199, 4);
      v99 = v210;
      v96 = v209;
    }
    if (v98 != v99)
      bzero((char *)v96 + 4 * v99, 4 * (v98 - v99));
    v100 = 0;
    v101 = 0;
    LODWORD(v210) = v98;
    do
    {
      if (v101 == v94)
        ++v101;
      if (v100 == v95)
        ++v100;
      *((_DWORD *)v96 + v100++) = v101++;
    }
    while (v101 != v98 && v100 != v98);
  }
LABEL_159:
  *((_DWORD *)v96 + v95) = v94;
  v103 = v210;
  v208 = v78;
  v104 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v208);
  v207 = (uint64_t **)v104;
  v105 = (uint64_t *)(*(_QWORD *)(v104 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v105)
    goto LABEL_168;
  v106 = *v105;
  v107 = mlir::TypeID::get<mlir::ShapedType>();
  v108 = *(unsigned int *)(v106 + 16);
  if (!(_DWORD)v108)
    goto LABEL_168;
  v109 = *(_QWORD **)(v106 + 8);
  v110 = &v109[2 * v108];
  do
  {
    v111 = v108 >> 1;
    v112 = &v109[2 * (v108 >> 1)];
    v114 = *v112;
    v113 = v112 + 2;
    v108 += ~(v108 >> 1);
    if (v114 < v107)
      v109 = v113;
    else
      v108 = v111;
  }
  while (v108);
  if (v109 != v110 && *v109 == v107)
    v115 = v109[1];
  else
LABEL_168:
    v115 = 0;
  v206[0] = v105;
  v206[1] = v115;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v206))
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v206);
    v218 = (int32x4_t *)v220;
    v219 = 0x500000000;
    v117 = (mlir::GenericProgramPoint *)(int)v116;
    if ((unint64_t)(v116 << 32) >= 0x500000001)
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v218, v220, (int)v116, 8);
    if (v88)
    {
      v118 = 4 * v88;
      do
      {
        v119 = *v84;
        v120 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v206) + 8 * v119);
        v121 = v219;
        if (v219 >= (unint64_t)HIDWORD(v219))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v218, v220, v219 + 1, 8);
          v121 = v219;
        }
        v218->i64[v121] = v120;
        v122 = v219 + 1;
        LODWORD(v219) = v219 + 1;
        ++v84;
        v118 -= 4;
      }
      while (v118);
    }
    else
    {
      v122 = v219;
    }
    v215 = (mlir::GenericProgramPoint *)v206[0];
    *(_QWORD *)(v104 + 8) = *(_QWORD *)(v104 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v215, (uint64_t)v218, v122);
    if ((v45 & 1) != 0 || (*((_BYTE *)v208 + 46) & 0x80) == 0 || *((_DWORD *)v208 + 17) != 3)
      goto LABEL_224;
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(_QWORD *)(*((_QWORD *)v208 + 9) + 88));
    if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
    {
      v215 = v117;
      v143 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v208 + 24));
      v144 = mlir::IntegerType::get(v143, 0x40u, 1u);
      v145 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v215, 1, v144, 0);
      v146 = v145;
      if (!v145)
        goto LABEL_205;
      v147 = *v145;
      v148 = mlir::TypeID::get<mlir::ShapedType>();
      v149 = *(unsigned int *)(v147 + 16);
      if (!(_DWORD)v149)
        goto LABEL_205;
      v150 = *(_QWORD **)(v147 + 8);
      v151 = &v150[2 * v149];
      do
      {
        v152 = v149 >> 1;
        v153 = &v150[2 * (v149 >> 1)];
        v155 = *v153;
        v154 = v153 + 2;
        v149 += ~(v149 >> 1);
        if (v155 < v148)
          v150 = v154;
        else
          v149 = v152;
      }
      while (v149);
      if (v150 != v151 && *v150 == v148)
        v156 = v150[1];
      else
LABEL_205:
        v156 = 0;
      v157 = *((_QWORD *)v208 + 3);
      v215 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v146, v156, v218, 8 * v219, 8, 1, 1);
      v158 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 1), v157, (uint64_t **)&v215);
LABEL_218:
      v174 = (uint64_t *)((char *)v158 - 16);
      v175 = (_QWORD *)*((_QWORD *)v208 + 9);
      v176 = v175 + 8;
      v177 = (_QWORD *)v175[9];
      if (v177)
      {
        *v177 = *v176;
        if (*v176)
          *(_QWORD *)(*v176 + 8) = v175[9];
      }
      v175[11] = v174;
      v175[9] = v174;
      v178 = *v174;
      v175[8] = *v174;
      if (v178)
        *(_QWORD *)(v178 + 8) = v176;
      *v174 = (uint64_t)v176;
LABEL_224:
      if (v218 != (int32x4_t *)v220)
        free(v218);
      goto LABEL_226;
    }
    v123 = v218;
    v124 = v219;
    v215 = v117;
    v125 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v208 + 24));
    v126 = mlir::IntegerType::get(v125, 0x20u, 1u);
    v127 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v215, 1, v126, 0);
    v128 = v127;
    if (!v127)
      goto LABEL_192;
    v129 = *v127;
    v130 = mlir::TypeID::get<mlir::ShapedType>();
    v131 = *(unsigned int *)(v129 + 16);
    if (!(_DWORD)v131)
      goto LABEL_192;
    v132 = *(_QWORD **)(v129 + 8);
    v133 = &v132[2 * v131];
    do
    {
      v134 = v131 >> 1;
      v135 = &v132[2 * (v131 >> 1)];
      v137 = *v135;
      v136 = v135 + 2;
      v131 += ~(v131 >> 1);
      if (v137 < v130)
        v132 = v136;
      else
        v131 = v134;
    }
    while (v131);
    if (v132 != v133 && *v132 == v130)
      v138 = v132[1];
    else
LABEL_192:
      v138 = 0;
    v139 = *((_QWORD *)v208 + 3);
    v215 = (mlir::GenericProgramPoint *)v217;
    v216 = 0x500000000;
    v188 = v139;
    if (v124 < 6)
    {
      if (!(_DWORD)v124)
      {
        v173 = 0;
        v142 = (uint64_t *)v217;
LABEL_216:
        LODWORD(v216) = v173 + v124;
        v204 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v128, v138, v142, 4 * (v173 + v124), 4, 1, 1);
        v158 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 1), v188, &v204);
        if (v215 != (mlir::GenericProgramPoint *)v217)
          free(v215);
        goto LABEL_218;
      }
      v141 = 0;
      v142 = (uint64_t *)v217;
    }
    else
    {
      v140 = v138;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v217, v124, 4);
      v138 = v140;
      v141 = v216;
      v142 = (uint64_t *)v215;
    }
    v159 = (int32x4_t *)((char *)v142 + 4 * v141);
    v160 = (v124 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v160 >= 7)
    {
      v163 = v160 + 1;
      v164 = (v160 + 1) & 0x3FFFFFFFFFFFFFF8;
      v161 = (int32x4_t *)((char *)v159 + 4 * v164);
      v162 = &v123->i8[8 * v164];
      v165 = v123 + 2;
      v166 = v159 + 1;
      v167 = v164;
      do
      {
        v169 = v165[-2];
        v168 = v165[-1];
        v171 = *v165;
        v170 = v165[1];
        v165 += 4;
        v166[-1] = vuzp1q_s32(v169, v168);
        *v166 = vuzp1q_s32(v171, v170);
        v166 += 2;
        v167 -= 8;
      }
      while (v167);
      if (v163 == v164)
        goto LABEL_215;
    }
    else
    {
      v161 = v159;
      v162 = (char *)v123;
    }
    do
    {
      v172 = *(_QWORD *)v162;
      v162 += 8;
      v161->i32[0] = v172;
      v161 = (int32x4_t *)((char *)v161 + 4);
    }
    while (v162 != (char *)v123 + 8 * v124);
LABEL_215:
    v173 = v216;
    goto LABEL_216;
  }
LABEL_226:
  v179 = (mlir::UnitAttr *)*((_QWORD *)v208 + 2);
  mlir::GenericProgramPoint::~GenericProgramPoint(v208);
  v181 = *(mlir::UnitAttr **)(v180 + 8);
  a5[3] = v179;
  a5[4] = v181;
  if ((int32x4_t *)v104 != v218)
  {
    DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v218);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v206))
    {
      v183 = (uint64_t *)v218;
    }
    else
    {
      v184 = (mlir::UnitAttr *)*((_QWORD *)DefiningOp + 2);
      mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
      v186 = *(mlir::UnitAttr **)(v185 + 8);
      a5[3] = v184;
      a5[4] = v186;
      v187 = *((_QWORD *)v208 + 3);
      ElementTypeOrSelf = 0;
      LOBYTE(v204) = 1;
      v215 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>(a5 + 1, v187, (uint64_t *)&v218, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v204);
      v183 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v215);
    }
    mlir::Value::replaceAllUsesExcept(&v207, v183, (uint64_t)DefiningOp);
  }
  if (v209 != v211)
    free(v209);
  if (v212 != (unsigned int *)v214)
    free(v212);
  return 1;
}

uint64_t mlir::mps::`anonymous namespace'::ConvertDepthwise3DConvolutionInterface<mlir::mps::DepthwiseConv3DOp>::convertLayout(mlir::Operation *,mlir::mps::LayoutConversionType,mlir::mps::LayoutConversionType,mlir::RewriterBase &)const::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  signed int **v6;
  signed int v7;
  int v8;
  int v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  int v14;
  int v16;
  int v17;
  uint64_t v19;
  void *v21;
  uint64_t v22;
  _QWORD v23[4];

  v23[3] = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(**(_QWORD **)(a1 + 8) + 24);
  v6 = *(signed int ***)(a1 + 16);
  if (a3)
  {
    v7 = **v6;
    v8 = *v6[1];
    v9 = *v6[2];
    v10 = v23;
    v21 = v23;
    v22 = 0x500000000;
    if (!v7)
      goto LABEL_29;
    if (v7 < 6)
    {
      v11 = 0;
      v12 = v7;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v21, v23, v7, 4);
      v11 = v22;
      v10 = v21;
      v12 = v7 - (unint64_t)v22;
      if (v7 == (unint64_t)v22)
      {
LABEL_19:
        v16 = 0;
        v17 = 0;
        LODWORD(v22) = v7;
        do
        {
          if (v17 == v8)
            ++v17;
          if (v16 == v9)
            ++v16;
          *((_DWORD *)v10 + v16++) = v17++;
        }
        while (v17 != v7 && v16 != v7);
        goto LABEL_29;
      }
    }
    bzero((char *)v10 + 4 * v11, 4 * v12);
    goto LABEL_19;
  }
  v13 = 0;
  v14 = 0;
  v8 = *v6[3];
  v9 = *v6[4];
  v10 = v23;
  v21 = v23;
  v23[0] = 0;
  v23[1] = 0;
  v22 = 0x500000004;
  do
  {
    if (v14 == v8)
      ++v14;
    if (v13 == v9)
      ++v13;
    *((_DWORD *)v23 + v13++) = v14++;
  }
  while (v14 != 4 && v13 != 4);
LABEL_29:
  *((_DWORD *)v10 + v9) = v8;
  if (v21 != v23)
    free(v21);
  return v19;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConvertDepthwise3DConvolutionInterface<mlir::mps::DepthwiseConv3DDataGradientOp>>::convertLayout(uint64_t a1, _QWORD *a2, int a3, uint64_t a4, mlir::UnitAttr **a5)
{
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  unint64_t v25;
  unint64_t *v26;
  _QWORD *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  unint64_t v36;
  unint64_t *v37;
  _QWORD *v38;
  unint64_t v39;
  uint64_t v40;
  void *v41;
  BOOL v44;
  char v45;
  BOOL v46;
  BOOL v47;
  BOOL v48;
  mlir::CallableOpInterface *v49;
  int v50;
  int ArgOperands;
  uint64_t result;
  unsigned int v53;
  int ChannelAxis;
  int PositiveAxis;
  unsigned int v56;
  int v57;
  int v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  uint64_t *v66;
  uint64_t *v67;
  uint64_t *v68;
  uint64_t *v69;
  uint64_t v70;
  _QWORD *v71;
  _QWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t Context;
  uint64_t v76;
  uint64_t v77;
  mlir::GenericProgramPoint *v78;
  char *v79;
  int v80;
  int v81;
  unsigned int v82;
  int v83;
  unsigned int *v84;
  signed int v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  unsigned int v90;
  int v92;
  int v93;
  int v94;
  int v95;
  _QWORD *v96;
  signed int v98;
  uint64_t v99;
  int v100;
  int v101;
  unint64_t v103;
  uint64_t v104;
  uint64_t *v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  _QWORD *v109;
  _QWORD *v110;
  unint64_t v111;
  unint64_t *v112;
  _QWORD *v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  mlir::GenericProgramPoint *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unsigned int v122;
  int32x4_t *v123;
  unint64_t v124;
  uint64_t v125;
  uint64_t v126;
  _QWORD *v127;
  _QWORD *v128;
  uint64_t v129;
  unint64_t v130;
  unint64_t v131;
  _QWORD *v132;
  _QWORD *v133;
  unint64_t v134;
  unint64_t *v135;
  _QWORD *v136;
  unint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t *v142;
  uint64_t v143;
  uint64_t v144;
  _QWORD *v145;
  _QWORD *v146;
  uint64_t v147;
  unint64_t v148;
  unint64_t v149;
  _QWORD *v150;
  _QWORD *v151;
  unint64_t v152;
  unint64_t *v153;
  _QWORD *v154;
  unint64_t v155;
  uint64_t v156;
  uint64_t v157;
  mlir::GenericProgramPoint *v158;
  int32x4_t *v159;
  unint64_t v160;
  int32x4_t *v161;
  char *v162;
  unint64_t v163;
  uint64_t v164;
  int32x4_t *v165;
  int32x4_t *v166;
  uint64_t v167;
  int32x4_t v168;
  int32x4_t v169;
  int32x4_t v170;
  int32x4_t v171;
  uint64_t v172;
  int v173;
  uint64_t *v174;
  _QWORD *v175;
  _QWORD *v176;
  _QWORD *v177;
  uint64_t v178;
  mlir::UnitAttr *v179;
  uint64_t v180;
  mlir::UnitAttr *v181;
  mlir::GenericProgramPoint *DefiningOp;
  uint64_t *v183;
  mlir::UnitAttr *v184;
  uint64_t v185;
  mlir::UnitAttr *v186;
  uint64_t v187;
  uint64_t v188;
  _QWORD v189[3];
  signed int *v190;
  unsigned int *v191;
  signed int *v192;
  unsigned int *v193;
  int *v194;
  int v195;
  signed int v196;
  int v197;
  int v198;
  unsigned int v199;
  _QWORD v200[2];
  _QWORD v201[2];
  _QWORD v202[2];
  _QWORD *v203;
  uint64_t *v204;
  uint64_t ElementTypeOrSelf;
  _QWORD v206[2];
  uint64_t **v207;
  mlir::GenericProgramPoint *v208;
  void *v209;
  uint64_t v210;
  _QWORD v211[3];
  unsigned int *v212;
  uint64_t v213;
  _QWORD v214[3];
  mlir::GenericProgramPoint *v215;
  uint64_t v216;
  _BYTE v217[24];
  int32x4_t *v218;
  uint64_t v219;
  _DWORD v220[10];
  uint64_t v221;

  v221 = *MEMORY[0x1E0C80C00];
  v203 = a2;
  v8 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a2[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8)
    goto LABEL_10;
  v9 = *v8;
  v10 = mlir::TypeID::get<mlir::ShapedType>();
  v11 = *(unsigned int *)(v9 + 16);
  if (!(_DWORD)v11)
    goto LABEL_10;
  v12 = *(_QWORD **)(v9 + 8);
  v13 = &v12[2 * v11];
  do
  {
    v14 = v11 >> 1;
    v15 = &v12[2 * (v11 >> 1)];
    v17 = *v15;
    v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10)
      v12 = v16;
    else
      v11 = v14;
  }
  while (v11);
  if (v12 != v13 && *v12 == v10)
    v18 = v12[1];
  else
LABEL_10:
    v18 = 0;
  v202[0] = v8;
  v202[1] = v18;
  v19 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a2[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v19)
    goto LABEL_20;
  v20 = *v19;
  v21 = mlir::TypeID::get<mlir::ShapedType>();
  v22 = *(unsigned int *)(v20 + 16);
  if (!(_DWORD)v22)
    goto LABEL_20;
  v23 = *(_QWORD **)(v20 + 8);
  v24 = &v23[2 * v22];
  do
  {
    v25 = v22 >> 1;
    v26 = &v23[2 * (v22 >> 1)];
    v28 = *v26;
    v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21)
      v23 = v27;
    else
      v22 = v25;
  }
  while (v22);
  if (v23 != v24 && *v23 == v21)
    v29 = v23[1];
  else
LABEL_20:
    v29 = 0;
  v201[0] = v19;
  v201[1] = v29;
  v30 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v203) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v30)
    goto LABEL_30;
  v31 = *v30;
  v32 = mlir::TypeID::get<mlir::ShapedType>();
  v33 = *(unsigned int *)(v31 + 16);
  if (!(_DWORD)v33)
    goto LABEL_30;
  v34 = *(_QWORD **)(v31 + 8);
  v35 = &v34[2 * v33];
  do
  {
    v36 = v33 >> 1;
    v37 = &v34[2 * (v33 >> 1)];
    v39 = *v37;
    v38 = v37 + 2;
    v33 += ~(v33 >> 1);
    if (v39 < v32)
      v34 = v38;
    else
      v33 = v36;
  }
  while (v33);
  if (v34 != v35 && *v34 == v32)
    v40 = v34[1];
  else
LABEL_30:
    v40 = 0;
  v200[0] = v30;
  v200[1] = v40;
  v41 = *(void **)(v203[6] + 16);
  v44 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
  v45 = v44;
  if (v44
    || (v41 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id
      ? (v46 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id)
      : (v46 = 1),
        !v46 ? (v47 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id) : (v47 = 1),
        !v47 ? (v48 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id) : (v48 = 1),
        v48))
  {
    v199 = 0;
    v49 = (mlir::CallableOpInterface *)v202;
    if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v202) & 1) == 0)
    {
      v49 = (mlir::CallableOpInterface *)v200;
      ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v200);
      result = 0;
      if (!ArgOperands)
        return result;
    }
    v50 = 0;
  }
  else
  {
    v199 = 0;
    v49 = (mlir::CallableOpInterface *)v202;
    if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v202) & 1) == 0)
    {
      v49 = (mlir::CallableOpInterface *)v201;
      if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v201) & 1) == 0)
        return 0;
    }
    v50 = 1;
  }
  mlir::CallableOpInterface::getArgAttrsAttr(v49);
  v199 = v53;
  if (v53 == -1)
    return 0;
  ChannelAxis = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v203);
  PositiveAxis = mlir::getPositiveAxis(ChannelAxis, (int)v199);
  result = 0;
  v56 = v199;
  v197 = PositiveAxis - (v199 != 4);
  v198 = PositiveAxis;
  if (!a3 || (v199 & 0xFFFFFFFE) != 4)
    return result;
  if (v199 == 4)
    v57 = PositiveAxis + 1;
  else
    v57 = PositiveAxis;
  if (a3 == 1)
    v58 = 1;
  else
    v58 = 4;
  if (v57 == v58)
    return 0;
  if (a3 == 1)
    v59 = v199 != 4;
  else
    v59 = v199 - 1;
  if (a3 == 1)
    v60 = 0;
  else
    v60 = 3;
  v195 = v60;
  v196 = v59;
  v190 = (signed int *)&v199;
  v191 = (unsigned int *)&v198;
  v192 = &v196;
  v193 = (unsigned int *)&v197;
  v194 = &v195;
  v189[0] = a5;
  v189[1] = &v203;
  v189[2] = &v190;
  v61 = *(_QWORD *)(v203[9] + 24);
  v62 = v203[3];
  v218 = (int32x4_t *)v220;
  HIDWORD(v219) = 5;
  bzero(v220, 4 * v199);
  v63 = 0;
  v64 = 0;
  LODWORD(v219) = v56;
  do
  {
    if (v64 == PositiveAxis)
      ++v64;
    if (v63 == v59)
      ++v63;
    v220[v63++] = v64++;
  }
  while (v64 != v56 && v63 != v56);
  v220[v59] = PositiveAxis;
  if (v218 != (int32x4_t *)v220)
    free(v218);
  v68 = (uint64_t *)v203[9];
  v69 = (uint64_t *)v68[1];
  if (v69)
  {
    *v69 = *v68;
    if (*v68)
      *(_QWORD *)(*v68 + 8) = v68[1];
  }
  v68[3] = (uint64_t)v66;
  v68[1] = (uint64_t)v66;
  v70 = *v66;
  *v68 = *v66;
  if (v70)
    *(_QWORD *)(v70 + 8) = v68;
  *v66 = (uint64_t)v68;
  v71 = (_QWORD *)v203[9];
  v72 = v71 + 4;
  v73 = (_QWORD *)v71[5];
  if (v73)
  {
    *v73 = *v72;
    if (*v72)
      *(_QWORD *)(*v72 + 8) = v71[5];
  }
  v71[7] = v67;
  v71[5] = v67;
  v74 = *v67;
  v71[4] = *v67;
  if (v74)
    *(_QWORD *)(v74 + 8) = v72;
  *v67 = (uint64_t)v72;
  Context = mlir::Attribute::getContext((mlir::Attribute *)(v203 + 3));
  v76 = mlir::IntegerType::get(Context, 0x20u, 1u);
  v77 = mlir::IntegerAttr::get(v76, v196);
  mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v203, v77);
  v78 = (mlir::GenericProgramPoint *)v203;
  v79 = "cutableConstantDataRequest initWithCoder:]";
  if ((v50 & 1) != 0)
  {
    v80 = 0;
    v81 = 0;
    v82 = *v193;
    v83 = *v194;
    v84 = (unsigned int *)v214;
    v212 = (unsigned int *)v214;
    v214[0] = 0;
    v214[1] = 0;
    v213 = 0x500000004;
    do
    {
      if (v81 == v82)
        ++v81;
      if (v80 == v83)
        ++v80;
      *((_DWORD *)v214 + v80++) = v81++;
    }
    while (v81 != 4 && v80 != 4);
  }
  else
  {
    v86 = *v190;
    v82 = *v191;
    v83 = *v192;
    v84 = (unsigned int *)v214;
    v212 = (unsigned int *)v214;
    v213 = 0x500000000;
    if (!v86)
    {
      *((_DWORD *)v214 + v83) = v82;
      v88 = v213;
      goto LABEL_143;
    }
    if (v86 < 6)
    {
      v87 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v86, 4);
      v79 = "-[MPSGraphExecutableConstantDataRequest initWithCoder:]" + 13;
      v87 = v213;
      v84 = v212;
    }
    if (v86 != v87)
    {
      bzero(&v84[v87], 4 * (v86 - v87));
      v79 = "-[MPSGraphExecutableConstantDataRequest initWithCoder:]" + 13;
    }
    v89 = 0;
    v90 = 0;
    LODWORD(v213) = v86;
    do
    {
      if (v90 == v82)
        ++v90;
      if (v89 == v83)
        ++v89;
      v84[v89++] = v90++;
    }
    while (v90 != v86 && v89 != v86);
  }
  v84[v83] = v82;
  v88 = v213;
  if ((v50 & 1) != 0)
  {
    v92 = 0;
    v93 = 0;
    v94 = v195;
    v95 = v197;
    v96 = v211;
    v209 = v211;
    v211[0] = 0;
    v211[1] = 0;
    v210 = 0x500000004;
    do
    {
      if (v93 == v94)
        ++v93;
      if (v92 == v95)
        ++v92;
      *((_DWORD *)v211 + v92++) = v93++;
    }
    while (v93 != 4 && v92 != 4);
    goto LABEL_159;
  }
LABEL_143:
  v95 = v198;
  v98 = v199;
  v94 = v196;
  v96 = v211;
  v209 = v211;
  v210 = *((_QWORD *)v79 + 422);
  if (v199)
  {
    if (v199 < 6)
    {
      v99 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, v211, (int)v199, 4);
      v99 = v210;
      v96 = v209;
    }
    if (v98 != v99)
      bzero((char *)v96 + 4 * v99, 4 * (v98 - v99));
    v100 = 0;
    v101 = 0;
    LODWORD(v210) = v98;
    do
    {
      if (v101 == v94)
        ++v101;
      if (v100 == v95)
        ++v100;
      *((_DWORD *)v96 + v100++) = v101++;
    }
    while (v101 != v98 && v100 != v98);
  }
LABEL_159:
  *((_DWORD *)v96 + v95) = v94;
  v103 = v210;
  v208 = v78;
  v104 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v208);
  v207 = (uint64_t **)v104;
  v105 = (uint64_t *)(*(_QWORD *)(v104 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v105)
    goto LABEL_168;
  v106 = *v105;
  v107 = mlir::TypeID::get<mlir::ShapedType>();
  v108 = *(unsigned int *)(v106 + 16);
  if (!(_DWORD)v108)
    goto LABEL_168;
  v109 = *(_QWORD **)(v106 + 8);
  v110 = &v109[2 * v108];
  do
  {
    v111 = v108 >> 1;
    v112 = &v109[2 * (v108 >> 1)];
    v114 = *v112;
    v113 = v112 + 2;
    v108 += ~(v108 >> 1);
    if (v114 < v107)
      v109 = v113;
    else
      v108 = v111;
  }
  while (v108);
  if (v109 != v110 && *v109 == v107)
    v115 = v109[1];
  else
LABEL_168:
    v115 = 0;
  v206[0] = v105;
  v206[1] = v115;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v206))
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v206);
    v218 = (int32x4_t *)v220;
    v219 = 0x500000000;
    v117 = (mlir::GenericProgramPoint *)(int)v116;
    if ((unint64_t)(v116 << 32) >= 0x500000001)
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v218, v220, (int)v116, 8);
    if (v88)
    {
      v118 = 4 * v88;
      do
      {
        v119 = *v84;
        v120 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v206) + 8 * v119);
        v121 = v219;
        if (v219 >= (unint64_t)HIDWORD(v219))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v218, v220, v219 + 1, 8);
          v121 = v219;
        }
        v218->i64[v121] = v120;
        v122 = v219 + 1;
        LODWORD(v219) = v219 + 1;
        ++v84;
        v118 -= 4;
      }
      while (v118);
    }
    else
    {
      v122 = v219;
    }
    v215 = (mlir::GenericProgramPoint *)v206[0];
    *(_QWORD *)(v104 + 8) = *(_QWORD *)(v104 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v215, (uint64_t)v218, v122);
    if ((v45 & 1) != 0 || (*((_BYTE *)v208 + 46) & 0x80) == 0 || *((_DWORD *)v208 + 17) != 3)
      goto LABEL_224;
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(_QWORD *)(*((_QWORD *)v208 + 9) + 88));
    if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
    {
      v215 = v117;
      v143 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v208 + 24));
      v144 = mlir::IntegerType::get(v143, 0x40u, 1u);
      v145 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v215, 1, v144, 0);
      v146 = v145;
      if (!v145)
        goto LABEL_205;
      v147 = *v145;
      v148 = mlir::TypeID::get<mlir::ShapedType>();
      v149 = *(unsigned int *)(v147 + 16);
      if (!(_DWORD)v149)
        goto LABEL_205;
      v150 = *(_QWORD **)(v147 + 8);
      v151 = &v150[2 * v149];
      do
      {
        v152 = v149 >> 1;
        v153 = &v150[2 * (v149 >> 1)];
        v155 = *v153;
        v154 = v153 + 2;
        v149 += ~(v149 >> 1);
        if (v155 < v148)
          v150 = v154;
        else
          v149 = v152;
      }
      while (v149);
      if (v150 != v151 && *v150 == v148)
        v156 = v150[1];
      else
LABEL_205:
        v156 = 0;
      v157 = *((_QWORD *)v208 + 3);
      v215 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v146, v156, v218, 8 * v219, 8, 1, 1);
      v158 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 1), v157, (uint64_t **)&v215);
LABEL_218:
      v174 = (uint64_t *)((char *)v158 - 16);
      v175 = (_QWORD *)*((_QWORD *)v208 + 9);
      v176 = v175 + 8;
      v177 = (_QWORD *)v175[9];
      if (v177)
      {
        *v177 = *v176;
        if (*v176)
          *(_QWORD *)(*v176 + 8) = v175[9];
      }
      v175[11] = v174;
      v175[9] = v174;
      v178 = *v174;
      v175[8] = *v174;
      if (v178)
        *(_QWORD *)(v178 + 8) = v176;
      *v174 = (uint64_t)v176;
LABEL_224:
      if (v218 != (int32x4_t *)v220)
        free(v218);
      goto LABEL_226;
    }
    v123 = v218;
    v124 = v219;
    v215 = v117;
    v125 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v208 + 24));
    v126 = mlir::IntegerType::get(v125, 0x20u, 1u);
    v127 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v215, 1, v126, 0);
    v128 = v127;
    if (!v127)
      goto LABEL_192;
    v129 = *v127;
    v130 = mlir::TypeID::get<mlir::ShapedType>();
    v131 = *(unsigned int *)(v129 + 16);
    if (!(_DWORD)v131)
      goto LABEL_192;
    v132 = *(_QWORD **)(v129 + 8);
    v133 = &v132[2 * v131];
    do
    {
      v134 = v131 >> 1;
      v135 = &v132[2 * (v131 >> 1)];
      v137 = *v135;
      v136 = v135 + 2;
      v131 += ~(v131 >> 1);
      if (v137 < v130)
        v132 = v136;
      else
        v131 = v134;
    }
    while (v131);
    if (v132 != v133 && *v132 == v130)
      v138 = v132[1];
    else
LABEL_192:
      v138 = 0;
    v139 = *((_QWORD *)v208 + 3);
    v215 = (mlir::GenericProgramPoint *)v217;
    v216 = 0x500000000;
    v188 = v139;
    if (v124 < 6)
    {
      if (!(_DWORD)v124)
      {
        v173 = 0;
        v142 = (uint64_t *)v217;
LABEL_216:
        LODWORD(v216) = v173 + v124;
        v204 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v128, v138, v142, 4 * (v173 + v124), 4, 1, 1);
        v158 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 1), v188, &v204);
        if (v215 != (mlir::GenericProgramPoint *)v217)
          free(v215);
        goto LABEL_218;
      }
      v141 = 0;
      v142 = (uint64_t *)v217;
    }
    else
    {
      v140 = v138;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v217, v124, 4);
      v138 = v140;
      v141 = v216;
      v142 = (uint64_t *)v215;
    }
    v159 = (int32x4_t *)((char *)v142 + 4 * v141);
    v160 = (v124 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v160 >= 7)
    {
      v163 = v160 + 1;
      v164 = (v160 + 1) & 0x3FFFFFFFFFFFFFF8;
      v161 = (int32x4_t *)((char *)v159 + 4 * v164);
      v162 = &v123->i8[8 * v164];
      v165 = v123 + 2;
      v166 = v159 + 1;
      v167 = v164;
      do
      {
        v169 = v165[-2];
        v168 = v165[-1];
        v171 = *v165;
        v170 = v165[1];
        v165 += 4;
        v166[-1] = vuzp1q_s32(v169, v168);
        *v166 = vuzp1q_s32(v171, v170);
        v166 += 2;
        v167 -= 8;
      }
      while (v167);
      if (v163 == v164)
        goto LABEL_215;
    }
    else
    {
      v161 = v159;
      v162 = (char *)v123;
    }
    do
    {
      v172 = *(_QWORD *)v162;
      v162 += 8;
      v161->i32[0] = v172;
      v161 = (int32x4_t *)((char *)v161 + 4);
    }
    while (v162 != (char *)v123 + 8 * v124);
LABEL_215:
    v173 = v216;
    goto LABEL_216;
  }
LABEL_226:
  v179 = (mlir::UnitAttr *)*((_QWORD *)v208 + 2);
  mlir::GenericProgramPoint::~GenericProgramPoint(v208);
  v181 = *(mlir::UnitAttr **)(v180 + 8);
  a5[3] = v179;
  a5[4] = v181;
  if ((int32x4_t *)v104 != v218)
  {
    DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v218);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v206))
    {
      v183 = (uint64_t *)v218;
    }
    else
    {
      v184 = (mlir::UnitAttr *)*((_QWORD *)DefiningOp + 2);
      mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
      v186 = *(mlir::UnitAttr **)(v185 + 8);
      a5[3] = v184;
      a5[4] = v186;
      v187 = *((_QWORD *)v208 + 3);
      ElementTypeOrSelf = 0;
      LOBYTE(v204) = 1;
      v215 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>(a5 + 1, v187, (uint64_t *)&v218, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v204);
      v183 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v215);
    }
    mlir::Value::replaceAllUsesExcept(&v207, v183, (uint64_t)DefiningOp);
  }
  if (v209 != v211)
    free(v209);
  if (v212 != (unsigned int *)v214)
    free(v212);
  return 1;
}

uint64_t mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConvertDepthwise3DConvolutionInterface<mlir::mps::DepthwiseConv3DWeightsGradientOp>>::convertLayout(uint64_t a1, _QWORD *a2, int a3, uint64_t a4, mlir::UnitAttr **a5)
{
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  unint64_t v25;
  unint64_t *v26;
  _QWORD *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  unint64_t v36;
  unint64_t *v37;
  _QWORD *v38;
  unint64_t v39;
  uint64_t v40;
  void *v41;
  BOOL v44;
  char v45;
  BOOL v46;
  BOOL v47;
  BOOL v48;
  mlir::CallableOpInterface *v49;
  int v50;
  int ArgOperands;
  uint64_t result;
  unsigned int v53;
  int ChannelAxis;
  int PositiveAxis;
  unsigned int v56;
  int v57;
  int v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  uint64_t *v66;
  uint64_t *v67;
  uint64_t *v68;
  uint64_t *v69;
  uint64_t v70;
  _QWORD *v71;
  _QWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t Context;
  uint64_t v76;
  uint64_t v77;
  mlir::GenericProgramPoint *v78;
  char *v79;
  int v80;
  int v81;
  unsigned int v82;
  int v83;
  unsigned int *v84;
  signed int v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  unsigned int v90;
  int v92;
  int v93;
  int v94;
  int v95;
  _QWORD *v96;
  signed int v98;
  uint64_t v99;
  int v100;
  int v101;
  unint64_t v103;
  uint64_t v104;
  uint64_t *v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  _QWORD *v109;
  _QWORD *v110;
  unint64_t v111;
  unint64_t *v112;
  _QWORD *v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  mlir::GenericProgramPoint *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unsigned int v122;
  int32x4_t *v123;
  unint64_t v124;
  uint64_t v125;
  uint64_t v126;
  _QWORD *v127;
  _QWORD *v128;
  uint64_t v129;
  unint64_t v130;
  unint64_t v131;
  _QWORD *v132;
  _QWORD *v133;
  unint64_t v134;
  unint64_t *v135;
  _QWORD *v136;
  unint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t *v142;
  uint64_t v143;
  uint64_t v144;
  _QWORD *v145;
  _QWORD *v146;
  uint64_t v147;
  unint64_t v148;
  unint64_t v149;
  _QWORD *v150;
  _QWORD *v151;
  unint64_t v152;
  unint64_t *v153;
  _QWORD *v154;
  unint64_t v155;
  uint64_t v156;
  uint64_t v157;
  mlir::GenericProgramPoint *v158;
  int32x4_t *v159;
  unint64_t v160;
  int32x4_t *v161;
  char *v162;
  unint64_t v163;
  uint64_t v164;
  int32x4_t *v165;
  int32x4_t *v166;
  uint64_t v167;
  int32x4_t v168;
  int32x4_t v169;
  int32x4_t v170;
  int32x4_t v171;
  uint64_t v172;
  int v173;
  uint64_t *v174;
  _QWORD *v175;
  _QWORD *v176;
  _QWORD *v177;
  uint64_t v178;
  mlir::UnitAttr *v179;
  uint64_t v180;
  mlir::UnitAttr *v181;
  mlir::GenericProgramPoint *DefiningOp;
  uint64_t *v183;
  mlir::UnitAttr *v184;
  uint64_t v185;
  mlir::UnitAttr *v186;
  uint64_t v187;
  uint64_t v188;
  _QWORD v189[3];
  signed int *v190;
  unsigned int *v191;
  signed int *v192;
  unsigned int *v193;
  int *v194;
  int v195;
  signed int v196;
  int v197;
  int v198;
  unsigned int v199;
  _QWORD v200[2];
  _QWORD v201[2];
  _QWORD v202[2];
  _QWORD *v203;
  uint64_t *v204;
  uint64_t ElementTypeOrSelf;
  _QWORD v206[2];
  uint64_t **v207;
  mlir::GenericProgramPoint *v208;
  void *v209;
  uint64_t v210;
  _QWORD v211[3];
  unsigned int *v212;
  uint64_t v213;
  _QWORD v214[3];
  mlir::GenericProgramPoint *v215;
  uint64_t v216;
  _BYTE v217[24];
  int32x4_t *v218;
  uint64_t v219;
  _DWORD v220[10];
  uint64_t v221;

  v221 = *MEMORY[0x1E0C80C00];
  v203 = a2;
  v8 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a2[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8)
    goto LABEL_10;
  v9 = *v8;
  v10 = mlir::TypeID::get<mlir::ShapedType>();
  v11 = *(unsigned int *)(v9 + 16);
  if (!(_DWORD)v11)
    goto LABEL_10;
  v12 = *(_QWORD **)(v9 + 8);
  v13 = &v12[2 * v11];
  do
  {
    v14 = v11 >> 1;
    v15 = &v12[2 * (v11 >> 1)];
    v17 = *v15;
    v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10)
      v12 = v16;
    else
      v11 = v14;
  }
  while (v11);
  if (v12 != v13 && *v12 == v10)
    v18 = v12[1];
  else
LABEL_10:
    v18 = 0;
  v202[0] = v8;
  v202[1] = v18;
  v19 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a2[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v19)
    goto LABEL_20;
  v20 = *v19;
  v21 = mlir::TypeID::get<mlir::ShapedType>();
  v22 = *(unsigned int *)(v20 + 16);
  if (!(_DWORD)v22)
    goto LABEL_20;
  v23 = *(_QWORD **)(v20 + 8);
  v24 = &v23[2 * v22];
  do
  {
    v25 = v22 >> 1;
    v26 = &v23[2 * (v22 >> 1)];
    v28 = *v26;
    v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21)
      v23 = v27;
    else
      v22 = v25;
  }
  while (v22);
  if (v23 != v24 && *v23 == v21)
    v29 = v23[1];
  else
LABEL_20:
    v29 = 0;
  v201[0] = v19;
  v201[1] = v29;
  v30 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v203) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v30)
    goto LABEL_30;
  v31 = *v30;
  v32 = mlir::TypeID::get<mlir::ShapedType>();
  v33 = *(unsigned int *)(v31 + 16);
  if (!(_DWORD)v33)
    goto LABEL_30;
  v34 = *(_QWORD **)(v31 + 8);
  v35 = &v34[2 * v33];
  do
  {
    v36 = v33 >> 1;
    v37 = &v34[2 * (v33 >> 1)];
    v39 = *v37;
    v38 = v37 + 2;
    v33 += ~(v33 >> 1);
    if (v39 < v32)
      v34 = v38;
    else
      v33 = v36;
  }
  while (v33);
  if (v34 != v35 && *v34 == v32)
    v40 = v34[1];
  else
LABEL_30:
    v40 = 0;
  v200[0] = v30;
  v200[1] = v40;
  v41 = *(void **)(v203[6] + 16);
  v44 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id
     || v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
  v45 = v44;
  if (v44
    || (v41 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id
      ? (v46 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id)
      : (v46 = 1),
        !v46 ? (v47 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id) : (v47 = 1),
        !v47 ? (v48 = v41 == &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id) : (v48 = 1),
        v48))
  {
    v199 = 0;
    v49 = (mlir::CallableOpInterface *)v202;
    if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v202) & 1) == 0)
    {
      v49 = (mlir::CallableOpInterface *)v200;
      ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v200);
      result = 0;
      if (!ArgOperands)
        return result;
    }
    v50 = 0;
  }
  else
  {
    v199 = 0;
    v49 = (mlir::CallableOpInterface *)v202;
    if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v202) & 1) == 0)
    {
      v49 = (mlir::CallableOpInterface *)v201;
      if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v201) & 1) == 0)
        return 0;
    }
    v50 = 1;
  }
  mlir::CallableOpInterface::getArgAttrsAttr(v49);
  v199 = v53;
  if (v53 == -1)
    return 0;
  ChannelAxis = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v203);
  PositiveAxis = mlir::getPositiveAxis(ChannelAxis, (int)v199);
  result = 0;
  v56 = v199;
  v197 = PositiveAxis - (v199 != 4);
  v198 = PositiveAxis;
  if (!a3 || (v199 & 0xFFFFFFFE) != 4)
    return result;
  if (v199 == 4)
    v57 = PositiveAxis + 1;
  else
    v57 = PositiveAxis;
  if (a3 == 1)
    v58 = 1;
  else
    v58 = 4;
  if (v57 == v58)
    return 0;
  if (a3 == 1)
    v59 = v199 != 4;
  else
    v59 = v199 - 1;
  if (a3 == 1)
    v60 = 0;
  else
    v60 = 3;
  v195 = v60;
  v196 = v59;
  v190 = (signed int *)&v199;
  v191 = (unsigned int *)&v198;
  v192 = &v196;
  v193 = (unsigned int *)&v197;
  v194 = &v195;
  v189[0] = a5;
  v189[1] = &v203;
  v189[2] = &v190;
  v61 = *(_QWORD *)(v203[9] + 24);
  v62 = v203[3];
  v218 = (int32x4_t *)v220;
  HIDWORD(v219) = 5;
  bzero(v220, 4 * v199);
  v63 = 0;
  v64 = 0;
  LODWORD(v219) = v56;
  do
  {
    if (v64 == PositiveAxis)
      ++v64;
    if (v63 == v59)
      ++v63;
    v220[v63++] = v64++;
  }
  while (v64 != v56 && v63 != v56);
  v220[v59] = PositiveAxis;
  if (v218 != (int32x4_t *)v220)
    free(v218);
  v68 = (uint64_t *)v203[9];
  v69 = (uint64_t *)v68[1];
  if (v69)
  {
    *v69 = *v68;
    if (*v68)
      *(_QWORD *)(*v68 + 8) = v68[1];
  }
  v68[3] = (uint64_t)v66;
  v68[1] = (uint64_t)v66;
  v70 = *v66;
  *v68 = *v66;
  if (v70)
    *(_QWORD *)(v70 + 8) = v68;
  *v66 = (uint64_t)v68;
  v71 = (_QWORD *)v203[9];
  v72 = v71 + 4;
  v73 = (_QWORD *)v71[5];
  if (v73)
  {
    *v73 = *v72;
    if (*v72)
      *(_QWORD *)(*v72 + 8) = v71[5];
  }
  v71[7] = v67;
  v71[5] = v67;
  v74 = *v67;
  v71[4] = *v67;
  if (v74)
    *(_QWORD *)(v74 + 8) = v72;
  *v67 = (uint64_t)v72;
  Context = mlir::Attribute::getContext((mlir::Attribute *)(v203 + 3));
  v76 = mlir::IntegerType::get(Context, 0x20u, 1u);
  v77 = mlir::IntegerAttr::get(v76, v196);
  mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr((uint64_t *)&v203, v77);
  v78 = (mlir::GenericProgramPoint *)v203;
  v79 = "cutableConstantDataRequest initWithCoder:]";
  if ((v50 & 1) != 0)
  {
    v80 = 0;
    v81 = 0;
    v82 = *v193;
    v83 = *v194;
    v84 = (unsigned int *)v214;
    v212 = (unsigned int *)v214;
    v214[0] = 0;
    v214[1] = 0;
    v213 = 0x500000004;
    do
    {
      if (v81 == v82)
        ++v81;
      if (v80 == v83)
        ++v80;
      *((_DWORD *)v214 + v80++) = v81++;
    }
    while (v81 != 4 && v80 != 4);
  }
  else
  {
    v86 = *v190;
    v82 = *v191;
    v83 = *v192;
    v84 = (unsigned int *)v214;
    v212 = (unsigned int *)v214;
    v213 = 0x500000000;
    if (!v86)
    {
      *((_DWORD *)v214 + v83) = v82;
      v88 = v213;
      goto LABEL_143;
    }
    if (v86 < 6)
    {
      v87 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v86, 4);
      v79 = "-[MPSGraphExecutableConstantDataRequest initWithCoder:]" + 13;
      v87 = v213;
      v84 = v212;
    }
    if (v86 != v87)
    {
      bzero(&v84[v87], 4 * (v86 - v87));
      v79 = "-[MPSGraphExecutableConstantDataRequest initWithCoder:]" + 13;
    }
    v89 = 0;
    v90 = 0;
    LODWORD(v213) = v86;
    do
    {
      if (v90 == v82)
        ++v90;
      if (v89 == v83)
        ++v89;
      v84[v89++] = v90++;
    }
    while (v90 != v86 && v89 != v86);
  }
  v84[v83] = v82;
  v88 = v213;
  if ((v50 & 1) != 0)
  {
    v92 = 0;
    v93 = 0;
    v94 = v195;
    v95 = v197;
    v96 = v211;
    v209 = v211;
    v211[0] = 0;
    v211[1] = 0;
    v210 = 0x500000004;
    do
    {
      if (v93 == v94)
        ++v93;
      if (v92 == v95)
        ++v92;
      *((_DWORD *)v211 + v92++) = v93++;
    }
    while (v93 != 4 && v92 != 4);
    goto LABEL_159;
  }
LABEL_143:
  v95 = v198;
  v98 = v199;
  v94 = v196;
  v96 = v211;
  v209 = v211;
  v210 = *((_QWORD *)v79 + 422);
  if (v199)
  {
    if (v199 < 6)
    {
      v99 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, v211, (int)v199, 4);
      v99 = v210;
      v96 = v209;
    }
    if (v98 != v99)
      bzero((char *)v96 + 4 * v99, 4 * (v98 - v99));
    v100 = 0;
    v101 = 0;
    LODWORD(v210) = v98;
    do
    {
      if (v101 == v94)
        ++v101;
      if (v100 == v95)
        ++v100;
      *((_DWORD *)v96 + v100++) = v101++;
    }
    while (v101 != v98 && v100 != v98);
  }
LABEL_159:
  *((_DWORD *)v96 + v95) = v94;
  v103 = v210;
  v208 = v78;
  v104 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v208);
  v207 = (uint64_t **)v104;
  v105 = (uint64_t *)(*(_QWORD *)(v104 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v105)
    goto LABEL_168;
  v106 = *v105;
  v107 = mlir::TypeID::get<mlir::ShapedType>();
  v108 = *(unsigned int *)(v106 + 16);
  if (!(_DWORD)v108)
    goto LABEL_168;
  v109 = *(_QWORD **)(v106 + 8);
  v110 = &v109[2 * v108];
  do
  {
    v111 = v108 >> 1;
    v112 = &v109[2 * (v108 >> 1)];
    v114 = *v112;
    v113 = v112 + 2;
    v108 += ~(v108 >> 1);
    if (v114 < v107)
      v109 = v113;
    else
      v108 = v111;
  }
  while (v108);
  if (v109 != v110 && *v109 == v107)
    v115 = v109[1];
  else
LABEL_168:
    v115 = 0;
  v206[0] = v105;
  v206[1] = v115;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v206))
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v206);
    v218 = (int32x4_t *)v220;
    v219 = 0x500000000;
    v117 = (mlir::GenericProgramPoint *)(int)v116;
    if ((unint64_t)(v116 << 32) >= 0x500000001)
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v218, v220, (int)v116, 8);
    if (v88)
    {
      v118 = 4 * v88;
      do
      {
        v119 = *v84;
        v120 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v206) + 8 * v119);
        v121 = v219;
        if (v219 >= (unint64_t)HIDWORD(v219))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v218, v220, v219 + 1, 8);
          v121 = v219;
        }
        v218->i64[v121] = v120;
        v122 = v219 + 1;
        LODWORD(v219) = v219 + 1;
        ++v84;
        v118 -= 4;
      }
      while (v118);
    }
    else
    {
      v122 = v219;
    }
    v215 = (mlir::GenericProgramPoint *)v206[0];
    *(_QWORD *)(v104 + 8) = *(_QWORD *)(v104 + 8) & 7 | mlir::TensorType::clone((uint64_t)&v215, (uint64_t)v218, v122);
    if ((v45 & 1) != 0 || (*((_BYTE *)v208 + 46) & 0x80) == 0 || *((_DWORD *)v208 + 17) != 3)
      goto LABEL_224;
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(_QWORD *)(*((_QWORD *)v208 + 9) + 88));
    if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 32)
    {
      v215 = v117;
      v143 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v208 + 24));
      v144 = mlir::IntegerType::get(v143, 0x40u, 1u);
      v145 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v215, 1, v144, 0);
      v146 = v145;
      if (!v145)
        goto LABEL_205;
      v147 = *v145;
      v148 = mlir::TypeID::get<mlir::ShapedType>();
      v149 = *(unsigned int *)(v147 + 16);
      if (!(_DWORD)v149)
        goto LABEL_205;
      v150 = *(_QWORD **)(v147 + 8);
      v151 = &v150[2 * v149];
      do
      {
        v152 = v149 >> 1;
        v153 = &v150[2 * (v149 >> 1)];
        v155 = *v153;
        v154 = v153 + 2;
        v149 += ~(v149 >> 1);
        if (v155 < v148)
          v150 = v154;
        else
          v149 = v152;
      }
      while (v149);
      if (v150 != v151 && *v150 == v148)
        v156 = v150[1];
      else
LABEL_205:
        v156 = 0;
      v157 = *((_QWORD *)v208 + 3);
      v215 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v146, v156, v218, 8 * v219, 8, 1, 1);
      v158 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 1), v157, (uint64_t **)&v215);
LABEL_218:
      v174 = (uint64_t *)((char *)v158 - 16);
      v175 = (_QWORD *)*((_QWORD *)v208 + 9);
      v176 = v175 + 8;
      v177 = (_QWORD *)v175[9];
      if (v177)
      {
        *v177 = *v176;
        if (*v176)
          *(_QWORD *)(*v176 + 8) = v175[9];
      }
      v175[11] = v174;
      v175[9] = v174;
      v178 = *v174;
      v175[8] = *v174;
      if (v178)
        *(_QWORD *)(v178 + 8) = v176;
      *v174 = (uint64_t)v176;
LABEL_224:
      if (v218 != (int32x4_t *)v220)
        free(v218);
      goto LABEL_226;
    }
    v123 = v218;
    v124 = v219;
    v215 = v117;
    v125 = mlir::Attribute::getContext((mlir::GenericProgramPoint *)((char *)v208 + 24));
    v126 = mlir::IntegerType::get(v125, 0x20u, 1u);
    v127 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v215, 1, v126, 0);
    v128 = v127;
    if (!v127)
      goto LABEL_192;
    v129 = *v127;
    v130 = mlir::TypeID::get<mlir::ShapedType>();
    v131 = *(unsigned int *)(v129 + 16);
    if (!(_DWORD)v131)
      goto LABEL_192;
    v132 = *(_QWORD **)(v129 + 8);
    v133 = &v132[2 * v131];
    do
    {
      v134 = v131 >> 1;
      v135 = &v132[2 * (v131 >> 1)];
      v137 = *v135;
      v136 = v135 + 2;
      v131 += ~(v131 >> 1);
      if (v137 < v130)
        v132 = v136;
      else
        v131 = v134;
    }
    while (v131);
    if (v132 != v133 && *v132 == v130)
      v138 = v132[1];
    else
LABEL_192:
      v138 = 0;
    v139 = *((_QWORD *)v208 + 3);
    v215 = (mlir::GenericProgramPoint *)v217;
    v216 = 0x500000000;
    v188 = v139;
    if (v124 < 6)
    {
      if (!(_DWORD)v124)
      {
        v173 = 0;
        v142 = (uint64_t *)v217;
LABEL_216:
        LODWORD(v216) = v173 + v124;
        v204 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v128, v138, v142, 4 * (v173 + v124), 4, 1, 1);
        v158 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a5 + 1), v188, &v204);
        if (v215 != (mlir::GenericProgramPoint *)v217)
          free(v215);
        goto LABEL_218;
      }
      v141 = 0;
      v142 = (uint64_t *)v217;
    }
    else
    {
      v140 = v138;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v217, v124, 4);
      v138 = v140;
      v141 = v216;
      v142 = (uint64_t *)v215;
    }
    v159 = (int32x4_t *)((char *)v142 + 4 * v141);
    v160 = (v124 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v160 >= 7)
    {
      v163 = v160 + 1;
      v164 = (v160 + 1) & 0x3FFFFFFFFFFFFFF8;
      v161 = (int32x4_t *)((char *)v159 + 4 * v164);
      v162 = &v123->i8[8 * v164];
      v165 = v123 + 2;
      v166 = v159 + 1;
      v167 = v164;
      do
      {
        v169 = v165[-2];
        v168 = v165[-1];
        v171 = *v165;
        v170 = v165[1];
        v165 += 4;
        v166[-1] = vuzp1q_s32(v169, v168);
        *v166 = vuzp1q_s32(v171, v170);
        v166 += 2;
        v167 -= 8;
      }
      while (v167);
      if (v163 == v164)
        goto LABEL_215;
    }
    else
    {
      v161 = v159;
      v162 = (char *)v123;
    }
    do
    {
      v172 = *(_QWORD *)v162;
      v162 += 8;
      v161->i32[0] = v172;
      v161 = (int32x4_t *)((char *)v161 + 4);
    }
    while (v162 != (char *)v123 + 8 * v124);
LABEL_215:
    v173 = v216;
    goto LABEL_216;
  }
LABEL_226:
  v179 = (mlir::UnitAttr *)*((_QWORD *)v208 + 2);
  mlir::GenericProgramPoint::~GenericProgramPoint(v208);
  v181 = *(mlir::UnitAttr **)(v180 + 8);
  a5[3] = v179;
  a5[4] = v181;
  if ((int32x4_t *)v104 != v218)
  {
    DefiningOp = (mlir::GenericProgramPoint *)mlir::Value::getDefiningOp((mlir::Value *)&v218);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v206))
    {
      v183 = (uint64_t *)v218;
    }
    else
    {
      v184 = (mlir::UnitAttr *)*((_QWORD *)DefiningOp + 2);
      mlir::GenericProgramPoint::~GenericProgramPoint(DefiningOp);
      v186 = *(mlir::UnitAttr **)(v185 + 8);
      a5[3] = v184;
      a5[4] = v186;
      v187 = *((_QWORD *)v208 + 3);
      ElementTypeOrSelf = 0;
      LOBYTE(v204) = 1;
      v215 = mlir::OpBuilder::create<mlir::mps::DynamicShapeCastOp,mlir::Value &,decltype(nullptr),BOOL>(a5 + 1, v187, (uint64_t *)&v218, (uint64_t)&ElementTypeOrSelf, (unsigned __int8 *)&v204);
      v183 = (uint64_t *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v215);
    }
    mlir::Value::replaceAllUsesExcept(&v207, v183, (uint64_t)DefiningOp);
  }
  if (v209 != v211)
    free(v209);
  if (v212 != (unsigned int *)v214)
    free(v212);
  return 1;
}

mlir::GenericProgramPoint *mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConvertPoolingInterface<mlir::mps::PoolAvgOp>>::convertLayout(uint64_t a1, uint64_t a2, int a3, uint64_t a4, mlir::UnitAttr **a5, uint64_t a6, uint64_t a7, uint64_t a8, char *a9, char *a10)
{
  char isSplat;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v15;
  uint64_t RawStringData;
  unint64_t NumElements;
  int v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  _BYTE *v26;
  uint64_t v27;
  _BYTE *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  int v32;
  _BYTE *v33;
  uint64_t v34;
  _BYTE *v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  unint64_t v41;
  _BYTE *v42;
  unsigned int v43;
  _BYTE *v44;
  unint64_t v45;
  char *v46;
  char *v47;
  uint64_t v48;
  BOOL v49;
  BOOL v50;
  uint64_t v51;
  int v52;
  BOOL v53;
  BOOL v54;
  _BYTE *v55;
  _BOOL4 v56;
  mlir::GenericProgramPoint *result;
  int v58;
  int v59;
  uint64_t v60;
  uint64_t Input;
  uint64_t InputAttributeNames;
  char v63;
  uint64_t Offsets;
  char v65;
  uint64_t Strides;
  uint64_t WindowSizes;
  uint64_t v68;
  mlir::GenericProgramPoint *v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t i;
  uint64_t NextResultAtOffset;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  _QWORD *v78;
  uint64_t v79;
  mlir::UnitAttr **v80;
  uint64_t v81;
  uint64_t *v82;
  uint64_t *v83;
  uint64_t *v84;
  uint64_t *v85;
  unsigned int *v86;
  uint64_t *v87;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92[2];
  uint64_t v93;
  void *__src;
  _BYTE v95[20];
  int v96;
  void *__dst;
  _BYTE v98[20];
  int v99;
  void *v100;
  uint64_t v101;
  _BYTE v102[40];
  _QWORD *v103;
  uint64_t v104;
  _BYTE v105[40];
  _QWORD *v106;
  uint64_t v107;
  _QWORD v108[7];

  v108[5] = *MEMORY[0x1E0C80C00];
  v91 = a2;
  v93 = a2;
  __dst = (void *)mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v93);
  v15 = "cutableConstantDataRequest initWithCoder:]";
  if ((mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&__dst, 8, 1, 0) & 1) != 0)
  {
    RawStringData = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&__dst);
    isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&__dst);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&__dst);
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&__dst);
    v11 = NumElements;
    v106 = v108;
    v107 = 0x500000000;
    if (NumElements < 6)
    {
      v18 = 0;
      if (!NumElements)
        goto LABEL_12;
      v19 = v108;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v108, NumElements, 8);
      v18 = v107;
      v19 = v106;
    }
  }
  else
  {
    v18 = 0;
    RawStringData = 0;
    v19 = v108;
    v106 = v108;
    v107 = 0x500000000;
  }
  v20 = 0;
  v21 = &v19[v18];
  do
  {
    if (isSplat)
      v22 = 0;
    else
      v22 = v20;
    v21[v20++] = *(_QWORD *)(RawStringData + 8 * v22);
  }
  while (v11 != v20);
LABEL_12:
  LODWORD(v107) = v18 + v11;
  __dst = (void *)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v93);
  if ((mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&__dst, 8, 1, 0) & 1) != 0)
  {
    v23 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&__dst);
    isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&__dst);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&__dst);
    v24 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&__dst);
    v12 = v24;
    v103 = v105;
    v104 = 0x500000000;
    if (v24 < 6)
    {
      v25 = 0;
      if (!v24)
        goto LABEL_23;
      v26 = v105;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v105, v24, 8);
      v25 = v104;
      v26 = v103;
    }
  }
  else
  {
    v25 = 0;
    v23 = 0;
    v26 = v105;
    v103 = v105;
    v104 = 0x500000000;
  }
  v27 = 0;
  v28 = &v26[8 * v25];
  do
  {
    if (isSplat)
      v29 = 0;
    else
      v29 = v27;
    *(_QWORD *)&v28[8 * v27++] = *(_QWORD *)(v23 + 8 * v29);
  }
  while (v12 != v27);
LABEL_23:
  LODWORD(v104) = v25 + v12;
  __dst = (void *)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v93);
  if ((mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&__dst, 8, 1, 0) & 1) != 0)
  {
    v30 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&__dst);
    isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&__dst);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&__dst);
    v31 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&__dst);
    v13 = v31;
    v100 = v102;
    v101 = 0x500000000;
    if (v31 < 6)
    {
      v32 = 0;
      if (!v31)
        goto LABEL_34;
      v33 = v102;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v102, v31, 8);
      v32 = v101;
      v33 = v100;
    }
  }
  else
  {
    v32 = 0;
    v30 = 0;
    v33 = v102;
    v100 = v102;
    v101 = 0x500000000;
  }
  v34 = 0;
  v35 = &v33[8 * v32];
  do
  {
    if (isSplat)
      v36 = 0;
    else
      v36 = v34;
    *(_QWORD *)&v35[8 * v34++] = *(_QWORD *)(v30 + 8 * v36);
  }
  while (v13 != v34);
LABEL_34:
  LODWORD(v101) = v32 + v13;
  __dst = &v98[8];
  *(_QWORD *)v98 = 0xA00000000;
  mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v93);
  if (v37)
  {
    v92[0] = mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v93);
    v92[1] = v38;
    if (!(_BYTE)v38)
      goto LABEL_154;
    v39 = a3;
    if ((mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)v92, 8, 1, 0) & 1) != 0)
    {
      v40 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)v92);
      isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)v92);
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v92);
      v41 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v92);
      v15 = (char *)v41;
      v42 = &v95[8];
      __src = &v95[8];
      *(_QWORD *)v95 = 0xA00000000;
      if (v41 < 0xB)
      {
        v43 = 0;
        LODWORD(v45) = 0;
        v44 = &v95[8];
        if (!v41)
          goto LABEL_56;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, &v95[8], v41, 8);
        v43 = *(_DWORD *)v95;
        v44 = __src;
      }
    }
    else
    {
      v43 = 0;
      v40 = 0;
      v44 = &v95[8];
      __src = &v95[8];
      *(_DWORD *)&v95[4] = 10;
      v42 = &v95[8];
    }
    v46 = 0;
    do
    {
      if (isSplat)
        v47 = 0;
      else
        v47 = v46;
      *(_QWORD *)&v44[8 * v43 + 8 * (_QWORD)v46++] = *(_QWORD *)(v40 + 8 * (_QWORD)v47);
    }
    while (v15 != v46);
    v45 = v43 + v15;
    *(_DWORD *)v95 = v43 + (_DWORD)v15;
    if (v44 != &v95[8])
    {
      if (__dst != &v98[8])
      {
        free(__dst);
        v44 = __src;
        LODWORD(v45) = *(_DWORD *)v95;
      }
      __dst = v44;
      *(_DWORD *)v98 = v45;
      *(_DWORD *)&v98[4] = *(_DWORD *)&v95[4];
      __src = &v95[8];
      *(_DWORD *)&v95[4] = 0;
      goto LABEL_63;
    }
    v48 = *(unsigned int *)v98;
    if (*(_DWORD *)v98 < v45)
    {
      if (*(_DWORD *)&v98[4] >= v45)
      {
        if (*(_DWORD *)v98)
        {
          memmove(__dst, v44, 8 * *(unsigned int *)v98);
LABEL_60:
          if (v48 != *(unsigned int *)v95)
            memcpy((char *)__dst + 8 * v48, (char *)__src + 8 * v48, 8 * *(unsigned int *)v95 - 8 * v48);
          *(_DWORD *)v98 = v45;
          v42 = v44;
          goto LABEL_63;
        }
      }
      else
      {
        *(_DWORD *)v98 = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v98[8], v45, 8);
      }
      v48 = 0;
      goto LABEL_60;
    }
    if ((_DWORD)v45)
      memmove(__dst, v44, 8 * v45);
    v42 = v44;
LABEL_56:
    *(_DWORD *)v98 = v45;
LABEL_63:
    *(_DWORD *)v95 = 0;
    v49 = __src == v42;
    a3 = v39;
    if (!v49)
      free(__src);
  }
  if ((_DWORD)v107 != 4)
  {
    v51 = 0;
    v52 = 0;
    goto LABEL_99;
  }
  __src = &v95[16];
  *(_DWORD *)&v95[16] = 0;
  *(int64x2_t *)v95 = vdupq_n_s64(4uLL);
  if (*v106 != 1 || *v103 != 1 || *(_QWORD *)v100 != 1)
    goto LABEL_73;
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v93))
  {
    v50 = 0;
    goto LABEL_74;
  }
  if (!*(_QWORD *)__dst)
    v50 = *((_QWORD *)__dst + 1) != 0;
  else
LABEL_73:
    v50 = 1;
LABEL_74:
  *(_BYTE *)__src = v50;
  if (v106[1] != 1 || v103[1] != 1 || *((_QWORD *)v100 + 1) != 1)
    goto LABEL_80;
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v93))
  {
    v53 = 0;
    goto LABEL_81;
  }
  if (!*((_QWORD *)__dst + 2))
    v53 = *((_QWORD *)__dst + 3) != 0;
  else
LABEL_80:
    v53 = 1;
LABEL_81:
  *((_BYTE *)__src + 1) = v53;
  if (v106[2] != 1 || v103[2] != 1 || *((_QWORD *)v100 + 2) != 1)
    goto LABEL_87;
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v93))
  {
    v54 = 0;
    goto LABEL_88;
  }
  if (!*((_QWORD *)__dst + 4))
    v54 = *((_QWORD *)__dst + 5) != 0;
  else
LABEL_87:
    v54 = 1;
LABEL_88:
  *((_BYTE *)__src + 2) = v54;
  if (v106[3] != 1 || v103[3] != 1 || *((_QWORD *)v100 + 3) != 1)
    goto LABEL_95;
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v93))
  {
    v55 = __src;
    *((_BYTE *)__src + 3) = 0;
    if (!*v55)
      goto LABEL_118;
LABEL_97:
    v51 = 0;
    v52 = 0;
    if (v55 == &v95[16])
      goto LABEL_99;
    goto LABEL_98;
  }
  if (!*((_QWORD *)__dst + 6))
    v56 = *((_QWORD *)__dst + 7) != 0;
  else
LABEL_95:
    v56 = 1;
  v55 = __src;
  *((_BYTE *)__src + 3) = v56;
  if (*v55)
    goto LABEL_97;
  if (v56)
  {
    if (!v55[1])
    {
      v52 = 0;
      goto LABEL_119;
    }
    goto LABEL_97;
  }
LABEL_118:
  v52 = 1;
LABEL_119:
  v51 = 0x100000000;
  if (v55 != &v95[16])
LABEL_98:
    free(v55);
LABEL_99:
  if (__dst != &v98[8])
    free(__dst);
  if (v100 != v102)
    free(v100);
  if (v103 != (_QWORD *)v105)
    free(v103);
  if (v106 != v108)
    free(v106);
  result = 0;
  if (a3 && (v51 & 0x100000000) != 0)
  {
    if (v52)
    {
      if (a3 == 1)
        goto LABEL_111;
    }
    else if (a3 == 2)
    {
LABEL_111:
      v58 = a3 != 1;
      __dst = &v98[8];
      if (v52 == v58)
      {
        *(_OWORD *)&v98[4] = xmmword_181240960;
        v59 = 3;
      }
      else
      {
        *(_QWORD *)&v98[4] = 5;
        if (a3 == 1)
        {
          *(_QWORD *)&v98[12] = 0x100000003;
          v59 = 2;
        }
        else
        {
          *(_QWORD *)&v98[12] = 0x300000002;
          v59 = 1;
        }
      }
      v99 = v59;
      *(_DWORD *)v98 = 4;
      v60 = *(_QWORD *)(v91 + 24);
      Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91);
      InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v91);
      v93 = 0;
      mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v91);
      if (!v63)
        goto LABEL_127;
      Offsets = mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v91);
      if (v65)
      {
LABEL_127:
        Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v91);
        WindowSizes = mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v91);
        v68 = *(_QWORD *)(v91 + 24);
        LODWORD(__src) = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v91);
        LOBYTE(v106) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v91);
        LOBYTE(v103) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v91);
        v69 = mlir::OpBuilder::create<mlir::mps::PoolAvgOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL>(a5 + 1, v68, (uint64_t *)&v100, &v89, &v90, v92, (unsigned int *)&__src, &v93, (char *)&v106, (char *)&v103);
        if (v52 == v58)
        {
          __src = &v95[8];
          *(_OWORD *)&v95[4] = xmmword_181240960;
          v70 = 3;
        }
        else
        {
          __src = &v95[8];
          *(_QWORD *)&v95[4] = 5;
          if (v52)
          {
            *(_QWORD *)&v95[12] = 0x300000002;
            v70 = 1;
          }
          else
          {
            *(_QWORD *)&v95[12] = 0x100000003;
            v70 = 2;
          }
        }
        v96 = v70;
        *(_DWORD *)v95 = 4;
        v106 = v108;
        v107 = 0x200000000;
        v71 = *((unsigned int *)v69 + 9);
        if ((_DWORD)v71)
          v72 = (uint64_t)v69 - 16;
        else
          v72 = 0;
        if ((_DWORD)v71)
        {
          for (i = 0; i != v71; ++i)
          {
            NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v72, i);
            v76 = v107;
            if (v107 >= (unint64_t)HIDWORD(v107))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v108, v107 + 1, 8);
              v76 = v107;
            }
            v106[v76] = v75;
            v77 = (v107 + 1);
            LODWORD(v107) = v107 + 1;
          }
          v78 = v106;
        }
        else
        {
          v77 = 0;
          v78 = v108;
        }
        v79 = v91;
        mlir::ValueRange::ValueRange((unint64_t *)&v103, (uint64_t)v78, v77);
        (*((void (**)(mlir::UnitAttr **, uint64_t, _QWORD *, uint64_t))*a5 + 3))(a5, v79, v103, v104);
        if (v106 != v108)
          free(v106);
        if (__src != &v95[8])
          free(__src);
        if (__dst != &v98[8])
          free(__dst);
        return (mlir::GenericProgramPoint *)1;
      }
LABEL_154:
      v80 = (mlir::UnitAttr **)std::__throw_bad_optional_access[abi:nn180100]();
      return mlir::OpBuilder::create<mlir::mps::PoolAvgOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL>(v80, v81, v82, v83, v84, v85, v86, v87, a9, a10);
    }
    return 0;
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::PoolAvgOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned int *a7, uint64_t *a8, char *a9, char *a10)
{
  uint64_t *Context;
  uint64_t v19;
  char v20;
  mlir::GenericProgramPoint *v21;
  mlir::GenericProgramPoint *v22;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  uint64_t v27[4];
  __int16 v28;
  _QWORD v29[40];

  v29[38] = *MEMORY[0x1E0C80C00];
  v24 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_average", (const unsigned __int8 *)0x13, Context);
  if (!v20)
  {
    v28 = 1283;
    v27[2] = (uint64_t)"mps.pooling_average";
    v27[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v19);
  mlir::mps::PoolAvgOp::build(a1, (uint64_t)v29, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10);
  v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((_QWORD *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PoolAvgOp,void>::id)
    v22 = v21;
  else
    v22 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v22;
}

mlir::GenericProgramPoint *mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConvertPoolingInterface<mlir::mps::PoolMaxOp>>::convertLayout(uint64_t a1, uint64_t a2, int a3, uint64_t a4, mlir::UnitAttr **a5, uint64_t a6, uint64_t a7, uint64_t a8, char *a9, char *a10, unsigned int *a11, uint64_t *a12)
{
  char isSplat;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  mlir::GenericProgramPoint *result;
  uint64_t RawStringData;
  unint64_t NumElements;
  int v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  _BYTE *v28;
  int v29;
  _BYTE *v30;
  uint64_t v31;
  _BYTE *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  int v36;
  _BYTE *v37;
  uint64_t v38;
  _BYTE *v39;
  uint64_t v40;
  char v41;
  uint64_t v42;
  mlir::UnitAttr **v43;
  uint64_t v44;
  unint64_t v45;
  char *v46;
  unsigned int v47;
  char *v48;
  unint64_t v49;
  _BYTE *v50;
  _BYTE *v51;
  uint64_t v52;
  BOOL v53;
  uint64_t v54;
  int v55;
  BOOL v56;
  BOOL v57;
  _BYTE *v58;
  _BOOL4 v59;
  int v60;
  int v61;
  uint64_t v62;
  uint64_t Input;
  uint64_t InputAttributeNames;
  char v65;
  uint64_t Offsets;
  char v67;
  uint64_t Strides;
  uint64_t v69;
  uint64_t v70;
  mlir::GenericProgramPoint *v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t i;
  uint64_t NextResultAtOffset;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  _QWORD *v80;
  uint64_t v81;
  mlir::UnitAttr **v82;
  uint64_t v83;
  uint64_t *v84;
  uint64_t *v85;
  uint64_t *v86;
  uint64_t *v87;
  unsigned int *v88;
  uint64_t *v89;
  int v90;
  BOOL ResetAfter;
  BOOL InferredResultTypes;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96[2];
  uint64_t v97;
  void *__src;
  _BYTE v99[20];
  int v100;
  char *WindowSizes;
  _BYTE v102[20];
  int v103;
  _QWORD *v104;
  uint64_t v105;
  _BYTE v106[40];
  _QWORD *v107;
  uint64_t v108;
  _BYTE v109[40];
  _QWORD *v110;
  uint64_t v111;
  _QWORD v112[7];

  v112[5] = *MEMORY[0x1E0C80C00];
  v95 = a2;
  if (*(_QWORD *)mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v95))
    return 0;
  v97 = v95;
  WindowSizes = (char *)mlir::mps::PoolMaxGradientOp::getWindowSizes((mlir::mps::PoolMaxGradientOp *)&v97);
  if ((mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&WindowSizes, 8, 1, 0) & 1) != 0)
  {
    RawStringData = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&WindowSizes);
    isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&WindowSizes);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&WindowSizes);
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&WindowSizes);
    v13 = NumElements;
    v110 = v112;
    v111 = 0x500000000;
    if (NumElements < 6)
    {
      v21 = 0;
      if (!NumElements)
        goto LABEL_15;
      v22 = v112;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v110, v112, NumElements, 8);
      v21 = v111;
      v22 = v110;
    }
  }
  else
  {
    v21 = 0;
    RawStringData = 0;
    v22 = v112;
    v110 = v112;
    v111 = 0x500000000;
  }
  v23 = 0;
  v24 = &v22[v21];
  do
  {
    if (isSplat)
      v25 = 0;
    else
      v25 = v23;
    v24[v23++] = *(_QWORD *)(RawStringData + 8 * v25);
  }
  while (v13 != v23);
LABEL_15:
  LODWORD(v111) = v21 + v13;
  WindowSizes = (char *)mlir::mps::PoolMaxGradientOp::getStrides((mlir::mps::PoolMaxGradientOp *)&v97);
  if ((mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&WindowSizes, 8, 1, 0) & 1) != 0)
  {
    v26 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&WindowSizes);
    isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&WindowSizes);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&WindowSizes);
    v27 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&WindowSizes);
    v14 = v27;
    v28 = v109;
    v107 = v109;
    v108 = 0x500000000;
    if (v27 < 6)
    {
      v29 = 0;
      if (!v27)
        goto LABEL_26;
      v30 = v109;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v107, v109, v27, 8);
      v29 = v108;
      v30 = v107;
    }
  }
  else
  {
    v29 = 0;
    v26 = 0;
    v30 = v109;
    v107 = v109;
    v108 = 0x500000000;
    v28 = v109;
  }
  v31 = 0;
  v32 = &v30[8 * v29];
  do
  {
    if (isSplat)
      v33 = 0;
    else
      v33 = v31;
    *(_QWORD *)&v32[8 * v31++] = *(_QWORD *)(v26 + 8 * v33);
  }
  while (v14 != v31);
LABEL_26:
  LODWORD(v108) = v29 + v14;
  WindowSizes = (char *)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v97);
  if ((mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&WindowSizes, 8, 1, 0) & 1) != 0)
  {
    v34 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&WindowSizes);
    isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&WindowSizes);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&WindowSizes);
    v35 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&WindowSizes);
    v15 = v35;
    v104 = v106;
    v105 = 0x500000000;
    if (v35 < 6)
    {
      v36 = 0;
      if (!v35)
        goto LABEL_37;
      v37 = v106;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v106, v35, 8);
      v36 = v105;
      v37 = v104;
    }
  }
  else
  {
    v36 = 0;
    v34 = 0;
    v37 = v106;
    v104 = v106;
    v105 = 0x500000000;
  }
  v38 = 0;
  v39 = &v37[8 * v36];
  do
  {
    if (isSplat)
      v40 = 0;
    else
      v40 = v38;
    *(_QWORD *)&v39[8 * v38++] = *(_QWORD *)(v34 + 8 * v40);
  }
  while (v15 != v38);
LABEL_37:
  LODWORD(v105) = v36 + v15;
  WindowSizes = &v102[8];
  *(_QWORD *)v102 = 0xA00000000;
  mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v97);
  if (v41)
  {
    v96[0] = mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v97);
    v96[1] = v42;
    if (!(_BYTE)v42)
      goto LABEL_157;
    v90 = a3;
    v43 = a5;
    if ((mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)v96, 8, 1, 0) & 1) != 0)
    {
      v44 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)v96);
      isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)v96);
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v96);
      v45 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v96);
      v28 = (_BYTE *)v45;
      v46 = &v99[8];
      __src = &v99[8];
      *(_QWORD *)v99 = 0xA00000000;
      if (v45 < 0xB)
      {
        v47 = 0;
        LODWORD(v49) = 0;
        v48 = &v99[8];
        if (!v45)
          goto LABEL_59;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, &v99[8], v45, 8);
        v47 = *(_DWORD *)v99;
        v48 = (char *)__src;
      }
    }
    else
    {
      v47 = 0;
      v44 = 0;
      v48 = &v99[8];
      __src = &v99[8];
      *(_DWORD *)&v99[4] = 10;
      v46 = &v99[8];
    }
    v50 = 0;
    do
    {
      if (isSplat)
        v51 = 0;
      else
        v51 = v50;
      *(_QWORD *)&v48[8 * v47 + 8 * (_QWORD)v50++] = *(_QWORD *)(v44 + 8 * (_QWORD)v51);
    }
    while (v28 != v50);
    v49 = v47 + v28;
    *(_DWORD *)v99 = v47 + (_DWORD)v28;
    if (v48 != &v99[8])
    {
      if (WindowSizes != &v102[8])
      {
        free(WindowSizes);
        v48 = (char *)__src;
        LODWORD(v49) = *(_DWORD *)v99;
      }
      WindowSizes = v48;
      *(_DWORD *)v102 = v49;
      *(_DWORD *)&v102[4] = *(_DWORD *)&v99[4];
      __src = &v99[8];
      *(_DWORD *)&v99[4] = 0;
      goto LABEL_66;
    }
    v52 = *(unsigned int *)v102;
    if (*(_DWORD *)v102 < v49)
    {
      if (*(_DWORD *)&v102[4] >= v49)
      {
        if (*(_DWORD *)v102)
          memmove(WindowSizes, v48, 8 * *(unsigned int *)v102);
        else
          v52 = 0;
      }
      else
      {
        *(_DWORD *)v102 = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&WindowSizes, &v102[8], v49, 8);
        v52 = 0;
      }
      if (v52 != *(unsigned int *)v99)
        memcpy(&WindowSizes[8 * v52], (char *)__src + 8 * v52, 8 * *(unsigned int *)v99 - 8 * v52);
      *(_DWORD *)v102 = v49;
      v46 = v48;
      goto LABEL_66;
    }
    if ((_DWORD)v49)
      memmove(WindowSizes, v48, 8 * v49);
    v46 = v48;
LABEL_59:
    *(_DWORD *)v102 = v49;
LABEL_66:
    *(_DWORD *)v99 = 0;
    a5 = v43;
    if (__src != v46)
      free(__src);
    a3 = v90;
  }
  if ((_DWORD)v111 != 4)
  {
    v54 = 0;
    v55 = 0;
    goto LABEL_103;
  }
  __src = &v99[16];
  *(_DWORD *)&v99[16] = 0;
  *(int64x2_t *)v99 = vdupq_n_s64(4uLL);
  if (*v110 != 1 || *v107 != 1 || *v104 != 1)
    goto LABEL_77;
  if (mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v97))
  {
    v53 = 0;
    goto LABEL_78;
  }
  if (!*(_QWORD *)WindowSizes)
    v53 = *((_QWORD *)WindowSizes + 1) != 0;
  else
LABEL_77:
    v53 = 1;
LABEL_78:
  *(_BYTE *)__src = v53;
  if (v110[1] != 1 || v107[1] != 1 || v104[1] != 1)
    goto LABEL_84;
  if (mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v97))
  {
    v56 = 0;
    goto LABEL_85;
  }
  if (!*((_QWORD *)WindowSizes + 2))
    v56 = *((_QWORD *)WindowSizes + 3) != 0;
  else
LABEL_84:
    v56 = 1;
LABEL_85:
  *((_BYTE *)__src + 1) = v56;
  if (v110[2] != 1 || v107[2] != 1 || v104[2] != 1)
    goto LABEL_91;
  if (mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v97))
  {
    v57 = 0;
    goto LABEL_92;
  }
  if (!*((_QWORD *)WindowSizes + 4))
    v57 = *((_QWORD *)WindowSizes + 5) != 0;
  else
LABEL_91:
    v57 = 1;
LABEL_92:
  *((_BYTE *)__src + 2) = v57;
  if (v110[3] != 1 || v107[3] != 1 || v104[3] != 1)
    goto LABEL_99;
  if (mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v97))
  {
    v58 = __src;
    *((_BYTE *)__src + 3) = 0;
    if (!*v58)
      goto LABEL_122;
LABEL_101:
    v54 = 0;
    v55 = 0;
    if (v58 == &v99[16])
      goto LABEL_103;
    goto LABEL_102;
  }
  if (!*((_QWORD *)WindowSizes + 6))
    v59 = *((_QWORD *)WindowSizes + 7) != 0;
  else
LABEL_99:
    v59 = 1;
  v58 = __src;
  *((_BYTE *)__src + 3) = v59;
  if (*v58)
    goto LABEL_101;
  if (v59)
  {
    if (!v58[1])
    {
      v55 = 0;
      goto LABEL_123;
    }
    goto LABEL_101;
  }
LABEL_122:
  v55 = 1;
LABEL_123:
  v54 = 0x100000000;
  if (v58 != &v99[16])
LABEL_102:
    free(v58);
LABEL_103:
  if (WindowSizes != &v102[8])
    free(WindowSizes);
  if (v104 != (_QWORD *)v106)
    free(v104);
  if (v107 != (_QWORD *)v109)
    free(v107);
  if (v110 != v112)
    free(v110);
  result = 0;
  if (a3 && (v54 & 0x100000000) != 0)
  {
    if (v55)
    {
      if (a3 == 1)
      {
LABEL_120:
        v60 = a3 != 1;
        WindowSizes = &v102[8];
        if (v55 == v60)
        {
          *(_OWORD *)&v102[4] = xmmword_181240960;
          v61 = 3;
        }
        else
        {
          *(_QWORD *)&v102[4] = 5;
          if (a3 == 1)
          {
            *(_QWORD *)&v102[12] = 0x100000003;
            v61 = 2;
          }
          else
          {
            *(_QWORD *)&v102[12] = 0x300000002;
            v61 = 1;
          }
        }
        v103 = v61;
        *(_DWORD *)v102 = 4;
        v62 = *(_QWORD *)(v95 + 24);
        Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v95);
        InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v95);
        v97 = 0;
        mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v95);
        if (!v65)
          goto LABEL_131;
        Offsets = mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v95);
        if (v67)
        {
LABEL_131:
          Strides = mlir::mps::PoolMaxGradientOp::getStrides((mlir::mps::PoolMaxGradientOp *)&v95);
          v69 = mlir::mps::PoolMaxGradientOp::getWindowSizes((mlir::mps::PoolMaxGradientOp *)&v95);
          v70 = *(_QWORD *)(v95 + 24);
          LODWORD(v110) = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v95);
          InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v95);
          ResetAfter = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v95);
          LODWORD(v107) = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v95);
          __src = (void *)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v95);
          v71 = mlir::OpBuilder::create<mlir::mps::PoolMaxOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL,mlir::mps::PoolIndicesMode,mlir::TypeAttr>(a5 + 1, v70, (uint64_t *)&v104, &v93, &v94, v96, (unsigned int *)&v110, &v97, (char *)&InferredResultTypes, (char *)&ResetAfter, (unsigned int *)&v107, (uint64_t *)&__src);
          if (v55 == v60)
          {
            __src = &v99[8];
            *(_OWORD *)&v99[4] = xmmword_181240960;
            v72 = 3;
          }
          else
          {
            __src = &v99[8];
            *(_QWORD *)&v99[4] = 5;
            if (v55)
            {
              *(_QWORD *)&v99[12] = 0x300000002;
              v72 = 1;
            }
            else
            {
              *(_QWORD *)&v99[12] = 0x100000003;
              v72 = 2;
            }
          }
          v100 = v72;
          *(_DWORD *)v99 = 4;
          v110 = v112;
          v111 = 0x200000000;
          v73 = *((unsigned int *)v71 + 9);
          if ((_DWORD)v73)
            v74 = (uint64_t)v71 - 16;
          else
            v74 = 0;
          if ((_DWORD)v73)
          {
            for (i = 0; i != v73; ++i)
            {
              NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v74, i);
              v78 = v111;
              if (v111 >= (unint64_t)HIDWORD(v111))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v110, v112, v111 + 1, 8);
                v78 = v111;
              }
              v110[v78] = v77;
              v79 = (v111 + 1);
              LODWORD(v111) = v111 + 1;
            }
            v80 = v110;
          }
          else
          {
            v79 = 0;
            v80 = v112;
          }
          v81 = v95;
          mlir::ValueRange::ValueRange((unint64_t *)&v107, (uint64_t)v80, v79);
          (*((void (**)(mlir::UnitAttr **, uint64_t, _QWORD *, uint64_t))*a5 + 3))(a5, v81, v107, v108);
          if (v110 != v112)
            free(v110);
          if (__src != &v99[8])
            free(__src);
          if (WindowSizes != &v102[8])
            free(WindowSizes);
          return (mlir::GenericProgramPoint *)1;
        }
LABEL_157:
        v82 = (mlir::UnitAttr **)std::__throw_bad_optional_access[abi:nn180100]();
        return mlir::OpBuilder::create<mlir::mps::PoolMaxOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL,mlir::mps::PoolIndicesMode,mlir::TypeAttr>(v82, v83, v84, v85, v86, v87, v88, v89, a9, a10, a11, a12);
      }
    }
    else if (a3 == 2)
    {
      goto LABEL_120;
    }
    return 0;
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::PoolMaxOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL,mlir::mps::PoolIndicesMode,mlir::TypeAttr>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned int *a7, uint64_t *a8, char *a9, char *a10, unsigned int *a11, uint64_t *a12)
{
  uint64_t *Context;
  uint64_t v21;
  char v22;
  mlir::GenericProgramPoint *v23;
  mlir::GenericProgramPoint *v24;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  uint64_t v29[4];
  __int16 v30;
  _QWORD v31[40];

  v31[38] = *MEMORY[0x1E0C80C00];
  v26 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  v21 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_max", (const unsigned __int8 *)0xF, Context);
  if (!v22)
  {
    v30 = 1283;
    v29[2] = (uint64_t)"mps.pooling_max";
    v29[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v31, a2, v21);
  mlir::mps::PoolMaxOp::build(a1, (uint64_t)v31, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11, *a12);
  v23 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v31);
  if (*(_UNKNOWN **)(*((_QWORD *)v23 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PoolMaxOp,void>::id)
    v24 = v23;
  else
    v24 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v31);
  return v24;
}

mlir::GenericProgramPoint *mlir::detail::ConvertOpLayoutInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConvertPoolingInterface<mlir::mps::PoolL2NormOp>>::convertLayout(uint64_t a1, uint64_t a2, int a3, uint64_t a4, mlir::UnitAttr **a5, uint64_t a6, uint64_t a7, uint64_t a8, char *a9, char *a10)
{
  char isSplat;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v15;
  uint64_t RawStringData;
  unint64_t NumElements;
  int v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  _BYTE *v26;
  uint64_t v27;
  _BYTE *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  int v32;
  _BYTE *v33;
  uint64_t v34;
  _BYTE *v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  unint64_t v41;
  _BYTE *v42;
  unsigned int v43;
  _BYTE *v44;
  unint64_t v45;
  char *v46;
  char *v47;
  uint64_t v48;
  BOOL v49;
  BOOL v50;
  uint64_t v51;
  int v52;
  BOOL v53;
  BOOL v54;
  _BYTE *v55;
  _BOOL4 v56;
  mlir::GenericProgramPoint *result;
  int v58;
  int v59;
  uint64_t v60;
  uint64_t Input;
  uint64_t InputAttributeNames;
  char v63;
  uint64_t Offsets;
  char v65;
  uint64_t Strides;
  uint64_t WindowSizes;
  uint64_t v68;
  mlir::GenericProgramPoint *v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t i;
  uint64_t NextResultAtOffset;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  _QWORD *v78;
  uint64_t v79;
  mlir::UnitAttr **v80;
  uint64_t v81;
  uint64_t *v82;
  uint64_t *v83;
  uint64_t *v84;
  uint64_t *v85;
  unsigned int *v86;
  uint64_t *v87;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92[2];
  uint64_t v93;
  void *__src;
  _BYTE v95[20];
  int v96;
  void *__dst;
  _BYTE v98[20];
  int v99;
  void *v100;
  uint64_t v101;
  _BYTE v102[40];
  _QWORD *v103;
  uint64_t v104;
  _BYTE v105[40];
  _QWORD *v106;
  uint64_t v107;
  _QWORD v108[7];

  v108[5] = *MEMORY[0x1E0C80C00];
  v91 = a2;
  v93 = a2;
  __dst = (void *)mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v93);
  v15 = "cutableConstantDataRequest initWithCoder:]";
  if ((mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&__dst, 8, 1, 0) & 1) != 0)
  {
    RawStringData = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&__dst);
    isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&__dst);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&__dst);
    NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&__dst);
    v11 = NumElements;
    v106 = v108;
    v107 = 0x500000000;
    if (NumElements < 6)
    {
      v18 = 0;
      if (!NumElements)
        goto LABEL_12;
      v19 = v108;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v108, NumElements, 8);
      v18 = v107;
      v19 = v106;
    }
  }
  else
  {
    v18 = 0;
    RawStringData = 0;
    v19 = v108;
    v106 = v108;
    v107 = 0x500000000;
  }
  v20 = 0;
  v21 = &v19[v18];
  do
  {
    if (isSplat)
      v22 = 0;
    else
      v22 = v20;
    v21[v20++] = *(_QWORD *)(RawStringData + 8 * v22);
  }
  while (v11 != v20);
LABEL_12:
  LODWORD(v107) = v18 + v11;
  __dst = (void *)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v93);
  if ((mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&__dst, 8, 1, 0) & 1) != 0)
  {
    v23 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&__dst);
    isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&__dst);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&__dst);
    v24 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&__dst);
    v12 = v24;
    v103 = v105;
    v104 = 0x500000000;
    if (v24 < 6)
    {
      v25 = 0;
      if (!v24)
        goto LABEL_23;
      v26 = v105;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v105, v24, 8);
      v25 = v104;
      v26 = v103;
    }
  }
  else
  {
    v25 = 0;
    v23 = 0;
    v26 = v105;
    v103 = v105;
    v104 = 0x500000000;
  }
  v27 = 0;
  v28 = &v26[8 * v25];
  do
  {
    if (isSplat)
      v29 = 0;
    else
      v29 = v27;
    *(_QWORD *)&v28[8 * v27++] = *(_QWORD *)(v23 + 8 * v29);
  }
  while (v12 != v27);
LABEL_23:
  LODWORD(v104) = v25 + v12;
  __dst = (void *)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v93);
  if ((mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)&__dst, 8, 1, 0) & 1) != 0)
  {
    v30 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&__dst);
    isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&__dst);
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&__dst);
    v31 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&__dst);
    v13 = v31;
    v100 = v102;
    v101 = 0x500000000;
    if (v31 < 6)
    {
      v32 = 0;
      if (!v31)
        goto LABEL_34;
      v33 = v102;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v102, v31, 8);
      v32 = v101;
      v33 = v100;
    }
  }
  else
  {
    v32 = 0;
    v30 = 0;
    v33 = v102;
    v100 = v102;
    v101 = 0x500000000;
  }
  v34 = 0;
  v35 = &v33[8 * v32];
  do
  {
    if (isSplat)
      v36 = 0;
    else
      v36 = v34;
    *(_QWORD *)&v35[8 * v34++] = *(_QWORD *)(v30 + 8 * v36);
  }
  while (v13 != v34);
LABEL_34:
  LODWORD(v101) = v32 + v13;
  __dst = &v98[8];
  *(_QWORD *)v98 = 0xA00000000;
  mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v93);
  if (v37)
  {
    v92[0] = mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v93);
    v92[1] = v38;
    if (!(_BYTE)v38)
      goto LABEL_154;
    v39 = a3;
    if ((mlir::DenseElementsAttr::isValidIntOrFloat((mlir::DenseElementsAttr *)v92, 8, 1, 0) & 1) != 0)
    {
      v40 = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)v92);
      isSplat = mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)v92);
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)v92);
      v41 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v92);
      v15 = (char *)v41;
      v42 = &v95[8];
      __src = &v95[8];
      *(_QWORD *)v95 = 0xA00000000;
      if (v41 < 0xB)
      {
        v43 = 0;
        LODWORD(v45) = 0;
        v44 = &v95[8];
        if (!v41)
          goto LABEL_56;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, &v95[8], v41, 8);
        v43 = *(_DWORD *)v95;
        v44 = __src;
      }
    }
    else
    {
      v43 = 0;
      v40 = 0;
      v44 = &v95[8];
      __src = &v95[8];
      *(_DWORD *)&v95[4] = 10;
      v42 = &v95[8];
    }
    v46 = 0;
    do
    {
      if (isSplat)
        v47 = 0;
      else
        v47 = v46;
      *(_QWORD *)&v44[8 * v43 + 8 * (_QWORD)v46++] = *(_QWORD *)(v40 + 8 * (_QWORD)v47);
    }
    while (v15 != v46);
    v45 = v43 + v15;
    *(_DWORD *)v95 = v43 + (_DWORD)v15;
    if (v44 != &v95[8])
    {
      if (__dst != &v98[8])
      {
        free(__dst);
        v44 = __src;
        LODWORD(v45) = *(_DWORD *)v95;
      }
      __dst = v44;
      *(_DWORD *)v98 = v45;
      *(_DWORD *)&v98[4] = *(_DWORD *)&v95[4];
      __src = &v95[8];
      *(_DWORD *)&v95[4] = 0;
      goto LABEL_63;
    }
    v48 = *(unsigned int *)v98;
    if (*(_DWORD *)v98 < v45)
    {
      if (*(_DWORD *)&v98[4] >= v45)
      {
        if (*(_DWORD *)v98)
        {
          memmove(__dst, v44, 8 * *(unsigned int *)v98);
LABEL_60:
          if (v48 != *(unsigned int *)v95)
            memcpy((char *)__dst + 8 * v48, (char *)__src + 8 * v48, 8 * *(unsigned int *)v95 - 8 * v48);
          *(_DWORD *)v98 = v45;
          v42 = v44;
          goto LABEL_63;
        }
      }
      else
      {
        *(_DWORD *)v98 = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, &v98[8], v45, 8);
      }
      v48 = 0;
      goto LABEL_60;
    }
    if ((_DWORD)v45)
      memmove(__dst, v44, 8 * v45);
    v42 = v44;
LABEL_56:
    *(_DWORD *)v98 = v45;
LABEL_63:
    *(_DWORD *)v95 = 0;
    v49 = __src == v42;
    a3 = v39;
    if (!v49)
      free(__src);
  }
  if ((_DWORD)v107 != 4)
  {
    v51 = 0;
    v52 = 0;
    goto LABEL_99;
  }
  __src = &v95[16];
  *(_DWORD *)&v95[16] = 0;
  *(int64x2_t *)v95 = vdupq_n_s64(4uLL);
  if (*v106 != 1 || *v103 != 1 || *(_QWORD *)v100 != 1)
    goto LABEL_73;
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v93))
  {
    v50 = 0;
    goto LABEL_74;
  }
  if (!*(_QWORD *)__dst)
    v50 = *((_QWORD *)__dst + 1) != 0;
  else
LABEL_73:
    v50 = 1;
LABEL_74:
  *(_BYTE *)__src = v50;
  if (v106[1] != 1 || v103[1] != 1 || *((_QWORD *)v100 + 1) != 1)
    goto LABEL_80;
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v93))
  {
    v53 = 0;
    goto LABEL_81;
  }
  if (!*((_QWORD *)__dst + 2))
    v53 = *((_QWORD *)__dst + 3) != 0;
  else
LABEL_80:
    v53 = 1;
LABEL_81:
  *((_BYTE *)__src + 1) = v53;
  if (v106[2] != 1 || v103[2] != 1 || *((_QWORD *)v100 + 2) != 1)
    goto LABEL_87;
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v93))
  {
    v54 = 0;
    goto LABEL_88;
  }
  if (!*((_QWORD *)__dst + 4))
    v54 = *((_QWORD *)__dst + 5) != 0;
  else
LABEL_87:
    v54 = 1;
LABEL_88:
  *((_BYTE *)__src + 2) = v54;
  if (v106[3] != 1 || v103[3] != 1 || *((_QWORD *)v100 + 3) != 1)
    goto LABEL_95;
  if (mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v93))
  {
    v55 = __src;
    *((_BYTE *)__src + 3) = 0;
    if (!*v55)
      goto LABEL_118;
LABEL_97:
    v51 = 0;
    v52 = 0;
    if (v55 == &v95[16])
      goto LABEL_99;
    goto LABEL_98;
  }
  if (!*((_QWORD *)__dst + 6))
    v56 = *((_QWORD *)__dst + 7) != 0;
  else
LABEL_95:
    v56 = 1;
  v55 = __src;
  *((_BYTE *)__src + 3) = v56;
  if (*v55)
    goto LABEL_97;
  if (v56)
  {
    if (!v55[1])
    {
      v52 = 0;
      goto LABEL_119;
    }
    goto LABEL_97;
  }
LABEL_118:
  v52 = 1;
LABEL_119:
  v51 = 0x100000000;
  if (v55 != &v95[16])
LABEL_98:
    free(v55);
LABEL_99:
  if (__dst != &v98[8])
    free(__dst);
  if (v100 != v102)
    free(v100);
  if (v103 != (_QWORD *)v105)
    free(v103);
  if (v106 != v108)
    free(v106);
  result = 0;
  if (a3 && (v51 & 0x100000000) != 0)
  {
    if (v52)
    {
      if (a3 == 1)
        goto LABEL_111;
    }
    else if (a3 == 2)
    {
LABEL_111:
      v58 = a3 != 1;
      __dst = &v98[8];
      if (v52 == v58)
      {
        *(_OWORD *)&v98[4] = xmmword_181240960;
        v59 = 3;
      }
      else
      {
        *(_QWORD *)&v98[4] = 5;
        if (a3 == 1)
        {
          *(_QWORD *)&v98[12] = 0x100000003;
          v59 = 2;
        }
        else
        {
          *(_QWORD *)&v98[12] = 0x300000002;
          v59 = 1;
        }
      }
      v99 = v59;
      *(_DWORD *)v98 = 4;
      v60 = *(_QWORD *)(v91 + 24);
      Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v91);
      InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v91);
      v93 = 0;
      mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v91);
      if (!v63)
        goto LABEL_127;
      Offsets = mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v91);
      if (v65)
      {
LABEL_127:
        Strides = mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v91);
        WindowSizes = mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v91);
        v68 = *(_QWORD *)(v91 + 24);
        LODWORD(__src) = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v91);
        LOBYTE(v106) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v91);
        LOBYTE(v103) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v91);
        v69 = mlir::OpBuilder::create<mlir::mps::PoolL2NormOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL>(a5 + 1, v68, (uint64_t *)&v100, &v89, &v90, v92, (unsigned int *)&__src, &v93, (char *)&v106, (char *)&v103);
        if (v52 == v58)
        {
          __src = &v95[8];
          *(_OWORD *)&v95[4] = xmmword_181240960;
          v70 = 3;
        }
        else
        {
          __src = &v95[8];
          *(_QWORD *)&v95[4] = 5;
          if (v52)
          {
            *(_QWORD *)&v95[12] = 0x300000002;
            v70 = 1;
          }
          else
          {
            *(_QWORD *)&v95[12] = 0x100000003;
            v70 = 2;
          }
        }
        v96 = v70;
        *(_DWORD *)v95 = 4;
        v106 = v108;
        v107 = 0x200000000;
        v71 = *((unsigned int *)v69 + 9);
        if ((_DWORD)v71)
          v72 = (uint64_t)v69 - 16;
        else
          v72 = 0;
        if ((_DWORD)v71)
        {
          for (i = 0; i != v71; ++i)
          {
            NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v72, i);
            v76 = v107;
            if (v107 >= (unint64_t)HIDWORD(v107))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v108, v107 + 1, 8);
              v76 = v107;
            }
            v106[v76] = v75;
            v77 = (v107 + 1);
            LODWORD(v107) = v107 + 1;
          }
          v78 = v106;
        }
        else
        {
          v77 = 0;
          v78 = v108;
        }
        v79 = v91;
        mlir::ValueRange::ValueRange((unint64_t *)&v103, (uint64_t)v78, v77);
        (*((void (**)(mlir::UnitAttr **, uint64_t, _QWORD *, uint64_t))*a5 + 3))(a5, v79, v103, v104);
        if (v106 != v108)
          free(v106);
        if (__src != &v95[8])
          free(__src);
        if (__dst != &v98[8])
          free(__dst);
        return (mlir::GenericProgramPoint *)1;
      }
LABEL_154:
      v80 = (mlir::UnitAttr **)std::__throw_bad_optional_access[abi:nn180100]();
      return mlir::OpBuilder::create<mlir::mps::PoolL2NormOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL>(v80, v81, v82, v83, v84, v85, v86, v87, a9, a10);
    }
    return 0;
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::PoolL2NormOp,mlir::Value &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyle,mlir::DenseIntElementsAttr &,BOOL,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned int *a7, uint64_t *a8, char *a9, char *a10)
{
  uint64_t *Context;
  uint64_t v19;
  char v20;
  mlir::GenericProgramPoint *v21;
  mlir::GenericProgramPoint *v22;
  uint64_t v24;
  const char *v25;
  __int16 v26;
  uint64_t v27[4];
  __int16 v28;
  _QWORD v29[40];

  v29[38] = *MEMORY[0x1E0C80C00];
  v24 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
  v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_l2_norm", (const unsigned __int8 *)0x13, Context);
  if (!v20)
  {
    v28 = 1283;
    v27[2] = (uint64_t)"mps.pooling_l2_norm";
    v27[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v26 = 259;
    llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
    llvm::report_fatal_error((llvm::Twine *)v29, 1);
  }
  mlir::OperationState::OperationState(v29, a2, v19);
  mlir::mps::PoolL2NormOp::build(a1, (uint64_t)v29, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10);
  v21 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v29);
  if (*(_UNKNOWN **)(*((_QWORD *)v21 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PoolL2NormOp,void>::id)
    v22 = v21;
  else
    v22 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v29);
  return v22;
}

_QWORD *mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(_QWORD *a1, _QWORD *a2)
{
  _QWORD *result;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD v11[3];
  _QWORD *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  result = operator new(0x68uLL);
  v5 = result;
  v6 = (_QWORD *)a2[3];
  if (v6)
  {
    if (v6 == a2)
    {
      v12 = v11;
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v11);
      v6 = v12;
    }
    else
    {
      v12 = (_QWORD *)a2[3];
      a2[3] = 0;
    }
  }
  else
  {
    v12 = 0;
  }
  v5[3] = "mps";
  v5[4] = 3;
  v5[2] = 0x300000001;
  *v5 = off_1E0E524D8;
  v5[1] = v5 + 3;
  if (!v6)
  {
    v5[12] = 0;
    goto LABEL_15;
  }
  if (v6 != v11)
  {
    v5[12] = v6;
    goto LABEL_15;
  }
  v5[12] = v5 + 9;
  (*(void (**)(_QWORD *))(v11[0] + 24))(v11);
  result = v12;
  if (v12 == v11)
  {
    v7 = 4;
    result = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_15;
    v7 = 5;
  }
  result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v7))();
LABEL_15:
  v10 = v5;
  v8 = (_QWORD *)a1[4];
  if ((unint64_t)v8 >= a1[5])
  {
    v9 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 3, (uint64_t *)&v10);
    result = v10;
    a1[4] = v9;
    v10 = 0;
    if (result)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
  }
  else
  {
    *v8 = v5;
    a1[4] = v8 + 1;
  }
  return result;
}

void mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>)::Extension::~Extension(mlir::DialectExtensionBase *this)
{
  char *v2;
  char *v3;
  uint64_t v4;

  *(_QWORD *)this = off_1E0E524D8;
  v2 = (char *)this + 72;
  v3 = (char *)*((_QWORD *)this + 12);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  mlir::DialectExtensionBase::~DialectExtensionBase(this);
}

{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;

  *(_QWORD *)this = off_1E0E524D8;
  v2 = (char *)this + 72;
  v3 = (char *)*((_QWORD *)this + 12);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  mlir::DialectExtensionBase::~DialectExtensionBase(this);
  operator delete(v5);
}

uint64_t mlir::DialectExtension<void mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>)::Extension,mlir::mps::MPSDialect>::apply(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 32))(a1, a2, *a3);
}

uint64_t mlir::DialectExtension<void mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>)::Extension,mlir::mps::MPSDialect>::clone@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  void **v7;
  unsigned int v8;
  unsigned int v9;
  _QWORD *v10;
  uint64_t result;

  v4 = operator new(0x68uLL);
  v5 = v4;
  *v4 = off_1E0E2BD48;
  v6 = v4 + 3;
  v4[1] = v4 + 3;
  v7 = (void **)(v4 + 1);
  v4[2] = 0x300000000;
  if (v4 == (_QWORD *)a1)
    goto LABEL_9;
  v8 = *(_DWORD *)(a1 + 16);
  if (!v8)
    goto LABEL_9;
  if (v8 < 4)
  {
    v9 = *(_DWORD *)(a1 + 16);
    goto LABEL_7;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v4 + 1), v6, *(unsigned int *)(a1 + 16), 16);
  v9 = *(_DWORD *)(a1 + 16);
  if (v9)
  {
    v6 = *v7;
LABEL_7:
    memcpy(v6, *(const void **)(a1 + 8), 16 * v9);
  }
  *((_DWORD *)v5 + 4) = v8;
LABEL_9:
  *v5 = off_1E0E524D8;
  v10 = v5 + 9;
  result = *(_QWORD *)(a1 + 96);
  if (result)
  {
    if (result == a1 + 72)
    {
      v5[12] = v10;
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
    }
    else
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)result + 16))(result, v10);
      v5[12] = result;
    }
  }
  else
  {
    v5[12] = 0;
  }
  *a2 = v5;
  return result;
}

uint64_t mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>)::Extension::apply(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v5 = a3;
  v6 = a2;
  v3 = *(_QWORD *)(a1 + 96);
  if (!v3)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    JUMPOUT(0x1804F1CE0);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v6, &v5);
}

_QWORD *std::__function::__func<void (*)(mlir::MLIRContext *,mlir::mps::MPSDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::mps::MPSDialect *)>,void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &unk_1E0E4FF00;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void (*)(mlir::MLIRContext *,mlir::mps::MPSDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::mps::MPSDialect *)>,void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &unk_1E0E4FF00;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void (*)(mlir::MLIRContext *,mlir::mps::MPSDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::mps::MPSDialect *)>,void ()(mlir::MLIRContext *,mlir::mps::MPSDialect *)>::operator()(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 8))(*a2, *a3);
}

void **mlir::mps::registerMapDynamicShapeOpExternalModels(mlir::mps *this, mlir::DialectRegistry *a2)
{
  void **v3;
  uint64_t v4;
  void **result;
  uint64_t v6;
  void *v7;
  void (*v8)(uint64_t *);
  void **v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v7 = &unk_1E0E4FF00;
  v8 = mlir::mps::registerMapDynamicShapeOpExternalModels(mlir::DialectRegistry &)::$_0::__invoke;
  v9 = &v7;
  mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(this, &v7);
  v3 = v9;
  if (v9 == &v7)
  {
    v4 = 4;
    v3 = &v7;
  }
  else
  {
    if (!v9)
      goto LABEL_6;
    v4 = 5;
  }
  (*((void (**)(void))*v3 + v4))();
LABEL_6:
  v7 = &unk_1E0E4FFA0;
  v8 = mlir::mps::registerMapDynamicShapeOpExternalModels(mlir::DialectRegistry &)::$_1::__invoke;
  v9 = &v7;
  mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(this, &v7);
  result = v9;
  if (v9 == &v7)
  {
    v6 = 4;
    result = &v7;
  }
  else
  {
    if (!v9)
      return result;
    v6 = 5;
  }
  return (void **)(*((uint64_t (**)(void))*result + v6))();
}

uint64_t mlir::MapDynamicShapeOpInterface::mapDynamicShape(mlir::MapDynamicShapeOpInterface *this)
{
  return (**((uint64_t (***)(_QWORD, _QWORD))this + 1))(*((_QWORD *)this + 1), *(_QWORD *)this);
}

void mlir::mps::registerMapDynamicShapeOpExternalModels(mlir::DialectRegistry &)::$_0::__invoke(uint64_t *a1)
{
  _QWORD *v2;
  char v3;
  _QWORD *v4;
  void *v5;
  uint64_t Values;
  __guard v7;
  _QWORD *v8;
  __guard v9;
  _QWORD *v10;
  char v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  __guard v15;
  _QWORD *v16;
  __guard v17;
  const char *v18;
  _QWORD *v19;
  char v20;
  _QWORD *v21;
  void *v22;
  uint64_t v23;
  __guard v24;
  _QWORD *v25;
  __guard v26;
  const char *v27;
  _QWORD *v28;
  char v29;
  _QWORD *v30;
  void *v31;
  uint64_t v32;
  __guard v33;
  _QWORD *v34;
  __guard v35;
  _QWORD *v36;
  char v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  __guard v41;
  _QWORD *v42;
  __guard v43;
  _QWORD *v44;
  char v45;
  _QWORD *v46;
  void *v47;
  uint64_t v48;
  __guard v49;
  _QWORD *v50;
  __guard v51;
  _QWORD *v52;
  char v53;
  _QWORD *v54;
  void *v55;
  uint64_t v56;
  __guard v57;
  _QWORD *v58;
  __guard v59;
  _QWORD *v60;
  char v61;
  _QWORD *v62;
  void *v63;
  uint64_t v64;
  __guard v65;
  _QWORD *v66;
  __guard v67;
  _QWORD *v68;
  char v69;
  _QWORD *v70;
  void *v71;
  uint64_t v72;
  __guard v73;
  _QWORD *v74;
  __guard v75;
  _QWORD *v76;
  char v77;
  _QWORD *v78;
  void *v79;
  uint64_t v80;
  __guard v81;
  _QWORD *v82;
  __guard v83;
  const char *v84;
  _QWORD *v85;
  char v86;
  _QWORD *v87;
  void *v88;
  uint64_t v89;
  __guard v90;
  _QWORD *v91;
  __guard v92;
  const char *v93;
  _QWORD *v94;
  char v95;
  _QWORD *v96;
  void *v97;
  uint64_t v98;
  __guard v99;
  _QWORD *v100;
  __guard v101;
  const char *v102;
  _QWORD *v103;
  char v104;
  _QWORD *v105;
  void *v106;
  uint64_t v107;
  __guard v108;
  _QWORD *v109;
  __guard v110;
  _QWORD *v111;
  char v112;
  _QWORD *v113;
  void *v114;
  uint64_t v115;
  __guard v116;
  _QWORD *v117;
  __guard v118;
  _QWORD *v119;
  char v120;
  _QWORD *v121;
  void *v122;
  uint64_t v123;
  __guard v124;
  _QWORD *v125;
  __guard v126;
  _QWORD *v127;
  char v128;
  _QWORD *v129;
  void *v130;
  uint64_t v131;
  __guard v132;
  _QWORD *v133;
  __guard v134;
  _QWORD *v135;
  char v136;
  _QWORD *v137;
  void *v138;
  uint64_t v139;
  __guard v140;
  _QWORD *v141;
  __guard v142;
  uint64_t v143;
  const char *v144;
  __int16 v145;
  const char *v146;
  const char *v147;
  uint64_t v148;
  __int16 v149;
  _QWORD v150[5];

  v2 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.relu", (const unsigned __int8 *)8, a1);
  if (!v3)
  {
    v149 = 1283;
    v146 = "Attempting to attach an interface to an unregistered operation ";
    v147 = "mps.relu";
    v143 = 8;
    goto LABEL_79;
  }
  v4 = v2;
  v5 = (void *)v2[2];
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v2[1];
    Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v5 = (void *)v4[2];
  }
  else
  {
    Values = v2[3];
  }
  v7 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(Values, (uint64_t)v5, v7);
  v8 = malloc(8uLL);
  v9 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v4 + 4), v9, v8);
  v10 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, a1);
  if (!v11)
  {
    v149 = 1283;
    v146 = "Attempting to attach an interface to an unregistered operation ";
    v147 = "mps.add";
    v143 = 7;
    goto LABEL_79;
  }
  v12 = v10;
  v13 = (void *)v10[2];
  if (v13 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v10[1];
    v14 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v13 = (void *)v12[2];
  }
  else
  {
    v14 = v10[3];
  }
  v15 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v14, (uint64_t)v13, v15);
  v16 = malloc(8uLL);
  v17 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v12 + 4), v17, v16);
  v18 = "mps.multiply";
  v19 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, a1);
  if (!v20)
    goto LABEL_70;
  v21 = v19;
  v22 = (void *)v19[2];
  if (v22 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v19[1];
    v23 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v22 = (void *)v21[2];
  }
  else
  {
    v23 = v19[3];
  }
  v24 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v23, (uint64_t)v22, v24);
  v25 = malloc(8uLL);
  v26 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v21 + 4), v26, v25);
  v27 = "mps.gather";
  v28 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gather", (const unsigned __int8 *)0xA, a1);
  if (!v29)
    goto LABEL_71;
  v30 = v28;
  v31 = (void *)v28[2];
  if (v31 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v28[1];
    v32 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v31 = (void *)v30[2];
  }
  else
  {
    v32 = v28[3];
  }
  v33 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v32, (uint64_t)v31, v33);
  v34 = malloc(8uLL);
  v35 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v30 + 4), v35, v34);
  v27 = "mps.matmul";
  v36 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matmul", (const unsigned __int8 *)0xA, a1);
  if (!v37)
  {
LABEL_71:
    v149 = 1283;
    v146 = "Attempting to attach an interface to an unregistered operation ";
    v147 = v27;
    v143 = 10;
    goto LABEL_79;
  }
  v38 = v36;
  v39 = (void *)v36[2];
  if (v39 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v36[1];
    v40 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v39 = (void *)v38[2];
  }
  else
  {
    v40 = v36[3];
  }
  v41 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v40, (uint64_t)v39, v41);
  v42 = malloc(8uLL);
  v43 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v38 + 4), v43, v42);
  v18 = "mps.exponent";
  v44 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.exponent", (const unsigned __int8 *)0xC, a1);
  if (!v45)
    goto LABEL_70;
  v46 = v44;
  v47 = (void *)v44[2];
  if (v47 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v44[1];
    v48 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v47 = (void *)v46[2];
  }
  else
  {
    v48 = v44[3];
  }
  v49 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v48, (uint64_t)v47, v49);
  v50 = malloc(8uLL);
  v51 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v46 + 4), v51, v50);
  v18 = "mps.negative";
  v52 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.negative", (const unsigned __int8 *)0xC, a1);
  if (!v53)
    goto LABEL_70;
  v54 = v52;
  v55 = (void *)v52[2];
  if (v55 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v52[1];
    v56 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v55 = (void *)v54[2];
  }
  else
  {
    v56 = v52[3];
  }
  v57 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v56, (uint64_t)v55, v57);
  v58 = malloc(8uLL);
  v59 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v54 + 4), v59, v58);
  v18 = "mps.subtract";
  v60 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.subtract", (const unsigned __int8 *)0xC, a1);
  if (!v61)
    goto LABEL_70;
  v62 = v60;
  v63 = (void *)v60[2];
  if (v63 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v60[1];
    v64 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v63 = (void *)v62[2];
  }
  else
  {
    v64 = v60[3];
  }
  v65 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v64, (uint64_t)v63, v65);
  v66 = malloc(8uLL);
  v67 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v62 + 4), v67, v66);
  v68 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal", (const unsigned __int8 *)0xE, a1);
  if (!v69)
  {
    v149 = 1283;
    v146 = "Attempting to attach an interface to an unregistered operation ";
    v147 = "mps.reciprocal";
    v143 = 14;
    goto LABEL_79;
  }
  v70 = v68;
  v71 = (void *)v68[2];
  if (v71 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v68[1];
    v72 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v71 = (void *)v70[2];
  }
  else
  {
    v72 = v68[3];
  }
  v73 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v72, (uint64_t)v71, v73);
  v74 = malloc(8uLL);
  v75 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v70 + 4), v75, v74);
  v18 = "mps.identity";
  v76 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.identity", (const unsigned __int8 *)0xC, a1);
  if (!v77)
  {
LABEL_70:
    v149 = 1283;
    v146 = "Attempting to attach an interface to an unregistered operation ";
    v147 = v18;
    v143 = 12;
    goto LABEL_79;
  }
  v78 = v76;
  v79 = (void *)v76[2];
  if (v79 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v76[1];
    v80 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v79 = (void *)v78[2];
  }
  else
  {
    v80 = v76[3];
  }
  v81 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v80, (uint64_t)v79, v81);
  v82 = malloc(8uLL);
  v83 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v78 + 4), v83, v82);
  v84 = "mps.permute";
  v85 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.permute", (const unsigned __int8 *)0xB, a1);
  if (!v86)
    goto LABEL_72;
  v87 = v85;
  v88 = (void *)v85[2];
  if (v88 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v85[1];
    v89 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v88 = (void *)v87[2];
  }
  else
  {
    v89 = v85[3];
  }
  v90 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v89, (uint64_t)v88, v90);
  v91 = malloc(8uLL);
  v92 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v87 + 4), v92, v91);
  v93 = "mps.read_variable";
  v94 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.read_variable", (const unsigned __int8 *)0x11, a1);
  if (!v95)
    goto LABEL_73;
  v96 = v94;
  v97 = (void *)v94[2];
  if (v97 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v94[1];
    v98 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v97 = (void *)v96[2];
  }
  else
  {
    v98 = v94[3];
  }
  v99 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v98, (uint64_t)v97, v99);
  v100 = malloc(8uLL);
  v101 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v96 + 4), v101, v100);
  v102 = "mps.variable_from_tensor";
  v103 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.variable_from_tensor", (const unsigned __int8 *)0x18, a1);
  if (!v104)
    goto LABEL_74;
  v105 = v103;
  v106 = (void *)v103[2];
  if (v106 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v103[1];
    v107 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v106 = (void *)v105[2];
  }
  else
  {
    v107 = v103[3];
  }
  v108 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v107, (uint64_t)v106, v108);
  v109 = malloc(8uLL);
  v110 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v105 + 4), v110, v109);
  v84 = "mps.reshape";
  v111 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, a1);
  if (!v112)
  {
LABEL_72:
    v149 = 1283;
    v146 = "Attempting to attach an interface to an unregistered operation ";
    v147 = v84;
    v143 = 11;
    goto LABEL_79;
  }
  v113 = v111;
  v114 = (void *)v111[2];
  if (v114 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v111[1];
    v115 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v114 = (void *)v113[2];
  }
  else
  {
    v115 = v111[3];
  }
  v116 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v115, (uint64_t)v114, v116);
  v117 = malloc(8uLL);
  v118 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v113 + 4), v118, v117);
  v93 = "mps.strided_slice";
  v119 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.strided_slice", (const unsigned __int8 *)0x11, a1);
  if (!v120)
  {
LABEL_73:
    v149 = 1283;
    v146 = "Attempting to attach an interface to an unregistered operation ";
    v147 = v93;
    v143 = 17;
    goto LABEL_79;
  }
  v121 = v119;
  v122 = (void *)v119[2];
  if (v122 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v119[1];
    v123 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v122 = (void *)v121[2];
  }
  else
  {
    v123 = v119[3];
  }
  v124 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v123, (uint64_t)v122, v124);
  v125 = malloc(8uLL);
  v126 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v121 + 4), v126, v125);
  v102 = "mps.strided_slice_update";
  v127 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.strided_slice_update", (const unsigned __int8 *)0x18, a1);
  if (!v128)
  {
LABEL_74:
    v149 = 1283;
    v146 = "Attempting to attach an interface to an unregistered operation ";
    v147 = v102;
    v143 = 24;
    goto LABEL_79;
  }
  v129 = v127;
  v130 = (void *)v127[2];
  if (v130 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v127[1];
    v131 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v130 = (void *)v129[2];
  }
  else
  {
    v131 = v127[3];
  }
  v132 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v131, (uint64_t)v130, v132);
  v133 = malloc(8uLL);
  v134 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v129 + 4), v134, v133);
  v135 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, a1);
  if (!v136)
  {
    v149 = 1283;
    v146 = "Attempting to attach an interface to an unregistered operation ";
    v147 = "mps.transpose";
    v143 = 13;
LABEL_79:
    v148 = v143;
    v144 = ".";
    v145 = 259;
    llvm::operator+((uint64_t *)&v146, (uint64_t *)&v144, (uint64_t)v150);
    llvm::report_fatal_error((llvm::Twine *)v150, 1);
  }
  v137 = v135;
  v138 = (void *)v135[2];
  if (v138 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v150[0] = v135[1];
    v139 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v150);
    v138 = (void *)v137[2];
  }
  else
  {
    v139 = v135[3];
  }
  v140 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v139, (uint64_t)v138, v140);
  v141 = malloc(8uLL);
  v142 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v137 + 4), v142, v141);
}

__guard mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>()
{
  unsigned __int8 v0;
  __guard *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  if ((v0 & 1) == 0)
  {
    if (v3)
    {
      v11 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MapDynamicShapeOpInterface]";
      v12 = 82;
      v4 = llvm::StringRef::find((uint64_t *)&v11, "DesiredTypeName = ", 0x12uLL, 0);
      if (v12 >= v4)
        v5 = v4;
      else
        v5 = v12;
      v6 = &v11[v5];
      v7 = v12 - v5;
      if (v12 - v5 >= 0x12)
        v8 = 18;
      else
        v8 = v12 - v5;
      v9 = v7 - v8;
      if (v9 >= v9 - 1)
        v10 = v9 - 1;
      else
        v10 = v9;
      mlir::detail::TypeIDResolver<mlir::MapDynamicShapeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v6[v8], v10);
    }
  }
  return v1[126];
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapReluOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *a1@<X1>, uint64_t a2@<X8>)
{
}

void mlir::`anonymous namespace'::mapDynamicShapeNAry(mlir::_anonymous_namespace_ *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *ArgAttrsAttr;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  _BYTE *v13;
  uint64_t v14;
  BOOL v15;
  unsigned int v16;
  void *v17;
  int v18;
  unsigned int v19;
  void *__dst;
  uint64_t v21;
  _BYTE v22[48];
  void *__src;
  uint64_t v24;
  _QWORD v25[7];

  v25[6] = *MEMORY[0x1E0C80C00];
  __src = v25;
  v24 = 0x600000000;
  if ((*((_BYTE *)this + 46) & 0x80) == 0)
    goto LABEL_18;
  v4 = *((unsigned int *)this + 17);
  if (!(_DWORD)v4)
    goto LABEL_17;
  v5 = 0;
  v6 = *((_QWORD *)this + 9);
  do
  {
    __dst = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(*(_QWORD *)(v6 + 32 * v5 + 24) + 8) & 0xFFFFFFFFFFFFFFF8));
    v21 = v8;
    if (!__dst)
      goto LABEL_7;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&__dst))
    {
      ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__dst);
      if (!v10)
        goto LABEL_7;
      v11 = 8 * v10;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v11 -= 8;
        if (!v11)
          goto LABEL_7;
      }
    }
    v7 = v24;
    if (v24 >= (unint64_t)HIDWORD(v24))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v25, v24 + 1, 8);
      v7 = v24;
    }
    *((_QWORD *)__src + v7) = v5;
    LODWORD(v24) = v24 + 1;
LABEL_7:
    ++v5;
  }
  while (v5 != v4);
  v12 = v24;
  if ((_DWORD)v24)
  {
    v13 = v22;
    __dst = v22;
    v21 = 0x600000000;
    goto LABEL_22;
  }
LABEL_17:
  if (HIDWORD(v24))
  {
LABEL_18:
    v14 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v25, 1uLL, 8);
    v14 = v24;
  }
  *((_QWORD *)__src + v14) = -1;
  v13 = v22;
  __dst = v22;
  v21 = 0x600000000;
  v15 = __CFADD__((_DWORD)v24, 1);
  v12 = v24 + 1;
  LODWORD(v24) = v24 + 1;
  if (v15)
  {
    v12 = 0;
  }
  else
  {
LABEL_22:
    if (v12 < 7)
    {
      v16 = v12;
LABEL_26:
      memcpy(v13, __src, 8 * v16);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v22, v12, 8);
      v16 = v24;
      if ((_DWORD)v24)
      {
        v13 = __dst;
        goto LABEL_26;
      }
    }
    LODWORD(v21) = v12;
  }
  v17 = (void *)(a2 + 32);
  *(_QWORD *)(a2 + 16) = a2 + 32;
  *(_QWORD *)a2 = a2 + 16;
  *(_QWORD *)(a2 + 8) = 0x100000000;
  *(_QWORD *)(a2 + 24) = 0x600000000;
  v18 = 1;
  if ((void **)(a2 + 16) != &__dst && v12)
  {
    if (v12 < 7)
    {
      v19 = v12;
LABEL_34:
      memcpy(v17, __dst, 8 * v19);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 16, (void *)(a2 + 32), v12, 8);
      v19 = v21;
      if ((_DWORD)v21)
      {
        v17 = *(void **)(a2 + 16);
        goto LABEL_34;
      }
    }
    *(_DWORD *)(a2 + 24) = v12;
    v18 = *(_DWORD *)(a2 + 8) + 1;
  }
  *(_DWORD *)(a2 + 8) = v18;
  if (__dst != v22)
    free(__dst);
  if (__src != v25)
    free(__src);
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapAddOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapMultiplyOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapGatherOpInterface>::mapDynamicShape(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  _QWORD *ArgAttrsAttr;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int Count;
  uint64_t DefiningOp;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unsigned int v44;
  _BYTE *v45;
  _BYTE *v46;
  void *v47;
  int v48;
  unsigned int v49;
  _QWORD v50[2];
  _QWORD v51[2];
  uint64_t v52;
  void *__src;
  uint64_t v54;
  _BYTE v55[48];
  void *__b;
  uint64_t v57;
  unsigned int v58;
  void *v59;
  uint64_t v60;
  _BYTE v61[48];
  _QWORD v62[2];
  _QWORD v63[7];

  v63[6] = *MEMORY[0x1E0C80C00];
  v52 = a1;
  if (*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v52) + 8) >= 8uLL)
    mlir::TypeID::get<mlir::ShapedType>();
  v3 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v52) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3)
    goto LABEL_12;
  v4 = *v3;
  v5 = mlir::TypeID::get<mlir::ShapedType>();
  v6 = *(unsigned int *)(v4 + 16);
  if (!(_DWORD)v6)
    goto LABEL_12;
  v7 = *(_QWORD **)(v4 + 8);
  v8 = &v7[2 * v6];
  do
  {
    v9 = v6 >> 1;
    v10 = &v7[2 * (v6 >> 1)];
    v12 = *v10;
    v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5)
      v7 = v11;
    else
      v6 = v9;
  }
  while (v6);
  if (v7 != v8 && *v7 == v5)
    v13 = v7[1];
  else
LABEL_12:
    v13 = 0;
  v51[0] = v3;
  v51[1] = v13;
  v14 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v52) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14)
    goto LABEL_22;
  v15 = *v14;
  v16 = mlir::TypeID::get<mlir::ShapedType>();
  v17 = *(unsigned int *)(v15 + 16);
  if (!(_DWORD)v17)
    goto LABEL_22;
  v18 = *(_QWORD **)(v15 + 8);
  v19 = &v18[2 * v17];
  do
  {
    v20 = v17 >> 1;
    v21 = &v18[2 * (v17 >> 1)];
    v23 = *v21;
    v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16)
      v18 = v22;
    else
      v17 = v20;
  }
  while (v17);
  if (v18 != v19 && *v18 == v16)
    v24 = v18[1];
  else
LABEL_22:
    v24 = 0;
  v50[0] = v14;
  v50[1] = v24;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v51)
    && mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v50))
  {
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v50))
    {
      ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50);
      if (!v26)
        goto LABEL_38;
      v27 = 8 * v26;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v27 -= 8;
        if (!v27)
          goto LABEL_38;
      }
    }
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v51);
    v29 = v28;
    Count = mlir::pdl_interp::CheckOperandCountOp::getCount((mlir::pdl_interp::CheckOperandCountOp *)&v52);
    v62[0] = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v52);
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v62);
    if (DefiningOp)
    {
      v32 = DefiningOp;
      v33 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v32 + 48) + 32))(*(_QWORD *)(v32 + 48), v33))
      {
        __b = &v58;
        v57 = 0x100000000;
        mlir::Operation::fold(v32, 0, 0, (uint64_t)&__b);
        v34 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)__b & 0xFFFFFFFFFFFFFFF8));
        v36 = v35;
        if (__b != &v58)
          free(__b);
        if (v34)
        {
          v62[0] = v63;
          v62[1] = 0x600000000;
          mlir::getIntValues<long long>((uint64_t)v34, v36, (uint64_t)v62, 1);
          v37 = *(_QWORD *)v62[0];
          __b = 0;
          v57 = 0;
          v58 = 0;
          v59 = v61;
          v60 = 0x600000000;
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50);
          if (v38 >= 1)
          {
            v39 = v38;
            v40 = 0;
            v41 = v37 + Count;
            v42 = v41 + v29;
            do
            {
              if (*(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50)
                             + 8 * v40) == 0x8000000000000000)
              {
                __src = (void *)(v40 >= v41 && v40 <= v42);
                llvm::SetVector<long long,llvm::SmallVector<long long,6u>,llvm::DenseSet<long long,llvm::DenseMapInfo<long long,void>>,2u>::insert((uint64_t)&__b, (uint64_t *)&__src);
              }
              ++v40;
            }
            while (v39 != v40);
          }
          if (!(_DWORD)v60)
          {
            __src = (void *)-1;
            llvm::SetVector<long long,llvm::SmallVector<long long,6u>,llvm::DenseSet<long long,llvm::DenseMapInfo<long long,void>>,2u>::insert((uint64_t)&__b, (uint64_t *)&__src);
          }
          if (v57)
          {
            if (v58 <= 4 * (int)v57 || v58 < 0x41)
            {
              if (v58)
                memset_pattern16(__b, &unk_1812362E0, 8 * v58);
              v57 = 0;
            }
            else
            {
              llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::shrink_and_clear((uint64_t)&__b);
            }
          }
          __src = v55;
          v54 = 0x600000000;
          v43 = v60;
          if (!(_DWORD)v60)
          {
LABEL_67:
            v47 = (void *)(a2 + 32);
            *(_QWORD *)(a2 + 16) = a2 + 32;
            *(_QWORD *)a2 = a2 + 16;
            *(_QWORD *)(a2 + 8) = 0x100000000;
            *(_QWORD *)(a2 + 24) = 0x600000000;
            v48 = 1;
            if ((void **)(a2 + 16) == &__src || !(_DWORD)v43)
            {
LABEL_75:
              *(_DWORD *)(a2 + 8) = v48;
              if (__src != v55)
                free(__src);
              if (v59 != v61)
                free(v59);
              llvm::deallocate_buffer((llvm *)__b, (void *)(8 * v58));
            }
            if (v43 < 7)
            {
              v49 = v43;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 16, (void *)(a2 + 32), v43, 8);
              v49 = v54;
              if (!(_DWORD)v54)
              {
LABEL_74:
                *(_DWORD *)(a2 + 24) = v43;
                v48 = *(_DWORD *)(a2 + 8) + 1;
                goto LABEL_75;
              }
              v47 = *(void **)(a2 + 16);
            }
            memcpy(v47, __src, 8 * v49);
            goto LABEL_74;
          }
          if (v59 != v61)
          {
            __src = v59;
            v54 = v60;
            v59 = v61;
            HIDWORD(v60) = 0;
LABEL_66:
            LODWORD(v60) = 0;
            goto LABEL_67;
          }
          if (v60 < 7)
          {
            v46 = v55;
            v45 = v61;
            v44 = v60;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v55, v60, 8);
            v44 = v60;
            if (!(_DWORD)v60)
            {
LABEL_65:
              LODWORD(v54) = v43;
              goto LABEL_66;
            }
            v45 = v59;
            v46 = __src;
          }
          memcpy(v46, v45, 8 * v44);
          goto LABEL_65;
        }
      }
    }
  }
LABEL_38:
  *(_QWORD *)(a2 + 32) = -1;
  *(_QWORD *)(a2 + 16) = a2 + 32;
  *(_QWORD *)a2 = a2 + 16;
  *(_QWORD *)(a2 + 24) = 0x600000001;
  *(_QWORD *)(a2 + 8) = 0x100000001;
}

uint64_t llvm::SetVector<long long,llvm::SmallVector<long long,6u>,llvm::DenseSet<long long,llvm::DenseMapInfo<long long,void>>,2u>::insert(uint64_t a1, uint64_t *a2)
{
  int v4;
  int v5;
  unsigned int v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  int v10;
  BOOL v11;
  unsigned int v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t *v21;
  int v22;
  unsigned int v23;
  uint64_t *v24;
  uint64_t v25;
  int v26;
  uint64_t *v27;
  uint64_t *v28;
  int v29;
  BOOL v30;
  unsigned int v31;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;

  if (!*(_DWORD *)(a1 + 8))
  {
    v13 = a1 + 24;
    v14 = *(_QWORD **)(a1 + 24);
    v15 = *(unsigned int *)(a1 + 32);
    v16 = v14;
    if ((_DWORD)v15)
    {
      v17 = 8 * v15;
      v16 = *(_QWORD **)(a1 + 24);
      while (*v16 != *a2)
      {
        ++v16;
        v17 -= 8;
        if (!v17)
        {
          v16 = &v14[v15];
          break;
        }
      }
    }
    if (v15 != v16 - v14)
      return 0;
    v18 = *a2;
    if (v15 >= *(_DWORD *)(a1 + 36))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v13, (void *)(a1 + 40), v15 + 1, 8);
      v15 = *(unsigned int *)(a1 + 32);
      v14 = *(_QWORD **)(a1 + 24);
    }
    v14[v15] = v18;
    v19 = *(_DWORD *)(a1 + 32) + 1;
    *(_DWORD *)(a1 + 32) = v19;
    if (v19 < 3)
      return 1;
    v20 = *(uint64_t **)(a1 + 24);
    v21 = &v20[v19];
    while (1)
    {
      v26 = *(_DWORD *)(a1 + 16);
      if (!v26)
        break;
      v22 = v26 - 1;
      v23 = (37 * *v20) & v22;
      v24 = (uint64_t *)(*(_QWORD *)a1 + 8 * v23);
      v25 = *v24;
      if (*v20 != *v24)
      {
        v28 = 0;
        v29 = 1;
        while (v25 != 0x7FFFFFFFFFFFFFFFLL)
        {
          if (v28)
            v30 = 0;
          else
            v30 = v25 == 0x8000000000000000;
          if (v30)
            v28 = v24;
          v31 = v23 + v29++;
          v23 = v31 & v22;
          v24 = (uint64_t *)(*(_QWORD *)a1 + 8 * v23);
          v25 = *v24;
          if (*v20 == *v24)
            goto LABEL_24;
        }
        if (v28)
          v27 = v28;
        else
          v27 = v24;
        goto LABEL_27;
      }
LABEL_24:
      if (++v20 == v21)
        return 1;
    }
    v27 = 0;
LABEL_27:
    llvm::DenseMapBase<llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::InsertIntoBucket<long long const&,llvm::detail::DenseSetEmpty&>(a1, v27, v20);
    goto LABEL_24;
  }
  v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    v5 = v4 - 1;
    v6 = (37 * *a2) & v5;
    v7 = (uint64_t *)(*(_QWORD *)a1 + 8 * v6);
    v8 = *v7;
    if (*a2 != *v7)
    {
      v9 = 0;
      v10 = 1;
      while (v8 != 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v9)
          v11 = 0;
        else
          v11 = v8 == 0x8000000000000000;
        if (v11)
          v9 = v7;
        v12 = v6 + v10++;
        v6 = v12 & v5;
        v7 = (uint64_t *)(*(_QWORD *)a1 + 8 * v6);
        v8 = *v7;
        if (*a2 == *v7)
          return 0;
      }
      if (v9)
        v33 = v9;
      else
        v33 = v7;
      goto LABEL_42;
    }
    return 0;
  }
  v33 = 0;
LABEL_42:
  llvm::DenseMapBase<llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::InsertIntoBucket<long long const&,llvm::detail::DenseSetEmpty&>(a1, v33, a2);
  v34 = *a2;
  v35 = *(unsigned int *)(a1 + 32);
  if (v35 >= *(_DWORD *)(a1 + 36))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (void *)(a1 + 40), v35 + 1, 8);
    LODWORD(v35) = *(_DWORD *)(a1 + 32);
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v35) = v34;
  ++*(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t *llvm::DenseMapBase<llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::InsertIntoBucket<long long const&,llvm::detail::DenseSetEmpty&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6;
  unsigned int v7;
  uint64_t v8;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t *v13;
  int v14;
  BOOL v15;
  unsigned int v16;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
LABEL_3:
    v8 = *a2;
    goto LABEL_4;
  }
  llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::grow(a1, v7);
  v8 = *a3;
  v10 = *(_DWORD *)(a1 + 16) - 1;
  v11 = (37 * *a3) & v10;
  a2 = (uint64_t *)(*(_QWORD *)a1 + 8 * v11);
  v12 = *a2;
  if (*a3 != *a2)
  {
    v13 = 0;
    v14 = 1;
    while (v12 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if (v13)
        v15 = 0;
      else
        v15 = v12 == 0x8000000000000000;
      if (v15)
        v13 = a2;
      v16 = v11 + v14++;
      v11 = v16 & v10;
      a2 = (uint64_t *)(*(_QWORD *)a1 + 8 * (v16 & v10));
      v12 = *a2;
      if (v8 == *a2)
        goto LABEL_4;
    }
    if (v13)
      a2 = v13;
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != 0x7FFFFFFFFFFFFFFFLL)
    --*(_DWORD *)(a1 + 12);
  *a2 = *a3;
  return a2;
}

void llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::shrink_and_clear(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v3;
  int v4;

  v1 = *(unsigned int *)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 8);
  v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64)
    v3 = 64;
  if (v2)
    v4 = v3;
  else
    v4 = 0;
  if (v4 != (_DWORD)v1)
    llvm::deallocate_buffer(*(llvm **)a1, (void *)(8 * v1));
  *(_QWORD *)(a1 + 8) = 0;
  if ((_DWORD)v1)
    memset_pattern16(*(void **)a1, &unk_1812362E0, 8 * v1);
}

_QWORD *mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapMatMulOpInterface>::mapDynamicShape@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  unint64_t v31;
  unint64_t *v32;
  _QWORD *v33;
  unint64_t v34;
  uint64_t v35;
  _BOOL4 IsNegated;
  _BOOL4 TransposeRhs;
  uint64_t v39;

  v39 = a1;
  v3 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3)
    goto LABEL_10;
  v4 = *v3;
  v5 = mlir::TypeID::get<mlir::ShapedType>();
  v6 = *(unsigned int *)(v4 + 16);
  if (!(_DWORD)v6)
    goto LABEL_10;
  v7 = *(_QWORD **)(v4 + 8);
  v8 = &v7[2 * v6];
  do
  {
    v9 = v6 >> 1;
    v10 = &v7[2 * (v6 >> 1)];
    v12 = *v10;
    v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5)
      v7 = v11;
    else
      v6 = v9;
  }
  while (v6);
  if (v7 != v8 && *v7 == v5)
    v13 = v7[1];
  else
LABEL_10:
    v13 = 0;
  v14 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14)
    goto LABEL_20;
  v15 = *v14;
  v16 = mlir::TypeID::get<mlir::ShapedType>();
  v17 = *(unsigned int *)(v15 + 16);
  if (!(_DWORD)v17)
    goto LABEL_20;
  v18 = *(_QWORD **)(v15 + 8);
  v19 = &v18[2 * v17];
  do
  {
    v20 = v17 >> 1;
    v21 = &v18[2 * (v17 >> 1)];
    v23 = *v21;
    v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16)
      v18 = v22;
    else
      v17 = v20;
  }
  while (v17);
  if (v18 != v19 && *v18 == v16)
    v24 = v18[1];
  else
LABEL_20:
    v24 = 0;
  v25 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v25)
    goto LABEL_30;
  v26 = *v25;
  v27 = mlir::TypeID::get<mlir::ShapedType>();
  v28 = *(unsigned int *)(v26 + 16);
  if (!(_DWORD)v28)
    goto LABEL_30;
  v29 = *(_QWORD **)(v26 + 8);
  v30 = &v29[2 * v28];
  do
  {
    v31 = v28 >> 1;
    v32 = &v29[2 * (v28 >> 1)];
    v34 = *v32;
    v33 = v32 + 2;
    v28 += ~(v28 >> 1);
    if (v34 < v27)
      v29 = v33;
    else
      v28 = v31;
  }
  while (v28);
  if (v29 != v30 && *v29 == v27)
    v35 = v29[1];
  else
LABEL_30:
    v35 = 0;
  IsNegated = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v39);
  TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v39);
}

_QWORD *mlir::`anonymous namespace'::mapMatMulOperands@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, int a7@<W6>, int a8@<W7>, uint64_t a9@<X8>)
{
  _QWORD *result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unsigned int v28;
  void *v29;
  int v30;
  unsigned int v31;
  uint64_t v32;
  _QWORD v34[2];
  void *__dst;
  uint64_t v36;
  _BYTE v37[48];
  void *__b;
  uint64_t v39;
  unsigned int v40;
  void *__src;
  uint64_t v42;
  _QWORD v43[8];

  v43[6] = *MEMORY[0x1E0C80C00];
  v34[0] = a5;
  v34[1] = a6;
  result = (_QWORD *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v34);
  if ((_DWORD)result)
  {
    if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v34))
      goto LABEL_8;
    result = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v34);
    if (v16)
    {
      v17 = 8 * v16;
      while (*result != 0x8000000000000000)
      {
        ++result;
        v17 -= 8;
        if (!v17)
          goto LABEL_7;
      }
LABEL_8:
      __b = 0;
      v39 = 0;
      v40 = 0;
      __src = v43;
      v42 = 0x600000000;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v34);
      if (v18 >= 1)
      {
        v19 = v18;
        v20 = 0;
        if (a7)
          v21 = -1;
        else
          v21 = -2;
        v32 = v21;
        if (a8)
          v22 = -2;
        else
          v22 = -1;
        do
        {
          if (*(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v34)
                         + 8 * v20) == 0x8000000000000000)
          {
            __dst = a1;
            v36 = a2;
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__dst);
            v24 = v23;
            if (v20 + 2 <= v23
              && *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__dst)
                           + 8 * v20) == 0x8000000000000000
              || v20 == v24 + v32
              && *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__dst)
                           + 8 * v20) == 0x8000000000000000)
            {
              __dst = 0;
              llvm::SetVector<long long,llvm::SmallVector<long long,6u>,llvm::DenseSet<long long,llvm::DenseMapInfo<long long,void>>,2u>::insert((uint64_t)&__b, (uint64_t *)&__dst);
            }
            __dst = a3;
            v36 = a4;
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__dst);
            v26 = v25;
            if (v20 + 2 <= v25
              && *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__dst)
                           + 8 * v20) == 0x8000000000000000
              || v20 == v26 + v22
              && *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__dst)
                           + 8 * v20) == 0x8000000000000000)
            {
              __dst = (void *)1;
              llvm::SetVector<long long,llvm::SmallVector<long long,6u>,llvm::DenseSet<long long,llvm::DenseMapInfo<long long,void>>,2u>::insert((uint64_t)&__b, (uint64_t *)&__dst);
            }
          }
          ++v20;
        }
        while (v19 != v20);
      }
      if (!(_DWORD)v42)
      {
        __dst = (void *)-1;
        llvm::SetVector<long long,llvm::SmallVector<long long,6u>,llvm::DenseSet<long long,llvm::DenseMapInfo<long long,void>>,2u>::insert((uint64_t)&__b, (uint64_t *)&__dst);
      }
      if (v39)
      {
        if (v40 <= 4 * (int)v39 || v40 < 0x41)
        {
          if (v40)
            memset_pattern16(__b, &unk_1812362E0, 8 * v40);
          v39 = 0;
        }
        else
        {
          llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::shrink_and_clear((uint64_t)&__b);
        }
      }
      __dst = v37;
      v36 = 0x600000000;
      v27 = v42;
      if ((_DWORD)v42)
      {
        if (__src == v43)
        {
          v28 = v42;
          if (v42 < 7
            || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v37, v42, 8),
                (v28 = v42) != 0))
          {
            memcpy(__dst, __src, 8 * v28);
          }
          LODWORD(v36) = v27;
        }
        else
        {
          __dst = __src;
          v36 = v42;
          __src = v43;
          HIDWORD(v42) = 0;
        }
        LODWORD(v42) = 0;
      }
      v29 = (void *)(a9 + 32);
      *(_QWORD *)(a9 + 16) = a9 + 32;
      *(_QWORD *)a9 = a9 + 16;
      *(_QWORD *)(a9 + 8) = 0x100000000;
      *(_QWORD *)(a9 + 24) = 0x600000000;
      v30 = 1;
      if ((void **)(a9 + 16) == &__dst || !(_DWORD)v27)
      {
LABEL_53:
        *(_DWORD *)(a9 + 8) = v30;
        if (__dst != v37)
          free(__dst);
        if (__src != v43)
          free(__src);
        llvm::deallocate_buffer((llvm *)__b, (void *)(8 * v40));
      }
      if (v27 < 7)
      {
        v31 = v27;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a9 + 16, (void *)(a9 + 32), v27, 8);
        v31 = v36;
        if (!(_DWORD)v36)
        {
LABEL_52:
          *(_DWORD *)(a9 + 24) = v27;
          v30 = *(_DWORD *)(a9 + 8) + 1;
          goto LABEL_53;
        }
        v29 = *(void **)(a9 + 16);
      }
      memcpy(v29, __dst, 8 * v31);
      goto LABEL_52;
    }
  }
LABEL_7:
  *(_QWORD *)(a9 + 32) = -1;
  *(_QWORD *)(a9 + 16) = a9 + 32;
  *(_QWORD *)a9 = a9 + 16;
  *(_QWORD *)(a9 + 24) = 0x600000001;
  *(_QWORD *)(a9 + 8) = 0x100000001;
  return result;
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapExponentOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapNegativeOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapSubtractOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapReciprocalOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapIdentityOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

double mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapPermuteOpInterface>::mapDynamicShape@<D0>(_QWORD *a1@<X8>)
{
  double result;

  a1[4] = 0;
  a1[2] = a1 + 4;
  *a1 = a1 + 2;
  a1[3] = 0x600000001;
  *(_QWORD *)&result = 0x100000001;
  a1[1] = 0x100000001;
  return result;
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapReadVariableOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapVariableFromTensorOpInterface>::mapDynamicShape(mlir::_anonymous_namespace_ *this@<X1>, uint64_t a2@<X8>)
{
}

int64x2_t *mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapReshapeOpInterface>::mapDynamicShape@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  int64x2_t *result;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  int64x2_t *v34;
  int64x2_t v35;
  int64x2_t v36;
  uint64_t v37;
  int64x2_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  __int128 v58;

  v57 = a1;
  v3 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3)
    goto LABEL_10;
  v4 = *v3;
  v5 = mlir::TypeID::get<mlir::ShapedType>();
  v6 = *(unsigned int *)(v4 + 16);
  if (!(_DWORD)v6)
    goto LABEL_10;
  v7 = *(_QWORD **)(v4 + 8);
  v8 = &v7[2 * v6];
  do
  {
    v9 = v6 >> 1;
    v10 = &v7[2 * (v6 >> 1)];
    v12 = *v10;
    v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5)
      v7 = v11;
    else
      v6 = v9;
  }
  while (v6);
  if (v7 != v8 && *v7 == v5)
    v13 = v7[1];
  else
LABEL_10:
    v13 = 0;
  *(_QWORD *)&v56 = v3;
  *((_QWORD *)&v56 + 1) = v13;
  v14 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v57) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14)
    goto LABEL_20;
  v15 = *v14;
  v16 = mlir::TypeID::get<mlir::ShapedType>();
  v17 = *(unsigned int *)(v15 + 16);
  if (!(_DWORD)v17)
    goto LABEL_20;
  v18 = *(_QWORD **)(v15 + 8);
  v19 = &v18[2 * v17];
  do
  {
    v20 = v17 >> 1;
    v21 = &v18[2 * (v17 >> 1)];
    v23 = *v21;
    v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16)
      v18 = v22;
    else
      v17 = v20;
  }
  while (v17);
  if (v18 != v19 && *v18 == v16)
    v24 = v18[1];
  else
LABEL_20:
    v24 = 0;
  *(_QWORD *)&v55 = v14;
  *((_QWORD *)&v55 + 1) = v24;
  result = (int64x2_t *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v56);
  if (!(_DWORD)result)
    goto LABEL_41;
  result = (int64x2_t *)mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v55);
  if (!(_DWORD)result)
    goto LABEL_41;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v55))
  {
    result = (int64x2_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v55);
    if (!v26)
    {
LABEL_41:
      *(_QWORD *)(a2 + 32) = -1;
      *(_QWORD *)(a2 + 16) = a2 + 32;
      *(_QWORD *)a2 = a2 + 16;
      *(_DWORD *)(a2 + 12) = 1;
      *(_DWORD *)(a2 + 28) = 6;
      goto LABEL_42;
    }
    v27 = 8 * v26;
    while (result->i64[0] != 0x8000000000000000)
    {
      result = (int64x2_t *)((char *)result + 8);
      v27 -= 8;
      if (!v27)
        goto LABEL_41;
    }
  }
  result = (int64x2_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v56);
  if (v28)
  {
    v29 = (v28 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v29 >= 3)
    {
      v32 = v29 + 1;
      v33 = (v29 + 1) & 0x3FFFFFFFFFFFFFFCLL;
      v31 = &result->i64[v33];
      v34 = result + 1;
      v35 = 0uLL;
      v36 = vdupq_n_s64(0x8000000000000000);
      v37 = v33;
      v38 = 0uLL;
      do
      {
        v35 = vsubq_s64(v35, vceqq_s64(v34[-1], v36));
        v38 = vsubq_s64(v38, vceqq_s64(*v34, v36));
        v34 += 2;
        v37 -= 4;
      }
      while (v37);
      v30 = vaddvq_s64(vaddq_s64(v38, v35));
      if (v32 == v33)
        goto LABEL_40;
    }
    else
    {
      v30 = 0;
      v31 = (uint64_t *)result;
    }
    do
    {
      v39 = *v31++;
      if (v39 == 0x8000000000000000)
        ++v30;
    }
    while (v31 != (uint64_t *)((char *)result + 8 * v28));
LABEL_40:
    if (v30 >= 2)
      goto LABEL_41;
  }
  v58 = v56;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
  if (v40 >= 1)
  {
    v41 = 0;
    v42 = 0;
    v43 = 1;
    v44 = 1;
    while (1)
    {
      if (*(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58)
                     + 8 * v41) != 0x8000000000000000)
      {
        v46 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58)
                        + 8 * v41);
        if ((v42 & 1) == 0)
        {
          v42 = 0;
          v44 *= v46;
          goto LABEL_47;
        }
        v43 *= v46;
      }
      v42 = 1;
LABEL_47:
      ++v41;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      if (v41 >= v45)
        goto LABEL_52;
    }
  }
  v44 = 1;
  v43 = 1;
LABEL_52:
  v58 = v55;
  result = (int64x2_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
  if (v47 >= 1)
  {
    v48 = 0;
    v49 = 0;
    v50 = 1;
    v51 = 1;
    while (1)
    {
      if (*(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58)
                     + 8 * v48) != 0x8000000000000000)
      {
        v53 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58)
                        + 8 * v48);
        if ((v49 & 1) == 0)
        {
          v49 = 0;
          v51 *= v53;
          goto LABEL_56;
        }
        v50 *= v53;
      }
      v49 = 1;
LABEL_56:
      ++v48;
      result = (int64x2_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      if (v48 >= v52)
        goto LABEL_61;
    }
  }
  v51 = 1;
  v50 = 1;
LABEL_61:
  v54 = (_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 16) = a2 + 32;
  *(_QWORD *)a2 = a2 + 16;
  *(_DWORD *)(a2 + 12) = 1;
  *(_DWORD *)(a2 + 28) = 6;
  if (v44 == v51 && v43 == v50)
    *v54 = 0;
  else
    *v54 = -1;
LABEL_42:
  *(_DWORD *)(a2 + 24) = 1;
  *(_DWORD *)(a2 + 8) = 1;
  return result;
}

void mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapStridedSliceOpInterface>::mapDynamicShape(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  _QWORD *ArgAttrsAttr;
  uint64_t v26;
  uint64_t v27;
  uint64_t *DefiningOp;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int Index;
  unsigned int EndMask;
  unsigned int Groups;
  uint64_t v43;
  const void *v44;
  uint64_t v45;
  size_t v46;
  unsigned int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t i;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  int64_t v54;
  _QWORD v55[2];
  _QWORD v56[2];
  uint64_t v57;
  uint64_t v58[2];
  uint64_t v59;
  void *v60;
  uint64_t v61;
  _BYTE v62[48];
  void *v63;
  uint64_t v64;
  _BYTE v65[32];
  _QWORD *v66;
  uint64_t v67;
  _BYTE v68[32];
  _QWORD *v69;
  uint64_t v70;
  _QWORD v71[6];

  v71[4] = *MEMORY[0x1E0C80C00];
  v57 = a1;
  v3 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3)
    goto LABEL_10;
  v4 = *v3;
  v5 = mlir::TypeID::get<mlir::ShapedType>();
  v6 = *(unsigned int *)(v4 + 16);
  if (!(_DWORD)v6)
    goto LABEL_10;
  v7 = *(_QWORD **)(v4 + 8);
  v8 = &v7[2 * v6];
  do
  {
    v9 = v6 >> 1;
    v10 = &v7[2 * (v6 >> 1)];
    v12 = *v10;
    v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5)
      v7 = v11;
    else
      v6 = v9;
  }
  while (v6);
  if (v7 != v8 && *v7 == v5)
    v13 = v7[1];
  else
LABEL_10:
    v13 = 0;
  v56[0] = v3;
  v56[1] = v13;
  v14 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v57) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14)
    goto LABEL_20;
  v15 = *v14;
  v16 = mlir::TypeID::get<mlir::ShapedType>();
  v17 = *(unsigned int *)(v15 + 16);
  if (!(_DWORD)v17)
    goto LABEL_20;
  v18 = *(_QWORD **)(v15 + 8);
  v19 = &v18[2 * v17];
  do
  {
    v20 = v17 >> 1;
    v21 = &v18[2 * (v17 >> 1)];
    v23 = *v21;
    v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16)
      v18 = v22;
    else
      v17 = v20;
  }
  while (v17);
  if (v18 != v19 && *v18 == v16)
    v24 = v18[1];
  else
LABEL_20:
    v24 = 0;
  v55[0] = v14;
  v55[1] = v24;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v56)
    || !mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v55))
  {
    goto LABEL_28;
  }
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v55))
    goto LABEL_30;
  ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  if (!v26)
  {
LABEL_28:
    *(_QWORD *)(a2 + 32) = -1;
    *(_QWORD *)(a2 + 16) = a2 + 32;
    *(_QWORD *)a2 = a2 + 16;
    *(_QWORD *)(a2 + 24) = 0x600000001;
    *(_QWORD *)(a2 + 8) = 0x100000001;
    return;
  }
  v27 = 8 * v26;
  while (*ArgAttrsAttr != 0x8000000000000000)
  {
    ++ArgAttrsAttr;
    v27 -= 8;
    if (!v27)
      goto LABEL_28;
  }
LABEL_30:
  v58[0] = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v57);
  DefiningOp = (uint64_t *)mlir::Value::getDefiningOp((mlir::Value *)v58);
  if (DefiningOp)
  {
    v29 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)DefiningOp[6] + 32))(DefiningOp[6], v29))
    {
      v60 = v62;
      v61 = 0x100000000;
      mlir::Operation::fold((uint64_t)DefiningOp, 0, 0, (uint64_t)&v60);
      DefiningOp = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v60 & 0xFFFFFFFFFFFFFFF8));
      if (DefiningOp)
        v31 = v30;
      else
        v31 = 0;
      if (v60 != v62)
        free(v60);
    }
    else
    {
      v31 = 0;
      DefiningOp = 0;
    }
  }
  else
  {
    v31 = 0;
  }
  v58[0] = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v57);
  v32 = (uint64_t *)mlir::Value::getDefiningOp((mlir::Value *)v58);
  if (v32)
  {
    v33 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)v32[6] + 32))(v32[6], v33))
    {
      v60 = v62;
      v61 = 0x100000000;
      mlir::Operation::fold((uint64_t)v32, 0, 0, (uint64_t)&v60);
      v32 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v60 & 0xFFFFFFFFFFFFFFF8));
      if (v32)
        v35 = v34;
      else
        v35 = 0;
      if (v60 != v62)
        free(v60);
    }
    else
    {
      v35 = 0;
      v32 = 0;
    }
  }
  else
  {
    v35 = 0;
  }
  v58[0] = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v57);
  v36 = (uint64_t *)mlir::Value::getDefiningOp((mlir::Value *)v58);
  if (!v36)
    goto LABEL_58;
  v37 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)v36[6] + 32))(v36[6], v37))
  {
    v36 = 0;
LABEL_58:
    v39 = 0;
    goto LABEL_59;
  }
  v60 = v62;
  v61 = 0x100000000;
  mlir::Operation::fold((uint64_t)v36, 0, 0, (uint64_t)&v60);
  v36 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v60 & 0xFFFFFFFFFFFFFFF8));
  if (v36)
    v39 = v38;
  else
    v39 = 0;
  if (v60 != v62)
    free(v60);
LABEL_59:
  v69 = v71;
  v70 = 0x400000000;
  v66 = v68;
  v67 = 0x400000000;
  v63 = v65;
  v64 = 0x400000000;
  if (DefiningOp)
    mlir::getIntValues<long long>((uint64_t)DefiningOp, v31, (uint64_t)&v69, 1);
  if (v32)
    mlir::getIntValues<long long>((uint64_t)v32, v35, (uint64_t)&v66, 1);
  if (v36)
    mlir::getIntValues<long long>((uint64_t)v36, v39, (uint64_t)&v63, 1);
  Index = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v57);
  EndMask = mlir::mps::StridedSliceGradientOp::getEndMask((mlir::mps::StridedSliceGradientOp *)&v57);
  Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v57);
  v44 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  v45 = v43;
  v60 = v62;
  v61 = 0x600000000;
  v46 = 8 * v43;
  if ((unint64_t)(8 * v43) >= 0x31)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v62, (8 * v43) >> 3, 8);
    v47 = v61;
    if (!v45)
      goto LABEL_70;
    goto LABEL_69;
  }
  v47 = 0;
  if (v43)
  {
LABEL_69:
    memcpy((char *)v60 + 8 * v47, v44, v46);
    v47 = v61;
  }
LABEL_70:
  LODWORD(v61) = v47 + (v46 >> 3);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v56);
  if (v48 >= 1)
  {
    v49 = 0;
    for (i = 0; i < v51; ++i)
    {
      if (((Groups >> i) & 1) != 0)
      {
        v58[0] = 1;
        llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v60, (uint64_t)v60 + v49, v58);
      }
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v56);
      v49 += 8;
    }
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v56);
  if (v52 < 1)
  {
LABEL_91:
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 16) = a2 + 32;
    *(_QWORD *)a2 = a2 + 16;
LABEL_93:
    *(_QWORD *)(a2 + 24) = 0x600000001;
    *(_QWORD *)(a2 + 8) = 0x100000001;
  }
  else
  {
    v53 = 0;
    while (1)
    {
      if (*((_QWORD *)v60 + v53) == 0x8000000000000000
        && *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v56)
                     + 8 * v53) == 0x8000000000000000)
      {
        if (v53 >= v64
          || *((_QWORD *)v63 + v53) != 1
          || v53 >= v70
          || v69[v53] && ((Index >> v53) & 1) == 0)
        {
          *(_QWORD *)(a2 + 32) = -1;
          *(_QWORD *)(a2 + 16) = a2 + 32;
          *(_QWORD *)a2 = a2 + 16;
          goto LABEL_93;
        }
        if (v53 >= v67 || v66[v53] && ((EndMask >> v53) & 1) == 0)
          break;
      }
      ++v53;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v56);
      if ((uint64_t)v53 >= v54)
        goto LABEL_91;
    }
    v58[0] = (uint64_t)&v59;
    v58[1] = 0x600000000;
    *(_QWORD *)(a2 + 16) = a2 + 32;
    v59 = -1;
    *(_QWORD *)a2 = a2 + 16;
    *(_DWORD *)(a2 + 12) = 1;
    *(_QWORD *)(a2 + 24) = 0x600000000;
    if ((uint64_t *)(a2 + 16) != v58)
    {
      *(_QWORD *)(a2 + 32) = v59;
      *(_DWORD *)(a2 + 24) = 1;
    }
    *(_DWORD *)(a2 + 8) = 1;
  }
  if (v60 != v62)
    free(v60);
  if (v63 != v65)
    free(v63);
  if (v66 != (_QWORD *)v68)
    free(v66);
  if (v69 != v71)
    free(v69);
}

double mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapStridedSliceUpdateOpInterface>::mapDynamicShape@<D0>(_QWORD *a1@<X8>)
{
  double result;

  a1[4] = 0;
  a1[2] = a1 + 4;
  *a1 = a1 + 2;
  a1[3] = 0x600000001;
  *(_QWORD *)&result = 0x100000001;
  a1[1] = 0x100000001;
  return result;
}

double mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapTransposeOpInterface>::mapDynamicShape@<D0>(_QWORD *a1@<X8>)
{
  double result;

  a1[4] = 0;
  a1[2] = a1 + 4;
  *a1 = a1 + 2;
  a1[3] = 0x600000001;
  *(_QWORD *)&result = 0x100000001;
  a1[1] = 0x100000001;
  return result;
}

void mlir::mps::registerMapDynamicShapeOpExternalModels(mlir::DialectRegistry &)::$_1::__invoke(uint64_t *a1)
{
  _QWORD *v2;
  char v3;
  _QWORD *v4;
  void *v5;
  uint64_t Values;
  __guard v7;
  _QWORD *v8;
  __guard v9;
  _QWORD *v10;
  char v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  __guard v15;
  _QWORD *v16;
  __guard v17;
  _QWORD *v18;
  char v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  __guard v23;
  _QWORD *v24;
  __guard v25;
  uint64_t v26;
  const char *v27;
  __int16 v28;
  const char *v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  _QWORD v33[5];

  v2 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.quantized_matmul", (const unsigned __int8 *)0x15, a1);
  if (!v3)
  {
    v32 = 1283;
    v29 = "Attempting to attach an interface to an unregistered operation ";
    v30 = "mpsx.quantized_matmul";
    v26 = 21;
    goto LABEL_17;
  }
  v4 = v2;
  v5 = (void *)v2[2];
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v33[0] = v2[1];
    Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v33);
    v5 = (void *)v4[2];
  }
  else
  {
    Values = v2[3];
  }
  v7 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(Values, (uint64_t)v5, v7);
  v8 = malloc(8uLL);
  v9 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v4 + 4), v9, v8);
  v10 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.rms_norm", (const unsigned __int8 *)0xD, a1);
  if (!v11)
  {
    v32 = 1283;
    v29 = "Attempting to attach an interface to an unregistered operation ";
    v30 = "mpsx.rms_norm";
    v26 = 13;
    goto LABEL_17;
  }
  v12 = v10;
  v13 = (void *)v10[2];
  if (v13 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v33[0] = v10[1];
    v14 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v33);
    v13 = (void *)v12[2];
  }
  else
  {
    v14 = v10[3];
  }
  v15 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v14, (uint64_t)v13, v15);
  v16 = malloc(8uLL);
  v17 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v12 + 4), v17, v16);
  v18 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.sdpa", (const unsigned __int8 *)9, a1);
  if (!v19)
  {
    v32 = 1283;
    v29 = "Attempting to attach an interface to an unregistered operation ";
    v30 = "mpsx.sdpa";
    v26 = 9;
LABEL_17:
    v31 = v26;
    v27 = ".";
    v28 = 259;
    llvm::operator+((uint64_t *)&v29, (uint64_t *)&v27, (uint64_t)v33);
    llvm::report_fatal_error((llvm::Twine *)v33, 1);
  }
  v20 = v18;
  v21 = (void *)v18[2];
  if (v21 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v33[0] = v18[1];
    v22 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v33);
    v21 = (void *)v20[2];
  }
  else
  {
    v22 = v18[3];
  }
  v23 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v22, (uint64_t)v21, v23);
  v24 = malloc(8uLL);
  v25 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v20 + 4), v25, v24);
}

_QWORD *mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapQuantizedMatMulOpInterface>::mapDynamicShape@<X0>(mlir::Operation *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t *v21;
  _QWORD *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  unint64_t v31;
  unint64_t *v32;
  _QWORD *v33;
  unint64_t v34;
  uint64_t v35;
  _BOOL4 TransposeLhs;
  _BOOL4 TransposeRhs;
  mlir::Operation *v39;

  v39 = a1;
  v3 = (uint64_t *)(*(_QWORD *)(mlir::mpsx::QuantizedMatMulOp::getInput(&v39) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3)
    goto LABEL_10;
  v4 = *v3;
  v5 = mlir::TypeID::get<mlir::ShapedType>();
  v6 = *(unsigned int *)(v4 + 16);
  if (!(_DWORD)v6)
    goto LABEL_10;
  v7 = *(_QWORD **)(v4 + 8);
  v8 = &v7[2 * v6];
  do
  {
    v9 = v6 >> 1;
    v10 = &v7[2 * (v6 >> 1)];
    v12 = *v10;
    v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5)
      v7 = v11;
    else
      v6 = v9;
  }
  while (v6);
  if (v7 != v8 && *v7 == v5)
    v13 = v7[1];
  else
LABEL_10:
    v13 = 0;
  v14 = (uint64_t *)(*(_QWORD *)(mlir::mpsx::QuantizedMatMulOp::getWeights(&v39) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14)
    goto LABEL_20;
  v15 = *v14;
  v16 = mlir::TypeID::get<mlir::ShapedType>();
  v17 = *(unsigned int *)(v15 + 16);
  if (!(_DWORD)v17)
    goto LABEL_20;
  v18 = *(_QWORD **)(v15 + 8);
  v19 = &v18[2 * v17];
  do
  {
    v20 = v17 >> 1;
    v21 = &v18[2 * (v17 >> 1)];
    v23 = *v21;
    v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16)
      v18 = v22;
    else
      v17 = v20;
  }
  while (v17);
  if (v18 != v19 && *v18 == v16)
    v24 = v18[1];
  else
LABEL_20:
    v24 = 0;
  v25 = (uint64_t *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v25)
    goto LABEL_30;
  v26 = *v25;
  v27 = mlir::TypeID::get<mlir::ShapedType>();
  v28 = *(unsigned int *)(v26 + 16);
  if (!(_DWORD)v28)
    goto LABEL_30;
  v29 = *(_QWORD **)(v26 + 8);
  v30 = &v29[2 * v28];
  do
  {
    v31 = v28 >> 1;
    v32 = &v29[2 * (v28 >> 1)];
    v34 = *v32;
    v33 = v32 + 2;
    v28 += ~(v28 >> 1);
    if (v34 < v27)
      v29 = v33;
    else
      v28 = v31;
  }
  while (v28);
  if (v29 != v30 && *v29 == v27)
    v35 = v29[1];
  else
LABEL_30:
    v35 = 0;
  TransposeLhs = mlir::mpsx::QuantizedMatMulOp::getTransposeLhs(&v39);
  TransposeRhs = mlir::mpsx::QuantizedMatMulOp::getTransposeRhs(&v39);
}

double mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapRMSNormOpInterface>::mapDynamicShape@<D0>(_QWORD *a1@<X8>)
{
  double result;

  a1[4] = 0;
  a1[2] = a1 + 4;
  *a1 = a1 + 2;
  a1[3] = 0x600000001;
  *(_QWORD *)&result = 0x100000001;
  a1[1] = 0x100000001;
  return result;
}

double mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits::FallbackModel<mlir::`anonymous namespace'::MapScaledDotProductAttentionOpInterface>::mapDynamicShape@<D0>(_QWORD *a1@<X8>)
{
  double result;

  a1[4] = 0;
  a1[2] = a1 + 4;
  *a1 = a1 + 2;
  a1[3] = 0x600000001;
  *(_QWORD *)&result = 0x100000001;
  a1[1] = 0x100000001;
  return result;
}

_QWORD *mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(_QWORD *a1, _QWORD *a2)
{
  _QWORD *result;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD v11[3];
  _QWORD *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  result = operator new(0x68uLL);
  v5 = result;
  v6 = (_QWORD *)a2[3];
  if (v6)
  {
    if (v6 == a2)
    {
      v12 = v11;
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, v11);
      v6 = v12;
    }
    else
    {
      v12 = (_QWORD *)a2[3];
      a2[3] = 0;
    }
  }
  else
  {
    v12 = 0;
  }
  v5[3] = "mpsx";
  v5[4] = 4;
  v5[2] = 0x300000001;
  *v5 = off_1E0E52548;
  v5[1] = v5 + 3;
  if (!v6)
  {
    v5[12] = 0;
    goto LABEL_15;
  }
  if (v6 != v11)
  {
    v5[12] = v6;
    goto LABEL_15;
  }
  v5[12] = v5 + 9;
  (*(void (**)(_QWORD *))(v11[0] + 24))(v11);
  result = v12;
  if (v12 == v11)
  {
    v7 = 4;
    result = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_15;
    v7 = 5;
  }
  result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v7))();
LABEL_15:
  v10 = v5;
  v8 = (_QWORD *)a1[4];
  if ((unint64_t)v8 >= a1[5])
  {
    v9 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 3, (uint64_t *)&v10);
    result = v10;
    a1[4] = v9;
    v10 = 0;
    if (result)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
  }
  else
  {
    *v8 = v5;
    a1[4] = v8 + 1;
  }
  return result;
}

void mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>)::Extension::~Extension(mlir::DialectExtensionBase *this)
{
  char *v2;
  char *v3;
  uint64_t v4;

  *(_QWORD *)this = off_1E0E52548;
  v2 = (char *)this + 72;
  v3 = (char *)*((_QWORD *)this + 12);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  mlir::DialectExtensionBase::~DialectExtensionBase(this);
}

{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;

  *(_QWORD *)this = off_1E0E52548;
  v2 = (char *)this + 72;
  v3 = (char *)*((_QWORD *)this + 12);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  mlir::DialectExtensionBase::~DialectExtensionBase(this);
  operator delete(v5);
}

uint64_t mlir::DialectExtension<void mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>)::Extension,mlir::mpsx::MPSXDialect>::apply(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 32))(a1, a2, *a3);
}

uint64_t mlir::DialectExtension<void mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>)::Extension,mlir::mpsx::MPSXDialect>::clone@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  void **v7;
  unsigned int v8;
  unsigned int v9;
  _QWORD *v10;
  uint64_t result;

  v4 = operator new(0x68uLL);
  v5 = v4;
  *v4 = off_1E0E2BD48;
  v6 = v4 + 3;
  v4[1] = v4 + 3;
  v7 = (void **)(v4 + 1);
  v4[2] = 0x300000000;
  if (v4 == (_QWORD *)a1)
    goto LABEL_9;
  v8 = *(_DWORD *)(a1 + 16);
  if (!v8)
    goto LABEL_9;
  if (v8 < 4)
  {
    v9 = *(_DWORD *)(a1 + 16);
    goto LABEL_7;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v4 + 1), v6, *(unsigned int *)(a1 + 16), 16);
  v9 = *(_DWORD *)(a1 + 16);
  if (v9)
  {
    v6 = *v7;
LABEL_7:
    memcpy(v6, *(const void **)(a1 + 8), 16 * v9);
  }
  *((_DWORD *)v5 + 4) = v8;
LABEL_9:
  *v5 = off_1E0E52548;
  v10 = v5 + 9;
  result = *(_QWORD *)(a1 + 96);
  if (result)
  {
    if (result == a1 + 72)
    {
      v5[12] = v10;
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
    }
    else
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)result + 16))(result, v10);
      v5[12] = result;
    }
  }
  else
  {
    v5[12] = 0;
  }
  *a2 = v5;
  return result;
}

uint64_t mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(std::function<void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>)::Extension::apply(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;

  v5 = a3;
  v6 = a2;
  v3 = *(_QWORD *)(a1 + 96);
  if (!v3)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    JUMPOUT(0x1804F4FE4);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v3 + 48))(v3, &v6, &v5);
}

_QWORD *std::__function::__func<void (*)(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>,void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &unk_1E0E4FFA0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void (*)(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>,void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &unk_1E0E4FFA0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void (*)(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>,void ()(mlir::MLIRContext *,mlir::mpsx::MPSXDialect *)>::operator()(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 8))(*a2, *a3);
}

void **mlir::mps::registerMPSRuntimeDynamicEncodeOpExternalModels(mlir::mps *this, mlir::DialectRegistry *a2)
{
  void **v3;
  uint64_t v4;
  void **result;
  uint64_t v6;
  void *v7;
  void (*v8)(uint64_t *);
  void **v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v7 = &unk_1E0E4FF00;
  v8 = (void (*)(uint64_t *))mlir::mps::registerMPSRuntimeDynamicEncodeOpExternalModels(mlir::DialectRegistry &)::$_0::__invoke;
  v9 = &v7;
  mlir::DialectRegistry::addExtension<mlir::mps::MPSDialect>(this, &v7);
  v3 = v9;
  if (v9 == &v7)
  {
    v4 = 4;
    v3 = &v7;
  }
  else
  {
    if (!v9)
      goto LABEL_6;
    v4 = 5;
  }
  (*((void (**)(void))*v3 + v4))();
LABEL_6:
  v7 = &unk_1E0E4FFA0;
  v8 = mlir::mps::registerMPSRuntimeDynamicEncodeOpExternalModels(mlir::DialectRegistry &)::$_1::__invoke;
  v9 = &v7;
  mlir::DialectRegistry::addExtension<mlir::mpsx::MPSXDialect>(this, &v7);
  result = v9;
  if (v9 == &v7)
  {
    v6 = 4;
    result = &v7;
  }
  else
  {
    if (!v9)
      return result;
    v6 = 5;
  }
  return (void **)(*((uint64_t (**)(void))*result + v6))();
}

void mlir::mps::registerMPSRuntimeDynamicEncodeOpExternalModels(mlir::DialectRegistry &)::$_0::operator()(uint64_t *a1)
{
  const char *v2;
  _QWORD *v3;
  char v4;
  _QWORD *v5;
  void *v6;
  uint64_t Values;
  __guard v8;
  _QWORD *v9;
  __guard v10;
  const char *v11;
  _QWORD *v12;
  char v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  __guard v17;
  _QWORD *v18;
  __guard v19;
  _QWORD *v20;
  char v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  __guard v25;
  _QWORD *v26;
  __guard v27;
  _QWORD *v28;
  char v29;
  _QWORD *v30;
  void *v31;
  uint64_t v32;
  __guard v33;
  _QWORD *v34;
  __guard v35;
  _QWORD *v36;
  char v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  __guard v41;
  _QWORD *v42;
  __guard v43;
  _QWORD *v44;
  char v45;
  _QWORD *v46;
  void *v47;
  uint64_t v48;
  __guard v49;
  _QWORD *v50;
  __guard v51;
  _QWORD *v52;
  char v53;
  _QWORD *v54;
  void *v55;
  uint64_t v56;
  __guard v57;
  _QWORD *v58;
  __guard v59;
  const char *v60;
  _QWORD *v61;
  char v62;
  _QWORD *v63;
  void *v64;
  uint64_t v65;
  __guard v66;
  _QWORD *v67;
  __guard v68;
  const char *v69;
  _QWORD *v70;
  char v71;
  _QWORD *v72;
  void *v73;
  uint64_t v74;
  __guard v75;
  _QWORD *v76;
  __guard v77;
  const char *v78;
  _QWORD *v79;
  char v80;
  _QWORD *v81;
  void *v82;
  uint64_t v83;
  __guard v84;
  _QWORD *v85;
  __guard v86;
  _QWORD *v87;
  char v88;
  _QWORD *v89;
  void *v90;
  uint64_t v91;
  __guard v92;
  _QWORD *v93;
  __guard v94;
  _QWORD *v95;
  char v96;
  _QWORD *v97;
  void *v98;
  uint64_t v99;
  __guard v100;
  _QWORD *v101;
  __guard v102;
  const char *v103;
  _QWORD *v104;
  char v105;
  _QWORD *v106;
  void *v107;
  uint64_t v108;
  __guard v109;
  _QWORD *v110;
  __guard v111;
  const char *v112;
  _QWORD *v113;
  char v114;
  _QWORD *v115;
  void *v116;
  uint64_t v117;
  __guard v118;
  _QWORD *v119;
  __guard v120;
  const char *v121;
  _QWORD *v122;
  char v123;
  _QWORD *v124;
  void *v125;
  uint64_t v126;
  __guard v127;
  _QWORD *v128;
  __guard v129;
  _QWORD *v130;
  char v131;
  _QWORD *v132;
  void *v133;
  uint64_t v134;
  __guard v135;
  _QWORD *v136;
  __guard v137;
  const char *v138;
  _QWORD *v139;
  char v140;
  _QWORD *v141;
  void *v142;
  uint64_t v143;
  __guard v144;
  _QWORD *v145;
  __guard v146;
  const char *v147;
  _QWORD *v148;
  char v149;
  _QWORD *v150;
  void *v151;
  uint64_t v152;
  __guard v153;
  _QWORD *v154;
  __guard v155;
  const char *v156;
  _QWORD *v157;
  char v158;
  _QWORD *v159;
  void *v160;
  uint64_t v161;
  __guard v162;
  _QWORD *v163;
  __guard v164;
  _QWORD *v165;
  char v166;
  _QWORD *v167;
  void *v168;
  uint64_t v169;
  __guard v170;
  _QWORD *v171;
  __guard v172;
  _QWORD *v173;
  char v174;
  _QWORD *v175;
  void *v176;
  uint64_t v177;
  __guard v178;
  _QWORD *v179;
  __guard v180;
  _QWORD *v181;
  char v182;
  _QWORD *v183;
  void *v184;
  uint64_t v185;
  __guard v186;
  _QWORD *v187;
  __guard v188;
  _QWORD *v189;
  char v190;
  _QWORD *v191;
  void *v192;
  uint64_t v193;
  __guard v194;
  _QWORD *v195;
  __guard v196;
  _QWORD *v197;
  char v198;
  _QWORD *v199;
  void *v200;
  uint64_t v201;
  __guard v202;
  _QWORD *v203;
  __guard v204;
  _QWORD *v205;
  char v206;
  _QWORD *v207;
  void *v208;
  uint64_t v209;
  __guard v210;
  _QWORD *v211;
  __guard v212;
  _QWORD *v213;
  char v214;
  _QWORD *v215;
  void *v216;
  uint64_t v217;
  __guard v218;
  _QWORD *v219;
  __guard v220;
  const char *v221;
  _QWORD *v222;
  char v223;
  _QWORD *v224;
  void *v225;
  uint64_t v226;
  __guard v227;
  _QWORD *v228;
  __guard v229;
  _QWORD *v230;
  char v231;
  _QWORD *v232;
  void *v233;
  uint64_t v234;
  __guard v235;
  _QWORD *v236;
  __guard v237;
  _QWORD *v238;
  char v239;
  _QWORD *v240;
  void *v241;
  uint64_t v242;
  __guard v243;
  _QWORD *v244;
  __guard v245;
  _QWORD *v246;
  char v247;
  _QWORD *v248;
  void *v249;
  uint64_t v250;
  __guard v251;
  _QWORD *v252;
  __guard v253;
  _QWORD *v254;
  char v255;
  _QWORD *v256;
  void *v257;
  uint64_t v258;
  __guard v259;
  _QWORD *v260;
  __guard v261;
  const char *v262;
  _QWORD *v263;
  char v264;
  _QWORD *v265;
  void *v266;
  uint64_t v267;
  __guard v268;
  _QWORD *v269;
  __guard v270;
  _QWORD *v271;
  char v272;
  _QWORD *v273;
  void *v274;
  uint64_t v275;
  __guard v276;
  _QWORD *v277;
  __guard v278;
  const char *v279;
  _QWORD *v280;
  char v281;
  _QWORD *v282;
  void *v283;
  uint64_t v284;
  __guard v285;
  _QWORD *v286;
  __guard v287;
  _QWORD *v288;
  char v289;
  _QWORD *v290;
  void *v291;
  uint64_t v292;
  __guard v293;
  _QWORD *v294;
  __guard v295;
  _QWORD *v296;
  char v297;
  _QWORD *v298;
  void *v299;
  uint64_t v300;
  __guard v301;
  _QWORD *v302;
  __guard v303;
  _QWORD *v304;
  char v305;
  _QWORD *v306;
  void *v307;
  uint64_t v308;
  __guard v309;
  _QWORD *v310;
  __guard v311;
  const char *v312;
  _QWORD *v313;
  char v314;
  _QWORD *v315;
  void *v316;
  uint64_t v317;
  __guard v318;
  _QWORD *v319;
  __guard v320;
  _QWORD *v321;
  char v322;
  _QWORD *v323;
  void *v324;
  uint64_t v325;
  __guard v326;
  _QWORD *v327;
  __guard v328;
  _QWORD *v329;
  char v330;
  _QWORD *v331;
  void *v332;
  uint64_t v333;
  __guard v334;
  _QWORD *v335;
  __guard v336;
  _QWORD *v337;
  char v338;
  _QWORD *v339;
  void *v340;
  uint64_t v341;
  __guard v342;
  _QWORD *v343;
  __guard v344;
  _QWORD *v345;
  char v346;
  _QWORD *v347;
  void *v348;
  uint64_t v349;
  __guard v350;
  _QWORD *v351;
  __guard v352;
  _QWORD *v353;
  char v354;
  _QWORD *v355;
  void *v356;
  uint64_t v357;
  __guard v358;
  _QWORD *v359;
  __guard v360;
  _QWORD *v361;
  char v362;
  _QWORD *v363;
  void *v364;
  uint64_t v365;
  __guard v366;
  _QWORD *v367;
  __guard v368;
  _QWORD *v369;
  char v370;
  _QWORD *v371;
  void *v372;
  uint64_t v373;
  __guard v374;
  _QWORD *v375;
  __guard v376;
  const char *v377;
  _QWORD *v378;
  char v379;
  _QWORD *v380;
  void *v381;
  uint64_t v382;
  __guard v383;
  _QWORD *v384;
  __guard v385;
  _QWORD *v386;
  char v387;
  _QWORD *v388;
  void *v389;
  uint64_t v390;
  __guard v391;
  _QWORD *v392;
  __guard v393;
  _QWORD *v394;
  char v395;
  _QWORD *v396;
  void *v397;
  uint64_t v398;
  __guard v399;
  _QWORD *v400;
  __guard v401;
  _QWORD *v402;
  char v403;
  _QWORD *v404;
  void *v405;
  uint64_t v406;
  __guard v407;
  _QWORD *v408;
  __guard v409;
  _QWORD *v410;
  char v411;
  _QWORD *v412;
  void *v413;
  uint64_t v414;
  __guard v415;
  _QWORD *v416;
  __guard v417;
  _QWORD *v418;
  char v419;
  _QWORD *v420;
  void *v421;
  uint64_t v422;
  __guard v423;
  _QWORD *v424;
  __guard v425;
  _QWORD *v426;
  char v427;
  _QWORD *v428;
  void *v429;
  uint64_t v430;
  __guard v431;
  _QWORD *v432;
  __guard v433;
  const char *v434;
  _QWORD *v435;
  char v436;
  _QWORD *v437;
  void *v438;
  uint64_t v439;
  __guard v440;
  _QWORD *v441;
  __guard v442;
  _QWORD *v443;
  char v444;
  _QWORD *v445;
  void *v446;
  uint64_t v447;
  __guard v448;
  _QWORD *v449;
  __guard v450;
  _QWORD *v451;
  char v452;
  _QWORD *v453;
  void *v454;
  uint64_t v455;
  __guard v456;
  _QWORD *v457;
  __guard v458;
  _QWORD *v459;
  char v460;
  _QWORD *v461;
  void *v462;
  uint64_t v463;
  __guard v464;
  _QWORD *v465;
  __guard v466;
  _QWORD *v467;
  char v468;
  _QWORD *v469;
  void *v470;
  uint64_t v471;
  __guard v472;
  _QWORD *v473;
  __guard v474;
  _QWORD *v475;
  char v476;
  _QWORD *v477;
  void *v478;
  uint64_t v479;
  __guard v480;
  _QWORD *v481;
  __guard v482;
  _QWORD *v483;
  char v484;
  _QWORD *v485;
  void *v486;
  uint64_t v487;
  __guard v488;
  _QWORD *v489;
  __guard v490;
  _QWORD *v491;
  char v492;
  _QWORD *v493;
  void *v494;
  uint64_t v495;
  __guard v496;
  _QWORD *v497;
  __guard v498;
  _QWORD *v499;
  char v500;
  _QWORD *v501;
  void *v502;
  uint64_t v503;
  __guard v504;
  _QWORD *v505;
  __guard v506;
  _QWORD *v507;
  char v508;
  _QWORD *v509;
  void *v510;
  uint64_t v511;
  __guard v512;
  _QWORD *v513;
  __guard v514;
  _QWORD *v515;
  char v516;
  _QWORD *v517;
  void *v518;
  uint64_t v519;
  __guard v520;
  _QWORD *v521;
  __guard v522;
  _QWORD *v523;
  char v524;
  _QWORD *v525;
  void *v526;
  uint64_t v527;
  __guard v528;
  _QWORD *v529;
  __guard v530;
  _QWORD *v531;
  char v532;
  _QWORD *v533;
  void *v534;
  uint64_t v535;
  __guard v536;
  _QWORD *v537;
  __guard v538;
  const char *v539;
  _QWORD *v540;
  char v541;
  _QWORD *v542;
  void *v543;
  uint64_t v544;
  __guard v545;
  _QWORD *v546;
  __guard v547;
  _QWORD *v548;
  char v549;
  _QWORD *v550;
  void *v551;
  uint64_t v552;
  __guard v553;
  _QWORD *v554;
  __guard v555;
  _QWORD *v556;
  char v557;
  _QWORD *v558;
  void *v559;
  uint64_t v560;
  __guard v561;
  _QWORD *v562;
  __guard v563;
  _QWORD *v564;
  char v565;
  _QWORD *v566;
  void *v567;
  uint64_t v568;
  __guard v569;
  _QWORD *v570;
  __guard v571;
  _QWORD *v572;
  char v573;
  _QWORD *v574;
  void *v575;
  uint64_t v576;
  __guard v577;
  _QWORD *v578;
  __guard v579;
  _QWORD *v580;
  char v581;
  _QWORD *v582;
  void *v583;
  uint64_t v584;
  __guard v585;
  _QWORD *v586;
  __guard v587;
  _QWORD *v588;
  char v589;
  _QWORD *v590;
  void *v591;
  uint64_t v592;
  __guard v593;
  _QWORD *v594;
  __guard v595;
  _QWORD *v596;
  char v597;
  _QWORD *v598;
  void *v599;
  uint64_t v600;
  __guard v601;
  _QWORD *v602;
  __guard v603;
  _QWORD *v604;
  char v605;
  _QWORD *v606;
  void *v607;
  uint64_t v608;
  __guard v609;
  _QWORD *v610;
  __guard v611;
  _QWORD *v612;
  char v613;
  _QWORD *v614;
  void *v615;
  uint64_t v616;
  __guard v617;
  _QWORD *v618;
  __guard v619;
  _QWORD *v620;
  char v621;
  _QWORD *v622;
  void *v623;
  uint64_t v624;
  __guard v625;
  _QWORD *v626;
  __guard v627;
  _QWORD *v628;
  char v629;
  _QWORD *v630;
  void *v631;
  uint64_t v632;
  __guard v633;
  _QWORD *v634;
  __guard v635;
  _QWORD *v636;
  char v637;
  _QWORD *v638;
  void *v639;
  uint64_t v640;
  __guard v641;
  _QWORD *v642;
  __guard v643;
  _QWORD *v644;
  char v645;
  _QWORD *v646;
  void *v647;
  uint64_t v648;
  __guard v649;
  _QWORD *v650;
  __guard v651;
  _QWORD *v652;
  char v653;
  _QWORD *v654;
  void *v655;
  uint64_t v656;
  __guard v657;
  _QWORD *v658;
  __guard v659;
  _QWORD *v660;
  char v661;
  _QWORD *v662;
  void *v663;
  uint64_t v664;
  __guard v665;
  _QWORD *v666;
  __guard v667;
  _QWORD *v668;
  char v669;
  _QWORD *v670;
  void *v671;
  uint64_t v672;
  __guard v673;
  _QWORD *v674;
  __guard v675;
  _QWORD *v676;
  char v677;
  _QWORD *v678;
  void *v679;
  uint64_t v680;
  __guard v681;
  _QWORD *v682;
  __guard v683;
  _QWORD *v684;
  char v685;
  _QWORD *v686;
  void *v687;
  uint64_t v688;
  __guard v689;
  _QWORD *v690;
  __guard v691;
  const char *v692;
  _QWORD *v693;
  char v694;
  _QWORD *v695;
  void *v696;
  uint64_t v697;
  __guard v698;
  _QWORD *v699;
  __guard v700;
  _QWORD *v701;
  char v702;
  _QWORD *v703;
  void *v704;
  uint64_t v705;
  __guard v706;
  _QWORD *v707;
  __guard v708;
  _QWORD *v709;
  char v710;
  _QWORD *v711;
  void *v712;
  uint64_t v713;
  __guard v714;
  _QWORD *v715;
  __guard v716;
  _QWORD *v717;
  char v718;
  _QWORD *v719;
  void *v720;
  uint64_t v721;
  __guard v722;
  _QWORD *v723;
  __guard v724;
  const char *v725;
  _QWORD *v726;
  char v727;
  _QWORD *v728;
  void *v729;
  uint64_t v730;
  __guard v731;
  _QWORD *v732;
  __guard v733;
  _QWORD *v734;
  char v735;
  _QWORD *v736;
  void *v737;
  uint64_t v738;
  __guard v739;
  _QWORD *v740;
  __guard v741;
  _QWORD *v742;
  char v743;
  _QWORD *v744;
  void *v745;
  uint64_t v746;
  __guard v747;
  _QWORD *v748;
  __guard v749;
  _QWORD *v750;
  char v751;
  _QWORD *v752;
  void *v753;
  uint64_t v754;
  __guard v755;
  _QWORD *v756;
  __guard v757;
  _QWORD *v758;
  char v759;
  _QWORD *v760;
  void *v761;
  uint64_t v762;
  __guard v763;
  _QWORD *v764;
  __guard v765;
  _QWORD *v766;
  char v767;
  _QWORD *v768;
  void *v769;
  uint64_t v770;
  __guard v771;
  _QWORD *v772;
  __guard v773;
  _QWORD *v774;
  char v775;
  _QWORD *v776;
  void *v777;
  uint64_t v778;
  __guard v779;
  _QWORD *v780;
  __guard v781;
  _QWORD *v782;
  char v783;
  _QWORD *v784;
  void *v785;
  uint64_t v786;
  __guard v787;
  _QWORD *v788;
  __guard v789;
  _QWORD *v790;
  char v791;
  _QWORD *v792;
  void *v793;
  uint64_t v794;
  __guard v795;
  _QWORD *v796;
  __guard v797;
  const char *v798;
  _QWORD *v799;
  char v800;
  _QWORD *v801;
  void *v802;
  uint64_t v803;
  __guard v804;
  _QWORD *v805;
  __guard v806;
  _QWORD *v807;
  char v808;
  _QWORD *v809;
  void *v810;
  uint64_t v811;
  __guard v812;
  _QWORD *v813;
  __guard v814;
  _QWORD *v815;
  char v816;
  _QWORD *v817;
  void *v818;
  uint64_t v819;
  __guard v820;
  _QWORD *v821;
  __guard v822;
  _QWORD *v823;
  char v824;
  _QWORD *v825;
  void *v826;
  uint64_t v827;
  __guard v828;
  _QWORD *v829;
  __guard v830;
  _QWORD *v831;
  char v832;
  _QWORD *v833;
  void *v834;
  uint64_t v835;
  __guard v836;
  _QWORD *v837;
  __guard v838;
  _QWORD *v839;
  char v840;
  _QWORD *v841;
  void *v842;
  uint64_t v843;
  __guard v844;
  _QWORD *v845;
  __guard v846;
  _QWORD *v847;
  char v848;
  _QWORD *v849;
  void *v850;
  uint64_t v851;
  __guard v852;
  _QWORD *v853;
  __guard v854;
  _QWORD *v855;
  char v856;
  _QWORD *v857;
  void *v858;
  uint64_t v859;
  __guard v860;
  _QWORD *v861;
  __guard v862;
  _QWORD *v863;
  char v864;
  _QWORD *v865;
  void *v866;
  uint64_t v867;
  __guard v868;
  _QWORD *v869;
  __guard v870;
  _QWORD *v871;
  char v872;
  _QWORD *v873;
  void *v874;
  uint64_t v875;
  __guard v876;
  _QWORD *v877;
  __guard v878;
  _QWORD *v879;
  char v880;
  _QWORD *v881;
  void *v882;
  uint64_t v883;
  __guard v884;
  _QWORD *v885;
  __guard v886;
  _QWORD *v887;
  char v888;
  _QWORD *v889;
  void *v890;
  uint64_t v891;
  __guard v892;
  _QWORD *v893;
  __guard v894;
  const char *v895;
  _QWORD *v896;
  char v897;
  _QWORD *v898;
  void *v899;
  uint64_t v900;
  __guard v901;
  _QWORD *v902;
  __guard v903;
  _QWORD *v904;
  char v905;
  _QWORD *v906;
  void *v907;
  uint64_t v908;
  __guard v909;
  _QWORD *v910;
  __guard v911;
  _QWORD *v912;
  char v913;
  _QWORD *v914;
  void *v915;
  uint64_t v916;
  __guard v917;
  _QWORD *v918;
  __guard v919;
  _QWORD *v920;
  char v921;
  _QWORD *v922;
  void *v923;
  uint64_t v924;
  __guard v925;
  _QWORD *v926;
  __guard v927;
  _QWORD *v928;
  char v929;
  _QWORD *v930;
  void *v931;
  uint64_t v932;
  __guard v933;
  _QWORD *v934;
  __guard v935;
  _QWORD *v936;
  char v937;
  _QWORD *v938;
  void *v939;
  uint64_t v940;
  __guard v941;
  _QWORD *v942;
  __guard v943;
  _QWORD *v944;
  char v945;
  _QWORD *v946;
  void *v947;
  uint64_t v948;
  __guard v949;
  _QWORD *v950;
  __guard v951;
  _QWORD *v952;
  char v953;
  _QWORD *v954;
  void *v955;
  uint64_t v956;
  __guard v957;
  _QWORD *v958;
  __guard v959;
  _QWORD *v960;
  char v961;
  _QWORD *v962;
  void *v963;
  uint64_t v964;
  __guard v965;
  _QWORD *v966;
  __guard v967;
  _QWORD *v968;
  char v969;
  _QWORD *v970;
  void *v971;
  uint64_t v972;
  __guard v973;
  _QWORD *v974;
  __guard v975;
  _QWORD *v976;
  char v977;
  _QWORD *v978;
  void *v979;
  uint64_t v980;
  __guard v981;
  _QWORD *v982;
  __guard v983;
  _QWORD *v984;
  char v985;
  _QWORD *v986;
  void *v987;
  uint64_t v988;
  __guard v989;
  _QWORD *v990;
  __guard v991;
  _QWORD *v992;
  char v993;
  _QWORD *v994;
  void *v995;
  uint64_t v996;
  __guard v997;
  _QWORD *v998;
  __guard v999;
  _QWORD *v1000;
  char v1001;
  _QWORD *v1002;
  void *v1003;
  uint64_t v1004;
  __guard v1005;
  _QWORD *v1006;
  __guard v1007;
  _QWORD *v1008;
  char v1009;
  _QWORD *v1010;
  void *v1011;
  uint64_t v1012;
  __guard v1013;
  _QWORD *v1014;
  __guard v1015;
  _QWORD *v1016;
  char v1017;
  _QWORD *v1018;
  void *v1019;
  uint64_t v1020;
  __guard v1021;
  _QWORD *v1022;
  __guard v1023;
  _QWORD *v1024;
  char v1025;
  _QWORD *v1026;
  void *v1027;
  uint64_t v1028;
  __guard v1029;
  _QWORD *v1030;
  __guard v1031;
  _QWORD *v1032;
  char v1033;
  _QWORD *v1034;
  void *v1035;
  uint64_t v1036;
  __guard v1037;
  _QWORD *v1038;
  __guard v1039;
  _QWORD *v1040;
  char v1041;
  _QWORD *v1042;
  void *v1043;
  uint64_t v1044;
  __guard v1045;
  _QWORD *v1046;
  __guard v1047;
  _QWORD *v1048;
  char v1049;
  _QWORD *v1050;
  void *v1051;
  uint64_t v1052;
  __guard v1053;
  _QWORD *v1054;
  __guard v1055;
  const char *v1056;
  _QWORD *v1057;
  char v1058;
  _QWORD *v1059;
  void *v1060;
  uint64_t v1061;
  __guard v1062;
  _QWORD *v1063;
  __guard v1064;
  _QWORD *v1065;
  char v1066;
  _QWORD *v1067;
  void *v1068;
  uint64_t v1069;
  __guard v1070;
  _QWORD *v1071;
  __guard v1072;
  _QWORD *v1073;
  char v1074;
  _QWORD *v1075;
  void *v1076;
  uint64_t v1077;
  __guard v1078;
  _QWORD *v1079;
  __guard v1080;
  _QWORD *v1081;
  char v1082;
  _QWORD *v1083;
  void *v1084;
  uint64_t v1085;
  __guard v1086;
  _QWORD *v1087;
  __guard v1088;
  _QWORD *v1089;
  char v1090;
  _QWORD *v1091;
  void *v1092;
  uint64_t v1093;
  __guard v1094;
  _QWORD *v1095;
  __guard v1096;
  _QWORD *v1097;
  char v1098;
  _QWORD *v1099;
  void *v1100;
  uint64_t v1101;
  __guard v1102;
  _QWORD *v1103;
  __guard v1104;
  _QWORD *v1105;
  char v1106;
  _QWORD *v1107;
  void *v1108;
  uint64_t v1109;
  __guard v1110;
  _QWORD *v1111;
  __guard v1112;
  _QWORD *v1113;
  char v1114;
  _QWORD *v1115;
  void *v1116;
  uint64_t v1117;
  __guard v1118;
  _QWORD *v1119;
  __guard v1120;
  _QWORD *v1121;
  char v1122;
  _QWORD *v1123;
  void *v1124;
  uint64_t v1125;
  __guard v1126;
  _QWORD *v1127;
  __guard v1128;
  _QWORD *v1129;
  char v1130;
  _QWORD *v1131;
  void *v1132;
  uint64_t v1133;
  __guard v1134;
  _QWORD *v1135;
  __guard v1136;
  const char *v1137;
  _QWORD *v1138;
  char v1139;
  _QWORD *v1140;
  void *v1141;
  uint64_t v1142;
  __guard v1143;
  _QWORD *v1144;
  __guard v1145;
  _QWORD *v1146;
  char v1147;
  _QWORD *v1148;
  void *v1149;
  uint64_t v1150;
  __guard v1151;
  _QWORD *v1152;
  __guard v1153;
  _QWORD *v1154;
  char v1155;
  _QWORD *v1156;
  void *v1157;
  uint64_t v1158;
  __guard v1159;
  _QWORD *v1160;
  __guard v1161;
  _QWORD *v1162;
  char v1163;
  _QWORD *v1164;
  void *v1165;
  uint64_t v1166;
  __guard v1167;
  _QWORD *v1168;
  __guard v1169;
  _QWORD *v1170;
  char v1171;
  _QWORD *v1172;
  void *v1173;
  uint64_t v1174;
  __guard v1175;
  _QWORD *v1176;
  __guard v1177;
  _QWORD *v1178;
  char v1179;
  _QWORD *v1180;
  void *v1181;
  uint64_t v1182;
  __guard v1183;
  _QWORD *v1184;
  __guard v1185;
  _QWORD *v1186;
  char v1187;
  _QWORD *v1188;
  void *v1189;
  uint64_t v1190;
  __guard v1191;
  _QWORD *v1192;
  __guard v1193;
  _QWORD *v1194;
  char v1195;
  _QWORD *v1196;
  void *v1197;
  uint64_t v1198;
  __guard v1199;
  _QWORD *v1200;
  __guard v1201;
  _QWORD *v1202;
  char v1203;
  _QWORD *v1204;
  void *v1205;
  uint64_t v1206;
  __guard v1207;
  _QWORD *v1208;
  __guard v1209;
  _QWORD *v1210;
  char v1211;
  _QWORD *v1212;
  void *v1213;
  uint64_t v1214;
  __guard v1215;
  _QWORD *v1216;
  __guard v1217;
  _QWORD *v1218;
  char v1219;
  _QWORD *v1220;
  void *v1221;
  uint64_t v1222;
  __guard v1223;
  _QWORD *v1224;
  __guard v1225;
  _QWORD *v1226;
  char v1227;
  _QWORD *v1228;
  void *v1229;
  uint64_t v1230;
  __guard v1231;
  _QWORD *v1232;
  __guard v1233;
  _QWORD *v1234;
  char v1235;
  _QWORD *v1236;
  void *v1237;
  uint64_t v1238;
  __guard v1239;
  _QWORD *v1240;
  __guard v1241;
  _QWORD *v1242;
  char v1243;
  _QWORD *v1244;
  void *v1245;
  uint64_t v1246;
  __guard v1247;
  _QWORD *v1248;
  __guard v1249;
  _QWORD *v1250;
  char v1251;
  _QWORD *v1252;
  void *v1253;
  uint64_t v1254;
  __guard v1255;
  _QWORD *v1256;
  __guard v1257;
  _QWORD *v1258;
  char v1259;
  _QWORD *v1260;
  void *v1261;
  uint64_t v1262;
  __guard v1263;
  _QWORD *v1264;
  __guard v1265;
  _QWORD *v1266;
  char v1267;
  _QWORD *v1268;
  void *v1269;
  uint64_t v1270;
  __guard v1271;
  _QWORD *v1272;
  __guard v1273;
  _QWORD *v1274;
  char v1275;
  _QWORD *v1276;
  void *v1277;
  uint64_t v1278;
  __guard v1279;
  _QWORD *v1280;
  __guard v1281;
  _QWORD *v1282;
  char v1283;
  _QWORD *v1284;
  void *v1285;
  uint64_t v1286;
  __guard v1287;
  _QWORD *v1288;
  __guard v1289;
  _QWORD *v1290;
  char v1291;
  _QWORD *v1292;
  void *v1293;
  uint64_t v1294;
  __guard v1295;
  _QWORD *v1296;
  __guard v1297;
  _QWORD *v1298;
  char v1299;
  _QWORD *v1300;
  void *v1301;
  uint64_t v1302;
  __guard v1303;
  _QWORD *v1304;
  __guard v1305;
  _QWORD *v1306;
  char v1307;
  _QWORD *v1308;
  void *v1309;
  uint64_t v1310;
  __guard v1311;
  _QWORD *v1312;
  __guard v1313;
  _QWORD *v1314;
  char v1315;
  _QWORD *v1316;
  void *v1317;
  uint64_t v1318;
  __guard v1319;
  _QWORD *v1320;
  __guard v1321;
  _QWORD *v1322;
  char v1323;
  _QWORD *v1324;
  void *v1325;
  uint64_t v1326;
  __guard v1327;
  _QWORD *v1328;
  __guard v1329;
  _QWORD *v1330;
  char v1331;
  _QWORD *v1332;
  void *v1333;
  uint64_t v1334;
  __guard v1335;
  _QWORD *v1336;
  __guard v1337;
  _QWORD *v1338;
  char v1339;
  _QWORD *v1340;
  void *v1341;
  uint64_t v1342;
  __guard v1343;
  _QWORD *v1344;
  __guard v1345;
  _QWORD *v1346;
  char v1347;
  _QWORD *v1348;
  void *v1349;
  uint64_t v1350;
  __guard v1351;
  _QWORD *v1352;
  __guard v1353;
  _QWORD *v1354;
  char v1355;
  _QWORD *v1356;
  void *v1357;
  uint64_t v1358;
  __guard v1359;
  _QWORD *v1360;
  __guard v1361;
  _QWORD *v1362;
  char v1363;
  _QWORD *v1364;
  void *v1365;
  uint64_t v1366;
  __guard v1367;
  _QWORD *v1368;
  __guard v1369;
  _QWORD *v1370;
  char v1371;
  _QWORD *v1372;
  void *v1373;
  uint64_t v1374;
  __guard v1375;
  _QWORD *v1376;
  __guard v1377;
  _QWORD *v1378;
  char v1379;
  _QWORD *v1380;
  void *v1381;
  uint64_t v1382;
  __guard v1383;
  _QWORD *v1384;
  __guard v1385;
  _QWORD *v1386;
  char v1387;
  _QWORD *v1388;
  void *v1389;
  uint64_t v1390;
  __guard v1391;
  _QWORD *v1392;
  __guard v1393;
  _QWORD *v1394;
  char v1395;
  _QWORD *v1396;
  void *v1397;
  uint64_t v1398;
  __guard v1399;
  _QWORD *v1400;
  __guard v1401;
  _QWORD *v1402;
  char v1403;
  _QWORD *v1404;
  void *v1405;
  uint64_t v1406;
  __guard v1407;
  _QWORD *v1408;
  __guard v1409;
  _QWORD *v1410;
  char v1411;
  _QWORD *v1412;
  void *v1413;
  uint64_t v1414;
  __guard v1415;
  _QWORD *v1416;
  __guard v1417;
  _QWORD *v1418;
  char v1419;
  _QWORD *v1420;
  void *v1421;
  uint64_t v1422;
  __guard v1423;
  _QWORD *v1424;
  __guard v1425;
  _QWORD *v1426;
  char v1427;
  _QWORD *v1428;
  void *v1429;
  uint64_t v1430;
  __guard v1431;
  _QWORD *v1432;
  __guard v1433;
  _QWORD *v1434;
  char v1435;
  _QWORD *v1436;
  void *v1437;
  uint64_t v1438;
  __guard v1439;
  _QWORD *v1440;
  __guard v1441;
  _QWORD *v1442;
  char v1443;
  _QWORD *v1444;
  void *v1445;
  uint64_t v1446;
  __guard v1447;
  _QWORD *v1448;
  __guard v1449;
  _QWORD *v1450;
  char v1451;
  _QWORD *v1452;
  void *v1453;
  uint64_t v1454;
  __guard v1455;
  _QWORD *v1456;
  __guard v1457;
  _QWORD *v1458;
  char v1459;
  _QWORD *v1460;
  void *v1461;
  uint64_t v1462;
  __guard v1463;
  _QWORD *v1464;
  __guard v1465;
  _QWORD *v1466;
  char v1467;
  _QWORD *v1468;
  void *v1469;
  uint64_t v1470;
  __guard v1471;
  _QWORD *v1472;
  __guard v1473;
  _QWORD *v1474;
  char v1475;
  _QWORD *v1476;
  void *v1477;
  uint64_t v1478;
  __guard v1479;
  _QWORD *v1480;
  __guard v1481;
  _QWORD *v1482;
  char v1483;
  _QWORD *v1484;
  void *v1485;
  uint64_t v1486;
  __guard v1487;
  _QWORD *v1488;
  __guard v1489;
  _QWORD *v1490;
  char v1491;
  _QWORD *v1492;
  void *v1493;
  uint64_t v1494;
  __guard v1495;
  _QWORD *v1496;
  __guard v1497;
  _QWORD *v1498;
  char v1499;
  _QWORD *v1500;
  void *v1501;
  uint64_t v1502;
  __guard v1503;
  _QWORD *v1504;
  __guard v1505;
  _QWORD *v1506;
  char v1507;
  _QWORD *v1508;
  void *v1509;
  uint64_t v1510;
  __guard v1511;
  _QWORD *v1512;
  __guard v1513;
  _QWORD *v1514;
  char v1515;
  _QWORD *v1516;
  void *v1517;
  uint64_t v1518;
  __guard v1519;
  _QWORD *v1520;
  __guard v1521;
  _QWORD *v1522;
  char v1523;
  _QWORD *v1524;
  void *v1525;
  uint64_t v1526;
  __guard v1527;
  _QWORD *v1528;
  __guard v1529;
  _QWORD *v1530;
  char v1531;
  _QWORD *v1532;
  void *v1533;
  uint64_t v1534;
  __guard v1535;
  _QWORD *v1536;
  __guard v1537;
  _QWORD *v1538;
  char v1539;
  _QWORD *v1540;
  void *v1541;
  uint64_t v1542;
  __guard v1543;
  _QWORD *v1544;
  __guard v1545;
  _QWORD *v1546;
  char v1547;
  _QWORD *v1548;
  void *v1549;
  uint64_t v1550;
  __guard v1551;
  _QWORD *v1552;
  __guard v1553;
  _QWORD *v1554;
  char v1555;
  _QWORD *v1556;
  void *v1557;
  uint64_t v1558;
  __guard v1559;
  _QWORD *v1560;
  __guard v1561;
  _QWORD *v1562;
  char v1563;
  _QWORD *v1564;
  void *v1565;
  uint64_t v1566;
  __guard v1567;
  _QWORD *v1568;
  __guard v1569;
  _QWORD *v1570;
  char v1571;
  _QWORD *v1572;
  void *v1573;
  uint64_t v1574;
  __guard v1575;
  _QWORD *v1576;
  __guard v1577;
  _QWORD *v1578;
  char v1579;
  _QWORD *v1580;
  void *v1581;
  uint64_t v1582;
  __guard v1583;
  _QWORD *v1584;
  __guard v1585;
  _QWORD *v1586;
  char v1587;
  _QWORD *v1588;
  void *v1589;
  uint64_t v1590;
  __guard v1591;
  _QWORD *v1592;
  __guard v1593;
  _QWORD *v1594;
  char v1595;
  _QWORD *v1596;
  void *v1597;
  uint64_t v1598;
  __guard v1599;
  _QWORD *v1600;
  __guard v1601;
  _QWORD *v1602;
  char v1603;
  _QWORD *v1604;
  void *v1605;
  uint64_t v1606;
  __guard v1607;
  _QWORD *v1608;
  __guard v1609;
  _QWORD *v1610;
  char v1611;
  _QWORD *v1612;
  void *v1613;
  uint64_t v1614;
  __guard v1615;
  _QWORD *v1616;
  __guard v1617;
  _QWORD *v1618;
  char v1619;
  _QWORD *v1620;
  void *v1621;
  uint64_t v1622;
  __guard v1623;
  _QWORD *v1624;
  __guard v1625;
  _QWORD *v1626;
  char v1627;
  _QWORD *v1628;
  void *v1629;
  uint64_t v1630;
  __guard v1631;
  _QWORD *v1632;
  __guard v1633;
  const char *v1634;
  _QWORD *v1635;
  char v1636;
  _QWORD *v1637;
  void *v1638;
  uint64_t v1639;
  __guard v1640;
  _QWORD *v1641;
  __guard v1642;
  _QWORD *v1643;
  char v1644;
  _QWORD *v1645;
  void *v1646;
  uint64_t v1647;
  __guard v1648;
  _QWORD *v1649;
  __guard v1650;
  _QWORD *v1651;
  char v1652;
  _QWORD *v1653;
  void *v1654;
  uint64_t v1655;
  __guard v1656;
  _QWORD *v1657;
  __guard v1658;
  _QWORD *v1659;
  char v1660;
  _QWORD *v1661;
  void *v1662;
  uint64_t v1663;
  __guard v1664;
  _QWORD *v1665;
  __guard v1666;
  _QWORD *v1667;
  char v1668;
  _QWORD *v1669;
  void *v1670;
  uint64_t v1671;
  __guard v1672;
  _QWORD *v1673;
  __guard v1674;
  _QWORD *v1675;
  char v1676;
  _QWORD *v1677;
  void *v1678;
  uint64_t v1679;
  __guard v1680;
  _QWORD *v1681;
  __guard v1682;
  _QWORD *v1683;
  char v1684;
  _QWORD *v1685;
  void *v1686;
  uint64_t v1687;
  __guard v1688;
  _QWORD *v1689;
  __guard v1690;
  uint64_t v1691;
  const char *v1692;
  __int16 v1693;
  const char *v1694;
  const char *v1695;
  uint64_t v1696;
  __int16 v1697;
  _QWORD v1698[5];

  v2 = "mps.acos";
  v3 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.acos", (const unsigned __int8 *)8, a1);
  if (!v4)
    goto LABEL_834;
  v5 = v3;
  v6 = (void *)v3[2];
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v3[1];
    Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v6 = (void *)v5[2];
  }
  else
  {
    Values = v3[3];
  }
  v8 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(Values, (uint64_t)v6, v8);
  v9 = malloc(8uLL);
  v10 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v5 + 4), v10, v9);
  v11 = "mps.acosh";
  v12 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.acosh", (const unsigned __int8 *)9, a1);
  if (!v13)
    goto LABEL_835;
  v14 = v12;
  v15 = (void *)v12[2];
  if (v15 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v12[1];
    v16 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v15 = (void *)v14[2];
  }
  else
  {
    v16 = v12[3];
  }
  v17 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v16, (uint64_t)v15, v17);
  v18 = malloc(8uLL);
  v19 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v14 + 4), v19, v18);
  v2 = "mps.asin";
  v20 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.asin", (const unsigned __int8 *)8, a1);
  if (!v21)
    goto LABEL_834;
  v22 = v20;
  v23 = (void *)v20[2];
  if (v23 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v20[1];
    v24 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v23 = (void *)v22[2];
  }
  else
  {
    v24 = v20[3];
  }
  v25 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v24, (uint64_t)v23, v25);
  v26 = malloc(8uLL);
  v27 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v22 + 4), v27, v26);
  v11 = "mps.asinh";
  v28 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.asinh", (const unsigned __int8 *)9, a1);
  if (!v29)
    goto LABEL_835;
  v30 = v28;
  v31 = (void *)v28[2];
  if (v31 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v28[1];
    v32 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v31 = (void *)v30[2];
  }
  else
  {
    v32 = v28[3];
  }
  v33 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v32, (uint64_t)v31, v33);
  v34 = malloc(8uLL);
  v35 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v30 + 4), v35, v34);
  v11 = "mps.atan2";
  v36 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.atan2", (const unsigned __int8 *)9, a1);
  if (!v37)
    goto LABEL_835;
  v38 = v36;
  v39 = (void *)v36[2];
  if (v39 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v36[1];
    v40 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v39 = (void *)v38[2];
  }
  else
  {
    v40 = v36[3];
  }
  v41 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v40, (uint64_t)v39, v41);
  v42 = malloc(8uLL);
  v43 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v38 + 4), v43, v42);
  v2 = "mps.atan";
  v44 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.atan", (const unsigned __int8 *)8, a1);
  if (!v45)
    goto LABEL_834;
  v46 = v44;
  v47 = (void *)v44[2];
  if (v47 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v44[1];
    v48 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v47 = (void *)v46[2];
  }
  else
  {
    v48 = v44[3];
  }
  v49 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v48, (uint64_t)v47, v49);
  v50 = malloc(8uLL);
  v51 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v46 + 4), v51, v50);
  v11 = "mps.atanh";
  v52 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.atanh", (const unsigned __int8 *)9, a1);
  if (!v53)
    goto LABEL_835;
  v54 = v52;
  v55 = (void *)v52[2];
  if (v55 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v52[1];
    v56 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v55 = (void *)v54[2];
  }
  else
  {
    v56 = v52[3];
  }
  v57 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v56, (uint64_t)v55, v57);
  v58 = malloc(8uLL);
  v59 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v54 + 4), v59, v58);
  v60 = "mps.absolute";
  v61 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.absolute", (const unsigned __int8 *)0xC, a1);
  if (!v62)
    goto LABEL_839;
  v63 = v61;
  v64 = (void *)v61[2];
  if (v64 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v61[1];
    v65 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v64 = (void *)v63[2];
  }
  else
  {
    v65 = v61[3];
  }
  v66 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v65, (uint64_t)v64, v66);
  v67 = malloc(8uLL);
  v68 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v63 + 4), v68, v67);
  v69 = "mps.absolute_square";
  v70 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.absolute_square", (const unsigned __int8 *)0x13, a1);
  if (!v71)
    goto LABEL_845;
  v72 = v70;
  v73 = (void *)v70[2];
  if (v73 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v70[1];
    v74 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v73 = (void *)v72[2];
  }
  else
  {
    v74 = v70[3];
  }
  v75 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v74, (uint64_t)v73, v75);
  v76 = malloc(8uLL);
  v77 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v72 + 4), v77, v76);
  v78 = "mps.add";
  v79 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, a1);
  if (!v80)
    goto LABEL_838;
  v81 = v79;
  v82 = (void *)v79[2];
  if (v82 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v79[1];
    v83 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v82 = (void *)v81[2];
  }
  else
  {
    v83 = v79[3];
  }
  v84 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v83, (uint64_t)v82, v84);
  v85 = malloc(8uLL);
  v86 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v81 + 4), v86, v85);
  v78 = "mps.and";
  v87 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.and", (const unsigned __int8 *)7, a1);
  if (!v88)
    goto LABEL_838;
  v89 = v87;
  v90 = (void *)v87[2];
  if (v90 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v87[1];
    v91 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v90 = (void *)v89[2];
  }
  else
  {
    v91 = v87[3];
  }
  v92 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v91, (uint64_t)v90, v92);
  v93 = malloc(8uLL);
  v94 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v89 + 4), v94, v93);
  v69 = "mps.assign_variable";
  v95 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.assign_variable", (const unsigned __int8 *)0x13, a1);
  if (!v96)
    goto LABEL_845;
  v97 = v95;
  v98 = (void *)v95[2];
  if (v98 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v95[1];
    v99 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v98 = (void *)v97[2];
  }
  else
  {
    v99 = v95[3];
  }
  v100 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v99, (uint64_t)v98, v100);
  v101 = malloc(8uLL);
  v102 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v97 + 4), v102, v101);
  v103 = "mps.band_part";
  v104 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.band_part", (const unsigned __int8 *)0xD, a1);
  if (!v105)
    goto LABEL_840;
  v106 = v104;
  v107 = (void *)v104[2];
  if (v107 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v104[1];
    v108 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v107 = (void *)v106[2];
  }
  else
  {
    v108 = v104[3];
  }
  v109 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v108, (uint64_t)v107, v109);
  v110 = malloc(8uLL);
  v111 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v106 + 4), v111, v110);
  v112 = "mps.bitwise_and";
  v113 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bitwise_and", (const unsigned __int8 *)0xF, a1);
  if (!v114)
    goto LABEL_843;
  v115 = v113;
  v116 = (void *)v113[2];
  if (v116 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v113[1];
    v117 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v116 = (void *)v115[2];
  }
  else
  {
    v117 = v113[3];
  }
  v118 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v117, (uint64_t)v116, v118);
  v119 = malloc(8uLL);
  v120 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v115 + 4), v120, v119);
  v121 = "mps.bitwise_left_shift";
  v122 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bitwise_left_shift", (const unsigned __int8 *)0x16, a1);
  if (!v123)
    goto LABEL_848;
  v124 = v122;
  v125 = (void *)v122[2];
  if (v125 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v122[1];
    v126 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v125 = (void *)v124[2];
  }
  else
  {
    v126 = v122[3];
  }
  v127 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v126, (uint64_t)v125, v127);
  v128 = malloc(8uLL);
  v129 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v124 + 4), v129, v128);
  v112 = "mps.bitwise_not";
  v130 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bitwise_not", (const unsigned __int8 *)0xF, a1);
  if (!v131)
    goto LABEL_843;
  v132 = v130;
  v133 = (void *)v130[2];
  if (v133 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v130[1];
    v134 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v133 = (void *)v132[2];
  }
  else
  {
    v134 = v130[3];
  }
  v135 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v134, (uint64_t)v133, v135);
  v136 = malloc(8uLL);
  v137 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v132 + 4), v137, v136);
  v138 = "mps.bitwise_or";
  v139 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bitwise_or", (const unsigned __int8 *)0xE, a1);
  if (!v140)
    goto LABEL_846;
  v141 = v139;
  v142 = (void *)v139[2];
  if (v142 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v139[1];
    v143 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v142 = (void *)v141[2];
  }
  else
  {
    v143 = v139[3];
  }
  v144 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v143, (uint64_t)v142, v144);
  v145 = malloc(8uLL);
  v146 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v141 + 4), v146, v145);
  v147 = "mps.bitwise_popcount";
  v148 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bitwise_popcount", (const unsigned __int8 *)0x14, a1);
  if (!v149)
    goto LABEL_847;
  v150 = v148;
  v151 = (void *)v148[2];
  if (v151 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v148[1];
    v152 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v151 = (void *)v150[2];
  }
  else
  {
    v152 = v148[3];
  }
  v153 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v152, (uint64_t)v151, v153);
  v154 = malloc(8uLL);
  v155 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v150 + 4), v155, v154);
  v156 = "mps.bitwise_right_shift";
  v157 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bitwise_right_shift", (const unsigned __int8 *)0x17, a1);
  if (!v158)
  {
LABEL_854:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v156;
    v1691 = 23;
    goto LABEL_862;
  }
  v159 = v157;
  v160 = (void *)v157[2];
  if (v160 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v157[1];
    v161 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v160 = (void *)v159[2];
  }
  else
  {
    v161 = v157[3];
  }
  v162 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v161, (uint64_t)v160, v162);
  v163 = malloc(8uLL);
  v164 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v159 + 4), v164, v163);
  v112 = "mps.bitwise_xor";
  v165 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bitwise_xor", (const unsigned __int8 *)0xF, a1);
  if (!v166)
    goto LABEL_843;
  v167 = v165;
  v168 = (void *)v165[2];
  if (v168 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v165[1];
    v169 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v168 = (void *)v167[2];
  }
  else
  {
    v169 = v165[3];
  }
  v170 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v169, (uint64_t)v168, v170);
  v171 = malloc(8uLL);
  v172 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v167 + 4), v172, v171);
  v2 = "mps.cast";
  v173 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, a1);
  if (!v174)
    goto LABEL_834;
  v175 = v173;
  v176 = (void *)v173[2];
  if (v176 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v173[1];
    v177 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v176 = (void *)v175[2];
  }
  else
  {
    v177 = v173[3];
  }
  v178 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v177, (uint64_t)v176, v178);
  v179 = malloc(8uLL);
  v180 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v175 + 4), v180, v179);
  v2 = "mps.ceil";
  v181 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.ceil", (const unsigned __int8 *)8, a1);
  if (!v182)
    goto LABEL_834;
  v183 = v181;
  v184 = (void *)v181[2];
  if (v184 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v181[1];
    v185 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v184 = (void *)v183[2];
  }
  else
  {
    v185 = v181[3];
  }
  v186 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v185, (uint64_t)v184, v186);
  v187 = malloc(8uLL);
  v188 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v183 + 4), v188, v187);
  v11 = "mps.clamp";
  v189 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.clamp", (const unsigned __int8 *)9, a1);
  if (!v190)
    goto LABEL_835;
  v191 = v189;
  v192 = (void *)v189[2];
  if (v192 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v189[1];
    v193 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v192 = (void *)v191[2];
  }
  else
  {
    v193 = v189[3];
  }
  v194 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v193, (uint64_t)v192, v194);
  v195 = malloc(8uLL);
  v196 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v191 + 4), v196, v195);
  v103 = "mps.col_to_im";
  v197 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.col_to_im", (const unsigned __int8 *)0xD, a1);
  if (!v198)
    goto LABEL_840;
  v199 = v197;
  v200 = (void *)v197[2];
  if (v200 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v197[1];
    v201 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v200 = (void *)v199[2];
  }
  else
  {
    v201 = v197[3];
  }
  v202 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v201, (uint64_t)v200, v202);
  v203 = malloc(8uLL);
  v204 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v199 + 4), v204, v203);
  v103 = "mps.conjugate";
  v205 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conjugate", (const unsigned __int8 *)0xD, a1);
  if (!v206)
    goto LABEL_840;
  v207 = v205;
  v208 = (void *)v205[2];
  if (v208 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v205[1];
    v209 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v208 = (void *)v207[2];
  }
  else
  {
    v209 = v205[3];
  }
  v210 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v209, (uint64_t)v208, v210);
  v211 = malloc(8uLL);
  v212 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v207 + 4), v212, v211);
  v60 = "mps.constant";
  v213 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, a1);
  if (!v214)
    goto LABEL_839;
  v215 = v213;
  v216 = (void *)v213[2];
  if (v216 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v213[1];
    v217 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v216 = (void *)v215[2];
  }
  else
  {
    v217 = v213[3];
  }
  v218 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v217, (uint64_t)v216, v218);
  v219 = malloc(8uLL);
  v220 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v215 + 4), v220, v219);
  v221 = "mps.conv_2d";
  v222 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d", (const unsigned __int8 *)0xB, a1);
  if (!v223)
    goto LABEL_836;
  v224 = v222;
  v225 = (void *)v222[2];
  if (v225 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v222[1];
    v226 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v225 = (void *)v224[2];
  }
  else
  {
    v226 = v222[3];
  }
  v227 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v226, (uint64_t)v225, v227);
  v228 = malloc(8uLL);
  v229 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v224 + 4), v229, v228);
  v221 = "mps.conv_3d";
  v230 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_3d", (const unsigned __int8 *)0xB, a1);
  if (!v231)
    goto LABEL_836;
  v232 = v230;
  v233 = (void *)v230[2];
  if (v233 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v230[1];
    v234 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v233 = (void *)v232[2];
  }
  else
  {
    v234 = v230[3];
  }
  v235 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v234, (uint64_t)v233, v235);
  v236 = malloc(8uLL);
  v237 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v232 + 4), v237, v236);
  v78 = "mps.cos";
  v238 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cos", (const unsigned __int8 *)7, a1);
  if (!v239)
    goto LABEL_838;
  v240 = v238;
  v241 = (void *)v238[2];
  if (v241 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v238[1];
    v242 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v241 = (void *)v240[2];
  }
  else
  {
    v242 = v238[3];
  }
  v243 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v242, (uint64_t)v241, v243);
  v244 = malloc(8uLL);
  v245 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v240 + 4), v245, v244);
  v2 = "mps.cosh";
  v246 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cosh", (const unsigned __int8 *)8, a1);
  if (!v247)
    goto LABEL_834;
  v248 = v246;
  v249 = (void *)v246[2];
  if (v249 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v246[1];
    v250 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v249 = (void *)v248[2];
  }
  else
  {
    v250 = v246[3];
  }
  v251 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v250, (uint64_t)v249, v251);
  v252 = malloc(8uLL);
  v253 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v248 + 4), v253, v252);
  v112 = "mps.cost_volume";
  v254 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cost_volume", (const unsigned __int8 *)0xF, a1);
  if (!v255)
    goto LABEL_843;
  v256 = v254;
  v257 = (void *)v254[2];
  if (v257 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v254[1];
    v258 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v257 = (void *)v256[2];
  }
  else
  {
    v258 = v254[3];
  }
  v259 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v258, (uint64_t)v257, v259);
  v260 = malloc(8uLL);
  v261 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v256 + 4), v261, v260);
  v262 = "mps.create_complex";
  v263 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.create_complex", (const unsigned __int8 *)0x12, a1);
  if (!v264)
    goto LABEL_837;
  v265 = v263;
  v266 = (void *)v263[2];
  if (v266 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v263[1];
    v267 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v266 = (void *)v265[2];
  }
  else
  {
    v267 = v263[3];
  }
  v268 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v267, (uint64_t)v266, v268);
  v269 = malloc(8uLL);
  v270 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v265 + 4), v270, v269);
  v112 = "mps.crop_resize";
  v271 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.crop_resize", (const unsigned __int8 *)0xF, a1);
  if (!v272)
  {
LABEL_843:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v112;
LABEL_844:
    v1691 = 15;
    goto LABEL_862;
  }
  v273 = v271;
  v274 = (void *)v271[2];
  if (v274 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v271[1];
    v275 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v274 = (void *)v273[2];
  }
  else
  {
    v275 = v271[3];
  }
  v276 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v275, (uint64_t)v274, v276);
  v277 = malloc(8uLL);
  v278 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v273 + 4), v278, v277);
  v279 = "mps.depthwise_conv_2d";
  v280 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_2d", (const unsigned __int8 *)0x15, a1);
  if (!v281)
    goto LABEL_849;
  v282 = v280;
  v283 = (void *)v280[2];
  if (v283 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v280[1];
    v284 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v283 = (void *)v282[2];
  }
  else
  {
    v284 = v280[3];
  }
  v285 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v284, (uint64_t)v283, v285);
  v286 = malloc(8uLL);
  v287 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v282 + 4), v287, v286);
  v279 = "mps.depthwise_conv_3d";
  v288 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d", (const unsigned __int8 *)0x15, a1);
  if (!v289)
    goto LABEL_849;
  v290 = v288;
  v291 = (void *)v288[2];
  if (v291 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v288[1];
    v292 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v291 = (void *)v290[2];
  }
  else
  {
    v292 = v288[3];
  }
  v293 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v292, (uint64_t)v291, v293);
  v294 = malloc(8uLL);
  v295 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v290 + 4), v295, v294);
  v262 = "mps.dequantize_lut";
  v296 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize_lut", (const unsigned __int8 *)0x12, a1);
  if (!v297)
    goto LABEL_837;
  v298 = v296;
  v299 = (void *)v296[2];
  if (v299 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v296[1];
    v300 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v299 = (void *)v298[2];
  }
  else
  {
    v300 = v296[3];
  }
  v301 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v300, (uint64_t)v299, v301);
  v302 = malloc(8uLL);
  v303 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v298 + 4), v303, v302);
  v138 = "mps.dequantize";
  v304 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize", (const unsigned __int8 *)0xE, a1);
  if (!v305)
    goto LABEL_846;
  v306 = v304;
  v307 = (void *)v304[2];
  if (v307 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v304[1];
    v308 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v307 = (void *)v306[2];
  }
  else
  {
    v308 = v304[3];
  }
  v309 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v308, (uint64_t)v307, v309);
  v310 = malloc(8uLL);
  v311 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v306 + 4), v311, v310);
  v312 = "mps.divide";
  v313 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.divide", (const unsigned __int8 *)0xA, a1);
  if (!v314)
    goto LABEL_842;
  v315 = v313;
  v316 = (void *)v313[2];
  if (v316 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v313[1];
    v317 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v316 = (void *)v315[2];
  }
  else
  {
    v317 = v313[3];
  }
  v318 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v317, (uint64_t)v316, v318);
  v319 = malloc(8uLL);
  v320 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v315 + 4), v320, v319);
  v121 = "mps.dynamic_shape_cast";
  v321 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dynamic_shape_cast", (const unsigned __int8 *)0x16, a1);
  if (!v322)
    goto LABEL_848;
  v323 = v321;
  v324 = (void *)v321[2];
  if (v324 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v321[1];
    v325 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v324 = (void *)v323[2];
  }
  else
  {
    v325 = v321[3];
  }
  v326 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v325, (uint64_t)v324, v326);
  v327 = malloc(8uLL);
  v328 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v323 + 4), v328, v327);
  v78 = "mps.elu";
  v329 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.elu", (const unsigned __int8 *)7, a1);
  if (!v330)
    goto LABEL_838;
  v331 = v329;
  v332 = (void *)v329[2];
  if (v332 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v329[1];
    v333 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v332 = (void *)v331[2];
  }
  else
  {
    v333 = v329[3];
  }
  v334 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v333, (uint64_t)v332, v334);
  v335 = malloc(8uLL);
  v336 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v331 + 4), v336, v335);
  v11 = "mps.equal";
  v337 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.equal", (const unsigned __int8 *)9, a1);
  if (!v338)
    goto LABEL_835;
  v339 = v337;
  v340 = (void *)v337[2];
  if (v340 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v337[1];
    v341 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v340 = (void *)v339[2];
  }
  else
  {
    v341 = v337[3];
  }
  v342 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v341, (uint64_t)v340, v342);
  v343 = malloc(8uLL);
  v344 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v339 + 4), v344, v343);
  v78 = "mps.erf";
  v345 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.erf", (const unsigned __int8 *)7, a1);
  if (!v346)
    goto LABEL_838;
  v347 = v345;
  v348 = (void *)v345[2];
  if (v348 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v345[1];
    v349 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v348 = (void *)v347[2];
  }
  else
  {
    v349 = v345[3];
  }
  v350 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v349, (uint64_t)v348, v350);
  v351 = malloc(8uLL);
  v352 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v347 + 4), v352, v351);
  v147 = "mps.exponent_base_10";
  v353 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.exponent_base_10", (const unsigned __int8 *)0x14, a1);
  if (!v354)
    goto LABEL_847;
  v355 = v353;
  v356 = (void *)v353[2];
  if (v356 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v353[1];
    v357 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v356 = (void *)v355[2];
  }
  else
  {
    v357 = v353[3];
  }
  v358 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v357, (uint64_t)v356, v358);
  v359 = malloc(8uLL);
  v360 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v355 + 4), v360, v359);
  v69 = "mps.exponent_base_2";
  v361 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.exponent_base_2", (const unsigned __int8 *)0x13, a1);
  if (!v362)
    goto LABEL_845;
  v363 = v361;
  v364 = (void *)v361[2];
  if (v364 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v361[1];
    v365 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v364 = (void *)v363[2];
  }
  else
  {
    v365 = v361[3];
  }
  v366 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v365, (uint64_t)v364, v366);
  v367 = malloc(8uLL);
  v368 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v363 + 4), v368, v367);
  v60 = "mps.exponent";
  v369 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.exponent", (const unsigned __int8 *)0xC, a1);
  if (!v370)
    goto LABEL_839;
  v371 = v369;
  v372 = (void *)v369[2];
  if (v372 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v369[1];
    v373 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v372 = (void *)v371[2];
  }
  else
  {
    v373 = v369[3];
  }
  v374 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v373, (uint64_t)v372, v374);
  v375 = malloc(8uLL);
  v376 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v371 + 4), v376, v375);
  v377 = "mps.floor_divide";
  v378 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.floor_divide", (const unsigned __int8 *)0x10, a1);
  if (!v379)
    goto LABEL_850;
  v380 = v378;
  v381 = (void *)v378[2];
  if (v381 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v378[1];
    v382 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v381 = (void *)v380[2];
  }
  else
  {
    v382 = v378[3];
  }
  v383 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v382, (uint64_t)v381, v383);
  v384 = malloc(8uLL);
  v385 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v380 + 4), v385, v384);
  v11 = "mps.floor";
  v386 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.floor", (const unsigned __int8 *)9, a1);
  if (!v387)
    goto LABEL_835;
  v388 = v386;
  v389 = (void *)v386[2];
  if (v389 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v386[1];
    v390 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v389 = (void *)v388[2];
  }
  else
  {
    v390 = v386[3];
  }
  v391 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v390, (uint64_t)v389, v391);
  v392 = malloc(8uLL);
  v393 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v388 + 4), v393, v392);
  v377 = "mps.gru_gradient";
  v394 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gru_gradient", (const unsigned __int8 *)0x10, a1);
  if (!v395)
    goto LABEL_850;
  v396 = v394;
  v397 = (void *)v394[2];
  if (v397 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v394[1];
    v398 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v397 = (void *)v396[2];
  }
  else
  {
    v398 = v394[3];
  }
  v399 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v398, (uint64_t)v397, v399);
  v400 = malloc(8uLL);
  v401 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v396 + 4), v401, v400);
  v78 = "mps.gru";
  v402 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gru", (const unsigned __int8 *)7, a1);
  if (!v403)
    goto LABEL_838;
  v404 = v402;
  v405 = (void *)v402[2];
  if (v405 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v402[1];
    v406 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v405 = (void *)v404[2];
  }
  else
  {
    v406 = v402[3];
  }
  v407 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v406, (uint64_t)v405, v407);
  v408 = malloc(8uLL);
  v409 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v404 + 4), v409, v408);
  v103 = "mps.gather_nd";
  v410 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gather_nd", (const unsigned __int8 *)0xD, a1);
  if (!v411)
    goto LABEL_840;
  v412 = v410;
  v413 = (void *)v410[2];
  if (v413 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v410[1];
    v414 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v413 = (void *)v412[2];
  }
  else
  {
    v414 = v410[3];
  }
  v415 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v414, (uint64_t)v413, v415);
  v416 = malloc(8uLL);
  v417 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v412 + 4), v417, v416);
  v2 = "mps.gelu";
  v418 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gelu", (const unsigned __int8 *)8, a1);
  if (!v419)
    goto LABEL_834;
  v420 = v418;
  v421 = (void *)v418[2];
  if (v421 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v418[1];
    v422 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v421 = (void *)v420[2];
  }
  else
  {
    v422 = v418[3];
  }
  v423 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v422, (uint64_t)v421, v423);
  v424 = malloc(8uLL);
  v425 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v420 + 4), v425, v424);
  v221 = "mps.greater";
  v426 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.greater", (const unsigned __int8 *)0xB, a1);
  if (!v427)
  {
LABEL_836:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v221;
    v1691 = 11;
    goto LABEL_862;
  }
  v428 = v426;
  v429 = (void *)v426[2];
  if (v429 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v426[1];
    v430 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v429 = (void *)v428[2];
  }
  else
  {
    v430 = v426[3];
  }
  v431 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v430, (uint64_t)v429, v431);
  v432 = malloc(8uLL);
  v433 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v428 + 4), v433, v432);
  v434 = "mps.greater_equal";
  v435 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.greater_equal", (const unsigned __int8 *)0x11, a1);
  if (!v436)
    goto LABEL_841;
  v437 = v435;
  v438 = (void *)v435[2];
  if (v438 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v435[1];
    v439 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v438 = (void *)v437[2];
  }
  else
  {
    v439 = v435[3];
  }
  v440 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v439, (uint64_t)v438, v440);
  v441 = malloc(8uLL);
  v442 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v437 + 4), v442, v441);
  v147 = "mps.hamming_distance";
  v443 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.hamming_distance", (const unsigned __int8 *)0x14, a1);
  if (!v444)
    goto LABEL_847;
  v445 = v443;
  v446 = (void *)v443[2];
  if (v446 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v443[1];
    v447 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v446 = (void *)v445[2];
  }
  else
  {
    v447 = v443[3];
  }
  v448 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v447, (uint64_t)v446, v448);
  v449 = malloc(8uLL);
  v450 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v445 + 4), v450, v449);
  v60 = "mps.identity";
  v451 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.identity", (const unsigned __int8 *)0xC, a1);
  if (!v452)
    goto LABEL_839;
  v453 = v451;
  v454 = (void *)v451[2];
  if (v454 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v451[1];
    v455 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v454 = (void *)v453[2];
  }
  else
  {
    v455 = v451[3];
  }
  v456 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v455, (uint64_t)v454, v456);
  v457 = malloc(8uLL);
  v458 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v453 + 4), v458, v457);
  v103 = "mps.im_to_col";
  v459 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.im_to_col", (const unsigned __int8 *)0xD, a1);
  if (!v460)
    goto LABEL_840;
  v461 = v459;
  v462 = (void *)v459[2];
  if (v462 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v459[1];
    v463 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v462 = (void *)v461[2];
  }
  else
  {
    v463 = v459[3];
  }
  v464 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v463, (uint64_t)v462, v464);
  v465 = malloc(8uLL);
  v466 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v461 + 4), v466, v465);
  v262 = "mps.imaginary_part";
  v467 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.imaginary_part", (const unsigned __int8 *)0x12, a1);
  if (!v468)
    goto LABEL_837;
  v469 = v467;
  v470 = (void *)v467[2];
  if (v470 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v467[1];
    v471 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v470 = (void *)v469[2];
  }
  else
  {
    v471 = v467[3];
  }
  v472 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v471, (uint64_t)v470, v472);
  v473 = malloc(8uLL);
  v474 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v469 + 4), v474, v473);
  v103 = "mps.is_finite";
  v475 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.is_finite", (const unsigned __int8 *)0xD, a1);
  if (!v476)
    goto LABEL_840;
  v477 = v475;
  v478 = (void *)v475[2];
  if (v478 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v475[1];
    v479 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v478 = (void *)v477[2];
  }
  else
  {
    v479 = v475[3];
  }
  v480 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v479, (uint64_t)v478, v480);
  v481 = malloc(8uLL);
  v482 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v477 + 4), v482, v481);
  v112 = "mps.is_infinite";
  v483 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.is_infinite", (const unsigned __int8 *)0xF, a1);
  if (!v484)
    goto LABEL_843;
  v485 = v483;
  v486 = (void *)v483[2];
  if (v486 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v483[1];
    v487 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v486 = (void *)v485[2];
  }
  else
  {
    v487 = v483[3];
  }
  v488 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v487, (uint64_t)v486, v488);
  v489 = malloc(8uLL);
  v490 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v485 + 4), v490, v489);
  v312 = "mps.is_nan";
  v491 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.is_nan", (const unsigned __int8 *)0xA, a1);
  if (!v492)
    goto LABEL_842;
  v493 = v491;
  v494 = (void *)v491[2];
  if (v494 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v491[1];
    v495 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v494 = (void *)v493[2];
  }
  else
  {
    v495 = v491[3];
  }
  v496 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v495, (uint64_t)v494, v496);
  v497 = malloc(8uLL);
  v498 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v493 + 4), v498, v497);
  v434 = "mps.lstm_gradient";
  v499 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.lstm_gradient", (const unsigned __int8 *)0x11, a1);
  if (!v500)
    goto LABEL_841;
  v501 = v499;
  v502 = (void *)v499[2];
  if (v502 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v499[1];
    v503 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v502 = (void *)v501[2];
  }
  else
  {
    v503 = v499[3];
  }
  v504 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v503, (uint64_t)v502, v504);
  v505 = malloc(8uLL);
  v506 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v501 + 4), v506, v505);
  v2 = "mps.lstm";
  v507 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.lstm", (const unsigned __int8 *)8, a1);
  if (!v508)
    goto LABEL_834;
  v509 = v507;
  v510 = (void *)v507[2];
  if (v510 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v507[1];
    v511 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v510 = (void *)v509[2];
  }
  else
  {
    v511 = v507[3];
  }
  v512 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v511, (uint64_t)v510, v512);
  v513 = malloc(8uLL);
  v514 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v509 + 4), v514, v513);
  v138 = "mps.leaky_relu";
  v515 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.leaky_relu", (const unsigned __int8 *)0xE, a1);
  if (!v516)
    goto LABEL_846;
  v517 = v515;
  v518 = (void *)v515[2];
  if (v518 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v515[1];
    v519 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v518 = (void *)v517[2];
  }
  else
  {
    v519 = v515[3];
  }
  v520 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v519, (uint64_t)v518, v520);
  v521 = malloc(8uLL);
  v522 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v517 + 4), v522, v521);
  v2 = "mps.less";
  v523 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.less", (const unsigned __int8 *)8, a1);
  if (!v524)
    goto LABEL_834;
  v525 = v523;
  v526 = (void *)v523[2];
  if (v526 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v523[1];
    v527 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v526 = (void *)v525[2];
  }
  else
  {
    v527 = v523[3];
  }
  v528 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v527, (uint64_t)v526, v528);
  v529 = malloc(8uLL);
  v530 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v525 + 4), v530, v529);
  v138 = "mps.less_equal";
  v531 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.less_equal", (const unsigned __int8 *)0xE, a1);
  if (!v532)
  {
LABEL_846:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v138;
    v1691 = 14;
    goto LABEL_862;
  }
  v533 = v531;
  v534 = (void *)v531[2];
  if (v534 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v531[1];
    v535 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v534 = (void *)v533[2];
  }
  else
  {
    v535 = v531[3];
  }
  v536 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v535, (uint64_t)v534, v536);
  v537 = malloc(8uLL);
  v538 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v533 + 4), v538, v537);
  v539 = "mps.local_convolution_data_gradient";
  v540 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.local_convolution_data_gradient", (const unsigned __int8 *)0x23, a1);
  if (!v541)
    goto LABEL_855;
  v542 = v540;
  v543 = (void *)v540[2];
  if (v543 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v540[1];
    v544 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v543 = (void *)v542[2];
  }
  else
  {
    v544 = v540[3];
  }
  v545 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v544, (uint64_t)v543, v545);
  v546 = malloc(8uLL);
  v547 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v542 + 4), v547, v546);
  v279 = "mps.local_convolution";
  v548 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.local_convolution", (const unsigned __int8 *)0x15, a1);
  if (!v549)
    goto LABEL_849;
  v550 = v548;
  v551 = (void *)v548[2];
  if (v551 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v548[1];
    v552 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v551 = (void *)v550[2];
  }
  else
  {
    v552 = v548[3];
  }
  v553 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v552, (uint64_t)v551, v553);
  v554 = malloc(8uLL);
  v555 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v550 + 4), v555, v554);
  v556 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.local_convolution_weight_gradient", (const unsigned __int8 *)0x25, a1);
  if (!v557)
  {
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = "mps.local_convolution_weight_gradient";
    v1691 = 37;
    goto LABEL_862;
  }
  v558 = v556;
  v559 = (void *)v556[2];
  if (v559 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v556[1];
    v560 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v559 = (void *)v558[2];
  }
  else
  {
    v560 = v556[3];
  }
  v561 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v560, (uint64_t)v559, v561);
  v562 = malloc(8uLL);
  v563 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v558 + 4), v563, v562);
  v279 = "mps.logarithm_base_10";
  v564 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.logarithm_base_10", (const unsigned __int8 *)0x15, a1);
  if (!v565)
    goto LABEL_849;
  v566 = v564;
  v567 = (void *)v564[2];
  if (v567 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v564[1];
    v568 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v567 = (void *)v566[2];
  }
  else
  {
    v568 = v564[3];
  }
  v569 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v568, (uint64_t)v567, v569);
  v570 = malloc(8uLL);
  v571 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v566 + 4), v571, v570);
  v147 = "mps.logarithm_base_2";
  v572 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.logarithm_base_2", (const unsigned __int8 *)0x14, a1);
  if (!v573)
    goto LABEL_847;
  v574 = v572;
  v575 = (void *)v572[2];
  if (v575 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v572[1];
    v576 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v575 = (void *)v574[2];
  }
  else
  {
    v576 = v572[3];
  }
  v577 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v576, (uint64_t)v575, v577);
  v578 = malloc(8uLL);
  v579 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v574 + 4), v579, v578);
  v103 = "mps.logarithm";
  v580 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.logarithm", (const unsigned __int8 *)0xD, a1);
  if (!v581)
    goto LABEL_840;
  v582 = v580;
  v583 = (void *)v580[2];
  if (v583 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v580[1];
    v584 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v583 = (void *)v582[2];
  }
  else
  {
    v584 = v580[3];
  }
  v585 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v584, (uint64_t)v583, v585);
  v586 = malloc(8uLL);
  v587 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v582 + 4), v587, v586);
  v312 = "mps.matmul";
  v588 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matmul", (const unsigned __int8 *)0xA, a1);
  if (!v589)
    goto LABEL_842;
  v590 = v588;
  v591 = (void *)v588[2];
  if (v591 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v588[1];
    v592 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v591 = (void *)v590[2];
  }
  else
  {
    v592 = v588[3];
  }
  v593 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v592, (uint64_t)v591, v593);
  v594 = malloc(8uLL);
  v595 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v590 + 4), v595, v594);
  v221 = "mps.maximum";
  v596 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.maximum", (const unsigned __int8 *)0xB, a1);
  if (!v597)
    goto LABEL_836;
  v598 = v596;
  v599 = (void *)v596[2];
  if (v599 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v596[1];
    v600 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v599 = (void *)v598[2];
  }
  else
  {
    v600 = v596[3];
  }
  v601 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v600, (uint64_t)v599, v601);
  v602 = malloc(8uLL);
  v603 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v598 + 4), v603, v602);
  v221 = "mps.minimum";
  v604 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.minimum", (const unsigned __int8 *)0xB, a1);
  if (!v605)
    goto LABEL_836;
  v606 = v604;
  v607 = (void *)v604[2];
  if (v607 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v604[1];
    v608 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v607 = (void *)v606[2];
  }
  else
  {
    v608 = v604[3];
  }
  v609 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v608, (uint64_t)v607, v609);
  v610 = malloc(8uLL);
  v611 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v606 + 4), v611, v610);
  v312 = "mps.modulo";
  v612 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.modulo", (const unsigned __int8 *)0xA, a1);
  if (!v613)
  {
LABEL_842:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v312;
    v1691 = 10;
    goto LABEL_862;
  }
  v614 = v612;
  v615 = (void *)v612[2];
  if (v615 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v612[1];
    v616 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v615 = (void *)v614[2];
  }
  else
  {
    v616 = v612[3];
  }
  v617 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v616, (uint64_t)v615, v617);
  v618 = malloc(8uLL);
  v619 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v614 + 4), v619, v618);
  v60 = "mps.multiply";
  v620 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, a1);
  if (!v621)
    goto LABEL_839;
  v622 = v620;
  v623 = (void *)v620[2];
  if (v623 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v620[1];
    v624 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v623 = (void *)v622[2];
  }
  else
  {
    v624 = v620[3];
  }
  v625 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v624, (uint64_t)v623, v625);
  v626 = malloc(8uLL);
  v627 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v622 + 4), v627, v626);
  v312 = "mps.n_relu";
  v628 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.n_relu", (const unsigned __int8 *)0xA, a1);
  if (!v629)
    goto LABEL_842;
  v630 = v628;
  v631 = (void *)v628[2];
  if (v631 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v628[1];
    v632 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v631 = (void *)v630[2];
  }
  else
  {
    v632 = v628[3];
  }
  v633 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v632, (uint64_t)v631, v633);
  v634 = malloc(8uLL);
  v635 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v630 + 4), v635, v634);
  v2 = "mps.nand";
  v636 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.nand", (const unsigned __int8 *)8, a1);
  if (!v637)
    goto LABEL_834;
  v638 = v636;
  v639 = (void *)v636[2];
  if (v639 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v636[1];
    v640 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v639 = (void *)v638[2];
  }
  else
  {
    v640 = v636[3];
  }
  v641 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v640, (uint64_t)v639, v641);
  v642 = malloc(8uLL);
  v643 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v638 + 4), v643, v642);
  v60 = "mps.negative";
  v644 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.negative", (const unsigned __int8 *)0xC, a1);
  if (!v645)
  {
LABEL_839:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v60;
    v1691 = 12;
    goto LABEL_862;
  }
  v646 = v644;
  v647 = (void *)v644[2];
  if (v647 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v644[1];
    v648 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v647 = (void *)v646[2];
  }
  else
  {
    v648 = v644[3];
  }
  v649 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v648, (uint64_t)v647, v649);
  v650 = malloc(8uLL);
  v651 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v646 + 4), v651, v650);
  v78 = "mps.nor";
  v652 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.nor", (const unsigned __int8 *)7, a1);
  if (!v653)
    goto LABEL_838;
  v654 = v652;
  v655 = (void *)v652[2];
  if (v655 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v652[1];
    v656 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v655 = (void *)v654[2];
  }
  else
  {
    v656 = v652[3];
  }
  v657 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v656, (uint64_t)v655, v657);
  v658 = malloc(8uLL);
  v659 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v654 + 4), v659, v658);
  v103 = "mps.not_equal";
  v660 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.not_equal", (const unsigned __int8 *)0xD, a1);
  if (!v661)
    goto LABEL_840;
  v662 = v660;
  v663 = (void *)v660[2];
  if (v663 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v660[1];
    v664 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v663 = (void *)v662[2];
  }
  else
  {
    v664 = v660[3];
  }
  v665 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v664, (uint64_t)v663, v665);
  v666 = malloc(8uLL);
  v667 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v662 + 4), v667, v666);
  v78 = "mps.not";
  v668 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.not", (const unsigned __int8 *)7, a1);
  if (!v669)
    goto LABEL_838;
  v670 = v668;
  v671 = (void *)v668[2];
  if (v671 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v668[1];
    v672 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v671 = (void *)v670[2];
  }
  else
  {
    v672 = v668[3];
  }
  v673 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v672, (uint64_t)v671, v673);
  v674 = malloc(8uLL);
  v675 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v670 + 4), v675, v674);
  v676 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.or", (const unsigned __int8 *)6, a1);
  if (!v677)
  {
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = "mps.or";
    v1691 = 6;
LABEL_862:
    v1696 = v1691;
    v1692 = ".";
    v1693 = 259;
    llvm::operator+((uint64_t *)&v1694, (uint64_t *)&v1692, (uint64_t)v1698);
    llvm::report_fatal_error((llvm::Twine *)v1698, 1);
  }
  v678 = v676;
  v679 = (void *)v676[2];
  if (v679 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v676[1];
    v680 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v679 = (void *)v678[2];
  }
  else
  {
    v680 = v676[3];
  }
  v681 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v680, (uint64_t)v679, v681);
  v682 = malloc(8uLL);
  v683 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v678 + 4), v683, v682);
  v11 = "mps.prelu";
  v684 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.prelu", (const unsigned __int8 *)9, a1);
  if (!v685)
    goto LABEL_835;
  v686 = v684;
  v687 = (void *)v684[2];
  if (v687 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v684[1];
    v688 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v687 = (void *)v686[2];
  }
  else
  {
    v688 = v684[3];
  }
  v689 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v688, (uint64_t)v687, v689);
  v690 = malloc(8uLL);
  v691 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v686 + 4), v691, v690);
  v692 = "mps.pooling_average_gradient";
  v693 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_average_gradient", (const unsigned __int8 *)0x1C, a1);
  if (!v694)
    goto LABEL_851;
  v695 = v693;
  v696 = (void *)v693[2];
  if (v696 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v693[1];
    v697 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v696 = (void *)v695[2];
  }
  else
  {
    v697 = v693[3];
  }
  v698 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v697, (uint64_t)v696, v698);
  v699 = malloc(8uLL);
  v700 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v695 + 4), v700, v699);
  v69 = "mps.pooling_average";
  v701 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_average", (const unsigned __int8 *)0x13, a1);
  if (!v702)
    goto LABEL_845;
  v703 = v701;
  v704 = (void *)v701[2];
  if (v704 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v701[1];
    v705 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v704 = (void *)v703[2];
  }
  else
  {
    v705 = v701[3];
  }
  v706 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v705, (uint64_t)v704, v706);
  v707 = malloc(8uLL);
  v708 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v703 + 4), v708, v707);
  v692 = "mps.pooling_l2_norm_gradient";
  v709 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_l2_norm_gradient", (const unsigned __int8 *)0x1C, a1);
  if (!v710)
    goto LABEL_851;
  v711 = v709;
  v712 = (void *)v709[2];
  if (v712 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v709[1];
    v713 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v712 = (void *)v711[2];
  }
  else
  {
    v713 = v709[3];
  }
  v714 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v713, (uint64_t)v712, v714);
  v715 = malloc(8uLL);
  v716 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v711 + 4), v716, v715);
  v69 = "mps.pooling_l2_norm";
  v717 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_l2_norm", (const unsigned __int8 *)0x13, a1);
  if (!v718)
    goto LABEL_845;
  v719 = v717;
  v720 = (void *)v717[2];
  if (v720 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v717[1];
    v721 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v720 = (void *)v719[2];
  }
  else
  {
    v721 = v717[3];
  }
  v722 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v721, (uint64_t)v720, v722);
  v723 = malloc(8uLL);
  v724 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v719 + 4), v724, v723);
  v725 = "mps.pooling_max_gradient";
  v726 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_max_gradient", (const unsigned __int8 *)0x18, a1);
  if (!v727)
    goto LABEL_857;
  v728 = v726;
  v729 = (void *)v726[2];
  if (v729 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v726[1];
    v730 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v729 = (void *)v728[2];
  }
  else
  {
    v730 = v726[3];
  }
  v731 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v730, (uint64_t)v729, v731);
  v732 = malloc(8uLL);
  v733 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v728 + 4), v733, v732);
  v112 = "mps.pooling_max";
  v734 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pooling_max", (const unsigned __int8 *)0xF, a1);
  if (!v735)
    goto LABEL_843;
  v736 = v734;
  v737 = (void *)v734[2];
  if (v737 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v734[1];
    v738 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v737 = (void *)v736[2];
  }
  else
  {
    v738 = v734[3];
  }
  v739 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v738, (uint64_t)v737, v739);
  v740 = malloc(8uLL);
  v741 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v736 + 4), v741, v740);
  v11 = "mps.power";
  v742 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.power", (const unsigned __int8 *)9, a1);
  if (!v743)
    goto LABEL_835;
  v744 = v742;
  v745 = (void *)v742[2];
  if (v745 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v742[1];
    v746 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v745 = (void *)v744[2];
  }
  else
  {
    v746 = v742[3];
  }
  v747 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v746, (uint64_t)v745, v747);
  v748 = malloc(8uLL);
  v749 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v744 + 4), v749, v748);
  v262 = "mps.prune_gradient";
  v750 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.prune_gradient", (const unsigned __int8 *)0x12, a1);
  if (!v751)
    goto LABEL_837;
  v752 = v750;
  v753 = (void *)v750[2];
  if (v753 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v750[1];
    v754 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v753 = (void *)v752[2];
  }
  else
  {
    v754 = v750[3];
  }
  v755 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v754, (uint64_t)v753, v755);
  v756 = malloc(8uLL);
  v757 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v752 + 4), v757, v756);
  v11 = "mps.prune";
  v758 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.prune", (const unsigned __int8 *)9, a1);
  if (!v759)
    goto LABEL_835;
  v760 = v758;
  v761 = (void *)v758[2];
  if (v761 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v758[1];
    v762 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v761 = (void *)v760[2];
  }
  else
  {
    v762 = v758[3];
  }
  v763 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v762, (uint64_t)v761, v763);
  v764 = malloc(8uLL);
  v765 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v760 + 4), v765, v764);
  v60 = "mps.quantize";
  v766 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.quantize", (const unsigned __int8 *)0xC, a1);
  if (!v767)
    goto LABEL_839;
  v768 = v766;
  v769 = (void *)v766[2];
  if (v769 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v766[1];
    v770 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v769 = (void *)v768[2];
  }
  else
  {
    v770 = v766[3];
  }
  v771 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v770, (uint64_t)v769, v771);
  v772 = malloc(8uLL);
  v773 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v768 + 4), v773, v772);
  v434 = "mps.read_variable";
  v774 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.read_variable", (const unsigned __int8 *)0x11, a1);
  if (!v775)
    goto LABEL_841;
  v776 = v774;
  v777 = (void *)v774[2];
  if (v777 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v774[1];
    v778 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v777 = (void *)v776[2];
  }
  else
  {
    v778 = v774[3];
  }
  v779 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v778, (uint64_t)v777, v779);
  v780 = malloc(8uLL);
  v781 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v776 + 4), v781, v780);
  v103 = "mps.real_part";
  v782 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.real_part", (const unsigned __int8 *)0xD, a1);
  if (!v783)
    goto LABEL_840;
  v784 = v782;
  v785 = (void *)v782[2];
  if (v785 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v782[1];
    v786 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v785 = (void *)v784[2];
  }
  else
  {
    v786 = v782[3];
  }
  v787 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v786, (uint64_t)v785, v787);
  v788 = malloc(8uLL);
  v789 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v784 + 4), v789, v788);
  v138 = "mps.reciprocal";
  v790 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal", (const unsigned __int8 *)0xE, a1);
  if (!v791)
    goto LABEL_846;
  v792 = v790;
  v793 = (void *)v790[2];
  if (v793 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v790[1];
    v794 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v793 = (void *)v792[2];
  }
  else
  {
    v794 = v790[3];
  }
  v795 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v794, (uint64_t)v793, v795);
  v796 = malloc(8uLL);
  v797 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v792 + 4), v797, v796);
  v798 = "mps.reciprocal_square_root";
  v799 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal_square_root", (const unsigned __int8 *)0x1A, a1);
  if (!v800)
    goto LABEL_856;
  v801 = v799;
  v802 = (void *)v799[2];
  if (v802 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v799[1];
    v803 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v802 = (void *)v801[2];
  }
  else
  {
    v803 = v799[3];
  }
  v804 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v803, (uint64_t)v802, v804);
  v805 = malloc(8uLL);
  v806 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v801 + 4), v806, v805);
  v147 = "mps.reinterpret_cast";
  v807 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reinterpret_cast", (const unsigned __int8 *)0x14, a1);
  if (!v808)
    goto LABEL_847;
  v809 = v807;
  v810 = (void *)v807[2];
  if (v810 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v807[1];
    v811 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v810 = (void *)v809[2];
  }
  else
  {
    v811 = v807[3];
  }
  v812 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v811, (uint64_t)v810, v812);
  v813 = malloc(8uLL);
  v814 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v809 + 4), v814, v813);
  v11 = "mps.relu6";
  v815 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.relu6", (const unsigned __int8 *)9, a1);
  if (!v816)
    goto LABEL_835;
  v817 = v815;
  v818 = (void *)v815[2];
  if (v818 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v815[1];
    v819 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v818 = (void *)v817[2];
  }
  else
  {
    v819 = v815[3];
  }
  v820 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v819, (uint64_t)v818, v820);
  v821 = malloc(8uLL);
  v822 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v817 + 4), v822, v821);
  v103 = "mps.relu_grad";
  v823 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.relu_grad", (const unsigned __int8 *)0xD, a1);
  if (!v824)
    goto LABEL_840;
  v825 = v823;
  v826 = (void *)v823[2];
  if (v826 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v823[1];
    v827 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v826 = (void *)v825[2];
  }
  else
  {
    v827 = v823[3];
  }
  v828 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v827, (uint64_t)v826, v828);
  v829 = malloc(8uLL);
  v830 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v825 + 4), v830, v829);
  v2 = "mps.relu";
  v831 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.relu", (const unsigned __int8 *)8, a1);
  if (!v832)
    goto LABEL_834;
  v833 = v831;
  v834 = (void *)v831[2];
  if (v834 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v831[1];
    v835 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v834 = (void *)v833[2];
  }
  else
  {
    v835 = v831[3];
  }
  v836 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v835, (uint64_t)v834, v836);
  v837 = malloc(8uLL);
  v838 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v833 + 4), v838, v837);
  v2 = "mps.rint";
  v839 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.rint", (const unsigned __int8 *)8, a1);
  if (!v840)
    goto LABEL_834;
  v841 = v839;
  v842 = (void *)v839[2];
  if (v842 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v839[1];
    v843 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v842 = (void *)v841[2];
  }
  else
  {
    v843 = v839[3];
  }
  v844 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v843, (uint64_t)v842, v844);
  v845 = malloc(8uLL);
  v846 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v841 + 4), v846, v845);
  v11 = "mps.round";
  v847 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.round", (const unsigned __int8 *)9, a1);
  if (!v848)
  {
LABEL_835:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v11;
    v1691 = 9;
    goto LABEL_862;
  }
  v849 = v847;
  v850 = (void *)v847[2];
  if (v850 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v847[1];
    v851 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v850 = (void *)v849[2];
  }
  else
  {
    v851 = v847[3];
  }
  v852 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v851, (uint64_t)v850, v852);
  v853 = malloc(8uLL);
  v854 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v849 + 4), v854, v853);
  v138 = "mps.scatter_nd";
  v855 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.scatter_nd", (const unsigned __int8 *)0xE, a1);
  if (!v856)
    goto LABEL_846;
  v857 = v855;
  v858 = (void *)v855[2];
  if (v858 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v855[1];
    v859 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v858 = (void *)v857[2];
  }
  else
  {
    v859 = v855[3];
  }
  v860 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v859, (uint64_t)v858, v860);
  v861 = malloc(8uLL);
  v862 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v857 + 4), v862, v861);
  v312 = "mps.select";
  v863 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, a1);
  if (!v864)
    goto LABEL_842;
  v865 = v863;
  v866 = (void *)v863[2];
  if (v866 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v863[1];
    v867 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v866 = (void *)v865[2];
  }
  else
  {
    v867 = v863[3];
  }
  v868 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v867, (uint64_t)v866, v868);
  v869 = malloc(8uLL);
  v870 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v865 + 4), v870, v869);
  v2 = "mps.sign";
  v871 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sign", (const unsigned __int8 *)8, a1);
  if (!v872)
    goto LABEL_834;
  v873 = v871;
  v874 = (void *)v871[2];
  if (v874 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v871[1];
    v875 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v874 = (void *)v873[2];
  }
  else
  {
    v875 = v871[3];
  }
  v876 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v875, (uint64_t)v874, v876);
  v877 = malloc(8uLL);
  v878 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v873 + 4), v878, v877);
  v221 = "mps.signbit";
  v879 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.signbit", (const unsigned __int8 *)0xB, a1);
  if (!v880)
    goto LABEL_836;
  v881 = v879;
  v882 = (void *)v879[2];
  if (v882 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v879[1];
    v883 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v882 = (void *)v881[2];
  }
  else
  {
    v883 = v879[3];
  }
  v884 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v883, (uint64_t)v882, v884);
  v885 = malloc(8uLL);
  v886 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v881 + 4), v886, v885);
  v78 = "mps.sin";
  v887 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sin", (const unsigned __int8 *)7, a1);
  if (!v888)
    goto LABEL_838;
  v889 = v887;
  v890 = (void *)v887[2];
  if (v890 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v887[1];
    v891 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v890 = (void *)v889[2];
  }
  else
  {
    v891 = v887[3];
  }
  v892 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v891, (uint64_t)v890, v892);
  v893 = malloc(8uLL);
  v894 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v889 + 4), v894, v893);
  v895 = "mps.singlegate_rnn_gradient";
  v896 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.singlegate_rnn_gradient", (const unsigned __int8 *)0x1B, a1);
  if (!v897)
    goto LABEL_853;
  v898 = v896;
  v899 = (void *)v896[2];
  if (v899 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v896[1];
    v900 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v899 = (void *)v898[2];
  }
  else
  {
    v900 = v896[3];
  }
  v901 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v900, (uint64_t)v899, v901);
  v902 = malloc(8uLL);
  v903 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v898 + 4), v903, v902);
  v262 = "mps.singlegate_rnn";
  v904 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.singlegate_rnn", (const unsigned __int8 *)0x12, a1);
  if (!v905)
    goto LABEL_837;
  v906 = v904;
  v907 = (void *)v904[2];
  if (v907 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v904[1];
    v908 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v907 = (void *)v906[2];
  }
  else
  {
    v908 = v904[3];
  }
  v909 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v908, (uint64_t)v907, v909);
  v910 = malloc(8uLL);
  v911 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v906 + 4), v911, v910);
  v2 = "mps.sinh";
  v912 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sinh", (const unsigned __int8 *)8, a1);
  if (!v913)
    goto LABEL_834;
  v914 = v912;
  v915 = (void *)v912[2];
  if (v915 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v912[1];
    v916 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v915 = (void *)v914[2];
  }
  else
  {
    v916 = v912[3];
  }
  v917 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v916, (uint64_t)v915, v917);
  v918 = malloc(8uLL);
  v919 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v914 + 4), v919, v918);
  v60 = "mps.softplus";
  v920 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softplus", (const unsigned __int8 *)0xC, a1);
  if (!v921)
    goto LABEL_839;
  v922 = v920;
  v923 = (void *)v920[2];
  if (v923 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v920[1];
    v924 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v923 = (void *)v922[2];
  }
  else
  {
    v924 = v920[3];
  }
  v925 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v924, (uint64_t)v923, v925);
  v926 = malloc(8uLL);
  v927 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v922 + 4), v927, v926);
  v156 = "mps.softplus_parametric";
  v928 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softplus_parametric", (const unsigned __int8 *)0x17, a1);
  if (!v929)
    goto LABEL_854;
  v930 = v928;
  v931 = (void *)v928[2];
  if (v931 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v928[1];
    v932 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v931 = (void *)v930[2];
  }
  else
  {
    v932 = v928[3];
  }
  v933 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v932, (uint64_t)v931, v933);
  v934 = malloc(8uLL);
  v935 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v930 + 4), v935, v934);
  v60 = "mps.softsign";
  v936 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softsign", (const unsigned __int8 *)0xC, a1);
  if (!v937)
    goto LABEL_839;
  v938 = v936;
  v939 = (void *)v936[2];
  if (v939 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v936[1];
    v940 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v939 = (void *)v938[2];
  }
  else
  {
    v940 = v936[3];
  }
  v941 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v940, (uint64_t)v939, v941);
  v942 = malloc(8uLL);
  v943 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v938 + 4), v943, v942);
  v312 = "mps.square";
  v944 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square", (const unsigned __int8 *)0xA, a1);
  if (!v945)
    goto LABEL_842;
  v946 = v944;
  v947 = (void *)v944[2];
  if (v947 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v944[1];
    v948 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v947 = (void *)v946[2];
  }
  else
  {
    v948 = v944[3];
  }
  v949 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v948, (uint64_t)v947, v949);
  v950 = malloc(8uLL);
  v951 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v946 + 4), v951, v950);
  v112 = "mps.square_root";
  v952 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square_root", (const unsigned __int8 *)0xF, a1);
  if (!v953)
    goto LABEL_843;
  v954 = v952;
  v955 = (void *)v952[2];
  if (v955 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v952[1];
    v956 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v955 = (void *)v954[2];
  }
  else
  {
    v956 = v952[3];
  }
  v957 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v956, (uint64_t)v955, v957);
  v958 = malloc(8uLL);
  v959 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v954 + 4), v959, v958);
  v221 = "mps.stencil";
  v960 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.stencil", (const unsigned __int8 *)0xB, a1);
  if (!v961)
    goto LABEL_836;
  v962 = v960;
  v963 = (void *)v960[2];
  if (v963 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v960[1];
    v964 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v963 = (void *)v962[2];
  }
  else
  {
    v964 = v960[3];
  }
  v965 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v964, (uint64_t)v963, v965);
  v966 = malloc(8uLL);
  v967 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v962 + 4), v967, v966);
  v60 = "mps.subtract";
  v968 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.subtract", (const unsigned __int8 *)0xC, a1);
  if (!v969)
    goto LABEL_839;
  v970 = v968;
  v971 = (void *)v968[2];
  if (v971 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v968[1];
    v972 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v971 = (void *)v970[2];
  }
  else
  {
    v972 = v968[3];
  }
  v973 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v972, (uint64_t)v971, v973);
  v974 = malloc(8uLL);
  v975 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v970 + 4), v975, v974);
  v11 = "mps.swish";
  v976 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.swish", (const unsigned __int8 *)9, a1);
  if (!v977)
    goto LABEL_835;
  v978 = v976;
  v979 = (void *)v976[2];
  if (v979 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v976[1];
    v980 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v979 = (void *)v978[2];
  }
  else
  {
    v980 = v976[3];
  }
  v981 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v980, (uint64_t)v979, v981);
  v982 = malloc(8uLL);
  v983 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v978 + 4), v983, v982);
  v78 = "mps.tan";
  v984 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.tan", (const unsigned __int8 *)7, a1);
  if (!v985)
    goto LABEL_838;
  v986 = v984;
  v987 = (void *)v984[2];
  if (v987 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v984[1];
    v988 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v987 = (void *)v986[2];
  }
  else
  {
    v988 = v984[3];
  }
  v989 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v988, (uint64_t)v987, v989);
  v990 = malloc(8uLL);
  v991 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v986 + 4), v991, v990);
  v2 = "mps.tanh";
  v992 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.tanh", (const unsigned __int8 *)8, a1);
  if (!v993)
    goto LABEL_834;
  v994 = v992;
  v995 = (void *)v992[2];
  if (v995 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v992[1];
    v996 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v995 = (void *)v994[2];
  }
  else
  {
    v996 = v992[3];
  }
  v997 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v996, (uint64_t)v995, v997);
  v998 = malloc(8uLL);
  v999 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v994 + 4), v999, v998);
  v60 = "mps.truncate";
  v1000 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.truncate", (const unsigned __int8 *)0xC, a1);
  if (!v1001)
    goto LABEL_839;
  v1002 = v1000;
  v1003 = (void *)v1000[2];
  if (v1003 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1000[1];
    v1004 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1003 = (void *)v1002[2];
  }
  else
  {
    v1004 = v1000[3];
  }
  v1005 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1004, (uint64_t)v1003, v1005);
  v1006 = malloc(8uLL);
  v1007 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1002 + 4), v1007, v1006);
  v69 = "mps.type_constraint";
  v1008 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.type_constraint", (const unsigned __int8 *)0x13, a1);
  if (!v1009)
    goto LABEL_845;
  v1010 = v1008;
  v1011 = (void *)v1008[2];
  if (v1011 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1008[1];
    v1012 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1011 = (void *)v1010[2];
  }
  else
  {
    v1012 = v1008[3];
  }
  v1013 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1012, (uint64_t)v1011, v1013);
  v1014 = malloc(8uLL);
  v1015 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1010 + 4), v1015, v1014);
  v725 = "mps.variable_from_tensor";
  v1016 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.variable_from_tensor", (const unsigned __int8 *)0x18, a1);
  if (!v1017)
    goto LABEL_857;
  v1018 = v1016;
  v1019 = (void *)v1016[2];
  if (v1019 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1016[1];
    v1020 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1019 = (void *)v1018[2];
  }
  else
  {
    v1020 = v1016[3];
  }
  v1021 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1020, (uint64_t)v1019, v1021);
  v1022 = malloc(8uLL);
  v1023 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1018 + 4), v1023, v1022);
  v2 = "mps.xnor";
  v1024 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.xnor", (const unsigned __int8 *)8, a1);
  if (!v1025)
    goto LABEL_834;
  v1026 = v1024;
  v1027 = (void *)v1024[2];
  if (v1027 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1024[1];
    v1028 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1027 = (void *)v1026[2];
  }
  else
  {
    v1028 = v1024[3];
  }
  v1029 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1028, (uint64_t)v1027, v1029);
  v1030 = malloc(8uLL);
  v1031 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1026 + 4), v1031, v1030);
  v78 = "mps.xor";
  v1032 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.xor", (const unsigned __int8 *)7, a1);
  if (!v1033)
    goto LABEL_838;
  v1034 = v1032;
  v1035 = (void *)v1032[2];
  if (v1035 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1032[1];
    v1036 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1035 = (void *)v1034[2];
  }
  else
  {
    v1036 = v1032[3];
  }
  v1037 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1036, (uint64_t)v1035, v1037);
  v1038 = malloc(8uLL);
  v1039 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1034 + 4), v1039, v1038);
  v377 = "mps.broadcast_to";
  v1040 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.broadcast_to", (const unsigned __int8 *)0x10, a1);
  if (!v1041)
    goto LABEL_850;
  v1042 = v1040;
  v1043 = (void *)v1040[2];
  if (v1043 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1040[1];
    v1044 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1043 = (void *)v1042[2];
  }
  else
  {
    v1044 = v1040[3];
  }
  v1045 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1044, (uint64_t)v1043, v1045);
  v1046 = malloc(8uLL);
  v1047 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1042 + 4), v1047, v1046);
  v312 = "mps.concat";
  v1048 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.concat", (const unsigned __int8 *)0xA, a1);
  if (!v1049)
    goto LABEL_842;
  v1050 = v1048;
  v1051 = (void *)v1048[2];
  if (v1051 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1048[1];
    v1052 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1051 = (void *)v1050[2];
  }
  else
  {
    v1052 = v1048[3];
  }
  v1053 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1052, (uint64_t)v1051, v1053);
  v1054 = malloc(8uLL);
  v1055 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1050 + 4), v1055, v1054);
  v1056 = "mps.conv_2d_data_gradient";
  v1057 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d_data_gradient", (const unsigned __int8 *)0x19, a1);
  if (!v1058)
    goto LABEL_852;
  v1059 = v1057;
  v1060 = (void *)v1057[2];
  if (v1060 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1057[1];
    v1061 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1060 = (void *)v1059[2];
  }
  else
  {
    v1061 = v1057[3];
  }
  v1062 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1061, (uint64_t)v1060, v1062);
  v1063 = malloc(8uLL);
  v1064 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1059 + 4), v1064, v1063);
  v692 = "mps.conv_2d_weights_gradient";
  v1065 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d_weights_gradient", (const unsigned __int8 *)0x1C, a1);
  if (!v1066)
    goto LABEL_851;
  v1067 = v1065;
  v1068 = (void *)v1065[2];
  if (v1068 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1065[1];
    v1069 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1068 = (void *)v1067[2];
  }
  else
  {
    v1069 = v1065[3];
  }
  v1070 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1069, (uint64_t)v1068, v1070);
  v1071 = malloc(8uLL);
  v1072 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1067 + 4), v1072, v1071);
  v1056 = "mps.conv_3d_data_gradient";
  v1073 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_3d_data_gradient", (const unsigned __int8 *)0x19, a1);
  if (!v1074)
    goto LABEL_852;
  v1075 = v1073;
  v1076 = (void *)v1073[2];
  if (v1076 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1073[1];
    v1077 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1076 = (void *)v1075[2];
  }
  else
  {
    v1077 = v1073[3];
  }
  v1078 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1077, (uint64_t)v1076, v1078);
  v1079 = malloc(8uLL);
  v1080 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1075 + 4), v1080, v1079);
  v692 = "mps.conv_3d_weights_gradient";
  v1081 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_3d_weights_gradient", (const unsigned __int8 *)0x1C, a1);
  if (!v1082)
  {
LABEL_851:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v692;
    v1691 = 28;
    goto LABEL_862;
  }
  v1083 = v1081;
  v1084 = (void *)v1081[2];
  if (v1084 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1081[1];
    v1085 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1084 = (void *)v1083[2];
  }
  else
  {
    v1085 = v1081[3];
  }
  v1086 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1085, (uint64_t)v1084, v1086);
  v1087 = malloc(8uLL);
  v1088 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1083 + 4), v1088, v1087);
  v2 = "mps.crop";
  v1089 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.crop", (const unsigned __int8 *)8, a1);
  if (!v1090)
    goto LABEL_834;
  v1091 = v1089;
  v1092 = (void *)v1089[2];
  if (v1092 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1089[1];
    v1093 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1092 = (void *)v1091[2];
  }
  else
  {
    v1093 = v1089[3];
  }
  v1094 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1093, (uint64_t)v1092, v1094);
  v1095 = malloc(8uLL);
  v1096 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1091 + 4), v1096, v1095);
  v121 = "mps.cumulative_maximum";
  v1097 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cumulative_maximum", (const unsigned __int8 *)0x16, a1);
  if (!v1098)
    goto LABEL_848;
  v1099 = v1097;
  v1100 = (void *)v1097[2];
  if (v1100 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1097[1];
    v1101 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1100 = (void *)v1099[2];
  }
  else
  {
    v1101 = v1097[3];
  }
  v1102 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1101, (uint64_t)v1100, v1102);
  v1103 = malloc(8uLL);
  v1104 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1099 + 4), v1104, v1103);
  v121 = "mps.cumulative_minimum";
  v1105 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cumulative_minimum", (const unsigned __int8 *)0x16, a1);
  if (!v1106)
    goto LABEL_848;
  v1107 = v1105;
  v1108 = (void *)v1105[2];
  if (v1108 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1105[1];
    v1109 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1108 = (void *)v1107[2];
  }
  else
  {
    v1109 = v1105[3];
  }
  v1110 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1109, (uint64_t)v1108, v1110);
  v1111 = malloc(8uLL);
  v1112 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1107 + 4), v1112, v1111);
  v121 = "mps.cumulative_product";
  v1113 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cumulative_product", (const unsigned __int8 *)0x16, a1);
  if (!v1114)
    goto LABEL_848;
  v1115 = v1113;
  v1116 = (void *)v1113[2];
  if (v1116 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1113[1];
    v1117 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1116 = (void *)v1115[2];
  }
  else
  {
    v1117 = v1113[3];
  }
  v1118 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1117, (uint64_t)v1116, v1118);
  v1119 = malloc(8uLL);
  v1120 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1115 + 4), v1120, v1119);
  v262 = "mps.cumulative_sum";
  v1121 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cumulative_sum", (const unsigned __int8 *)0x12, a1);
  if (!v1122)
    goto LABEL_837;
  v1123 = v1121;
  v1124 = (void *)v1121[2];
  if (v1124 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1121[1];
    v1125 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1124 = (void *)v1123[2];
  }
  else
  {
    v1125 = v1121[3];
  }
  v1126 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1125, (uint64_t)v1124, v1126);
  v1127 = malloc(8uLL);
  v1128 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1123 + 4), v1128, v1127);
  v539 = "mps.depthwise_conv_2d_data_gradient";
  v1129 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_2d_data_gradient", (const unsigned __int8 *)0x23, a1);
  if (!v1130)
    goto LABEL_855;
  v1131 = v1129;
  v1132 = (void *)v1129[2];
  if (v1132 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1129[1];
    v1133 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1132 = (void *)v1131[2];
  }
  else
  {
    v1133 = v1129[3];
  }
  v1134 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1133, (uint64_t)v1132, v1134);
  v1135 = malloc(8uLL);
  v1136 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1131 + 4), v1136, v1135);
  v1137 = "mps.depthwise_conv_2d_weights_gradient";
  v1138 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_2d_weights_gradient", (const unsigned __int8 *)0x26, a1);
  if (!v1139)
    goto LABEL_858;
  v1140 = v1138;
  v1141 = (void *)v1138[2];
  if (v1141 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1138[1];
    v1142 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1141 = (void *)v1140[2];
  }
  else
  {
    v1142 = v1138[3];
  }
  v1143 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1142, (uint64_t)v1141, v1143);
  v1144 = malloc(8uLL);
  v1145 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1140 + 4), v1145, v1144);
  v539 = "mps.depthwise_conv_3d_data_gradient";
  v1146 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d_data_gradient", (const unsigned __int8 *)0x23, a1);
  if (!v1147)
  {
LABEL_855:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v539;
    v1691 = 35;
    goto LABEL_862;
  }
  v1148 = v1146;
  v1149 = (void *)v1146[2];
  if (v1149 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1146[1];
    v1150 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1149 = (void *)v1148[2];
  }
  else
  {
    v1150 = v1146[3];
  }
  v1151 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1150, (uint64_t)v1149, v1151);
  v1152 = malloc(8uLL);
  v1153 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1148 + 4), v1153, v1152);
  v1137 = "mps.depthwise_conv_3d_weights_gradient";
  v1154 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depthwise_conv_3d_weights_gradient", (const unsigned __int8 *)0x26, a1);
  if (!v1155)
  {
LABEL_858:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v1137;
    v1691 = 38;
    goto LABEL_862;
  }
  v1156 = v1154;
  v1157 = (void *)v1154[2];
  if (v1157 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1154[1];
    v1158 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1157 = (void *)v1156[2];
  }
  else
  {
    v1158 = v1154[3];
  }
  v1159 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1158, (uint64_t)v1157, v1159);
  v1160 = malloc(8uLL);
  v1161 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1156 + 4), v1161, v1160);
  v112 = "mps.expand_dims";
  v1162 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.expand_dims", (const unsigned __int8 *)0xF, a1);
  if (!v1163)
    goto LABEL_843;
  v1164 = v1162;
  v1165 = (void *)v1162[2];
  if (v1165 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1162[1];
    v1166 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1165 = (void *)v1164[2];
  }
  else
  {
    v1166 = v1162[3];
  }
  v1167 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1166, (uint64_t)v1165, v1167);
  v1168 = malloc(8uLL);
  v1169 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1164 + 4), v1169, v1168);
  v798 = "mps.fast_fourier_transform";
  v1170 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.fast_fourier_transform", (const unsigned __int8 *)0x1A, a1);
  if (!v1171)
    goto LABEL_856;
  v1172 = v1170;
  v1173 = (void *)v1170[2];
  if (v1173 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1170[1];
    v1174 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1173 = (void *)v1172[2];
  }
  else
  {
    v1174 = v1170[3];
  }
  v1175 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1174, (uint64_t)v1173, v1175);
  v1176 = malloc(8uLL);
  v1177 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1172 + 4), v1177, v1176);
  v138 = "mps.flatten_2d";
  v1178 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.flatten_2d", (const unsigned __int8 *)0xE, a1);
  if (!v1179)
    goto LABEL_846;
  v1180 = v1178;
  v1181 = (void *)v1178[2];
  if (v1181 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1178[1];
    v1182 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1181 = (void *)v1180[2];
  }
  else
  {
    v1182 = v1178[3];
  }
  v1183 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1182, (uint64_t)v1181, v1183);
  v1184 = malloc(8uLL);
  v1185 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1180 + 4), v1185, v1184);
  v279 = "mps.gather_along_axis";
  v1186 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gather_along_axis", (const unsigned __int8 *)0x15, a1);
  if (!v1187)
    goto LABEL_849;
  v1188 = v1186;
  v1189 = (void *)v1186[2];
  if (v1189 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1186[1];
    v1190 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1189 = (void *)v1188[2];
  }
  else
  {
    v1190 = v1186[3];
  }
  v1191 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1190, (uint64_t)v1189, v1191);
  v1192 = malloc(8uLL);
  v1193 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1188 + 4), v1193, v1192);
  v312 = "mps.gather";
  v1194 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gather", (const unsigned __int8 *)0xA, a1);
  if (!v1195)
    goto LABEL_842;
  v1196 = v1194;
  v1197 = (void *)v1194[2];
  if (v1197 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1194[1];
    v1198 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1197 = (void *)v1196[2];
  }
  else
  {
    v1198 = v1194[3];
  }
  v1199 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1198, (uint64_t)v1197, v1199);
  v1200 = malloc(8uLL);
  v1201 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1196 + 4), v1201, v1200);
  v69 = "mps.get_coordinates";
  v1202 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.get_coordinates", (const unsigned __int8 *)0x13, a1);
  if (!v1203)
    goto LABEL_845;
  v1204 = v1202;
  v1205 = (void *)v1202[2];
  if (v1205 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1202[1];
    v1206 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1205 = (void *)v1204[2];
  }
  else
  {
    v1206 = v1202[3];
  }
  v1207 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1206, (uint64_t)v1205, v1207);
  v1208 = malloc(8uLL);
  v1209 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1204 + 4), v1209, v1208);
  v1056 = "mps.hermitean_to_real_fft";
  v1210 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.hermitean_to_real_fft", (const unsigned __int8 *)0x19, a1);
  if (!v1211)
    goto LABEL_852;
  v1212 = v1210;
  v1213 = (void *)v1210[2];
  if (v1213 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1210[1];
    v1214 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1213 = (void *)v1212[2];
  }
  else
  {
    v1214 = v1210[3];
  }
  v1215 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1214, (uint64_t)v1213, v1215);
  v1216 = malloc(8uLL);
  v1217 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1212 + 4), v1217, v1216);
  v434 = "mps.instance_norm";
  v1218 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.instance_norm", (const unsigned __int8 *)0x11, a1);
  if (!v1219)
  {
LABEL_841:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v434;
    v1691 = 17;
    goto LABEL_862;
  }
  v1220 = v1218;
  v1221 = (void *)v1218[2];
  if (v1221 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1218[1];
    v1222 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1221 = (void *)v1220[2];
  }
  else
  {
    v1222 = v1218[3];
  }
  v1223 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1222, (uint64_t)v1221, v1223);
  v1224 = malloc(8uLL);
  v1225 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1220 + 4), v1225, v1224);
  v221 = "mps.one_hot";
  v1226 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.one_hot", (const unsigned __int8 *)0xB, a1);
  if (!v1227)
    goto LABEL_836;
  v1228 = v1226;
  v1229 = (void *)v1226[2];
  if (v1229 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1226[1];
    v1230 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1229 = (void *)v1228[2];
  }
  else
  {
    v1230 = v1226[3];
  }
  v1231 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1230, (uint64_t)v1229, v1231);
  v1232 = malloc(8uLL);
  v1233 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1228 + 4), v1233, v1232);
  v377 = "mps.pad_gradient";
  v1234 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pad_gradient", (const unsigned __int8 *)0x10, a1);
  if (!v1235)
    goto LABEL_850;
  v1236 = v1234;
  v1237 = (void *)v1234[2];
  if (v1237 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1234[1];
    v1238 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1237 = (void *)v1236[2];
  }
  else
  {
    v1238 = v1234[3];
  }
  v1239 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1238, (uint64_t)v1237, v1239);
  v1240 = malloc(8uLL);
  v1241 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1236 + 4), v1241, v1240);
  v78 = "mps.pad";
  v1242 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pad", (const unsigned __int8 *)7, a1);
  if (!v1243)
  {
LABEL_838:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v78;
    v1691 = 7;
    goto LABEL_862;
  }
  v1244 = v1242;
  v1245 = (void *)v1242[2];
  if (v1245 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1242[1];
    v1246 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1245 = (void *)v1244[2];
  }
  else
  {
    v1246 = v1242[3];
  }
  v1247 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1246, (uint64_t)v1245, v1247);
  v1248 = malloc(8uLL);
  v1249 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1244 + 4), v1249, v1248);
  v221 = "mps.permute";
  v1250 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.permute", (const unsigned __int8 *)0xB, a1);
  if (!v1251)
    goto LABEL_836;
  v1252 = v1250;
  v1253 = (void *)v1250[2];
  if (v1253 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1250[1];
    v1254 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1253 = (void *)v1252[2];
  }
  else
  {
    v1254 = v1250[3];
  }
  v1255 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1254, (uint64_t)v1253, v1255);
  v1256 = malloc(8uLL);
  v1257 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1252 + 4), v1257, v1256);
  v1056 = "mps.real_to_hermitean_fft";
  v1258 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.real_to_hermitean_fft", (const unsigned __int8 *)0x19, a1);
  if (!v1259)
    goto LABEL_852;
  v1260 = v1258;
  v1261 = (void *)v1258[2];
  if (v1261 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1258[1];
    v1262 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1261 = (void *)v1260[2];
  }
  else
  {
    v1262 = v1258[3];
  }
  v1263 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1262, (uint64_t)v1261, v1263);
  v1264 = malloc(8uLL);
  v1265 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1260 + 4), v1265, v1264);
  v434 = "mps.reduction_and";
  v1266 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_and", (const unsigned __int8 *)0x11, a1);
  if (!v1267)
    goto LABEL_841;
  v1268 = v1266;
  v1269 = (void *)v1266[2];
  if (v1269 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1266[1];
    v1270 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1269 = (void *)v1268[2];
  }
  else
  {
    v1270 = v1266[3];
  }
  v1271 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1270, (uint64_t)v1269, v1271);
  v1272 = malloc(8uLL);
  v1273 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1268 + 4), v1273, v1272);
  v147 = "mps.reduction_argmax";
  v1274 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_argmax", (const unsigned __int8 *)0x14, a1);
  if (!v1275)
    goto LABEL_847;
  v1276 = v1274;
  v1277 = (void *)v1274[2];
  if (v1277 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1274[1];
    v1278 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1277 = (void *)v1276[2];
  }
  else
  {
    v1278 = v1274[3];
  }
  v1279 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1278, (uint64_t)v1277, v1279);
  v1280 = malloc(8uLL);
  v1281 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1276 + 4), v1281, v1280);
  v147 = "mps.reduction_argmin";
  v1282 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_argmin", (const unsigned __int8 *)0x14, a1);
  if (!v1283)
    goto LABEL_847;
  v1284 = v1282;
  v1285 = (void *)v1282[2];
  if (v1285 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1282[1];
    v1286 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1285 = (void *)v1284[2];
  }
  else
  {
    v1286 = v1282[3];
  }
  v1287 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1286, (uint64_t)v1285, v1287);
  v1288 = malloc(8uLL);
  v1289 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1284 + 4), v1289, v1288);
  v156 = "mps.reduction_logsumexp";
  v1290 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_logsumexp", (const unsigned __int8 *)0x17, a1);
  if (!v1291)
    goto LABEL_854;
  v1292 = v1290;
  v1293 = (void *)v1290[2];
  if (v1293 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1290[1];
    v1294 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1293 = (void *)v1292[2];
  }
  else
  {
    v1294 = v1290[3];
  }
  v1295 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1294, (uint64_t)v1293, v1295);
  v1296 = malloc(8uLL);
  v1297 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1292 + 4), v1297, v1296);
  v434 = "mps.reduction_max";
  v1298 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_max", (const unsigned __int8 *)0x11, a1);
  if (!v1299)
    goto LABEL_841;
  v1300 = v1298;
  v1301 = (void *)v1298[2];
  if (v1301 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1298[1];
    v1302 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1301 = (void *)v1300[2];
  }
  else
  {
    v1302 = v1298[3];
  }
  v1303 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1302, (uint64_t)v1301, v1303);
  v1304 = malloc(8uLL);
  v1305 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1300 + 4), v1305, v1304);
  v262 = "mps.reduction_mean";
  v1306 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_mean", (const unsigned __int8 *)0x12, a1);
  if (!v1307)
    goto LABEL_837;
  v1308 = v1306;
  v1309 = (void *)v1306[2];
  if (v1309 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1306[1];
    v1310 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1309 = (void *)v1308[2];
  }
  else
  {
    v1310 = v1306[3];
  }
  v1311 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1310, (uint64_t)v1309, v1311);
  v1312 = malloc(8uLL);
  v1313 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1308 + 4), v1313, v1312);
  v434 = "mps.reduction_min";
  v1314 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_min", (const unsigned __int8 *)0x11, a1);
  if (!v1315)
    goto LABEL_841;
  v1316 = v1314;
  v1317 = (void *)v1314[2];
  if (v1317 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1314[1];
    v1318 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1317 = (void *)v1316[2];
  }
  else
  {
    v1318 = v1314[3];
  }
  v1319 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1318, (uint64_t)v1317, v1319);
  v1320 = malloc(8uLL);
  v1321 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1316 + 4), v1321, v1320);
  v377 = "mps.reduction_or";
  v1322 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_or", (const unsigned __int8 *)0x10, a1);
  if (!v1323)
  {
LABEL_850:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v377;
    v1691 = 16;
    goto LABEL_862;
  }
  v1324 = v1322;
  v1325 = (void *)v1322[2];
  if (v1325 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1322[1];
    v1326 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1325 = (void *)v1324[2];
  }
  else
  {
    v1326 = v1322[3];
  }
  v1327 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1326, (uint64_t)v1325, v1327);
  v1328 = malloc(8uLL);
  v1329 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1324 + 4), v1329, v1328);
  v262 = "mps.reduction_prod";
  v1330 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_prod", (const unsigned __int8 *)0x12, a1);
  if (!v1331)
    goto LABEL_837;
  v1332 = v1330;
  v1333 = (void *)v1330[2];
  if (v1333 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1330[1];
    v1334 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1333 = (void *)v1332[2];
  }
  else
  {
    v1334 = v1330[3];
  }
  v1335 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1334, (uint64_t)v1333, v1335);
  v1336 = malloc(8uLL);
  v1337 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1332 + 4), v1337, v1336);
  v434 = "mps.reduction_sum";
  v1338 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_sum", (const unsigned __int8 *)0x11, a1);
  if (!v1339)
    goto LABEL_841;
  v1340 = v1338;
  v1341 = (void *)v1338[2];
  if (v1341 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1338[1];
    v1342 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1341 = (void *)v1340[2];
  }
  else
  {
    v1342 = v1338[3];
  }
  v1343 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1342, (uint64_t)v1341, v1343);
  v1344 = malloc(8uLL);
  v1345 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1340 + 4), v1345, v1344);
  v121 = "mps.reduction_variance";
  v1346 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_variance", (const unsigned __int8 *)0x16, a1);
  if (!v1347)
    goto LABEL_848;
  v1348 = v1346;
  v1349 = (void *)v1346[2];
  if (v1349 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1346[1];
    v1350 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1349 = (void *)v1348[2];
  }
  else
  {
    v1350 = v1346[3];
  }
  v1351 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1350, (uint64_t)v1349, v1351);
  v1352 = malloc(8uLL);
  v1353 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1348 + 4), v1353, v1352);
  v221 = "mps.reshape";
  v1354 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, a1);
  if (!v1355)
    goto LABEL_836;
  v1356 = v1354;
  v1357 = (void *)v1354[2];
  if (v1357 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1354[1];
    v1358 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1357 = (void *)v1356[2];
  }
  else
  {
    v1358 = v1354[3];
  }
  v1359 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1358, (uint64_t)v1357, v1359);
  v1360 = malloc(8uLL);
  v1361 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1356 + 4), v1361, v1360);
  v69 = "mps.resize_gradient";
  v1362 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.resize_gradient", (const unsigned __int8 *)0x13, a1);
  if (!v1363)
  {
LABEL_845:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v69;
    v1691 = 19;
    goto LABEL_862;
  }
  v1364 = v1362;
  v1365 = (void *)v1362[2];
  if (v1365 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1362[1];
    v1366 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1365 = (void *)v1364[2];
  }
  else
  {
    v1366 = v1362[3];
  }
  v1367 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1366, (uint64_t)v1365, v1367);
  v1368 = malloc(8uLL);
  v1369 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1364 + 4), v1369, v1368);
  v312 = "mps.resize";
  v1370 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.resize", (const unsigned __int8 *)0xA, a1);
  if (!v1371)
    goto LABEL_842;
  v1372 = v1370;
  v1373 = (void *)v1370[2];
  if (v1373 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1370[1];
    v1374 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1373 = (void *)v1372[2];
  }
  else
  {
    v1374 = v1370[3];
  }
  v1375 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1374, (uint64_t)v1373, v1375);
  v1376 = malloc(8uLL);
  v1377 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1372 + 4), v1377, v1376);
  v221 = "mps.reverse";
  v1378 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reverse", (const unsigned __int8 *)0xB, a1);
  if (!v1379)
    goto LABEL_836;
  v1380 = v1378;
  v1381 = (void *)v1378[2];
  if (v1381 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1378[1];
    v1382 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1381 = (void *)v1380[2];
  }
  else
  {
    v1382 = v1378[3];
  }
  v1383 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1382, (uint64_t)v1381, v1383);
  v1384 = malloc(8uLL);
  v1385 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1380 + 4), v1385, v1384);
  v121 = "mps.scatter_along_axis";
  v1386 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.scatter_along_axis", (const unsigned __int8 *)0x16, a1);
  if (!v1387)
  {
LABEL_848:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v121;
    v1691 = 22;
    goto LABEL_862;
  }
  v1388 = v1386;
  v1389 = (void *)v1386[2];
  if (v1389 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1386[1];
    v1390 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1389 = (void *)v1388[2];
  }
  else
  {
    v1390 = v1386[3];
  }
  v1391 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1390, (uint64_t)v1389, v1391);
  v1392 = malloc(8uLL);
  v1393 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1388 + 4), v1393, v1392);
  v221 = "mps.scatter";
  v1394 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.scatter", (const unsigned __int8 *)0xB, a1);
  if (!v1395)
    goto LABEL_836;
  v1396 = v1394;
  v1397 = (void *)v1394[2];
  if (v1397 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1394[1];
    v1398 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1397 = (void *)v1396[2];
  }
  else
  {
    v1398 = v1394[3];
  }
  v1399 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1398, (uint64_t)v1397, v1399);
  v1400 = malloc(8uLL);
  v1401 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1396 + 4), v1401, v1400);
  v11 = "mps.slice";
  v1402 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, a1);
  if (!v1403)
    goto LABEL_835;
  v1404 = v1402;
  v1405 = (void *)v1402[2];
  if (v1405 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1402[1];
    v1406 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1405 = (void *)v1404[2];
  }
  else
  {
    v1406 = v1402[3];
  }
  v1407 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1406, (uint64_t)v1405, v1407);
  v1408 = malloc(8uLL);
  v1409 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1404 + 4), v1409, v1408);
  v221 = "mps.softmax";
  v1410 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softmax", (const unsigned __int8 *)0xB, a1);
  if (!v1411)
    goto LABEL_836;
  v1412 = v1410;
  v1413 = (void *)v1410[2];
  if (v1413 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1410[1];
    v1414 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1413 = (void *)v1412[2];
  }
  else
  {
    v1414 = v1410[3];
  }
  v1415 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1414, (uint64_t)v1413, v1415);
  v1416 = malloc(8uLL);
  v1417 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1412 + 4), v1417, v1416);
  v2 = "mps.sort";
  v1418 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sort", (const unsigned __int8 *)8, a1);
  if (!v1419)
    goto LABEL_834;
  v1420 = v1418;
  v1421 = (void *)v1418[2];
  if (v1421 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1418[1];
    v1422 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1421 = (void *)v1420[2];
  }
  else
  {
    v1422 = v1418[3];
  }
  v1423 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1422, (uint64_t)v1421, v1423);
  v1424 = malloc(8uLL);
  v1425 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1420 + 4), v1425, v1424);
  v11 = "mps.split";
  v1426 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.split", (const unsigned __int8 *)9, a1);
  if (!v1427)
    goto LABEL_835;
  v1428 = v1426;
  v1429 = (void *)v1426[2];
  if (v1429 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1426[1];
    v1430 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1429 = (void *)v1428[2];
  }
  else
  {
    v1430 = v1426[3];
  }
  v1431 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1430, (uint64_t)v1429, v1431);
  v1432 = malloc(8uLL);
  v1433 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1428 + 4), v1433, v1432);
  v221 = "mps.squeeze";
  v1434 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.squeeze", (const unsigned __int8 *)0xB, a1);
  if (!v1435)
    goto LABEL_836;
  v1436 = v1434;
  v1437 = (void *)v1434[2];
  if (v1437 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1434[1];
    v1438 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1437 = (void *)v1436[2];
  }
  else
  {
    v1438 = v1434[3];
  }
  v1439 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1438, (uint64_t)v1437, v1439);
  v1440 = malloc(8uLL);
  v1441 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1436 + 4), v1441, v1440);
  v798 = "mps.strided_slice_gradient";
  v1442 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.strided_slice_gradient", (const unsigned __int8 *)0x1A, a1);
  if (!v1443)
  {
LABEL_856:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v798;
    v1691 = 26;
    goto LABEL_862;
  }
  v1444 = v1442;
  v1445 = (void *)v1442[2];
  if (v1445 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1442[1];
    v1446 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1445 = (void *)v1444[2];
  }
  else
  {
    v1446 = v1442[3];
  }
  v1447 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1446, (uint64_t)v1445, v1447);
  v1448 = malloc(8uLL);
  v1449 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1444 + 4), v1449, v1448);
  v434 = "mps.strided_slice";
  v1450 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.strided_slice", (const unsigned __int8 *)0x11, a1);
  if (!v1451)
    goto LABEL_841;
  v1452 = v1450;
  v1453 = (void *)v1450[2];
  if (v1453 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1450[1];
    v1454 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1453 = (void *)v1452[2];
  }
  else
  {
    v1454 = v1450[3];
  }
  v1455 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1454, (uint64_t)v1453, v1455);
  v1456 = malloc(8uLL);
  v1457 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1452 + 4), v1457, v1456);
  v725 = "mps.strided_slice_update";
  v1458 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.strided_slice_update", (const unsigned __int8 *)0x18, a1);
  if (!v1459)
  {
LABEL_857:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v725;
    v1691 = 24;
    goto LABEL_862;
  }
  v1460 = v1458;
  v1461 = (void *)v1458[2];
  if (v1461 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1458[1];
    v1462 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1461 = (void *)v1460[2];
  }
  else
  {
    v1462 = v1458[3];
  }
  v1463 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1462, (uint64_t)v1461, v1463);
  v1464 = malloc(8uLL);
  v1465 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1460 + 4), v1465, v1464);
  v434 = "mps.tile_gradient";
  v1466 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.tile_gradient", (const unsigned __int8 *)0x11, a1);
  if (!v1467)
    goto LABEL_841;
  v1468 = v1466;
  v1469 = (void *)v1466[2];
  if (v1469 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1466[1];
    v1470 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1469 = (void *)v1468[2];
  }
  else
  {
    v1470 = v1466[3];
  }
  v1471 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1470, (uint64_t)v1469, v1471);
  v1472 = malloc(8uLL);
  v1473 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1468 + 4), v1473, v1472);
  v2 = "mps.tile";
  v1474 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.tile", (const unsigned __int8 *)8, a1);
  if (!v1475)
  {
LABEL_834:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v2;
    v1691 = 8;
    goto LABEL_862;
  }
  v1476 = v1474;
  v1477 = (void *)v1474[2];
  if (v1477 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1474[1];
    v1478 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1477 = (void *)v1476[2];
  }
  else
  {
    v1478 = v1474[3];
  }
  v1479 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1478, (uint64_t)v1477, v1479);
  v1480 = malloc(8uLL);
  v1481 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1476 + 4), v1481, v1480);
  v138 = "mps.top_k_grad";
  v1482 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.top_k_grad", (const unsigned __int8 *)0xE, a1);
  if (!v1483)
    goto LABEL_846;
  v1484 = v1482;
  v1485 = (void *)v1482[2];
  if (v1485 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1482[1];
    v1486 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1485 = (void *)v1484[2];
  }
  else
  {
    v1486 = v1482[3];
  }
  v1487 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1486, (uint64_t)v1485, v1487);
  v1488 = malloc(8uLL);
  v1489 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1484 + 4), v1489, v1488);
  v11 = "mps.top_k";
  v1490 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.top_k", (const unsigned __int8 *)9, a1);
  if (!v1491)
    goto LABEL_835;
  v1492 = v1490;
  v1493 = (void *)v1490[2];
  if (v1493 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1490[1];
    v1494 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1493 = (void *)v1492[2];
  }
  else
  {
    v1494 = v1490[3];
  }
  v1495 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1494, (uint64_t)v1493, v1495);
  v1496 = malloc(8uLL);
  v1497 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1492 + 4), v1497, v1496);
  v103 = "mps.transpose";
  v1498 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, a1);
  if (!v1499)
  {
LABEL_840:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v103;
    v1691 = 13;
    goto LABEL_862;
  }
  v1500 = v1498;
  v1501 = (void *)v1498[2];
  if (v1501 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1498[1];
    v1502 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1501 = (void *)v1500[2];
  }
  else
  {
    v1502 = v1498[3];
  }
  v1503 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1502, (uint64_t)v1501, v1503);
  v1504 = malloc(8uLL);
  v1505 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1500 + 4), v1505, v1504);
  v2 = "mps.call";
  v1506 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.call", (const unsigned __int8 *)8, a1);
  if (!v1507)
    goto LABEL_834;
  v1508 = v1506;
  v1509 = (void *)v1506[2];
  if (v1509 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1506[1];
    v1510 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1509 = (void *)v1508[2];
  }
  else
  {
    v1510 = v1506[3];
  }
  v1511 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1510, (uint64_t)v1509, v1511);
  v1512 = malloc(8uLL);
  v1513 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1508 + 4), v1513, v1512);
  v262 = "mps.dimension_size";
  v1514 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dimension_size", (const unsigned __int8 *)0x12, a1);
  if (!v1515)
    goto LABEL_837;
  v1516 = v1514;
  v1517 = (void *)v1514[2];
  if (v1517 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1514[1];
    v1518 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1517 = (void *)v1516[2];
  }
  else
  {
    v1518 = v1514[3];
  }
  v1519 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1518, (uint64_t)v1517, v1519);
  v1520 = malloc(8uLL);
  v1521 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1516 + 4), v1521, v1520);
  v2 = "mps.rank";
  v1522 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.rank", (const unsigned __int8 *)8, a1);
  if (!v1523)
    goto LABEL_834;
  v1524 = v1522;
  v1525 = (void *)v1522[2];
  if (v1525 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1522[1];
    v1526 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1525 = (void *)v1524[2];
  }
  else
  {
    v1526 = v1522[3];
  }
  v1527 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1526, (uint64_t)v1525, v1527);
  v1528 = malloc(8uLL);
  v1529 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1524 + 4), v1529, v1528);
  v11 = "mps.shape";
  v1530 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.shape", (const unsigned __int8 *)9, a1);
  if (!v1531)
    goto LABEL_835;
  v1532 = v1530;
  v1533 = (void *)v1530[2];
  if (v1533 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1530[1];
    v1534 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1533 = (void *)v1532[2];
  }
  else
  {
    v1534 = v1530[3];
  }
  v1535 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1534, (uint64_t)v1533, v1535);
  v1536 = malloc(8uLL);
  v1537 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1532 + 4), v1537, v1536);
  v2 = "mps.size";
  v1538 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.size", (const unsigned __int8 *)8, a1);
  if (!v1539)
    goto LABEL_834;
  v1540 = v1538;
  v1541 = (void *)v1538[2];
  if (v1541 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1538[1];
    v1542 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1541 = (void *)v1540[2];
  }
  else
  {
    v1542 = v1538[3];
  }
  v1543 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1542, (uint64_t)v1541, v1543);
  v1544 = malloc(8uLL);
  v1545 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1540 + 4), v1545, v1544);
  v434 = "mps.random_normal";
  v1546 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.random_normal", (const unsigned __int8 *)0x11, a1);
  if (!v1547)
    goto LABEL_841;
  v1548 = v1546;
  v1549 = (void *)v1546[2];
  if (v1549 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1546[1];
    v1550 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1549 = (void *)v1548[2];
  }
  else
  {
    v1550 = v1546[3];
  }
  v1551 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1550, (uint64_t)v1549, v1551);
  v1552 = malloc(8uLL);
  v1553 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1548 + 4), v1553, v1552);
  v895 = "mps.random_truncated_normal";
  v1554 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.random_truncated_normal", (const unsigned __int8 *)0x1B, a1);
  if (!v1555)
    goto LABEL_853;
  v1556 = v1554;
  v1557 = (void *)v1554[2];
  if (v1557 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1554[1];
    v1558 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1557 = (void *)v1556[2];
  }
  else
  {
    v1558 = v1554[3];
  }
  v1559 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1558, (uint64_t)v1557, v1559);
  v1560 = malloc(8uLL);
  v1561 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1556 + 4), v1561, v1560);
  v262 = "mps.random_uniform";
  v1562 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.random_uniform", (const unsigned __int8 *)0x12, a1);
  if (!v1563)
    goto LABEL_837;
  v1564 = v1562;
  v1565 = (void *)v1562[2];
  if (v1565 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1562[1];
    v1566 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1565 = (void *)v1564[2];
  }
  else
  {
    v1566 = v1562[3];
  }
  v1567 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1566, (uint64_t)v1565, v1567);
  v1568 = malloc(8uLL);
  v1569 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1564 + 4), v1569, v1568);
  v692 = "mps.init_random_philox_state";
  v1570 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.init_random_philox_state", (const unsigned __int8 *)0x1C, a1);
  if (!v1571)
    goto LABEL_851;
  v1572 = v1570;
  v1573 = (void *)v1570[2];
  if (v1573 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1570[1];
    v1574 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1573 = (void *)v1572[2];
  }
  else
  {
    v1574 = v1570[3];
  }
  v1575 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1574, (uint64_t)v1573, v1575);
  v1576 = malloc(8uLL);
  v1577 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1572 + 4), v1577, v1576);
  v156 = "mps.update_random_state";
  v1578 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.update_random_state", (const unsigned __int8 *)0x17, a1);
  if (!v1579)
    goto LABEL_854;
  v1580 = v1578;
  v1581 = (void *)v1578[2];
  if (v1581 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1578[1];
    v1582 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1581 = (void *)v1580[2];
  }
  else
  {
    v1582 = v1578[3];
  }
  v1583 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1582, (uint64_t)v1581, v1583);
  v1584 = malloc(8uLL);
  v1585 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1580 + 4), v1585, v1584);
  v262 = "mps.batch_to_space";
  v1586 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.batch_to_space", (const unsigned __int8 *)0x12, a1);
  if (!v1587)
    goto LABEL_837;
  v1588 = v1586;
  v1589 = (void *)v1586[2];
  if (v1589 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1586[1];
    v1590 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1589 = (void *)v1588[2];
  }
  else
  {
    v1590 = v1586[3];
  }
  v1591 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1590, (uint64_t)v1589, v1591);
  v1592 = malloc(8uLL);
  v1593 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1588 + 4), v1593, v1592);
  v262 = "mps.space_to_batch";
  v1594 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.space_to_batch", (const unsigned __int8 *)0x12, a1);
  if (!v1595)
    goto LABEL_837;
  v1596 = v1594;
  v1597 = (void *)v1594[2];
  if (v1597 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1594[1];
    v1598 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1597 = (void *)v1596[2];
  }
  else
  {
    v1598 = v1594[3];
  }
  v1599 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1598, (uint64_t)v1597, v1599);
  v1600 = malloc(8uLL);
  v1601 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1596 + 4), v1601, v1600);
  v279 = "mps.space_to_depth_2d";
  v1602 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.space_to_depth_2d", (const unsigned __int8 *)0x15, a1);
  if (!v1603)
    goto LABEL_849;
  v1604 = v1602;
  v1605 = (void *)v1602[2];
  if (v1605 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1602[1];
    v1606 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1605 = (void *)v1604[2];
  }
  else
  {
    v1606 = v1602[3];
  }
  v1607 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1606, (uint64_t)v1605, v1607);
  v1608 = malloc(8uLL);
  v1609 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1604 + 4), v1609, v1608);
  v279 = "mps.depth_to_space_2d";
  v1610 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depth_to_space_2d", (const unsigned __int8 *)0x15, a1);
  if (!v1611)
  {
LABEL_849:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v279;
    v1691 = 21;
    goto LABEL_862;
  }
  v1612 = v1610;
  v1613 = (void *)v1610[2];
  if (v1613 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1610[1];
    v1614 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1613 = (void *)v1612[2];
  }
  else
  {
    v1614 = v1610[3];
  }
  v1615 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1614, (uint64_t)v1613, v1615);
  v1616 = malloc(8uLL);
  v1617 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1612 + 4), v1617, v1616);
  v895 = "mps.broadcast_gradient_args";
  v1618 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.broadcast_gradient_args", (const unsigned __int8 *)0x1B, a1);
  if (!v1619)
    goto LABEL_853;
  v1620 = v1618;
  v1621 = (void *)v1618[2];
  if (v1621 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1618[1];
    v1622 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1621 = (void *)v1620[2];
  }
  else
  {
    v1622 = v1618[3];
  }
  v1623 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1622, (uint64_t)v1621, v1623);
  v1624 = malloc(8uLL);
  v1625 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1620 + 4), v1625, v1624);
  v1056 = "mps.create_texture_tensor";
  v1626 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.create_texture_tensor", (const unsigned __int8 *)0x19, a1);
  if (!v1627)
  {
LABEL_852:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v1056;
    v1691 = 25;
    goto LABEL_862;
  }
  v1628 = v1626;
  v1629 = (void *)v1626[2];
  if (v1629 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1626[1];
    v1630 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1629 = (void *)v1628[2];
  }
  else
  {
    v1630 = v1626[3];
  }
  v1631 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1630, (uint64_t)v1629, v1631);
  v1632 = malloc(8uLL);
  v1633 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1628 + 4), v1633, v1632);
  v1634 = "mps.materialize_sparse_tensor";
  v1635 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.materialize_sparse_tensor", (const unsigned __int8 *)0x1D, a1);
  if (!v1636)
    goto LABEL_859;
  v1637 = v1635;
  v1638 = (void *)v1635[2];
  if (v1638 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1635[1];
    v1639 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1638 = (void *)v1637[2];
  }
  else
  {
    v1639 = v1635[3];
  }
  v1640 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1639, (uint64_t)v1638, v1640);
  v1641 = malloc(8uLL);
  v1642 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1637 + 4), v1642, v1641);
  v895 = "mps.matrix_decomposition_lu";
  v1643 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matrix_decomposition_lu", (const unsigned __int8 *)0x1B, a1);
  if (!v1644)
  {
LABEL_853:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v895;
    v1691 = 27;
    goto LABEL_862;
  }
  v1645 = v1643;
  v1646 = (void *)v1643[2];
  if (v1646 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1643[1];
    v1647 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1646 = (void *)v1645[2];
  }
  else
  {
    v1647 = v1643[3];
  }
  v1648 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1647, (uint64_t)v1646, v1648);
  v1649 = malloc(8uLL);
  v1650 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1645 + 4), v1650, v1649);
  v262 = "mps.matrix_inverse";
  v1651 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matrix_inverse", (const unsigned __int8 *)0x12, a1);
  if (!v1652)
  {
LABEL_837:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v262;
    v1691 = 18;
    goto LABEL_862;
  }
  v1653 = v1651;
  v1654 = (void *)v1651[2];
  if (v1654 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1651[1];
    v1655 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1654 = (void *)v1653[2];
  }
  else
  {
    v1655 = v1651[3];
  }
  v1656 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1655, (uint64_t)v1654, v1656);
  v1657 = malloc(8uLL);
  v1658 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1653 + 4), v1658, v1657);
  v147 = "mps.matrix_solver_lu";
  v1659 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matrix_solver_lu", (const unsigned __int8 *)0x14, a1);
  if (!v1660)
  {
LABEL_847:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v147;
    v1691 = 20;
    goto LABEL_862;
  }
  v1661 = v1659;
  v1662 = (void *)v1659[2];
  if (v1662 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1659[1];
    v1663 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1662 = (void *)v1661[2];
  }
  else
  {
    v1663 = v1659[3];
  }
  v1664 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1663, (uint64_t)v1662, v1664);
  v1665 = malloc(8uLL);
  v1666 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1661 + 4), v1666, v1665);
  v895 = "mps.non_maximum_suppression";
  v1667 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.non_maximum_suppression", (const unsigned __int8 *)0x1B, a1);
  if (!v1668)
    goto LABEL_853;
  v1669 = v1667;
  v1670 = (void *)v1667[2];
  if (v1670 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1667[1];
    v1671 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1670 = (void *)v1669[2];
  }
  else
  {
    v1671 = v1667[3];
  }
  v1672 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1671, (uint64_t)v1670, v1672);
  v1673 = malloc(8uLL);
  v1674 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1669 + 4), v1674, v1673);
  v1634 = "mps.sample_grid_data_gradient";
  v1675 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sample_grid_data_gradient", (const unsigned __int8 *)0x1D, a1);
  if (!v1676)
  {
LABEL_859:
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = v1634;
    v1691 = 29;
    goto LABEL_862;
  }
  v1677 = v1675;
  v1678 = (void *)v1675[2];
  if (v1678 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1675[1];
    v1679 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1678 = (void *)v1677[2];
  }
  else
  {
    v1679 = v1675[3];
  }
  v1680 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1679, (uint64_t)v1678, v1680);
  v1681 = malloc(8uLL);
  v1682 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1677 + 4), v1682, v1681);
  v1683 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sample_grid", (const unsigned __int8 *)0xF, a1);
  if (!v1684)
  {
    v1697 = 1283;
    v1694 = "Attempting to attach an interface to an unregistered operation ";
    v1695 = "mps.sample_grid";
    goto LABEL_844;
  }
  v1685 = v1683;
  v1686 = (void *)v1683[2];
  if (v1686 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v1698[0] = v1683[1];
    v1687 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v1698);
    v1686 = (void *)v1685[2];
  }
  else
  {
    v1687 = v1683[3];
  }
  v1688 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v1687, (uint64_t)v1686, v1688);
  v1689 = malloc(8uLL);
  v1690 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v1685 + 4), v1690, v1689);
}

__guard mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>()
{
  unsigned __int8 v0;
  __guard *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  if ((v0 & 1) == 0)
  {
    if (v3)
    {
      v11 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MPSRuntimeDynamicEncodeOpInterface]";
      v12 = 90;
      v4 = llvm::StringRef::find((uint64_t *)&v11, "DesiredTypeName = ", 0x12uLL, 0);
      if (v12 >= v4)
        v5 = v4;
      else
        v5 = v12;
      v6 = &v11[v5];
      v7 = v12 - v5;
      if (v12 - v5 >= 0x12)
        v8 = 18;
      else
        v8 = v12 - v5;
      v9 = v7 - v8;
      if (v9 >= v9 - 1)
        v10 = v9 - 1;
      else
        v10 = v9;
      mlir::detail::TypeIDResolver<mlir::MPSRuntimeDynamicEncodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v6[v8], v10);
    }
  }
  return v1[128];
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ACosOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ACoshOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ASinOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ASinhOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ATan2Op>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ATanOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ATanhOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::AbsoluteOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::AbsoluteSquareOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::AddOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::AndOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::AssignVariableOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::BandPartOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::BitwiseAndOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::BitwiseLeftShiftOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::BitwiseNotOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::BitwiseOrOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::BitwisePopcountOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::BitwiseRightShiftOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::BitwiseXorOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::CastOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::CeilOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ClampOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ColToImOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ConjugateOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ConstantOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::Conv2DOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::Conv3DOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::CosOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::CoshOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::CostVolumeOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::CreateComplexOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::CropResizeOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::DepthwiseConv2DOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::DepthwiseConv3DOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::DequantizeLUTOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::DequantizeOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::DivideOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::DynamicShapeCastOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::EluOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::EqualToOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ErfOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ExponentBase10Op>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ExponentBase2Op>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ExponentOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::FloorDivideOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::FloorOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::GRUGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::GRUOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::GatherNDOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::GeluOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::GreaterThanOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::GreaterThanOrEqualToOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::HammingDistanceOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::IdentityOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ImToColOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ImaginaryPartOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::IsFiniteOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::IsInfiniteOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::IsNaNOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LSTMGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LSTMOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LeakyReluOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LessThanOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LessThanOrEqualToOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LocalConvolutionDataGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LocalConvolutionOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LocalConvolutionWeightGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LogarithmBase10Op>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LogarithmBase2Op>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::LogarithmOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::MatMulOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::MaximumOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::MinimumOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ModuloOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::MultiplyOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::NReluOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::NandOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::NegativeOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::NorOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::NotEqualToOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::NotOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::OrOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PReluOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PoolAvgGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PoolAvgOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PoolL2NormGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PoolL2NormOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PoolMaxGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PoolMaxOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PowerOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PruningGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::PruningOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::QuantizeOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ReadVariableOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::RealPartOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ReciprocalOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ReciprocalSquareRootOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ReinterpretCastOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::Relu6Op>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ReluGradOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ReluOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::RintOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::RoundOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::ScatterNDOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SelectOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SignOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SignbitOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SinOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SingleGateRNNGradientOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SingleGateRNNOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SinhOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SoftplusOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SoftplusParametricOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SoftsignOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SquareOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SquareRootOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::StencilOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SubtractOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::SwishOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::TanOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::TanhOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::TruncateOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::TypeConstraintOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::VariableFromTensorOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::XnorOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mps::XorOp>>::isDynamicallyEncoded()
{
  return 0;
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::BroadcastToOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ConcatOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  _BOOL8 result;

  result = 0;
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
  {
    v3 = *(_DWORD *)(a2 + 68);
    if (v3)
    {
      if (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 32 * (v3 - 1) + 24)))return 1;
    }
  }
  return result;
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::Conv2DDataGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::Conv2DWeightsGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::Conv3DDataGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::Conv3DWeightsGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::CropOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56))
       || (*(_BYTE *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 3u
       && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88))
        || (*(_BYTE *)(a2 + 46) & 0x80) != 0
        && *(_DWORD *)(a2 + 68) >= 4u
        && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 120))));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::CumulativeMaximumOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::CumulativeMinimumOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::CumulativeProductOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::CumulativeSumOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::DepthwiseConv2DDataGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::DepthwiseConv2DWeightsGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::DepthwiseConv3DDataGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::DepthwiseConv3DWeightsGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ExpandDimsOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::FastFourierTransformOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::Flatten2DOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::GatherAlongAxisOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::GatherOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::GetCoordOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68)
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::HermiteanToRealFFTOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::InstanceNormOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::OneHotOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56))
       || (*(_BYTE *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 3u
       && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88)));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::PadGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::PadOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::PermuteOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::RealToHermiteanFFTOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionAndOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionArgMaxOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionArgMinOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionLogSumExpOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionMaxOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionMeanOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionMinOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionOrOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionProdOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionSumOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReductionVarianceOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReshapeOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ResizeGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ResizeOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ReverseOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ScatterAlongAxisOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 4u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 120));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::ScatterOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 4u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 120));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::SliceOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56))
       || (*(_BYTE *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 3u
       && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88))
        || (*(_BYTE *)(a2 + 46) & 0x80) != 0
        && *(_DWORD *)(a2 + 68) >= 4u
        && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 120))));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::SoftmaxOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::SortOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::SplitOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56))
       || (*(_BYTE *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 3u
       && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88)));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::SqueezeOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::StridedSliceGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56))
       || (*(_BYTE *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 3u
       && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88))
        || (*(_BYTE *)(a2 + 46) & 0x80) != 0
        && *(_DWORD *)(a2 + 68) >= 4u
        && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 120))
         || (*(_BYTE *)(a2 + 46) & 0x80) != 0
         && *(_DWORD *)(a2 + 68) >= 5u
         && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 152)))));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::StridedSliceOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56))
       || (*(_BYTE *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 3u
       && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88))
        || (*(_BYTE *)(a2 + 46) & 0x80) != 0
        && *(_DWORD *)(a2 + 68) >= 4u
        && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 120))));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::StridedSliceUpdateOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88))
       || (*(_BYTE *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 4u
       && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 120))
        || (*(_BYTE *)(a2 + 46) & 0x80) != 0
        && *(_DWORD *)(a2 + 68) >= 5u
        && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 152))));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::TileGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::TileOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::TopKGradientOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88))
       || (*(_BYTE *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 4u
       && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 120)));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::TopKOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56))
       || (*(_BYTE *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 3u
       && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88)));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mps::TransposeOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 2u
      && (!mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 56))
       || (*(_BYTE *)(a2 + 46) & 0x80) != 0
       && *(_DWORD *)(a2 + 68) >= 3u
       && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88)));
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::CallOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::DimensionSizeOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::RankOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::ShapeOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::SizeOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::RandomNormalOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::RandomTruncatedNormalOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::RandomUniformOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::InitRandomPhiloxStateOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::UpdateRandomStateOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::BatchToSpaceOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::SpaceToBatchOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::SpaceToDepth2DOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::DepthToSpace2DOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::BroadcastGradientArgsOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::CreateTextureTensorOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::MaterializeSparseTensorOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::MatrixDecompositionLUOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::MatrixInverseOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::MatrixSolverLUOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::NonMaximumSuppressionOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::SampleGridDataGradientOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mps::SampleGridOp>>::isDynamicallyEncoded()
{
  return 1;
}

void mlir::mps::registerMPSRuntimeDynamicEncodeOpExternalModels(mlir::DialectRegistry &)::$_1::__invoke(uint64_t *a1)
{
  _QWORD *v2;
  char v3;
  _QWORD *v4;
  void *v5;
  uint64_t Values;
  __guard v7;
  _QWORD *v8;
  __guard v9;
  const char *v10;
  _QWORD *v11;
  char v12;
  _QWORD *v13;
  void *v14;
  uint64_t v15;
  __guard v16;
  _QWORD *v17;
  __guard v18;
  const char *v19;
  _QWORD *v20;
  char v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  __guard v25;
  _QWORD *v26;
  __guard v27;
  _QWORD *v28;
  char v29;
  _QWORD *v30;
  void *v31;
  uint64_t v32;
  __guard v33;
  _QWORD *v34;
  __guard v35;
  _QWORD *v36;
  char v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  __guard v41;
  _QWORD *v42;
  __guard v43;
  _QWORD *v44;
  char v45;
  _QWORD *v46;
  void *v47;
  uint64_t v48;
  __guard v49;
  _QWORD *v50;
  __guard v51;
  _QWORD *v52;
  char v53;
  _QWORD *v54;
  void *v55;
  uint64_t v56;
  __guard v57;
  _QWORD *v58;
  __guard v59;
  const char *v60;
  _QWORD *v61;
  char v62;
  _QWORD *v63;
  void *v64;
  uint64_t v65;
  __guard v66;
  _QWORD *v67;
  __guard v68;
  _QWORD *v69;
  char v70;
  _QWORD *v71;
  void *v72;
  uint64_t v73;
  __guard v74;
  _QWORD *v75;
  __guard v76;
  const char *v77;
  _QWORD *v78;
  char v79;
  _QWORD *v80;
  void *v81;
  uint64_t v82;
  __guard v83;
  _QWORD *v84;
  __guard v85;
  _QWORD *v86;
  char v87;
  _QWORD *v88;
  void *v89;
  uint64_t v90;
  __guard v91;
  _QWORD *v92;
  __guard v93;
  _QWORD *v94;
  char v95;
  _QWORD *v96;
  void *v97;
  uint64_t v98;
  __guard v99;
  _QWORD *v100;
  __guard v101;
  _QWORD *v102;
  char v103;
  _QWORD *v104;
  void *v105;
  uint64_t v106;
  __guard v107;
  _QWORD *v108;
  __guard v109;
  _QWORD *v110;
  char v111;
  _QWORD *v112;
  void *v113;
  uint64_t v114;
  __guard v115;
  _QWORD *v116;
  __guard v117;
  _QWORD *v118;
  char v119;
  _QWORD *v120;
  void *v121;
  uint64_t v122;
  __guard v123;
  _QWORD *v124;
  __guard v125;
  _QWORD *v126;
  char v127;
  _QWORD *v128;
  void *v129;
  uint64_t v130;
  __guard v131;
  _QWORD *v132;
  __guard v133;
  _QWORD *v134;
  char v135;
  _QWORD *v136;
  void *v137;
  uint64_t v138;
  __guard v139;
  _QWORD *v140;
  __guard v141;
  uint64_t v142;
  const char *v143;
  __int16 v144;
  const char *v145;
  const char *v146;
  uint64_t v147;
  __int16 v148;
  _QWORD v149[5];

  v2 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.fp_to_int_clamped", (const unsigned __int8 *)0x16, a1);
  if (!v3)
  {
    v148 = 1283;
    v145 = "Attempting to attach an interface to an unregistered operation ";
    v146 = "mpsx.fp_to_int_clamped";
    v142 = 22;
    goto LABEL_82;
  }
  v4 = v2;
  v5 = (void *)v2[2];
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v2[1];
    Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v5 = (void *)v4[2];
  }
  else
  {
    Values = v2[3];
  }
  v7 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(Values, (uint64_t)v5, v7);
  v8 = malloc(8uLL);
  v9 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v4 + 4), v9, v8);
  v10 = "mpsx.quantized_matmul";
  v11 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.quantized_matmul", (const unsigned __int8 *)0x15, a1);
  if (!v12)
    goto LABEL_71;
  v13 = v11;
  v14 = (void *)v11[2];
  if (v14 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v11[1];
    v15 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v14 = (void *)v13[2];
  }
  else
  {
    v15 = v11[3];
  }
  v16 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v15, (uint64_t)v14, v16);
  v17 = malloc(8uLL);
  v18 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v13 + 4), v18, v17);
  v19 = "mpsx.region_return";
  v20 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.region_return", (const unsigned __int8 *)0x12, a1);
  if (!v21)
    goto LABEL_73;
  v22 = v20;
  v23 = (void *)v20[2];
  if (v23 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v20[1];
    v24 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v23 = (void *)v22[2];
  }
  else
  {
    v24 = v20[3];
  }
  v25 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v24, (uint64_t)v23, v25);
  v26 = malloc(8uLL);
  v27 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v22 + 4), v27, v26);
  v28 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.stitched_return", (const unsigned __int8 *)0x14, a1);
  if (!v29)
  {
    v148 = 1283;
    v145 = "Attempting to attach an interface to an unregistered operation ";
    v146 = "mpsx.stitched_return";
    v142 = 20;
    goto LABEL_82;
  }
  v30 = v28;
  v31 = (void *)v28[2];
  if (v31 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v28[1];
    v32 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v31 = (void *)v30[2];
  }
  else
  {
    v32 = v28[3];
  }
  v33 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v32, (uint64_t)v31, v33);
  v34 = malloc(8uLL);
  v35 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v30 + 4), v35, v34);
  v36 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.sdpa", (const unsigned __int8 *)9, a1);
  if (!v37)
  {
    v148 = 1283;
    v145 = "Attempting to attach an interface to an unregistered operation ";
    v146 = "mpsx.sdpa";
    v142 = 9;
    goto LABEL_82;
  }
  v38 = v36;
  v39 = (void *)v36[2];
  if (v39 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v36[1];
    v40 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v39 = (void *)v38[2];
  }
  else
  {
    v40 = v36[3];
  }
  v41 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v40, (uint64_t)v39, v41);
  v42 = malloc(8uLL);
  v43 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v38 + 4), v43, v42);
  v44 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.var_handle", (const unsigned __int8 *)0xF, a1);
  if (!v45)
  {
    v148 = 1283;
    v145 = "Attempting to attach an interface to an unregistered operation ";
    v146 = "mpsx.var_handle";
    v142 = 15;
    goto LABEL_82;
  }
  v46 = v44;
  v47 = (void *)v44[2];
  if (v47 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v44[1];
    v48 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v47 = (void *)v46[2];
  }
  else
  {
    v48 = v44[3];
  }
  v49 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v48, (uint64_t)v47, v49);
  v50 = malloc(8uLL);
  v51 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v46 + 4), v51, v50);
  v10 = "mpsx.quantized_gather";
  v52 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.quantized_gather", (const unsigned __int8 *)0x15, a1);
  if (!v53)
  {
LABEL_71:
    v148 = 1283;
    v145 = "Attempting to attach an interface to an unregistered operation ";
    v146 = v10;
    v142 = 21;
    goto LABEL_82;
  }
  v54 = v52;
  v55 = (void *)v52[2];
  if (v55 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v52[1];
    v56 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v55 = (void *)v54[2];
  }
  else
  {
    v56 = v52[3];
  }
  v57 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v56, (uint64_t)v55, v57);
  v58 = malloc(8uLL);
  v59 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v54 + 4), v59, v58);
  v60 = "mpsx.rms_norm";
  v61 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.rms_norm", (const unsigned __int8 *)0xD, a1);
  if (!v62)
    goto LABEL_72;
  v63 = v61;
  v64 = (void *)v61[2];
  if (v64 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v61[1];
    v65 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v64 = (void *)v63[2];
  }
  else
  {
    v65 = v61[3];
  }
  v66 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v65, (uint64_t)v64, v66);
  v67 = malloc(8uLL);
  v68 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v63 + 4), v68, v67);
  v60 = "mpsx.stitched";
  v69 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.stitched", (const unsigned __int8 *)0xD, a1);
  if (!v70)
  {
LABEL_72:
    v148 = 1283;
    v145 = "Attempting to attach an interface to an unregistered operation ";
    v146 = v60;
    v142 = 13;
    goto LABEL_82;
  }
  v71 = v69;
  v72 = (void *)v69[2];
  if (v72 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v69[1];
    v73 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v72 = (void *)v71[2];
  }
  else
  {
    v73 = v69[3];
  }
  v74 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v73, (uint64_t)v72, v74);
  v75 = malloc(8uLL);
  v76 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v71 + 4), v76, v75);
  v77 = "mpsx.cpu";
  v78 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.cpu", (const unsigned __int8 *)8, a1);
  if (!v79)
    goto LABEL_70;
  v80 = v78;
  v81 = (void *)v78[2];
  if (v81 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v78[1];
    v82 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v81 = (void *)v80[2];
  }
  else
  {
    v82 = v78[3];
  }
  v83 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v82, (uint64_t)v81, v83);
  v84 = malloc(8uLL);
  v85 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v80 + 4), v85, v84);
  v86 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.file_backed_constant", (const unsigned __int8 *)0x19, a1);
  if (!v87)
  {
    v148 = 1283;
    v145 = "Attempting to attach an interface to an unregistered operation ";
    v146 = "mpsx.file_backed_constant";
    v142 = 25;
    goto LABEL_82;
  }
  v88 = v86;
  v89 = (void *)v86[2];
  if (v89 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v86[1];
    v90 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v89 = (void *)v88[2];
  }
  else
  {
    v90 = v86[3];
  }
  v91 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v90, (uint64_t)v89, v91);
  v92 = malloc(8uLL);
  v93 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v88 + 4), v93, v92);
  v77 = "mpsx.ane";
  v94 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.ane", (const unsigned __int8 *)8, a1);
  if (!v95)
    goto LABEL_70;
  v96 = v94;
  v97 = (void *)v94[2];
  if (v97 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v94[1];
    v98 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v97 = (void *)v96[2];
  }
  else
  {
    v98 = v94[3];
  }
  v99 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v98, (uint64_t)v97, v99);
  v100 = malloc(8uLL);
  v101 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v96 + 4), v101, v100);
  v77 = "mpsx.gpu";
  v102 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.gpu", (const unsigned __int8 *)8, a1);
  if (!v103)
  {
LABEL_70:
    v148 = 1283;
    v145 = "Attempting to attach an interface to an unregistered operation ";
    v146 = v77;
    v142 = 8;
    goto LABEL_82;
  }
  v104 = v102;
  v105 = (void *)v102[2];
  if (v105 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v102[1];
    v106 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v105 = (void *)v104[2];
  }
  else
  {
    v106 = v102[3];
  }
  v107 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v106, (uint64_t)v105, v107);
  v108 = malloc(8uLL);
  v109 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v104 + 4), v109, v108);
  v19 = "mpsx.list_pop_back";
  v110 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.list_pop_back", (const unsigned __int8 *)0x12, a1);
  if (!v111)
  {
LABEL_73:
    v148 = 1283;
    v145 = "Attempting to attach an interface to an unregistered operation ";
    v146 = v19;
    v142 = 18;
    goto LABEL_82;
  }
  v112 = v110;
  v113 = (void *)v110[2];
  if (v113 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v110[1];
    v114 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v113 = (void *)v112[2];
  }
  else
  {
    v114 = v110[3];
  }
  v115 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v114, (uint64_t)v113, v115);
  v116 = malloc(8uLL);
  v117 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v112 + 4), v117, v116);
  v118 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.list_push_back", (const unsigned __int8 *)0x13, a1);
  if (!v119)
  {
    v148 = 1283;
    v145 = "Attempting to attach an interface to an unregistered operation ";
    v146 = "mpsx.list_push_back";
    v142 = 19;
    goto LABEL_82;
  }
  v120 = v118;
  v121 = (void *)v118[2];
  if (v121 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v118[1];
    v122 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v121 = (void *)v120[2];
  }
  else
  {
    v122 = v118[3];
  }
  v123 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v122, (uint64_t)v121, v123);
  v124 = malloc(8uLL);
  v125 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v120 + 4), v125, v124);
  v126 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.make_list", (const unsigned __int8 *)0xE, a1);
  if (!v127)
  {
    v148 = 1283;
    v145 = "Attempting to attach an interface to an unregistered operation ";
    v146 = "mpsx.make_list";
    v142 = 14;
    goto LABEL_82;
  }
  v128 = v126;
  v129 = (void *)v126[2];
  if (v129 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v126[1];
    v130 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v129 = (void *)v128[2];
  }
  else
  {
    v130 = v126[3];
  }
  v131 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v130, (uint64_t)v129, v131);
  v132 = malloc(8uLL);
  v133 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v128 + 4), v133, v132);
  v134 = (_QWORD *)mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.sparse_dense_matmul", (const unsigned __int8 *)0x18, a1);
  if (!v135)
  {
    v148 = 1283;
    v145 = "Attempting to attach an interface to an unregistered operation ";
    v146 = "mpsx.sparse_dense_matmul";
    v142 = 24;
LABEL_82:
    v147 = v142;
    v143 = ".";
    v144 = 259;
    llvm::operator+((uint64_t *)&v145, (uint64_t *)&v143, (uint64_t)v149);
    llvm::report_fatal_error((llvm::Twine *)v149, 1);
  }
  v136 = v134;
  v137 = (void *)v134[2];
  if (v137 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v149[0] = v134[1];
    v138 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v149);
    v137 = (void *)v136[2];
  }
  else
  {
    v138 = v134[3];
  }
  v139 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::dialect_extension_detail::handleAdditionOfUndefinedPromisedInterface(v138, (uint64_t)v137, v139);
  v140 = malloc(8uLL);
  v141 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
  mlir::detail::InterfaceMap::insert((uint64_t)(v136 + 4), v141, v140);
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mpsx::FPToIntClampedOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mpsx::QuantizedMatMulOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mpsx::RegionReturnOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mpsx::ReturnStitchedOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mpsx::ScaledDotProductAttentionOp>>::isDynamicallyEncoded()
{
  return 0;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::NeverDynamicEncodeOpInterface<mlir::mpsx::VarHandleOp>>::isDynamicallyEncoded()
{
  return 0;
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mpsx::QuantizedGatherOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88));
}

BOOL mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mpsx::RMSNormOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(_BYTE *)(a2 + 46) & 0x80) != 0
      && *(_DWORD *)(a2 + 68) >= 3u
      && !mlir::mps::ConstantRuntimeAnalysis::isConstant(a3, *(_QWORD *)(*(_QWORD *)(a2 + 72) + 88));
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::ConditionalDynamicEncodeOpInterface<mlir::mpsx::StitchedOp>>::isDynamicallyEncoded(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Region *Body;
  mlir::GenericProgramPoint *v5;
  mlir::GenericProgramPoint *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (**InterfaceFor)(_QWORD, uint64_t, uint64_t);
  uint64_t v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v13;
  __int128 v14;
  mlir::GenericProgramPoint *v15;

  v13 = a2;
  Body = (mlir::Region *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v13);
  mlir::Region::OpIterator::OpIterator(&v14, Body, 0);
  mlir::Region::OpIterator::OpIterator(&v11, Body, 1);
  v5 = v15;
  v6 = v12;
  if (v15 == v12)
    return 0;
  while (1)
  {
    mlir::GenericProgramPoint::~GenericProgramPoint(v5);
    v8 = v7;
    if (!mlir::OpInterface<mlir::MPSRuntimeDynamicEncodeOpInterface,mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits>::getInterfaceFor(v7))
      break;
    InterfaceFor = (uint64_t (**)(_QWORD, uint64_t, uint64_t))mlir::OpInterface<mlir::MPSRuntimeDynamicEncodeOpInterface,mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits>::getInterfaceFor(v8);
    if (!v8 || ((*InterfaceFor)(InterfaceFor, v8, a3) & 1) != 0)
      break;
    mlir::Region::OpIterator::operator++((uint64_t *)&v14);
    v5 = v15;
    if (v15 == v6)
      return 0;
  }
  return 1;
}

uint64_t mlir::OpInterface<mlir::MPSRuntimeDynamicEncodeOpInterface,mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  BOOL v3;
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  __guard v18;
  uint64_t v19;
  __guard v20;
  uint64_t v21;

  v1 = *(_QWORD *)(a1 + 48);
  v2 = *(void **)(v1 + 16);
  v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
    v4 = 0;
  else
    v4 = *(_QWORD *)(a1 + 48);
  if (v3)
  {
    v21 = *(_QWORD *)(v1 + 8);
    result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v21);
    if (result)
    {
      v19 = result;
      v20 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
      return (*(uint64_t (**)(uint64_t, __guard, uint64_t))(*(_QWORD *)v19 + 104))(v19, v20, v1);
    }
  }
  else
  {
    v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    v7 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
    v8 = *(unsigned int *)(v6 + 40);
    if (!(_DWORD)v8)
      goto LABEL_14;
    v9 = *(_QWORD **)(v6 + 32);
    v10 = &v9[2 * v8];
    do
    {
      v11 = v8 >> 1;
      v12 = &v9[2 * (v8 >> 1)];
      v14 = *v12;
      v13 = v12 + 2;
      v8 += ~(v8 >> 1);
      if (v14 < v7)
        v9 = v13;
      else
        v8 = v11;
    }
    while (v8);
    if (v9 == v10 || *v9 != v7 || (result = v9[1]) == 0)
    {
LABEL_14:
      v16 = *(_QWORD *)(v6 + 24);
      v17 = *(_QWORD *)(a1 + 48);
      v18 = mlir::TypeID::get<mlir::MPSRuntimeDynamicEncodeOpInterface>();
      return (*(uint64_t (**)(uint64_t, __guard, uint64_t))(*(_QWORD *)v16 + 104))(v16, v18, v17);
    }
  }
  return result;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mpsx::CPUOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mpsx::FileBackedConstantOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mpsx::ANEOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mpsx::GPUOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mpsx::ListPopBackOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mpsx::ListPushBackOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mpsx::MakeListOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::detail::MPSRuntimeDynamicEncodeOpInterfaceInterfaceTraits::FallbackModel<mlir::mps::`anonymous namespace'::AlwaysDynamicEncodeOpInterface<mlir::mpsx::SparseDenseMatMulOp>>::isDynamicallyEncoded()
{
  return 1;
}

uint64_t mlir::mps::ArchiveWrapper::ArchiveWrapper(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  size_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  char v12;
  void *v13;
  size_t v14;
  void **p_dst;
  size_t v16;
  uint64_t v17;
  size_t v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  unint64_t v22;
  unsigned __int8 *v23;
  uint64_t v24;
  void *v25;
  unint64_t v26;
  void *v28;
  uint64_t v29;
  void **__dst;
  size_t v31;
  unint64_t v32;
  __int128 v33;
  void **v34;
  __int128 v35;
  char v36;
  void *__src;
  size_t __len;
  uint64_t v39;
  unint64_t v40;
  __n128 v41;
  __int128 v42;
  unint64_t v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = 0;
  v4 = *a2;
  *a2 = 0;
  *(_QWORD *)(a1 + 8) = v4;
  v5 = *a3;
  *a3 = 0;
  *(_QWORD *)(a1 + 16) = v5;
  *(_OWORD *)(a1 + 24) = 0u;
  v6 = a1 + 24;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_DWORD *)(a1 + 56) = 1065353216;
  llvm::object::Archive::child_begin(*(_QWORD *)(a1 + 8), (uint64_t *)a1, 1, (uint64_t)&v41);
  llvm::object::Archive::child_end((uint64_t)&__src);
  v7 = v41.n128_u64[1];
  v33 = v42;
  v8 = __len;
  if (*(_QWORD *)a1)
    goto LABEL_41;
  v9 = v43;
  v10 = v40;
  v11 = v39;
  v41.n128_u64[1] = 0;
  v42 = v33;
  if (v7)
  {
    (**(void (***)(void **__return_ptr, unint64_t))v7)(&__src, v7);
    v41.n128_u64[1] = (unint64_t)__src;
  }
  v43 = v9;
  if (v8)
  {
    (**(void (***)(void **__return_ptr, size_t))v8)(&__src, v8);
    v28 = __src;
  }
  else
  {
    v28 = 0;
  }
  v29 = v11;
  while ((v43 > 7 || v10 >= 8) && (_QWORD)v42 != v11)
  {
    llvm::object::Archive::Child::getName((llvm::object::Archive::Child *)&v41, (uint64_t)&__src);
    if ((v39 & 1) != 0)
    {
      *(_QWORD *)a1 = __src;
      break;
    }
    llvm::object::Archive::Child::getBuffer((llvm::object::Archive::Child *)&v41, (uint64_t)&v35);
    v12 = v36;
    if ((v36 & 1) != 0)
    {
      *(_QWORD *)a1 = v35;
      goto LABEL_31;
    }
    v13 = __src;
    if (__src)
    {
      v14 = __len;
      if (__len >= 0x7FFFFFFFFFFFFFF8)
        abort();
      if (__len >= 0x17)
      {
        v16 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((__len | 7) != 0x17)
          v16 = __len | 7;
        v17 = v6;
        v18 = v8;
        v19 = v7;
        v20 = v10;
        v21 = v16 + 1;
        p_dst = (void **)operator new(v16 + 1);
        v22 = v21 | 0x8000000000000000;
        v10 = v20;
        v7 = v19;
        v8 = v18;
        v6 = v17;
        v11 = v29;
        v31 = v14;
        v32 = v22;
        __dst = p_dst;
      }
      else
      {
        HIBYTE(v32) = __len;
        p_dst = (void **)&__dst;
        if (!__len)
          goto LABEL_24;
      }
      memmove(p_dst, v13, v14);
LABEL_24:
      *((_BYTE *)p_dst + v14) = 0;
      goto LABEL_25;
    }
    __dst = 0;
    v31 = 0;
    v32 = 0;
LABEL_25:
    v34 = (void **)&__dst;
    v23 = std::__hash_table<std::__hash_value_type<std::string,llvm::StringRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,llvm::StringRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,llvm::StringRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,llvm::StringRef>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v6, (uint64_t)&__dst, (uint64_t)&std::piecewise_construct, (__int128 **)&v34);
    *(_OWORD *)(v23 + 40) = v35;
    if (SHIBYTE(v32) < 0)
    {
      operator delete(__dst);
      if ((v36 & 1) == 0)
        goto LABEL_31;
    }
    else if ((v36 & 1) == 0)
    {
      goto LABEL_31;
    }
    v24 = v35;
    *(_QWORD *)&v35 = 0;
    if (v24)
      (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
LABEL_31:
    if ((v39 & 1) != 0)
    {
      v25 = __src;
      __src = 0;
      if (v25)
        (*(void (**)(void *))(*(_QWORD *)v25 + 8))(v25);
    }
    if ((v12 & 1) != 0)
      break;
    llvm::fallible_iterator<llvm::object::Archive::ChildFallibleIterator>::operator++(&v41);
  }
  if (v28)
    (*(void (**)(void *))(*(_QWORD *)v28 + 16))(v28);
  v26 = v41.n128_u64[1];
  v41.n128_u64[1] = 0;
  if (v26)
    (*(void (**)(unint64_t))(*(_QWORD *)v26 + 16))(v26);
LABEL_41:
  if (v8)
    (*(void (**)(size_t))(*(_QWORD *)v8 + 16))(v8);
  if (v7)
    (*(void (**)(unint64_t))(*(_QWORD *)v7 + 16))(v7);
  return a1;
}

__n128 *llvm::fallible_iterator<llvm::object::Archive::ChildFallibleIterator>::operator++(__n128 *a1)
{
  char v2;
  unint64_t v3;
  __n128 v4;
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  __n128 v10[2];
  unsigned __int16 v11;
  char v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  llvm::object::Archive::Child::getNext((llvm::object::Archive::Child *)a1, v10);
  v2 = v12;
  if ((v12 & 1) != 0)
  {
    v5 = v10[0].n128_u64[0];
    v10[0].n128_u64[0] = 0;
  }
  else
  {
    if (v10 != a1)
    {
      v3 = a1->n128_u64[1];
      v4 = v10[0];
      v10[0].n128_u64[1] = 0;
      *a1 = v4;
      if (v3)
      {
        (*(void (**)(unint64_t))(*(_QWORD *)v3 + 16))(v3);
        v2 = v12;
      }
      v5 = 0;
      a1[1] = v10[1];
      a1[2].n128_u16[0] = v11;
      if ((v2 & 1) != 0)
        goto LABEL_11;
LABEL_8:
      v6 = (_QWORD *)v10[0].n128_u64[1];
      v10[0].n128_u64[1] = 0;
      if (!v6)
        goto LABEL_14;
      v7 = 2;
      goto LABEL_13;
    }
    v5 = 0;
    if ((v12 & 1) == 0)
      goto LABEL_8;
  }
LABEL_11:
  v6 = (_QWORD *)v10[0].n128_u64[0];
  v10[0].n128_u64[0] = 0;
  if (!v6)
    goto LABEL_14;
  v7 = 1;
LABEL_13:
  (*(void (**)(_QWORD *))(*v6 + 8 * v7))(v6);
LABEL_14:
  v8 = (_QWORD *)(a1[2].n128_u64[1] & 0xFFFFFFFFFFFFFFF8);
  if (v5)
  {
    *v8 = v5;
    a1[2].n128_u64[1] = a1[2].n128_u64[1] & 3 | 4;
  }
  else
  {
    *v8 = 0;
  }
  return a1;
}

uint64_t mlir::mps::ArchiveWrapper::getData@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result;
  const std::error_category *v5;
  void *v6;
  const char *v7;
  __int16 v8;

  result = (uint64_t)std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>>>::find<std::string>((_QWORD *)(a1 + 24), a2);
  if (result)
  {
    *(_BYTE *)(a3 + 16) &= ~1u;
    *(_OWORD *)a3 = *(_OWORD *)(result + 40);
  }
  else
  {
    v5 = std::generic_category();
    v6 = operator new(0x38uLL);
    v7 = "No such archive member.";
    v8 = 259;
    result = llvm::StringError::StringError((uint64_t)v6, (llvm::Twine *)&v7, 22, (uint64_t)v5);
    *(_BYTE *)(a3 + 16) |= 1u;
    *(_QWORD *)a3 = result;
  }
  return result;
}

llvm *mlir::mps::ArchiveManager::getOrLoad@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  llvm *result;
  std::error_code v7;
  unsigned __int8 *v8;
  char v9;
  uint64_t v10;
  void **v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void **v15;
  __int128 v16;
  uint64_t v17;
  void *__p;
  __int16 v19;
  void *v20;
  __int128 v21[2];
  uint64_t v22;
  llvm *v23;
  char v24;
  llvm *v25[2];
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  result = (llvm *)std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>>>::find<std::string>(a1, a2);
  if (result)
  {
    *(_BYTE *)(a3 + 8) &= ~1u;
    *(_QWORD *)a3 = (char *)result + 40;
  }
  else
  {
    v19 = 260;
    *(_QWORD *)&v16 = a2;
    llvm::MemoryBuffer::getFile((unsigned __int8 *)&v16, 1, 0, 0, 0, (uint64_t)v25);
    if ((v26 & 1) != 0)
    {
      *(llvm **)&v7.__val_ = v25[1];
      result = (llvm *)llvm::errorCodeToError(v25[0], v7, &v22);
      *(_BYTE *)(a3 + 8) |= 1u;
      *(_QWORD *)a3 = v22;
      v22 = 0;
    }
    else
    {
      llvm::MemoryBufferRef::MemoryBufferRef((llvm::MemoryBufferRef *)v21, v25[0]);
      result = (llvm *)llvm::object::Archive::create(v21, (uint64_t)&v23);
      if ((v24 & 1) != 0)
      {
        v10 = (uint64_t)v23;
        *(_BYTE *)(a3 + 8) |= 1u;
        *(_QWORD *)a3 = v10;
      }
      else
      {
        mlir::mps::ArchiveWrapper::ArchiveWrapper((uint64_t)&v16, (uint64_t *)&v23, (uint64_t *)v25);
        v8 = (unsigned __int8 *)v16;
        if ((_QWORD)v16)
        {
          *(_QWORD *)&v16 = 0;
          v9 = *(_BYTE *)(a3 + 8) | 1;
        }
        else
        {
          v8 = std::__hash_table<std::__hash_value_type<std::string,mlir::mps::ArchiveWrapper>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mlir::mps::ArchiveWrapper>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mlir::mps::ArchiveWrapper>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mlir::mps::ArchiveWrapper>>>::__emplace_unique_key_args<std::string,std::string&,mlir::mps::ArchiveWrapper>((uint64_t)a1, a2, a2, &v16)+ 40;
          v9 = *(_BYTE *)(a3 + 8) & 0xFE;
        }
        *(_BYTE *)(a3 + 8) = v9;
        *(_QWORD *)a3 = v8;
        v11 = (void **)v20;
        if (v20)
        {
          do
          {
            v15 = (void **)*v11;
            if (*((char *)v11 + 39) < 0)
              operator delete(v11[2]);
            operator delete(v11);
            v11 = v15;
          }
          while (v15);
        }
        v12 = __p;
        __p = 0;
        if (v12)
          operator delete(v12);
        v13 = v17;
        v17 = 0;
        if (v13)
          (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
        v14 = *((_QWORD *)&v16 + 1);
        *((_QWORD *)&v16 + 1) = 0;
        if (v14)
          (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
        if ((_QWORD)v16)
          (*(void (**)(_QWORD))(*(_QWORD *)v16 + 8))(v16);
        result = v23;
        v23 = 0;
        if (result)
          result = (llvm *)(*(uint64_t (**)(llvm *))(*(_QWORD *)result + 8))(result);
      }
    }
    if ((v26 & 1) == 0)
    {
      result = v25[0];
      v25[0] = 0;
      if (result)
        return (llvm *)(*(uint64_t (**)(llvm *))(*(_QWORD *)result + 8))(result);
    }
  }
  return result;
}

void mlir::mps::createLoadConstantsPass(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  char *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  std::string __p;
  char v15;
  uint64_t v16;
  int v17;
  int v18;
  int *v19;
  __n128 v20;

  v6 = (char *)operator new(0x320uLL);
  __p.__r_.__value_.__s.__data_[0] = 0;
  v15 = 0;
  if (*(_BYTE *)(a1 + 24))
  {
    if (*(char *)(a1 + 23) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
    else
      __p = *(std::string *)a1;
    v15 = 1;
  }
  v16 = a2;
  v6[16] = 0;
  v6[32] = 0;
  v6[40] = 0;
  v6[120] = 0;
  *((_OWORD *)v6 + 8) = 0u;
  *((_OWORD *)v6 + 9) = 0u;
  *((_OWORD *)v6 + 10) = 0u;
  *((_QWORD *)v6 + 22) = 0;
  *((_QWORD *)v6 + 23) = v6 + 200;
  *((_QWORD *)v6 + 24) = 0x400000000;
  *((_QWORD *)v6 + 29) = v6 + 248;
  *((_QWORD *)v6 + 30) = 0x400000000;
  *((_QWORD *)v6 + 35) = 0;
  *((_QWORD *)v6 + 36) = 0;
  *((_QWORD *)v6 + 37) = 0x1000000000;
  *((_OWORD *)v6 + 19) = 0u;
  *((_OWORD *)v6 + 20) = 0u;
  *((_QWORD *)v6 + 42) = 0;
  *(_QWORD *)v6 = off_1E0E4B988;
  v20.n128_u64[1] = 78;
  LODWORD(v19) = 0;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc,llvm::cl::NumOccurrencesFlag>((_QWORD *)v6 + 43, (_QWORD *)v6 + 19, (uint64_t)"archive-dir", 11, &v20, &v19);
  *((_QWORD *)v6 + 43) = &off_1E0E4C260;
  *((_QWORD *)v6 + 72) = &unk_1E0E4C2E0;
  v20.n128_u64[0] = (unint64_t)"The data size limit (in bytes) under which to load constants from their archive.";
  v20.n128_u64[1] = 80;
  v17 = 0;
  v18 = -1;
  v19 = &v18;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<unsigned int>,llvm::cl::NumOccurrencesFlag>((_QWORD *)v6 + 74, (_QWORD *)v6 + 19, (uint64_t)"data-size-limit", 15, &v20, &v19, &v17);
  *((_QWORD *)v6 + 74) = off_1E0E4C3E0;
  *((_QWORD *)v6 + 98) = &unk_1E0E4C460;
  *(_QWORD *)v6 = off_1E0E49390;
  if (v15)
  {
    std::string::operator=((std::string *)(v6 + 472), &__p);
    v7 = *((_QWORD *)v6 + 71);
    if (!v7)
    {
LABEL_17:
      v10 = std::__throw_bad_function_call[abi:nn180100]();
      mlir::mps::createStoreConstantsPass(v10, v11, v12, v13);
      return;
    }
    (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v7 + 48))(v7, &__p);
  }
  if ((a2 & 0xFF00000000) != 0)
    v8 = &v16;
  else
  *((_DWORD *)v6 + 180) = *(_DWORD *)v8;
  v9 = *((_QWORD *)v6 + 97);
  if (!v9)
    goto LABEL_17;
  (*(void (**)(uint64_t))(*(_QWORD *)v9 + 48))(v9);
  if (v15)
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  *a3 = v6;
}

void mlir::mps::createStoreConstantsPass(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 **v16;
  std::string __p;
  char v18;
  std::string __str;
  char v20;
  uint64_t v21;
  int v22;
  __n128 v23;

  v8 = (char *)operator new(0x420uLL);
  __str.__r_.__value_.__s.__data_[0] = 0;
  v20 = 0;
  if (*(_BYTE *)(a1 + 24))
  {
    if (*(char *)(a1 + 23) < 0)
      std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
    else
      __str = *(std::string *)a1;
    v20 = 1;
  }
  __p.__r_.__value_.__s.__data_[0] = 0;
  v18 = 0;
  if (*(_BYTE *)(a2 + 24))
  {
    if (*(char *)(a2 + 23) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
    else
      __p = *(std::string *)a2;
    v18 = 1;
  }
  v21 = a3;
  v8[16] = 0;
  v8[32] = 0;
  v8[40] = 0;
  v8[120] = 0;
  *((_OWORD *)v8 + 8) = 0u;
  *((_OWORD *)v8 + 9) = 0u;
  *((_OWORD *)v8 + 10) = 0u;
  *((_QWORD *)v8 + 22) = 0;
  *((_QWORD *)v8 + 23) = v8 + 200;
  *((_QWORD *)v8 + 24) = 0x400000000;
  *((_QWORD *)v8 + 29) = v8 + 248;
  *((_QWORD *)v8 + 30) = 0x400000000;
  *((_QWORD *)v8 + 35) = 0;
  *((_QWORD *)v8 + 36) = 0;
  *((_QWORD *)v8 + 37) = 0x1000000000;
  *((_OWORD *)v8 + 19) = 0u;
  *((_OWORD *)v8 + 20) = 0u;
  *((_QWORD *)v8 + 42) = 0;
  *(_QWORD *)v8 = off_1E0E4BB08;
                                      "ts will be stored.";
  v23.n128_u64[1] = 100;
  v22 = 2;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc,llvm::cl::NumOccurrencesFlag>((_QWORD *)v8 + 43, (_QWORD *)v8 + 19, (uint64_t)"archive", 7, &v23, &v22);
  *((_QWORD *)v8 + 43) = &off_1E0E4C260;
  *((_QWORD *)v8 + 72) = &unk_1E0E4C2E0;
  v23.n128_u64[1] = 48;
  v22 = 0;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc,llvm::cl::NumOccurrencesFlag>((_QWORD *)v8 + 74, (_QWORD *)v8 + 19, (uint64_t)"archive-dir", 11, &v23, &v22);
  *((_QWORD *)v8 + 74) = &off_1E0E4C260;
  *((_QWORD *)v8 + 103) = &unk_1E0E4C2E0;
  v23.n128_u64[0] = (unint64_t)"The data size limit (in bytes) above which to store constants in the archive file.";
  v23.n128_u64[1] = 82;
  v22 = 0;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::NumOccurrencesFlag>((_QWORD *)v8 + 105, (_QWORD *)v8 + 19, (uint64_t)"data-size-limit", 15, &v23, &v22);
  *((_QWORD *)v8 + 105) = off_1E0E4C3E0;
  *((_QWORD *)v8 + 129) = &unk_1E0E4C460;
  *(_QWORD *)v8 = off_1E0E49A80;
  *((_DWORD *)v8 + 262) = 0;
  if (v20)
  {
    std::string::operator=((std::string *)(v8 + 472), &__str);
    v9 = *((_QWORD *)v8 + 71);
    if (!v9)
      goto LABEL_28;
    (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v9 + 48))(v9, &__str);
  }
  if (!v18)
    goto LABEL_17;
  std::string::operator=((std::string *)v8 + 30, &__p);
  v10 = *((_QWORD *)v8 + 102);
  if (!v10)
  {
LABEL_28:
    v13 = std::__throw_bad_function_call[abi:nn180100]();
    std::__hash_table<std::__hash_value_type<std::string,llvm::StringRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,llvm::StringRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,llvm::StringRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,llvm::StringRef>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v13, v14, v15, v16);
    return;
  }
  (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v10 + 48))(v10, &__p);
LABEL_17:
  if ((a3 & 0xFF00000000) != 0)
    v11 = &v21;
  else
  *((_DWORD *)v8 + 242) = *(_DWORD *)v11;
  v12 = *((_QWORD *)v8 + 128);
  if (!v12)
    goto LABEL_28;
  (*(void (**)(uint64_t))(*(_QWORD *)v12 + 48))(v12);
  if (v18 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v20)
  {
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
  }
  *a4 = v8;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,llvm::StringRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,llvm::StringRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,llvm::StringRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,llvm::StringRef>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t a1, uint64_t a2, uint64_t a3, __int128 **a4)
{
  unint64_t v4;
  _BYTE *v6;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  void **v15;
  unsigned __int8 *v16;
  char v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 *v23;
  __int128 v24;
  float v25;
  float v26;
  _BOOL8 v27;
  unint64_t v28;
  unint64_t v29;
  size_t prime;
  int8x8_t v31;
  unint64_t v32;
  uint8x8_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  unint64_t v37;
  char v39;

  v6 = (_BYTE *)a2;
  v8 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v9 = v8;
  }
  v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v39, (uint64_t *)a2, v9);
  v11 = v10;
  v12 = *(_QWORD *)(a1 + 8);
  if (v12)
  {
    v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      v4 = v10;
      if (v10 >= v12)
        v4 = v10 % v12;
    }
    else
    {
      v4 = (v12 - 1) & v10;
    }
    v15 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v15)
    {
      v16 = (unsigned __int8 *)*v15;
      if (*v15)
      {
        v17 = v6[23];
        if (v17 >= 0)
          v18 = v6[23];
        else
          v18 = *((_QWORD *)v6 + 1);
        if (v17 < 0)
          v6 = *(_BYTE **)v6;
        do
        {
          v19 = *((_QWORD *)v16 + 1);
          if (v19 == v11)
          {
            v20 = v16[39];
            if ((v20 & 0x80u) == 0)
              v21 = v16[39];
            else
              v21 = *((_QWORD *)v16 + 3);
            if (v21 == v18)
            {
              if ((v20 & 0x80) != 0)
              {
                if (!memcmp(*((const void **)v16 + 2), v6, *((_QWORD *)v16 + 3)))
                  return v16;
              }
              else
              {
                if (!v16[39])
                  return v16;
                v22 = 0;
                while (v16[v22 + 16] == v6[v22])
                {
                  if (v20 == ++v22)
                    return v16;
                }
              }
            }
          }
          else
          {
            if (v14 <= 1)
            {
              v19 &= v12 - 1;
            }
            else if (v19 >= v12)
            {
              v19 %= v12;
            }
            if (v19 != v4)
              break;
          }
          v16 = *(unsigned __int8 **)v16;
        }
        while (v16);
      }
    }
  }
  v16 = (unsigned __int8 *)operator new(0x38uLL);
  *(_QWORD *)v16 = 0;
  *((_QWORD *)v16 + 1) = v11;
  v23 = *a4;
  v24 = **a4;
  *((_QWORD *)v16 + 4) = *((_QWORD *)*a4 + 2);
  *((_OWORD *)v16 + 1) = v24;
  *((_QWORD *)v23 + 1) = 0;
  *((_QWORD *)v23 + 2) = 0;
  *(_QWORD *)v23 = 0;
  *((_QWORD *)v16 + 5) = 0;
  *((_QWORD *)v16 + 6) = 0;
  v25 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v26 = *(float *)(a1 + 32);
  if (!v12 || (float)(v26 * (float)v12) < v25)
  {
    v27 = 1;
    if (v12 >= 3)
      v27 = (v12 & (v12 - 1)) != 0;
    v28 = v27 | (2 * v12);
    v29 = vcvtps_u32_f32(v25 / v26);
    if (v28 <= v29)
      prime = v29;
    else
      prime = v28;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
    }
    v31 = *(int8x8_t *)(a1 + 8);
    if (prime > *(_QWORD *)&v31)
      goto LABEL_59;
    if (prime < *(_QWORD *)&v31)
    {
      v32 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(_QWORD *)&v31 < 3uLL || (v33 = (uint8x8_t)vcnt_s8(v31), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        v32 = std::__next_prime(v32);
      }
      else
      {
        v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2)
          v32 = v34;
      }
      if (prime <= v32)
        prime = v32;
      if (prime < *(_QWORD *)&v31)
LABEL_59:
        std::__hash_table<std::__hash_value_type<ZinIrDimension,unsigned long>,std::__unordered_map_hasher<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::hash<ZinIrDimension>,std::equal_to<ZinIrDimension>,true>,std::__unordered_map_equal<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::equal_to<ZinIrDimension>,std::hash<ZinIrDimension>,true>,std::allocator<std::__hash_value_type<ZinIrDimension,unsigned long>>>::__do_rehash<true>(a1, prime);
    }
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v4 = v11 % v12;
      else
        v4 = v11;
    }
    else
    {
      v4 = (v12 - 1) & v11;
    }
  }
  v35 = *(_QWORD *)a1;
  v36 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v36)
  {
    *(_QWORD *)v16 = *v36;
LABEL_73:
    *v36 = v16;
    goto LABEL_74;
  }
  *(_QWORD *)v16 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v16;
  *(_QWORD *)(v35 + 8 * v4) = a1 + 16;
  if (*(_QWORD *)v16)
  {
    v37 = *(_QWORD *)(*(_QWORD *)v16 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v37 >= v12)
        v37 %= v12;
    }
    else
    {
      v37 &= v12 - 1;
    }
    v36 = (_QWORD *)(*(_QWORD *)a1 + 8 * v37);
    goto LABEL_73;
  }
LABEL_74:
  ++*(_QWORD *)(a1 + 24);
  return v16;
}

void std::__hash_table<std::__hash_value_type<std::string,llvm::StringRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,llvm::StringRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,llvm::StringRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,llvm::StringRef>>>::__move_assign(uint64_t a1, uint64_t *a2)
{
  void **v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  void **v16;

  if (*(_QWORD *)(a1 + 24))
  {
    v4 = *(void ***)(a1 + 16);
    if (v4)
    {
      do
      {
        v16 = (void **)*v4;
        if (*((char *)v4 + 39) < 0)
          operator delete(v4[2]);
        operator delete(v4);
        v4 = v16;
      }
      while (v16);
    }
    *(_QWORD *)(a1 + 16) = 0;
    v5 = *(_QWORD *)(a1 + 8);
    if (v5)
    {
      for (i = 0; i != v5; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
  v7 = *a2;
  *a2 = 0;
  v8 = *(void **)a1;
  *(_QWORD *)a1 = v7;
  if (v8)
    operator delete(v8);
  v11 = a2[2];
  v10 = a2 + 2;
  v9 = v11;
  v12 = *(v10 - 1);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(a1 + 8) = v12;
  *(v10 - 1) = 0;
  v13 = v10[1];
  *(_QWORD *)(a1 + 24) = v13;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v10 + 4);
  if (v13)
  {
    v14 = *(_QWORD *)(v9 + 8);
    v15 = *(_QWORD *)(a1 + 8);
    if ((v15 & (v15 - 1)) != 0)
    {
      if (v14 >= v15)
        v14 %= v15;
    }
    else
    {
      v14 &= v15 - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v14) = a1 + 16;
    *v10 = 0;
    v10[1] = 0;
  }
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,mlir::mps::ArchiveWrapper>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mlir::mps::ArchiveWrapper>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mlir::mps::ArchiveWrapper>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mlir::mps::ArchiveWrapper>>>::__emplace_unique_key_args<std::string,std::string&,mlir::mps::ArchiveWrapper>(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  unint64_t v4;
  _BYTE *v7;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint8x8_t v14;
  unint64_t v15;
  void **v16;
  unsigned __int8 *v17;
  unint64_t v18;
  char v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  std::string *v26;
  __int128 v27;
  uint64_t v28;
  float v29;
  float v30;
  _BOOL8 v31;
  unint64_t v32;
  unint64_t v33;
  size_t prime;
  int8x8_t v35;
  unint64_t v36;
  uint8x8_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  unint64_t v41;
  unint64_t v43;
  char v44;

  v7 = (_BYTE *)a2;
  v9 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v10 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v10 = v9;
  }
  v11 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v44, (uint64_t *)a2, v10);
  v12 = v11;
  v13 = *(_QWORD *)(a1 + 8);
  if (v13)
  {
    v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
    v14.i16[0] = vaddlv_u8(v14);
    v15 = v14.u32[0];
    if (v14.u32[0] > 1uLL)
    {
      v4 = v11;
      if (v11 >= v13)
        v4 = v11 % v13;
    }
    else
    {
      v4 = (v13 - 1) & v11;
    }
    v16 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v16)
    {
      v17 = (unsigned __int8 *)*v16;
      if (*v16)
      {
        v18 = v13 - 1;
        v19 = v7[23];
        if (v19 >= 0)
          v20 = v7[23];
        else
          v20 = *((_QWORD *)v7 + 1);
        if (v19 < 0)
          v7 = *(_BYTE **)v7;
        do
        {
          v21 = *((_QWORD *)v17 + 1);
          if (v21 == v12)
          {
            v22 = v17[39];
            if ((v22 & 0x80u) == 0)
              v23 = v17[39];
            else
              v23 = *((_QWORD *)v17 + 3);
            if (v23 == v20)
            {
              if ((v22 & 0x80) != 0)
              {
                v43 = v18;
                v25 = memcmp(*((const void **)v17 + 2), v7, *((_QWORD *)v17 + 3));
                v18 = v43;
                if (!v25)
                  return v17;
              }
              else
              {
                if (!v17[39])
                  return v17;
                v24 = 0;
                while (v17[v24 + 16] == v7[v24])
                {
                  if (v22 == ++v24)
                    return v17;
                }
              }
            }
          }
          else
          {
            if (v15 <= 1)
            {
              v21 &= v18;
            }
            else if (v21 >= v13)
            {
              v21 %= v13;
            }
            if (v21 != v4)
              break;
          }
          v17 = *(unsigned __int8 **)v17;
        }
        while (v17);
      }
    }
  }
  v17 = (unsigned __int8 *)operator new(0x68uLL);
  *(_QWORD *)v17 = 0;
  *((_QWORD *)v17 + 1) = v12;
  v26 = (std::string *)(v17 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v26, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v26->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((_QWORD *)v17 + 4) = *(_QWORD *)(a3 + 16);
  }
  *((_OWORD *)v17 + 4) = 0u;
  *((_OWORD *)v17 + 5) = 0u;
  *((_DWORD *)v17 + 24) = 1065353216;
  v27 = *a4;
  *(_QWORD *)a4 = 0;
  *((_QWORD *)a4 + 1) = 0;
  *(_OWORD *)(v17 + 40) = v27;
  v28 = *((_QWORD *)a4 + 2);
  *((_QWORD *)a4 + 2) = 0;
  *((_QWORD *)v17 + 7) = v28;
  std::__hash_table<std::__hash_value_type<std::string,llvm::StringRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,llvm::StringRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,llvm::StringRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,llvm::StringRef>>>::__move_assign((uint64_t)(v17 + 64), (uint64_t *)a4 + 3);
  v29 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v30 = *(float *)(a1 + 32);
  if (!v13 || (float)(v30 * (float)v13) < v29)
  {
    v31 = 1;
    if (v13 >= 3)
      v31 = (v13 & (v13 - 1)) != 0;
    v32 = v31 | (2 * v13);
    v33 = vcvtps_u32_f32(v29 / v30);
    if (v32 <= v33)
      prime = v33;
    else
      prime = v32;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
    }
    v35 = *(int8x8_t *)(a1 + 8);
    if (prime > *(_QWORD *)&v35)
      goto LABEL_62;
    if (prime < *(_QWORD *)&v35)
    {
      v36 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(_QWORD *)&v35 < 3uLL || (v37 = (uint8x8_t)vcnt_s8(v35), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
      {
        v36 = std::__next_prime(v36);
      }
      else
      {
        v38 = 1 << -(char)__clz(v36 - 1);
        if (v36 >= 2)
          v36 = v38;
      }
      if (prime <= v36)
        prime = v36;
      if (prime < *(_QWORD *)&v35)
LABEL_62:
        std::__hash_table<std::__hash_value_type<ZinIrDimension,unsigned long>,std::__unordered_map_hasher<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::hash<ZinIrDimension>,std::equal_to<ZinIrDimension>,true>,std::__unordered_map_equal<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::equal_to<ZinIrDimension>,std::hash<ZinIrDimension>,true>,std::allocator<std::__hash_value_type<ZinIrDimension,unsigned long>>>::__do_rehash<true>(a1, prime);
    }
    v13 = *(_QWORD *)(a1 + 8);
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v12 >= v13)
        v4 = v12 % v13;
      else
        v4 = v12;
    }
    else
    {
      v4 = (v13 - 1) & v12;
    }
  }
  v39 = *(_QWORD *)a1;
  v40 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v40)
  {
    *(_QWORD *)v17 = *v40;
LABEL_76:
    *v40 = v17;
    goto LABEL_77;
  }
  *(_QWORD *)v17 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v17;
  *(_QWORD *)(v39 + 8 * v4) = a1 + 16;
  if (*(_QWORD *)v17)
  {
    v41 = *(_QWORD *)(*(_QWORD *)v17 + 8);
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v41 >= v13)
        v41 %= v13;
    }
    else
    {
      v41 &= v13 - 1;
    }
    v40 = (_QWORD *)(*(_QWORD *)a1 + 8 * v41);
    goto LABEL_76;
  }
LABEL_77:
  ++*(_QWORD *)(a1 + 24);
  return v17;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,mlir::mps::ArchiveWrapper>,0>(uint64_t a1)
{
  void **v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void **v7;

  v2 = *(void ***)(a1 + 64);
  if (v2)
  {
    do
    {
      v7 = (void **)*v2;
      if (*((char *)v2 + 39) < 0)
        operator delete(v2[2]);
      operator delete(v2);
      v2 = v7;
    }
    while (v7);
  }
  v3 = *(void **)(a1 + 48);
  *(_QWORD *)(a1 + 48) = 0;
  if (v3)
    operator delete(v3);
  v4 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  v5 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = *(_QWORD *)(a1 + 24);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void mlir::mps::`anonymous namespace'::LoadConstantsPass::~LoadConstantsPass(mlir::mps::_anonymous_namespace_::LoadConstantsPass *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;

  *(_QWORD *)this = off_1E0E4B988;
  *((_QWORD *)this + 74) = &unk_1E0E23658;
  v2 = (char *)this + 752;
  v3 = (char *)*((_QWORD *)this + 97);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)this + 74) = &unk_1E0E23930;
  v5 = (void *)*((_QWORD *)this + 86);
  if (v5 != *((void **)this + 85))
    free(v5);
  v6 = (char *)*((_QWORD *)this + 82);
  if (v6 != (char *)this + 672)
    free(v6);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 344);
  mlir::Pass::~Pass(this);
}

{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;
  void *v7;

  *(_QWORD *)this = off_1E0E4B988;
  *((_QWORD *)this + 74) = &unk_1E0E23658;
  v2 = (char *)this + 752;
  v3 = (char *)*((_QWORD *)this + 97);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)this + 74) = &unk_1E0E23930;
  v5 = (void *)*((_QWORD *)this + 86);
  if (v5 != *((void **)this + 85))
    free(v5);
  v6 = (char *)*((_QWORD *)this + 82);
  if (v6 != (char *)this + 672)
    free(v6);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 344);
  mlir::Pass::~Pass(this);
  operator delete(v7);
}

const char *mlir::mps::MPSLoadConstantsBase<mlir::mps::`anonymous namespace'::LoadConstantsPass>::getName()
{
  return "MPSLoadConstants";
}

_QWORD *mlir::mps::MPSLoadConstantsBase<mlir::mps::`anonymous namespace'::LoadConstantsPass>::getDependentDialects(int a1, uint64_t **a2)
{
  uint64_t v2;
  _QWORD *result;
  _QWORD v4[3];
  _QWORD *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4[0] = off_1E0E50990;
  v5 = v4;
  v2 = 4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::mpsx::MPSXDialect,void>::id, "mpsx", 4uLL, v4);
  result = v5;
  if (v5 == v4)
  {
    result = v4;
  }
  else
  {
    if (!v5)
      return result;
    v2 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v2))();
}

const char *mlir::mps::MPSLoadConstantsBase<mlir::mps::`anonymous namespace'::LoadConstantsPass>::getArgument()
{
  return "mps-load-constants";
}

const char *mlir::mps::MPSLoadConstantsBase<mlir::mps::`anonymous namespace'::LoadConstantsPass>::getDescription()
{
  return "Load file backed constants above a certain size from their archive.";
}

void mlir::mps::`anonymous namespace'::LoadConstantsPass::runOnOperation(mlir::mps::_anonymous_namespace_::LoadConstantsPass *this)
{
  uint64_t v2;
  mlir::ForwardIterator *v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD v7[2];
  void *__p[2];
  __int128 v9;
  int v10;

  *(_OWORD *)__p = 0u;
  v9 = 0u;
  v10 = 1065353216;
  v2 = *((_QWORD *)this + 5);
  v3 = (mlir::ForwardIterator *)(v2 & 0xFFFFFFFFFFFFFFF8);
  if ((v2 & 0xFFFFFFFFFFFFFFF8) != 0)
    mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(v2 & 0xFFFFFFFFFFFFFFF8);
  v7[0] = this;
  v7[1] = __p;
  {
    v4 = (_QWORD *)v9;
    if ((_QWORD)v9)
      goto LABEL_5;
  }
  else
  {
    *((_QWORD *)this + 5) |= 4uLL;
    v4 = (_QWORD *)v9;
    if ((_QWORD)v9)
    {
      do
      {
LABEL_5:
        v5 = (_QWORD *)*v4;
        std::__destroy_at[abi:nn180100]<std::pair<std::string const,mlir::mps::ArchiveWrapper>,0>((uint64_t)(v4 + 2));
        operator delete(v4);
        v4 = v5;
      }
      while (v5);
    }
  }
  v6 = __p[0];
  __p[0] = 0;
  if (v6)
    operator delete(v6);
}

BOOL mlir::InterfacePass<mlir::FunctionOpInterface>::canScheduleOn(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t *v8;
  _QWORD *v9;
  unint64_t v10;

  v3 = mlir::TypeID::get<mlir::FunctionOpInterface>();
  v4 = *(unsigned int *)(a2 + 40);
  if (!(_DWORD)v4)
    return 0;
  v5 = *(_QWORD **)(a2 + 32);
  v6 = &v5[2 * v4];
  do
  {
    v7 = v4 >> 1;
    v8 = &v5[2 * (v4 >> 1)];
    v10 = *v8;
    v9 = v8 + 2;
    v4 += ~(v4 >> 1);
    if (v10 < v3)
      v5 = v9;
    else
      v4 = v7;
  }
  while (v4);
  return v5 != v6 && *v5 == v3 && v5[1] != 0;
}

_QWORD *mlir::mps::MPSLoadConstantsBase<mlir::mps::`anonymous namespace'::LoadConstantsPass>::clonePass@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _OWORD *v4;
  uint64_t v5;
  _QWORD *result;
  int v7;
  int v8;
  int *v9;
  __n128 v10;

  v4 = operator new(0x320uLL);
  v5 = *(_QWORD *)(a1 + 8);
  v4[1] = *(_OWORD *)(a1 + 16);
  *((_QWORD *)v4 + 4) = *(_QWORD *)(a1 + 32);
  *((_BYTE *)v4 + 40) = 0;
  *((_BYTE *)v4 + 120) = 0;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  *((_QWORD *)v4 + 22) = 0;
  *((_QWORD *)v4 + 23) = (char *)v4 + 200;
  *((_QWORD *)v4 + 24) = 0x400000000;
  *((_QWORD *)v4 + 29) = (char *)v4 + 248;
  *((_QWORD *)v4 + 30) = 0x400000000;
  *((_QWORD *)v4 + 35) = 0;
  *((_QWORD *)v4 + 36) = 0;
  *((_DWORD *)v4 + 74) = 0;
  *((_DWORD *)v4 + 75) = 16;
  v4[19] = 0u;
  v4[20] = 0u;
  *((_QWORD *)v4 + 42) = 0;
  *(_QWORD *)v4 = off_1E0E4B988;
  *((_QWORD *)v4 + 1) = v5;
  v10.n128_u64[1] = 78;
  LODWORD(v9) = 0;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc,llvm::cl::NumOccurrencesFlag>((_QWORD *)v4 + 43, (_QWORD *)v4 + 19, (uint64_t)"archive-dir", 11, &v10, &v9);
  *((_QWORD *)v4 + 43) = &off_1E0E4C260;
  *((_QWORD *)v4 + 72) = &unk_1E0E4C2E0;
  v10.n128_u64[0] = (unint64_t)"The data size limit (in bytes) under which to load constants from their archive.";
  v10.n128_u64[1] = 80;
  v7 = 0;
  v8 = -1;
  v9 = &v8;
  result = mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<unsigned int>,llvm::cl::NumOccurrencesFlag>((_QWORD *)v4 + 74, (_QWORD *)v4 + 19, (uint64_t)"data-size-limit", 15, &v10, &v9, &v7);
  *((_QWORD *)v4 + 74) = off_1E0E4C3E0;
  *((_QWORD *)v4 + 98) = &unk_1E0E4C460;
  *(_QWORD *)v4 = off_1E0E49390;
  *a2 = v4;
  return result;
}

_QWORD *mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc,llvm::cl::NumOccurrencesFlag>(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4, __n128 *a5, _WORD *a6)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t *v20;
  char *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t *v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  const void **v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  _QWORD v35[2];
  _QWORD v36[3];
  _QWORD *v37;
  const void *v38[3];
  const void **v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v35[0] = a3;
  v35[1] = a4;
  v38[0] = a2;
  v8 = llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::NumOccurrencesFlag>((uint64_t)a1, (uint64_t)v35, v38, a5, a6);
  *(_QWORD *)(v8 + 232) = &unk_1E0E4E088;
  v9 = v8 + 232;
  *(_BYTE *)(v8 + 240) = 0;
  *(_QWORD *)v8 = &off_1E0E4E008;
  v11 = (uint64_t *)a2[21];
  v10 = a2[22];
  v12 = v11;
  if ((unint64_t)v11 >= v10)
  {
    v14 = (uint64_t *)a2[20];
    v15 = v11 - v14;
    v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61)
      abort();
    v17 = v10 - (_QWORD)v14;
    if (v17 >> 2 > v16)
      v16 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v16;
    if (v18)
    {
      if (v18 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v19 = (char *)operator new(8 * v18);
    }
    else
    {
      v19 = 0;
    }
    v20 = (uint64_t *)&v19[8 * v15];
    v21 = &v19[8 * v18];
    *v20 = v9;
    v13 = v20 + 1;
    if (v11 != v14)
    {
      v22 = (char *)v11 - (char *)v14 - 8;
      if (v22 < 0x58)
        goto LABEL_38;
      if ((unint64_t)((char *)v14 - v19) < 0x20)
        goto LABEL_38;
      v23 = (v22 >> 3) + 1;
      v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v12 = &v11[v24 / 0xFFFFFFFFFFFFFFF8];
      v20 = (uint64_t *)((char *)v20 - v24);
      v25 = &v19[8 * v15 - 16];
      v26 = v11 - 2;
      v27 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v28 = *(_OWORD *)v26;
        *((_OWORD *)v25 - 1) = *((_OWORD *)v26 - 1);
        *(_OWORD *)v25 = v28;
        v25 -= 32;
        v26 -= 4;
        v27 -= 4;
      }
      while (v27);
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_38:
        do
        {
          v29 = *--v12;
          *--v20 = v29;
        }
        while (v12 != v14);
      }
      v12 = (uint64_t *)a2[20];
    }
    a2[20] = v20;
    a2[21] = v13;
    a2[22] = v21;
    if (v12)
      operator delete(v12);
  }
  else
  {
    *v11 = v9;
    v13 = v11 + 1;
  }
  a2[21] = v13;
  v36[0] = off_1E0E514C8;
  v36[1] = a1;
  v37 = v36;
  v38[0] = off_1E0E514C8;
  v39 = v38;
  v38[1] = a1;
  std::__function::__value_func<void ()(long long const&)>::swap[abi:nn180100](v38, a1 + 25);
  v30 = v39;
  if (v39 == v38)
  {
    v31 = 4;
    v30 = v38;
  }
  else
  {
    if (!v39)
      goto LABEL_28;
    v31 = 5;
  }
  (*((void (**)(void))*v30 + v31))();
LABEL_28:
  v32 = v37;
  if (v37 == v36)
  {
    v33 = 4;
    v32 = v36;
    goto LABEL_32;
  }
  if (v37)
  {
    v33 = 5;
LABEL_32:
    (*(void (**)(void))(*v32 + 8 * v33))();
  }
  return a1;
}

uint64_t llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::NumOccurrencesFlag>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, _WORD *a5)
{
  void *v10;
  uint64_t v11;
  uint64_t *GeneralCategory;
  uint64_t v13;

  *(_WORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &unk_1E0E23930;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  v10 = (void *)(a1 + 80);
  *(_QWORD *)(a1 + 64) = a1 + 80;
  v11 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(_QWORD *)(a1 + 72) = 0x100000000;
  *(_QWORD *)(a1 + 88) = a1 + 120;
  *(_QWORD *)(a1 + 96) = a1 + 120;
  *(_QWORD *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  v13 = *(unsigned int *)(a1 + 72);
  if (v13 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v11, v10, v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a1 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v13) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = &unk_1E0E22F48;
  *(_QWORD *)a1 = &unk_1E0E23450;
  *(_QWORD *)(a1 + 192) = &unk_1E0E23B38;
  *(_QWORD *)(a1 + 200) = off_1E0E4FA58;
  *(_QWORD *)(a1 + 224) = a1 + 200;
  llvm::cl::apply<llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::NumOccurrencesFlag>(a1, a2, a3, a4, a5);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

__n128 llvm::cl::apply<llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::NumOccurrencesFlag>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, _WORD *a5)
{
  const void *v9;
  uint64_t v10;
  __n128 result;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;

  llvm::cl::Option::setArgStr(a1, *(int8x16_t **)a2, *(const unsigned __int8 **)(a2 + 8));
  v9 = *a3;
  v10 = *(_QWORD *)(a1 + 96);
  if (v10 != *(_QWORD *)(a1 + 88))
  {
LABEL_2:
    llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(a1 + 88), v9);
    goto LABEL_3;
  }
  v12 = *(unsigned int *)(a1 + 108);
  if (!(_DWORD)v12)
  {
LABEL_12:
    if (v12 < *(_DWORD *)(a1 + 104))
    {
      *(_DWORD *)(a1 + 108) = v12 + 1;
      *(_QWORD *)(v10 + 8 * v12) = v9;
      goto LABEL_3;
    }
    goto LABEL_2;
  }
  v13 = 0;
  v14 = 8 * v12;
  v15 = *(_QWORD **)(a1 + 96);
  while ((const void *)*v15 != v9)
  {
    if (*v15 == -2)
      v13 = v15;
    ++v15;
    v14 -= 8;
    if (!v14)
    {
      if (!v13)
        goto LABEL_12;
      *v13 = v9;
      --*(_DWORD *)(a1 + 112);
      break;
    }
  }
LABEL_3:
  result = *a4;
  *(__n128 *)(a1 + 32) = *a4;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 10) & 0xFFF8 | *a5 & 7;
  return result;
}

_QWORD *_ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN4llvm2cl6parserISB_EEEC1IJNSD_4descENSD_18NumOccurrencesFlagEEEERS4_NSC_9StringRefEDpOT_EUlRKT_E_NS9_ISS_EEFvRKSB_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1E0E514C8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN4llvm2cl6parserISB_EEEC1IJNSD_4descENSD_18NumOccurrencesFlagEEEERS4_NSC_9StringRefEDpOT_EUlRKT_E_NS9_ISS_EEFvRKSB_EE7__cloneEPNS0_6__baseISW_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1E0E514C8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEN4llvm2cl6parserISB_EEEC1IJNSD_4descENSD_18NumOccurrencesFlagEEEERS4_NSC_9StringRefEDpOT_EUlRKT_E_NS9_ISS_EEFvRKSB_EEclESV_(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 8) + 240) = 1;
  return result;
}

_QWORD *mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<unsigned int>,llvm::cl::NumOccurrencesFlag>(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4, __n128 *a5, _DWORD **a6, _WORD *a7)
{
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t *v21;
  char *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t *v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  const void **v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  _QWORD v36[2];
  _QWORD v37[3];
  _QWORD *v38;
  const void *v39[3];
  const void **v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v36[0] = a3;
  v36[1] = a4;
  v39[0] = a2;
  v9 = llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<unsigned int>,llvm::cl::NumOccurrencesFlag>((uint64_t)a1, (uint64_t)v36, v39, a5, a6, a7);
  *(_QWORD *)(v9 + 192) = &unk_1E0E4E208;
  v10 = v9 + 192;
  *(_BYTE *)(v9 + 200) = 0;
  *(_QWORD *)v9 = off_1E0E4E188;
  v12 = (uint64_t *)a2[21];
  v11 = a2[22];
  v13 = v12;
  if ((unint64_t)v12 >= v11)
  {
    v15 = (uint64_t *)a2[20];
    v16 = v12 - v15;
    v17 = v16 + 1;
    if ((unint64_t)(v16 + 1) >> 61)
      abort();
    v18 = v11 - (_QWORD)v15;
    if (v18 >> 2 > v17)
      v17 = v18 >> 2;
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
      v19 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v19 = v17;
    if (v19)
    {
      if (v19 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v20 = (char *)operator new(8 * v19);
    }
    else
    {
      v20 = 0;
    }
    v21 = (uint64_t *)&v20[8 * v16];
    v22 = &v20[8 * v19];
    *v21 = v10;
    v14 = v21 + 1;
    if (v12 != v15)
    {
      v23 = (char *)v12 - (char *)v15 - 8;
      if (v23 < 0x58)
        goto LABEL_38;
      if ((unint64_t)((char *)v15 - v20) < 0x20)
        goto LABEL_38;
      v24 = (v23 >> 3) + 1;
      v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
      v13 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
      v21 = (uint64_t *)((char *)v21 - v25);
      v26 = &v20[8 * v16 - 16];
      v27 = v12 - 2;
      v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v29 = *(_OWORD *)v27;
        *((_OWORD *)v26 - 1) = *((_OWORD *)v27 - 1);
        *(_OWORD *)v26 = v29;
        v26 -= 32;
        v27 -= 4;
        v28 -= 4;
      }
      while (v28);
      if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_38:
        do
        {
          v30 = *--v13;
          *--v21 = v30;
        }
        while (v13 != v15);
      }
      v13 = (uint64_t *)a2[20];
    }
    a2[20] = v21;
    a2[21] = v14;
    a2[22] = v22;
    if (v13)
      operator delete(v13);
  }
  else
  {
    *v12 = v10;
    v14 = v12 + 1;
  }
  a2[21] = v14;
  v37[0] = off_1E0E51630;
  v37[1] = a1;
  v38 = v37;
  v39[0] = off_1E0E51630;
  v40 = v39;
  v39[1] = a1;
  std::__function::__value_func<void ()(long long const&)>::swap[abi:nn180100](v39, a1 + 20);
  v31 = v40;
  if (v40 == v39)
  {
    v32 = 4;
    v31 = v39;
  }
  else
  {
    if (!v40)
      goto LABEL_28;
    v32 = 5;
  }
  (*((void (**)(void))*v31 + v32))();
LABEL_28:
  v33 = v38;
  if (v38 == v37)
  {
    v34 = 4;
    v33 = v37;
    goto LABEL_32;
  }
  if (v38)
  {
    v34 = 5;
LABEL_32:
    (*(void (**)(void))(*v33 + 8 * v34))();
  }
  return a1;
}

_QWORD *mlir::Pass::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;
  _QWORD *v6;

  *a1 = &unk_1E0E23658;
  v2 = a1 + 20;
  v3 = (_QWORD *)a1[23];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  *a1 = &unk_1E0E23930;
  v5 = (void *)a1[12];
  if (v5 != (void *)a1[11])
    free(v5);
  v6 = (_QWORD *)a1[8];
  if (v6 != a1 + 10)
    free(v6);
  return a1;
}

void mlir::Pass::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;

  *(_QWORD *)__p = &unk_1E0E23658;
  v2 = __p + 160;
  v3 = (char *)*((_QWORD *)__p + 23);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *(_QWORD *)__p = &unk_1E0E23930;
  v5 = (void *)*((_QWORD *)__p + 12);
  if (v5 != *((void **)__p + 11))
    free(v5);
  v6 = (char *)*((_QWORD *)__p + 8);
  if (v6 != __p + 80)
    free(v6);
  operator delete(__p);
}

llvm::raw_ostream *mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::print(uint64_t a1, llvm::raw_ostream *this)
{
  const void *v4;
  size_t v5;
  _BYTE *v6;
  llvm::raw_ostream *v7;

  v4 = *(const void **)(a1 + 16);
  v5 = *(_QWORD *)(a1 + 24);
  v6 = (_BYTE *)*((_QWORD *)this + 4);
  if (v5 <= *((_QWORD *)this + 3) - (_QWORD)v6)
  {
    if (v5)
    {
      memcpy(v6, v4, v5);
      v6 = (_BYTE *)(*((_QWORD *)this + 4) + v5);
      *((_QWORD *)this + 4) = v6;
    }
    v7 = this;
  }
  else
  {
    v7 = llvm::raw_ostream::write(this, (const char *)v4, v5);
    v6 = (_BYTE *)*((_QWORD *)v7 + 4);
  }
  if ((unint64_t)v6 >= *((_QWORD *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 61);
  }
  else
  {
    *((_QWORD *)v7 + 4) = v6 + 1;
    *v6 = 61;
  }
  return llvm::raw_ostream::operator<<(this, *(unsigned int *)(a1 + 128));
}

uint64_t mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::copyValueFrom(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 128) = *(_DWORD *)(a2 - 64);
  *(_BYTE *)(result + 200) = *(_BYTE *)(a2 + 8);
  return result;
}

void `non-virtual thunk to'mlir::Pass::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;
  void *v6;

  *(_QWORD *)(a1 - 192) = &unk_1E0E23658;
  v2 = (_QWORD *)(a1 - 32);
  v3 = *(_QWORD **)(a1 - 8);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  *(_QWORD *)(a1 - 192) = &unk_1E0E23930;
  v5 = *(void **)(a1 - 96);
  if (v5 != *(void **)(a1 - 104))
    free(v5);
  v6 = *(void **)(a1 - 128);
  if (v6 != (void *)(a1 - 112))
    free(v6);
}

{
  void *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  void *v7;

  *(_QWORD *)(a1 - 192) = &unk_1E0E23658;
  v2 = (void *)(a1 - 192);
  v3 = (_QWORD *)(a1 - 32);
  v4 = *(_QWORD **)(a1 - 8);
  if (v4 == v3)
  {
    v5 = 4;
    v4 = v3;
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  *(_QWORD *)(a1 - 192) = &unk_1E0E23930;
  v6 = *(void **)(a1 - 96);
  if (v6 != *(void **)(a1 - 104))
    free(v6);
  v7 = *(void **)(a1 - 128);
  if (v7 != (void *)(a1 - 112))
    free(v7);
  operator delete(v2);
}

llvm::raw_ostream *`non-virtual thunk to'mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::print(uint64_t a1, llvm::raw_ostream *this)
{
  const void *v4;
  size_t v5;
  _BYTE *v6;
  llvm::raw_ostream *v7;

  v4 = *(const void **)(a1 - 176);
  v5 = *(_QWORD *)(a1 - 168);
  v6 = (_BYTE *)*((_QWORD *)this + 4);
  if (v5 <= *((_QWORD *)this + 3) - (_QWORD)v6)
  {
    if (v5)
    {
      memcpy(v6, v4, v5);
      v6 = (_BYTE *)(*((_QWORD *)this + 4) + v5);
      *((_QWORD *)this + 4) = v6;
    }
    v7 = this;
  }
  else
  {
    v7 = llvm::raw_ostream::write(this, (const char *)v4, v5);
    v6 = (_BYTE *)*((_QWORD *)v7 + 4);
  }
  if ((unint64_t)v6 >= *((_QWORD *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 61);
  }
  else
  {
    *((_QWORD *)v7 + 4) = v6 + 1;
    *v6 = 61;
  }
  return llvm::raw_ostream::operator<<(this, *(unsigned int *)(a1 - 64));
}

uint64_t `non-virtual thunk to'mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::getOption(uint64_t a1)
{
  return a1 - 192;
}

uint64_t `non-virtual thunk to'mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::copyValueFrom(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result - 64) = *(_DWORD *)(a2 - 64);
  *(_BYTE *)(result + 8) = *(_BYTE *)(a2 + 8);
  return result;
}

uint64_t llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<unsigned int>,llvm::cl::NumOccurrencesFlag>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, _DWORD **a5, _WORD *a6)
{
  void *v12;
  uint64_t v13;
  uint64_t *GeneralCategory;
  uint64_t v15;

  *(_QWORD *)a1 = &unk_1E0E23930;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  v12 = (void *)(a1 + 80);
  *(_QWORD *)(a1 + 64) = a1 + 80;
  v13 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(_QWORD *)(a1 + 72) = 0x100000000;
  *(_QWORD *)(a1 + 88) = a1 + 120;
  *(_QWORD *)(a1 + 96) = a1 + 120;
  *(_QWORD *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  v15 = *(unsigned int *)(a1 + 72);
  if (v15 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v13, v12, v15 + 1, 8);
    LODWORD(v15) = *(_DWORD *)(a1 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v15) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = &off_1E0E22FA8;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)a1 = &unk_1E0E23658;
  *(_QWORD *)(a1 + 152) = &unk_1E0E23BC8;
  *(_QWORD *)(a1 + 160) = off_1E0E4FBE0;
  *(_QWORD *)(a1 + 184) = a1 + 160;
  llvm::cl::apply<llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<unsigned int>,llvm::cl::NumOccurrencesFlag>(a1, a2, a3, a4, a5, a6);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

_QWORD *mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;
  _QWORD *v6;

  *a1 = &unk_1E0E23658;
  v2 = a1 + 20;
  v3 = (_QWORD *)a1[23];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  *a1 = &unk_1E0E23930;
  v5 = (void *)a1[12];
  if (v5 != (void *)a1[11])
    free(v5);
  v6 = (_QWORD *)a1[8];
  if (v6 != a1 + 10)
    free(v6);
  return a1;
}

void mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;

  *(_QWORD *)__p = &unk_1E0E23658;
  v2 = __p + 160;
  v3 = (char *)*((_QWORD *)__p + 23);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *(_QWORD *)__p = &unk_1E0E23930;
  v5 = (void *)*((_QWORD *)__p + 12);
  if (v5 != *((void **)__p + 11))
    free(v5);
  v6 = (char *)*((_QWORD *)__p + 8);
  if (v6 != __p + 80)
    free(v6);
  operator delete(__p);
}

void `non-virtual thunk to'mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::~Option(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;
  void *v6;

  *(_QWORD *)(a1 - 192) = &unk_1E0E23658;
  v2 = (_QWORD *)(a1 - 32);
  v3 = *(_QWORD **)(a1 - 8);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  *(_QWORD *)(a1 - 192) = &unk_1E0E23930;
  v5 = *(void **)(a1 - 96);
  if (v5 != *(void **)(a1 - 104))
    free(v5);
  v6 = *(void **)(a1 - 128);
  if (v6 != (void *)(a1 - 112))
    free(v6);
}

{
  void *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  void *v7;

  *(_QWORD *)(a1 - 192) = &unk_1E0E23658;
  v2 = (void *)(a1 - 192);
  v3 = (_QWORD *)(a1 - 32);
  v4 = *(_QWORD **)(a1 - 8);
  if (v4 == v3)
  {
    v5 = 4;
    v4 = v3;
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  *(_QWORD *)(a1 - 192) = &unk_1E0E23930;
  v6 = *(void **)(a1 - 96);
  if (v6 != *(void **)(a1 - 104))
    free(v6);
  v7 = *(void **)(a1 - 128);
  if (v7 != (void *)(a1 - 112))
    free(v7);
  operator delete(v2);
}

__n128 llvm::cl::apply<llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<unsigned int>,llvm::cl::NumOccurrencesFlag>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, _DWORD **a5, _WORD *a6)
{
  const void *v11;
  uint64_t v12;
  __n128 result;
  _DWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;

  llvm::cl::Option::setArgStr(a1, *(int8x16_t **)a2, *(const unsigned __int8 **)(a2 + 8));
  v11 = *a3;
  v12 = *(_QWORD *)(a1 + 96);
  if (v12 != *(_QWORD *)(a1 + 88))
  {
LABEL_2:
    llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(a1 + 88), v11);
    goto LABEL_3;
  }
  v15 = *(unsigned int *)(a1 + 108);
  if (!(_DWORD)v15)
  {
LABEL_12:
    if (v15 < *(_DWORD *)(a1 + 104))
    {
      *(_DWORD *)(a1 + 108) = v15 + 1;
      *(_QWORD *)(v12 + 8 * v15) = v11;
      goto LABEL_3;
    }
    goto LABEL_2;
  }
  v16 = 0;
  v17 = 8 * v15;
  v18 = *(_QWORD **)(a1 + 96);
  while ((const void *)*v18 != v11)
  {
    if (*v18 == -2)
      v16 = v18;
    ++v18;
    v17 -= 8;
    if (!v17)
    {
      if (!v16)
        goto LABEL_12;
      *v16 = v11;
      --*(_DWORD *)(a1 + 112);
      break;
    }
  }
LABEL_3:
  result = *a4;
  *(__n128 *)(a1 + 32) = *a4;
  v14 = *a5;
  *(_DWORD *)(a1 + 128) = **a5;
  *(_BYTE *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = *v14;
  *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 10) & 0xFFF8 | *a6 & 7;
  return result;
}

_QWORD *_ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_11initializerIjEENS7_18NumOccurrencesFlagEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISO_EEFvRKjEE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1E0E51630;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_11initializerIjEENS7_18NumOccurrencesFlagEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISO_EEFvRKjEE7__cloneEPNS0_6__baseIST_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1E0E51630;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_11initializerIjEENS7_18NumOccurrencesFlagEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISO_EEFvRKjEEclESS_(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 8) + 200) = 1;
  return result;
}

uint64_t llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<mlir::mps::`anonymous namespace'::LoadConstantsPass::runOnOperation(void)::$_0>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  mlir::Operation *v3;
  uint64_t v6;
  const char *Archive;
  uint64_t v8;
  int v9;
  const void *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  _QWORD *v16;
  void *v17;
  size_t v18;
  _QWORD *p_dst;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t Identifier;
  unint64_t v24;
  size_t v25;
  const void *v26;
  void *p_p;
  uint64_t v28;
  void *v29;
  size_t v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *DataSize;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  _QWORD *v45;
  _QWORD *v46;
  unint64_t v47;
  unint64_t *v48;
  _QWORD *v49;
  unint64_t v50;
  uint64_t v51;
  mlir::Operation *v52;
  uint64_t v53;
  uint64_t v54;
  mlir::GenericProgramPoint *v55;
  uint64_t v56;
  const char *v57;
  const std::error_category *v58;
  uint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  void *v62;
  size_t v63;
  void *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  void *v70;
  size_t v71;
  unint64_t v72;
  void *__p;
  size_t v74;
  unint64_t v75;
  _QWORD *__dst;
  size_t v77;
  unint64_t v78;
  __int16 v79;
  uint64_t *v80[4];
  __int16 v81;
  mlir::Operation *v82;
  _QWORD *v83[4];
  __int16 v84;
  const char *Context;
  _QWORD v86[3];
  __int16 v87;
  uint64_t v88;
  char v89;
  void *__src;
  __int128 __len;
  _QWORD v92[33];

  v92[32] = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  if (*(_UNKNOWN **)(a2[6] + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::FileBackedConstantOp,void>::id)
    v3 = (mlir::Operation *)a2;
  else
    v3 = 0;
  v82 = v3;
  if (!v3 || (unint64_t)mlir::mpsx::FileBackedConstantOp::getDataSize(&v82) > *(unsigned int *)(v2 + 720))
    return 1;
  __src = v92;
  __len = xmmword_181236410;
  Archive = (const char *)mlir::mpsx::FileBackedConstantOp::getArchive(&v82);
  v87 = 261;
  Context = Archive;
  v86[0] = v8;
  if (llvm::sys::path::is_relative(&Context, 0))
  {
    v9 = *(char *)(v2 + 495);
    if (v9 >= 0)
      v10 = (const void *)(v2 + 472);
    else
      v10 = *(const void **)(v2 + 472);
    if (v9 >= 0)
      v11 = *(unsigned __int8 *)(v2 + 495);
    else
      v11 = *(_QWORD *)(v2 + 480);
    *(_QWORD *)&__len = 0;
    if (*((_QWORD *)&__len + 1) >= v11)
    {
      v12 = 0;
      v13 = 0;
      if (!v11)
      {
LABEL_18:
        *(_QWORD *)&__len = v13 + v11;
        goto LABEL_19;
      }
    }
    else
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&__src, v92, v11, 1);
      v12 = __len;
    }
    memcpy((char *)__src + v12, v10, v11);
    v13 = __len;
    goto LABEL_18;
  }
LABEL_19:
  v14 = (const char *)mlir::mpsx::FileBackedConstantOp::getArchive(&v82);
  v87 = 261;
  Context = v14;
  v86[0] = v15;
  v84 = 257;
  v81 = 257;
  v79 = 257;
  llvm::sys::path::append(&__src, (_QWORD **)&Context, v83, (const char **)v80, &__dst);
  v16 = (_QWORD *)a1[1];
  v17 = __src;
  if (!__src)
  {
    __dst = 0;
    v77 = 0;
    v78 = 0;
    goto LABEL_30;
  }
  v18 = __len;
  if ((unint64_t)__len > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_114;
  if ((unint64_t)__len >= 0x17)
  {
    v20 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if (((unint64_t)__len | 7) != 0x17)
      v20 = __len | 7;
    v21 = v20 + 1;
    p_dst = operator new(v20 + 1);
    v77 = v18;
    v78 = v21 | 0x8000000000000000;
    __dst = p_dst;
  }
  else
  {
    HIBYTE(v78) = __len;
    p_dst = &__dst;
    if (!(_QWORD)__len)
      goto LABEL_29;
  }
  memmove(p_dst, v17, v18);
LABEL_29:
  *((_BYTE *)p_dst + v18) = 0;
LABEL_30:
  mlir::mps::ArchiveManager::getOrLoad(v16, (uint64_t)&__dst, (uint64_t)&v88);
  if (SHIBYTE(v78) < 0)
  {
    operator delete(__dst);
    if ((v89 & 1) == 0)
    {
LABEL_32:
      v22 = v88;
      Identifier = mlir::mpsx::FileBackedConstantOp::getIdentifier(&v82);
      if (!Identifier)
      {
        __p = 0;
        v74 = 0;
        v75 = 0;
        goto LABEL_51;
      }
      v25 = v24;
      if (v24 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_114;
      v26 = (const void *)Identifier;
      if (v24 >= 0x17)
      {
        v32 = (v24 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v24 | 7) != 0x17)
          v32 = v24 | 7;
        v33 = v32 + 1;
        p_p = operator new(v32 + 1);
        v74 = v25;
        v75 = v33 | 0x8000000000000000;
        __p = p_p;
      }
      else
      {
        HIBYTE(v75) = v24;
        p_p = &__p;
        if (!v24)
          goto LABEL_50;
      }
      memmove(p_p, v26, v25);
LABEL_50:
      *((_BYTE *)p_p + v25) = 0;
LABEL_51:
      v34 = std::__hash_table<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::shared_ptr<plist::PListType>>>>::find<std::string>((_QWORD *)(v22 + 24), (uint64_t)&__p);
      v35 = v34;
      if (v34)
      {
        v36 = (void *)v34[5];
        if ((SHIBYTE(v75) & 0x80000000) == 0)
          goto LABEL_54;
      }
      else
      {
        v58 = std::generic_category();
        v36 = operator new(0x38uLL);
        Context = "No such archive member.";
        v87 = 259;
        llvm::StringError::StringError((uint64_t)v36, (llvm::Twine *)&Context, 22, (uint64_t)v58);
        if ((SHIBYTE(v75) & 0x80000000) == 0)
        {
LABEL_54:
          if (v35)
          {
            v37 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v82) + 8) & 0xFFFFFFFFFFFFFFF8);
            v83[0] = v37;
            DataSize = mlir::mpsx::FileBackedConstantOp::getDataSize(&v82);
            if (!v37)
              goto LABEL_64;
            v42 = *v37;
            v43 = mlir::TypeID::get<mlir::ShapedType>();
            v44 = *(unsigned int *)(v42 + 16);
            if (!(_DWORD)v44)
              goto LABEL_64;
            v45 = *(_QWORD **)(v42 + 8);
            v46 = &v45[2 * v44];
            do
            {
              v47 = v44 >> 1;
              v48 = &v45[2 * (v44 >> 1)];
              v50 = *v48;
              v49 = v48 + 2;
              v44 += ~(v44 >> 1);
              if (v50 < v43)
                v45 = v49;
              else
                v44 = v47;
            }
            while (v44);
            if (v45 != v46 && *v45 == v43)
              v51 = v45[1];
            else
LABEL_64:
              v51 = 0;
            v80[0] = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v37, v51, v36, DataSize, v38, v39, v40);
            v52 = v82;
            Context = (const char *)mlir::Attribute::getContext((mlir::Operation *)((char *)v82 + 24));
            v86[0] = 0;
            v53 = *((_QWORD *)v52 + 2);
            mlir::GenericProgramPoint::~GenericProgramPoint(v52);
            v86[1] = v53;
            v86[2] = v54;
            v55 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::MemRefType &,mlir::mps::MPSBufferTensorAttr &>((mlir::OpBuilder *)&Context, *((_QWORD *)v82 + 3), (uint64_t *)v83, v80);
            v56 = *((unsigned int *)v82 + 9);
            v57 = (char *)v82 - 16;
            if (!(_DWORD)v56)
              v57 = 0;
            Context = v57;
            v86[0] = v56;
            mlir::ResultRange::replaceAllUsesWith((uint64_t *)&Context, v55);
            mlir::Operation::erase(v82);
            v6 = 1;
            if ((v89 & 1) == 0)
              goto LABEL_110;
            goto LABEL_108;
          }
          v59 = a2[3];
          v80[0] = (uint64_t *)"Could not find child '";
          v81 = 259;
          mlir::emitError(v59, (uint64_t)v80, (uint64_t)&Context);
          v60 = (_QWORD *)mlir::mpsx::FileBackedConstantOp::getIdentifier(&v82);
          if (Context)
          {
            v84 = 261;
            v83[0] = v60;
            v83[1] = v61;
            mlir::Diagnostic::operator<<((uint64_t)v86, (const void ***)v83);
            if (Context)
              mlir::Diagnostic::operator<<((uint64_t)v86, "' in '");
          }
          v62 = __src;
          if (!__src)
          {
            v70 = 0;
            v71 = 0;
            v72 = 0;
LABEL_98:
            if (Context)
            {
              v84 = 260;
              v83[0] = &v70;
              mlir::Diagnostic::operator<<((uint64_t)v86, (const void ***)v83);
              if (Context)
                mlir::Diagnostic::operator<<((uint64_t)v86, "'.");
            }
            if (SHIBYTE(v72) < 0)
              operator delete(v70);
            if (Context)
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Context);
            std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v86);
            if (v36)
              (*(void (**)(void *))(*(_QWORD *)v36 + 8))(v36);
            v6 = 0;
            if ((v89 & 1) == 0)
              goto LABEL_110;
            goto LABEL_108;
          }
          v63 = __len;
          if ((unint64_t)__len <= 0x7FFFFFFFFFFFFFF7)
          {
            if ((unint64_t)__len >= 0x17)
            {
              v67 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
              if (((unint64_t)__len | 7) != 0x17)
                v67 = __len | 7;
              v68 = v67 + 1;
              v64 = operator new(v67 + 1);
              v71 = v63;
              v72 = v68 | 0x8000000000000000;
              v70 = v64;
            }
            else
            {
              HIBYTE(v72) = __len;
              v64 = &v70;
              if (!(_QWORD)__len)
                goto LABEL_97;
            }
            memmove(v64, v62, v63);
LABEL_97:
            *((_BYTE *)v64 + v63) = 0;
            goto LABEL_98;
          }
LABEL_114:
          abort();
        }
      }
      operator delete(__p);
      goto LABEL_54;
    }
  }
  else if ((v89 & 1) == 0)
  {
    goto LABEL_32;
  }
  v28 = a2[3];
  v80[0] = (uint64_t *)"Failed to process archive '";
  v81 = 259;
  mlir::emitError(v28, (uint64_t)v80, (uint64_t)&Context);
  v29 = __src;
  if (!__src)
  {
    __p = 0;
    v74 = 0;
    v75 = 0;
    if (!Context)
      goto LABEL_86;
    goto LABEL_84;
  }
  v30 = __len;
  if ((unint64_t)__len > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_114;
  if ((unint64_t)__len >= 0x17)
  {
    v65 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if (((unint64_t)__len | 7) != 0x17)
      v65 = __len | 7;
    v66 = v65 + 1;
    v31 = operator new(v65 + 1);
    v74 = v30;
    v75 = v66 | 0x8000000000000000;
    __p = v31;
    goto LABEL_82;
  }
  HIBYTE(v75) = __len;
  v31 = &__p;
  if ((_QWORD)__len)
LABEL_82:
    memmove(v31, v29, v30);
  *((_BYTE *)v31 + v30) = 0;
  if (!Context)
    goto LABEL_86;
LABEL_84:
  v84 = 260;
  v83[0] = &__p;
  mlir::Diagnostic::operator<<((uint64_t)v86, (const void ***)v83);
  if (Context)
    mlir::Diagnostic::operator<<((uint64_t)v86, "'.");
LABEL_86:
  if (SHIBYTE(v75) < 0)
    operator delete(__p);
  if (Context)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Context);
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v86);
  v6 = 0;
  if ((v89 & 1) == 0)
    goto LABEL_110;
LABEL_108:
  if (v88)
    (*(void (**)(uint64_t))(*(_QWORD *)v88 + 8))(v88);
LABEL_110:
  if (__src != v92)
    free(__src);
  return v6;
}

void mlir::mps::`anonymous namespace'::StoreConstantsPass::~StoreConstantsPass(mlir::mps::_anonymous_namespace_::StoreConstantsPass *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;

  *(_QWORD *)this = off_1E0E4BB08;
  *((_QWORD *)this + 105) = &unk_1E0E23658;
  v2 = (char *)this + 1000;
  v3 = (char *)*((_QWORD *)this + 128);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)this + 105) = &unk_1E0E23930;
  v5 = (void *)*((_QWORD *)this + 117);
  if (v5 != *((void **)this + 116))
    free(v5);
  v6 = (char *)*((_QWORD *)this + 113);
  if (v6 != (char *)this + 920)
    free(v6);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 592);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 344);
  mlir::Pass::~Pass(this);
}

{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;
  void *v7;

  *(_QWORD *)this = off_1E0E4BB08;
  *((_QWORD *)this + 105) = &unk_1E0E23658;
  v2 = (char *)this + 1000;
  v3 = (char *)*((_QWORD *)this + 128);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)this + 105) = &unk_1E0E23930;
  v5 = (void *)*((_QWORD *)this + 117);
  if (v5 != *((void **)this + 116))
    free(v5);
  v6 = (char *)*((_QWORD *)this + 113);
  if (v6 != (char *)this + 920)
    free(v6);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 592);
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::~Option((uint64_t)this + 344);
  mlir::Pass::~Pass(this);
  operator delete(v7);
}

const char *mlir::mps::MPSStoreConstantsBase<mlir::mps::`anonymous namespace'::StoreConstantsPass>::getName()
{
  return "MPSStoreConstants";
}

_QWORD *mlir::mps::MPSStoreConstantsBase<mlir::mps::`anonymous namespace'::StoreConstantsPass>::getDependentDialects(int a1, uint64_t **a2)
{
  uint64_t v2;
  _QWORD *result;
  _QWORD v4[3];
  _QWORD *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4[0] = off_1E0E50990;
  v5 = v4;
  v2 = 4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::mpsx::MPSXDialect,void>::id, "mpsx", 4uLL, v4);
  result = v5;
  if (v5 == v4)
  {
    result = v4;
  }
  else
  {
    if (!v5)
      return result;
    v2 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v2))();
}

const char *mlir::mps::MPSStoreConstantsBase<mlir::mps::`anonymous namespace'::StoreConstantsPass>::getArgument()
{
  return "mps-store-constants";
}

const char *mlir::mps::MPSStoreConstantsBase<mlir::mps::`anonymous namespace'::StoreConstantsPass>::getDescription()
{
  return "Store constants above a certain size to an archive.";
}

void mlir::mps::`anonymous namespace'::StoreConstantsPass::runOnOperation(mlir::mps::_anonymous_namespace_::StoreConstantsPass *this)
{
  uint64_t v2;
  mlir::ForwardIterator *v3;
  int v4;
  char *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27[4];
  __int16 v28;
  const char *v29[4];
  __int16 v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  void *__p;
  _BYTE *v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  __int16 v39;
  _QWORD *v40;
  _QWORD v41[3];
  __int16 v42;
  void *v43;
  __int128 v44;
  _QWORD v45[33];

  v45[32] = *MEMORY[0x1E0C80C00];
  __p = 0;
  v35 = 0;
  v36 = 0;
  v31 = (uint64_t)&v31;
  v32 = &v31;
  v33 = 0;
  v2 = *((_QWORD *)this + 5);
  v3 = (mlir::ForwardIterator *)(v2 & 0xFFFFFFFFFFFFFFF8);
  if ((v2 & 0xFFFFFFFFFFFFFFF8) != 0)
    mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(v2 & 0xFFFFFFFFFFFFFFF8);
  v43 = this;
  *(_QWORD *)&v44 = &v31;
  *((_QWORD *)&v44 + 1) = &__p;
  v43 = v45;
  v44 = xmmword_181236410;
  v42 = 260;
  v40 = (_QWORD *)((char *)this + 472);
  if (llvm::sys::path::is_relative((const char **)&v40, 0))
  {
    v4 = *((char *)this + 743);
    if (v4 >= 0)
      v5 = (char *)this + 720;
    else
      v5 = (char *)*((_QWORD *)this + 90);
    if (v4 >= 0)
      v6 = *((unsigned __int8 *)this + 743);
    else
      v6 = *((_QWORD *)this + 91);
    *(_QWORD *)&v44 = 0;
    if (*((_QWORD *)&v44 + 1) >= v6)
    {
      v7 = 0;
      v8 = 0;
      if (!v6)
      {
LABEL_14:
        *(_QWORD *)&v44 = v8 + v6;
        goto LABEL_15;
      }
    }
    else
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v43, v45, v6, 1);
      v7 = v44;
    }
    memcpy((char *)v43 + v7, v5, v6);
    v8 = v44;
    goto LABEL_14;
  }
LABEL_15:
  v42 = 260;
  v40 = (_QWORD *)((char *)this + 472);
  v39 = 257;
  v30 = 257;
  v28 = 257;
  llvm::sys::path::append(&v43, &v40, &v37, v29, v27);
  v42 = 261;
  v40 = v43;
  v41[0] = v44;
  if (llvm::sys::fs::access((unsigned __int8 *)&v40, 0))
  {
    v26 = 0;
    llvm::writeArchive((uint64_t)v43, v44, (unint64_t)__p, 0xAAAAAAAAAAAAAAABLL * ((v35 - (_BYTE *)__p) >> 4), 0, 3, 0, 0, (unsigned __int8 **)v27, &v26, 0);
    v9 = v26;
    v26 = 0;
    if (v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
    if (v27[0])
    {
      v10 = *((_QWORD *)this + 5);
      v11 = v10 & 0xFFFFFFFFFFFFFFF8;
      if ((v10 & 0xFFFFFFFFFFFFFFF8) != 0)
        mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(v10 & 0xFFFFFFFFFFFFFFF8);
      v12 = *(_QWORD *)(v11 + 24);
      v29[0] = "Failed to write archive '";
      v30 = 259;
      mlir::emitError(v12, (uint64_t)v29, (uint64_t)&v40);
      if (v40)
      {
        v39 = 261;
        v37 = v43;
        v38 = v44;
        mlir::Diagnostic::operator<<((uint64_t)v41, (const void ***)&v37);
        if (v40)
        {
          mlir::Diagnostic::operator<<((uint64_t)v41, "'.");
          if (v40)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v40);
        }
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v41);
      *((_QWORD *)this + 5) |= 4uLL;
      v13 = v27[0];
      v27[0] = 0;
      v37 = v13;
      llvm::handleErrors<llvm::consumeError(llvm::Error)::{lambda(llvm::ErrorInfoBase const&)#1}>(&v37, (uint64_t *)&v40);
      if (v37)
        (*(void (**)(_QWORD *))(*v37 + 8))(v37);
      if (v27[0])
        (*(void (**)(_QWORD *))(*v27[0] + 8))(v27[0]);
    }
  }
  else
  {
    v14 = *((_QWORD *)this + 5);
    v15 = v14 & 0xFFFFFFFFFFFFFFF8;
    if ((v14 & 0xFFFFFFFFFFFFFFF8) != 0)
      mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(v14 & 0xFFFFFFFFFFFFFFF8);
    v16 = *(_QWORD *)(v15 + 24);
    v29[0] = "Archive '";
    v30 = 259;
    mlir::emitError(v16, (uint64_t)v29, (uint64_t)&v40);
    if (v40)
    {
      v39 = 261;
      v37 = v43;
      v38 = v44;
      mlir::Diagnostic::operator<<((uint64_t)v41, (const void ***)&v37);
      if (v40)
      {
        mlir::Diagnostic::operator<<((uint64_t)v41, "' already exists. This pass does not support appending to an existing archive.");
        if (v40)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v40);
      }
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v41);
    *((_QWORD *)this + 5) |= 4uLL;
  }
  if (v43 != v45)
    free(v43);
  if (v33)
  {
    v17 = v31;
    v18 = v32;
    v19 = *v32;
    *(_QWORD *)(v19 + 8) = *(_QWORD *)(v31 + 8);
    **(_QWORD **)(v17 + 8) = v19;
    v33 = 0;
    if (v18 != &v31)
    {
      do
      {
        v23 = (uint64_t *)v18[1];
        if (*((char *)v18 + 39) < 0)
          operator delete((void *)v18[2]);
        operator delete(v18);
        v18 = v23;
      }
      while (v23 != &v31);
    }
  }
  v20 = __p;
  if (__p)
  {
    v21 = v35;
    v22 = __p;
    if (v35 != __p)
    {
      do
      {
        v25 = *(v21 - 6);
        v21 -= 6;
        v24 = v25;
        *v21 = 0;
        if (v25)
          (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
      }
      while (v21 != v20);
      v22 = __p;
    }
    v35 = v20;
    operator delete(v22);
  }
}

_QWORD *mlir::mps::MPSStoreConstantsBase<mlir::mps::`anonymous namespace'::StoreConstantsPass>::clonePass@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _OWORD *v4;
  uint64_t v5;
  _QWORD *result;
  int v7;
  __n128 v8;

  v4 = operator new(0x420uLL);
  v5 = *(_QWORD *)(a1 + 8);
  v4[1] = *(_OWORD *)(a1 + 16);
  *((_QWORD *)v4 + 4) = *(_QWORD *)(a1 + 32);
  *((_BYTE *)v4 + 40) = 0;
  *((_BYTE *)v4 + 120) = 0;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  *((_QWORD *)v4 + 22) = 0;
  *((_QWORD *)v4 + 23) = (char *)v4 + 200;
  *((_QWORD *)v4 + 24) = 0x400000000;
  *((_QWORD *)v4 + 29) = (char *)v4 + 248;
  *((_QWORD *)v4 + 30) = 0x400000000;
  *((_QWORD *)v4 + 35) = 0;
  *((_QWORD *)v4 + 36) = 0;
  *((_DWORD *)v4 + 74) = 0;
  *((_DWORD *)v4 + 75) = 16;
  v4[19] = 0u;
  v4[20] = 0u;
  *((_QWORD *)v4 + 42) = 0;
  *(_QWORD *)v4 = off_1E0E4BB08;
  *((_QWORD *)v4 + 1) = v5;
                                     "s will be stored.";
  v8.n128_u64[1] = 100;
  v7 = 2;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc,llvm::cl::NumOccurrencesFlag>((_QWORD *)v4 + 43, (_QWORD *)v4 + 19, (uint64_t)"archive", 7, &v8, &v7);
  *((_QWORD *)v4 + 43) = &off_1E0E4C260;
  *((_QWORD *)v4 + 72) = &unk_1E0E4C2E0;
  v8.n128_u64[1] = 48;
  v7 = 0;
  mlir::detail::PassOptions::Option<std::string,llvm::cl::parser<std::string>>::Option<llvm::cl::desc,llvm::cl::NumOccurrencesFlag>((_QWORD *)v4 + 74, (_QWORD *)v4 + 19, (uint64_t)"archive-dir", 11, &v8, &v7);
  *((_QWORD *)v4 + 74) = &off_1E0E4C260;
  *((_QWORD *)v4 + 103) = &unk_1E0E4C2E0;
  v8.n128_u64[0] = (unint64_t)"The data size limit (in bytes) above which to store constants in the archive file.";
  v8.n128_u64[1] = 82;
  v7 = 0;
  result = mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::NumOccurrencesFlag>((_QWORD *)v4 + 105, (_QWORD *)v4 + 19, (uint64_t)"data-size-limit", 15, &v8, &v7);
  *((_QWORD *)v4 + 105) = off_1E0E4C3E0;
  *((_QWORD *)v4 + 129) = &unk_1E0E4C460;
  *(_QWORD *)v4 = off_1E0E49A80;
  *((_DWORD *)v4 + 262) = *(_DWORD *)(a1 + 1048);
  *a2 = v4;
  return result;
}

_QWORD *mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::NumOccurrencesFlag>(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4, __n128 *a5, _WORD *a6)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t *v20;
  char *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t *v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  const void **v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  _QWORD v35[2];
  _QWORD v36[3];
  _QWORD *v37;
  const void *v38[3];
  const void **v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v35[0] = a3;
  v35[1] = a4;
  v38[0] = a2;
  v8 = llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::NumOccurrencesFlag>((uint64_t)a1, (uint64_t)v35, v38, a5, a6);
  *(_QWORD *)(v8 + 192) = &unk_1E0E4E208;
  v9 = v8 + 192;
  *(_BYTE *)(v8 + 200) = 0;
  *(_QWORD *)v8 = off_1E0E4E188;
  v11 = (uint64_t *)a2[21];
  v10 = a2[22];
  v12 = v11;
  if ((unint64_t)v11 >= v10)
  {
    v14 = (uint64_t *)a2[20];
    v15 = v11 - v14;
    v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61)
      abort();
    v17 = v10 - (_QWORD)v14;
    if (v17 >> 2 > v16)
      v16 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v16;
    if (v18)
    {
      if (v18 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v19 = (char *)operator new(8 * v18);
    }
    else
    {
      v19 = 0;
    }
    v20 = (uint64_t *)&v19[8 * v15];
    v21 = &v19[8 * v18];
    *v20 = v9;
    v13 = v20 + 1;
    if (v11 != v14)
    {
      v22 = (char *)v11 - (char *)v14 - 8;
      if (v22 < 0x58)
        goto LABEL_38;
      if ((unint64_t)((char *)v14 - v19) < 0x20)
        goto LABEL_38;
      v23 = (v22 >> 3) + 1;
      v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v12 = &v11[v24 / 0xFFFFFFFFFFFFFFF8];
      v20 = (uint64_t *)((char *)v20 - v24);
      v25 = &v19[8 * v15 - 16];
      v26 = v11 - 2;
      v27 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v28 = *(_OWORD *)v26;
        *((_OWORD *)v25 - 1) = *((_OWORD *)v26 - 1);
        *(_OWORD *)v25 = v28;
        v25 -= 32;
        v26 -= 4;
        v27 -= 4;
      }
      while (v27);
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_38:
        do
        {
          v29 = *--v12;
          *--v20 = v29;
        }
        while (v12 != v14);
      }
      v12 = (uint64_t *)a2[20];
    }
    a2[20] = v20;
    a2[21] = v13;
    a2[22] = v21;
    if (v12)
      operator delete(v12);
  }
  else
  {
    *v11 = v9;
    v13 = v11 + 1;
  }
  a2[21] = v13;
  v36[0] = off_1E0E51678;
  v36[1] = a1;
  v37 = v36;
  v38[0] = off_1E0E51678;
  v39 = v38;
  v38[1] = a1;
  std::__function::__value_func<void ()(long long const&)>::swap[abi:nn180100](v38, a1 + 20);
  v30 = v39;
  if (v39 == v38)
  {
    v31 = 4;
    v30 = v38;
  }
  else
  {
    if (!v39)
      goto LABEL_28;
    v31 = 5;
  }
  (*((void (**)(void))*v30 + v31))();
LABEL_28:
  v32 = v37;
  if (v37 == v36)
  {
    v33 = 4;
    v32 = v36;
    goto LABEL_32;
  }
  if (v37)
  {
    v33 = 5;
LABEL_32:
    (*(void (**)(void))(*v32 + 8 * v33))();
  }
  return a1;
}

uint64_t llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::NumOccurrencesFlag>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, _WORD *a5)
{
  void *v10;
  uint64_t v11;
  uint64_t *GeneralCategory;
  uint64_t v13;

  *(_WORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &unk_1E0E23930;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  v10 = (void *)(a1 + 80);
  *(_QWORD *)(a1 + 64) = a1 + 80;
  v11 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(_QWORD *)(a1 + 72) = 0x100000000;
  *(_QWORD *)(a1 + 88) = a1 + 120;
  *(_QWORD *)(a1 + 96) = a1 + 120;
  *(_QWORD *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  v13 = *(unsigned int *)(a1 + 72);
  if (v13 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v11, v10, v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a1 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v13) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = &off_1E0E22FA8;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)a1 = &unk_1E0E23658;
  *(_QWORD *)(a1 + 152) = &unk_1E0E23BC8;
  *(_QWORD *)(a1 + 160) = off_1E0E4FBE0;
  *(_QWORD *)(a1 + 184) = a1 + 160;
  llvm::cl::apply<llvm::cl::opt<std::string,false,llvm::cl::parser<std::string>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::NumOccurrencesFlag>(a1, a2, a3, a4, a5);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

_QWORD *_ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_18NumOccurrencesFlagEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISM_EEFvRKjEE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1E0E51678;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_18NumOccurrencesFlagEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISM_EEFvRKjEE7__cloneEPNS0_6__baseISR_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1E0E51678;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_18NumOccurrencesFlagEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISM_EEFvRKjEEclESQ_(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 8) + 200) = 1;
  return result;
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::mps::`anonymous namespace'::StoreConstantsPass::runOnOperation(void)::$_0>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t DefiningOp;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  unint64_t v11;
  _BOOL4 v12;
  uint64_t RawStringData;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  int v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  mlir::GenericProgramPoint *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  unint64_t v40;
  __int128 Context;
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v40 = 0;
  if (*(_DWORD *)(a2 + 36))
  {
    v5 = a2 - 16;
    *(_QWORD *)&v38 = a2 - 16;
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v38);
    if (DefiningOp)
    {
      v7 = DefiningOp;
      v8 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v7 + 48) + 32))(*(_QWORD *)(v7 + 48), v8))
      {
        *(_QWORD *)&Context = &v42;
        *((_QWORD *)&Context + 1) = 0x100000000;
        mlir::Operation::fold(v7, 0, 0, (uint64_t)&Context);
        v9 = *(_QWORD *)Context;
        v10 = mlir::DenseElementsAttr::classof(*(_QWORD *)Context & 0xFFFFFFFFFFFFFFF8);
        v11 = v9 & 0xFFFFFFFFFFFFFFF8;
        v12 = (v9 & 0xFFFFFFFFFFFFFFF8) != 0 && v10;
        if (v12)
          v40 = v11;
        if ((__int128 *)Context != &v42)
          free((void *)Context);
        if (v12)
        {
          RawStringData = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&v40);
          if (v14 > *(unsigned int *)(v2 + 968))
          {
            v15 = RawStringData;
            v16 = v14;
            if ((mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v40) & 1) == 0)
            {
              v17 = (uint64_t *)a1[1];
              v18 = *(_DWORD *)(v2 + 1048);
              *(_DWORD *)(v2 + 1048) = v18 + 1;
              std::to_string((std::string *)&Context, v18);
              v19 = operator new(0x28uLL);
              v19[4] = v42;
              *((_OWORD *)v19 + 1) = Context;
              v19[1] = v17;
              v20 = *v17;
              *v19 = *v17;
              *(_QWORD *)(v20 + 8) = v19;
              *v17 = (uint64_t)v19;
              ++v17[2];
              v21 = (uint64_t *)a1[2];
              v22 = *(_QWORD *)a1[1];
              v25 = *(_QWORD *)(v22 + 16);
              v23 = v22 + 16;
              v24 = v25;
              v26 = *(char *)(v23 + 23);
              if (v26 >= 0)
                v24 = v23;
              v27 = *(_QWORD *)(v23 + 8);
              if (v26 >= 0)
                v27 = v26;
              *(_QWORD *)&v38 = v15;
              *((_QWORD *)&v38 + 1) = v16;
              *(_QWORD *)&v39 = v24;
              *((_QWORD *)&v39 + 1) = v27;
              v28 = v21[1];
              if (v28 >= v21[2])
              {
                v29 = std::vector<llvm::NewArchiveMember>::__emplace_back_slow_path<llvm::MemoryBufferRef>(v21, &v38);
              }
              else
              {
                Context = v38;
                v42 = v39;
                v29 = llvm::NewArchiveMember::NewArchiveMember(v28, &Context) + 48;
              }
              v21[1] = v29;
              *(_QWORD *)&v38 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v40);
              Context = (unint64_t)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
              v30 = *(_QWORD *)(a2 + 16);
              mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)a2);
              *(_QWORD *)&v42 = v30;
              *((_QWORD *)&v42 + 1) = v31;
              v32 = *(_QWORD *)(a2 + 24);
              v33 = *(_QWORD *)a1[1] + 16;
              v37 = v16;
              v34 = mlir::OpBuilder::create<mlir::mpsx::FileBackedConstantOp,mlir::TensorType &,mlir::Pass::Option<std::string,llvm::cl::parser<std::string>> &,std::string&,unsigned long>((mlir::StringAttr **)&Context, v32, (uint64_t *)&v38, v2 + 344, v33, &v37);
              v35 = *(unsigned int *)(a2 + 36);
              if ((_DWORD)v35)
                v36 = v5;
              else
                v36 = 0;
              *(_QWORD *)&Context = v36;
              *((_QWORD *)&Context + 1) = v35;
              mlir::ResultRange::replaceAllUsesWith((uint64_t *)&Context, v34);
              mlir::Operation::erase((mlir::Operation *)a2);
            }
          }
        }
      }
    }
  }
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::FileBackedConstantOp,mlir::TensorType &,mlir::Pass::Option<std::string,llvm::cl::parser<std::string>> &,std::string&,unsigned long>(mlir::StringAttr **a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  mlir::GenericProgramPoint *v24;
  mlir::GenericProgramPoint *v25;
  uint64_t v27;
  const char *v28;
  __int16 v29;
  uint64_t v30[4];
  __int16 v31;
  _QWORD v32[39];

  v32[38] = *MEMORY[0x1E0C80C00];
  v27 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v27);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.file_backed_constant", (const unsigned __int8 *)0x19, Context);
  if (!v14)
  {
    v31 = 1283;
    v30[2] = (uint64_t)"mpsx.file_backed_constant";
    v30[3] = 25;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v29 = 259;
    llvm::operator+(v30, (uint64_t *)&v28, (uint64_t)v32);
    llvm::report_fatal_error((llvm::Twine *)v32, 1);
  }
  mlir::OperationState::OperationState(v32, a2, v13);
  v17 = *(_QWORD *)(a4 + 128);
  v16 = a4 + 128;
  v15 = v17;
  v18 = *(char *)(v16 + 23);
  if (v18 >= 0)
    v19 = v16;
  else
    v19 = v15;
  if (v18 >= 0)
    v20 = *(unsigned __int8 *)(v16 + 23);
  else
    v20 = *(_QWORD *)(v16 + 8);
  v21 = *(char *)(a5 + 23);
  if (v21 >= 0)
    v22 = a5;
  else
    v22 = *(_QWORD *)a5;
  if (v21 >= 0)
    v23 = *(unsigned __int8 *)(a5 + 23);
  else
    v23 = *(_QWORD *)(a5 + 8);
  mlir::mpsx::FileBackedConstantOp::build(a1, (uint64_t)v32, *a3, v19, v20, v22, v23, *a6);
  v24 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v32);
  if (*(_UNKNOWN **)(*((_QWORD *)v24 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::FileBackedConstantOp,void>::id)
    v25 = v24;
  else
    v25 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v32);
  return v25;
}

uint64_t std::vector<llvm::NewArchiveMember>::__emplace_back_slow_path<llvm::MemoryBufferRef>(uint64_t *a1, _OWORD *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v6;
  char *v7;
  __int128 v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD v21[2];

  v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  v3 = v2 + 1;
  if (v2 + 1 > 0x555555555555555)
    abort();
  if (0x5555555555555556 * ((a1[2] - *a1) >> 4) > v3)
    v3 = 0x5555555555555556 * ((a1[2] - *a1) >> 4);
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 4) >= 0x2AAAAAAAAAAAAAALL)
    v6 = 0x555555555555555;
  else
    v6 = v3;
  if (v6)
  {
    if (v6 > 0x555555555555555)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v7 = (char *)operator new(48 * v6);
  }
  else
  {
    v7 = 0;
  }
  v8 = a2[1];
  v9 = &v7[48 * v6];
  v21[0] = *a2;
  v21[1] = v8;
  v10 = llvm::NewArchiveMember::NewArchiveMember((uint64_t)&v7[48 * v2], v21);
  v11 = v10 + 48;
  v12 = (char *)*a1;
  v13 = (char *)a1[1];
  if (v13 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v11;
    a1[2] = (uint64_t)v9;
  }
  else
  {
    do
    {
      v14 = *((_QWORD *)v13 - 6);
      v13 -= 48;
      *(_QWORD *)v13 = 0;
      *(_QWORD *)(v10 - 48) = v14;
      v10 -= 48;
      v15 = *(_OWORD *)(v13 + 8);
      v16 = *(_OWORD *)(v13 + 24);
      *(_DWORD *)(v10 + 40) = *((_DWORD *)v13 + 10);
      *(_OWORD *)(v10 + 24) = v16;
      *(_OWORD *)(v10 + 8) = v15;
    }
    while (v13 != v12);
    v13 = (char *)*a1;
    v17 = (char *)a1[1];
    *a1 = v10;
    a1[1] = v11;
    a1[2] = (uint64_t)v9;
    while (v17 != v13)
    {
      v19 = *((_QWORD *)v17 - 6);
      v17 -= 48;
      v18 = v19;
      *(_QWORD *)v17 = 0;
      if (v19)
        (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
    }
  }
  if (v13)
    operator delete(v13);
  return v11;
}

_QWORD **llvm::handleErrors<llvm::consumeError(llvm::Error)::{lambda(llvm::ErrorInfoBase const&)#1}>@<X0>(_QWORD **result@<X0>, uint64_t *a2@<X8>)
{
  _QWORD *v3;
  uint64_t **v4;
  uint64_t **v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v3 = *result;
  if (*result)
  {
    *result = 0;
    if ((*(unsigned int (**)(_QWORD *, void *))(*v3 + 48))(v3, &llvm::ErrorList::ID))
    {
      *a2 = 0;
      v4 = (uint64_t **)v3[1];
      v5 = (uint64_t **)v3[2];
      if (v4 != v5)
      {
        v6 = 0;
        do
        {
          v9 = v6;
          v7 = *v4;
          *v4 = 0;
          if ((*(unsigned int (**)(uint64_t *, void *))(*v7 + 48))(v7, &llvm::ErrorInfoBase::ID))
          {
            (*(void (**)(uint64_t *))(*v7 + 8))(v7);
            v7 = 0;
          }
          v8 = v7;
          llvm::ErrorList::join(&v9, &v8, &v10);
          v6 = v10;
          *a2 = v10;
          v10 = 0;
          if (v8)
            (*(void (**)(uint64_t *))(*v8 + 8))(v8);
          if (v9)
            (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
          ++v4;
        }
        while (v4 != v5);
      }
      return (_QWORD **)(*(uint64_t (**)(_QWORD *))(*v3 + 8))(v3);
    }
    else
    {
      result = (_QWORD **)(*(uint64_t (**)(_QWORD *, void *))(*v3 + 48))(v3, &llvm::ErrorInfoBase::ID);
      if ((_DWORD)result)
      {
        *a2 = 0;
        return (_QWORD **)(*(uint64_t (**)(_QWORD *))(*v3 + 8))(v3);
      }
      else
      {
        *a2 = (uint64_t)v3;
      }
    }
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

uint64_t *llvm::ErrorList::join@<X0>(uint64_t *a1@<X0>, uint64_t **a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t *result;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  char **v13;
  char *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t **v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t *v26;

  result = (uint64_t *)*a1;
  v7 = *a2;
  if (!result)
  {
LABEL_18:
    *a3 = v7;
    *a2 = 0;
    return result;
  }
  if (!v7)
  {
    *a3 = result;
LABEL_33:
    *a1 = 0;
    return result;
  }
  if ((*(unsigned int (**)(uint64_t *, void *))(*result + 48))(result, &llvm::ErrorList::ID))
  {
    v8 = (uint64_t *)*a1;
    result = *a2;
    if (*a2)
    {
      result = (uint64_t *)(*(uint64_t (**)(uint64_t *, void *))(*result + 48))(result, &llvm::ErrorList::ID);
      v9 = *a2;
      if ((_DWORD)result)
      {
        *a2 = 0;
        v10 = (uint64_t *)v9[1];
        v11 = (uint64_t *)v9[2];
        if (v10 == v11)
          goto LABEL_31;
        result = (uint64_t *)v8[2];
        do
        {
          if ((unint64_t)result >= v8[3])
          {
            result = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(v8 + 1, v10);
          }
          else
          {
            v12 = *v10;
            *v10 = 0;
            *result++ = v12;
          }
          v8[2] = (uint64_t)result;
          ++v10;
        }
        while (v10 != v11);
        if (v9)
LABEL_31:
          result = (uint64_t *)(*(uint64_t (**)(uint64_t *))(*v9 + 8))(v9);
LABEL_32:
        *a3 = *a1;
        goto LABEL_33;
      }
    }
    else
    {
      v9 = 0;
    }
    v26 = v9;
    *a2 = 0;
    v20 = (uint64_t **)v8[2];
    if ((unint64_t)v20 >= v8[3])
    {
      v23 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(v8 + 1, (uint64_t *)&v26);
      result = v26;
      v8[2] = (uint64_t)v23;
      v26 = 0;
      if (result)
        result = (uint64_t *)(*(uint64_t (**)(uint64_t *))(*result + 8))(result);
    }
    else
    {
      *v20 = v9;
      v8[2] = (uint64_t)(v20 + 1);
    }
    goto LABEL_32;
  }
  if (*a2 && (*(unsigned int (**)(uint64_t *, void *))(**a2 + 48))(*a2, &llvm::ErrorList::ID))
  {
    v13 = (char **)(*a2 + 1);
    v14 = *v13;
    v26 = (uint64_t *)*a1;
    *a1 = 0;
    std::vector<std::unique_ptr<llvm::ErrorInfoBase>>::insert(v13, (uint64_t)v14, (uint64_t *)&v26);
    result = v26;
    v26 = 0;
    if (result)
      result = (uint64_t *)(*(uint64_t (**)(uint64_t *))(*result + 8))(result);
    v7 = *a2;
    goto LABEL_18;
  }
  v15 = operator new(0x20uLL);
  v16 = *a1;
  *a1 = 0;
  v17 = *a2;
  v24 = *a2;
  v25 = (uint64_t *)v16;
  *a2 = 0;
  *v15 = &unk_1E0E25838;
  v15[1] = 0;
  v15[2] = 0;
  v15[3] = 0;
  v18 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(v15 + 1, (uint64_t *)&v25);
  v19 = v15[3];
  v15[2] = v18;
  if ((unint64_t)v18 >= v19)
  {
    v21 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(v15 + 1, (uint64_t *)&v24);
    v22 = (uint64_t)v24;
    v15[2] = v21;
    *a3 = v15;
    v24 = 0;
    if (v22)
      (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
  }
  else
  {
    *v18 = v17;
    v15[2] = v18 + 1;
    *a3 = v15;
    v24 = 0;
  }
  result = v25;
  v25 = 0;
  if (result)
    return (uint64_t *)(*(uint64_t (**)(uint64_t *))(*result + 8))(result);
  return result;
}

char *std::vector<std::unique_ptr<llvm::ErrorInfoBase>>::insert(char **a1, uint64_t a2, uint64_t *a3)
{
  unint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t *v18;
  char *v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  unint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  _OWORD *v32;
  char *v33;
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  char *v38;
  char *v39;
  char *v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  _OWORD *v47;
  char *v48;
  uint64_t v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  BOOL v59;
  uint64_t v60;
  uint64_t v61;
  _OWORD *v62;
  char *v63;
  uint64_t v64;
  __int128 v65;
  __int128 v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  char *v75;
  unint64_t v76;
  char *v77;
  char *v78;
  _QWORD *v79;

  v6 = *a1;
  v5 = (unint64_t)a1[1];
  v7 = a2 - (_QWORD)*a1;
  v8 = v7 >> 3;
  v9 = &(*a1)[v7 & 0xFFFFFFFFFFFFFFF8];
  v10 = (unint64_t)a1[2];
  if (v5 < v10)
  {
    if (v9 == (char *)v5)
    {
      v24 = *a3;
      *a3 = 0;
      *(_QWORD *)v9 = v24;
      a1[1] = v9 + 8;
      return v9;
    }
    v11 = v5 - (_QWORD)(v9 + 8);
    v12 = v11 >> 3;
    v13 = (uint64_t *)(v5 - 8);
    if (v5 < 8)
    {
      v19 = a1[1];
    }
    else
    {
      v14 = v7 & 0xFFFFFFFFFFFFFFF8;
      v15 = (v7 & 0xFFFFFFFFFFFFFFF8) + v11;
      if (v5 <= (unint64_t)&v6[v15 + 8])
        v16 = (uint64_t)&v6[v15 + 8];
      else
        v16 = (uint64_t)a1[1];
      v17 = v16 + ~(unint64_t)v6 - v15;
      if (v17 >= 0xE8)
      {
        v56 = v11 + v14;
        v57 = (unint64_t)&v6[v14 + v5 - (_QWORD)v9];
        if (v5 > v57)
          v57 = (unint64_t)a1[1];
        v58 = (v57 + ~(unint64_t)v6 - v56) & 0xFFFFFFFFFFFFFFF8;
        v59 = (unint64_t)v13 >= v58 + v5 + 8 || v5 >= (unint64_t)&v6[v56 + 8 + v58];
        v18 = (uint64_t *)(v5 - 8);
        v19 = a1[1];
        if (v59)
        {
          v60 = (v17 >> 3) + 1;
          v61 = v60 & 0x3FFFFFFFFFFFFFFCLL;
          v18 = &v13[v61];
          v19 = (char *)(v5 + v61 * 8);
          v62 = (_OWORD *)(v5 + 16);
          v63 = &v6[8 * v12 + 16 + 8 * v8];
          v64 = v60 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v65 = *((_OWORD *)v63 - 1);
            v66 = *(_OWORD *)v63;
            *((_OWORD *)v63 - 1) = 0uLL;
            *(_OWORD *)v63 = 0uLL;
            *(v62 - 1) = v65;
            *v62 = v66;
            v62 += 2;
            v63 += 32;
            v64 -= 4;
          }
          while (v64);
          if (v60 == (v60 & 0x3FFFFFFFFFFFFFFCLL))
            goto LABEL_61;
        }
      }
      else
      {
        v18 = (uint64_t *)(v5 - 8);
        v19 = a1[1];
      }
      do
      {
        v67 = *v18;
        *v18++ = 0;
        *(_QWORD *)v19 = v67;
        v19 += 8;
      }
      while ((unint64_t)v18 < v5);
    }
LABEL_61:
    a1[1] = v19;
    if ((char *)v5 != v9 + 8)
    {
      v68 = 8 * v12;
      v69 = (uint64_t)&v6[8 * v8 - 8];
      do
      {
        v70 = *(_QWORD *)(v69 + v68);
        *(_QWORD *)(v69 + v68) = 0;
        v71 = *v13;
        *v13 = v70;
        if (v71)
          (*(void (**)(uint64_t))(*(_QWORD *)v71 + 8))(v71);
        --v13;
        v68 -= 8;
      }
      while (v68);
    }
    v72 = *a3;
    *a3 = 0;
    v73 = *(_QWORD *)v9;
    *(_QWORD *)v9 = v72;
    if (v73)
      (*(void (**)(uint64_t))(*(_QWORD *)v73 + 8))(v73);
    return v9;
  }
  v20 = ((uint64_t)(v5 - (_QWORD)v6) >> 3) + 1;
  if (v20 >> 61)
    abort();
  v21 = v10 - (_QWORD)v6;
  if (v21 >> 2 > v20)
    v20 = v21 >> 2;
  if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8)
    v22 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v22 = v20;
  v79 = a1 + 2;
  if (v22)
  {
    if (v22 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v23 = (char *)operator new(8 * v22);
  }
  else
  {
    v23 = 0;
  }
  v75 = v23;
  v76 = (unint64_t)&v23[8 * v8];
  v77 = (char *)v76;
  v78 = &v23[8 * v22];
  std::__split_buffer<std::unique_ptr<llvm::ErrorInfoBase>>::push_back(&v75, a3);
  v25 = v76;
  v26 = *a1;
  v27 = v76;
  if (*a1 != v9)
  {
    v28 = &v6[v7 & 0xFFFFFFFFFFFFFFF8] - v26 - 8;
    v29 = v9;
    v27 = v76;
    if (v28 < 0x88)
      goto LABEL_74;
    if ((unint64_t)&v6[(v7 & 0xFFFFFFFFFFFFFFF8) - (v28 & 0xFFFFFFFFFFFFFFF8) - 8] < v76)
    {
      v29 = v9;
      v27 = v76;
      if (v76 - (v28 & 0xFFFFFFFFFFFFFFF8) - 8 < (unint64_t)v9)
        goto LABEL_74;
    }
    v30 = (v28 >> 3) + 1;
    v31 = 8 * (v30 & 0x3FFFFFFFFFFFFFFCLL);
    v29 = &v9[-v31];
    v27 = v76 - v31;
    v32 = (_OWORD *)(v76 - 16);
    v33 = &v6[8 * v8 - 16];
    v34 = v30 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v36 = *((_OWORD *)v33 - 1);
      v35 = *(_OWORD *)v33;
      *((_OWORD *)v33 - 1) = 0uLL;
      *(_OWORD *)v33 = 0uLL;
      *(v32 - 1) = v36;
      *v32 = v35;
      v32 -= 2;
      v33 -= 32;
      v34 -= 4;
    }
    while (v34);
    if (v30 != (v30 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_74:
      do
      {
        v37 = *((_QWORD *)v29 - 1);
        v29 -= 8;
        *(_QWORD *)v29 = 0;
        *(_QWORD *)(v27 - 8) = v37;
        v27 -= 8;
      }
      while (v29 != v26);
    }
  }
  v76 = v27;
  v38 = a1[1];
  v39 = v77;
  if (v38 != v9)
  {
    v40 = &v6[v7 & 0xFFFFFFFFFFFFFFF8];
    v41 = v38 - v40 - 8;
    if (v41 < 0x88)
      goto LABEL_38;
    v42 = (unint64_t)&v40[(v41 & 0xFFFFFFFFFFFFFFF8) + 8];
    if (v9 < &v77[(v41 & 0xFFFFFFFFFFFFFFF8) + 8] && (unint64_t)v77 < v42)
      goto LABEL_38;
    v44 = (v41 >> 3) + 1;
    v45 = 8 * (v44 & 0x3FFFFFFFFFFFFFFCLL);
    v9 += v45;
    v46 = &v77[v45];
    v47 = v77 + 16;
    v48 = &v6[8 * v8 + 16];
    v49 = v44 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v50 = *((_OWORD *)v48 - 1);
      v51 = *(_OWORD *)v48;
      *((_OWORD *)v48 - 1) = 0uLL;
      *(_OWORD *)v48 = 0uLL;
      *(v47 - 1) = v50;
      *v47 = v51;
      v47 += 2;
      v48 += 32;
      v49 -= 4;
    }
    while (v49);
    v39 = v46;
    if (v44 != (v44 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_38:
      v46 = v39;
      do
      {
        v52 = *(_QWORD *)v9;
        *(_QWORD *)v9 = 0;
        v9 += 8;
        *(_QWORD *)v46 = v52;
        v46 += 8;
      }
      while (v9 != v38);
    }
    v27 = v76;
    v9 = a1[1];
    v39 = v46;
  }
  v53 = *a1;
  *a1 = (char *)v27;
  a1[1] = v39;
  v54 = a1[2];
  a1[2] = v78;
  v77 = v9;
  v78 = v54;
  v75 = v53;
  v76 = (unint64_t)v53;
  if (v9 == v53)
  {
    if (!v9)
      return (char *)v25;
    goto LABEL_48;
  }
  do
  {
    v77 = v9 - 8;
    v55 = *((_QWORD *)v9 - 1);
    *((_QWORD *)v9 - 1) = 0;
    if (v55)
      (*(void (**)(uint64_t))(*(_QWORD *)v55 + 8))(v55);
    v9 = v77;
  }
  while (v77 != v53);
  v9 = v75;
  if (v75)
LABEL_48:
    operator delete(v9);
  return (char *)v25;
}

void std::__split_buffer<std::unique_ptr<llvm::ErrorInfoBase>>::push_back(char **a1, uint64_t *a2)
{
  char *v4;
  char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  int64_t v19;
  char *v20;
  unint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  unint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  __int128 *v31;
  char *v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  char *v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;

  v4 = a1[2];
  if (v4 != a1[3])
    goto LABEL_23;
  v5 = *a1;
  v6 = a1[1];
  if (v6 > *a1)
  {
    v7 = (v6 - *a1) >> 3;
    if (v7 >= -1)
      v8 = v7 + 1;
    else
      v8 = v7 + 2;
    v9 = v8 >> 1;
    v10 = -v9;
    if (v6 == v4)
    {
      v23 = &v6[-8 * v9];
    }
    else
    {
      do
      {
        v11 = *(_QWORD *)v6;
        *(_QWORD *)v6 = 0;
        v12 = *(_QWORD *)&v6[8 * v10];
        *(_QWORD *)&v6[8 * v10] = v11;
        if (v12)
          (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
        v6 += 8;
      }
      while (v6 != v4);
      v4 = a1[1];
      v23 = &v6[8 * v10];
    }
    a1[1] = &v4[8 * v10];
    a1[2] = v23;
    goto LABEL_23;
  }
  v13 = (v4 - v5) >> 2;
  if (v4 == v5)
    v13 = 1;
  if (v13 >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  v14 = v13 >> 2;
  v15 = 8 * v13;
  v16 = (char *)operator new(8 * v13);
  v17 = &v16[8 * v14];
  v18 = &v16[v15];
  v19 = v4 - v6;
  if (v4 == v6)
  {
    *a1 = v16;
    a1[1] = v17;
    a1[2] = v17;
    a1[3] = v18;
    goto LABEL_21;
  }
  v20 = &v17[v19 & 0xFFFFFFFFFFFFFFF8];
  v21 = v19 - 8;
  if ((unint64_t)(v19 - 8) < 0x78)
  {
    v22 = &v16[8 * v14];
    do
    {
LABEL_32:
      v36 = *(_QWORD *)v6;
      *(_QWORD *)v6 = 0;
      v6 += 8;
      *(_QWORD *)v22 = v36;
      v22 += 8;
    }
    while (v22 != v20);
    goto LABEL_33;
  }
  v26 = v19 & 0xFFFFFFFFFFFFFFF8;
  v27 = v6 >= &v16[8 * v14 + v26] || v17 >= &v6[v26];
  v22 = &v16[8 * v14];
  if (!v27)
    goto LABEL_32;
  v28 = (v21 >> 3) + 1;
  v29 = 8 * (v28 & 0x3FFFFFFFFFFFFFFCLL);
  v22 = &v17[v29];
  v30 = &v6[v29];
  v31 = (__int128 *)(v6 + 16);
  v32 = &v16[8 * v14 + 16];
  v33 = v28 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v34 = *(v31 - 1);
    v35 = *v31;
    *(v31 - 1) = 0uLL;
    *v31 = 0uLL;
    *((_OWORD *)v32 - 1) = v34;
    *(_OWORD *)v32 = v35;
    v31 += 2;
    v32 += 32;
    v33 -= 4;
  }
  while (v33);
  v6 = v30;
  if (v28 != (v28 & 0x3FFFFFFFFFFFFFFCLL))
    goto LABEL_32;
LABEL_33:
  v5 = *a1;
  v37 = a1[1];
  v38 = a1[2];
  *a1 = v16;
  a1[1] = v17;
  a1[2] = v20;
  a1[3] = v18;
  while (v38 != v37)
  {
    v40 = *((_QWORD *)v38 - 1);
    v38 -= 8;
    v39 = v40;
    *(_QWORD *)v38 = 0;
    if (v40)
      (*(void (**)(uint64_t))(*(_QWORD *)v39 + 8))(v39);
  }
LABEL_21:
  if (v5)
    operator delete(v5);
LABEL_23:
  v24 = a1[2];
  v25 = *a2;
  *a2 = 0;
  *(_QWORD *)v24 = v25;
  a1[2] += 8;
}

uint64_t mlir::mps::createLoweringPass@<X0>(_BYTE *a1@<X0>, _QWORD *a2@<X8>)
{
  _BYTE *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  char v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;

  v4 = operator new(0x498uLL);
  *(_QWORD *)v5 = off_1E0E48AA8;
  *(_BYTE *)(v5 + 472) = *a1;
  v6 = *(_QWORD *)(v5 + 528);
  if (!v6)
    goto LABEL_6;
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v6 + 48))(v6, a1);
  v4[680] = a1[1];
  v7 = *((_QWORD *)v4 + 92);
  if (!v7)
    goto LABEL_6;
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v7 + 48))(v7, a1 + 1);
  v4[888] = a1[2];
  v8 = *((_QWORD *)v4 + 118);
  if (!v8)
    goto LABEL_6;
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v8 + 48))(v8, a1 + 2);
  v10 = a1[3];
  v9 = a1 + 3;
  v4[1096] = v10;
  v11 = *((_QWORD *)v4 + 144);
  if (v11)
  {
    result = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)v11 + 48))(v11, v9);
    *a2 = v4;
  }
  else
  {
LABEL_6:
    v13 = std::__throw_bad_function_call[abi:nn180100]();
  }
  return result;
}

uint64_t mlir::mps::MPSLoweringBase<mlir::mps::`anonymous namespace'::LoweringPass>::MPSLoweringBase(uint64_t a1)
{
  _QWORD *v2;
  char v4;
  char *v5;
  __n128 v6;

  *(_QWORD *)(a1 + 16) = "func.func";
  *(_QWORD *)(a1 + 24) = 9;
  *(_BYTE *)(a1 + 32) = 1;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  v2 = (_QWORD *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = a1 + 200;
  *(_QWORD *)(a1 + 192) = 0x400000000;
  *(_QWORD *)(a1 + 232) = a1 + 248;
  *(_QWORD *)(a1 + 240) = 0x400000000;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0x1000000000;
  *(_QWORD *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_QWORD *)a1 = off_1E0E4B7E8;
  v6.n128_u64[0] = (unint64_t)"MPS Runtime supports Convolution Kernels with int8 inputs";
  v6.n128_u64[1] = 57;
  v4 = 0;
  v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 344), (_QWORD *)(a1 + 152), (uint64_t)"native-int8-conv", 16, &v6, &v5);
  *(_QWORD *)(a1 + 344) = &off_1E0E4C320;
  *(_QWORD *)(a1 + 536) = &unk_1E0E4C3A0;
  v6.n128_u64[0] = (unint64_t)"MPS Runtime supports GEMM Kernels with int8 inputs";
  v6.n128_u64[1] = 50;
  v4 = 0;
  v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 552), v2, (uint64_t)"native-int8-gemm", 16, &v6, &v5);
  *(_QWORD *)(a1 + 552) = &off_1E0E4C320;
  *(_QWORD *)(a1 + 744) = &unk_1E0E4C3A0;
  v6.n128_u64[0] = (unint64_t)"MPS Runtime supports Convolution Kernels with int8 + zeroPoint inputs";
  v6.n128_u64[1] = 69;
  v4 = 0;
  v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 760), v2, (uint64_t)"native-int8-conv-zp", 19, &v6, &v5);
  *(_QWORD *)(a1 + 760) = &off_1E0E4C320;
  *(_QWORD *)(a1 + 952) = &unk_1E0E4C3A0;
  v6.n128_u64[0] = (unint64_t)"MPS Runtime supports GEMM Kernels with int8 + zeroPoint inputs";
  v6.n128_u64[1] = 62;
  v4 = 0;
  v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 968), v2, (uint64_t)"native-int8-gemm-zp", 19, &v6, &v5);
  *(_QWORD *)(a1 + 968) = &off_1E0E4C320;
  *(_QWORD *)(a1 + 1160) = &unk_1E0E4C3A0;
  return a1;
}

void mlir::mps::`anonymous namespace'::LoweringPass::~LoweringPass(mlir::mps::_anonymous_namespace_::LoweringPass *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;
  mlir::mps::_anonymous_namespace_::LoweringPass *v7;
  uint64_t v8;
  void *v9;
  char *v10;
  mlir::mps::_anonymous_namespace_::LoweringPass *v11;
  uint64_t v12;
  void *v13;
  char *v14;
  mlir::mps::_anonymous_namespace_::LoweringPass *v15;
  uint64_t v16;
  void *v17;
  char *v18;

  *(_QWORD *)this = off_1E0E4B7E8;
  *((_QWORD *)this + 121) = &unk_1E0E23520;
  v2 = (char *)this + 1128;
  v3 = (char *)*((_QWORD *)this + 144);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)this + 121) = &unk_1E0E23930;
  v5 = (void *)*((_QWORD *)this + 133);
  if (v5 != *((void **)this + 132))
    free(v5);
  v6 = (char *)*((_QWORD *)this + 129);
  if (v6 != (char *)this + 1048)
    free(v6);
  *((_QWORD *)this + 95) = &unk_1E0E23520;
  v7 = (mlir::mps::_anonymous_namespace_::LoweringPass *)*((_QWORD *)this + 118);
  if (v7 == (mlir::mps::_anonymous_namespace_::LoweringPass *)((char *)this + 920))
  {
    v8 = 4;
    v7 = (mlir::mps::_anonymous_namespace_::LoweringPass *)((char *)this + 920);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_15:
  *((_QWORD *)this + 95) = &unk_1E0E23930;
  v9 = (void *)*((_QWORD *)this + 107);
  if (v9 != *((void **)this + 106))
    free(v9);
  v10 = (char *)*((_QWORD *)this + 103);
  if (v10 != (char *)this + 840)
    free(v10);
  *((_QWORD *)this + 69) = &unk_1E0E23520;
  v11 = (mlir::mps::_anonymous_namespace_::LoweringPass *)*((_QWORD *)this + 92);
  if (v11 == (mlir::mps::_anonymous_namespace_::LoweringPass *)((char *)this + 712))
  {
    v12 = 4;
    v11 = (mlir::mps::_anonymous_namespace_::LoweringPass *)((char *)this + 712);
  }
  else
  {
    if (!v11)
      goto LABEL_24;
    v12 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v11 + 8 * v12))();
LABEL_24:
  *((_QWORD *)this + 69) = &unk_1E0E23930;
  v13 = (void *)*((_QWORD *)this + 81);
  if (v13 != *((void **)this + 80))
    free(v13);
  v14 = (char *)*((_QWORD *)this + 77);
  if (v14 != (char *)this + 632)
    free(v14);
  *((_QWORD *)this + 43) = &unk_1E0E23520;
  v15 = (mlir::mps::_anonymous_namespace_::LoweringPass *)*((_QWORD *)this + 66);
  if (v15 == (mlir::mps::_anonymous_namespace_::LoweringPass *)((char *)this + 504))
  {
    v16 = 4;
    v15 = (mlir::mps::_anonymous_namespace_::LoweringPass *)((char *)this + 504);
  }
  else
  {
    if (!v15)
      goto LABEL_33;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_33:
  *((_QWORD *)this + 43) = &unk_1E0E23930;
  v17 = (void *)*((_QWORD *)this + 55);
  if (v17 != *((void **)this + 54))
    free(v17);
  v18 = (char *)*((_QWORD *)this + 51);
  if (v18 != (char *)this + 424)
    free(v18);
  mlir::Pass::~Pass(this);
}

{
  void *v1;

  operator delete(v1);
}

const char *mlir::mps::MPSLoweringBase<mlir::mps::`anonymous namespace'::LoweringPass>::getName()
{
  return "MPSLowering";
}

_QWORD *mlir::mps::MPSLoweringBase<mlir::mps::`anonymous namespace'::LoweringPass>::getDependentDialects(int a1, uint64_t **a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *result;
  uint64_t v10;
  _QWORD v11[3];
  _QWORD *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v11[0] = off_1E0E50870;
  v12 = v11;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::mps::MPSDialect,void>::id, "mps", 3uLL, v11);
  v3 = v12;
  if (v12 == v11)
  {
    v4 = 4;
    v3 = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  v11[0] = off_1E0E50990;
  v12 = v11;
  v5 = 4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::mpsx::MPSXDialect,void>::id, "mpsx", 4uLL, v11);
  v6 = v12;
  if (v12 == v11)
  {
    v6 = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_11;
    v5 = 5;
  }
  (*(void (**)(void))(*v6 + 8 * v5))();
LABEL_11:
  v11[0] = off_1E0DFB820;
  v12 = v11;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::arith::ArithDialect,void>::id, "arith", 5uLL, v11);
  v7 = v12;
  if (v12 == v11)
  {
    v8 = 4;
    v7 = v11;
  }
  else
  {
    if (!v12)
      goto LABEL_16;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_16:
  v11[0] = off_1E0E50A20;
  v12 = v11;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::tensor::TensorDialect,void>::id, "tensor", 6uLL, v11);
  result = v12;
  if (v12 == v11)
  {
    v10 = 4;
    result = v11;
  }
  else
  {
    if (!v12)
      return result;
    v10 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v10))();
}

const char *mlir::mps::MPSLoweringBase<mlir::mps::`anonymous namespace'::LoweringPass>::getArgument()
{
  return "mps-lowering";
}

const char *mlir::mps::MPSLoweringBase<mlir::mps::`anonymous namespace'::LoweringPass>::getDescription()
{
  return "Lower high-level MPS ops to lower-level MPS ops.";
}

void mlir::mps::`anonymous namespace'::LoweringPass::runOnOperation(mlir::mps::_anonymous_namespace_::LoweringPass *this)
{
}

_QWORD *mlir::mps::MPSLoweringBase<mlir::mps::`anonymous namespace'::LoweringPass>::clonePass@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _OWORD *v4;
  uint64_t v5;
  _QWORD *result;
  char v7;
  char *v8;
  __n128 v9;

  v4 = operator new(0x498uLL);
  v5 = *(_QWORD *)(a1 + 8);
  v4[1] = *(_OWORD *)(a1 + 16);
  *((_QWORD *)v4 + 4) = *(_QWORD *)(a1 + 32);
  *((_BYTE *)v4 + 40) = 0;
  *((_BYTE *)v4 + 120) = 0;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  *((_QWORD *)v4 + 22) = 0;
  *((_QWORD *)v4 + 23) = (char *)v4 + 200;
  *((_QWORD *)v4 + 24) = 0x400000000;
  *((_QWORD *)v4 + 29) = (char *)v4 + 248;
  *((_QWORD *)v4 + 30) = 0x400000000;
  *((_QWORD *)v4 + 35) = 0;
  *((_QWORD *)v4 + 36) = 0;
  *((_DWORD *)v4 + 74) = 0;
  *((_DWORD *)v4 + 75) = 16;
  v4[19] = 0u;
  v4[20] = 0u;
  *((_QWORD *)v4 + 42) = 0;
  *(_QWORD *)v4 = off_1E0E4B7E8;
  *((_QWORD *)v4 + 1) = v5;
  v9.n128_u64[0] = (unint64_t)"MPS Runtime supports Convolution Kernels with int8 inputs";
  v9.n128_u64[1] = 57;
  v7 = 0;
  v8 = &v7;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)v4 + 43, (_QWORD *)v4 + 19, (uint64_t)"native-int8-conv", 16, &v9, &v8);
  *((_QWORD *)v4 + 43) = &off_1E0E4C320;
  *((_QWORD *)v4 + 67) = &unk_1E0E4C3A0;
  v9.n128_u64[0] = (unint64_t)"MPS Runtime supports GEMM Kernels with int8 inputs";
  v9.n128_u64[1] = 50;
  v7 = 0;
  v8 = &v7;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)v4 + 69, (_QWORD *)v4 + 19, (uint64_t)"native-int8-gemm", 16, &v9, &v8);
  *((_QWORD *)v4 + 69) = &off_1E0E4C320;
  *((_QWORD *)v4 + 93) = &unk_1E0E4C3A0;
  v9.n128_u64[0] = (unint64_t)"MPS Runtime supports Convolution Kernels with int8 + zeroPoint inputs";
  v9.n128_u64[1] = 69;
  v7 = 0;
  v8 = &v7;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)v4 + 95, (_QWORD *)v4 + 19, (uint64_t)"native-int8-conv-zp", 19, &v9, &v8);
  *((_QWORD *)v4 + 95) = &off_1E0E4C320;
  *((_QWORD *)v4 + 119) = &unk_1E0E4C3A0;
  v9.n128_u64[0] = (unint64_t)"MPS Runtime supports GEMM Kernels with int8 + zeroPoint inputs";
  v9.n128_u64[1] = 62;
  v7 = 0;
  v8 = &v7;
  result = mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)v4 + 121, (_QWORD *)v4 + 19, (uint64_t)"native-int8-gemm-zp", 19, &v9, &v8);
  *((_QWORD *)v4 + 121) = &off_1E0E4C320;
  *((_QWORD *)v4 + 145) = &unk_1E0E4C3A0;
  *(_QWORD *)v4 = off_1E0E48AA8;
  *a2 = v4;
  return result;
}

_QWORD *std::__function::__func<void mlir::DialectRegistry::insert<mlir::arith::ArithDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::arith::ArithDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = off_1E0DFB820;
  return result;
}

void std::__function::__func<void mlir::DialectRegistry::insert<mlir::arith::ArithDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::arith::ArithDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = off_1E0DFB820;
}

mlir::Dialect *std::__function::__func<void mlir::DialectRegistry::insert<mlir::arith::ArithDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::arith::ArithDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::operator()(uint64_t a1, _QWORD **a2)
{
  uint64_t v3;

  return mlir::MLIRContext::getOrLoadDialect(*a2, (uint64_t)"arith", 5, (uint64_t)&mlir::detail::TypeIDResolver<mlir::arith::ArithDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::arith::ArithDialect * mlir::MLIRContext::getOrLoadDialect<mlir::arith::ArithDialect>(void)::{lambda(void)#1}>, (uint64_t)&v3);
}

void mlir::mps::`anonymous namespace'::LoweringPass::lower(mlir::mps::_anonymous_namespace_::LoweringPass *this, mlir::Operation *a2)
{
  mlir::MLIRContext *Context;
  uint64_t (**v5)();
  uint64_t (***v6)();
  uint64_t v7;
  uint64_t (**v8)();
  uint64_t (***v9)();
  uint64_t v10;
  uint64_t (**v11)();
  uint64_t (***v12)();
  uint64_t v13;
  uint64_t (***v14)();
  uint64_t v15;
  uint64_t (***v16)();
  uint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t v20;
  const char *v21;
  unint64_t v22;
  uint64_t v23;
  const char *v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  void *v28;
  char *v29;
  int64_t v30;
  int64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  char *v35;
  char *v36;
  char *v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  char *v43;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  unint64_t v52;
  unint64_t v53;
  const char *v54;
  unint64_t v55;
  uint64_t v56;
  const char *v57;
  unint64_t v58;
  unint64_t v59;
  char *v60;
  void *v61;
  char *v62;
  int64_t v63;
  int64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  char *v74;
  char *v75;
  char *v76;
  uint64_t v77;
  __int128 v78;
  __int128 v79;
  uint64_t v80;
  char *v81;
  uint64_t v82;
  uint64_t v83;
  _QWORD *v84;
  unint64_t v85;
  unint64_t v86;
  const char *v87;
  unint64_t v88;
  uint64_t v89;
  const char *v90;
  unint64_t v91;
  unint64_t v92;
  char *v93;
  void *v94;
  char *v95;
  int64_t v96;
  int64_t v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  char *v101;
  char *v102;
  char *v103;
  unint64_t v104;
  uint64_t v105;
  uint64_t v106;
  char *v107;
  char *v108;
  char *v109;
  uint64_t v110;
  __int128 v111;
  __int128 v112;
  uint64_t v113;
  char *v114;
  uint64_t v115;
  uint64_t v116;
  _QWORD *v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  const char *v123;
  unint64_t v124;
  unint64_t v125;
  char *v126;
  void *v127;
  char *v128;
  int64_t v129;
  int64_t v130;
  unint64_t v131;
  uint64_t v132;
  unint64_t v133;
  char *v134;
  char *v135;
  char *v136;
  unint64_t v137;
  uint64_t v138;
  uint64_t v139;
  char *v140;
  char *v141;
  char *v142;
  uint64_t v143;
  __int128 v144;
  __int128 v145;
  uint64_t v146;
  char *v147;
  uint64_t v148;
  uint64_t v149;
  _QWORD *v150;
  unint64_t v151;
  unint64_t v152;
  const char *v153;
  unint64_t v154;
  uint64_t v155;
  const char *v156;
  unint64_t v157;
  unint64_t v158;
  char *v159;
  void *v160;
  char *v161;
  int64_t v162;
  int64_t v163;
  unint64_t v164;
  uint64_t v165;
  unint64_t v166;
  char *v167;
  char *v168;
  char *v169;
  unint64_t v170;
  uint64_t v171;
  uint64_t v172;
  char *v173;
  char *v174;
  char *v175;
  uint64_t v176;
  __int128 v177;
  __int128 v178;
  uint64_t v179;
  char *v180;
  uint64_t v181;
  uint64_t v182;
  _QWORD *v183;
  unint64_t v184;
  unint64_t v185;
  const char *v186;
  unint64_t v187;
  uint64_t v188;
  const char *v189;
  unint64_t v190;
  unint64_t v191;
  char *v192;
  void *v193;
  char *v194;
  int64_t v195;
  int64_t v196;
  unint64_t v197;
  uint64_t v198;
  unint64_t v199;
  char *v200;
  char *v201;
  char *v202;
  unint64_t v203;
  uint64_t v204;
  uint64_t v205;
  char *v206;
  char *v207;
  char *v208;
  uint64_t v209;
  __int128 v210;
  __int128 v211;
  uint64_t v212;
  char *v213;
  uint64_t v214;
  uint64_t v215;
  _QWORD *v216;
  unint64_t v217;
  unint64_t v218;
  const char *v219;
  unint64_t v220;
  uint64_t v221;
  const char *v222;
  unint64_t v223;
  unint64_t v224;
  char *v225;
  void *v226;
  char *v227;
  int64_t v228;
  int64_t v229;
  unint64_t v230;
  uint64_t v231;
  unint64_t v232;
  char *v233;
  char *v234;
  char *v235;
  unint64_t v236;
  uint64_t v237;
  uint64_t v238;
  char *v239;
  char *v240;
  char *v241;
  uint64_t v242;
  __int128 v243;
  __int128 v244;
  uint64_t v245;
  char *v246;
  uint64_t v247;
  uint64_t v248;
  _QWORD *v249;
  unint64_t v250;
  unint64_t v251;
  const char *v252;
  unint64_t v253;
  uint64_t v254;
  const char *v255;
  unint64_t v256;
  unint64_t v257;
  char *v258;
  void *v259;
  char *v260;
  int64_t v261;
  int64_t v262;
  unint64_t v263;
  uint64_t v264;
  unint64_t v265;
  char *v266;
  char *v267;
  char *v268;
  unint64_t v269;
  uint64_t v270;
  uint64_t v271;
  char *v272;
  char *v273;
  char *v274;
  uint64_t v275;
  __int128 v276;
  __int128 v277;
  uint64_t v278;
  char *v279;
  uint64_t v280;
  uint64_t v281;
  _QWORD *v282;
  unint64_t v283;
  unint64_t v284;
  const char *v285;
  unint64_t v286;
  uint64_t v287;
  const char *v288;
  unint64_t v289;
  unint64_t v290;
  char *v291;
  void *v292;
  char *v293;
  int64_t v294;
  int64_t v295;
  unint64_t v296;
  uint64_t v297;
  unint64_t v298;
  char *v299;
  char *v300;
  char *v301;
  unint64_t v302;
  uint64_t v303;
  uint64_t v304;
  char *v305;
  char *v306;
  char *v307;
  uint64_t v308;
  __int128 v309;
  __int128 v310;
  uint64_t v311;
  char *v312;
  uint64_t v313;
  uint64_t v314;
  _QWORD *v315;
  unint64_t v316;
  unint64_t v317;
  const char *v318;
  unint64_t v319;
  uint64_t v320;
  const char *v321;
  unint64_t v322;
  unint64_t v323;
  char *v324;
  void *v325;
  char *v326;
  int64_t v327;
  int64_t v328;
  unint64_t v329;
  uint64_t v330;
  unint64_t v331;
  char *v332;
  char *v333;
  char *v334;
  unint64_t v335;
  uint64_t v336;
  uint64_t v337;
  char *v338;
  char *v339;
  char *v340;
  uint64_t v341;
  __int128 v342;
  __int128 v343;
  uint64_t v344;
  char *v345;
  uint64_t v346;
  uint64_t v347;
  _QWORD *v348;
  unint64_t v349;
  unint64_t v350;
  const char *v351;
  unint64_t v352;
  uint64_t v353;
  const char *v354;
  unint64_t v355;
  unint64_t v356;
  char *v357;
  void *v358;
  char *v359;
  int64_t v360;
  int64_t v361;
  unint64_t v362;
  uint64_t v363;
  unint64_t v364;
  char *v365;
  char *v366;
  char *v367;
  unint64_t v368;
  uint64_t v369;
  uint64_t v370;
  char *v371;
  char *v372;
  char *v373;
  uint64_t v374;
  __int128 v375;
  __int128 v376;
  uint64_t v377;
  char *v378;
  uint64_t v379;
  uint64_t v380;
  _QWORD *v381;
  unint64_t v382;
  unint64_t v383;
  const char *v384;
  unint64_t v385;
  uint64_t v386;
  const char *v387;
  unint64_t v388;
  unint64_t v389;
  char *v390;
  void *v391;
  char *v392;
  int64_t v393;
  int64_t v394;
  unint64_t v395;
  uint64_t v396;
  unint64_t v397;
  char *v398;
  char *v399;
  char *v400;
  unint64_t v401;
  uint64_t v402;
  uint64_t v403;
  char *v404;
  char *v405;
  char *v406;
  uint64_t v407;
  __int128 v408;
  __int128 v409;
  uint64_t v410;
  char *v411;
  uint64_t v412;
  uint64_t v413;
  _QWORD *v414;
  unint64_t v415;
  unint64_t v416;
  const char *v417;
  unint64_t v418;
  uint64_t v419;
  const char *v420;
  unint64_t v421;
  unint64_t v422;
  char *v423;
  void *v424;
  char *v425;
  int64_t v426;
  int64_t v427;
  unint64_t v428;
  uint64_t v429;
  unint64_t v430;
  char *v431;
  char *v432;
  char *v433;
  unint64_t v434;
  uint64_t v435;
  uint64_t v436;
  char *v437;
  char *v438;
  char *v439;
  uint64_t v440;
  __int128 v441;
  __int128 v442;
  uint64_t v443;
  char *v444;
  uint64_t v445;
  uint64_t v446;
  _QWORD *v447;
  unint64_t v448;
  unint64_t v449;
  const char *v450;
  unint64_t v451;
  uint64_t v452;
  const char *v453;
  unint64_t v454;
  unint64_t v455;
  char *v456;
  void *v457;
  char *v458;
  int64_t v459;
  int64_t v460;
  unint64_t v461;
  uint64_t v462;
  unint64_t v463;
  char *v464;
  char *v465;
  char *v466;
  unint64_t v467;
  uint64_t v468;
  uint64_t v469;
  char *v470;
  char *v471;
  char *v472;
  uint64_t v473;
  __int128 v474;
  __int128 v475;
  uint64_t v476;
  char *v477;
  uint64_t v478;
  uint64_t v479;
  _QWORD *v480;
  unint64_t v481;
  unint64_t v482;
  const char *v483;
  unint64_t v484;
  uint64_t v485;
  const char *v486;
  unint64_t v487;
  unint64_t v488;
  char *v489;
  void *v490;
  char *v491;
  int64_t v492;
  int64_t v493;
  unint64_t v494;
  uint64_t v495;
  unint64_t v496;
  char *v497;
  char *v498;
  char *v499;
  unint64_t v500;
  uint64_t v501;
  uint64_t v502;
  char *v503;
  char *v504;
  char *v505;
  uint64_t v506;
  __int128 v507;
  __int128 v508;
  uint64_t v509;
  char *v510;
  uint64_t v511;
  uint64_t v512;
  const mlir::FrozenRewritePatternSet *v513;
  _BYTE v514[4];
  const char *v515;
  unint64_t v516;
  uint64_t (**v517)();
  void *__p[2];
  __int128 v519;
  _QWORD *v520;
  uint64_t v521;
  _QWORD v522[8];
  int v523;
  uint64_t v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  uint64_t v528;
  uint64_t v529;
  uint64_t (**v530)();
  _BYTE *v531;
  uint64_t v532;
  _QWORD v533[16];
  __int128 v534;
  _BYTE v535[64];
  __int128 v536;
  _BYTE v537[64];
  __int128 v538;
  _BYTE v539[64];
  __int128 v540;
  _BYTE v541[64];
  uint64_t v542;
  uint64_t v543;
  uint64_t v544;
  uint64_t v545;
  __int128 v546;
  __int128 v547;
  _BYTE v548[152];
  uint64_t v549;
  uint64_t v550;

  v550 = *MEMORY[0x1E0C80C00];
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Operation *)((char *)a2 + 24));
  mlir::mps::MPSConversionTarget::MPSConversionTarget((mlir::mps::MPSConversionTarget *)v548, Context);
  v514[0] = *((_BYTE *)this + 472);
  v514[1] = *((_BYTE *)this + 680);
  v514[2] = *((_BYTE *)this + 888);
  v514[3] = *((_BYTE *)this + 1096);
  mlir::OperationName::OperationName(&v530, "mps.bias_add_grad", 17, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.bias_add", 12, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.degamma", 11, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mpsx.deinterleave", 17, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.dequantize", 14, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.dirac", 9, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.elu", 7, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.floor_divide", 16, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.gelu", 8, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.instance_norm", 17, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mpsx.interleave", 15, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.lp_norm", 11, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.leaky_relu", 14, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.normalization", 17, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.non_zero", 12, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.prelu", 9, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.quantize", 12, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.reduction_logsumexp", 23, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.reduction_mean", 18, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.reduction_variance", 22, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.relu6", 9, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.relu_grad", 13, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.relu", 8, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.n_relu", 10, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.sigmoid_gradient", 20, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.sigmoid_gradient_with_sigmoid", 33, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.sigmoid_hard", 16, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.sigmoid", 11, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.softplus", 12, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.softplus_parametric", 23, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.softsign", 12, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.swish", 9, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  mlir::OperationName::OperationName(&v530, "mps.truncate", 12, v549);
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v530, 2);
  v530 = off_1E0E50DD8;
  LOBYTE(v531) = 0;
  v533[0] = &v530;
  mlir::OperationName::OperationName(&v517, "mpsx.quantized_matmul", 21, v549);
  v5 = v517;
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v517, 1);
  mlir::ConversionTarget::setLegalityCallback((uint64_t)v548, (uint64_t)v5, &v530);
  v6 = (uint64_t (***)())v533[0];
  if ((uint64_t (***)())v533[0] == &v530)
  {
    v7 = 4;
    v6 = &v530;
  }
  else
  {
    if (!v533[0])
      goto LABEL_6;
    v7 = 5;
  }
  (*v6)[v7]();
LABEL_6:
  v530 = off_1E0E50B98;
  LOBYTE(v531) = 0;
  v533[0] = &v530;
  mlir::OperationName::OperationName(&v517, "mps.softmax", 11, v549);
  v8 = v517;
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v517, 1);
  mlir::ConversionTarget::setLegalityCallback((uint64_t)v548, (uint64_t)v8, &v530);
  v9 = (uint64_t (***)())v533[0];
  if ((uint64_t (***)())v533[0] == &v530)
  {
    v10 = 4;
    v9 = &v530;
  }
  else
  {
    if (!v533[0])
      goto LABEL_11;
    v10 = 5;
  }
  (*v9)[v10]();
LABEL_11:
  v530 = off_1E0E50B50;
  v531 = v514;
  v533[0] = &v530;
  mlir::OperationName::OperationName(&v517, "mps.dequantize", 14, v549);
  v11 = v517;
  mlir::ConversionTarget::setOpAction((uint64_t)v548, (uint64_t)v517, 1);
  mlir::ConversionTarget::setLegalityCallback((uint64_t)v548, (uint64_t)v11, &v530);
  v12 = (uint64_t (***)())v533[0];
  if ((uint64_t (***)())v533[0] == &v530)
  {
    v13 = 4;
    v12 = &v530;
  }
  else
  {
    if (!v533[0])
      goto LABEL_16;
    v13 = 5;
  }
  (*v12)[v13]();
LABEL_16:
  v546 = 0u;
  v547 = 0u;
  v544 = 0;
  memset(v541, 0, sizeof(v541));
  v540 = 0u;
  v538 = 0u;
  memset(v539, 0, sizeof(v539));
  memset(v537, 0, sizeof(v537));
  v536 = 0u;
  memset(v535, 0, sizeof(v535));
  v534 = 0u;
  memset(v533, 0, sizeof(v533));
  v530 = (uint64_t (**)())off_1E0E2B630;
  v531 = v533;
  v532 = 0x400000000;
  *(_QWORD *)&v534 = v535;
  *(_QWORD *)&v536 = v537;
  HIDWORD(v534) = 2;
  HIDWORD(v536) = 2;
  *(_QWORD *)&v538 = v539;
  HIDWORD(v538) = 2;
  *(_QWORD *)&v540 = v541;
  HIDWORD(v540) = 2;
  v542 = 0;
  v543 = 0;
  v545 = 0;
  *(_QWORD *)&v546 = 0;
  DWORD2(v546) = 0;
  llvm::sys::RWMutexImpl::RWMutexImpl((llvm::sys::RWMutexImpl *)&v547);
  *((_QWORD *)&v547 + 1) = 0;
  v530 = (uint64_t (**)())off_1E0E4A220;
  v517 = off_1E0E51B98;
  __p[0] = &v530;
  *(_QWORD *)&v519 = &v517;
  mlir::TypeConverter::registerConversion((unsigned int *)&v530, (uint64_t)&v517);
  v14 = (uint64_t (***)())v519;
  if ((uint64_t (***)())v519 == &v517)
  {
    v15 = 4;
    v14 = &v517;
  }
  else
  {
    if (!(_QWORD)v519)
      goto LABEL_21;
    v15 = 5;
  }
  (*v14)[v15]();
LABEL_21:
  v517 = &off_1E0E51BE0;
  *(_QWORD *)&v519 = &v517;
  if (DWORD2(v536) >= HIDWORD(v536))
  {
    llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>,false>::growAndEmplaceBack<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>((uint64_t)&v536, (uint64_t)&v517);
  }
  else
  {
    *(_QWORD *)(v536 + 32 * DWORD2(v536) + 24) = v536 + 32 * DWORD2(v536);
    (*(void (**)(_QWORD))(*(_QWORD *)v519 + 24))(v519);
    ++DWORD2(v536);
  }
  v16 = (uint64_t (***)())v519;
  if ((uint64_t (***)())v519 == &v517)
  {
    v17 = 4;
    v16 = &v517;
  }
  else
  {
    if (!(_QWORD)v519)
      goto LABEL_28;
    v17 = 5;
  }
  (*v16)[v17]();
LABEL_28:
  v517 = (uint64_t (**)())Context;
  *(_OWORD *)__p = 0u;
  v519 = 0u;
  v520 = v522;
  v521 = 0x600000000;
  v522[7] = 0;
  v522[6] = 0;
  v523 = 0;
  v524 = 0;
  v525 = 0;
  v526 = 0x2800000000;
  v527 = 0;
  v528 = 0;
  v529 = 0x2800000000;
  v18 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v515, 1);
  mlir::Pattern::Pattern((uint64_t)(v18 + 1), (uint64_t)"mps.bias_add_grad", 17, (__int16)v515, (uint64_t)Context, 0, 0);
  v18[12] = &v530;
  *v18 = off_1E0E49D00;
  if (!v18[9])
  {
    v515 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerBiasAddGradNCHW]";
    v516 = 104;
    v19 = llvm::StringRef::find((uint64_t *)&v515, "DesiredTypeName = ", 0x12uLL, 0);
    if (v516 >= v19)
      v20 = v19;
    else
      v20 = v516;
    v21 = &v515[v20];
    v22 = v516 - v20;
    if (v516 - v20 >= 0x12)
      v23 = 18;
    else
      v23 = v516 - v20;
    v24 = &v21[v23];
    v25 = v22 - v23;
    if (v25 >= v25 - 1)
      --v25;
    v18[8] = v24;
    v18[9] = v25;
  }
  v26 = *((unsigned int *)v18 + 22);
  if (v26 > *((_DWORD *)v18 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v18 + 10), v18 + 12, v26, 16);
    LODWORD(v26) = *((_DWORD *)v18 + 22);
  }
  *((_DWORD *)v18 + 22) = v26;
  v27 = (char *)__p[1];
  if (__p[1] >= (void *)v519)
  {
    v29 = (char *)__p[0];
    v30 = (char *)__p[1] - (char *)__p[0];
    v31 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v32 = v31 + 1;
    if ((unint64_t)(v31 + 1) >> 61)
      goto LABEL_615;
    v33 = v519 - (unint64_t)__p[0];
    if ((uint64_t)(v519 - (unint64_t)__p[0]) >> 2 > v32)
      v32 = v33 >> 2;
    if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
      v34 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v34 = v32;
    if (v34)
    {
      if (v34 >> 61)
        goto LABEL_616;
      v35 = (char *)operator new(8 * v34);
    }
    else
    {
      v35 = 0;
    }
    v36 = &v35[8 * v31];
    v37 = &v35[8 * v34];
    *(_QWORD *)v36 = v18;
    v28 = v36 + 8;
    if (v27 == v29)
    {
      __p[0] = &v35[8 * v31];
      __p[1] = v36 + 8;
      *(_QWORD *)&v519 = v37;
    }
    else
    {
      v38 = v27 - v29 - 8;
      if (v38 < 0x78
        || &v27[-(v38 & 0xFFFFFFFFFFFFFFF8) - 8] < v36 && &v35[v30 - (v38 & 0xFFFFFFFFFFFFFFF8) - 8] < v27)
      {
        goto LABEL_619;
      }
      v39 = (v38 >> 3) + 1;
      v40 = 8 * (v39 & 0x3FFFFFFFFFFFFFFCLL);
      v41 = &v27[-v40];
      v36 -= v40;
      v42 = &v35[8 * v31 - 16];
      v43 = v27 - 16;
      v44 = v39 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v46 = *((_OWORD *)v43 - 1);
        v45 = *(_OWORD *)v43;
        *((_OWORD *)v43 - 1) = 0uLL;
        *(_OWORD *)v43 = 0uLL;
        *((_OWORD *)v42 - 1) = v46;
        *(_OWORD *)v42 = v45;
        v42 -= 32;
        v43 -= 32;
        v44 -= 4;
      }
      while (v44);
      v27 = v41;
      if (v39 != (v39 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_619:
        do
        {
          v47 = *((_QWORD *)v27 - 1);
          v27 -= 8;
          *(_QWORD *)v27 = 0;
          *((_QWORD *)v36 - 1) = v47;
          v36 -= 8;
        }
        while (v27 != v29);
      }
      v27 = (char *)__p[0];
      v48 = (char *)__p[1];
      __p[0] = v36;
      __p[1] = v28;
      *(_QWORD *)&v519 = v37;
      while (v48 != v27)
      {
        v50 = *((_QWORD *)v48 - 1);
        v48 -= 8;
        v49 = v50;
        *(_QWORD *)v48 = 0;
        if (v50)
          (*(void (**)(uint64_t))(*(_QWORD *)v49 + 8))(v49);
      }
    }
    if (v27)
      operator delete(v27);
  }
  else
  {
    *(_QWORD *)__p[1] = v18;
    v28 = v27 + 8;
  }
  __p[1] = v28;
  v51 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v515, 1);
  mlir::Pattern::Pattern((uint64_t)(v51 + 1), (uint64_t)"mps.bias_add_grad", 17, (__int16)v515, (uint64_t)Context, 0, 0);
  v51[12] = &v530;
  *v51 = off_1E0E54288;
  if (!v51[9])
  {
    v515 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerBiasAddGradNHWC]";
    v516 = 104;
    v52 = llvm::StringRef::find((uint64_t *)&v515, "DesiredTypeName = ", 0x12uLL, 0);
    if (v516 >= v52)
      v53 = v52;
    else
      v53 = v516;
    v54 = &v515[v53];
    v55 = v516 - v53;
    if (v516 - v53 >= 0x12)
      v56 = 18;
    else
      v56 = v516 - v53;
    v57 = &v54[v56];
    v58 = v55 - v56;
    if (v58 >= v58 - 1)
      --v58;
    v51[8] = v57;
    v51[9] = v58;
  }
  v59 = *((unsigned int *)v51 + 22);
  if (v59 > *((_DWORD *)v51 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v51 + 10), v51 + 12, v59, 16);
    LODWORD(v59) = *((_DWORD *)v51 + 22);
  }
  *((_DWORD *)v51 + 22) = v59;
  v60 = (char *)__p[1];
  if (__p[1] >= (void *)v519)
  {
    v62 = (char *)__p[0];
    v63 = (char *)__p[1] - (char *)__p[0];
    v64 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v65 = v64 + 1;
    if ((unint64_t)(v64 + 1) >> 61)
      goto LABEL_615;
    v66 = v519 - (unint64_t)__p[0];
    if ((uint64_t)(v519 - (unint64_t)__p[0]) >> 2 > v65)
      v65 = v66 >> 2;
    if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF8)
      v67 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v67 = v65;
    if (v67)
    {
      if (v67 >> 61)
        goto LABEL_616;
      v68 = (char *)operator new(8 * v67);
    }
    else
    {
      v68 = 0;
    }
    v69 = &v68[8 * v64];
    v70 = &v68[8 * v67];
    *(_QWORD *)v69 = v51;
    v61 = v69 + 8;
    if (v60 == v62)
    {
      __p[0] = &v68[8 * v64];
      __p[1] = v69 + 8;
      *(_QWORD *)&v519 = v70;
    }
    else
    {
      v71 = v60 - v62 - 8;
      if (v71 < 0x78
        || &v60[-(v71 & 0xFFFFFFFFFFFFFFF8) - 8] < v69 && &v68[v63 - (v71 & 0xFFFFFFFFFFFFFFF8) - 8] < v60)
      {
        goto LABEL_620;
      }
      v72 = (v71 >> 3) + 1;
      v73 = 8 * (v72 & 0x3FFFFFFFFFFFFFFCLL);
      v74 = &v60[-v73];
      v69 -= v73;
      v75 = &v68[8 * v64 - 16];
      v76 = v60 - 16;
      v77 = v72 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v79 = *((_OWORD *)v76 - 1);
        v78 = *(_OWORD *)v76;
        *((_OWORD *)v76 - 1) = 0uLL;
        *(_OWORD *)v76 = 0uLL;
        *((_OWORD *)v75 - 1) = v79;
        *(_OWORD *)v75 = v78;
        v75 -= 32;
        v76 -= 32;
        v77 -= 4;
      }
      while (v77);
      v60 = v74;
      if (v72 != (v72 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_620:
        do
        {
          v80 = *((_QWORD *)v60 - 1);
          v60 -= 8;
          *(_QWORD *)v60 = 0;
          *((_QWORD *)v69 - 1) = v80;
          v69 -= 8;
        }
        while (v60 != v62);
      }
      v60 = (char *)__p[0];
      v81 = (char *)__p[1];
      __p[0] = v69;
      __p[1] = v61;
      *(_QWORD *)&v519 = v70;
      while (v81 != v60)
      {
        v83 = *((_QWORD *)v81 - 1);
        v81 -= 8;
        v82 = v83;
        *(_QWORD *)v81 = 0;
        if (v83)
          (*(void (**)(uint64_t))(*(_QWORD *)v82 + 8))(v82);
      }
    }
    if (v60)
      operator delete(v60);
  }
  else
  {
    *(_QWORD *)__p[1] = v51;
    v61 = v60 + 8;
  }
  __p[1] = v61;
  v84 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v515, 1);
  mlir::Pattern::Pattern((uint64_t)(v84 + 1), (uint64_t)"mps.bias_add", 12, (__int16)v515, (uint64_t)Context, 0, 0);
  v84[12] = &v530;
  *v84 = off_1E0E542F0;
  if (!v84[9])
  {
    v515 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerBiasAddNCHW]";
    v516 = 100;
    v85 = llvm::StringRef::find((uint64_t *)&v515, "DesiredTypeName = ", 0x12uLL, 0);
    if (v516 >= v85)
      v86 = v85;
    else
      v86 = v516;
    v87 = &v515[v86];
    v88 = v516 - v86;
    if (v516 - v86 >= 0x12)
      v89 = 18;
    else
      v89 = v516 - v86;
    v90 = &v87[v89];
    v91 = v88 - v89;
    if (v91 >= v91 - 1)
      --v91;
    v84[8] = v90;
    v84[9] = v91;
  }
  v92 = *((unsigned int *)v84 + 22);
  if (v92 > *((_DWORD *)v84 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v84 + 10), v84 + 12, v92, 16);
    LODWORD(v92) = *((_DWORD *)v84 + 22);
  }
  *((_DWORD *)v84 + 22) = v92;
  v93 = (char *)__p[1];
  if (__p[1] >= (void *)v519)
  {
    v95 = (char *)__p[0];
    v96 = (char *)__p[1] - (char *)__p[0];
    v97 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v98 = v97 + 1;
    if ((unint64_t)(v97 + 1) >> 61)
      goto LABEL_615;
    v99 = v519 - (unint64_t)__p[0];
    if ((uint64_t)(v519 - (unint64_t)__p[0]) >> 2 > v98)
      v98 = v99 >> 2;
    if ((unint64_t)v99 >= 0x7FFFFFFFFFFFFFF8)
      v100 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v100 = v98;
    if (v100)
    {
      if (v100 >> 61)
        goto LABEL_616;
      v101 = (char *)operator new(8 * v100);
    }
    else
    {
      v101 = 0;
    }
    v102 = &v101[8 * v97];
    v103 = &v101[8 * v100];
    *(_QWORD *)v102 = v84;
    v94 = v102 + 8;
    if (v93 == v95)
    {
      __p[0] = &v101[8 * v97];
      __p[1] = v102 + 8;
      *(_QWORD *)&v519 = v103;
    }
    else
    {
      v104 = v93 - v95 - 8;
      if (v104 < 0x78
        || &v93[-(v104 & 0xFFFFFFFFFFFFFFF8) - 8] < v102 && &v101[v96 - (v104 & 0xFFFFFFFFFFFFFFF8) - 8] < v93)
      {
        goto LABEL_621;
      }
      v105 = (v104 >> 3) + 1;
      v106 = 8 * (v105 & 0x3FFFFFFFFFFFFFFCLL);
      v107 = &v93[-v106];
      v102 -= v106;
      v108 = &v101[8 * v97 - 16];
      v109 = v93 - 16;
      v110 = v105 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v112 = *((_OWORD *)v109 - 1);
        v111 = *(_OWORD *)v109;
        *((_OWORD *)v109 - 1) = 0uLL;
        *(_OWORD *)v109 = 0uLL;
        *((_OWORD *)v108 - 1) = v112;
        *(_OWORD *)v108 = v111;
        v108 -= 32;
        v109 -= 32;
        v110 -= 4;
      }
      while (v110);
      v93 = v107;
      if (v105 != (v105 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_621:
        do
        {
          v113 = *((_QWORD *)v93 - 1);
          v93 -= 8;
          *(_QWORD *)v93 = 0;
          *((_QWORD *)v102 - 1) = v113;
          v102 -= 8;
        }
        while (v93 != v95);
      }
      v93 = (char *)__p[0];
      v114 = (char *)__p[1];
      __p[0] = v102;
      __p[1] = v94;
      *(_QWORD *)&v519 = v103;
      while (v114 != v93)
      {
        v116 = *((_QWORD *)v114 - 1);
        v114 -= 8;
        v115 = v116;
        *(_QWORD *)v114 = 0;
        if (v116)
          (*(void (**)(uint64_t))(*(_QWORD *)v115 + 8))(v115);
      }
    }
    if (v93)
      operator delete(v93);
  }
  else
  {
    *(_QWORD *)__p[1] = v84;
    v94 = v93 + 8;
  }
  __p[1] = v94;
  v117 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v515, 1);
  mlir::Pattern::Pattern((uint64_t)(v117 + 1), (uint64_t)"mps.reduction_mean", 18, (__int16)v515, (uint64_t)Context, 0, 0);
  v117[12] = &v530;
  *v117 = off_1E0E49858;
  if (!v117[9])
  {
    v515 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerReductionMean]";
    v516 = 102;
    v118 = llvm::StringRef::find((uint64_t *)&v515, "DesiredTypeName = ", 0x12uLL, 0);
    if (v516 >= v118)
      v119 = v118;
    else
      v119 = v516;
    v120 = &v515[v119];
    v121 = v516 - v119;
    if (v516 - v119 >= 0x12)
      v122 = 18;
    else
      v122 = v516 - v119;
    v123 = &v120[v122];
    v124 = v121 - v122;
    if (v124 >= v124 - 1)
      --v124;
    v117[8] = v123;
    v117[9] = v124;
  }
  v125 = *((unsigned int *)v117 + 22);
  if (v125 > *((_DWORD *)v117 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v117 + 10), v117 + 12, v125, 16);
    LODWORD(v125) = *((_DWORD *)v117 + 22);
  }
  *((_DWORD *)v117 + 22) = v125;
  v126 = (char *)__p[1];
  if (__p[1] >= (void *)v519)
  {
    v128 = (char *)__p[0];
    v129 = (char *)__p[1] - (char *)__p[0];
    v130 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v131 = v130 + 1;
    if ((unint64_t)(v130 + 1) >> 61)
      goto LABEL_615;
    v132 = v519 - (unint64_t)__p[0];
    if ((uint64_t)(v519 - (unint64_t)__p[0]) >> 2 > v131)
      v131 = v132 >> 2;
    if ((unint64_t)v132 >= 0x7FFFFFFFFFFFFFF8)
      v133 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v133 = v131;
    if (v133)
    {
      if (v133 >> 61)
        goto LABEL_616;
      v134 = (char *)operator new(8 * v133);
    }
    else
    {
      v134 = 0;
    }
    v135 = &v134[8 * v130];
    v136 = &v134[8 * v133];
    *(_QWORD *)v135 = v117;
    v127 = v135 + 8;
    if (v126 == v128)
    {
      __p[0] = &v134[8 * v130];
      __p[1] = v135 + 8;
      *(_QWORD *)&v519 = v136;
    }
    else
    {
      v137 = v126 - v128 - 8;
      if (v137 < 0x78
        || &v126[-(v137 & 0xFFFFFFFFFFFFFFF8) - 8] < v135 && &v134[v129 - (v137 & 0xFFFFFFFFFFFFFFF8) - 8] < v126)
      {
        goto LABEL_622;
      }
      v138 = (v137 >> 3) + 1;
      v139 = 8 * (v138 & 0x3FFFFFFFFFFFFFFCLL);
      v140 = &v126[-v139];
      v135 -= v139;
      v141 = &v134[8 * v130 - 16];
      v142 = v126 - 16;
      v143 = v138 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v145 = *((_OWORD *)v142 - 1);
        v144 = *(_OWORD *)v142;
        *((_OWORD *)v142 - 1) = 0uLL;
        *(_OWORD *)v142 = 0uLL;
        *((_OWORD *)v141 - 1) = v145;
        *(_OWORD *)v141 = v144;
        v141 -= 32;
        v142 -= 32;
        v143 -= 4;
      }
      while (v143);
      v126 = v140;
      if (v138 != (v138 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_622:
        do
        {
          v146 = *((_QWORD *)v126 - 1);
          v126 -= 8;
          *(_QWORD *)v126 = 0;
          *((_QWORD *)v135 - 1) = v146;
          v135 -= 8;
        }
        while (v126 != v128);
      }
      v126 = (char *)__p[0];
      v147 = (char *)__p[1];
      __p[0] = v135;
      __p[1] = v127;
      *(_QWORD *)&v519 = v136;
      while (v147 != v126)
      {
        v149 = *((_QWORD *)v147 - 1);
        v147 -= 8;
        v148 = v149;
        *(_QWORD *)v147 = 0;
        if (v149)
          (*(void (**)(uint64_t))(*(_QWORD *)v148 + 8))(v148);
      }
    }
    if (v126)
      operator delete(v126);
  }
  else
  {
    *(_QWORD *)__p[1] = v117;
    v127 = v126 + 8;
  }
  __p[1] = v127;
  v150 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v515, 1);
  mlir::Pattern::Pattern((uint64_t)(v150 + 1), (uint64_t)"mps.reduction_variance", 22, (__int16)v515, (uint64_t)Context, 0, 0);
  v150[12] = &v530;
  *v150 = off_1E0E4A380;
  if (!v150[9])
  {
    v515 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerReductionVariance]";
    v516 = 106;
    v151 = llvm::StringRef::find((uint64_t *)&v515, "DesiredTypeName = ", 0x12uLL, 0);
    if (v516 >= v151)
      v152 = v151;
    else
      v152 = v516;
    v153 = &v515[v152];
    v154 = v516 - v152;
    if (v516 - v152 >= 0x12)
      v155 = 18;
    else
      v155 = v516 - v152;
    v156 = &v153[v155];
    v157 = v154 - v155;
    if (v157 >= v157 - 1)
      --v157;
    v150[8] = v156;
    v150[9] = v157;
  }
  v158 = *((unsigned int *)v150 + 22);
  if (v158 > *((_DWORD *)v150 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v150 + 10), v150 + 12, v158, 16);
    LODWORD(v158) = *((_DWORD *)v150 + 22);
  }
  *((_DWORD *)v150 + 22) = v158;
  v159 = (char *)__p[1];
  if (__p[1] >= (void *)v519)
  {
    v161 = (char *)__p[0];
    v162 = (char *)__p[1] - (char *)__p[0];
    v163 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v164 = v163 + 1;
    if ((unint64_t)(v163 + 1) >> 61)
      goto LABEL_615;
    v165 = v519 - (unint64_t)__p[0];
    if ((uint64_t)(v519 - (unint64_t)__p[0]) >> 2 > v164)
      v164 = v165 >> 2;
    if ((unint64_t)v165 >= 0x7FFFFFFFFFFFFFF8)
      v166 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v166 = v164;
    if (v166)
    {
      if (v166 >> 61)
        goto LABEL_616;
      v167 = (char *)operator new(8 * v166);
    }
    else
    {
      v167 = 0;
    }
    v168 = &v167[8 * v163];
    v169 = &v167[8 * v166];
    *(_QWORD *)v168 = v150;
    v160 = v168 + 8;
    if (v159 == v161)
    {
      __p[0] = &v167[8 * v163];
      __p[1] = v168 + 8;
      *(_QWORD *)&v519 = v169;
    }
    else
    {
      v170 = v159 - v161 - 8;
      if (v170 < 0x78
        || &v159[-(v170 & 0xFFFFFFFFFFFFFFF8) - 8] < v168 && &v167[v162 - (v170 & 0xFFFFFFFFFFFFFFF8) - 8] < v159)
      {
        goto LABEL_623;
      }
      v171 = (v170 >> 3) + 1;
      v172 = 8 * (v171 & 0x3FFFFFFFFFFFFFFCLL);
      v173 = &v159[-v172];
      v168 -= v172;
      v174 = &v167[8 * v163 - 16];
      v175 = v159 - 16;
      v176 = v171 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v178 = *((_OWORD *)v175 - 1);
        v177 = *(_OWORD *)v175;
        *((_OWORD *)v175 - 1) = 0uLL;
        *(_OWORD *)v175 = 0uLL;
        *((_OWORD *)v174 - 1) = v178;
        *(_OWORD *)v174 = v177;
        v174 -= 32;
        v175 -= 32;
        v176 -= 4;
      }
      while (v176);
      v159 = v173;
      if (v171 != (v171 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_623:
        do
        {
          v179 = *((_QWORD *)v159 - 1);
          v159 -= 8;
          *(_QWORD *)v159 = 0;
          *((_QWORD *)v168 - 1) = v179;
          v168 -= 8;
        }
        while (v159 != v161);
      }
      v159 = (char *)__p[0];
      v180 = (char *)__p[1];
      __p[0] = v168;
      __p[1] = v160;
      *(_QWORD *)&v519 = v169;
      while (v180 != v159)
      {
        v182 = *((_QWORD *)v180 - 1);
        v180 -= 8;
        v181 = v182;
        *(_QWORD *)v180 = 0;
        if (v182)
          (*(void (**)(uint64_t))(*(_QWORD *)v181 + 8))(v181);
      }
    }
    if (v159)
      operator delete(v159);
  }
  else
  {
    *(_QWORD *)__p[1] = v150;
    v160 = v159 + 8;
  }
  __p[1] = v160;
  v183 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v515, 1);
  mlir::Pattern::Pattern((uint64_t)(v183 + 1), (uint64_t)"mps.softplus", 12, (__int16)v515, (uint64_t)Context, 0, 0);
  v183[12] = &v530;
  *v183 = off_1E0E48BB0;
  if (!v183[9])
  {
    v515 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerSoftplus]";
    v516 = 97;
    v184 = llvm::StringRef::find((uint64_t *)&v515, "DesiredTypeName = ", 0x12uLL, 0);
    if (v516 >= v184)
      v185 = v184;
    else
      v185 = v516;
    v186 = &v515[v185];
    v187 = v516 - v185;
    if (v516 - v185 >= 0x12)
      v188 = 18;
    else
      v188 = v516 - v185;
    v189 = &v186[v188];
    v190 = v187 - v188;
    if (v190 >= v190 - 1)
      --v190;
    v183[8] = v189;
    v183[9] = v190;
  }
  v191 = *((unsigned int *)v183 + 22);
  if (v191 > *((_DWORD *)v183 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v183 + 10), v183 + 12, v191, 16);
    LODWORD(v191) = *((_DWORD *)v183 + 22);
  }
  *((_DWORD *)v183 + 22) = v191;
  v192 = (char *)__p[1];
  if (__p[1] >= (void *)v519)
  {
    v194 = (char *)__p[0];
    v195 = (char *)__p[1] - (char *)__p[0];
    v196 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v197 = v196 + 1;
    if ((unint64_t)(v196 + 1) >> 61)
      goto LABEL_615;
    v198 = v519 - (unint64_t)__p[0];
    if ((uint64_t)(v519 - (unint64_t)__p[0]) >> 2 > v197)
      v197 = v198 >> 2;
    if ((unint64_t)v198 >= 0x7FFFFFFFFFFFFFF8)
      v199 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v199 = v197;
    if (v199)
    {
      if (v199 >> 61)
        goto LABEL_616;
      v200 = (char *)operator new(8 * v199);
    }
    else
    {
      v200 = 0;
    }
    v201 = &v200[8 * v196];
    v202 = &v200[8 * v199];
    *(_QWORD *)v201 = v183;
    v193 = v201 + 8;
    if (v192 == v194)
    {
      __p[0] = &v200[8 * v196];
      __p[1] = v201 + 8;
      *(_QWORD *)&v519 = v202;
    }
    else
    {
      v203 = v192 - v194 - 8;
      if (v203 < 0x78
        || &v192[-(v203 & 0xFFFFFFFFFFFFFFF8) - 8] < v201 && &v200[v195 - (v203 & 0xFFFFFFFFFFFFFFF8) - 8] < v192)
      {
        goto LABEL_624;
      }
      v204 = (v203 >> 3) + 1;
      v205 = 8 * (v204 & 0x3FFFFFFFFFFFFFFCLL);
      v206 = &v192[-v205];
      v201 -= v205;
      v207 = &v200[8 * v196 - 16];
      v208 = v192 - 16;
      v209 = v204 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v211 = *((_OWORD *)v208 - 1);
        v210 = *(_OWORD *)v208;
        *((_OWORD *)v208 - 1) = 0uLL;
        *(_OWORD *)v208 = 0uLL;
        *((_OWORD *)v207 - 1) = v211;
        *(_OWORD *)v207 = v210;
        v207 -= 32;
        v208 -= 32;
        v209 -= 4;
      }
      while (v209);
      v192 = v206;
      if (v204 != (v204 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_624:
        do
        {
          v212 = *((_QWORD *)v192 - 1);
          v192 -= 8;
          *(_QWORD *)v192 = 0;
          *((_QWORD *)v201 - 1) = v212;
          v201 -= 8;
        }
        while (v192 != v194);
      }
      v192 = (char *)__p[0];
      v213 = (char *)__p[1];
      __p[0] = v201;
      __p[1] = v193;
      *(_QWORD *)&v519 = v202;
      while (v213 != v192)
      {
        v215 = *((_QWORD *)v213 - 1);
        v213 -= 8;
        v214 = v215;
        *(_QWORD *)v213 = 0;
        if (v215)
          (*(void (**)(uint64_t))(*(_QWORD *)v214 + 8))(v214);
      }
    }
    if (v192)
      operator delete(v192);
  }
  else
  {
    *(_QWORD *)__p[1] = v183;
    v193 = v192 + 8;
  }
  __p[1] = v193;
  v216 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v515, 1);
  mlir::Pattern::Pattern((uint64_t)(v216 + 1), (uint64_t)"mps.non_zero", 12, (__int16)v515, (uint64_t)Context, 0, 0);
  v216[12] = &v530;
  *v216 = off_1E0E489D8;
  if (!v216[9])
  {
    v515 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerNonZero]";
    v516 = 96;
    v217 = llvm::StringRef::find((uint64_t *)&v515, "DesiredTypeName = ", 0x12uLL, 0);
    if (v516 >= v217)
      v218 = v217;
    else
      v218 = v516;
    v219 = &v515[v218];
    v220 = v516 - v218;
    if (v516 - v218 >= 0x12)
      v221 = 18;
    else
      v221 = v516 - v218;
    v222 = &v219[v221];
    v223 = v220 - v221;
    if (v223 >= v223 - 1)
      --v223;
    v216[8] = v222;
    v216[9] = v223;
  }
  v224 = *((unsigned int *)v216 + 22);
  if (v224 > *((_DWORD *)v216 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v216 + 10), v216 + 12, v224, 16);
    LODWORD(v224) = *((_DWORD *)v216 + 22);
  }
  *((_DWORD *)v216 + 22) = v224;
  v225 = (char *)__p[1];
  if (__p[1] >= (void *)v519)
  {
    v227 = (char *)__p[0];
    v228 = (char *)__p[1] - (char *)__p[0];
    v229 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v230 = v229 + 1;
    if ((unint64_t)(v229 + 1) >> 61)
      goto LABEL_615;
    v231 = v519 - (unint64_t)__p[0];
    if ((uint64_t)(v519 - (unint64_t)__p[0]) >> 2 > v230)
      v230 = v231 >> 2;
    if ((unint64_t)v231 >= 0x7FFFFFFFFFFFFFF8)
      v232 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v232 = v230;
    if (v232)
    {
      if (v232 >> 61)
        goto LABEL_616;
      v233 = (char *)operator new(8 * v232);
    }
    else
    {
      v233 = 0;
    }
    v234 = &v233[8 * v229];
    v235 = &v233[8 * v232];
    *(_QWORD *)v234 = v216;
    v226 = v234 + 8;
    if (v225 == v227)
    {
      __p[0] = &v233[8 * v229];
      __p[1] = v234 + 8;
      *(_QWORD *)&v519 = v235;
    }
    else
    {
      v236 = v225 - v227 - 8;
      if (v236 < 0x78
        || &v225[-(v236 & 0xFFFFFFFFFFFFFFF8) - 8] < v234 && &v233[v228 - (v236 & 0xFFFFFFFFFFFFFFF8) - 8] < v225)
      {
        goto LABEL_625;
      }
      v237 = (v236 >> 3) + 1;
      v238 = 8 * (v237 & 0x3FFFFFFFFFFFFFFCLL);
      v239 = &v225[-v238];
      v234 -= v238;
      v240 = &v233[8 * v229 - 16];
      v241 = v225 - 16;
      v242 = v237 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v244 = *((_OWORD *)v241 - 1);
        v243 = *(_OWORD *)v241;
        *((_OWORD *)v241 - 1) = 0uLL;
        *(_OWORD *)v241 = 0uLL;
        *((_OWORD *)v240 - 1) = v244;
        *(_OWORD *)v240 = v243;
        v240 -= 32;
        v241 -= 32;
        v242 -= 4;
      }
      while (v242);
      v225 = v239;
      if (v237 != (v237 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_625:
        do
        {
          v245 = *((_QWORD *)v225 - 1);
          v225 -= 8;
          *(_QWORD *)v225 = 0;
          *((_QWORD *)v234 - 1) = v245;
          v234 -= 8;
        }
        while (v225 != v227);
      }
      v225 = (char *)__p[0];
      v246 = (char *)__p[1];
      __p[0] = v234;
      __p[1] = v226;
      *(_QWORD *)&v519 = v235;
      while (v246 != v225)
      {
        v248 = *((_QWORD *)v246 - 1);
        v246 -= 8;
        v247 = v248;
        *(_QWORD *)v246 = 0;
        if (v248)
          (*(void (**)(uint64_t))(*(_QWORD *)v247 + 8))(v247);
      }
    }
    if (v225)
      operator delete(v225);
  }
  else
  {
    *(_QWORD *)__p[1] = v216;
    v226 = v225 + 8;
  }
  __p[1] = v226;
  v249 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v515, 1);
  mlir::Pattern::Pattern((uint64_t)(v249 + 1), (uint64_t)"mps.sigmoid", 11, (__int16)v515, (uint64_t)Context, 0, 0);
  v249[12] = &v530;
  *v249 = off_1E0E48A40;
  if (!v249[9])
  {
    v515 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerSigmoid]";
    v516 = 96;
    v250 = llvm::StringRef::find((uint64_t *)&v515, "DesiredTypeName = ", 0x12uLL, 0);
    if (v516 >= v250)
      v251 = v250;
    else
      v251 = v516;
    v252 = &v515[v251];
    v253 = v516 - v251;
    if (v516 - v251 >= 0x12)
      v254 = 18;
    else
      v254 = v516 - v251;
    v255 = &v252[v254];
    v256 = v253 - v254;
    if (v256 >= v256 - 1)
      --v256;
    v249[8] = v255;
    v249[9] = v256;
  }
  v257 = *((unsigned int *)v249 + 22);
  if (v257 > *((_DWORD *)v249 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v249 + 10), v249 + 12, v257, 16);
    LODWORD(v257) = *((_DWORD *)v249 + 22);
  }
  *((_DWORD *)v249 + 22) = v257;
  v258 = (char *)__p[1];
  if (__p[1] >= (void *)v519)
  {
    v260 = (char *)__p[0];
    v261 = (char *)__p[1] - (char *)__p[0];
    v262 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v263 = v262 + 1;
    if ((unint64_t)(v262 + 1) >> 61)
      goto LABEL_615;
    v264 = v519 - (unint64_t)__p[0];
    if ((uint64_t)(v519 - (unint64_t)__p[0]) >> 2 > v263)
      v263 = v264 >> 2;
    if ((unint64_t)v264 >= 0x7FFFFFFFFFFFFFF8)
      v265 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v265 = v263;
    if (v265)
    {
      if (v265 >> 61)
        goto LABEL_616;
      v266 = (char *)operator new(8 * v265);
    }
    else
    {
      v266 = 0;
    }
    v267 = &v266[8 * v262];
    v268 = &v266[8 * v265];
    *(_QWORD *)v267 = v249;
    v259 = v267 + 8;
    if (v258 == v260)
    {
      __p[0] = &v266[8 * v262];
      __p[1] = v267 + 8;
      *(_QWORD *)&v519 = v268;
    }
    else
    {
      v269 = v258 - v260 - 8;
      if (v269 < 0x78
        || &v258[-(v269 & 0xFFFFFFFFFFFFFFF8) - 8] < v267 && &v266[v261 - (v269 & 0xFFFFFFFFFFFFFFF8) - 8] < v258)
      {
        goto LABEL_626;
      }
      v270 = (v269 >> 3) + 1;
      v271 = 8 * (v270 & 0x3FFFFFFFFFFFFFFCLL);
      v272 = &v258[-v271];
      v267 -= v271;
      v273 = &v266[8 * v262 - 16];
      v274 = v258 - 16;
      v275 = v270 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v277 = *((_OWORD *)v274 - 1);
        v276 = *(_OWORD *)v274;
        *((_OWORD *)v274 - 1) = 0uLL;
        *(_OWORD *)v274 = 0uLL;
        *((_OWORD *)v273 - 1) = v277;
        *(_OWORD *)v273 = v276;
        v273 -= 32;
        v274 -= 32;
        v275 -= 4;
      }
      while (v275);
      v258 = v272;
      if (v270 != (v270 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_626:
        do
        {
          v278 = *((_QWORD *)v258 - 1);
          v258 -= 8;
          *(_QWORD *)v258 = 0;
          *((_QWORD *)v267 - 1) = v278;
          v267 -= 8;
        }
        while (v258 != v260);
      }
      v258 = (char *)__p[0];
      v279 = (char *)__p[1];
      __p[0] = v267;
      __p[1] = v259;
      *(_QWORD *)&v519 = v268;
      while (v279 != v258)
      {
        v281 = *((_QWORD *)v279 - 1);
        v279 -= 8;
        v280 = v281;
        *(_QWORD *)v279 = 0;
        if (v281)
          (*(void (**)(uint64_t))(*(_QWORD *)v280 + 8))(v280);
      }
    }
    if (v258)
      operator delete(v258);
  }
  else
  {
    *(_QWORD *)__p[1] = v249;
    v259 = v258 + 8;
  }
  __p[1] = v259;
  v282 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v515, 1);
  mlir::Pattern::Pattern((uint64_t)(v282 + 1), (uint64_t)"arith.select", 12, (__int16)v515, (uint64_t)Context, 0, 0);
  v282[12] = &v530;
  *v282 = off_1E0DFB0D0;
  if (!v282[9])
  {
    v515 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerArithSelect]";
    v516 = 100;
    v283 = llvm::StringRef::find((uint64_t *)&v515, "DesiredTypeName = ", 0x12uLL, 0);
    if (v516 >= v283)
      v284 = v283;
    else
      v284 = v516;
    v285 = &v515[v284];
    v286 = v516 - v284;
    if (v516 - v284 >= 0x12)
      v287 = 18;
    else
      v287 = v516 - v284;
    v288 = &v285[v287];
    v289 = v286 - v287;
    if (v289 >= v289 - 1)
      --v289;
    v282[8] = v288;
    v282[9] = v289;
  }
  v290 = *((unsigned int *)v282 + 22);
  if (v290 > *((_DWORD *)v282 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v282 + 10), v282 + 12, v290, 16);
    LODWORD(v290) = *((_DWORD *)v282 + 22);
  }
  *((_DWORD *)v282 + 22) = v290;
  v291 = (char *)__p[1];
  if (__p[1] >= (void *)v519)
  {
    v293 = (char *)__p[0];
    v294 = (char *)__p[1] - (char *)__p[0];
    v295 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v296 = v295 + 1;
    if ((unint64_t)(v295 + 1) >> 61)
      goto LABEL_615;
    v297 = v519 - (unint64_t)__p[0];
    if ((uint64_t)(v519 - (unint64_t)__p[0]) >> 2 > v296)
      v296 = v297 >> 2;
    if ((unint64_t)v297 >= 0x7FFFFFFFFFFFFFF8)
      v298 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v298 = v296;
    if (v298)
    {
      if (v298 >> 61)
        goto LABEL_616;
      v299 = (char *)operator new(8 * v298);
    }
    else
    {
      v299 = 0;
    }
    v300 = &v299[8 * v295];
    v301 = &v299[8 * v298];
    *(_QWORD *)v300 = v282;
    v292 = v300 + 8;
    if (v291 == v293)
    {
      __p[0] = &v299[8 * v295];
      __p[1] = v300 + 8;
      *(_QWORD *)&v519 = v301;
    }
    else
    {
      v302 = v291 - v293 - 8;
      if (v302 < 0x78
        || &v291[-(v302 & 0xFFFFFFFFFFFFFFF8) - 8] < v300 && &v299[v294 - (v302 & 0xFFFFFFFFFFFFFFF8) - 8] < v291)
      {
        goto LABEL_627;
      }
      v303 = (v302 >> 3) + 1;
      v304 = 8 * (v303 & 0x3FFFFFFFFFFFFFFCLL);
      v305 = &v291[-v304];
      v300 -= v304;
      v306 = &v299[8 * v295 - 16];
      v307 = v291 - 16;
      v308 = v303 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v310 = *((_OWORD *)v307 - 1);
        v309 = *(_OWORD *)v307;
        *((_OWORD *)v307 - 1) = 0uLL;
        *(_OWORD *)v307 = 0uLL;
        *((_OWORD *)v306 - 1) = v310;
        *(_OWORD *)v306 = v309;
        v306 -= 32;
        v307 -= 32;
        v308 -= 4;
      }
      while (v308);
      v291 = v305;
      if (v303 != (v303 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_627:
        do
        {
          v311 = *((_QWORD *)v291 - 1);
          v291 -= 8;
          *(_QWORD *)v291 = 0;
          *((_QWORD *)v300 - 1) = v311;
          v300 -= 8;
        }
        while (v291 != v293);
      }
      v291 = (char *)__p[0];
      v312 = (char *)__p[1];
      __p[0] = v300;
      __p[1] = v292;
      *(_QWORD *)&v519 = v301;
      while (v312 != v291)
      {
        v314 = *((_QWORD *)v312 - 1);
        v312 -= 8;
        v313 = v314;
        *(_QWORD *)v312 = 0;
        if (v314)
          (*(void (**)(uint64_t))(*(_QWORD *)v313 + 8))(v313);
      }
    }
    if (v291)
      operator delete(v291);
  }
  else
  {
    *(_QWORD *)__p[1] = v282;
    v292 = v291 + 8;
  }
  __p[1] = v292;
  v315 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v515, 1);
  mlir::Pattern::Pattern((uint64_t)(v315 + 1), (uint64_t)"mpsx.deinterleave", 17, (__int16)v515, (uint64_t)Context, 0, 0);
  v315[12] = 0;
  *v315 = &off_1E0E49090;
  if (!v315[9])
  {
    v515 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerInterleave<mlir::mpsx"
           "::DeinterleaveOp>]";
    v516 = 127;
    v316 = llvm::StringRef::find((uint64_t *)&v515, "DesiredTypeName = ", 0x12uLL, 0);
    if (v516 >= v316)
      v317 = v316;
    else
      v317 = v516;
    v318 = &v515[v317];
    v319 = v516 - v317;
    if (v516 - v317 >= 0x12)
      v320 = 18;
    else
      v320 = v516 - v317;
    v321 = &v318[v320];
    v322 = v319 - v320;
    if (v322 >= v322 - 1)
      --v322;
    v315[8] = v321;
    v315[9] = v322;
  }
  v323 = *((unsigned int *)v315 + 22);
  if (v323 > *((_DWORD *)v315 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v315 + 10), v315 + 12, v323, 16);
    LODWORD(v323) = *((_DWORD *)v315 + 22);
  }
  *((_DWORD *)v315 + 22) = v323;
  v324 = (char *)__p[1];
  if (__p[1] >= (void *)v519)
  {
    v326 = (char *)__p[0];
    v327 = (char *)__p[1] - (char *)__p[0];
    v328 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v329 = v328 + 1;
    if ((unint64_t)(v328 + 1) >> 61)
      goto LABEL_615;
    v330 = v519 - (unint64_t)__p[0];
    if ((uint64_t)(v519 - (unint64_t)__p[0]) >> 2 > v329)
      v329 = v330 >> 2;
    if ((unint64_t)v330 >= 0x7FFFFFFFFFFFFFF8)
      v331 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v331 = v329;
    if (v331)
    {
      if (v331 >> 61)
        goto LABEL_616;
      v332 = (char *)operator new(8 * v331);
    }
    else
    {
      v332 = 0;
    }
    v333 = &v332[8 * v328];
    v334 = &v332[8 * v331];
    *(_QWORD *)v333 = v315;
    v325 = v333 + 8;
    if (v324 == v326)
    {
      __p[0] = &v332[8 * v328];
      __p[1] = v333 + 8;
      *(_QWORD *)&v519 = v334;
    }
    else
    {
      v335 = v324 - v326 - 8;
      if (v335 < 0x78
        || &v324[-(v335 & 0xFFFFFFFFFFFFFFF8) - 8] < v333 && &v332[v327 - (v335 & 0xFFFFFFFFFFFFFFF8) - 8] < v324)
      {
        goto LABEL_628;
      }
      v336 = (v335 >> 3) + 1;
      v337 = 8 * (v336 & 0x3FFFFFFFFFFFFFFCLL);
      v338 = &v324[-v337];
      v333 -= v337;
      v339 = &v332[8 * v328 - 16];
      v340 = v324 - 16;
      v341 = v336 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v343 = *((_OWORD *)v340 - 1);
        v342 = *(_OWORD *)v340;
        *((_OWORD *)v340 - 1) = 0uLL;
        *(_OWORD *)v340 = 0uLL;
        *((_OWORD *)v339 - 1) = v343;
        *(_OWORD *)v339 = v342;
        v339 -= 32;
        v340 -= 32;
        v341 -= 4;
      }
      while (v341);
      v324 = v338;
      if (v336 != (v336 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_628:
        do
        {
          v344 = *((_QWORD *)v324 - 1);
          v324 -= 8;
          *(_QWORD *)v324 = 0;
          *((_QWORD *)v333 - 1) = v344;
          v333 -= 8;
        }
        while (v324 != v326);
      }
      v324 = (char *)__p[0];
      v345 = (char *)__p[1];
      __p[0] = v333;
      __p[1] = v325;
      *(_QWORD *)&v519 = v334;
      while (v345 != v324)
      {
        v347 = *((_QWORD *)v345 - 1);
        v345 -= 8;
        v346 = v347;
        *(_QWORD *)v345 = 0;
        if (v347)
          (*(void (**)(uint64_t))(*(_QWORD *)v346 + 8))(v346);
      }
    }
    if (v324)
      operator delete(v324);
  }
  else
  {
    *(_QWORD *)__p[1] = v315;
    v325 = v324 + 8;
  }
  __p[1] = v325;
  v348 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v515, 1);
  mlir::Pattern::Pattern((uint64_t)(v348 + 1), (uint64_t)"mpsx.interleave", 15, (__int16)v515, (uint64_t)Context, 0, 0);
  v348[12] = 0;
  *v348 = &off_1E0E49028;
  if (!v348[9])
  {
    v515 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerInterleave<mlir::mpsx"
           "::InterleaveOp>]";
    v516 = 125;
    v349 = llvm::StringRef::find((uint64_t *)&v515, "DesiredTypeName = ", 0x12uLL, 0);
    if (v516 >= v349)
      v350 = v349;
    else
      v350 = v516;
    v351 = &v515[v350];
    v352 = v516 - v350;
    if (v516 - v350 >= 0x12)
      v353 = 18;
    else
      v353 = v516 - v350;
    v354 = &v351[v353];
    v355 = v352 - v353;
    if (v355 >= v355 - 1)
      --v355;
    v348[8] = v354;
    v348[9] = v355;
  }
  v356 = *((unsigned int *)v348 + 22);
  if (v356 > *((_DWORD *)v348 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v348 + 10), v348 + 12, v356, 16);
    LODWORD(v356) = *((_DWORD *)v348 + 22);
  }
  *((_DWORD *)v348 + 22) = v356;
  v357 = (char *)__p[1];
  if (__p[1] >= (void *)v519)
  {
    v359 = (char *)__p[0];
    v360 = (char *)__p[1] - (char *)__p[0];
    v361 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v362 = v361 + 1;
    if ((unint64_t)(v361 + 1) >> 61)
      goto LABEL_615;
    v363 = v519 - (unint64_t)__p[0];
    if ((uint64_t)(v519 - (unint64_t)__p[0]) >> 2 > v362)
      v362 = v363 >> 2;
    if ((unint64_t)v363 >= 0x7FFFFFFFFFFFFFF8)
      v364 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v364 = v362;
    if (v364)
    {
      if (v364 >> 61)
        goto LABEL_616;
      v365 = (char *)operator new(8 * v364);
    }
    else
    {
      v365 = 0;
    }
    v366 = &v365[8 * v361];
    v367 = &v365[8 * v364];
    *(_QWORD *)v366 = v348;
    v358 = v366 + 8;
    if (v357 == v359)
    {
      __p[0] = &v365[8 * v361];
      __p[1] = v366 + 8;
      *(_QWORD *)&v519 = v367;
    }
    else
    {
      v368 = v357 - v359 - 8;
      if (v368 < 0x78
        || &v357[-(v368 & 0xFFFFFFFFFFFFFFF8) - 8] < v366 && &v365[v360 - (v368 & 0xFFFFFFFFFFFFFFF8) - 8] < v357)
      {
        goto LABEL_629;
      }
      v369 = (v368 >> 3) + 1;
      v370 = 8 * (v369 & 0x3FFFFFFFFFFFFFFCLL);
      v371 = &v357[-v370];
      v366 -= v370;
      v372 = &v365[8 * v361 - 16];
      v373 = v357 - 16;
      v374 = v369 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v376 = *((_OWORD *)v373 - 1);
        v375 = *(_OWORD *)v373;
        *((_OWORD *)v373 - 1) = 0uLL;
        *(_OWORD *)v373 = 0uLL;
        *((_OWORD *)v372 - 1) = v376;
        *(_OWORD *)v372 = v375;
        v372 -= 32;
        v373 -= 32;
        v374 -= 4;
      }
      while (v374);
      v357 = v371;
      if (v369 != (v369 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_629:
        do
        {
          v377 = *((_QWORD *)v357 - 1);
          v357 -= 8;
          *(_QWORD *)v357 = 0;
          *((_QWORD *)v366 - 1) = v377;
          v366 -= 8;
        }
        while (v357 != v359);
      }
      v357 = (char *)__p[0];
      v378 = (char *)__p[1];
      __p[0] = v366;
      __p[1] = v358;
      *(_QWORD *)&v519 = v367;
      while (v378 != v357)
      {
        v380 = *((_QWORD *)v378 - 1);
        v378 -= 8;
        v379 = v380;
        *(_QWORD *)v378 = 0;
        if (v380)
          (*(void (**)(uint64_t))(*(_QWORD *)v379 + 8))(v379);
      }
    }
    if (v357)
      operator delete(v357);
  }
  else
  {
    *(_QWORD *)__p[1] = v348;
    v358 = v357 + 8;
  }
  __p[1] = v358;
  v381 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v515, 1);
  mlir::Pattern::Pattern((uint64_t)(v381 + 1), (uint64_t)"mps.dequantize_lut", 18, (__int16)v515, (uint64_t)Context, 0, 0);
  v381[12] = 0;
  *v381 = off_1E0E497F0;
  if (!v381[9])
  {
    v515 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerDequantizeLUT]";
    v516 = 102;
    v382 = llvm::StringRef::find((uint64_t *)&v515, "DesiredTypeName = ", 0x12uLL, 0);
    if (v516 >= v382)
      v383 = v382;
    else
      v383 = v516;
    v384 = &v515[v383];
    v385 = v516 - v383;
    if (v516 - v383 >= 0x12)
      v386 = 18;
    else
      v386 = v516 - v383;
    v387 = &v384[v386];
    v388 = v385 - v386;
    if (v388 >= v388 - 1)
      --v388;
    v381[8] = v387;
    v381[9] = v388;
  }
  v389 = *((unsigned int *)v381 + 22);
  if (v389 > *((_DWORD *)v381 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v381 + 10), v381 + 12, v389, 16);
    LODWORD(v389) = *((_DWORD *)v381 + 22);
  }
  *((_DWORD *)v381 + 22) = v389;
  v390 = (char *)__p[1];
  if (__p[1] >= (void *)v519)
  {
    v392 = (char *)__p[0];
    v393 = (char *)__p[1] - (char *)__p[0];
    v394 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v395 = v394 + 1;
    if ((unint64_t)(v394 + 1) >> 61)
      goto LABEL_615;
    v396 = v519 - (unint64_t)__p[0];
    if ((uint64_t)(v519 - (unint64_t)__p[0]) >> 2 > v395)
      v395 = v396 >> 2;
    if ((unint64_t)v396 >= 0x7FFFFFFFFFFFFFF8)
      v397 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v397 = v395;
    if (v397)
    {
      if (v397 >> 61)
        goto LABEL_616;
      v398 = (char *)operator new(8 * v397);
    }
    else
    {
      v398 = 0;
    }
    v399 = &v398[8 * v394];
    v400 = &v398[8 * v397];
    *(_QWORD *)v399 = v381;
    v391 = v399 + 8;
    if (v390 == v392)
    {
      __p[0] = &v398[8 * v394];
      __p[1] = v399 + 8;
      *(_QWORD *)&v519 = v400;
    }
    else
    {
      v401 = v390 - v392 - 8;
      if (v401 < 0x78
        || &v390[-(v401 & 0xFFFFFFFFFFFFFFF8) - 8] < v399 && &v398[v393 - (v401 & 0xFFFFFFFFFFFFFFF8) - 8] < v390)
      {
        goto LABEL_630;
      }
      v402 = (v401 >> 3) + 1;
      v403 = 8 * (v402 & 0x3FFFFFFFFFFFFFFCLL);
      v404 = &v390[-v403];
      v399 -= v403;
      v405 = &v398[8 * v394 - 16];
      v406 = v390 - 16;
      v407 = v402 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v409 = *((_OWORD *)v406 - 1);
        v408 = *(_OWORD *)v406;
        *((_OWORD *)v406 - 1) = 0uLL;
        *(_OWORD *)v406 = 0uLL;
        *((_OWORD *)v405 - 1) = v409;
        *(_OWORD *)v405 = v408;
        v405 -= 32;
        v406 -= 32;
        v407 -= 4;
      }
      while (v407);
      v390 = v404;
      if (v402 != (v402 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_630:
        do
        {
          v410 = *((_QWORD *)v390 - 1);
          v390 -= 8;
          *(_QWORD *)v390 = 0;
          *((_QWORD *)v399 - 1) = v410;
          v399 -= 8;
        }
        while (v390 != v392);
      }
      v390 = (char *)__p[0];
      v411 = (char *)__p[1];
      __p[0] = v399;
      __p[1] = v391;
      *(_QWORD *)&v519 = v400;
      while (v411 != v390)
      {
        v413 = *((_QWORD *)v411 - 1);
        v411 -= 8;
        v412 = v413;
        *(_QWORD *)v411 = 0;
        if (v413)
          (*(void (**)(uint64_t))(*(_QWORD *)v412 + 8))(v412);
      }
    }
    if (v390)
      operator delete(v390);
  }
  else
  {
    *(_QWORD *)__p[1] = v381;
    v391 = v390 + 8;
  }
  __p[1] = v391;
  v414 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v515, 1);
  mlir::Pattern::Pattern((uint64_t)(v414 + 1), (uint64_t)"mps.dequantize", 14, (__int16)v515, (uint64_t)Context, 0, 0);
  v414[12] = 0;
  *v414 = off_1E0E49400;
  if (!v414[9])
  {
    v515 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerDequantizeND]";
    v516 = 101;
    v415 = llvm::StringRef::find((uint64_t *)&v515, "DesiredTypeName = ", 0x12uLL, 0);
    if (v516 >= v415)
      v416 = v415;
    else
      v416 = v516;
    v417 = &v515[v416];
    v418 = v516 - v416;
    if (v516 - v416 >= 0x12)
      v419 = 18;
    else
      v419 = v516 - v416;
    v420 = &v417[v419];
    v421 = v418 - v419;
    if (v421 >= v421 - 1)
      --v421;
    v414[8] = v420;
    v414[9] = v421;
  }
  v422 = *((unsigned int *)v414 + 22);
  if (v422 > *((_DWORD *)v414 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v414 + 10), v414 + 12, v422, 16);
    LODWORD(v422) = *((_DWORD *)v414 + 22);
  }
  *((_DWORD *)v414 + 22) = v422;
  v423 = (char *)__p[1];
  if (__p[1] >= (void *)v519)
  {
    v425 = (char *)__p[0];
    v426 = (char *)__p[1] - (char *)__p[0];
    v427 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v428 = v427 + 1;
    if ((unint64_t)(v427 + 1) >> 61)
      goto LABEL_615;
    v429 = v519 - (unint64_t)__p[0];
    if ((uint64_t)(v519 - (unint64_t)__p[0]) >> 2 > v428)
      v428 = v429 >> 2;
    if ((unint64_t)v429 >= 0x7FFFFFFFFFFFFFF8)
      v430 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v430 = v428;
    if (v430)
    {
      if (v430 >> 61)
        goto LABEL_616;
      v431 = (char *)operator new(8 * v430);
    }
    else
    {
      v431 = 0;
    }
    v432 = &v431[8 * v427];
    v433 = &v431[8 * v430];
    *(_QWORD *)v432 = v414;
    v424 = v432 + 8;
    if (v423 == v425)
    {
      __p[0] = &v431[8 * v427];
      __p[1] = v432 + 8;
      *(_QWORD *)&v519 = v433;
    }
    else
    {
      v434 = v423 - v425 - 8;
      if (v434 < 0x78
        || &v423[-(v434 & 0xFFFFFFFFFFFFFFF8) - 8] < v432 && &v431[v426 - (v434 & 0xFFFFFFFFFFFFFFF8) - 8] < v423)
      {
        goto LABEL_631;
      }
      v435 = (v434 >> 3) + 1;
      v436 = 8 * (v435 & 0x3FFFFFFFFFFFFFFCLL);
      v437 = &v423[-v436];
      v432 -= v436;
      v438 = &v431[8 * v427 - 16];
      v439 = v423 - 16;
      v440 = v435 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v442 = *((_OWORD *)v439 - 1);
        v441 = *(_OWORD *)v439;
        *((_OWORD *)v439 - 1) = 0uLL;
        *(_OWORD *)v439 = 0uLL;
        *((_OWORD *)v438 - 1) = v442;
        *(_OWORD *)v438 = v441;
        v438 -= 32;
        v439 -= 32;
        v440 -= 4;
      }
      while (v440);
      v423 = v437;
      if (v435 != (v435 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_631:
        do
        {
          v443 = *((_QWORD *)v423 - 1);
          v423 -= 8;
          *(_QWORD *)v423 = 0;
          *((_QWORD *)v432 - 1) = v443;
          v432 -= 8;
        }
        while (v423 != v425);
      }
      v423 = (char *)__p[0];
      v444 = (char *)__p[1];
      __p[0] = v432;
      __p[1] = v424;
      *(_QWORD *)&v519 = v433;
      while (v444 != v423)
      {
        v446 = *((_QWORD *)v444 - 1);
        v444 -= 8;
        v445 = v446;
        *(_QWORD *)v444 = 0;
        if (v446)
          (*(void (**)(uint64_t))(*(_QWORD *)v445 + 8))(v445);
      }
    }
    if (v423)
      operator delete(v423);
  }
  else
  {
    *(_QWORD *)__p[1] = v414;
    v424 = v423 + 8;
  }
  __p[1] = v424;
  v447 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v515, 1);
  mlir::Pattern::Pattern((uint64_t)(v447 + 1), (uint64_t)"mps.dequantize", 14, (__int16)v515, (uint64_t)Context, 0, 0);
  v447[12] = 0;
  *v447 = off_1E0E4A318;
  if (!v447[9])
  {
    v515 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerPerAxisDequantize]";
    v516 = 106;
    v448 = llvm::StringRef::find((uint64_t *)&v515, "DesiredTypeName = ", 0x12uLL, 0);
    if (v516 >= v448)
      v449 = v448;
    else
      v449 = v516;
    v450 = &v515[v449];
    v451 = v516 - v449;
    if (v516 - v449 >= 0x12)
      v452 = 18;
    else
      v452 = v516 - v449;
    v453 = &v450[v452];
    v454 = v451 - v452;
    if (v454 >= v454 - 1)
      --v454;
    v447[8] = v453;
    v447[9] = v454;
  }
  v455 = *((unsigned int *)v447 + 22);
  if (v455 > *((_DWORD *)v447 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v447 + 10), v447 + 12, v455, 16);
    LODWORD(v455) = *((_DWORD *)v447 + 22);
  }
  *((_DWORD *)v447 + 22) = v455;
  v456 = (char *)__p[1];
  if (__p[1] >= (void *)v519)
  {
    v458 = (char *)__p[0];
    v459 = (char *)__p[1] - (char *)__p[0];
    v460 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v461 = v460 + 1;
    if ((unint64_t)(v460 + 1) >> 61)
      goto LABEL_615;
    v462 = v519 - (unint64_t)__p[0];
    if ((uint64_t)(v519 - (unint64_t)__p[0]) >> 2 > v461)
      v461 = v462 >> 2;
    if ((unint64_t)v462 >= 0x7FFFFFFFFFFFFFF8)
      v463 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v463 = v461;
    if (v463)
    {
      if (v463 >> 61)
        goto LABEL_616;
      v464 = (char *)operator new(8 * v463);
    }
    else
    {
      v464 = 0;
    }
    v465 = &v464[8 * v460];
    v466 = &v464[8 * v463];
    *(_QWORD *)v465 = v447;
    v457 = v465 + 8;
    if (v456 == v458)
    {
      __p[0] = &v464[8 * v460];
      __p[1] = v465 + 8;
      *(_QWORD *)&v519 = v466;
    }
    else
    {
      v467 = v456 - v458 - 8;
      if (v467 < 0x78
        || &v456[-(v467 & 0xFFFFFFFFFFFFFFF8) - 8] < v465 && &v464[v459 - (v467 & 0xFFFFFFFFFFFFFFF8) - 8] < v456)
      {
        goto LABEL_632;
      }
      v468 = (v467 >> 3) + 1;
      v469 = 8 * (v468 & 0x3FFFFFFFFFFFFFFCLL);
      v470 = &v456[-v469];
      v465 -= v469;
      v471 = &v464[8 * v460 - 16];
      v472 = v456 - 16;
      v473 = v468 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v475 = *((_OWORD *)v472 - 1);
        v474 = *(_OWORD *)v472;
        *((_OWORD *)v472 - 1) = 0uLL;
        *(_OWORD *)v472 = 0uLL;
        *((_OWORD *)v471 - 1) = v475;
        *(_OWORD *)v471 = v474;
        v471 -= 32;
        v472 -= 32;
        v473 -= 4;
      }
      while (v473);
      v456 = v470;
      if (v468 != (v468 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_632:
        do
        {
          v476 = *((_QWORD *)v456 - 1);
          v456 -= 8;
          *(_QWORD *)v456 = 0;
          *((_QWORD *)v465 - 1) = v476;
          v465 -= 8;
        }
        while (v456 != v458);
      }
      v456 = (char *)__p[0];
      v477 = (char *)__p[1];
      __p[0] = v465;
      __p[1] = v457;
      *(_QWORD *)&v519 = v466;
      while (v477 != v456)
      {
        v479 = *((_QWORD *)v477 - 1);
        v477 -= 8;
        v478 = v479;
        *(_QWORD *)v477 = 0;
        if (v479)
          (*(void (**)(uint64_t))(*(_QWORD *)v478 + 8))(v478);
      }
    }
    if (v456)
      operator delete(v456);
  }
  else
  {
    *(_QWORD *)__p[1] = v447;
    v457 = v456 + 8;
  }
  __p[1] = v457;
  v480 = operator new(0x68uLL);
  mlir::PatternBenefit::PatternBenefit(&v515, 1);
  mlir::Pattern::Pattern((uint64_t)(v480 + 1), (uint64_t)"mpsx.quantized_matmul", 21, (__int16)v515, (uint64_t)Context, 0, 0);
  v480[12] = 0;
  *v480 = off_1E0E49D68;
  if (!v480[9])
  {
    v515 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::LowerQuantizedMatmul]";
    v516 = 104;
    v481 = llvm::StringRef::find((uint64_t *)&v515, "DesiredTypeName = ", 0x12uLL, 0);
    if (v516 >= v481)
      v482 = v481;
    else
      v482 = v516;
    v483 = &v515[v482];
    v484 = v516 - v482;
    if (v516 - v482 >= 0x12)
      v485 = 18;
    else
      v485 = v516 - v482;
    v486 = &v483[v485];
    v487 = v484 - v485;
    if (v487 >= v487 - 1)
      --v487;
    v480[8] = v486;
    v480[9] = v487;
  }
  v488 = *((unsigned int *)v480 + 22);
  if (v488 > *((_DWORD *)v480 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v480 + 10), v480 + 12, v488, 16);
    LODWORD(v488) = *((_DWORD *)v480 + 22);
  }
  *((_DWORD *)v480 + 22) = v488;
  v489 = (char *)__p[1];
  if (__p[1] < (void *)v519)
  {
    *(_QWORD *)__p[1] = v480;
    v490 = v489 + 8;
    goto LABEL_613;
  }
  v491 = (char *)__p[0];
  v492 = (char *)__p[1] - (char *)__p[0];
  v493 = ((char *)__p[1] - (char *)__p[0]) >> 3;
  v494 = v493 + 1;
  if (!((unint64_t)(v493 + 1) >> 61))
  {
    v495 = v519 - (unint64_t)__p[0];
    if ((uint64_t)(v519 - (unint64_t)__p[0]) >> 2 > v494)
      v494 = v495 >> 2;
    if ((unint64_t)v495 >= 0x7FFFFFFFFFFFFFF8)
      v496 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v496 = v494;
    if (!v496)
    {
      v497 = 0;
      goto LABEL_598;
    }
    if (!(v496 >> 61))
    {
      v497 = (char *)operator new(8 * v496);
LABEL_598:
      v498 = &v497[8 * v493];
      v499 = &v497[8 * v496];
      *(_QWORD *)v498 = v480;
      v490 = v498 + 8;
      if (v489 == v491)
      {
        __p[0] = &v497[8 * v493];
        __p[1] = v498 + 8;
        *(_QWORD *)&v519 = v499;
      }
      else
      {
        v500 = v489 - v491 - 8;
        if (v500 < 0x78
          || &v489[-(v500 & 0xFFFFFFFFFFFFFFF8) - 8] < v498 && &v497[v492 - (v500 & 0xFFFFFFFFFFFFFFF8) - 8] < v489)
        {
          goto LABEL_633;
        }
        v501 = (v500 >> 3) + 1;
        v502 = 8 * (v501 & 0x3FFFFFFFFFFFFFFCLL);
        v503 = &v489[-v502];
        v498 -= v502;
        v504 = &v497[8 * v493 - 16];
        v505 = v489 - 16;
        v506 = v501 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v508 = *((_OWORD *)v505 - 1);
          v507 = *(_OWORD *)v505;
          *((_OWORD *)v505 - 1) = 0uLL;
          *(_OWORD *)v505 = 0uLL;
          *((_OWORD *)v504 - 1) = v508;
          *(_OWORD *)v504 = v507;
          v504 -= 32;
          v505 -= 32;
          v506 -= 4;
        }
        while (v506);
        v489 = v503;
        if (v501 != (v501 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_633:
          do
          {
            v509 = *((_QWORD *)v489 - 1);
            v489 -= 8;
            *(_QWORD *)v489 = 0;
            *((_QWORD *)v498 - 1) = v509;
            v498 -= 8;
          }
          while (v489 != v491);
        }
        v489 = (char *)__p[0];
        v510 = (char *)__p[1];
        __p[0] = v498;
        __p[1] = v490;
        *(_QWORD *)&v519 = v499;
        while (v510 != v489)
        {
          v512 = *((_QWORD *)v510 - 1);
          v510 -= 8;
          v511 = v512;
          *(_QWORD *)v510 = 0;
          if (v512)
            (*(void (**)(uint64_t))(*(_QWORD *)v511 + 8))(v511);
        }
      }
      if (v489)
        operator delete(v489);
LABEL_613:
      __p[1] = v490;
      mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(&v515, &v517, 0, 0, 0, 0);
      mlir::applyFullConversion(a2, (mlir::Operation *)v548, (const mlir::ConversionTarget *)&v515, v513);
    }
LABEL_616:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_615:
  abort();
}

void mlir::mps::`anonymous namespace'::populateWithGenerated(uint64_t *a1)
{
  uint64_t v2;
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  _QWORD *v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  char *v47;
  _QWORD *v48;
  char *v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  char *v55;
  char *v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  char *v61;
  char *v62;
  uint64_t v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;
  char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD *v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  char *v81;
  _QWORD *v82;
  char *v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  char *v88;
  char *v89;
  char *v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  char *v94;
  char *v95;
  char *v96;
  uint64_t v97;
  __int128 v98;
  __int128 v99;
  uint64_t v100;
  char *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  _QWORD *v105;
  unint64_t v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  uint64_t v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  char *v115;
  _QWORD *v116;
  char *v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  unint64_t v121;
  char *v122;
  char *v123;
  char *v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  char *v128;
  char *v129;
  char *v130;
  uint64_t v131;
  __int128 v132;
  __int128 v133;
  uint64_t v134;
  char *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  _QWORD *v139;
  unint64_t v140;
  unint64_t v141;
  uint64_t v142;
  unint64_t v143;
  uint64_t v144;
  uint64_t v145;
  unint64_t v146;
  unint64_t v147;
  unint64_t v148;
  char *v149;
  _QWORD *v150;
  char *v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t v154;
  unint64_t v155;
  char *v156;
  char *v157;
  char *v158;
  unint64_t v159;
  uint64_t v160;
  uint64_t v161;
  char *v162;
  char *v163;
  char *v164;
  uint64_t v165;
  __int128 v166;
  __int128 v167;
  uint64_t v168;
  char *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  _QWORD *v173;
  unint64_t v174;
  unint64_t v175;
  uint64_t v176;
  unint64_t v177;
  uint64_t v178;
  uint64_t v179;
  unint64_t v180;
  unint64_t v181;
  unint64_t v182;
  char *v183;
  _QWORD *v184;
  char *v185;
  uint64_t v186;
  unint64_t v187;
  uint64_t v188;
  unint64_t v189;
  char *v190;
  char *v191;
  char *v192;
  unint64_t v193;
  uint64_t v194;
  uint64_t v195;
  char *v196;
  char *v197;
  char *v198;
  uint64_t v199;
  __int128 v200;
  __int128 v201;
  uint64_t v202;
  char *v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  _QWORD *v207;
  unint64_t v208;
  unint64_t v209;
  uint64_t v210;
  unint64_t v211;
  uint64_t v212;
  uint64_t v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  char *v217;
  _QWORD *v218;
  char *v219;
  uint64_t v220;
  unint64_t v221;
  uint64_t v222;
  unint64_t v223;
  char *v224;
  char *v225;
  char *v226;
  unint64_t v227;
  uint64_t v228;
  uint64_t v229;
  char *v230;
  char *v231;
  char *v232;
  uint64_t v233;
  __int128 v234;
  __int128 v235;
  uint64_t v236;
  char *v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  _QWORD *v241;
  unint64_t v242;
  unint64_t v243;
  uint64_t v244;
  unint64_t v245;
  uint64_t v246;
  uint64_t v247;
  unint64_t v248;
  unint64_t v249;
  unint64_t v250;
  char *v251;
  _QWORD *v252;
  char *v253;
  uint64_t v254;
  unint64_t v255;
  uint64_t v256;
  unint64_t v257;
  char *v258;
  char *v259;
  char *v260;
  unint64_t v261;
  uint64_t v262;
  uint64_t v263;
  char *v264;
  char *v265;
  char *v266;
  uint64_t v267;
  __int128 v268;
  __int128 v269;
  uint64_t v270;
  char *v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  _QWORD *v275;
  unint64_t v276;
  unint64_t v277;
  uint64_t v278;
  unint64_t v279;
  uint64_t v280;
  uint64_t v281;
  unint64_t v282;
  unint64_t v283;
  unint64_t v284;
  char *v285;
  _QWORD *v286;
  char *v287;
  uint64_t v288;
  unint64_t v289;
  uint64_t v290;
  unint64_t v291;
  char *v292;
  char *v293;
  char *v294;
  unint64_t v295;
  uint64_t v296;
  uint64_t v297;
  char *v298;
  char *v299;
  char *v300;
  uint64_t v301;
  __int128 v302;
  __int128 v303;
  uint64_t v304;
  char *v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  _QWORD *v309;
  unint64_t v310;
  unint64_t v311;
  uint64_t v312;
  unint64_t v313;
  uint64_t v314;
  uint64_t v315;
  unint64_t v316;
  unint64_t v317;
  unint64_t v318;
  char *v319;
  _QWORD *v320;
  char *v321;
  uint64_t v322;
  unint64_t v323;
  uint64_t v324;
  unint64_t v325;
  char *v326;
  char *v327;
  char *v328;
  unint64_t v329;
  uint64_t v330;
  uint64_t v331;
  char *v332;
  char *v333;
  char *v334;
  uint64_t v335;
  __int128 v336;
  __int128 v337;
  uint64_t v338;
  char *v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  _QWORD *v343;
  unint64_t v344;
  unint64_t v345;
  uint64_t v346;
  unint64_t v347;
  uint64_t v348;
  uint64_t v349;
  unint64_t v350;
  unint64_t v351;
  unint64_t v352;
  char *v353;
  _QWORD *v354;
  char *v355;
  uint64_t v356;
  unint64_t v357;
  uint64_t v358;
  unint64_t v359;
  char *v360;
  char *v361;
  char *v362;
  unint64_t v363;
  uint64_t v364;
  uint64_t v365;
  char *v366;
  char *v367;
  char *v368;
  uint64_t v369;
  __int128 v370;
  __int128 v371;
  uint64_t v372;
  char *v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  _QWORD *v377;
  unint64_t v378;
  unint64_t v379;
  uint64_t v380;
  unint64_t v381;
  uint64_t v382;
  uint64_t v383;
  unint64_t v384;
  unint64_t v385;
  unint64_t v386;
  char *v387;
  _QWORD *v388;
  char *v389;
  uint64_t v390;
  unint64_t v391;
  uint64_t v392;
  unint64_t v393;
  char *v394;
  char *v395;
  char *v396;
  unint64_t v397;
  uint64_t v398;
  uint64_t v399;
  char *v400;
  char *v401;
  char *v402;
  uint64_t v403;
  __int128 v404;
  __int128 v405;
  uint64_t v406;
  char *v407;
  uint64_t v408;
  uint64_t v409;
  uint64_t v410;
  _QWORD *v411;
  unint64_t v412;
  unint64_t v413;
  uint64_t v414;
  unint64_t v415;
  uint64_t v416;
  uint64_t v417;
  unint64_t v418;
  unint64_t v419;
  unint64_t v420;
  char *v421;
  _QWORD *v422;
  char *v423;
  uint64_t v424;
  unint64_t v425;
  uint64_t v426;
  unint64_t v427;
  char *v428;
  char *v429;
  char *v430;
  unint64_t v431;
  uint64_t v432;
  uint64_t v433;
  char *v434;
  char *v435;
  char *v436;
  uint64_t v437;
  __int128 v438;
  __int128 v439;
  uint64_t v440;
  char *v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  _QWORD *v445;
  unint64_t v446;
  unint64_t v447;
  uint64_t v448;
  unint64_t v449;
  uint64_t v450;
  uint64_t v451;
  unint64_t v452;
  unint64_t v453;
  unint64_t v454;
  char *v455;
  _QWORD *v456;
  char *v457;
  uint64_t v458;
  unint64_t v459;
  uint64_t v460;
  unint64_t v461;
  char *v462;
  char *v463;
  char *v464;
  unint64_t v465;
  uint64_t v466;
  uint64_t v467;
  char *v468;
  char *v469;
  char *v470;
  uint64_t v471;
  __int128 v472;
  __int128 v473;
  uint64_t v474;
  char *v475;
  uint64_t v476;
  uint64_t v477;
  uint64_t v478;
  _QWORD *v479;
  unint64_t v480;
  unint64_t v481;
  uint64_t v482;
  unint64_t v483;
  uint64_t v484;
  uint64_t v485;
  unint64_t v486;
  unint64_t v487;
  unint64_t v488;
  char *v489;
  _QWORD *v490;
  char *v491;
  uint64_t v492;
  unint64_t v493;
  uint64_t v494;
  unint64_t v495;
  char *v496;
  char *v497;
  char *v498;
  unint64_t v499;
  uint64_t v500;
  uint64_t v501;
  char *v502;
  char *v503;
  char *v504;
  uint64_t v505;
  __int128 v506;
  __int128 v507;
  uint64_t v508;
  char *v509;
  uint64_t v510;
  uint64_t v511;
  uint64_t v512;
  _QWORD *v513;
  unint64_t v514;
  unint64_t v515;
  uint64_t v516;
  unint64_t v517;
  uint64_t v518;
  uint64_t v519;
  unint64_t v520;
  unint64_t v521;
  unint64_t v522;
  char *v523;
  _QWORD *v524;
  char *v525;
  uint64_t v526;
  unint64_t v527;
  uint64_t v528;
  unint64_t v529;
  char *v530;
  char *v531;
  char *v532;
  unint64_t v533;
  uint64_t v534;
  uint64_t v535;
  char *v536;
  char *v537;
  char *v538;
  uint64_t v539;
  __int128 v540;
  __int128 v541;
  uint64_t v542;
  char *v543;
  uint64_t v544;
  uint64_t v545;
  uint64_t v546;
  _QWORD *v547;
  unint64_t v548;
  unint64_t v549;
  uint64_t v550;
  unint64_t v551;
  uint64_t v552;
  uint64_t v553;
  unint64_t v554;
  unint64_t v555;
  unint64_t v556;
  char *v557;
  _QWORD *v558;
  char *v559;
  uint64_t v560;
  unint64_t v561;
  uint64_t v562;
  unint64_t v563;
  char *v564;
  char *v565;
  char *v566;
  unint64_t v567;
  uint64_t v568;
  uint64_t v569;
  char *v570;
  char *v571;
  char *v572;
  uint64_t v573;
  __int128 v574;
  __int128 v575;
  uint64_t v576;
  char *v577;
  uint64_t v578;
  uint64_t v579;
  uint64_t v580;
  _QWORD *v581;
  unint64_t v582;
  unint64_t v583;
  uint64_t v584;
  unint64_t v585;
  uint64_t v586;
  uint64_t v587;
  unint64_t v588;
  unint64_t v589;
  unint64_t v590;
  char *v591;
  _QWORD *v592;
  char *v593;
  uint64_t v594;
  unint64_t v595;
  uint64_t v596;
  unint64_t v597;
  char *v598;
  char *v599;
  char *v600;
  unint64_t v601;
  uint64_t v602;
  uint64_t v603;
  char *v604;
  char *v605;
  char *v606;
  uint64_t v607;
  __int128 v608;
  __int128 v609;
  uint64_t v610;
  char *v611;
  uint64_t v612;
  uint64_t v613;
  uint64_t v614;
  _QWORD *v615;
  unint64_t v616;
  unint64_t v617;
  uint64_t v618;
  unint64_t v619;
  uint64_t v620;
  uint64_t v621;
  unint64_t v622;
  unint64_t v623;
  unint64_t v624;
  char *v625;
  _QWORD *v626;
  char *v627;
  uint64_t v628;
  unint64_t v629;
  uint64_t v630;
  unint64_t v631;
  char *v632;
  char *v633;
  char *v634;
  unint64_t v635;
  uint64_t v636;
  uint64_t v637;
  char *v638;
  char *v639;
  char *v640;
  uint64_t v641;
  __int128 v642;
  __int128 v643;
  uint64_t v644;
  char *v645;
  uint64_t v646;
  uint64_t v647;
  uint64_t v648;
  _QWORD *v649;
  unint64_t v650;
  unint64_t v651;
  uint64_t v652;
  unint64_t v653;
  uint64_t v654;
  uint64_t v655;
  unint64_t v656;
  unint64_t v657;
  unint64_t v658;
  char *v659;
  _QWORD *v660;
  char *v661;
  uint64_t v662;
  unint64_t v663;
  uint64_t v664;
  unint64_t v665;
  char *v666;
  char *v667;
  char *v668;
  unint64_t v669;
  uint64_t v670;
  uint64_t v671;
  char *v672;
  char *v673;
  char *v674;
  uint64_t v675;
  __int128 v676;
  __int128 v677;
  uint64_t v678;
  char *v679;
  uint64_t v680;
  uint64_t v681;
  uint64_t v682;
  _QWORD *v683;
  unint64_t v684;
  unint64_t v685;
  uint64_t v686;
  unint64_t v687;
  uint64_t v688;
  uint64_t v689;
  unint64_t v690;
  unint64_t v691;
  unint64_t v692;
  char *v693;
  _QWORD *v694;
  char *v695;
  uint64_t v696;
  unint64_t v697;
  uint64_t v698;
  unint64_t v699;
  char *v700;
  char *v701;
  char *v702;
  unint64_t v703;
  uint64_t v704;
  uint64_t v705;
  char *v706;
  char *v707;
  char *v708;
  uint64_t v709;
  __int128 v710;
  __int128 v711;
  uint64_t v712;
  char *v713;
  uint64_t v714;
  uint64_t v715;
  uint64_t v716;
  _QWORD *v717;
  unint64_t v718;
  unint64_t v719;
  uint64_t v720;
  unint64_t v721;
  uint64_t v722;
  uint64_t v723;
  unint64_t v724;
  unint64_t v725;
  unint64_t v726;
  char *v727;
  _QWORD *v728;
  char *v729;
  uint64_t v730;
  unint64_t v731;
  uint64_t v732;
  unint64_t v733;
  char *v734;
  char *v735;
  char *v736;
  unint64_t v737;
  uint64_t v738;
  uint64_t v739;
  char *v740;
  char *v741;
  char *v742;
  uint64_t v743;
  __int128 v744;
  __int128 v745;
  uint64_t v746;
  char *v747;
  uint64_t v748;
  uint64_t v749;
  uint64_t v750;
  _QWORD *v751;
  unint64_t v752;
  unint64_t v753;
  uint64_t v754;
  unint64_t v755;
  uint64_t v756;
  uint64_t v757;
  unint64_t v758;
  unint64_t v759;
  unint64_t v760;
  char *v761;
  _QWORD *v762;
  char *v763;
  uint64_t v764;
  unint64_t v765;
  uint64_t v766;
  unint64_t v767;
  char *v768;
  char *v769;
  char *v770;
  unint64_t v771;
  uint64_t v772;
  uint64_t v773;
  char *v774;
  char *v775;
  char *v776;
  uint64_t v777;
  __int128 v778;
  __int128 v779;
  uint64_t v780;
  char *v781;
  uint64_t v782;
  uint64_t v783;
  uint64_t v784;
  _QWORD *v785;
  unint64_t v786;
  unint64_t v787;
  uint64_t v788;
  unint64_t v789;
  uint64_t v790;
  uint64_t v791;
  unint64_t v792;
  unint64_t v793;
  unint64_t v794;
  char *v795;
  _QWORD *v796;
  char *v797;
  uint64_t v798;
  unint64_t v799;
  uint64_t v800;
  unint64_t v801;
  char *v802;
  char *v803;
  char *v804;
  unint64_t v805;
  uint64_t v806;
  uint64_t v807;
  char *v808;
  char *v809;
  char *v810;
  uint64_t v811;
  __int128 v812;
  __int128 v813;
  uint64_t v814;
  char *v815;
  uint64_t v816;
  uint64_t v817;
  uint64_t v818;
  _QWORD *v819;
  unint64_t v820;
  unint64_t v821;
  uint64_t v822;
  unint64_t v823;
  uint64_t v824;
  uint64_t v825;
  unint64_t v826;
  unint64_t v827;
  unint64_t v828;
  char *v829;
  _QWORD *v830;
  char *v831;
  uint64_t v832;
  unint64_t v833;
  uint64_t v834;
  unint64_t v835;
  char *v836;
  char *v837;
  char *v838;
  unint64_t v839;
  uint64_t v840;
  uint64_t v841;
  char *v842;
  char *v843;
  char *v844;
  uint64_t v845;
  __int128 v846;
  __int128 v847;
  uint64_t v848;
  char *v849;
  uint64_t v850;
  uint64_t v851;
  uint64_t v852;
  _QWORD *v853;
  unint64_t v854;
  unint64_t v855;
  uint64_t v856;
  unint64_t v857;
  uint64_t v858;
  uint64_t v859;
  unint64_t v860;
  unint64_t v861;
  unint64_t v862;
  char *v863;
  _QWORD *v864;
  char *v865;
  uint64_t v866;
  unint64_t v867;
  uint64_t v868;
  unint64_t v869;
  char *v870;
  char *v871;
  char *v872;
  unint64_t v873;
  uint64_t v874;
  uint64_t v875;
  char *v876;
  char *v877;
  char *v878;
  uint64_t v879;
  __int128 v880;
  __int128 v881;
  uint64_t v882;
  char *v883;
  uint64_t v884;
  uint64_t v885;
  uint64_t v886;
  _QWORD *v887;
  unint64_t v888;
  unint64_t v889;
  uint64_t v890;
  unint64_t v891;
  uint64_t v892;
  uint64_t v893;
  unint64_t v894;
  unint64_t v895;
  unint64_t v896;
  char *v897;
  _QWORD *v898;
  char *v899;
  uint64_t v900;
  unint64_t v901;
  uint64_t v902;
  unint64_t v903;
  char *v904;
  char *v905;
  char *v906;
  unint64_t v907;
  uint64_t v908;
  uint64_t v909;
  char *v910;
  char *v911;
  char *v912;
  uint64_t v913;
  __int128 v914;
  __int128 v915;
  uint64_t v916;
  char *v917;
  uint64_t v918;
  uint64_t v919;
  __int16 v920;
  __int128 v921;
  __int128 v922;
  __int128 v923;
  __int128 v924;
  __int128 v925;
  __int128 v926;
  __int128 v927;
  __int128 v928;
  uint64_t v929;

  v929 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v3 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E54348;
  v922 = *(_OWORD *)&off_1E0E54358;
  mlir::Pattern::Pattern((uint64_t)(v3 + 1), (uint64_t)"mps.bias_add", 12, v920, v2, &v921, 2uLL);
  *v3 = off_1E0E49DD0;
  if (!v3[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerBiasAddNHWC]";
    *((_QWORD *)&v921 + 1) = 104;
    v4 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v4)
      v5 = v4;
    else
      v5 = *((_QWORD *)&v921 + 1);
    v6 = v921 + v5;
    v7 = *((_QWORD *)&v921 + 1) - v5;
    if (*((_QWORD *)&v921 + 1) - v5 >= 0x12)
      v8 = 18;
    else
      v8 = *((_QWORD *)&v921 + 1) - v5;
    v9 = v6 + v8;
    v10 = v7 - v8;
    if (v10 >= v10 - 1)
      --v10;
    v3[8] = v9;
    v3[9] = v10;
  }
  v11 = *((unsigned int *)v3 + 22);
  if (v11 > *((_DWORD *)v3 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v3 + 10), v3 + 12, v11, 16);
    LODWORD(v11) = *((_DWORD *)v3 + 22);
  }
  *((_DWORD *)v3 + 22) = v11;
  v13 = (char *)a1[2];
  v12 = a1[3];
  if ((unint64_t)v13 >= v12)
  {
    v15 = (char *)a1[1];
    v16 = (v13 - v15) >> 3;
    v17 = v16 + 1;
    if ((unint64_t)(v16 + 1) >> 61)
      goto LABEL_1055;
    v18 = v12 - (_QWORD)v15;
    if (v18 >> 2 > v17)
      v17 = v18 >> 2;
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
      v19 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v19 = v17;
    if (v19)
    {
      if (v19 >> 61)
        goto LABEL_1056;
      v20 = (char *)operator new(8 * v19);
    }
    else
    {
      v20 = 0;
    }
    v21 = &v20[8 * v16];
    v22 = &v20[8 * v19];
    *(_QWORD *)v21 = v3;
    v14 = v21 + 8;
    if (v13 == v15)
    {
      a1[1] = (uint64_t)v21;
      a1[2] = (uint64_t)v14;
      a1[3] = (uint64_t)v22;
    }
    else
    {
      v23 = v13 - v15 - 8;
      if (v23 < 0x78
        || &v13[-(v23 & 0xFFFFFFFFFFFFFFF8) - 8] < v21 && &v20[v13 - v15 - (v23 & 0xFFFFFFFFFFFFFFF8) - 8] < v13)
      {
        goto LABEL_1059;
      }
      v24 = (v23 >> 3) + 1;
      v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
      v26 = &v13[-v25];
      v21 -= v25;
      v27 = &v20[8 * v16 - 16];
      v28 = v13 - 16;
      v29 = v24 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v31 = *((_OWORD *)v28 - 1);
        v30 = *(_OWORD *)v28;
        *((_OWORD *)v28 - 1) = 0uLL;
        *(_OWORD *)v28 = 0uLL;
        *((_OWORD *)v27 - 1) = v31;
        *(_OWORD *)v27 = v30;
        v27 -= 32;
        v28 -= 32;
        v29 -= 4;
      }
      while (v29);
      v13 = v26;
      if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1059:
        do
        {
          v32 = *((_QWORD *)v13 - 1);
          v13 -= 8;
          *(_QWORD *)v13 = 0;
          *((_QWORD *)v21 - 1) = v32;
          v21 -= 8;
        }
        while (v13 != v15);
      }
      v13 = (char *)a1[1];
      v33 = (char *)a1[2];
      a1[1] = (uint64_t)v21;
      a1[2] = (uint64_t)v14;
      a1[3] = (uint64_t)v22;
      while (v33 != v13)
      {
        v35 = *((_QWORD *)v33 - 1);
        v33 -= 8;
        v34 = v35;
        *(_QWORD *)v33 = 0;
        if (v35)
          (*(void (**)(uint64_t))(*(_QWORD *)v34 + 8))(v34);
      }
    }
    if (v13)
      operator delete(v13);
  }
  else
  {
    *(_QWORD *)v13 = v3;
    v14 = v13 + 8;
  }
  a1[2] = (uint64_t)v14;
  v36 = *a1;
  v37 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  *(_QWORD *)&v921 = "mps.power";
  *((_QWORD *)&v921 + 1) = 9;
  mlir::Pattern::Pattern((uint64_t)(v37 + 1), (uint64_t)"mps.degamma", 11, v920, v36, &v921, 1uLL);
  *v37 = off_1E0E49260;
  if (!v37[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerDegamma]";
    *((_QWORD *)&v921 + 1) = 100;
    v38 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v38)
      v39 = v38;
    else
      v39 = *((_QWORD *)&v921 + 1);
    v40 = v921 + v39;
    v41 = *((_QWORD *)&v921 + 1) - v39;
    if (*((_QWORD *)&v921 + 1) - v39 >= 0x12)
      v42 = 18;
    else
      v42 = *((_QWORD *)&v921 + 1) - v39;
    v43 = v40 + v42;
    v44 = v41 - v42;
    if (v44 >= v44 - 1)
      --v44;
    v37[8] = v43;
    v37[9] = v44;
  }
  v45 = *((unsigned int *)v37 + 22);
  if (v45 > *((_DWORD *)v37 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v37 + 10), v37 + 12, v45, 16);
    LODWORD(v45) = *((_DWORD *)v37 + 22);
  }
  *((_DWORD *)v37 + 22) = v45;
  v47 = (char *)a1[2];
  v46 = a1[3];
  if ((unint64_t)v47 >= v46)
  {
    v49 = (char *)a1[1];
    v50 = (v47 - v49) >> 3;
    v51 = v50 + 1;
    if ((unint64_t)(v50 + 1) >> 61)
      goto LABEL_1055;
    v52 = v46 - (_QWORD)v49;
    if (v52 >> 2 > v51)
      v51 = v52 >> 2;
    if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8)
      v53 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v53 = v51;
    if (v53)
    {
      if (v53 >> 61)
        goto LABEL_1056;
      v54 = (char *)operator new(8 * v53);
    }
    else
    {
      v54 = 0;
    }
    v55 = &v54[8 * v50];
    v56 = &v54[8 * v53];
    *(_QWORD *)v55 = v37;
    v48 = v55 + 8;
    if (v47 == v49)
    {
      a1[1] = (uint64_t)v55;
      a1[2] = (uint64_t)v48;
      a1[3] = (uint64_t)v56;
    }
    else
    {
      v57 = v47 - v49 - 8;
      if (v57 < 0x78
        || &v47[-(v57 & 0xFFFFFFFFFFFFFFF8) - 8] < v55 && &v54[v47 - v49 - (v57 & 0xFFFFFFFFFFFFFFF8) - 8] < v47)
      {
        goto LABEL_1060;
      }
      v58 = (v57 >> 3) + 1;
      v59 = 8 * (v58 & 0x3FFFFFFFFFFFFFFCLL);
      v60 = &v47[-v59];
      v55 -= v59;
      v61 = &v54[8 * v50 - 16];
      v62 = v47 - 16;
      v63 = v58 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v65 = *((_OWORD *)v62 - 1);
        v64 = *(_OWORD *)v62;
        *((_OWORD *)v62 - 1) = 0uLL;
        *(_OWORD *)v62 = 0uLL;
        *((_OWORD *)v61 - 1) = v65;
        *(_OWORD *)v61 = v64;
        v61 -= 32;
        v62 -= 32;
        v63 -= 4;
      }
      while (v63);
      v47 = v60;
      if (v58 != (v58 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1060:
        do
        {
          v66 = *((_QWORD *)v47 - 1);
          v47 -= 8;
          *(_QWORD *)v47 = 0;
          *((_QWORD *)v55 - 1) = v66;
          v55 -= 8;
        }
        while (v47 != v49);
      }
      v47 = (char *)a1[1];
      v67 = (char *)a1[2];
      a1[1] = (uint64_t)v55;
      a1[2] = (uint64_t)v48;
      a1[3] = (uint64_t)v56;
      while (v67 != v47)
      {
        v69 = *((_QWORD *)v67 - 1);
        v67 -= 8;
        v68 = v69;
        *(_QWORD *)v67 = 0;
        if (v69)
          (*(void (**)(uint64_t))(*(_QWORD *)v68 + 8))(v68);
      }
    }
    if (v47)
      operator delete(v47);
  }
  else
  {
    *(_QWORD *)v47 = v37;
    v48 = v47 + 8;
  }
  a1[2] = (uint64_t)v48;
  v70 = *a1;
  v71 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E54368;
  v922 = *(_OWORD *)&off_1E0E54378;
  v923 = xmmword_1E0E54388;
  v924 = *(_OWORD *)&off_1E0E54398;
  mlir::Pattern::Pattern((uint64_t)(v71 + 1), (uint64_t)"mps.dequantize", 14, v920, v70, &v921, 4uLL);
  *v71 = off_1E0E49B48;
  if (!v71[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerDequantize]";
    *((_QWORD *)&v921 + 1) = 103;
    v72 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v72)
      v73 = v72;
    else
      v73 = *((_QWORD *)&v921 + 1);
    v74 = v921 + v73;
    v75 = *((_QWORD *)&v921 + 1) - v73;
    if (*((_QWORD *)&v921 + 1) - v73 >= 0x12)
      v76 = 18;
    else
      v76 = *((_QWORD *)&v921 + 1) - v73;
    v77 = v74 + v76;
    v78 = v75 - v76;
    if (v78 >= v78 - 1)
      --v78;
    v71[8] = v77;
    v71[9] = v78;
  }
  v79 = *((unsigned int *)v71 + 22);
  if (v79 > *((_DWORD *)v71 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v71 + 10), v71 + 12, v79, 16);
    LODWORD(v79) = *((_DWORD *)v71 + 22);
  }
  *((_DWORD *)v71 + 22) = v79;
  v81 = (char *)a1[2];
  v80 = a1[3];
  if ((unint64_t)v81 >= v80)
  {
    v83 = (char *)a1[1];
    v84 = (v81 - v83) >> 3;
    v85 = v84 + 1;
    if ((unint64_t)(v84 + 1) >> 61)
      goto LABEL_1055;
    v86 = v80 - (_QWORD)v83;
    if (v86 >> 2 > v85)
      v85 = v86 >> 2;
    if ((unint64_t)v86 >= 0x7FFFFFFFFFFFFFF8)
      v87 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v87 = v85;
    if (v87)
    {
      if (v87 >> 61)
        goto LABEL_1056;
      v88 = (char *)operator new(8 * v87);
    }
    else
    {
      v88 = 0;
    }
    v89 = &v88[8 * v84];
    v90 = &v88[8 * v87];
    *(_QWORD *)v89 = v71;
    v82 = v89 + 8;
    if (v81 == v83)
    {
      a1[1] = (uint64_t)v89;
      a1[2] = (uint64_t)v82;
      a1[3] = (uint64_t)v90;
    }
    else
    {
      v91 = v81 - v83 - 8;
      if (v91 < 0x78
        || &v81[-(v91 & 0xFFFFFFFFFFFFFFF8) - 8] < v89 && &v88[v81 - v83 - (v91 & 0xFFFFFFFFFFFFFFF8) - 8] < v81)
      {
        goto LABEL_1061;
      }
      v92 = (v91 >> 3) + 1;
      v93 = 8 * (v92 & 0x3FFFFFFFFFFFFFFCLL);
      v94 = &v81[-v93];
      v89 -= v93;
      v95 = &v88[8 * v84 - 16];
      v96 = v81 - 16;
      v97 = v92 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v99 = *((_OWORD *)v96 - 1);
        v98 = *(_OWORD *)v96;
        *((_OWORD *)v96 - 1) = 0uLL;
        *(_OWORD *)v96 = 0uLL;
        *((_OWORD *)v95 - 1) = v99;
        *(_OWORD *)v95 = v98;
        v95 -= 32;
        v96 -= 32;
        v97 -= 4;
      }
      while (v97);
      v81 = v94;
      if (v92 != (v92 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1061:
        do
        {
          v100 = *((_QWORD *)v81 - 1);
          v81 -= 8;
          *(_QWORD *)v81 = 0;
          *((_QWORD *)v89 - 1) = v100;
          v89 -= 8;
        }
        while (v81 != v83);
      }
      v81 = (char *)a1[1];
      v101 = (char *)a1[2];
      a1[1] = (uint64_t)v89;
      a1[2] = (uint64_t)v82;
      a1[3] = (uint64_t)v90;
      while (v101 != v81)
      {
        v103 = *((_QWORD *)v101 - 1);
        v101 -= 8;
        v102 = v103;
        *(_QWORD *)v101 = 0;
        if (v103)
          (*(void (**)(uint64_t))(*(_QWORD *)v102 + 8))(v102);
      }
    }
    if (v81)
      operator delete(v81);
  }
  else
  {
    *(_QWORD *)v81 = v71;
    v82 = v81 + 8;
  }
  a1[2] = (uint64_t)v82;
  v104 = *a1;
  v105 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E543A8;
  v922 = *(_OWORD *)&off_1E0E543B8;
  mlir::Pattern::Pattern((uint64_t)(v105 + 1), (uint64_t)"mps.dirac", 9, v920, v104, &v921, 2uLL);
  *v105 = off_1E0E48E38;
  if (!v105[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerDirac]";
    *((_QWORD *)&v921 + 1) = 98;
    v106 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v106)
      v107 = v106;
    else
      v107 = *((_QWORD *)&v921 + 1);
    v108 = v921 + v107;
    v109 = *((_QWORD *)&v921 + 1) - v107;
    if (*((_QWORD *)&v921 + 1) - v107 >= 0x12)
      v110 = 18;
    else
      v110 = *((_QWORD *)&v921 + 1) - v107;
    v111 = v108 + v110;
    v112 = v109 - v110;
    if (v112 >= v112 - 1)
      --v112;
    v105[8] = v111;
    v105[9] = v112;
  }
  v113 = *((unsigned int *)v105 + 22);
  if (v113 > *((_DWORD *)v105 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v105 + 10), v105 + 12, v113, 16);
    LODWORD(v113) = *((_DWORD *)v105 + 22);
  }
  *((_DWORD *)v105 + 22) = v113;
  v115 = (char *)a1[2];
  v114 = a1[3];
  if ((unint64_t)v115 >= v114)
  {
    v117 = (char *)a1[1];
    v118 = (v115 - v117) >> 3;
    v119 = v118 + 1;
    if ((unint64_t)(v118 + 1) >> 61)
      goto LABEL_1055;
    v120 = v114 - (_QWORD)v117;
    if (v120 >> 2 > v119)
      v119 = v120 >> 2;
    if ((unint64_t)v120 >= 0x7FFFFFFFFFFFFFF8)
      v121 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v121 = v119;
    if (v121)
    {
      if (v121 >> 61)
        goto LABEL_1056;
      v122 = (char *)operator new(8 * v121);
    }
    else
    {
      v122 = 0;
    }
    v123 = &v122[8 * v118];
    v124 = &v122[8 * v121];
    *(_QWORD *)v123 = v105;
    v116 = v123 + 8;
    if (v115 == v117)
    {
      a1[1] = (uint64_t)v123;
      a1[2] = (uint64_t)v116;
      a1[3] = (uint64_t)v124;
    }
    else
    {
      v125 = v115 - v117 - 8;
      if (v125 < 0x78
        || &v115[-(v125 & 0xFFFFFFFFFFFFFFF8) - 8] < v123
        && &v122[v115 - v117 - (v125 & 0xFFFFFFFFFFFFFFF8) - 8] < v115)
      {
        goto LABEL_1062;
      }
      v126 = (v125 >> 3) + 1;
      v127 = 8 * (v126 & 0x3FFFFFFFFFFFFFFCLL);
      v128 = &v115[-v127];
      v123 -= v127;
      v129 = &v122[8 * v118 - 16];
      v130 = v115 - 16;
      v131 = v126 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v133 = *((_OWORD *)v130 - 1);
        v132 = *(_OWORD *)v130;
        *((_OWORD *)v130 - 1) = 0uLL;
        *(_OWORD *)v130 = 0uLL;
        *((_OWORD *)v129 - 1) = v133;
        *(_OWORD *)v129 = v132;
        v129 -= 32;
        v130 -= 32;
        v131 -= 4;
      }
      while (v131);
      v115 = v128;
      if (v126 != (v126 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1062:
        do
        {
          v134 = *((_QWORD *)v115 - 1);
          v115 -= 8;
          *(_QWORD *)v115 = 0;
          *((_QWORD *)v123 - 1) = v134;
          v123 -= 8;
        }
        while (v115 != v117);
      }
      v115 = (char *)a1[1];
      v135 = (char *)a1[2];
      a1[1] = (uint64_t)v123;
      a1[2] = (uint64_t)v116;
      a1[3] = (uint64_t)v124;
      while (v135 != v115)
      {
        v137 = *((_QWORD *)v135 - 1);
        v135 -= 8;
        v136 = v137;
        *(_QWORD *)v135 = 0;
        if (v137)
          (*(void (**)(uint64_t))(*(_QWORD *)v136 + 8))(v136);
      }
    }
    if (v115)
      operator delete(v115);
  }
  else
  {
    *(_QWORD *)v115 = v105;
    v116 = v115 + 8;
  }
  a1[2] = (uint64_t)v116;
  v138 = *a1;
  v139 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v923 = xmmword_1E0E543E8;
  v924 = *(_OWORD *)&off_1E0E543F8;
  v925 = xmmword_1E0E54408;
  v921 = xmmword_1E0E543C8;
  v922 = *(_OWORD *)&off_1E0E543D8;
  mlir::Pattern::Pattern((uint64_t)(v139 + 1), (uint64_t)"mps.elu", 7, v920, v138, &v921, 5uLL);
  *v139 = off_1E0E48B18;
  if (!v139[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerElu]";
    *((_QWORD *)&v921 + 1) = 96;
    v140 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v140)
      v141 = v140;
    else
      v141 = *((_QWORD *)&v921 + 1);
    v142 = v921 + v141;
    v143 = *((_QWORD *)&v921 + 1) - v141;
    if (*((_QWORD *)&v921 + 1) - v141 >= 0x12)
      v144 = 18;
    else
      v144 = *((_QWORD *)&v921 + 1) - v141;
    v145 = v142 + v144;
    v146 = v143 - v144;
    if (v146 >= v146 - 1)
      --v146;
    v139[8] = v145;
    v139[9] = v146;
  }
  v147 = *((unsigned int *)v139 + 22);
  if (v147 > *((_DWORD *)v139 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v139 + 10), v139 + 12, v147, 16);
    LODWORD(v147) = *((_DWORD *)v139 + 22);
  }
  *((_DWORD *)v139 + 22) = v147;
  v149 = (char *)a1[2];
  v148 = a1[3];
  if ((unint64_t)v149 >= v148)
  {
    v151 = (char *)a1[1];
    v152 = (v149 - v151) >> 3;
    v153 = v152 + 1;
    if ((unint64_t)(v152 + 1) >> 61)
      goto LABEL_1055;
    v154 = v148 - (_QWORD)v151;
    if (v154 >> 2 > v153)
      v153 = v154 >> 2;
    if ((unint64_t)v154 >= 0x7FFFFFFFFFFFFFF8)
      v155 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v155 = v153;
    if (v155)
    {
      if (v155 >> 61)
        goto LABEL_1056;
      v156 = (char *)operator new(8 * v155);
    }
    else
    {
      v156 = 0;
    }
    v157 = &v156[8 * v152];
    v158 = &v156[8 * v155];
    *(_QWORD *)v157 = v139;
    v150 = v157 + 8;
    if (v149 == v151)
    {
      a1[1] = (uint64_t)v157;
      a1[2] = (uint64_t)v150;
      a1[3] = (uint64_t)v158;
    }
    else
    {
      v159 = v149 - v151 - 8;
      if (v159 < 0x78
        || &v149[-(v159 & 0xFFFFFFFFFFFFFFF8) - 8] < v157
        && &v156[v149 - v151 - (v159 & 0xFFFFFFFFFFFFFFF8) - 8] < v149)
      {
        goto LABEL_1063;
      }
      v160 = (v159 >> 3) + 1;
      v161 = 8 * (v160 & 0x3FFFFFFFFFFFFFFCLL);
      v162 = &v149[-v161];
      v157 -= v161;
      v163 = &v156[8 * v152 - 16];
      v164 = v149 - 16;
      v165 = v160 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v167 = *((_OWORD *)v164 - 1);
        v166 = *(_OWORD *)v164;
        *((_OWORD *)v164 - 1) = 0uLL;
        *(_OWORD *)v164 = 0uLL;
        *((_OWORD *)v163 - 1) = v167;
        *(_OWORD *)v163 = v166;
        v163 -= 32;
        v164 -= 32;
        v165 -= 4;
      }
      while (v165);
      v149 = v162;
      if (v160 != (v160 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1063:
        do
        {
          v168 = *((_QWORD *)v149 - 1);
          v149 -= 8;
          *(_QWORD *)v149 = 0;
          *((_QWORD *)v157 - 1) = v168;
          v157 -= 8;
        }
        while (v149 != v151);
      }
      v149 = (char *)a1[1];
      v169 = (char *)a1[2];
      a1[1] = (uint64_t)v157;
      a1[2] = (uint64_t)v150;
      a1[3] = (uint64_t)v158;
      while (v169 != v149)
      {
        v171 = *((_QWORD *)v169 - 1);
        v169 -= 8;
        v170 = v171;
        *(_QWORD *)v169 = 0;
        if (v171)
          (*(void (**)(uint64_t))(*(_QWORD *)v170 + 8))(v170);
      }
    }
    if (v149)
      operator delete(v149);
  }
  else
  {
    *(_QWORD *)v149 = v139;
    v150 = v149 + 8;
  }
  a1[2] = (uint64_t)v150;
  v172 = *a1;
  v173 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E54418;
  v922 = *(_OWORD *)&off_1E0E54428;
  mlir::Pattern::Pattern((uint64_t)(v173 + 1), (uint64_t)"mps.floor_divide", 16, v920, v172, &v921, 2uLL);
  *v173 = off_1E0E494A8;
  if (!v173[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerFloorDiv]";
    *((_QWORD *)&v921 + 1) = 101;
    v174 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v174)
      v175 = v174;
    else
      v175 = *((_QWORD *)&v921 + 1);
    v176 = v921 + v175;
    v177 = *((_QWORD *)&v921 + 1) - v175;
    if (*((_QWORD *)&v921 + 1) - v175 >= 0x12)
      v178 = 18;
    else
      v178 = *((_QWORD *)&v921 + 1) - v175;
    v179 = v176 + v178;
    v180 = v177 - v178;
    if (v180 >= v180 - 1)
      --v180;
    v173[8] = v179;
    v173[9] = v180;
  }
  v181 = *((unsigned int *)v173 + 22);
  if (v181 > *((_DWORD *)v173 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v173 + 10), v173 + 12, v181, 16);
    LODWORD(v181) = *((_DWORD *)v173 + 22);
  }
  *((_DWORD *)v173 + 22) = v181;
  v183 = (char *)a1[2];
  v182 = a1[3];
  if ((unint64_t)v183 >= v182)
  {
    v185 = (char *)a1[1];
    v186 = (v183 - v185) >> 3;
    v187 = v186 + 1;
    if ((unint64_t)(v186 + 1) >> 61)
      goto LABEL_1055;
    v188 = v182 - (_QWORD)v185;
    if (v188 >> 2 > v187)
      v187 = v188 >> 2;
    if ((unint64_t)v188 >= 0x7FFFFFFFFFFFFFF8)
      v189 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v189 = v187;
    if (v189)
    {
      if (v189 >> 61)
        goto LABEL_1056;
      v190 = (char *)operator new(8 * v189);
    }
    else
    {
      v190 = 0;
    }
    v191 = &v190[8 * v186];
    v192 = &v190[8 * v189];
    *(_QWORD *)v191 = v173;
    v184 = v191 + 8;
    if (v183 == v185)
    {
      a1[1] = (uint64_t)v191;
      a1[2] = (uint64_t)v184;
      a1[3] = (uint64_t)v192;
    }
    else
    {
      v193 = v183 - v185 - 8;
      if (v193 < 0x78
        || &v183[-(v193 & 0xFFFFFFFFFFFFFFF8) - 8] < v191
        && &v190[v183 - v185 - (v193 & 0xFFFFFFFFFFFFFFF8) - 8] < v183)
      {
        goto LABEL_1064;
      }
      v194 = (v193 >> 3) + 1;
      v195 = 8 * (v194 & 0x3FFFFFFFFFFFFFFCLL);
      v196 = &v183[-v195];
      v191 -= v195;
      v197 = &v190[8 * v186 - 16];
      v198 = v183 - 16;
      v199 = v194 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v201 = *((_OWORD *)v198 - 1);
        v200 = *(_OWORD *)v198;
        *((_OWORD *)v198 - 1) = 0uLL;
        *(_OWORD *)v198 = 0uLL;
        *((_OWORD *)v197 - 1) = v201;
        *(_OWORD *)v197 = v200;
        v197 -= 32;
        v198 -= 32;
        v199 -= 4;
      }
      while (v199);
      v183 = v196;
      if (v194 != (v194 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1064:
        do
        {
          v202 = *((_QWORD *)v183 - 1);
          v183 -= 8;
          *(_QWORD *)v183 = 0;
          *((_QWORD *)v191 - 1) = v202;
          v191 -= 8;
        }
        while (v183 != v185);
      }
      v183 = (char *)a1[1];
      v203 = (char *)a1[2];
      a1[1] = (uint64_t)v191;
      a1[2] = (uint64_t)v184;
      a1[3] = (uint64_t)v192;
      while (v203 != v183)
      {
        v205 = *((_QWORD *)v203 - 1);
        v203 -= 8;
        v204 = v205;
        *(_QWORD *)v203 = 0;
        if (v205)
          (*(void (**)(uint64_t))(*(_QWORD *)v204 + 8))(v204);
      }
    }
    if (v183)
      operator delete(v183);
  }
  else
  {
    *(_QWORD *)v183 = v173;
    v184 = v183 + 8;
  }
  a1[2] = (uint64_t)v184;
  v206 = *a1;
  v207 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E54438;
  v922 = *(_OWORD *)&off_1E0E54448;
  v923 = xmmword_1E0E54458;
  v924 = *(_OWORD *)&off_1E0E54468;
  mlir::Pattern::Pattern((uint64_t)(v207 + 1), (uint64_t)"mps.gelu", 8, v920, v206, &v921, 4uLL);
  *v207 = off_1E0E48C18;
  if (!v207[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerGelu]";
    *((_QWORD *)&v921 + 1) = 97;
    v208 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v208)
      v209 = v208;
    else
      v209 = *((_QWORD *)&v921 + 1);
    v210 = v921 + v209;
    v211 = *((_QWORD *)&v921 + 1) - v209;
    if (*((_QWORD *)&v921 + 1) - v209 >= 0x12)
      v212 = 18;
    else
      v212 = *((_QWORD *)&v921 + 1) - v209;
    v213 = v210 + v212;
    v214 = v211 - v212;
    if (v214 >= v214 - 1)
      --v214;
    v207[8] = v213;
    v207[9] = v214;
  }
  v215 = *((unsigned int *)v207 + 22);
  if (v215 > *((_DWORD *)v207 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v207 + 10), v207 + 12, v215, 16);
    LODWORD(v215) = *((_DWORD *)v207 + 22);
  }
  *((_DWORD *)v207 + 22) = v215;
  v217 = (char *)a1[2];
  v216 = a1[3];
  if ((unint64_t)v217 >= v216)
  {
    v219 = (char *)a1[1];
    v220 = (v217 - v219) >> 3;
    v221 = v220 + 1;
    if ((unint64_t)(v220 + 1) >> 61)
      goto LABEL_1055;
    v222 = v216 - (_QWORD)v219;
    if (v222 >> 2 > v221)
      v221 = v222 >> 2;
    if ((unint64_t)v222 >= 0x7FFFFFFFFFFFFFF8)
      v223 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v223 = v221;
    if (v223)
    {
      if (v223 >> 61)
        goto LABEL_1056;
      v224 = (char *)operator new(8 * v223);
    }
    else
    {
      v224 = 0;
    }
    v225 = &v224[8 * v220];
    v226 = &v224[8 * v223];
    *(_QWORD *)v225 = v207;
    v218 = v225 + 8;
    if (v217 == v219)
    {
      a1[1] = (uint64_t)v225;
      a1[2] = (uint64_t)v218;
      a1[3] = (uint64_t)v226;
    }
    else
    {
      v227 = v217 - v219 - 8;
      if (v227 < 0x78
        || &v217[-(v227 & 0xFFFFFFFFFFFFFFF8) - 8] < v225
        && &v224[v217 - v219 - (v227 & 0xFFFFFFFFFFFFFFF8) - 8] < v217)
      {
        goto LABEL_1065;
      }
      v228 = (v227 >> 3) + 1;
      v229 = 8 * (v228 & 0x3FFFFFFFFFFFFFFCLL);
      v230 = &v217[-v229];
      v225 -= v229;
      v231 = &v224[8 * v220 - 16];
      v232 = v217 - 16;
      v233 = v228 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v235 = *((_OWORD *)v232 - 1);
        v234 = *(_OWORD *)v232;
        *((_OWORD *)v232 - 1) = 0uLL;
        *(_OWORD *)v232 = 0uLL;
        *((_OWORD *)v231 - 1) = v235;
        *(_OWORD *)v231 = v234;
        v231 -= 32;
        v232 -= 32;
        v233 -= 4;
      }
      while (v233);
      v217 = v230;
      if (v228 != (v228 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1065:
        do
        {
          v236 = *((_QWORD *)v217 - 1);
          v217 -= 8;
          *(_QWORD *)v217 = 0;
          *((_QWORD *)v225 - 1) = v236;
          v225 -= 8;
        }
        while (v217 != v219);
      }
      v217 = (char *)a1[1];
      v237 = (char *)a1[2];
      a1[1] = (uint64_t)v225;
      a1[2] = (uint64_t)v218;
      a1[3] = (uint64_t)v226;
      while (v237 != v217)
      {
        v239 = *((_QWORD *)v237 - 1);
        v237 -= 8;
        v238 = v239;
        *(_QWORD *)v237 = 0;
        if (v239)
          (*(void (**)(uint64_t))(*(_QWORD *)v238 + 8))(v238);
      }
    }
    if (v217)
      operator delete(v217);
  }
  else
  {
    *(_QWORD *)v217 = v207;
    v218 = v217 + 8;
  }
  a1[2] = (uint64_t)v218;
  v240 = *a1;
  v241 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E54478;
  v922 = *(_OWORD *)&off_1E0E54488;
  v923 = xmmword_1E0E54498;
  mlir::Pattern::Pattern((uint64_t)(v241 + 1), (uint64_t)"mps.instance_norm", 17, v920, v240, &v921, 3uLL);
  *v241 = off_1E0E4A240;
  if (!v241[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerInstanceNorm]";
    *((_QWORD *)&v921 + 1) = 105;
    v242 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v242)
      v243 = v242;
    else
      v243 = *((_QWORD *)&v921 + 1);
    v244 = v921 + v243;
    v245 = *((_QWORD *)&v921 + 1) - v243;
    if (*((_QWORD *)&v921 + 1) - v243 >= 0x12)
      v246 = 18;
    else
      v246 = *((_QWORD *)&v921 + 1) - v243;
    v247 = v244 + v246;
    v248 = v245 - v246;
    if (v248 >= v248 - 1)
      --v248;
    v241[8] = v247;
    v241[9] = v248;
  }
  v249 = *((unsigned int *)v241 + 22);
  if (v249 > *((_DWORD *)v241 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v241 + 10), v241 + 12, v249, 16);
    LODWORD(v249) = *((_DWORD *)v241 + 22);
  }
  *((_DWORD *)v241 + 22) = v249;
  v251 = (char *)a1[2];
  v250 = a1[3];
  if ((unint64_t)v251 >= v250)
  {
    v253 = (char *)a1[1];
    v254 = (v251 - v253) >> 3;
    v255 = v254 + 1;
    if ((unint64_t)(v254 + 1) >> 61)
      goto LABEL_1055;
    v256 = v250 - (_QWORD)v253;
    if (v256 >> 2 > v255)
      v255 = v256 >> 2;
    if ((unint64_t)v256 >= 0x7FFFFFFFFFFFFFF8)
      v257 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v257 = v255;
    if (v257)
    {
      if (v257 >> 61)
        goto LABEL_1056;
      v258 = (char *)operator new(8 * v257);
    }
    else
    {
      v258 = 0;
    }
    v259 = &v258[8 * v254];
    v260 = &v258[8 * v257];
    *(_QWORD *)v259 = v241;
    v252 = v259 + 8;
    if (v251 == v253)
    {
      a1[1] = (uint64_t)v259;
      a1[2] = (uint64_t)v252;
      a1[3] = (uint64_t)v260;
    }
    else
    {
      v261 = v251 - v253 - 8;
      if (v261 < 0x78
        || &v251[-(v261 & 0xFFFFFFFFFFFFFFF8) - 8] < v259
        && &v258[v251 - v253 - (v261 & 0xFFFFFFFFFFFFFFF8) - 8] < v251)
      {
        goto LABEL_1066;
      }
      v262 = (v261 >> 3) + 1;
      v263 = 8 * (v262 & 0x3FFFFFFFFFFFFFFCLL);
      v264 = &v251[-v263];
      v259 -= v263;
      v265 = &v258[8 * v254 - 16];
      v266 = v251 - 16;
      v267 = v262 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v269 = *((_OWORD *)v266 - 1);
        v268 = *(_OWORD *)v266;
        *((_OWORD *)v266 - 1) = 0uLL;
        *(_OWORD *)v266 = 0uLL;
        *((_OWORD *)v265 - 1) = v269;
        *(_OWORD *)v265 = v268;
        v265 -= 32;
        v266 -= 32;
        v267 -= 4;
      }
      while (v267);
      v251 = v264;
      if (v262 != (v262 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1066:
        do
        {
          v270 = *((_QWORD *)v251 - 1);
          v251 -= 8;
          *(_QWORD *)v251 = 0;
          *((_QWORD *)v259 - 1) = v270;
          v259 -= 8;
        }
        while (v251 != v253);
      }
      v251 = (char *)a1[1];
      v271 = (char *)a1[2];
      a1[1] = (uint64_t)v259;
      a1[2] = (uint64_t)v252;
      a1[3] = (uint64_t)v260;
      while (v271 != v251)
      {
        v273 = *((_QWORD *)v271 - 1);
        v271 -= 8;
        v272 = v273;
        *(_QWORD *)v271 = 0;
        if (v273)
          (*(void (**)(uint64_t))(*(_QWORD *)v272 + 8))(v272);
      }
    }
    if (v251)
      operator delete(v251);
  }
  else
  {
    *(_QWORD *)v251 = v241;
    v252 = v251 + 8;
  }
  a1[2] = (uint64_t)v252;
  v274 = *a1;
  v275 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v925 = xmmword_1E0E544E8;
  v926 = *(_OWORD *)&off_1E0E544F8;
  v927 = xmmword_1E0E54508;
  v921 = xmmword_1E0E544A8;
  v922 = *(_OWORD *)&off_1E0E544B8;
  v923 = xmmword_1E0E544C8;
  v924 = *(_OWORD *)&off_1E0E544D8;
  mlir::Pattern::Pattern((uint64_t)(v275 + 1), (uint64_t)"mps.lp_norm", 11, v920, v274, &v921, 7uLL);
  *v275 = off_1E0E490F8;
  if (!v275[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerLPNorm]";
    *((_QWORD *)&v921 + 1) = 99;
    v276 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v276)
      v277 = v276;
    else
      v277 = *((_QWORD *)&v921 + 1);
    v278 = v921 + v277;
    v279 = *((_QWORD *)&v921 + 1) - v277;
    if (*((_QWORD *)&v921 + 1) - v277 >= 0x12)
      v280 = 18;
    else
      v280 = *((_QWORD *)&v921 + 1) - v277;
    v281 = v278 + v280;
    v282 = v279 - v280;
    if (v282 >= v282 - 1)
      --v282;
    v275[8] = v281;
    v275[9] = v282;
  }
  v283 = *((unsigned int *)v275 + 22);
  if (v283 > *((_DWORD *)v275 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v275 + 10), v275 + 12, v283, 16);
    LODWORD(v283) = *((_DWORD *)v275 + 22);
  }
  *((_DWORD *)v275 + 22) = v283;
  v285 = (char *)a1[2];
  v284 = a1[3];
  if ((unint64_t)v285 >= v284)
  {
    v287 = (char *)a1[1];
    v288 = (v285 - v287) >> 3;
    v289 = v288 + 1;
    if ((unint64_t)(v288 + 1) >> 61)
      goto LABEL_1055;
    v290 = v284 - (_QWORD)v287;
    if (v290 >> 2 > v289)
      v289 = v290 >> 2;
    if ((unint64_t)v290 >= 0x7FFFFFFFFFFFFFF8)
      v291 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v291 = v289;
    if (v291)
    {
      if (v291 >> 61)
        goto LABEL_1056;
      v292 = (char *)operator new(8 * v291);
    }
    else
    {
      v292 = 0;
    }
    v293 = &v292[8 * v288];
    v294 = &v292[8 * v291];
    *(_QWORD *)v293 = v275;
    v286 = v293 + 8;
    if (v285 == v287)
    {
      a1[1] = (uint64_t)v293;
      a1[2] = (uint64_t)v286;
      a1[3] = (uint64_t)v294;
    }
    else
    {
      v295 = v285 - v287 - 8;
      if (v295 < 0x78
        || &v285[-(v295 & 0xFFFFFFFFFFFFFFF8) - 8] < v293
        && &v292[v285 - v287 - (v295 & 0xFFFFFFFFFFFFFFF8) - 8] < v285)
      {
        goto LABEL_1067;
      }
      v296 = (v295 >> 3) + 1;
      v297 = 8 * (v296 & 0x3FFFFFFFFFFFFFFCLL);
      v298 = &v285[-v297];
      v293 -= v297;
      v299 = &v292[8 * v288 - 16];
      v300 = v285 - 16;
      v301 = v296 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v303 = *((_OWORD *)v300 - 1);
        v302 = *(_OWORD *)v300;
        *((_OWORD *)v300 - 1) = 0uLL;
        *(_OWORD *)v300 = 0uLL;
        *((_OWORD *)v299 - 1) = v303;
        *(_OWORD *)v299 = v302;
        v299 -= 32;
        v300 -= 32;
        v301 -= 4;
      }
      while (v301);
      v285 = v298;
      if (v296 != (v296 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1067:
        do
        {
          v304 = *((_QWORD *)v285 - 1);
          v285 -= 8;
          *(_QWORD *)v285 = 0;
          *((_QWORD *)v293 - 1) = v304;
          v293 -= 8;
        }
        while (v285 != v287);
      }
      v285 = (char *)a1[1];
      v305 = (char *)a1[2];
      a1[1] = (uint64_t)v293;
      a1[2] = (uint64_t)v286;
      a1[3] = (uint64_t)v294;
      while (v305 != v285)
      {
        v307 = *((_QWORD *)v305 - 1);
        v305 -= 8;
        v306 = v307;
        *(_QWORD *)v305 = 0;
        if (v307)
          (*(void (**)(uint64_t))(*(_QWORD *)v306 + 8))(v306);
      }
    }
    if (v285)
      operator delete(v285);
  }
  else
  {
    *(_QWORD *)v285 = v275;
    v286 = v285 + 8;
  }
  a1[2] = (uint64_t)v286;
  v308 = *a1;
  v309 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E54518;
  v922 = *(_OWORD *)&off_1E0E54528;
  v923 = xmmword_1E0E54538;
  mlir::Pattern::Pattern((uint64_t)(v309 + 1), (uint64_t)"mps.leaky_relu", 14, v920, v308, &v921, 3uLL);
  *v309 = off_1E0E49980;
  if (!v309[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerLeakyRelu]";
    *((_QWORD *)&v921 + 1) = 102;
    v310 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v310)
      v311 = v310;
    else
      v311 = *((_QWORD *)&v921 + 1);
    v312 = v921 + v311;
    v313 = *((_QWORD *)&v921 + 1) - v311;
    if (*((_QWORD *)&v921 + 1) - v311 >= 0x12)
      v314 = 18;
    else
      v314 = *((_QWORD *)&v921 + 1) - v311;
    v315 = v312 + v314;
    v316 = v313 - v314;
    if (v316 >= v316 - 1)
      --v316;
    v309[8] = v315;
    v309[9] = v316;
  }
  v317 = *((unsigned int *)v309 + 22);
  if (v317 > *((_DWORD *)v309 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v309 + 10), v309 + 12, v317, 16);
    LODWORD(v317) = *((_DWORD *)v309 + 22);
  }
  *((_DWORD *)v309 + 22) = v317;
  v319 = (char *)a1[2];
  v318 = a1[3];
  if ((unint64_t)v319 >= v318)
  {
    v321 = (char *)a1[1];
    v322 = (v319 - v321) >> 3;
    v323 = v322 + 1;
    if ((unint64_t)(v322 + 1) >> 61)
      goto LABEL_1055;
    v324 = v318 - (_QWORD)v321;
    if (v324 >> 2 > v323)
      v323 = v324 >> 2;
    if ((unint64_t)v324 >= 0x7FFFFFFFFFFFFFF8)
      v325 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v325 = v323;
    if (v325)
    {
      if (v325 >> 61)
        goto LABEL_1056;
      v326 = (char *)operator new(8 * v325);
    }
    else
    {
      v326 = 0;
    }
    v327 = &v326[8 * v322];
    v328 = &v326[8 * v325];
    *(_QWORD *)v327 = v309;
    v320 = v327 + 8;
    if (v319 == v321)
    {
      a1[1] = (uint64_t)v327;
      a1[2] = (uint64_t)v320;
      a1[3] = (uint64_t)v328;
    }
    else
    {
      v329 = v319 - v321 - 8;
      if (v329 < 0x78
        || &v319[-(v329 & 0xFFFFFFFFFFFFFFF8) - 8] < v327
        && &v326[v319 - v321 - (v329 & 0xFFFFFFFFFFFFFFF8) - 8] < v319)
      {
        goto LABEL_1068;
      }
      v330 = (v329 >> 3) + 1;
      v331 = 8 * (v330 & 0x3FFFFFFFFFFFFFFCLL);
      v332 = &v319[-v331];
      v327 -= v331;
      v333 = &v326[8 * v322 - 16];
      v334 = v319 - 16;
      v335 = v330 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v337 = *((_OWORD *)v334 - 1);
        v336 = *(_OWORD *)v334;
        *((_OWORD *)v334 - 1) = 0uLL;
        *(_OWORD *)v334 = 0uLL;
        *((_OWORD *)v333 - 1) = v337;
        *(_OWORD *)v333 = v336;
        v333 -= 32;
        v334 -= 32;
        v335 -= 4;
      }
      while (v335);
      v319 = v332;
      if (v330 != (v330 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1068:
        do
        {
          v338 = *((_QWORD *)v319 - 1);
          v319 -= 8;
          *(_QWORD *)v319 = 0;
          *((_QWORD *)v327 - 1) = v338;
          v327 -= 8;
        }
        while (v319 != v321);
      }
      v319 = (char *)a1[1];
      v339 = (char *)a1[2];
      a1[1] = (uint64_t)v327;
      a1[2] = (uint64_t)v320;
      a1[3] = (uint64_t)v328;
      while (v339 != v319)
      {
        v341 = *((_QWORD *)v339 - 1);
        v339 -= 8;
        v340 = v341;
        *(_QWORD *)v339 = 0;
        if (v341)
          (*(void (**)(uint64_t))(*(_QWORD *)v340 + 8))(v340);
      }
    }
    if (v319)
      operator delete(v319);
  }
  else
  {
    *(_QWORD *)v319 = v309;
    v320 = v319 + 8;
  }
  a1[2] = (uint64_t)v320;
  v342 = *a1;
  v343 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E54548;
  v922 = *(_OWORD *)&off_1E0E54558;
  v923 = xmmword_1E0E54568;
  v924 = *(_OWORD *)&off_1E0E54578;
  mlir::Pattern::Pattern((uint64_t)(v343 + 1), (uint64_t)"mps.n_relu", 10, v920, v342, &v921, 4uLL);
  *v343 = off_1E0E48E78;
  if (!v343[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerNRelu]";
    *((_QWORD *)&v921 + 1) = 98;
    v344 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v344)
      v345 = v344;
    else
      v345 = *((_QWORD *)&v921 + 1);
    v346 = v921 + v345;
    v347 = *((_QWORD *)&v921 + 1) - v345;
    if (*((_QWORD *)&v921 + 1) - v345 >= 0x12)
      v348 = 18;
    else
      v348 = *((_QWORD *)&v921 + 1) - v345;
    v349 = v346 + v348;
    v350 = v347 - v348;
    if (v350 >= v350 - 1)
      --v350;
    v343[8] = v349;
    v343[9] = v350;
  }
  v351 = *((unsigned int *)v343 + 22);
  if (v351 > *((_DWORD *)v343 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v343 + 10), v343 + 12, v351, 16);
    LODWORD(v351) = *((_DWORD *)v343 + 22);
  }
  *((_DWORD *)v343 + 22) = v351;
  v353 = (char *)a1[2];
  v352 = a1[3];
  if ((unint64_t)v353 >= v352)
  {
    v355 = (char *)a1[1];
    v356 = (v353 - v355) >> 3;
    v357 = v356 + 1;
    if ((unint64_t)(v356 + 1) >> 61)
      goto LABEL_1055;
    v358 = v352 - (_QWORD)v355;
    if (v358 >> 2 > v357)
      v357 = v358 >> 2;
    if ((unint64_t)v358 >= 0x7FFFFFFFFFFFFFF8)
      v359 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v359 = v357;
    if (v359)
    {
      if (v359 >> 61)
        goto LABEL_1056;
      v360 = (char *)operator new(8 * v359);
    }
    else
    {
      v360 = 0;
    }
    v361 = &v360[8 * v356];
    v362 = &v360[8 * v359];
    *(_QWORD *)v361 = v343;
    v354 = v361 + 8;
    if (v353 == v355)
    {
      a1[1] = (uint64_t)v361;
      a1[2] = (uint64_t)v354;
      a1[3] = (uint64_t)v362;
    }
    else
    {
      v363 = v353 - v355 - 8;
      if (v363 < 0x78
        || &v353[-(v363 & 0xFFFFFFFFFFFFFFF8) - 8] < v361
        && &v360[v353 - v355 - (v363 & 0xFFFFFFFFFFFFFFF8) - 8] < v353)
      {
        goto LABEL_1069;
      }
      v364 = (v363 >> 3) + 1;
      v365 = 8 * (v364 & 0x3FFFFFFFFFFFFFFCLL);
      v366 = &v353[-v365];
      v361 -= v365;
      v367 = &v360[8 * v356 - 16];
      v368 = v353 - 16;
      v369 = v364 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v371 = *((_OWORD *)v368 - 1);
        v370 = *(_OWORD *)v368;
        *((_OWORD *)v368 - 1) = 0uLL;
        *(_OWORD *)v368 = 0uLL;
        *((_OWORD *)v367 - 1) = v371;
        *(_OWORD *)v367 = v370;
        v367 -= 32;
        v368 -= 32;
        v369 -= 4;
      }
      while (v369);
      v353 = v366;
      if (v364 != (v364 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1069:
        do
        {
          v372 = *((_QWORD *)v353 - 1);
          v353 -= 8;
          *(_QWORD *)v353 = 0;
          *((_QWORD *)v361 - 1) = v372;
          v361 -= 8;
        }
        while (v353 != v355);
      }
      v353 = (char *)a1[1];
      v373 = (char *)a1[2];
      a1[1] = (uint64_t)v361;
      a1[2] = (uint64_t)v354;
      a1[3] = (uint64_t)v362;
      while (v373 != v353)
      {
        v375 = *((_QWORD *)v373 - 1);
        v373 -= 8;
        v374 = v375;
        *(_QWORD *)v373 = 0;
        if (v375)
          (*(void (**)(uint64_t))(*(_QWORD *)v374 + 8))(v374);
      }
    }
    if (v353)
      operator delete(v353);
  }
  else
  {
    *(_QWORD *)v353 = v343;
    v354 = v353 + 8;
  }
  a1[2] = (uint64_t)v354;
  v376 = *a1;
  v377 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v923 = xmmword_1E0E545A8;
  v924 = *(_OWORD *)&off_1E0E545B8;
  v925 = xmmword_1E0E545C8;
  v926 = *(_OWORD *)&off_1E0E545D8;
  v921 = xmmword_1E0E54588;
  v922 = *(_OWORD *)&off_1E0E54598;
  mlir::Pattern::Pattern((uint64_t)(v377 + 1), (uint64_t)"mps.normalization", 17, v920, v376, &v921, 6uLL);
  *v377 = off_1E0E4A3E8;
  if (!v377[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerNormalization]";
    *((_QWORD *)&v921 + 1) = 106;
    v378 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v378)
      v379 = v378;
    else
      v379 = *((_QWORD *)&v921 + 1);
    v380 = v921 + v379;
    v381 = *((_QWORD *)&v921 + 1) - v379;
    if (*((_QWORD *)&v921 + 1) - v379 >= 0x12)
      v382 = 18;
    else
      v382 = *((_QWORD *)&v921 + 1) - v379;
    v383 = v380 + v382;
    v384 = v381 - v382;
    if (v384 >= v384 - 1)
      --v384;
    v377[8] = v383;
    v377[9] = v384;
  }
  v385 = *((unsigned int *)v377 + 22);
  if (v385 > *((_DWORD *)v377 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v377 + 10), v377 + 12, v385, 16);
    LODWORD(v385) = *((_DWORD *)v377 + 22);
  }
  *((_DWORD *)v377 + 22) = v385;
  v387 = (char *)a1[2];
  v386 = a1[3];
  if ((unint64_t)v387 >= v386)
  {
    v389 = (char *)a1[1];
    v390 = (v387 - v389) >> 3;
    v391 = v390 + 1;
    if ((unint64_t)(v390 + 1) >> 61)
      goto LABEL_1055;
    v392 = v386 - (_QWORD)v389;
    if (v392 >> 2 > v391)
      v391 = v392 >> 2;
    if ((unint64_t)v392 >= 0x7FFFFFFFFFFFFFF8)
      v393 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v393 = v391;
    if (v393)
    {
      if (v393 >> 61)
        goto LABEL_1056;
      v394 = (char *)operator new(8 * v393);
    }
    else
    {
      v394 = 0;
    }
    v395 = &v394[8 * v390];
    v396 = &v394[8 * v393];
    *(_QWORD *)v395 = v377;
    v388 = v395 + 8;
    if (v387 == v389)
    {
      a1[1] = (uint64_t)v395;
      a1[2] = (uint64_t)v388;
      a1[3] = (uint64_t)v396;
    }
    else
    {
      v397 = v387 - v389 - 8;
      if (v397 < 0x78
        || &v387[-(v397 & 0xFFFFFFFFFFFFFFF8) - 8] < v395
        && &v394[v387 - v389 - (v397 & 0xFFFFFFFFFFFFFFF8) - 8] < v387)
      {
        goto LABEL_1070;
      }
      v398 = (v397 >> 3) + 1;
      v399 = 8 * (v398 & 0x3FFFFFFFFFFFFFFCLL);
      v400 = &v387[-v399];
      v395 -= v399;
      v401 = &v394[8 * v390 - 16];
      v402 = v387 - 16;
      v403 = v398 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v405 = *((_OWORD *)v402 - 1);
        v404 = *(_OWORD *)v402;
        *((_OWORD *)v402 - 1) = 0uLL;
        *(_OWORD *)v402 = 0uLL;
        *((_OWORD *)v401 - 1) = v405;
        *(_OWORD *)v401 = v404;
        v401 -= 32;
        v402 -= 32;
        v403 -= 4;
      }
      while (v403);
      v387 = v400;
      if (v398 != (v398 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1070:
        do
        {
          v406 = *((_QWORD *)v387 - 1);
          v387 -= 8;
          *(_QWORD *)v387 = 0;
          *((_QWORD *)v395 - 1) = v406;
          v395 -= 8;
        }
        while (v387 != v389);
      }
      v387 = (char *)a1[1];
      v407 = (char *)a1[2];
      a1[1] = (uint64_t)v395;
      a1[2] = (uint64_t)v388;
      a1[3] = (uint64_t)v396;
      while (v407 != v387)
      {
        v409 = *((_QWORD *)v407 - 1);
        v407 -= 8;
        v408 = v409;
        *(_QWORD *)v407 = 0;
        if (v409)
          (*(void (**)(uint64_t))(*(_QWORD *)v408 + 8))(v408);
      }
    }
    if (v387)
      operator delete(v387);
  }
  else
  {
    *(_QWORD *)v387 = v377;
    v388 = v387 + 8;
  }
  a1[2] = (uint64_t)v388;
  v410 = *a1;
  v411 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E545E8;
  v922 = *(_OWORD *)&off_1E0E545F8;
  v923 = xmmword_1E0E54608;
  v924 = *(_OWORD *)&off_1E0E54618;
  mlir::Pattern::Pattern((uint64_t)(v411 + 1), (uint64_t)"mps.prelu", 9, v920, v410, &v921, 4uLL);
  *v411 = off_1E0E48EB8;
  if (!v411[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerPRelu]";
    *((_QWORD *)&v921 + 1) = 98;
    v412 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v412)
      v413 = v412;
    else
      v413 = *((_QWORD *)&v921 + 1);
    v414 = v921 + v413;
    v415 = *((_QWORD *)&v921 + 1) - v413;
    if (*((_QWORD *)&v921 + 1) - v413 >= 0x12)
      v416 = 18;
    else
      v416 = *((_QWORD *)&v921 + 1) - v413;
    v417 = v414 + v416;
    v418 = v415 - v416;
    if (v418 >= v418 - 1)
      --v418;
    v411[8] = v417;
    v411[9] = v418;
  }
  v419 = *((unsigned int *)v411 + 22);
  if (v419 > *((_DWORD *)v411 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v411 + 10), v411 + 12, v419, 16);
    LODWORD(v419) = *((_DWORD *)v411 + 22);
  }
  *((_DWORD *)v411 + 22) = v419;
  v421 = (char *)a1[2];
  v420 = a1[3];
  if ((unint64_t)v421 >= v420)
  {
    v423 = (char *)a1[1];
    v424 = (v421 - v423) >> 3;
    v425 = v424 + 1;
    if ((unint64_t)(v424 + 1) >> 61)
      goto LABEL_1055;
    v426 = v420 - (_QWORD)v423;
    if (v426 >> 2 > v425)
      v425 = v426 >> 2;
    if ((unint64_t)v426 >= 0x7FFFFFFFFFFFFFF8)
      v427 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v427 = v425;
    if (v427)
    {
      if (v427 >> 61)
        goto LABEL_1056;
      v428 = (char *)operator new(8 * v427);
    }
    else
    {
      v428 = 0;
    }
    v429 = &v428[8 * v424];
    v430 = &v428[8 * v427];
    *(_QWORD *)v429 = v411;
    v422 = v429 + 8;
    if (v421 == v423)
    {
      a1[1] = (uint64_t)v429;
      a1[2] = (uint64_t)v422;
      a1[3] = (uint64_t)v430;
    }
    else
    {
      v431 = v421 - v423 - 8;
      if (v431 < 0x78
        || &v421[-(v431 & 0xFFFFFFFFFFFFFFF8) - 8] < v429
        && &v428[v421 - v423 - (v431 & 0xFFFFFFFFFFFFFFF8) - 8] < v421)
      {
        goto LABEL_1071;
      }
      v432 = (v431 >> 3) + 1;
      v433 = 8 * (v432 & 0x3FFFFFFFFFFFFFFCLL);
      v434 = &v421[-v433];
      v429 -= v433;
      v435 = &v428[8 * v424 - 16];
      v436 = v421 - 16;
      v437 = v432 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v439 = *((_OWORD *)v436 - 1);
        v438 = *(_OWORD *)v436;
        *((_OWORD *)v436 - 1) = 0uLL;
        *(_OWORD *)v436 = 0uLL;
        *((_OWORD *)v435 - 1) = v439;
        *(_OWORD *)v435 = v438;
        v435 -= 32;
        v436 -= 32;
        v437 -= 4;
      }
      while (v437);
      v421 = v434;
      if (v432 != (v432 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1071:
        do
        {
          v440 = *((_QWORD *)v421 - 1);
          v421 -= 8;
          *(_QWORD *)v421 = 0;
          *((_QWORD *)v429 - 1) = v440;
          v429 -= 8;
        }
        while (v421 != v423);
      }
      v421 = (char *)a1[1];
      v441 = (char *)a1[2];
      a1[1] = (uint64_t)v429;
      a1[2] = (uint64_t)v422;
      a1[3] = (uint64_t)v430;
      while (v441 != v421)
      {
        v443 = *((_QWORD *)v441 - 1);
        v441 -= 8;
        v442 = v443;
        *(_QWORD *)v441 = 0;
        if (v443)
          (*(void (**)(uint64_t))(*(_QWORD *)v442 + 8))(v442);
      }
    }
    if (v421)
      operator delete(v421);
  }
  else
  {
    *(_QWORD *)v421 = v411;
    v422 = v421 + 8;
  }
  a1[2] = (uint64_t)v422;
  v444 = *a1;
  v445 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v923 = xmmword_1E0E54648;
  v924 = *(_OWORD *)&off_1E0E54658;
  v925 = xmmword_1E0E54668;
  v921 = xmmword_1E0E54628;
  v922 = *(_OWORD *)&off_1E0E54638;
  mlir::Pattern::Pattern((uint64_t)(v445 + 1), (uint64_t)"mps.quantize", 12, v920, v444, &v921, 5uLL);
  *v445 = off_1E0E494E8;
  if (!v445[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerQuantize]";
    *((_QWORD *)&v921 + 1) = 101;
    v446 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v446)
      v447 = v446;
    else
      v447 = *((_QWORD *)&v921 + 1);
    v448 = v921 + v447;
    v449 = *((_QWORD *)&v921 + 1) - v447;
    if (*((_QWORD *)&v921 + 1) - v447 >= 0x12)
      v450 = 18;
    else
      v450 = *((_QWORD *)&v921 + 1) - v447;
    v451 = v448 + v450;
    v452 = v449 - v450;
    if (v452 >= v452 - 1)
      --v452;
    v445[8] = v451;
    v445[9] = v452;
  }
  v453 = *((unsigned int *)v445 + 22);
  if (v453 > *((_DWORD *)v445 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v445 + 10), v445 + 12, v453, 16);
    LODWORD(v453) = *((_DWORD *)v445 + 22);
  }
  *((_DWORD *)v445 + 22) = v453;
  v455 = (char *)a1[2];
  v454 = a1[3];
  if ((unint64_t)v455 >= v454)
  {
    v457 = (char *)a1[1];
    v458 = (v455 - v457) >> 3;
    v459 = v458 + 1;
    if ((unint64_t)(v458 + 1) >> 61)
      goto LABEL_1055;
    v460 = v454 - (_QWORD)v457;
    if (v460 >> 2 > v459)
      v459 = v460 >> 2;
    if ((unint64_t)v460 >= 0x7FFFFFFFFFFFFFF8)
      v461 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v461 = v459;
    if (v461)
    {
      if (v461 >> 61)
        goto LABEL_1056;
      v462 = (char *)operator new(8 * v461);
    }
    else
    {
      v462 = 0;
    }
    v463 = &v462[8 * v458];
    v464 = &v462[8 * v461];
    *(_QWORD *)v463 = v445;
    v456 = v463 + 8;
    if (v455 == v457)
    {
      a1[1] = (uint64_t)v463;
      a1[2] = (uint64_t)v456;
      a1[3] = (uint64_t)v464;
    }
    else
    {
      v465 = v455 - v457 - 8;
      if (v465 < 0x78
        || &v455[-(v465 & 0xFFFFFFFFFFFFFFF8) - 8] < v463
        && &v462[v455 - v457 - (v465 & 0xFFFFFFFFFFFFFFF8) - 8] < v455)
      {
        goto LABEL_1072;
      }
      v466 = (v465 >> 3) + 1;
      v467 = 8 * (v466 & 0x3FFFFFFFFFFFFFFCLL);
      v468 = &v455[-v467];
      v463 -= v467;
      v469 = &v462[8 * v458 - 16];
      v470 = v455 - 16;
      v471 = v466 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v473 = *((_OWORD *)v470 - 1);
        v472 = *(_OWORD *)v470;
        *((_OWORD *)v470 - 1) = 0uLL;
        *(_OWORD *)v470 = 0uLL;
        *((_OWORD *)v469 - 1) = v473;
        *(_OWORD *)v469 = v472;
        v469 -= 32;
        v470 -= 32;
        v471 -= 4;
      }
      while (v471);
      v455 = v468;
      if (v466 != (v466 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1072:
        do
        {
          v474 = *((_QWORD *)v455 - 1);
          v455 -= 8;
          *(_QWORD *)v455 = 0;
          *((_QWORD *)v463 - 1) = v474;
          v463 -= 8;
        }
        while (v455 != v457);
      }
      v455 = (char *)a1[1];
      v475 = (char *)a1[2];
      a1[1] = (uint64_t)v463;
      a1[2] = (uint64_t)v456;
      a1[3] = (uint64_t)v464;
      while (v475 != v455)
      {
        v477 = *((_QWORD *)v475 - 1);
        v475 -= 8;
        v476 = v477;
        *(_QWORD *)v475 = 0;
        if (v477)
          (*(void (**)(uint64_t))(*(_QWORD *)v476 + 8))(v476);
      }
    }
    if (v455)
      operator delete(v455);
  }
  else
  {
    *(_QWORD *)v455 = v445;
    v456 = v455 + 8;
  }
  a1[2] = (uint64_t)v456;
  v478 = *a1;
  v479 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E54678;
  v922 = *(_OWORD *)&off_1E0E54688;
  v923 = xmmword_1E0E54698;
  mlir::Pattern::Pattern((uint64_t)(v479 + 1), (uint64_t)"mps.quantize", 12, v920, v478, &v921, 3uLL);
  *v479 = off_1E0E4B2D8;
  if (!v479[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerQuant"
                       "izeWithMPSXQuantDAG]";
    *((_QWORD *)&v921 + 1) = 117;
    v480 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v480)
      v481 = v480;
    else
      v481 = *((_QWORD *)&v921 + 1);
    v482 = v921 + v481;
    v483 = *((_QWORD *)&v921 + 1) - v481;
    if (*((_QWORD *)&v921 + 1) - v481 >= 0x12)
      v484 = 18;
    else
      v484 = *((_QWORD *)&v921 + 1) - v481;
    v485 = v482 + v484;
    v486 = v483 - v484;
    if (v486 >= v486 - 1)
      --v486;
    v479[8] = v485;
    v479[9] = v486;
  }
  v487 = *((unsigned int *)v479 + 22);
  if (v487 > *((_DWORD *)v479 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v479 + 10), v479 + 12, v487, 16);
    LODWORD(v487) = *((_DWORD *)v479 + 22);
  }
  *((_DWORD *)v479 + 22) = v487;
  v489 = (char *)a1[2];
  v488 = a1[3];
  if ((unint64_t)v489 >= v488)
  {
    v491 = (char *)a1[1];
    v492 = (v489 - v491) >> 3;
    v493 = v492 + 1;
    if ((unint64_t)(v492 + 1) >> 61)
      goto LABEL_1055;
    v494 = v488 - (_QWORD)v491;
    if (v494 >> 2 > v493)
      v493 = v494 >> 2;
    if ((unint64_t)v494 >= 0x7FFFFFFFFFFFFFF8)
      v495 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v495 = v493;
    if (v495)
    {
      if (v495 >> 61)
        goto LABEL_1056;
      v496 = (char *)operator new(8 * v495);
    }
    else
    {
      v496 = 0;
    }
    v497 = &v496[8 * v492];
    v498 = &v496[8 * v495];
    *(_QWORD *)v497 = v479;
    v490 = v497 + 8;
    if (v489 == v491)
    {
      a1[1] = (uint64_t)v497;
      a1[2] = (uint64_t)v490;
      a1[3] = (uint64_t)v498;
    }
    else
    {
      v499 = v489 - v491 - 8;
      if (v499 < 0x78
        || &v489[-(v499 & 0xFFFFFFFFFFFFFFF8) - 8] < v497
        && &v496[v489 - v491 - (v499 & 0xFFFFFFFFFFFFFFF8) - 8] < v489)
      {
        goto LABEL_1073;
      }
      v500 = (v499 >> 3) + 1;
      v501 = 8 * (v500 & 0x3FFFFFFFFFFFFFFCLL);
      v502 = &v489[-v501];
      v497 -= v501;
      v503 = &v496[8 * v492 - 16];
      v504 = v489 - 16;
      v505 = v500 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v507 = *((_OWORD *)v504 - 1);
        v506 = *(_OWORD *)v504;
        *((_OWORD *)v504 - 1) = 0uLL;
        *(_OWORD *)v504 = 0uLL;
        *((_OWORD *)v503 - 1) = v507;
        *(_OWORD *)v503 = v506;
        v503 -= 32;
        v504 -= 32;
        v505 -= 4;
      }
      while (v505);
      v489 = v502;
      if (v500 != (v500 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1073:
        do
        {
          v508 = *((_QWORD *)v489 - 1);
          v489 -= 8;
          *(_QWORD *)v489 = 0;
          *((_QWORD *)v497 - 1) = v508;
          v497 -= 8;
        }
        while (v489 != v491);
      }
      v489 = (char *)a1[1];
      v509 = (char *)a1[2];
      a1[1] = (uint64_t)v497;
      a1[2] = (uint64_t)v490;
      a1[3] = (uint64_t)v498;
      while (v509 != v489)
      {
        v511 = *((_QWORD *)v509 - 1);
        v509 -= 8;
        v510 = v511;
        *(_QWORD *)v509 = 0;
        if (v511)
          (*(void (**)(uint64_t))(*(_QWORD *)v510 + 8))(v510);
      }
    }
    if (v489)
      operator delete(v489);
  }
  else
  {
    *(_QWORD *)v489 = v479;
    v490 = v489 + 8;
  }
  a1[2] = (uint64_t)v490;
  v512 = *a1;
  v513 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v925 = xmmword_1E0E546E8;
  v926 = *(_OWORD *)&off_1E0E546F8;
  v927 = xmmword_1E0E54708;
  v928 = *(_OWORD *)&off_1E0E54718;
  v921 = xmmword_1E0E546A8;
  v922 = *(_OWORD *)&off_1E0E546B8;
  v923 = xmmword_1E0E546C8;
  v924 = *(_OWORD *)&off_1E0E546D8;
  mlir::Pattern::Pattern((uint64_t)(v513 + 1), (uint64_t)"mps.reduction_logsumexp", 23, v920, v512, &v921, 8uLL);
  *v513 = off_1E0E4AED0;
  if (!v513[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerReductionLogSumExp]";
    *((_QWORD *)&v921 + 1) = 111;
    v514 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v514)
      v515 = v514;
    else
      v515 = *((_QWORD *)&v921 + 1);
    v516 = v921 + v515;
    v517 = *((_QWORD *)&v921 + 1) - v515;
    if (*((_QWORD *)&v921 + 1) - v515 >= 0x12)
      v518 = 18;
    else
      v518 = *((_QWORD *)&v921 + 1) - v515;
    v519 = v516 + v518;
    v520 = v517 - v518;
    if (v520 >= v520 - 1)
      --v520;
    v513[8] = v519;
    v513[9] = v520;
  }
  v521 = *((unsigned int *)v513 + 22);
  if (v521 > *((_DWORD *)v513 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v513 + 10), v513 + 12, v521, 16);
    LODWORD(v521) = *((_DWORD *)v513 + 22);
  }
  *((_DWORD *)v513 + 22) = v521;
  v523 = (char *)a1[2];
  v522 = a1[3];
  if ((unint64_t)v523 >= v522)
  {
    v525 = (char *)a1[1];
    v526 = (v523 - v525) >> 3;
    v527 = v526 + 1;
    if ((unint64_t)(v526 + 1) >> 61)
      goto LABEL_1055;
    v528 = v522 - (_QWORD)v525;
    if (v528 >> 2 > v527)
      v527 = v528 >> 2;
    if ((unint64_t)v528 >= 0x7FFFFFFFFFFFFFF8)
      v529 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v529 = v527;
    if (v529)
    {
      if (v529 >> 61)
        goto LABEL_1056;
      v530 = (char *)operator new(8 * v529);
    }
    else
    {
      v530 = 0;
    }
    v531 = &v530[8 * v526];
    v532 = &v530[8 * v529];
    *(_QWORD *)v531 = v513;
    v524 = v531 + 8;
    if (v523 == v525)
    {
      a1[1] = (uint64_t)v531;
      a1[2] = (uint64_t)v524;
      a1[3] = (uint64_t)v532;
    }
    else
    {
      v533 = v523 - v525 - 8;
      if (v533 < 0x78
        || &v523[-(v533 & 0xFFFFFFFFFFFFFFF8) - 8] < v531
        && &v530[v523 - v525 - (v533 & 0xFFFFFFFFFFFFFFF8) - 8] < v523)
      {
        goto LABEL_1074;
      }
      v534 = (v533 >> 3) + 1;
      v535 = 8 * (v534 & 0x3FFFFFFFFFFFFFFCLL);
      v536 = &v523[-v535];
      v531 -= v535;
      v537 = &v530[8 * v526 - 16];
      v538 = v523 - 16;
      v539 = v534 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v541 = *((_OWORD *)v538 - 1);
        v540 = *(_OWORD *)v538;
        *((_OWORD *)v538 - 1) = 0uLL;
        *(_OWORD *)v538 = 0uLL;
        *((_OWORD *)v537 - 1) = v541;
        *(_OWORD *)v537 = v540;
        v537 -= 32;
        v538 -= 32;
        v539 -= 4;
      }
      while (v539);
      v523 = v536;
      if (v534 != (v534 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1074:
        do
        {
          v542 = *((_QWORD *)v523 - 1);
          v523 -= 8;
          *(_QWORD *)v523 = 0;
          *((_QWORD *)v531 - 1) = v542;
          v531 -= 8;
        }
        while (v523 != v525);
      }
      v523 = (char *)a1[1];
      v543 = (char *)a1[2];
      a1[1] = (uint64_t)v531;
      a1[2] = (uint64_t)v524;
      a1[3] = (uint64_t)v532;
      while (v543 != v523)
      {
        v545 = *((_QWORD *)v543 - 1);
        v543 -= 8;
        v544 = v545;
        *(_QWORD *)v543 = 0;
        if (v545)
          (*(void (**)(uint64_t))(*(_QWORD *)v544 + 8))(v544);
      }
    }
    if (v523)
      operator delete(v523);
  }
  else
  {
    *(_QWORD *)v523 = v513;
    v524 = v523 + 8;
  }
  a1[2] = (uint64_t)v524;
  v546 = *a1;
  v547 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  *(_QWORD *)&v921 = "mps.maximum";
  *((_QWORD *)&v921 + 1) = 11;
  mlir::Pattern::Pattern((uint64_t)(v547 + 1), (uint64_t)"mps.relu", 8, v920, v546, &v921, 1uLL);
  *v547 = off_1E0E48C58;
  if (!v547[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerRelu]";
    *((_QWORD *)&v921 + 1) = 97;
    v548 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v548)
      v549 = v548;
    else
      v549 = *((_QWORD *)&v921 + 1);
    v550 = v921 + v549;
    v551 = *((_QWORD *)&v921 + 1) - v549;
    if (*((_QWORD *)&v921 + 1) - v549 >= 0x12)
      v552 = 18;
    else
      v552 = *((_QWORD *)&v921 + 1) - v549;
    v553 = v550 + v552;
    v554 = v551 - v552;
    if (v554 >= v554 - 1)
      --v554;
    v547[8] = v553;
    v547[9] = v554;
  }
  v555 = *((unsigned int *)v547 + 22);
  if (v555 > *((_DWORD *)v547 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v547 + 10), v547 + 12, v555, 16);
    LODWORD(v555) = *((_DWORD *)v547 + 22);
  }
  *((_DWORD *)v547 + 22) = v555;
  v557 = (char *)a1[2];
  v556 = a1[3];
  if ((unint64_t)v557 >= v556)
  {
    v559 = (char *)a1[1];
    v560 = (v557 - v559) >> 3;
    v561 = v560 + 1;
    if ((unint64_t)(v560 + 1) >> 61)
      goto LABEL_1055;
    v562 = v556 - (_QWORD)v559;
    if (v562 >> 2 > v561)
      v561 = v562 >> 2;
    if ((unint64_t)v562 >= 0x7FFFFFFFFFFFFFF8)
      v563 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v563 = v561;
    if (v563)
    {
      if (v563 >> 61)
        goto LABEL_1056;
      v564 = (char *)operator new(8 * v563);
    }
    else
    {
      v564 = 0;
    }
    v565 = &v564[8 * v560];
    v566 = &v564[8 * v563];
    *(_QWORD *)v565 = v547;
    v558 = v565 + 8;
    if (v557 == v559)
    {
      a1[1] = (uint64_t)v565;
      a1[2] = (uint64_t)v558;
      a1[3] = (uint64_t)v566;
    }
    else
    {
      v567 = v557 - v559 - 8;
      if (v567 < 0x78
        || &v557[-(v567 & 0xFFFFFFFFFFFFFFF8) - 8] < v565
        && &v564[v557 - v559 - (v567 & 0xFFFFFFFFFFFFFFF8) - 8] < v557)
      {
        goto LABEL_1075;
      }
      v568 = (v567 >> 3) + 1;
      v569 = 8 * (v568 & 0x3FFFFFFFFFFFFFFCLL);
      v570 = &v557[-v569];
      v565 -= v569;
      v571 = &v564[8 * v560 - 16];
      v572 = v557 - 16;
      v573 = v568 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v575 = *((_OWORD *)v572 - 1);
        v574 = *(_OWORD *)v572;
        *((_OWORD *)v572 - 1) = 0uLL;
        *(_OWORD *)v572 = 0uLL;
        *((_OWORD *)v571 - 1) = v575;
        *(_OWORD *)v571 = v574;
        v571 -= 32;
        v572 -= 32;
        v573 -= 4;
      }
      while (v573);
      v557 = v570;
      if (v568 != (v568 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1075:
        do
        {
          v576 = *((_QWORD *)v557 - 1);
          v557 -= 8;
          *(_QWORD *)v557 = 0;
          *((_QWORD *)v565 - 1) = v576;
          v565 -= 8;
        }
        while (v557 != v559);
      }
      v557 = (char *)a1[1];
      v577 = (char *)a1[2];
      a1[1] = (uint64_t)v565;
      a1[2] = (uint64_t)v558;
      a1[3] = (uint64_t)v566;
      while (v577 != v557)
      {
        v579 = *((_QWORD *)v577 - 1);
        v577 -= 8;
        v578 = v579;
        *(_QWORD *)v577 = 0;
        if (v579)
          (*(void (**)(uint64_t))(*(_QWORD *)v578 + 8))(v578);
      }
    }
    if (v557)
      operator delete(v557);
  }
  else
  {
    *(_QWORD *)v557 = v547;
    v558 = v557 + 8;
  }
  a1[2] = (uint64_t)v558;
  v580 = *a1;
  v581 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E54728;
  v922 = *(_OWORD *)&off_1E0E54738;
  mlir::Pattern::Pattern((uint64_t)(v581 + 1), (uint64_t)"mps.relu6", 9, v920, v580, &v921, 2uLL);
  *v581 = off_1E0E48EF8;
  if (!v581[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerRelu6]";
    *((_QWORD *)&v921 + 1) = 98;
    v582 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v582)
      v583 = v582;
    else
      v583 = *((_QWORD *)&v921 + 1);
    v584 = v921 + v583;
    v585 = *((_QWORD *)&v921 + 1) - v583;
    if (*((_QWORD *)&v921 + 1) - v583 >= 0x12)
      v586 = 18;
    else
      v586 = *((_QWORD *)&v921 + 1) - v583;
    v587 = v584 + v586;
    v588 = v585 - v586;
    if (v588 >= v588 - 1)
      --v588;
    v581[8] = v587;
    v581[9] = v588;
  }
  v589 = *((unsigned int *)v581 + 22);
  if (v589 > *((_DWORD *)v581 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v581 + 10), v581 + 12, v589, 16);
    LODWORD(v589) = *((_DWORD *)v581 + 22);
  }
  *((_DWORD *)v581 + 22) = v589;
  v591 = (char *)a1[2];
  v590 = a1[3];
  if ((unint64_t)v591 >= v590)
  {
    v593 = (char *)a1[1];
    v594 = (v591 - v593) >> 3;
    v595 = v594 + 1;
    if ((unint64_t)(v594 + 1) >> 61)
      goto LABEL_1055;
    v596 = v590 - (_QWORD)v593;
    if (v596 >> 2 > v595)
      v595 = v596 >> 2;
    if ((unint64_t)v596 >= 0x7FFFFFFFFFFFFFF8)
      v597 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v597 = v595;
    if (v597)
    {
      if (v597 >> 61)
        goto LABEL_1056;
      v598 = (char *)operator new(8 * v597);
    }
    else
    {
      v598 = 0;
    }
    v599 = &v598[8 * v594];
    v600 = &v598[8 * v597];
    *(_QWORD *)v599 = v581;
    v592 = v599 + 8;
    if (v591 == v593)
    {
      a1[1] = (uint64_t)v599;
      a1[2] = (uint64_t)v592;
      a1[3] = (uint64_t)v600;
    }
    else
    {
      v601 = v591 - v593 - 8;
      if (v601 < 0x78
        || &v591[-(v601 & 0xFFFFFFFFFFFFFFF8) - 8] < v599
        && &v598[v591 - v593 - (v601 & 0xFFFFFFFFFFFFFFF8) - 8] < v591)
      {
        goto LABEL_1076;
      }
      v602 = (v601 >> 3) + 1;
      v603 = 8 * (v602 & 0x3FFFFFFFFFFFFFFCLL);
      v604 = &v591[-v603];
      v599 -= v603;
      v605 = &v598[8 * v594 - 16];
      v606 = v591 - 16;
      v607 = v602 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v609 = *((_OWORD *)v606 - 1);
        v608 = *(_OWORD *)v606;
        *((_OWORD *)v606 - 1) = 0uLL;
        *(_OWORD *)v606 = 0uLL;
        *((_OWORD *)v605 - 1) = v609;
        *(_OWORD *)v605 = v608;
        v605 -= 32;
        v606 -= 32;
        v607 -= 4;
      }
      while (v607);
      v591 = v604;
      if (v602 != (v602 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1076:
        do
        {
          v610 = *((_QWORD *)v591 - 1);
          v591 -= 8;
          *(_QWORD *)v591 = 0;
          *((_QWORD *)v599 - 1) = v610;
          v599 -= 8;
        }
        while (v591 != v593);
      }
      v591 = (char *)a1[1];
      v611 = (char *)a1[2];
      a1[1] = (uint64_t)v599;
      a1[2] = (uint64_t)v592;
      a1[3] = (uint64_t)v600;
      while (v611 != v591)
      {
        v613 = *((_QWORD *)v611 - 1);
        v611 -= 8;
        v612 = v613;
        *(_QWORD *)v611 = 0;
        if (v613)
          (*(void (**)(uint64_t))(*(_QWORD *)v612 + 8))(v612);
      }
    }
    if (v591)
      operator delete(v591);
  }
  else
  {
    *(_QWORD *)v591 = v581;
    v592 = v591 + 8;
  }
  a1[2] = (uint64_t)v592;
  v614 = *a1;
  v615 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E54748;
  v922 = *(_OWORD *)&off_1E0E54758;
  mlir::Pattern::Pattern((uint64_t)(v615 + 1), (uint64_t)"mps.relu_grad", 13, v920, v614, &v921, 2uLL);
  *v615 = off_1E0E49528;
  if (!v615[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerReluGrad]";
    *((_QWORD *)&v921 + 1) = 101;
    v616 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v616)
      v617 = v616;
    else
      v617 = *((_QWORD *)&v921 + 1);
    v618 = v921 + v617;
    v619 = *((_QWORD *)&v921 + 1) - v617;
    if (*((_QWORD *)&v921 + 1) - v617 >= 0x12)
      v620 = 18;
    else
      v620 = *((_QWORD *)&v921 + 1) - v617;
    v621 = v618 + v620;
    v622 = v619 - v620;
    if (v622 >= v622 - 1)
      --v622;
    v615[8] = v621;
    v615[9] = v622;
  }
  v623 = *((unsigned int *)v615 + 22);
  if (v623 > *((_DWORD *)v615 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v615 + 10), v615 + 12, v623, 16);
    LODWORD(v623) = *((_DWORD *)v615 + 22);
  }
  *((_DWORD *)v615 + 22) = v623;
  v625 = (char *)a1[2];
  v624 = a1[3];
  if ((unint64_t)v625 >= v624)
  {
    v627 = (char *)a1[1];
    v628 = (v625 - v627) >> 3;
    v629 = v628 + 1;
    if ((unint64_t)(v628 + 1) >> 61)
      goto LABEL_1055;
    v630 = v624 - (_QWORD)v627;
    if (v630 >> 2 > v629)
      v629 = v630 >> 2;
    if ((unint64_t)v630 >= 0x7FFFFFFFFFFFFFF8)
      v631 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v631 = v629;
    if (v631)
    {
      if (v631 >> 61)
        goto LABEL_1056;
      v632 = (char *)operator new(8 * v631);
    }
    else
    {
      v632 = 0;
    }
    v633 = &v632[8 * v628];
    v634 = &v632[8 * v631];
    *(_QWORD *)v633 = v615;
    v626 = v633 + 8;
    if (v625 == v627)
    {
      a1[1] = (uint64_t)v633;
      a1[2] = (uint64_t)v626;
      a1[3] = (uint64_t)v634;
    }
    else
    {
      v635 = v625 - v627 - 8;
      if (v635 < 0x78
        || &v625[-(v635 & 0xFFFFFFFFFFFFFFF8) - 8] < v633
        && &v632[v625 - v627 - (v635 & 0xFFFFFFFFFFFFFFF8) - 8] < v625)
      {
        goto LABEL_1077;
      }
      v636 = (v635 >> 3) + 1;
      v637 = 8 * (v636 & 0x3FFFFFFFFFFFFFFCLL);
      v638 = &v625[-v637];
      v633 -= v637;
      v639 = &v632[8 * v628 - 16];
      v640 = v625 - 16;
      v641 = v636 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v643 = *((_OWORD *)v640 - 1);
        v642 = *(_OWORD *)v640;
        *((_OWORD *)v640 - 1) = 0uLL;
        *(_OWORD *)v640 = 0uLL;
        *((_OWORD *)v639 - 1) = v643;
        *(_OWORD *)v639 = v642;
        v639 -= 32;
        v640 -= 32;
        v641 -= 4;
      }
      while (v641);
      v625 = v638;
      if (v636 != (v636 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1077:
        do
        {
          v644 = *((_QWORD *)v625 - 1);
          v625 -= 8;
          *(_QWORD *)v625 = 0;
          *((_QWORD *)v633 - 1) = v644;
          v633 -= 8;
        }
        while (v625 != v627);
      }
      v625 = (char *)a1[1];
      v645 = (char *)a1[2];
      a1[1] = (uint64_t)v633;
      a1[2] = (uint64_t)v626;
      a1[3] = (uint64_t)v634;
      while (v645 != v625)
      {
        v647 = *((_QWORD *)v645 - 1);
        v645 -= 8;
        v646 = v647;
        *(_QWORD *)v645 = 0;
        if (v647)
          (*(void (**)(uint64_t))(*(_QWORD *)v646 + 8))(v646);
      }
    }
    if (v625)
      operator delete(v625);
  }
  else
  {
    *(_QWORD *)v625 = v615;
    v626 = v625 + 8;
  }
  a1[2] = (uint64_t)v626;
  v648 = *a1;
  v649 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E54768;
  v922 = *(_OWORD *)&off_1E0E54778;
  v923 = xmmword_1E0E54788;
  mlir::Pattern::Pattern((uint64_t)(v649 + 1), (uint64_t)"mps.sigmoid_gradient", 20, v920, v648, &v921, 3uLL);
  *v649 = off_1E0E4A9C0;
  if (!v649[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerSigmoidGradient]";
    *((_QWORD *)&v921 + 1) = 108;
    v650 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v650)
      v651 = v650;
    else
      v651 = *((_QWORD *)&v921 + 1);
    v652 = v921 + v651;
    v653 = *((_QWORD *)&v921 + 1) - v651;
    if (*((_QWORD *)&v921 + 1) - v651 >= 0x12)
      v654 = 18;
    else
      v654 = *((_QWORD *)&v921 + 1) - v651;
    v655 = v652 + v654;
    v656 = v653 - v654;
    if (v656 >= v656 - 1)
      --v656;
    v649[8] = v655;
    v649[9] = v656;
  }
  v657 = *((unsigned int *)v649 + 22);
  if (v657 > *((_DWORD *)v649 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v649 + 10), v649 + 12, v657, 16);
    LODWORD(v657) = *((_DWORD *)v649 + 22);
  }
  *((_DWORD *)v649 + 22) = v657;
  v659 = (char *)a1[2];
  v658 = a1[3];
  if ((unint64_t)v659 >= v658)
  {
    v661 = (char *)a1[1];
    v662 = (v659 - v661) >> 3;
    v663 = v662 + 1;
    if ((unint64_t)(v662 + 1) >> 61)
      goto LABEL_1055;
    v664 = v658 - (_QWORD)v661;
    if (v664 >> 2 > v663)
      v663 = v664 >> 2;
    if ((unint64_t)v664 >= 0x7FFFFFFFFFFFFFF8)
      v665 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v665 = v663;
    if (v665)
    {
      if (v665 >> 61)
        goto LABEL_1056;
      v666 = (char *)operator new(8 * v665);
    }
    else
    {
      v666 = 0;
    }
    v667 = &v666[8 * v662];
    v668 = &v666[8 * v665];
    *(_QWORD *)v667 = v649;
    v660 = v667 + 8;
    if (v659 == v661)
    {
      a1[1] = (uint64_t)v667;
      a1[2] = (uint64_t)v660;
      a1[3] = (uint64_t)v668;
    }
    else
    {
      v669 = v659 - v661 - 8;
      if (v669 < 0x78
        || &v659[-(v669 & 0xFFFFFFFFFFFFFFF8) - 8] < v667
        && &v666[v659 - v661 - (v669 & 0xFFFFFFFFFFFFFFF8) - 8] < v659)
      {
        goto LABEL_1078;
      }
      v670 = (v669 >> 3) + 1;
      v671 = 8 * (v670 & 0x3FFFFFFFFFFFFFFCLL);
      v672 = &v659[-v671];
      v667 -= v671;
      v673 = &v666[8 * v662 - 16];
      v674 = v659 - 16;
      v675 = v670 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v677 = *((_OWORD *)v674 - 1);
        v676 = *(_OWORD *)v674;
        *((_OWORD *)v674 - 1) = 0uLL;
        *(_OWORD *)v674 = 0uLL;
        *((_OWORD *)v673 - 1) = v677;
        *(_OWORD *)v673 = v676;
        v673 -= 32;
        v674 -= 32;
        v675 -= 4;
      }
      while (v675);
      v659 = v672;
      if (v670 != (v670 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1078:
        do
        {
          v678 = *((_QWORD *)v659 - 1);
          v659 -= 8;
          *(_QWORD *)v659 = 0;
          *((_QWORD *)v667 - 1) = v678;
          v667 -= 8;
        }
        while (v659 != v661);
      }
      v659 = (char *)a1[1];
      v679 = (char *)a1[2];
      a1[1] = (uint64_t)v667;
      a1[2] = (uint64_t)v660;
      a1[3] = (uint64_t)v668;
      while (v679 != v659)
      {
        v681 = *((_QWORD *)v679 - 1);
        v679 -= 8;
        v680 = v681;
        *(_QWORD *)v679 = 0;
        if (v681)
          (*(void (**)(uint64_t))(*(_QWORD *)v680 + 8))(v680);
      }
    }
    if (v659)
      operator delete(v659);
  }
  else
  {
    *(_QWORD *)v659 = v649;
    v660 = v659 + 8;
  }
  a1[2] = (uint64_t)v660;
  v682 = *a1;
  v683 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E54798;
  v922 = *(_OWORD *)&off_1E0E547A8;
  mlir::Pattern::Pattern((uint64_t)(v683 + 1), (uint64_t)"mps.sigmoid_gradient_with_sigmoid", 33, v920, v682, &v921, 2uLL);
  *v683 = off_1E0E4B370;
  if (!v683[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerSigmo"
                       "idGradientWithSigmoid]";
    *((_QWORD *)&v921 + 1) = 119;
    v684 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v684)
      v685 = v684;
    else
      v685 = *((_QWORD *)&v921 + 1);
    v686 = v921 + v685;
    v687 = *((_QWORD *)&v921 + 1) - v685;
    if (*((_QWORD *)&v921 + 1) - v685 >= 0x12)
      v688 = 18;
    else
      v688 = *((_QWORD *)&v921 + 1) - v685;
    v689 = v686 + v688;
    v690 = v687 - v688;
    if (v690 >= v690 - 1)
      --v690;
    v683[8] = v689;
    v683[9] = v690;
  }
  v691 = *((unsigned int *)v683 + 22);
  if (v691 > *((_DWORD *)v683 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v683 + 10), v683 + 12, v691, 16);
    LODWORD(v691) = *((_DWORD *)v683 + 22);
  }
  *((_DWORD *)v683 + 22) = v691;
  v693 = (char *)a1[2];
  v692 = a1[3];
  if ((unint64_t)v693 >= v692)
  {
    v695 = (char *)a1[1];
    v696 = (v693 - v695) >> 3;
    v697 = v696 + 1;
    if ((unint64_t)(v696 + 1) >> 61)
      goto LABEL_1055;
    v698 = v692 - (_QWORD)v695;
    if (v698 >> 2 > v697)
      v697 = v698 >> 2;
    if ((unint64_t)v698 >= 0x7FFFFFFFFFFFFFF8)
      v699 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v699 = v697;
    if (v699)
    {
      if (v699 >> 61)
        goto LABEL_1056;
      v700 = (char *)operator new(8 * v699);
    }
    else
    {
      v700 = 0;
    }
    v701 = &v700[8 * v696];
    v702 = &v700[8 * v699];
    *(_QWORD *)v701 = v683;
    v694 = v701 + 8;
    if (v693 == v695)
    {
      a1[1] = (uint64_t)v701;
      a1[2] = (uint64_t)v694;
      a1[3] = (uint64_t)v702;
    }
    else
    {
      v703 = v693 - v695 - 8;
      if (v703 < 0x78
        || &v693[-(v703 & 0xFFFFFFFFFFFFFFF8) - 8] < v701
        && &v700[v693 - v695 - (v703 & 0xFFFFFFFFFFFFFFF8) - 8] < v693)
      {
        goto LABEL_1079;
      }
      v704 = (v703 >> 3) + 1;
      v705 = 8 * (v704 & 0x3FFFFFFFFFFFFFFCLL);
      v706 = &v693[-v705];
      v701 -= v705;
      v707 = &v700[8 * v696 - 16];
      v708 = v693 - 16;
      v709 = v704 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v711 = *((_OWORD *)v708 - 1);
        v710 = *(_OWORD *)v708;
        *((_OWORD *)v708 - 1) = 0uLL;
        *(_OWORD *)v708 = 0uLL;
        *((_OWORD *)v707 - 1) = v711;
        *(_OWORD *)v707 = v710;
        v707 -= 32;
        v708 -= 32;
        v709 -= 4;
      }
      while (v709);
      v693 = v706;
      if (v704 != (v704 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1079:
        do
        {
          v712 = *((_QWORD *)v693 - 1);
          v693 -= 8;
          *(_QWORD *)v693 = 0;
          *((_QWORD *)v701 - 1) = v712;
          v701 -= 8;
        }
        while (v693 != v695);
      }
      v693 = (char *)a1[1];
      v713 = (char *)a1[2];
      a1[1] = (uint64_t)v701;
      a1[2] = (uint64_t)v694;
      a1[3] = (uint64_t)v702;
      while (v713 != v693)
      {
        v715 = *((_QWORD *)v713 - 1);
        v713 -= 8;
        v714 = v715;
        *(_QWORD *)v713 = 0;
        if (v715)
          (*(void (**)(uint64_t))(*(_QWORD *)v714 + 8))(v714);
      }
    }
    if (v693)
      operator delete(v693);
  }
  else
  {
    *(_QWORD *)v693 = v683;
    v694 = v693 + 8;
  }
  a1[2] = (uint64_t)v694;
  v716 = *a1;
  v717 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E547B8;
  v922 = *(_OWORD *)&off_1E0E547C8;
  v923 = xmmword_1E0E547D8;
  v924 = *(_OWORD *)&off_1E0E547E8;
  mlir::Pattern::Pattern((uint64_t)(v717 + 1), (uint64_t)"mps.sigmoid_hard", 16, v920, v716, &v921, 4uLL);
  *v717 = off_1E0E49E10;
  if (!v717[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerSigmoidHard]";
    *((_QWORD *)&v921 + 1) = 104;
    v718 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v718)
      v719 = v718;
    else
      v719 = *((_QWORD *)&v921 + 1);
    v720 = v921 + v719;
    v721 = *((_QWORD *)&v921 + 1) - v719;
    if (*((_QWORD *)&v921 + 1) - v719 >= 0x12)
      v722 = 18;
    else
      v722 = *((_QWORD *)&v921 + 1) - v719;
    v723 = v720 + v722;
    v724 = v721 - v722;
    if (v724 >= v724 - 1)
      --v724;
    v717[8] = v723;
    v717[9] = v724;
  }
  v725 = *((unsigned int *)v717 + 22);
  if (v725 > *((_DWORD *)v717 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v717 + 10), v717 + 12, v725, 16);
    LODWORD(v725) = *((_DWORD *)v717 + 22);
  }
  *((_DWORD *)v717 + 22) = v725;
  v727 = (char *)a1[2];
  v726 = a1[3];
  if ((unint64_t)v727 >= v726)
  {
    v729 = (char *)a1[1];
    v730 = (v727 - v729) >> 3;
    v731 = v730 + 1;
    if ((unint64_t)(v730 + 1) >> 61)
      goto LABEL_1055;
    v732 = v726 - (_QWORD)v729;
    if (v732 >> 2 > v731)
      v731 = v732 >> 2;
    if ((unint64_t)v732 >= 0x7FFFFFFFFFFFFFF8)
      v733 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v733 = v731;
    if (v733)
    {
      if (v733 >> 61)
        goto LABEL_1056;
      v734 = (char *)operator new(8 * v733);
    }
    else
    {
      v734 = 0;
    }
    v735 = &v734[8 * v730];
    v736 = &v734[8 * v733];
    *(_QWORD *)v735 = v717;
    v728 = v735 + 8;
    if (v727 == v729)
    {
      a1[1] = (uint64_t)v735;
      a1[2] = (uint64_t)v728;
      a1[3] = (uint64_t)v736;
    }
    else
    {
      v737 = v727 - v729 - 8;
      if (v737 < 0x78
        || &v727[-(v737 & 0xFFFFFFFFFFFFFFF8) - 8] < v735
        && &v734[v727 - v729 - (v737 & 0xFFFFFFFFFFFFFFF8) - 8] < v727)
      {
        goto LABEL_1080;
      }
      v738 = (v737 >> 3) + 1;
      v739 = 8 * (v738 & 0x3FFFFFFFFFFFFFFCLL);
      v740 = &v727[-v739];
      v735 -= v739;
      v741 = &v734[8 * v730 - 16];
      v742 = v727 - 16;
      v743 = v738 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v745 = *((_OWORD *)v742 - 1);
        v744 = *(_OWORD *)v742;
        *((_OWORD *)v742 - 1) = 0uLL;
        *(_OWORD *)v742 = 0uLL;
        *((_OWORD *)v741 - 1) = v745;
        *(_OWORD *)v741 = v744;
        v741 -= 32;
        v742 -= 32;
        v743 -= 4;
      }
      while (v743);
      v727 = v740;
      if (v738 != (v738 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1080:
        do
        {
          v746 = *((_QWORD *)v727 - 1);
          v727 -= 8;
          *(_QWORD *)v727 = 0;
          *((_QWORD *)v735 - 1) = v746;
          v735 -= 8;
        }
        while (v727 != v729);
      }
      v727 = (char *)a1[1];
      v747 = (char *)a1[2];
      a1[1] = (uint64_t)v735;
      a1[2] = (uint64_t)v728;
      a1[3] = (uint64_t)v736;
      while (v747 != v727)
      {
        v749 = *((_QWORD *)v747 - 1);
        v747 -= 8;
        v748 = v749;
        *(_QWORD *)v747 = 0;
        if (v749)
          (*(void (**)(uint64_t))(*(_QWORD *)v748 + 8))(v748);
      }
    }
    if (v727)
      operator delete(v727);
  }
  else
  {
    *(_QWORD *)v727 = v717;
    v728 = v727 + 8;
  }
  a1[2] = (uint64_t)v728;
  v750 = *a1;
  v751 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v923 = xmmword_1E0E54818;
  v924 = *(_OWORD *)&off_1E0E54828;
  v925 = xmmword_1E0E54838;
  v921 = xmmword_1E0E547F8;
  v922 = *(_OWORD *)&off_1E0E54808;
  mlir::Pattern::Pattern((uint64_t)(v751 + 1), (uint64_t)"mps.softmax", 11, v920, v750, &v921, 5uLL);
  *v751 = off_1E0E492A0;
  if (!v751[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerSoftmax]";
    *((_QWORD *)&v921 + 1) = 100;
    v752 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v752)
      v753 = v752;
    else
      v753 = *((_QWORD *)&v921 + 1);
    v754 = v921 + v753;
    v755 = *((_QWORD *)&v921 + 1) - v753;
    if (*((_QWORD *)&v921 + 1) - v753 >= 0x12)
      v756 = 18;
    else
      v756 = *((_QWORD *)&v921 + 1) - v753;
    v757 = v754 + v756;
    v758 = v755 - v756;
    if (v758 >= v758 - 1)
      --v758;
    v751[8] = v757;
    v751[9] = v758;
  }
  v759 = *((unsigned int *)v751 + 22);
  if (v759 > *((_DWORD *)v751 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v751 + 10), v751 + 12, v759, 16);
    LODWORD(v759) = *((_DWORD *)v751 + 22);
  }
  *((_DWORD *)v751 + 22) = v759;
  v761 = (char *)a1[2];
  v760 = a1[3];
  if ((unint64_t)v761 >= v760)
  {
    v763 = (char *)a1[1];
    v764 = (v761 - v763) >> 3;
    v765 = v764 + 1;
    if ((unint64_t)(v764 + 1) >> 61)
      goto LABEL_1055;
    v766 = v760 - (_QWORD)v763;
    if (v766 >> 2 > v765)
      v765 = v766 >> 2;
    if ((unint64_t)v766 >= 0x7FFFFFFFFFFFFFF8)
      v767 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v767 = v765;
    if (v767)
    {
      if (v767 >> 61)
        goto LABEL_1056;
      v768 = (char *)operator new(8 * v767);
    }
    else
    {
      v768 = 0;
    }
    v769 = &v768[8 * v764];
    v770 = &v768[8 * v767];
    *(_QWORD *)v769 = v751;
    v762 = v769 + 8;
    if (v761 == v763)
    {
      a1[1] = (uint64_t)v769;
      a1[2] = (uint64_t)v762;
      a1[3] = (uint64_t)v770;
    }
    else
    {
      v771 = v761 - v763 - 8;
      if (v771 < 0x78
        || &v761[-(v771 & 0xFFFFFFFFFFFFFFF8) - 8] < v769
        && &v768[v761 - v763 - (v771 & 0xFFFFFFFFFFFFFFF8) - 8] < v761)
      {
        goto LABEL_1081;
      }
      v772 = (v771 >> 3) + 1;
      v773 = 8 * (v772 & 0x3FFFFFFFFFFFFFFCLL);
      v774 = &v761[-v773];
      v769 -= v773;
      v775 = &v768[8 * v764 - 16];
      v776 = v761 - 16;
      v777 = v772 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v779 = *((_OWORD *)v776 - 1);
        v778 = *(_OWORD *)v776;
        *((_OWORD *)v776 - 1) = 0uLL;
        *(_OWORD *)v776 = 0uLL;
        *((_OWORD *)v775 - 1) = v779;
        *(_OWORD *)v775 = v778;
        v775 -= 32;
        v776 -= 32;
        v777 -= 4;
      }
      while (v777);
      v761 = v774;
      if (v772 != (v772 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1081:
        do
        {
          v780 = *((_QWORD *)v761 - 1);
          v761 -= 8;
          *(_QWORD *)v761 = 0;
          *((_QWORD *)v769 - 1) = v780;
          v769 -= 8;
        }
        while (v761 != v763);
      }
      v761 = (char *)a1[1];
      v781 = (char *)a1[2];
      a1[1] = (uint64_t)v769;
      a1[2] = (uint64_t)v762;
      a1[3] = (uint64_t)v770;
      while (v781 != v761)
      {
        v783 = *((_QWORD *)v781 - 1);
        v781 -= 8;
        v782 = v783;
        *(_QWORD *)v781 = 0;
        if (v783)
          (*(void (**)(uint64_t))(*(_QWORD *)v782 + 8))(v782);
      }
    }
    if (v761)
      operator delete(v761);
  }
  else
  {
    *(_QWORD *)v761 = v751;
    v762 = v761 + 8;
  }
  a1[2] = (uint64_t)v762;
  v784 = *a1;
  v785 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E54848;
  v922 = *(_OWORD *)&off_1E0E54858;
  v923 = xmmword_1E0E54868;
  mlir::Pattern::Pattern((uint64_t)(v785 + 1), (uint64_t)"mps.softplus_parametric", 23, v920, v784, &v921, 3uLL);
  *v785 = off_1E0E4AF10;
  if (!v785[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerSoftplusParametric]";
    *((_QWORD *)&v921 + 1) = 111;
    v786 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v786)
      v787 = v786;
    else
      v787 = *((_QWORD *)&v921 + 1);
    v788 = v921 + v787;
    v789 = *((_QWORD *)&v921 + 1) - v787;
    if (*((_QWORD *)&v921 + 1) - v787 >= 0x12)
      v790 = 18;
    else
      v790 = *((_QWORD *)&v921 + 1) - v787;
    v791 = v788 + v790;
    v792 = v789 - v790;
    if (v792 >= v792 - 1)
      --v792;
    v785[8] = v791;
    v785[9] = v792;
  }
  v793 = *((unsigned int *)v785 + 22);
  if (v793 > *((_DWORD *)v785 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v785 + 10), v785 + 12, v793, 16);
    LODWORD(v793) = *((_DWORD *)v785 + 22);
  }
  *((_DWORD *)v785 + 22) = v793;
  v795 = (char *)a1[2];
  v794 = a1[3];
  if ((unint64_t)v795 >= v794)
  {
    v797 = (char *)a1[1];
    v798 = (v795 - v797) >> 3;
    v799 = v798 + 1;
    if ((unint64_t)(v798 + 1) >> 61)
      goto LABEL_1055;
    v800 = v794 - (_QWORD)v797;
    if (v800 >> 2 > v799)
      v799 = v800 >> 2;
    if ((unint64_t)v800 >= 0x7FFFFFFFFFFFFFF8)
      v801 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v801 = v799;
    if (v801)
    {
      if (v801 >> 61)
        goto LABEL_1056;
      v802 = (char *)operator new(8 * v801);
    }
    else
    {
      v802 = 0;
    }
    v803 = &v802[8 * v798];
    v804 = &v802[8 * v801];
    *(_QWORD *)v803 = v785;
    v796 = v803 + 8;
    if (v795 == v797)
    {
      a1[1] = (uint64_t)v803;
      a1[2] = (uint64_t)v796;
      a1[3] = (uint64_t)v804;
    }
    else
    {
      v805 = v795 - v797 - 8;
      if (v805 < 0x78
        || &v795[-(v805 & 0xFFFFFFFFFFFFFFF8) - 8] < v803
        && &v802[v795 - v797 - (v805 & 0xFFFFFFFFFFFFFFF8) - 8] < v795)
      {
        goto LABEL_1082;
      }
      v806 = (v805 >> 3) + 1;
      v807 = 8 * (v806 & 0x3FFFFFFFFFFFFFFCLL);
      v808 = &v795[-v807];
      v803 -= v807;
      v809 = &v802[8 * v798 - 16];
      v810 = v795 - 16;
      v811 = v806 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v813 = *((_OWORD *)v810 - 1);
        v812 = *(_OWORD *)v810;
        *((_OWORD *)v810 - 1) = 0uLL;
        *(_OWORD *)v810 = 0uLL;
        *((_OWORD *)v809 - 1) = v813;
        *(_OWORD *)v809 = v812;
        v809 -= 32;
        v810 -= 32;
        v811 -= 4;
      }
      while (v811);
      v795 = v808;
      if (v806 != (v806 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1082:
        do
        {
          v814 = *((_QWORD *)v795 - 1);
          v795 -= 8;
          *(_QWORD *)v795 = 0;
          *((_QWORD *)v803 - 1) = v814;
          v803 -= 8;
        }
        while (v795 != v797);
      }
      v795 = (char *)a1[1];
      v815 = (char *)a1[2];
      a1[1] = (uint64_t)v803;
      a1[2] = (uint64_t)v796;
      a1[3] = (uint64_t)v804;
      while (v815 != v795)
      {
        v817 = *((_QWORD *)v815 - 1);
        v815 -= 8;
        v816 = v817;
        *(_QWORD *)v815 = 0;
        if (v817)
          (*(void (**)(uint64_t))(*(_QWORD *)v816 + 8))(v816);
      }
    }
    if (v795)
      operator delete(v795);
  }
  else
  {
    *(_QWORD *)v795 = v785;
    v796 = v795 + 8;
  }
  a1[2] = (uint64_t)v796;
  v818 = *a1;
  v819 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E54878;
  v922 = *(_OWORD *)&off_1E0E54888;
  v923 = xmmword_1E0E54898;
  mlir::Pattern::Pattern((uint64_t)(v819 + 1), (uint64_t)"mps.softsign", 12, v920, v818, &v921, 3uLL);
  *v819 = off_1E0E49568;
  if (!v819[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerSoftsign]";
    *((_QWORD *)&v921 + 1) = 101;
    v820 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v820)
      v821 = v820;
    else
      v821 = *((_QWORD *)&v921 + 1);
    v822 = v921 + v821;
    v823 = *((_QWORD *)&v921 + 1) - v821;
    if (*((_QWORD *)&v921 + 1) - v821 >= 0x12)
      v824 = 18;
    else
      v824 = *((_QWORD *)&v921 + 1) - v821;
    v825 = v822 + v824;
    v826 = v823 - v824;
    if (v826 >= v826 - 1)
      --v826;
    v819[8] = v825;
    v819[9] = v826;
  }
  v827 = *((unsigned int *)v819 + 22);
  if (v827 > *((_DWORD *)v819 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v819 + 10), v819 + 12, v827, 16);
    LODWORD(v827) = *((_DWORD *)v819 + 22);
  }
  *((_DWORD *)v819 + 22) = v827;
  v829 = (char *)a1[2];
  v828 = a1[3];
  if ((unint64_t)v829 >= v828)
  {
    v831 = (char *)a1[1];
    v832 = (v829 - v831) >> 3;
    v833 = v832 + 1;
    if ((unint64_t)(v832 + 1) >> 61)
      goto LABEL_1055;
    v834 = v828 - (_QWORD)v831;
    if (v834 >> 2 > v833)
      v833 = v834 >> 2;
    if ((unint64_t)v834 >= 0x7FFFFFFFFFFFFFF8)
      v835 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v835 = v833;
    if (v835)
    {
      if (v835 >> 61)
        goto LABEL_1056;
      v836 = (char *)operator new(8 * v835);
    }
    else
    {
      v836 = 0;
    }
    v837 = &v836[8 * v832];
    v838 = &v836[8 * v835];
    *(_QWORD *)v837 = v819;
    v830 = v837 + 8;
    if (v829 == v831)
    {
      a1[1] = (uint64_t)v837;
      a1[2] = (uint64_t)v830;
      a1[3] = (uint64_t)v838;
    }
    else
    {
      v839 = v829 - v831 - 8;
      if (v839 < 0x78
        || &v829[-(v839 & 0xFFFFFFFFFFFFFFF8) - 8] < v837
        && &v836[v829 - v831 - (v839 & 0xFFFFFFFFFFFFFFF8) - 8] < v829)
      {
        goto LABEL_1083;
      }
      v840 = (v839 >> 3) + 1;
      v841 = 8 * (v840 & 0x3FFFFFFFFFFFFFFCLL);
      v842 = &v829[-v841];
      v837 -= v841;
      v843 = &v836[8 * v832 - 16];
      v844 = v829 - 16;
      v845 = v840 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v847 = *((_OWORD *)v844 - 1);
        v846 = *(_OWORD *)v844;
        *((_OWORD *)v844 - 1) = 0uLL;
        *(_OWORD *)v844 = 0uLL;
        *((_OWORD *)v843 - 1) = v847;
        *(_OWORD *)v843 = v846;
        v843 -= 32;
        v844 -= 32;
        v845 -= 4;
      }
      while (v845);
      v829 = v842;
      if (v840 != (v840 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1083:
        do
        {
          v848 = *((_QWORD *)v829 - 1);
          v829 -= 8;
          *(_QWORD *)v829 = 0;
          *((_QWORD *)v837 - 1) = v848;
          v837 -= 8;
        }
        while (v829 != v831);
      }
      v829 = (char *)a1[1];
      v849 = (char *)a1[2];
      a1[1] = (uint64_t)v837;
      a1[2] = (uint64_t)v830;
      a1[3] = (uint64_t)v838;
      while (v849 != v829)
      {
        v851 = *((_QWORD *)v849 - 1);
        v849 -= 8;
        v850 = v851;
        *(_QWORD *)v849 = 0;
        if (v851)
          (*(void (**)(uint64_t))(*(_QWORD *)v850 + 8))(v850);
      }
    }
    if (v829)
      operator delete(v829);
  }
  else
  {
    *(_QWORD *)v829 = v819;
    v830 = v829 + 8;
  }
  a1[2] = (uint64_t)v830;
  v852 = *a1;
  v853 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E548A8;
  v922 = *(_OWORD *)&off_1E0E548B8;
  mlir::Pattern::Pattern((uint64_t)(v853 + 1), (uint64_t)"mps.swish", 9, v920, v852, &v921, 2uLL);
  *v853 = off_1E0E48F38;
  if (!v853[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerSwish]";
    *((_QWORD *)&v921 + 1) = 98;
    v854 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v854)
      v855 = v854;
    else
      v855 = *((_QWORD *)&v921 + 1);
    v856 = v921 + v855;
    v857 = *((_QWORD *)&v921 + 1) - v855;
    if (*((_QWORD *)&v921 + 1) - v855 >= 0x12)
      v858 = 18;
    else
      v858 = *((_QWORD *)&v921 + 1) - v855;
    v859 = v856 + v858;
    v860 = v857 - v858;
    if (v860 >= v860 - 1)
      --v860;
    v853[8] = v859;
    v853[9] = v860;
  }
  v861 = *((unsigned int *)v853 + 22);
  if (v861 > *((_DWORD *)v853 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v853 + 10), v853 + 12, v861, 16);
    LODWORD(v861) = *((_DWORD *)v853 + 22);
  }
  *((_DWORD *)v853 + 22) = v861;
  v863 = (char *)a1[2];
  v862 = a1[3];
  if ((unint64_t)v863 >= v862)
  {
    v865 = (char *)a1[1];
    v866 = (v863 - v865) >> 3;
    v867 = v866 + 1;
    if ((unint64_t)(v866 + 1) >> 61)
      goto LABEL_1055;
    v868 = v862 - (_QWORD)v865;
    if (v868 >> 2 > v867)
      v867 = v868 >> 2;
    if ((unint64_t)v868 >= 0x7FFFFFFFFFFFFFF8)
      v869 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v869 = v867;
    if (v869)
    {
      if (v869 >> 61)
        goto LABEL_1056;
      v870 = (char *)operator new(8 * v869);
    }
    else
    {
      v870 = 0;
    }
    v871 = &v870[8 * v866];
    v872 = &v870[8 * v869];
    *(_QWORD *)v871 = v853;
    v864 = v871 + 8;
    if (v863 == v865)
    {
      a1[1] = (uint64_t)v871;
      a1[2] = (uint64_t)v864;
      a1[3] = (uint64_t)v872;
    }
    else
    {
      v873 = v863 - v865 - 8;
      if (v873 < 0x78
        || &v863[-(v873 & 0xFFFFFFFFFFFFFFF8) - 8] < v871
        && &v870[v863 - v865 - (v873 & 0xFFFFFFFFFFFFFFF8) - 8] < v863)
      {
        goto LABEL_1084;
      }
      v874 = (v873 >> 3) + 1;
      v875 = 8 * (v874 & 0x3FFFFFFFFFFFFFFCLL);
      v876 = &v863[-v875];
      v871 -= v875;
      v877 = &v870[8 * v866 - 16];
      v878 = v863 - 16;
      v879 = v874 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v881 = *((_OWORD *)v878 - 1);
        v880 = *(_OWORD *)v878;
        *((_OWORD *)v878 - 1) = 0uLL;
        *(_OWORD *)v878 = 0uLL;
        *((_OWORD *)v877 - 1) = v881;
        *(_OWORD *)v877 = v880;
        v877 -= 32;
        v878 -= 32;
        v879 -= 4;
      }
      while (v879);
      v863 = v876;
      if (v874 != (v874 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_1084:
        do
        {
          v882 = *((_QWORD *)v863 - 1);
          v863 -= 8;
          *(_QWORD *)v863 = 0;
          *((_QWORD *)v871 - 1) = v882;
          v871 -= 8;
        }
        while (v863 != v865);
      }
      v863 = (char *)a1[1];
      v883 = (char *)a1[2];
      a1[1] = (uint64_t)v871;
      a1[2] = (uint64_t)v864;
      a1[3] = (uint64_t)v872;
      while (v883 != v863)
      {
        v885 = *((_QWORD *)v883 - 1);
        v883 -= 8;
        v884 = v885;
        *(_QWORD *)v883 = 0;
        if (v885)
          (*(void (**)(uint64_t))(*(_QWORD *)v884 + 8))(v884);
      }
    }
    if (v863)
      operator delete(v863);
  }
  else
  {
    *(_QWORD *)v863 = v853;
    v864 = v863 + 8;
  }
  a1[2] = (uint64_t)v864;
  v886 = *a1;
  v887 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v920, 1);
  v921 = xmmword_1E0E548C8;
  v922 = *(_OWORD *)&off_1E0E548D8;
  v923 = xmmword_1E0E548E8;
  v924 = *(_OWORD *)&off_1E0E548F8;
  mlir::Pattern::Pattern((uint64_t)(v887 + 1), (uint64_t)"mps.truncate", 12, v920, v886, &v921, 4uLL);
  *v887 = off_1E0E495A8;
  if (!v887[9])
  {
    *(_QWORD *)&v921 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_LowerTruncate]";
    *((_QWORD *)&v921 + 1) = 101;
    v888 = llvm::StringRef::find((uint64_t *)&v921, "DesiredTypeName = ", 0x12uLL, 0);
    if (*((_QWORD *)&v921 + 1) >= v888)
      v889 = v888;
    else
      v889 = *((_QWORD *)&v921 + 1);
    v890 = v921 + v889;
    v891 = *((_QWORD *)&v921 + 1) - v889;
    if (*((_QWORD *)&v921 + 1) - v889 >= 0x12)
      v892 = 18;
    else
      v892 = *((_QWORD *)&v921 + 1) - v889;
    v893 = v890 + v892;
    v894 = v891 - v892;
    if (v894 >= v894 - 1)
      --v894;
    v887[8] = v893;
    v887[9] = v894;
  }
  v895 = *((unsigned int *)v887 + 22);
  if (v895 > *((_DWORD *)v887 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v887 + 10), v887 + 12, v895, 16);
    LODWORD(v895) = *((_DWORD *)v887 + 22);
  }
  *((_DWORD *)v887 + 22) = v895;
  v897 = (char *)a1[2];
  v896 = a1[3];
  if ((unint64_t)v897 < v896)
  {
    *(_QWORD *)v897 = v887;
    v898 = v897 + 8;
    goto LABEL_1054;
  }
  v899 = (char *)a1[1];
  v900 = (v897 - v899) >> 3;
  v901 = v900 + 1;
  if ((unint64_t)(v900 + 1) >> 61)
LABEL_1055:
    abort();
  v902 = v896 - (_QWORD)v899;
  if (v902 >> 2 > v901)
    v901 = v902 >> 2;
  if ((unint64_t)v902 >= 0x7FFFFFFFFFFFFFF8)
    v903 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v903 = v901;
  if (!v903)
  {
    v904 = 0;
    goto LABEL_1039;
  }
  if (v903 >> 61)
LABEL_1056:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v904 = (char *)operator new(8 * v903);
LABEL_1039:
  v905 = &v904[8 * v900];
  v906 = &v904[8 * v903];
  *(_QWORD *)v905 = v887;
  v898 = v905 + 8;
  if (v897 == v899)
  {
    a1[1] = (uint64_t)v905;
    a1[2] = (uint64_t)v898;
    a1[3] = (uint64_t)v906;
  }
  else
  {
    v907 = v897 - v899 - 8;
    if (v907 < 0x78
      || &v897[-(v907 & 0xFFFFFFFFFFFFFFF8) - 8] < v905
      && &v904[v897 - v899 - (v907 & 0xFFFFFFFFFFFFFFF8) - 8] < v897)
    {
      goto LABEL_1085;
    }
    v908 = (v907 >> 3) + 1;
    v909 = 8 * (v908 & 0x3FFFFFFFFFFFFFFCLL);
    v910 = &v897[-v909];
    v905 -= v909;
    v911 = &v904[8 * v900 - 16];
    v912 = v897 - 16;
    v913 = v908 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v915 = *((_OWORD *)v912 - 1);
      v914 = *(_OWORD *)v912;
      *((_OWORD *)v912 - 1) = 0uLL;
      *(_OWORD *)v912 = 0uLL;
      *((_OWORD *)v911 - 1) = v915;
      *(_OWORD *)v911 = v914;
      v911 -= 32;
      v912 -= 32;
      v913 -= 4;
    }
    while (v913);
    v897 = v910;
    if (v908 != (v908 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_1085:
      do
      {
        v916 = *((_QWORD *)v897 - 1);
        v897 -= 8;
        *(_QWORD *)v897 = 0;
        *((_QWORD *)v905 - 1) = v916;
        v905 -= 8;
      }
      while (v897 != v899);
    }
    v897 = (char *)a1[1];
    v917 = (char *)a1[2];
    a1[1] = (uint64_t)v905;
    a1[2] = (uint64_t)v898;
    a1[3] = (uint64_t)v906;
    while (v917 != v897)
    {
      v919 = *((_QWORD *)v917 - 1);
      v917 -= 8;
      v918 = v919;
      *(_QWORD *)v917 = 0;
      if (v919)
        (*(void (**)(uint64_t))(*(_QWORD *)v918 + 8))(v918);
    }
  }
  if (v897)
    operator delete(v897);
LABEL_1054:
  a1[2] = (uint64_t)v898;
}

mlir::mps::MPSConversionTarget *mlir::mps::MPSConversionTarget::MPSConversionTarget(mlir::mps::MPSConversionTarget *this, mlir::MLIRContext *a2)
{
  void *v4[2];
  const char *v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 4) = (char *)this + 48;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 11) = 0x1000000000;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0x2800000000;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 19) = a2;
  *(_QWORD *)this = off_1E0E4B8F8;
  v5 = "mps";
  v6 = 3;
  mlir::ConversionTarget::setDialectAction((uint64_t *)this, (uint64_t)&v5, 1, 0);
  v5 = "mpsx";
  v6 = 4;
  mlir::ConversionTarget::setDialectAction((uint64_t *)this, (uint64_t)&v5, 1, 0);
  v4[0] = &v5;
  v5 = "scf";
  v6 = 3;
  v4[1] = (void *)0x200000001;
  mlir::ConversionTarget::setDialectAction((uint64_t *)this, (uint64_t)&v5, 1, 0);
  mlir::OperationName::OperationName(v4, "tensor.extract", 14, *((_QWORD *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  mlir::OperationName::OperationName(v4, "func.func", 9, *((_QWORD *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  mlir::OperationName::OperationName(v4, "builtin.module", 14, *((_QWORD *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  mlir::OperationName::OperationName(v4, "func.return", 11, *((_QWORD *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  mlir::OperationName::OperationName(v4, "tensor.cast", 11, *((_QWORD *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  mlir::OperationName::OperationName(v4, "tensor.from_elements", 20, *((_QWORD *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  mlir::OperationName::OperationName(v4, "placement.region_call", 21, *((_QWORD *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  mlir::OperationName::OperationName(v4, "placement.tensor_to_memref", 26, *((_QWORD *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  mlir::OperationName::OperationName(v4, "placement.memref_to_tensor", 26, *((_QWORD *)this + 19));
  mlir::ConversionTarget::setOpAction((uint64_t)this, (uint64_t)v4[0], 0);
  return this;
}

void mlir::mps::MPSConversionTarget::~MPSConversionTarget(mlir::mps::MPSConversionTarget *this)
{
  mlir::ConversionTarget::~ConversionTarget(this);
}

void sub_18050B9B4(void *__p)
{
  operator delete(__p);
}

void mlir::ConversionTarget::~ConversionTarget(mlir::ConversionTarget *this)
{
  mlir::ConversionTarget::~ConversionTarget(this);
}

{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  llvm *v14;
  llvm *v16;
  uint64_t v17;
  _QWORD **v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;

  *(_QWORD *)this = off_1E0E2B708;
  v2 = (char *)this + 120;
  v3 = (char *)*((_QWORD *)this + 18);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  if (*((_DWORD *)this + 27))
  {
    v5 = *((unsigned int *)this + 26);
    if ((_DWORD)v5)
    {
      v6 = 0;
      while (1)
      {
        v9 = *(_QWORD **)(*((_QWORD *)this + 12) + v6);
        if (v9 != (_QWORD *)-8 && v9 != 0)
          break;
        v6 += 8;
        if (8 * v5 == v6)
          goto LABEL_20;
      }
      v11 = *v9;
      v7 = (_QWORD *)v9[4];
      if (v7 == v9 + 1)
      {
        v7 = v9 + 1;
        v8 = 4;
      }
      else
      {
        if (!v7)
LABEL_11:
          llvm::deallocate_buffer((llvm *)v9, (void *)(v11 + 41));
        v8 = 5;
      }
      (*(void (**)(void))(*v7 + 8 * v8))();
      goto LABEL_11;
    }
  }
LABEL_20:
  free(*((void **)this + 12));
  if (*((_DWORD *)this + 21))
  {
    v12 = *((unsigned int *)this + 20);
    if ((_DWORD)v12)
    {
      v13 = 0;
      do
      {
        v14 = *(llvm **)(*((_QWORD *)this + 9) + v13);
        if (v14 != (llvm *)-8 && v14 != 0)
          llvm::deallocate_buffer(v14, (void *)(*(_QWORD *)v14 + 17));
        v13 += 8;
      }
      while (8 * v12 != v13);
    }
  }
  free(*((void **)this + 9));
  v16 = (llvm *)*((_QWORD *)this + 6);
  v17 = *((unsigned int *)this + 16);
  if (!(_DWORD)v17)
  {
    v22 = 0;
LABEL_40:
    llvm::deallocate_buffer(v16, (void *)v22);
  }
  v18 = (_QWORD **)((char *)v16 + 32);
  v19 = 40 * v17;
  while (1)
  {
    if (((unint64_t)*(v18 - 4) | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v20 = *v18;
      if (v18 - 3 == *v18)
      {
        v20 = v18 - 3;
        v21 = 4;
      }
      else
      {
        if (!v20)
          goto LABEL_33;
        v21 = 5;
      }
      (*(void (**)(void))(*v20 + 8 * v21))();
    }
LABEL_33:
    v18 += 5;
    v19 -= 40;
    if (!v19)
    {
      v16 = (llvm *)*((_QWORD *)this + 6);
      v22 = 40 * *((unsigned int *)this + 16);
      goto LABEL_40;
    }
  }
}

void sub_18050B9CC(void *__p)
{
  operator delete(__p);
}

uint64_t sub_18050BC10()
{
  uint64_t v0;

  return v0;
}

_BYTE *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4mpsx17QuantizedMatMulOpEZNS2_3mps12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__0EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SB_EEvE4typeEOSE_EUlSB_E_NS_9allocatorISI_EEFNS_8optionalIbEESB_EE7__cloneEv(uint64_t a1)
{
  _BYTE *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = off_1E0E50DD8;
  result[8] = *(_BYTE *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4mpsx17QuantizedMatMulOpEZNS2_3mps12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__0EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SB_EEvE4typeEOSE_EUlSB_E_NS_9allocatorISI_EEFNS_8optionalIbEESB_EE7__cloneEPNS0_6__baseISN_EE(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = off_1E0E50DD8;
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(result + 8);
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_4mpsx17QuantizedMatMulOpEZNS2_3mps12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__0EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SB_EEvE4typeEOSE_EUlSB_E_NS_9allocatorISI_EEFNS_8optionalIbEESB_EEclEOSB_(uint64_t a1, mlir::Operation **a2)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t *v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t *v22;
  _QWORD *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t *v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  _QWORD *v43;
  _QWORD *v44;
  unint64_t v45;
  unint64_t *v46;
  _QWORD *v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  _QWORD *v55;
  _QWORD *v56;
  unint64_t v57;
  unint64_t *v58;
  _QWORD *v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  unint64_t v70;
  unint64_t *v71;
  _QWORD *v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  _QWORD *v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  _QWORD *v80;
  _QWORD *v81;
  unint64_t v82;
  unint64_t *v83;
  _QWORD *v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  _QWORD *v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  _QWORD *v92;
  _QWORD *v93;
  unint64_t v94;
  unint64_t *v95;
  _QWORD *v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  _QWORD *v100;
  uint64_t v101;
  unint64_t v102;
  unint64_t v103;
  _QWORD *v104;
  _QWORD *v105;
  unint64_t v106;
  unint64_t *v107;
  _QWORD *v108;
  unint64_t v109;
  uint64_t v110;
  uint64_t v111;
  _QWORD *v112;
  uint64_t v113;
  unint64_t v114;
  unint64_t v115;
  _QWORD *v116;
  _QWORD *v117;
  unint64_t v118;
  unint64_t *v119;
  _QWORD *v120;
  unint64_t v121;
  uint64_t v122;
  uint64_t v123;
  int v124;
  _QWORD *v126;
  uint64_t v127;
  mlir::Operation *v128;
  _QWORD *v129;
  uint64_t v130;

  v128 = *a2;
  if (mlir::mpsx::QuantizedMatMulOp::isInputAffneQuantized(&v128)
    && mlir::mpsx::QuantizedMatMulOp::getInputQuantParamsAxisAttr(&v128))
  {
    v2 = (_QWORD *)(*(_QWORD *)(mlir::mpsx::QuantizedMatMulOp::getInput(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v2)
      goto LABEL_12;
    v3 = *v2;
    v4 = mlir::TypeID::get<mlir::ShapedType>();
    v5 = *(unsigned int *)(v3 + 16);
    if (!(_DWORD)v5)
      goto LABEL_12;
    v6 = *(_QWORD **)(v3 + 8);
    v7 = &v6[2 * v5];
    do
    {
      v8 = v5 >> 1;
      v9 = &v6[2 * (v5 >> 1)];
      v11 = *v9;
      v10 = v9 + 2;
      v5 += ~(v5 >> 1);
      if (v11 < v4)
        v6 = v10;
      else
        v5 = v8;
    }
    while (v5);
    if (v6 != v7 && *v6 == v4)
      v12 = v6[1];
    else
LABEL_12:
      v12 = 0;
    v126 = v2;
    v127 = v12;
    if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v126) & 1) != 0)
    {
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v126);
      v14 = v13;
      v15 = (_QWORD *)(*(_QWORD *)(mlir::mpsx::QuantizedMatMulOp::getInputScale(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v15)
        goto LABEL_23;
      v16 = *v15;
      v17 = mlir::TypeID::get<mlir::ShapedType>();
      v18 = *(unsigned int *)(v16 + 16);
      if (!(_DWORD)v18)
        goto LABEL_23;
      v19 = *(_QWORD **)(v16 + 8);
      v20 = &v19[2 * v18];
      do
      {
        v21 = v18 >> 1;
        v22 = &v19[2 * (v18 >> 1)];
        v24 = *v22;
        v23 = v22 + 2;
        v18 += ~(v18 >> 1);
        if (v24 < v17)
          v19 = v23;
        else
          v18 = v21;
      }
      while (v18);
      if (v19 != v20 && *v19 == v17)
        v25 = v19[1];
      else
LABEL_23:
        v25 = 0;
      v129 = v15;
      v130 = v25;
      if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v129) & 1) != 0)
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v129);
        if (v14 != 1 && v26 == 1)
          goto LABEL_133;
      }
      v27 = (_QWORD *)(*(_QWORD *)(mlir::mpsx::QuantizedMatMulOp::getInputZeroPoint(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v27)
        goto LABEL_36;
      v28 = *v27;
      v29 = mlir::TypeID::get<mlir::ShapedType>();
      v30 = *(unsigned int *)(v28 + 16);
      if (!(_DWORD)v30)
        goto LABEL_36;
      v31 = *(_QWORD **)(v28 + 8);
      v32 = &v31[2 * v30];
      do
      {
        v33 = v30 >> 1;
        v34 = &v31[2 * (v30 >> 1)];
        v36 = *v34;
        v35 = v34 + 2;
        v30 += ~(v30 >> 1);
        if (v36 < v29)
          v31 = v35;
        else
          v30 = v33;
      }
      while (v30);
      if (v31 != v32 && *v31 == v29)
        v37 = v31[1];
      else
LABEL_36:
        v37 = 0;
      v129 = v27;
      v130 = v37;
      if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v129) & 1) != 0)
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v129);
        if (v14 != 1 && v38 == 1)
          goto LABEL_133;
      }
      v39 = (_QWORD *)(*(_QWORD *)(mlir::mpsx::QuantizedMatMulOp::getInputMin(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v39)
        goto LABEL_49;
      v40 = *v39;
      v41 = mlir::TypeID::get<mlir::ShapedType>();
      v42 = *(unsigned int *)(v40 + 16);
      if (!(_DWORD)v42)
        goto LABEL_49;
      v43 = *(_QWORD **)(v40 + 8);
      v44 = &v43[2 * v42];
      do
      {
        v45 = v42 >> 1;
        v46 = &v43[2 * (v42 >> 1)];
        v48 = *v46;
        v47 = v46 + 2;
        v42 += ~(v42 >> 1);
        if (v48 < v41)
          v43 = v47;
        else
          v42 = v45;
      }
      while (v42);
      if (v43 != v44 && *v43 == v41)
        v49 = v43[1];
      else
LABEL_49:
        v49 = 0;
      v129 = v39;
      v130 = v49;
      if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v129) & 1) != 0)
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v129);
        if (v14 != 1 && v50 == 1)
          goto LABEL_133;
      }
    }
  }
  if (!mlir::mpsx::QuantizedMatMulOp::isWeightsAffineQuantized(&v128)
    && !mlir::mpsx::QuantizedMatMulOp::isWeightsDoubleAffineQuantized(&v128)
    || !mlir::mpsx::QuantizedMatMulOp::getWeightsQuantParamsAxisAttr(&v128))
  {
    goto LABEL_134;
  }
  v51 = (_QWORD *)(*(_QWORD *)(mlir::mpsx::QuantizedMatMulOp::getWeights(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v51)
    goto LABEL_65;
  v52 = *v51;
  v53 = mlir::TypeID::get<mlir::ShapedType>();
  v54 = *(unsigned int *)(v52 + 16);
  if (!(_DWORD)v54)
    goto LABEL_65;
  v55 = *(_QWORD **)(v52 + 8);
  v56 = &v55[2 * v54];
  do
  {
    v57 = v54 >> 1;
    v58 = &v55[2 * (v54 >> 1)];
    v60 = *v58;
    v59 = v58 + 2;
    v54 += ~(v54 >> 1);
    if (v60 < v53)
      v55 = v59;
    else
      v54 = v57;
  }
  while (v54);
  if (v55 != v56 && *v55 == v53)
    v61 = v55[1];
  else
LABEL_65:
    v61 = 0;
  v126 = v51;
  v127 = v61;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v126))
    goto LABEL_134;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v126);
  v63 = v62;
  v64 = (_QWORD *)(*(_QWORD *)(mlir::mpsx::QuantizedMatMulOp::getWeightsScale(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v64)
    goto LABEL_76;
  v65 = *v64;
  v66 = mlir::TypeID::get<mlir::ShapedType>();
  v67 = *(unsigned int *)(v65 + 16);
  if (!(_DWORD)v67)
    goto LABEL_76;
  v68 = *(_QWORD **)(v65 + 8);
  v69 = &v68[2 * v67];
  do
  {
    v70 = v67 >> 1;
    v71 = &v68[2 * (v67 >> 1)];
    v73 = *v71;
    v72 = v71 + 2;
    v67 += ~(v67 >> 1);
    if (v73 < v66)
      v68 = v72;
    else
      v67 = v70;
  }
  while (v67);
  if (v68 != v69 && *v68 == v66)
    v74 = v68[1];
  else
LABEL_76:
    v74 = 0;
  v129 = v64;
  v130 = v74;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v129) & 1) != 0)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v129);
    if (v63 != 1 && v75 == 1)
      goto LABEL_133;
  }
  v76 = (_QWORD *)(*(_QWORD *)(mlir::mpsx::QuantizedMatMulOp::getWeightsZeroPoint(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v76)
    goto LABEL_89;
  v77 = *v76;
  v78 = mlir::TypeID::get<mlir::ShapedType>();
  v79 = *(unsigned int *)(v77 + 16);
  if (!(_DWORD)v79)
    goto LABEL_89;
  v80 = *(_QWORD **)(v77 + 8);
  v81 = &v80[2 * v79];
  do
  {
    v82 = v79 >> 1;
    v83 = &v80[2 * (v79 >> 1)];
    v85 = *v83;
    v84 = v83 + 2;
    v79 += ~(v79 >> 1);
    if (v85 < v78)
      v80 = v84;
    else
      v79 = v82;
  }
  while (v79);
  if (v80 != v81 && *v80 == v78)
    v86 = v80[1];
  else
LABEL_89:
    v86 = 0;
  v129 = v76;
  v130 = v86;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v129) & 1) != 0)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v129);
    if (v63 != 1 && v87 == 1)
      goto LABEL_133;
  }
  v88 = (_QWORD *)(*(_QWORD *)(mlir::mpsx::QuantizedMatMulOp::getWeightsMin(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v88)
    goto LABEL_102;
  v89 = *v88;
  v90 = mlir::TypeID::get<mlir::ShapedType>();
  v91 = *(unsigned int *)(v89 + 16);
  if (!(_DWORD)v91)
    goto LABEL_102;
  v92 = *(_QWORD **)(v89 + 8);
  v93 = &v92[2 * v91];
  do
  {
    v94 = v91 >> 1;
    v95 = &v92[2 * (v91 >> 1)];
    v97 = *v95;
    v96 = v95 + 2;
    v91 += ~(v91 >> 1);
    if (v97 < v90)
      v92 = v96;
    else
      v91 = v94;
  }
  while (v91);
  if (v92 != v93 && *v92 == v90)
    v98 = v92[1];
  else
LABEL_102:
    v98 = 0;
  v129 = v88;
  v130 = v98;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v129) & 1) != 0)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v129);
    if (v63 != 1 && v99 == 1)
      goto LABEL_133;
  }
  if (!mlir::mpsx::QuantizedMatMulOp::isWeightsDoubleAffineQuantized(&v128))
    goto LABEL_134;
  v100 = (_QWORD *)(*(_QWORD *)(mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsScale(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v100)
    goto LABEL_116;
  v101 = *v100;
  v102 = mlir::TypeID::get<mlir::ShapedType>();
  v103 = *(unsigned int *)(v101 + 16);
  if (!(_DWORD)v103)
    goto LABEL_116;
  v104 = *(_QWORD **)(v101 + 8);
  v105 = &v104[2 * v103];
  do
  {
    v106 = v103 >> 1;
    v107 = &v104[2 * (v103 >> 1)];
    v109 = *v107;
    v108 = v107 + 2;
    v103 += ~(v103 >> 1);
    if (v109 < v102)
      v104 = v108;
    else
      v103 = v106;
  }
  while (v103);
  if (v104 != v105 && *v104 == v102)
    v110 = v104[1];
  else
LABEL_116:
    v110 = 0;
  v129 = v100;
  v130 = v110;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v129) & 1) != 0)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v129);
    if (v63 != 1 && v111 == 1)
      goto LABEL_133;
  }
  v112 = (_QWORD *)(*(_QWORD *)(mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsZeroPoint(&v128) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v112)
    goto LABEL_129;
  v113 = *v112;
  v114 = mlir::TypeID::get<mlir::ShapedType>();
  v115 = *(unsigned int *)(v113 + 16);
  if (!(_DWORD)v115)
    goto LABEL_129;
  v116 = *(_QWORD **)(v113 + 8);
  v117 = &v116[2 * v115];
  do
  {
    v118 = v115 >> 1;
    v119 = &v116[2 * (v115 >> 1)];
    v121 = *v119;
    v120 = v119 + 2;
    v115 += ~(v115 >> 1);
    if (v121 < v114)
      v116 = v120;
    else
      v115 = v118;
  }
  while (v115);
  if (v116 != v117 && *v116 == v114)
    v122 = v116[1];
  else
LABEL_129:
    v122 = 0;
  v129 = v112;
  v130 = v122;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v129) & 1) != 0
    && (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v129), v63 != 1)
    && v123 == 1)
  {
LABEL_133:
    v124 = 0;
  }
  else
  {
LABEL_134:
    v124 = 1;
  }
  return v124 | 0x100u;
}

_BYTE *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps9SoftmaxOpEZNS5_12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__1EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SA_EEvE4typeEOSD_EUlSA_E_NS_9allocatorISH_EEFNS_8optionalIbEESA_EE7__cloneEv(uint64_t a1)
{
  _BYTE *result;

  result = operator new(0x10uLL);
  *(_QWORD *)result = off_1E0E50B98;
  result[8] = *(_BYTE *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps9SoftmaxOpEZNS5_12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__1EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SA_EEvE4typeEOSD_EUlSA_E_NS_9allocatorISH_EEFNS_8optionalIbEESA_EE7__cloneEPNS0_6__baseISM_EE(uint64_t result, uint64_t a2)
{
  *(_QWORD *)a2 = off_1E0E50B98;
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(result + 8);
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps9SoftmaxOpEZNS5_12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__1EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SA_EEvE4typeEOSD_EUlSA_E_NS_9allocatorISH_EEFNS_8optionalIbEESA_EEclEOSA_(uint64_t a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t *v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BOOL4 v15;
  _QWORD v17[2];
  uint64_t v18;

  v18 = *a2;
  v2 = (uint64_t *)(*(_QWORD *)(mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v18) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v2)
    goto LABEL_10;
  v3 = *v2;
  v4 = mlir::TypeID::get<mlir::ShapedType>();
  v5 = *(unsigned int *)(v3 + 16);
  if (!(_DWORD)v5)
    goto LABEL_10;
  v6 = *(_QWORD **)(v3 + 8);
  v7 = &v6[2 * v5];
  do
  {
    v8 = v5 >> 1;
    v9 = &v6[2 * (v5 >> 1)];
    v11 = *v9;
    v10 = v9 + 2;
    v5 += ~(v5 >> 1);
    if (v11 < v4)
      v6 = v10;
    else
      v5 = v8;
  }
  while (v5);
  if (v6 != v7 && *v6 == v4)
    v12 = v6[1];
  else
LABEL_10:
    v12 = 0;
  v17[0] = v2;
  v17[1] = v12;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v17))
    goto LABEL_15;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v17);
  if (!v13)
  {
    v15 = 1;
    return v15 | 0x100u;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v17);
  if (v14 == 1)
    v15 = *(_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v17) == 1;
  else
LABEL_15:
    v15 = 0;
  return v15 | 0x100u;
}

_QWORD *_ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps12DequantizeOpEZNS5_12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__2EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SA_EEvE4typeEOSD_EUlSA_E_NS_9allocatorISH_EEFNS_8optionalIbEESA_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1E0E50B50;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps12DequantizeOpEZNS5_12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__2EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SA_EEvE4typeEOSD_EUlSA_E_NS_9allocatorISH_EEFNS_8optionalIbEESA_EE7__cloneEPNS0_6__baseISM_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1E0E50B50;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir16ConversionTarget21addDynamicallyLegalOpINS2_3mps12DequantizeOpEZNS5_12_GLOBAL__N_112LoweringPass5lowerEPNS2_9OperationEE3__2EENS_9enable_ifIXntsr3stdE14is_invocable_vIT0_SA_EEvE4typeEOSD_EUlSA_E_NS_9allocatorISH_EEFNS_8optionalIbEESA_EEclEOSA_(uint64_t a1, uint64_t *a2)
{
  unsigned __int8 *v2;
  uint64_t Input;
  int v4;
  _QWORD *v5;
  uint64_t v6;
  void *v7;
  BOOL v8;
  BOOL v9;
  BOOL v10;
  uint64_t v12;
  unsigned __int8 *ElementTypeOrSelf;
  uint64_t *v14;
  uint64_t v15;

  v2 = *(unsigned __int8 **)(a1 + 8);
  v12 = *a2;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v12);
  ElementTypeOrSelf = (unsigned __int8 *)mlir::getElementTypeOrSelf(Input);
  if (*(_UNKNOWN **)(*(_QWORD *)ElementTypeOrSelf + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    || mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) != 4)
  {
    v5 = *(_QWORD **)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v12);
    if (!v5)
    {
LABEL_35:
      v4 = 1;
      return v4 | 0x100u;
    }
    while (1)
    {
      v6 = v5[2];
      v7 = *(void **)(*(_QWORD *)(v6 + 48) + 16);
      if (v6)
        v8 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id;
      else
        v8 = 0;
      if (v8)
      {
        v4 = *v2;
        if (!*v2)
          return v4 | 0x100u;
        v14 = &v15;
        v15 = v6;
        ElementTypeOrSelf = v2;
        {
          goto LABEL_34;
        }
      }
      else
      {
        if (v6)
          v9 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id;
        else
          v9 = 0;
        if (v9)
        {
          v4 = v2[1];
          if (!v2[1])
            return v4 | 0x100u;
          v14 = &v15;
          v15 = v6;
          ElementTypeOrSelf = v2;
          {
            goto LABEL_34;
          }
        }
        else
        {
          if (v6)
            v10 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id;
          else
            v10 = 0;
          if (v10)
          {
            {
              goto LABEL_34;
            }
          }
          else
          {
            v4 = 0;
            if (!v6 || v7 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id)
              return v4 | 0x100u;
            {
LABEL_34:
              v4 = 0;
              return v4 | 0x100u;
            }
          }
        }
      }
      v5 = (_QWORD *)*v5;
      if (!v5)
        goto LABEL_35;
    }
  }
  v4 = mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v12) == 0;
  return v4 | 0x100u;
}

uint64_t mlir::mps::`anonymous namespace'::isDequantSupportedForLayer<mlir::mps::Conv2DOp>(mlir::mps::MPSRuntimeCapabilities const&,mlir::mps::Conv2DOp)::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t *a1, uint64_t a2, char a3)
{
  uint64_t result;
  void *v6;
  BOOL v7;
  uint64_t v8;
  uint64_t Filter;
  unint64_t matched;
  mlir::Operation *DefiningOp;
  int v12;
  unsigned int v13;
  _QWORD *v14;
  BOOL v15;
  uint64_t v16;
  void **v17;
  uint64_t *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  unint64_t v24;
  unint64_t *v25;
  _QWORD *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t *ArgAttrsAttr;
  uint64_t v30;
  uint64_t NumElements;
  int Axis;
  uint64_t v33;
  int WeightsLayout;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *__p;
  uint64_t v39;
  uint64_t Bias;
  void **p_p;

  v37 = a2;
  result = mlir::Value::getDefiningOp((mlir::Value *)&v37);
  if (result)
  {
    v6 = *(void **)(*(_QWORD *)(result + 48) + 16);
    v7 = v6 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id;
    if (v6 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id)
      v8 = result;
    else
      v8 = 0;
    v36 = v8;
    if (!v7)
      return 0;
    Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v36);
    matched = mlir::matchSplatConstantWithFloatValue<float>(Filter);
    result = 0;
    if ((matched & 0xFF00000000) != 0 && *(float *)&matched == 1.0)
    {
      Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v36);
      DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&Bias);
      if (DefiningOp)
      {
        LODWORD(v39) = 1;
        __p = 0;
        p_p = &__p;
        v12 = mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)&p_p, DefiningOp);
        v13 = v39;
        if (!v12)
        {
          v15 = 0;
          if (v39 < 0x41)
            goto LABEL_21;
          goto LABEL_19;
        }
        if (v39 < 0x41)
        {
          v14 = &__p;
          goto LABEL_18;
        }
        if (v13 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
        {
          v14 = __p;
LABEL_18:
          v15 = *v14 == 0;
          if (v13 < 0x41)
            goto LABEL_21;
LABEL_19:
          if (__p)
            operator delete[](__p);
LABEL_21:
          if (v15)
            return 1;
          goto LABEL_22;
        }
        if (__p)
          operator delete[](__p);
      }
LABEL_22:
      v16 = *a1;
      v17 = *(void ***)a1[1];
      Bias = v36;
      p_p = v17;
      if (!*(_BYTE *)(v16 + 2))
        return 0;
      if (*(_QWORD *)(mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&Bias) + 8) >= 8uLL)
        mlir::TypeID::get<mlir::ShapedType>();
      v18 = (uint64_t *)(*(_QWORD *)(mlir::anec::GOC::getBias((mlir::anec::GOC *)&Bias) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v18)
        goto LABEL_34;
      v19 = *v18;
      v20 = mlir::TypeID::get<mlir::ShapedType>();
      v21 = *(unsigned int *)(v19 + 16);
      if (!(_DWORD)v21)
        goto LABEL_34;
      v22 = *(_QWORD **)(v19 + 8);
      v23 = &v22[2 * v21];
      do
      {
        v24 = v21 >> 1;
        v25 = &v22[2 * (v21 >> 1)];
        v27 = *v25;
        v26 = v25 + 2;
        v21 += ~(v21 >> 1);
        if (v27 < v20)
          v22 = v26;
        else
          v21 = v24;
      }
      while (v21);
      if (v22 != v23 && *v22 == v20)
        v28 = v22[1];
      else
LABEL_34:
        v28 = 0;
      __p = v18;
      v39 = v28;
      ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__p);
      NumElements = mlir::ShapedType::getNumElements(ArgAttrsAttr, v30);
      if (NumElements != 1 && (a3 & 1) == 0)
      {
        Axis = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&Bias);
        if (Axis < 0)
          v33 = Axis;
        else
          v33 = Axis - 4;
        WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&p_p);
        v35 = -4;
        if (WeightsLayout != 2)
          v35 = -1;
        return v33 == v35;
      }
      return NumElements == 1;
    }
  }
  return result;
}

uint64_t mlir::mps::`anonymous namespace'::isDequantSupportedForLayer<mlir::mps::MatMulOp>(mlir::mps::MPSRuntimeCapabilities const&,mlir::mps::MatMulOp)::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t *a1, uint64_t a2, char a3)
{
  uint64_t result;
  void *v6;
  BOOL v7;
  uint64_t v8;
  uint64_t Filter;
  unint64_t matched;
  mlir::Operation *DefiningOp;
  int v12;
  unsigned int v13;
  _QWORD *p_p;
  BOOL v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  unint64_t v23;
  unint64_t *v24;
  _QWORD *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t *ArgAttrsAttr;
  uint64_t v29;
  uint64_t NumElements;
  int Axis;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _BOOL4 TransposeRhs;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD v39[2];
  void *__p;
  uint64_t v41;
  uint64_t v42;
  uint64_t Bias;

  v38 = a2;
  result = mlir::Value::getDefiningOp((mlir::Value *)&v38);
  if (result)
  {
    v6 = *(void **)(*(_QWORD *)(result + 48) + 16);
    v7 = v6 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id;
    if (v6 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id)
      v8 = result;
    else
      v8 = 0;
    v37 = v8;
    if (!v7)
      return 0;
    Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v37);
    matched = mlir::matchSplatConstantWithFloatValue<float>(Filter);
    result = 0;
    if ((matched & 0xFF00000000) != 0 && *(float *)&matched == 1.0)
    {
      Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v37);
      DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&Bias);
      if (DefiningOp)
      {
        LODWORD(v41) = 1;
        __p = 0;
        v39[0] = &__p;
        v12 = mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)v39, DefiningOp);
        v13 = v41;
        if (!v12)
        {
          v15 = 0;
          if (v41 < 0x41)
            goto LABEL_21;
          goto LABEL_19;
        }
        if (v41 < 0x41)
        {
          p_p = &__p;
          goto LABEL_18;
        }
        if (v13 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
        {
          p_p = __p;
LABEL_18:
          v15 = *p_p == 0;
          if (v13 < 0x41)
            goto LABEL_21;
LABEL_19:
          if (__p)
            operator delete[](__p);
LABEL_21:
          if (v15)
            return 1;
          goto LABEL_22;
        }
        if (__p)
          operator delete[](__p);
      }
LABEL_22:
      v16 = *a1;
      Bias = *(_QWORD *)a1[1];
      v42 = v37;
      if (!*(_BYTE *)(v16 + 3))
        return 0;
      v17 = (uint64_t *)(*(_QWORD *)(mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v17)
        goto LABEL_32;
      v18 = *v17;
      v19 = mlir::TypeID::get<mlir::ShapedType>();
      v20 = *(unsigned int *)(v18 + 16);
      if (!(_DWORD)v20)
        goto LABEL_32;
      v21 = *(_QWORD **)(v18 + 8);
      v22 = &v21[2 * v20];
      do
      {
        v23 = v20 >> 1;
        v24 = &v21[2 * (v20 >> 1)];
        v26 = *v24;
        v25 = v24 + 2;
        v20 += ~(v20 >> 1);
        if (v26 < v19)
          v21 = v25;
        else
          v20 = v23;
      }
      while (v20);
      if (v21 != v22 && *v21 == v19)
        v27 = v21[1];
      else
LABEL_32:
        v27 = 0;
      __p = v17;
      v41 = v27;
      ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__p);
      NumElements = mlir::ShapedType::getNumElements(ArgAttrsAttr, v29);
      if (NumElements != 1 && (a3 & 1) == 0)
      {
        Axis = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v42);
        v32 = Axis;
        if ((Axis & 0x80000000) == 0)
        {
          v39[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(v42 - 8) & 0xFFFFFFFFFFFFFFF8));
          v39[1] = v33;
          if (!v39[0] || (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v39) & 1) == 0)
            return 0;
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v39);
          v32 -= v34;
        }
        if (v32 >= -2)
        {
          TransposeRhs = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&Bias);
          v36 = -2;
          if (!TransposeRhs)
            v36 = -1;
          if (v32 == v36)
            return 1;
        }
        return 0;
      }
      return NumElements == 1;
    }
  }
  return result;
}

uint64_t mlir::mps::`anonymous namespace'::isDequantSupportedForLayer<mlir::mps::DepthwiseConv3DOp>(mlir::mps::MPSRuntimeCapabilities const&,mlir::mps::DepthwiseConv3DOp)::{lambda(mlir::Value,BOOL)#1}::operator()(uint64_t a1)
{
  uint64_t result;
  void *v2;
  BOOL v3;
  uint64_t v4;
  uint64_t Filter;
  unint64_t matched;
  mlir::Operation *DefiningOp;
  int v8;
  unsigned int v9;
  _QWORD *v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t Bias;
  void **p_p;
  void *__p;
  unsigned int v17;

  v13 = a1;
  result = mlir::Value::getDefiningOp((mlir::Value *)&v13);
  if (result)
  {
    v2 = *(void **)(*(_QWORD *)(result + 48) + 16);
    v3 = v2 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id;
    if (v2 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id)
      v4 = result;
    else
      v4 = 0;
    v12 = v4;
    if (!v3)
      return 0;
    Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v12);
    matched = mlir::matchSplatConstantWithFloatValue<float>(Filter);
    result = 0;
    if ((matched & 0xFF00000000) != 0 && *(float *)&matched == 1.0)
    {
      Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v12);
      DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&Bias);
      if (DefiningOp)
      {
        v17 = 1;
        p_p = &__p;
        __p = 0;
        v8 = mlir::detail::constant_int_value_binder::match((mlir::detail::constant_int_value_binder *)&p_p, DefiningOp);
        v9 = v17;
        if (!v8)
        {
          v11 = 0;
          if (v17 < 0x41)
            return v11;
          goto LABEL_19;
        }
        if (v17 < 0x41)
        {
          v10 = &__p;
          goto LABEL_18;
        }
        if (v9 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
        {
          v10 = __p;
LABEL_18:
          v11 = *v10 == 0;
          if (v9 < 0x41)
            return v11;
LABEL_19:
          if (__p)
            operator delete[](__p);
          return v11;
        }
        if (__p)
          operator delete[](__p);
      }
      return 0;
    }
  }
  return result;
}

char *mlir::mps::`anonymous namespace'::LoweringTypeConverter::materializeTypeConstraint(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[3];

  v12[2] = *MEMORY[0x1E0C80C00];
  v11 = a2;
  v12[0] = a3;
  v12[1] = a4;
  v10 = mlir::ValueRange::dereference_iterator(v12, 0);
  v9 = mlir::TypeAttr::get(a2);
  return (char *)mlir::OpBuilder::create<mlir::mps::TypeConstraintOp,mlir::Type &,mlir::Value,mlir::TypeAttr>(a1, a5, &v11, &v10, &v9)- 16;
}

void mlir::mps::`anonymous namespace'::LoweringTypeConverter::~LoweringTypeConverter(pthread_rwlock_t **this)
{
  mlir::TypeConverter::~TypeConverter(this);
}

void sub_18050CCFC(void *__p)
{
  operator delete(__p);
}

void mlir::TypeConverter::~TypeConverter(pthread_rwlock_t **this)
{
  mlir::TypeConverter::~TypeConverter(this);
}

{
  uint64_t v2;
  llvm *v3;
  char *v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;

  *this = (pthread_rwlock_t *)off_1E0E2B630;
  llvm::sys::RWMutexImpl::~RWMutexImpl(this + 65);
  v2 = *((unsigned int *)this + 128);
  v3 = (llvm *)this[62];
  if ((_DWORD)v2)
  {
    v4 = (char *)v3 + 24;
    v5 = 40 * v2;
    do
    {
      if ((*((_QWORD *)v4 - 3) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v6 = (char *)*((_QWORD *)v4 - 2);
        if (v4 != v6)
          free(v6);
      }
      v4 += 40;
      v5 -= 40;
    }
    while (v5);
    v3 = (llvm *)this[62];
    v7 = 40 * *((unsigned int *)this + 128);
  }
  else
  {
    v7 = 0;
  }
  llvm::deallocate_buffer(v3, (void *)v7);
}

void sub_18050CD14(void *__p)
{
  operator delete(__p);
}

void mlir::TypeConverter::registerConversion(unsigned int *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned int v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t i;
  uint64_t v23;
  void *v24;

  v3 = a1 + 2;
  v4 = a1[4];
  if (v4 >= a1[5])
  {
    llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>,false>::growAndEmplaceBack<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>((uint64_t)v3, a2);
    v7 = a1[120];
    if (v7)
      goto LABEL_9;
  }
  else
  {
    v5 = *v3 + 32 * v4;
    v6 = *(_QWORD *)(a2 + 24);
    if (v6)
    {
      if (v6 == a2)
      {
        *(_QWORD *)(v5 + 24) = v5;
        (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), v5);
        LODWORD(v4) = a1[4];
      }
      else
      {
        *(_QWORD *)(v5 + 24) = v6;
        *(_QWORD *)(a2 + 24) = 0;
      }
    }
    else
    {
      *(_QWORD *)(v5 + 24) = 0;
    }
    a1[4] = v4 + 1;
    v7 = a1[120];
    if (v7)
      goto LABEL_9;
  }
  if (!a1[121])
    goto LABEL_12;
LABEL_9:
  v8 = a1 + 118;
  v9 = a1[122];
  if (v9 <= 4 * v7 || v9 < 0x41)
  {
    if (!(_DWORD)v9)
      goto LABEL_23;
    v11 = (_QWORD *)*v8;
    v12 = (v9 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if (v12)
    {
      v13 = v12 + 1;
      v14 = (v12 + 1) & 0x1FFFFFFFFFFFFFFELL;
      v15 = &v11[2 * v14];
      v16 = v11 + 2;
      v17 = v14;
      do
      {
        *(v16 - 2) = -4096;
        *v16 = -4096;
        v16 += 4;
        v17 -= 2;
      }
      while (v17);
      if (v13 == v14)
      {
LABEL_23:
        *((_QWORD *)a1 + 60) = 0;
        v10 = a1[126];
        if (!v10)
          goto LABEL_24;
        goto LABEL_25;
      }
    }
    else
    {
      v15 = (_QWORD *)*v8;
    }
    v18 = &v11[2 * v9];
    do
    {
      *v15 = -4096;
      v15 += 2;
    }
    while (v15 != v18);
    goto LABEL_23;
  }
  llvm::DenseMap<mlir::Type,mlir::Type,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::Type>>::shrink_and_clear((uint64_t)v8);
LABEL_12:
  v10 = a1[126];
  if (!v10)
  {
LABEL_24:
    if (!a1[127])
      return;
  }
LABEL_25:
  v19 = a1 + 124;
  v20 = a1[128];
  if (v20 > 4 * v10 && v20 >= 0x41)
  {
    llvm::DenseMap<mlir::Type,llvm::SmallVector<mlir::Type,2u>,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,llvm::SmallVector<mlir::Type,2u>>>::shrink_and_clear((uint64_t)v19);
    return;
  }
  if ((_DWORD)v20)
  {
    v21 = *v19 + 24;
    for (i = 40 * v20; i; i -= 40)
    {
      v23 = *(_QWORD *)(v21 - 24);
      if (v23 != -8192)
      {
        if (v23 == -4096)
          goto LABEL_31;
        v24 = *(void **)(v21 - 16);
        if ((void *)v21 != v24)
          free(v24);
      }
      *(_QWORD *)(v21 - 24) = -4096;
LABEL_31:
      v21 += 40;
    }
  }
  *((_QWORD *)a1 + 63) = 0;
}

uint64_t llvm::SmallVectorTemplateBase<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>,false>::growAndEmplaceBack<std::function<std::optional<mlir::LogicalResult> ()(mlir::Type,llvm::SmallVectorImpl<mlir::Type> &)>>(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  char *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unint64_t v20;

  v20 = 0;
  v4 = (_QWORD *)(a1 + 16);
  v5 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 32, &v20);
  v6 = *(unsigned int *)(a1 + 8);
  v7 = &v5[32 * v6];
  v8 = *(_QWORD *)(a2 + 24);
  if (v8)
  {
    if (v8 == a2)
    {
      *((_QWORD *)v7 + 3) = v7;
      (*(void (**)(_QWORD))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24));
      v6 = *(unsigned int *)(a1 + 8);
      v9 = *(_QWORD **)a1;
      if (!(_DWORD)v6)
        goto LABEL_24;
    }
    else
    {
      *((_QWORD *)v7 + 3) = v8;
      *(_QWORD *)(a2 + 24) = 0;
      v9 = *(_QWORD **)a1;
      if (!(_DWORD)v6)
        goto LABEL_24;
    }
  }
  else
  {
    *((_QWORD *)v7 + 3) = 0;
    v9 = *(_QWORD **)a1;
    if (!(_DWORD)v6)
      goto LABEL_24;
  }
  v10 = 32 * v6;
  v11 = v5;
  do
  {
    v12 = (_QWORD *)v9[3];
    if (v12)
    {
      if (v9 == v12)
      {
        *((_QWORD *)v11 + 3) = v11;
        (*(void (**)(_QWORD, char *))(*(_QWORD *)v9[3] + 24))(v9[3], v11);
      }
      else
      {
        *((_QWORD *)v11 + 3) = v12;
        v9[3] = 0;
      }
    }
    else
    {
      *((_QWORD *)v11 + 3) = 0;
    }
    v11 += 32;
    v9 += 4;
    v10 -= 32;
  }
  while (v10);
  v9 = *(_QWORD **)a1;
  v13 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v13)
  {
    v14 = 4 * v13;
    while (1)
    {
      v15 = (_QWORD *)v9[v14 - 1];
      if (&v9[v14 - 4] == v15)
      {
        v15 = &v9[v14 - 4];
        v16 = 4;
      }
      else
      {
        if (!v15)
          goto LABEL_19;
        v16 = 5;
      }
      (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_19:
      v14 -= 4;
      if (!(v14 * 8))
      {
        v9 = *(_QWORD **)a1;
        break;
      }
    }
  }
LABEL_24:
  v17 = v20;
  if (v9 != v4)
    free(v9);
  *(_QWORD *)a1 = v5;
  v18 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v18;
  *(_DWORD *)(a1 + 12) = v17;
  return (uint64_t)&v5[32 * v18 - 32];
}

uint64_t llvm::DenseMap<mlir::Type,mlir::Type,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,mlir::Type>>::shrink_and_clear(uint64_t result)
{
  uint64_t v1;
  int v2;
  int v3;
  int v4;
  llvm *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  llvm *v9;
  _QWORD *v10;
  uint64_t v11;
  llvm *v12;

  v1 = *(unsigned int *)(result + 16);
  v2 = *(_DWORD *)(result + 8);
  v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64)
    v3 = 64;
  if (v2)
    v4 = v3;
  else
    v4 = 0;
  if (v4 != (_DWORD)v1)
    llvm::deallocate_buffer(*(llvm **)result, (void *)(16 * v1));
  *(_QWORD *)(result + 8) = 0;
  if ((_DWORD)v1)
  {
    v5 = *(llvm **)result;
    v6 = (v1 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if (v6)
    {
      v7 = v6 + 1;
      v8 = (v6 + 1) & 0x1FFFFFFFFFFFFFFELL;
      v9 = (llvm *)((char *)v5 + 16 * v8);
      v10 = (_QWORD *)((char *)v5 + 16);
      v11 = v8;
      do
      {
        *(v10 - 2) = -4096;
        *v10 = -4096;
        v10 += 4;
        v11 -= 2;
      }
      while (v11);
      if (v7 == v8)
        return result;
    }
    else
    {
      v9 = *(llvm **)result;
    }
    v12 = (llvm *)((char *)v5 + 16 * v1);
    do
    {
      *(_QWORD *)v9 = -4096;
      v9 = (llvm *)((char *)v9 + 16);
    }
    while (v9 != v12);
  }
  return result;
}

void llvm::DenseMap<mlir::Type,llvm::SmallVector<mlir::Type,2u>,llvm::DenseMapInfo<mlir::Type,void>,llvm::detail::DenseMapPair<mlir::Type,llvm::SmallVector<mlir::Type,2u>>>::shrink_and_clear(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  int v7;
  unsigned int v8;
  llvm *v9;
  unint64_t v10;
  llvm *v11;
  unint64_t v12;
  uint64_t v13;
  llvm *v14;
  llvm *v15;

  v2 = *(unsigned int *)(a1 + 16);
  v3 = *(_DWORD *)(a1 + 8);
  if ((_DWORD)v2)
  {
    v4 = *(_QWORD *)a1 + 24;
    v5 = 40 * v2;
    do
    {
      if ((*(_QWORD *)(v4 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v6 = *(void **)(v4 - 16);
        if ((void *)v4 != v6)
          free(v6);
      }
      v4 += 40;
      v5 -= 40;
    }
    while (v5);
  }
  v7 = 1 << (33 - __clz(v3 - 1));
  if (v7 <= 64)
    v7 = 64;
  if (v3)
    v8 = v7;
  else
    v8 = 0;
  if (v8 != *(_DWORD *)(a1 + 16))
    llvm::deallocate_buffer(*(llvm **)a1, (void *)(40 * v2));
  *(_QWORD *)(a1 + 8) = 0;
  if (v8)
  {
    v9 = *(llvm **)a1;
    v10 = 40 * v8 - 40;
    if (v10 < 0x28)
    {
      v11 = *(llvm **)a1;
LABEL_20:
      v15 = (llvm *)((char *)v9 + 40 * v8);
      do
      {
        *(_QWORD *)v11 = -4096;
        v11 = (llvm *)((char *)v11 + 40);
      }
      while (v11 != v15);
      return;
    }
    v12 = v10 / 0x28 + 1;
    v11 = (llvm *)((char *)v9 + 40 * (v12 & 0xFFFFFFFFFFFFFFELL));
    v13 = v12 & 0xFFFFFFFFFFFFFFELL;
    v14 = *(llvm **)a1;
    do
    {
      *(_QWORD *)v14 = -4096;
      *((_QWORD *)v14 + 5) = -4096;
      v14 = (llvm *)((char *)v14 + 80);
      v13 -= 2;
    }
    while (v13);
    if (v12 != (v12 & 0xFFFFFFFFFFFFFFELL))
      goto LABEL_20;
  }
}

_QWORD *_ZNKSt3__110__function6__funcIZNK4mlir13TypeConverter12wrapCallbackINS2_4TypeEZNKS3_12wrapCallbackIS5_ZNS2_3mps12_GLOBAL__N_121LoweringTypeConverterC1EvEUlS5_E_EENS_9enable_ifIXsr3stdE14is_invocable_vIT0_T_EENS_8functionIFNS_8optionalINS2_13LogicalResultEEES5_RN4llvm15SmallVectorImplIS5_EEEEEE4typeEOSC_EUlS5_SL_E_EENSB_IXsr3stdE14is_invocable_vISC_SD_SL_EESN_E4typeESQ_EUlS5_SL_E_NS_9allocatorISU_EESM_E7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1E0E51B98;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZNK4mlir13TypeConverter12wrapCallbackINS2_4TypeEZNKS3_12wrapCallbackIS5_ZNS2_3mps12_GLOBAL__N_121LoweringTypeConverterC1EvEUlS5_E_EENS_9enable_ifIXsr3stdE14is_invocable_vIT0_T_EENS_8functionIFNS_8optionalINS2_13LogicalResultEEES5_RN4llvm15SmallVectorImplIS5_EEEEEE4typeEOSC_EUlS5_SL_E_EENSB_IXsr3stdE14is_invocable_vISC_SD_SL_EESN_E4typeESQ_EUlS5_SL_E_NS_9allocatorISU_EESM_E7__cloneEPNS0_6__baseISM_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1E0E51B98;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZNK4mlir13TypeConverter12wrapCallbackINS2_4TypeEZNKS3_12wrapCallbackIS5_ZNS2_3mps12_GLOBAL__N_121LoweringTypeConverterC1EvEUlS5_E_EENS_9enable_ifIXsr3stdE14is_invocable_vIT0_T_EENS_8functionIFNS_8optionalINS2_13LogicalResultEEES5_RN4llvm15SmallVectorImplIS5_EEEEEE4typeEOSC_EUlS5_SL_E_EENSB_IXsr3stdE14is_invocable_vISC_SD_SL_EESN_E4typeESQ_EUlS5_SL_E_NS_9allocatorISU_EESM_EclEOS5_SL_(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  int v6;

  v3 = *a2;
  if (*a2)
  {
    v5 = *(unsigned int *)(a3 + 8);
    if (v5 >= *(_DWORD *)(a3 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v5 + 1, 8);
      LODWORD(v5) = *(_DWORD *)(a3 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a3 + 8 * v5) = v3;
    ++*(_DWORD *)(a3 + 8);
    v6 = 1;
  }
  else
  {
    v6 = 0;
  }
  return v6 | (v6 << 8);
}

_QWORD *std::__function::__func<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> mlir::TypeConverter::wrapMaterialization<mlir::Type,std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>(std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&)::{lambda(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)#1},std::allocator<std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&>,std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E0E51BE0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> mlir::TypeConverter::wrapMaterialization<mlir::Type,std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>(std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&)::{lambda(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)#1},std::allocator<std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&>,std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E0E51BE0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::function<std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)> mlir::TypeConverter::wrapMaterialization<mlir::Type,std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>(std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&)::{lambda(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)#1},std::allocator<std::optional<mlir::Value> (*)(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location) &&>,std::optional<mlir::Value> ()(mlir::OpBuilder &,mlir::Type,mlir::ValueRange,mlir::Location)>::operator()(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  if (*a3)
    return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 8))(a2, *a3, *a4, a4[1], *a5);
  else
    return 0;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::TypeConstraintOp,mlir::Type &,mlir::Value,mlir::TypeAttr>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.type_constraint", (const unsigned __int8 *)0x13, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.type_constraint";
    v19[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::TypeConstraintOp::build((uint64_t)a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::TypeConstraintOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::mps::`anonymous namespace'::LowerBiasAddGradNCHW::~LowerBiasAddGradNCHW(mlir::mps::_anonymous_namespace_::LowerBiasAddGradNCHW *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BiasAddGradOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BiasAddGradOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::BiasAddGradOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BiasAddGradOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::BiasAddGradOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::`anonymous namespace'::LowerBiasAddGradNCHW::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t IntegerType;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  mlir::GenericProgramPoint *Coord;
  uint64_t v23;
  mlir::GenericProgramPoint *v24;
  uint64_t v25;
  uint64_t v26;
  mlir::GenericProgramPoint *v27;
  unsigned __int8 v29;
  mlir::GenericProgramPoint *v30;
  mlir::GenericProgramPoint *v31;
  mlir::GenericProgramPoint *v32;
  mlir::GenericProgramPoint *v33;
  uint64_t Input;
  mlir::Operation *v35;
  _QWORD v36[2];
  uint64_t *v37[3];

  v37[2] = *(uint64_t **)MEMORY[0x1E0C80C00];
  v35 = a2;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v35);
  if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v35))
    return 0;
  v33 = mlir::OpBuilder::create<mlir::mps::RankOp,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *((_QWORD *)v35 + 3), &Input);
  v7 = *((_QWORD *)v35 + 3);
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x20u, 1);
  v9 = (_QWORD *)mlir::RankedTensorType::get(0, 0, IntegerType, 0);
  v10 = v9;
  if (!v9)
    goto LABEL_12;
  v11 = *v9;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_12;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_12:
    v20 = 0;
  LODWORD(v36[0]) = 0;
  v6 = 1;
  v37[0] = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v10, v20, v36, 4, 4, 1, 1);
  v32 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v7, v37);
  v31 = mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::mps::RankOp &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *((_QWORD *)v35 + 3), &v33, &v32);
  v21 = *((_QWORD *)v35 + 3);
  LODWORD(v37[0]) = 0;
  LODWORD(v36[0]) = 0;
  LODWORD(v30) = 3;
  Coord = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::mps::GetCoordOp &,int,int,int>((mlir::mps::ConstantOp *)(a4 + 8), v21, &v31, (unsigned int *)v37, (unsigned int *)v36, (unsigned int *)&v30);
  v23 = *((_QWORD *)v35 + 3);
  LODWORD(v37[0]) = 0;
  LODWORD(v36[0]) = -2;
  LODWORD(v30) = 2;
  v24 = mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::mps::GetCoordOp &,int,int,int>((mlir::mps::ConstantOp *)(a4 + 8), v23, &v31, (unsigned int *)v37, (unsigned int *)v36, (unsigned int *)&v30);
  v25 = *((_QWORD *)v35 + 3);
  v36[0] = (char *)Coord - 16;
  v36[1] = (char *)v24 - 16;
  mlir::ValueRange::ValueRange((unint64_t *)v37, (uint64_t)v36, 2uLL);
  v29 = 0;
  v30 = mlir::OpBuilder::create<mlir::mps::ConcatOp,mlir::ValueRange,mlir::mps::ConstantOp &,BOOL>((mlir::UnitAttr **)(a4 + 8), v25, (uint64_t *)v37, &v32, &v29);
  v26 = *((_QWORD *)v35 + 3);
  LOBYTE(v37[0]) = 0;
  v27 = mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::mps::ConcatOp &,BOOL>((mlir::UnitAttr **)(a4 + 8), v26, &Input, &v30, (unsigned __int8 *)v37);
  mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, a2, v27);
  return v6;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::RankOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.rank", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.rank";
    v15[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::RankOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::RankOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::mps::RankOp &,mlir::mps::ConstantOp &>(uint64_t *a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.get_coordinates", (const unsigned __int8 *)0x13, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.get_coordinates";
    v17[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::GetCoordOp::build(a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::GetCoordOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CropOp,mlir::mps::GetCoordOp &,int,int,int>(mlir::mps::ConstantOp *a1, uint64_t a2, _QWORD *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  uint64_t v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.crop", (const unsigned __int8 *)8, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.crop";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::CropOp::build(a1, v23, *a3 - 16, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CropOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SliceOp,mlir::mps::GetCoordOp &,int,int,int>(mlir::mps::ConstantOp *a1, uint64_t a2, _QWORD *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  uint64_t v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.slice", (const unsigned __int8 *)9, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.slice";
    v21[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::SliceOp::build(a1, v23, *a3 - 16, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SliceOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConcatOp,mlir::ValueRange,mlir::mps::ConstantOp &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, _QWORD *a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.concat", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.concat";
    v19[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ConcatOp::build(a1, (uint64_t)v21, *a3, a3[1], *a4 - 16, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConcatOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::mps::ConcatOp &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, _QWORD *a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_sum", (const unsigned __int8 *)0x11, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.reduction_sum";
    v19[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReductionSumOp::build(a1, (uint64_t)v21, *a3, *a4 - 16, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::mps::`anonymous namespace'::LowerBiasAddGradNHWC::~LowerBiasAddGradNHWC(mlir::mps::_anonymous_namespace_::LowerBiasAddGradNHWC *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::LowerBiasAddGradNHWC::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t IntegerType;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t *v16;
  _QWORD *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  unint64_t v30;
  unint64_t *v31;
  _QWORD *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  mlir::GenericProgramPoint *v36;
  int v38;
  mlir::GenericProgramPoint *v39;
  mlir::GenericProgramPoint *v40;
  mlir::GenericProgramPoint *v41;
  mlir::GenericProgramPoint *v42;
  mlir::GenericProgramPoint *v43;
  uint64_t Input;
  mlir::Operation *v45;

  v45 = a2;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v45) != 1)
    return 0;
  v43 = mlir::OpBuilder::create<mlir::mps::RankOp,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *((_QWORD *)v45 + 3), &Input);
  v6 = *((_QWORD *)v45 + 3);
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x20u, 1);
  v8 = (_QWORD *)mlir::RankedTensorType::get(0, 0, IntegerType, 0);
  v9 = v8;
  if (!v8)
    goto LABEL_11;
  v10 = *v8;
  v11 = mlir::TypeID::get<mlir::ShapedType>();
  v12 = *(unsigned int *)(v10 + 16);
  if (!(_DWORD)v12)
    goto LABEL_11;
  v13 = *(_QWORD **)(v10 + 8);
  v14 = &v13[2 * v12];
  do
  {
    v15 = v12 >> 1;
    v16 = &v13[2 * (v12 >> 1)];
    v18 = *v16;
    v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11)
      v13 = v17;
    else
      v12 = v15;
  }
  while (v12);
  if (v13 != v14 && *v13 == v11)
    v19 = v13[1];
  else
LABEL_11:
    v19 = 0;
  LODWORD(v40) = 0;
  v20 = 1;
  v41 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v19, &v40, 4, 4, 1, 1);
  v42 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v6, (uint64_t **)&v41);
  v41 = mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::mps::RankOp &,mlir::mps::ConstantOp &>((uint64_t *)(a4 + 8), *((_QWORD *)v45 + 3), &v43, &v42);
  v21 = *((_QWORD *)v45 + 3);
  v22 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x20u, 1);
  v23 = (_QWORD *)mlir::RankedTensorType::get(0, 0, v22, 0);
  v24 = v23;
  if (!v23)
    goto LABEL_21;
  v25 = *v23;
  v26 = mlir::TypeID::get<mlir::ShapedType>();
  v27 = *(unsigned int *)(v25 + 16);
  if (!(_DWORD)v27)
    goto LABEL_21;
  v28 = *(_QWORD **)(v25 + 8);
  v29 = &v28[2 * v27];
  do
  {
    v30 = v27 >> 1;
    v31 = &v28[2 * (v27 >> 1)];
    v33 = *v31;
    v32 = v31 + 2;
    v27 += ~(v27 >> 1);
    if (v33 < v26)
      v28 = v32;
    else
      v27 = v30;
  }
  while (v27);
  if (v28 != v29 && *v28 == v26)
    v34 = v28[1];
  else
LABEL_21:
    v34 = 0;
  v38 = 1;
  v39 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v24, v34, &v38, 4, 4, 1, 1);
  v40 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v21, (uint64_t **)&v39);
  v39 = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::mps::GetCoordOp &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>((mlir::UnknownLoc **)(a4 + 8), *((_QWORD *)v45 + 3), &v41, &v42, &v42, &v40);
  v35 = *((_QWORD *)v45 + 3);
  LOBYTE(v38) = 0;
  v36 = mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::mps::ConcatOp &,BOOL>((mlir::UnitAttr **)(a4 + 8), v35, &Input, &v39, (unsigned __int8 *)&v38);
  mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, a2, v36);
  return v20;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CropOp,mlir::mps::GetCoordOp &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(mlir::UnknownLoc **a1, uint64_t a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.crop", (const unsigned __int8 *)8, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.crop";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::CropOp::build(a1, (uint64_t)v23, *a3 - 16, *a4 - 16, *a5 - 16, *a6 - 16);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CropOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

void mlir::mps::`anonymous namespace'::LowerBiasAddNCHW::~LowerBiasAddNCHW(mlir::mps::_anonymous_namespace_::LowerBiasAddNCHW *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BiasAddOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BiasAddOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::BiasAddOpGenericAdaptorBase::BiasAddOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::BiasAddOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::BiasAddOpGenericAdaptorBase::BiasAddOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::`anonymous namespace'::LowerBiasAddNCHW::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::UnknownLoc **a4)
{
  uint64_t Input;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t IntegerType;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  unint64_t *v19;
  _QWORD *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  unint64_t v32;
  unint64_t *v33;
  _QWORD *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  _QWORD *v44;
  _QWORD *v45;
  unint64_t v46;
  unint64_t *v47;
  _QWORD *v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  _QWORD *v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  _QWORD *v58;
  _QWORD *v59;
  unint64_t v60;
  unint64_t *v61;
  _QWORD *v62;
  unint64_t v63;
  uint64_t v64;
  mlir::GenericProgramPoint *v65;
  int v67;
  mlir::GenericProgramPoint *v68;
  mlir::GenericProgramPoint *v69;
  mlir::GenericProgramPoint *v70;
  mlir::GenericProgramPoint *v71;
  mlir::GenericProgramPoint *v72;
  mlir::GenericProgramPoint *v73;
  mlir::GenericProgramPoint *v74;
  mlir::GenericProgramPoint *v75;
  uint64_t ElementTypeOrSelf;
  mlir::GenericProgramPoint *v77;
  uint64_t Filter;
  uint64_t v79;
  mlir::Operation *v80;

  v80 = a2;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v80);
  v79 = Input;
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v80);
  if (mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v80))
    return 0;
  v8 = *((_QWORD *)v80 + 3);
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(Input);
  v77 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a4 + 1, v8, &Filter, &ElementTypeOrSelf);
  ElementTypeOrSelf = (uint64_t)mlir::OpBuilder::create<mlir::mps::RankOp,mlir::Value &>((mlir::OpBuilder *)(a4 + 1), *((_QWORD *)v80 + 3), &v79);
  v9 = *((_QWORD *)v80 + 3);
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x20u, 1);
  v11 = (_QWORD *)mlir::RankedTensorType::get(0, 0, IntegerType, 0);
  v12 = v11;
  if (!v11)
    goto LABEL_12;
  v13 = *v11;
  v14 = mlir::TypeID::get<mlir::ShapedType>();
  v15 = *(unsigned int *)(v13 + 16);
  if (!(_DWORD)v15)
    goto LABEL_12;
  v16 = *(_QWORD **)(v13 + 8);
  v17 = &v16[2 * v15];
  do
  {
    v18 = v15 >> 1;
    v19 = &v16[2 * (v15 >> 1)];
    v21 = *v19;
    v20 = v19 + 2;
    v15 += ~(v15 >> 1);
    if (v21 < v14)
      v16 = v20;
    else
      v15 = v18;
  }
  while (v15);
  if (v16 != v17 && *v16 == v14)
    v22 = v16[1];
  else
LABEL_12:
    v22 = 0;
  LODWORD(v73) = 0;
  v74 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v12, v22, &v73, 4, 4, 1, 1);
  v75 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 1), v9, (uint64_t **)&v74);
  v74 = mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::mps::RankOp &,mlir::mps::ConstantOp &>((uint64_t *)a4 + 1, *((_QWORD *)v80 + 3), &ElementTypeOrSelf, &v75);
  v23 = *((_QWORD *)v80 + 3);
  v24 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x20u, 1);
  v25 = (_QWORD *)mlir::RankedTensorType::get(0, 0, v24, 0);
  v26 = v25;
  if (!v25)
    goto LABEL_22;
  v27 = *v25;
  v28 = mlir::TypeID::get<mlir::ShapedType>();
  v29 = *(unsigned int *)(v27 + 16);
  if (!(_DWORD)v29)
    goto LABEL_22;
  v30 = *(_QWORD **)(v27 + 8);
  v31 = &v30[2 * v29];
  do
  {
    v32 = v29 >> 1;
    v33 = &v30[2 * (v29 >> 1)];
    v35 = *v33;
    v34 = v33 + 2;
    v29 += ~(v29 >> 1);
    if (v35 < v28)
      v30 = v34;
    else
      v29 = v32;
  }
  while (v29);
  if (v30 != v31 && *v30 == v28)
    v36 = v30[1];
  else
LABEL_22:
    v36 = 0;
  LODWORD(v71) = 1;
  v72 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v26, v36, &v71, 4, 4, 1, 1);
  v73 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 1), v23, (uint64_t **)&v72);
  v72 = mlir::OpBuilder::create<mlir::mps::CropOp,mlir::mps::GetCoordOp &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(a4 + 1, *((_QWORD *)v80 + 3), &v74, &v75, &v75, &v73);
  v71 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::mps::CastOp &,mlir::mps::CropOp &>((mlir::OpBuilder *)(a4 + 1), *((_QWORD *)v80 + 3), &v77, &v72);
  v37 = *((_QWORD *)v80 + 3);
  v38 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x20u, 1);
  v39 = (_QWORD *)mlir::RankedTensorType::get(0, 0, v38, 0);
  v40 = v39;
  if (!v39)
    goto LABEL_32;
  v41 = *v39;
  v42 = mlir::TypeID::get<mlir::ShapedType>();
  v43 = *(unsigned int *)(v41 + 16);
  if (!(_DWORD)v43)
    goto LABEL_32;
  v44 = *(_QWORD **)(v41 + 8);
  v45 = &v44[2 * v43];
  do
  {
    v46 = v43 >> 1;
    v47 = &v44[2 * (v43 >> 1)];
    v49 = *v47;
    v48 = v47 + 2;
    v43 += ~(v43 >> 1);
    if (v49 < v42)
      v44 = v48;
    else
      v43 = v46;
  }
  while (v43);
  if (v44 != v45 && *v44 == v42)
    v50 = v44[1];
  else
LABEL_32:
    v50 = 0;
  LODWORD(v68) = -1;
  v69 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v40, v50, &v68, 4, 4, 1, 1);
  v70 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 1), v37, (uint64_t **)&v69);
  v51 = *((_QWORD *)v80 + 3);
  v52 = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 1), 0x20u, 1);
  v53 = (_QWORD *)mlir::RankedTensorType::get(0, 0, v52, 0);
  v54 = v53;
  if (!v53)
    goto LABEL_42;
  v55 = *v53;
  v56 = mlir::TypeID::get<mlir::ShapedType>();
  v57 = *(unsigned int *)(v55 + 16);
  if (!(_DWORD)v57)
    goto LABEL_42;
  v58 = *(_QWORD **)(v55 + 8);
  v59 = &v58[2 * v57];
  do
  {
    v60 = v57 >> 1;
    v61 = &v58[2 * (v57 >> 1)];
    v63 = *v61;
    v62 = v61 + 2;
    v57 += ~(v57 >> 1);
    if (v63 < v56)
      v58 = v62;
    else
      v57 = v60;
  }
  while (v57);
  if (v58 != v59 && *v58 == v56)
    v64 = v58[1];
  else
LABEL_42:
    v64 = 0;
  v67 = -3;
  v7 = 1;
  v68 = (mlir::GenericProgramPoint *)mlir::DenseElementsAttr::getFromRawBuffer(v54, v64, &v67, 4, 4, 1, 1);
  v69 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 1), v51, (uint64_t **)&v68);
  v68 = mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::mps::ExpandDimsOp &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(a4 + 1, *((_QWORD *)v80 + 3), &v71, &v69, &v70);
  v65 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value &,mlir::mps::TransposeOp &>(a4 + 1, *((_QWORD *)v80 + 3), &v79, &v68);
  mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, a2, v65);
  return v7;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::mps::CastOp &,mlir::mps::CropOp &>(mlir::OpBuilder *a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.expand_dims", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.expand_dims";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ExpandDimsOp::build((uint64_t)a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::mps::ExpandDimsOp &,mlir::mps::ConstantOp &,mlir::mps::ConstantOp &>(mlir::Float32Type **a1, uint64_t a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.transpose";
    v19[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::TransposeOp::build(a1, (uint64_t)v21, *a3 - 16, *a4 - 16, *a5 - 16);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value &,mlir::mps::TransposeOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.add";
    v17[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::`anonymous namespace'::LowerReductionMean::~LowerReductionMean(mlir::mps::_anonymous_namespace_::LowerReductionMean *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMeanOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMeanOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ReductionMeanOpGenericAdaptorBase::ReductionMeanOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionMeanOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ReductionMeanOpGenericAdaptorBase::ReductionMeanOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::`anonymous namespace'::LowerReductionMean::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  mlir::GenericProgramPoint *v7;
  mlir::MLIRContext *v8;
  uint64_t IntegerType;
  _BOOL4 isSignedInteger;
  int v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v13;
  char *v14;
  char *v16;
  mlir::GenericProgramPoint *v17;
  mlir::GenericProgramPoint *v18;
  uint64_t v19;
  uint64_t ElementTypeOrSelf;
  char *v21;
  BOOL InferredResultTypes;
  uint64_t Axes;
  uint64_t Input;
  uint64_t v25;
  unint64_t v26[2];
  uint64_t v27[2];

  v27[1] = *MEMORY[0x1E0C80C00];
  v25 = a2;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v25);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v25);
  InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v25);
  v6 = *(_QWORD *)(a2 + 24);
  if (Axes)
    v7 = mlir::OpBuilder::create<mlir::mps::DimensionSizeOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(a2 + 24), &Input, &Axes);
  else
    v7 = mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(a2 + 24), &Input);
  v21 = (char *)v7 - 16;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(Input);
  if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
  {
    IntegerType = mlir::Float32Type::get(*(mlir::Float32Type **)(a4 + 8), v8);
LABEL_9:
    v19 = mlir::TypeAttr::get(IntegerType);
    Input = (uint64_t)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>((mlir::UnknownLoc **)(a4 + 8), v6, &Input, &v19)- 16;
    v11 = 1;
    goto LABEL_10;
  }
  if (mlir::Type::isInteger((mlir::Type *)&ElementTypeOrSelf, 8)
    || mlir::Type::isInteger((mlir::Type *)&ElementTypeOrSelf, 16))
  {
    isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)&ElementTypeOrSelf);
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x20u, isSignedInteger);
    goto LABEL_9;
  }
  v11 = 0;
LABEL_10:
  v12 = mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::Value &,BOOL &>((mlir::UnitAttr **)(a4 + 8), v6, &Input, &Axes, (unsigned __int8 *)&InferredResultTypes);
  v19 = (uint64_t)v12;
  v18 = mlir::OpBuilder::create<mlir::mps::ReductionProdOp,mlir::Value &>((mlir::UnknownLoc **)(a4 + 8), v6, (uint64_t)&v21);
  v13 = mlir::getElementTypeOrSelf((uint64_t)v12 - 16);
  v16 = (char *)mlir::TypeAttr::get(v13);
  v17 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::ReductionProdOp &,mlir::TypeAttr>((mlir::UnknownLoc **)(a4 + 8), v6, &v18, (uint64_t *)&v16);
  v14 = (char *)mlir::OpBuilder::create<mlir::mps::DivideOp,mlir::mps::ReductionSumOp &,mlir::mps::CastOp &>((mlir::Float32Type **)(a4 + 8), v6, &v19, &v17)- 16;
  v16 = v14;
  if (v11)
  {
    v27[0] = mlir::TypeAttr::get(ElementTypeOrSelf);
    v14 = (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>((mlir::UnknownLoc **)(a4 + 8), v6, (uint64_t *)&v16, v27)- 16;
    v16 = v14;
  }
  v27[0] = (uint64_t)v14;
  mlir::ValueRange::ValueRange(v26, (uint64_t)v27, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, v26[0], v26[1]);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DimensionSizeOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dimension_size", (const unsigned __int8 *)0x12, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.dimension_size";
    v17[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::DimensionSizeOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DimensionSizeOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::Value &,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_sum", (const unsigned __int8 *)0x11, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.reduction_sum";
    v19[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReductionSumOp::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionProdOp,mlir::Value &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_prod", (const unsigned __int8 *)0x12, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.reduction_prod";
    v15[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ReductionProdOp::build(a1, (uint64_t)v17, a3, 1, 0, 0);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionProdOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::ReductionProdOp &,mlir::TypeAttr>(mlir::UnknownLoc **a1, uint64_t a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.cast";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::CastOp::build(a1, (uint64_t)v19, *a3 - 16, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DivideOp,mlir::mps::ReductionSumOp &,mlir::mps::CastOp &>(mlir::Float32Type **a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.divide", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.divide";
    v17[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3 - 16, *a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::`anonymous namespace'::LowerReductionVariance::~LowerReductionVariance(mlir::mps::_anonymous_namespace_::LowerReductionVariance *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionVarianceOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionVarianceOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ReductionVarianceOpGenericAdaptorBase::ReductionVarianceOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::ReductionVarianceOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::ReductionVarianceOpGenericAdaptorBase::ReductionVarianceOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::`anonymous namespace'::LowerReductionVariance::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::UnitAttr **a4)
{
  uint64_t v6;
  mlir::GenericProgramPoint *v7;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  mlir::GenericProgramPoint *v11;
  BOOL InferredResultTypes;
  uint64_t Axes;
  uint64_t Input;
  mlir::Operation *v15;

  v15 = a2;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v15);
  Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v15);
  InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v15);
  v6 = *((_QWORD *)a2 + 3);
  LOBYTE(v10) = 1;
  v11 = mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::Value &,mlir::Value &,BOOL>(a4 + 1, v6, &Input, &Axes, (unsigned __int8 *)&v10);
  v10 = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::mps::ReductionMeanOp &>(a4 + 1, v6, &Input, &v11);
  v9 = mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::mps::SubtractOp &>((mlir::OpBuilder *)(a4 + 1), v6, &v10);
  v7 = mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::mps::SquareOp &,mlir::Value &,BOOL &>(a4 + 1, v6, &v9, &Axes, (unsigned __int8 *)&InferredResultTypes);
  mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, a2, v7);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::Value &,mlir::Value &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_mean", (const unsigned __int8 *)0x12, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.reduction_mean";
    v19[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReductionMeanOp::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMeanOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::mps::ReductionMeanOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.subtract", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.subtract";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::mps::SubtractOp &>(mlir::OpBuilder *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square", (const unsigned __int8 *)0xA, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.square";
    v15[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3 - 16);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SquareOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::mps::SquareOp &,mlir::Value &,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, _QWORD *a3, uint64_t *a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_mean", (const unsigned __int8 *)0x12, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.reduction_mean";
    v19[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReductionMeanOp::build(a1, (uint64_t)v21, *a3 - 16, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMeanOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::mps::`anonymous namespace'::LowerSoftplus::~LowerSoftplus(mlir::mps::_anonymous_namespace_::LowerSoftplus *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftplusOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftplusOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SoftplusOpGenericAdaptorBase::SoftplusOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SoftplusOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SoftplusOpGenericAdaptorBase::SoftplusOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::`anonymous namespace'::LowerSoftplus::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t *v7;
  float v8;
  uint64_t *v9;
  mlir::GenericProgramPoint *v10;
  mlir::GenericProgramPoint *v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t ElementTypeOrSelf;
  uint64_t Input;
  mlir::Operation *v19;
  uint64_t Constant;

  v19 = a2;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v19);
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(Input);
  v6 = *((_QWORD *)a2 + 3);
  v16 = mlir::OpBuilder::create<mlir::mps::ExponentOp,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), v6, &Input);
  Constant = 1;
  v7 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, ElementTypeOrSelf, 0);
  Constant = mlir::mps::getConstantAttr<int>(v7, 1);
  v15 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v6, (uint64_t **)&Constant);
  v14 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::SubtractOp &,mlir::mps::ConstantOp>((mlir::Float32Type **)(a4 + 8), v6, &v16, &v15);
  v13 = mlir::OpBuilder::create<mlir::mps::LogarithmOp,mlir::mps::AddOp &>((mlir::OpBuilder *)(a4 + 8), v6, &v14);
  if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&ElementTypeOrSelf) >= 0x11)
    v8 = 20.0;
  else
    v8 = 10.0;
  Constant = 1;
  v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&Constant, 1, ElementTypeOrSelf, 0);
  Constant = mlir::mps::getConstantAttr<float>(v9, v8);
  Constant = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v6, (uint64_t **)&Constant);
  v12 = mlir::OpBuilder::create<mlir::mps::GreaterThanOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a4 + 8), v6, &Input, &Constant);
  v10 = mlir::OpBuilder::create<mlir::mps::SelectOp,mlir::mps::GreaterThanOp &,mlir::Value &,mlir::mps::LogarithmOp &>((mlir::OpBuilder *)(a4 + 8), v6, &v12, &Input, &v13);
  mlir::ConversionPatternRewriter::replaceOp((mlir::ConversionPatternRewriter *)a4, a2, v10);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ExponentOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.exponent", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.exponent";
    v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExponentOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::LogarithmOp,mlir::mps::AddOp &>(mlir::OpBuilder *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.logarithm", (const unsigned __int8 *)0xD, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.logarithm";
    v15[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3 - 16);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::LogarithmOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::GreaterThanOp,mlir::Value &,mlir::mps::ConstantOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.greater", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.greater";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::EqualToOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4 - 16);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::GreaterThanOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SelectOp,mlir::mps::GreaterThanOp &,mlir::Value &,mlir::mps::LogarithmOp &>(mlir::OpBuilder *a1, uint64_t a2, _QWORD *a3, uint64_t *a4, _QWORD *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.select";
    v19[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::SelectOp::build((uint64_t)a1, (uint64_t)v21, *a3 - 16, *a4, *a5 - 16);
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SelectOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t mlir::mps::getConstantAttr<int>(uint64_t *a1, int a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t *v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t ElementTypeOrSelf;
  void *v14;
  _QWORD v27[3];
  _QWORD v28[3];
  _QWORD v29[3];
  _QWORD v30[2];
  int v31;
  uint64_t v32;

  v31 = a2;
  v32 = 0;
  if (!a1)
    goto LABEL_10;
  v3 = *a1;
  v4 = mlir::TypeID::get<mlir::ShapedType>();
  v5 = *(unsigned int *)(v3 + 16);
  if (!(_DWORD)v5)
    goto LABEL_10;
  v6 = *(_QWORD **)(v3 + 8);
  v7 = &v6[2 * v5];
  do
  {
    v8 = v5 >> 1;
    v9 = &v6[2 * (v5 >> 1)];
    v11 = *v9;
    v10 = v9 + 2;
    v5 += ~(v5 >> 1);
    if (v11 < v4)
      v6 = v10;
    else
      v5 = v8;
  }
  while (v5);
  if (v6 != v7 && *v6 == v4)
    v12 = v6[1];
  else
LABEL_10:
    v12 = 0;
  v30[0] = a1;
  v30[1] = v12;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
  v29[0] = &v32;
  v29[1] = v30;
  v29[2] = &v31;
  v14 = *(void **)(*(_QWORD *)ElementTypeOrSelf + 136);
  if (v14 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    mlir::mps::getConstantAttr<int>(mlir::Type,int)::{lambda(mlir::Type)#1}::operator()((uint64_t)v29, ElementTypeOrSelf);
  }
  else
  {
    v28[0] = &v32;
    v28[1] = v30;
    v28[2] = &v31;
    if (v14 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
    {
      mlir::mps::getConstantAttr<int>(mlir::Type,int)::{lambda(mlir::Type)#2}::operator()((uint64_t)v28, ElementTypeOrSelf);
    }
    else
    {
      v27[0] = &v32;
      v27[1] = v30;
      v27[2] = &v31;
      if (v14 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
        mlir::mps::getConstantAttr<int>(mlir::Type,int)::{lambda(mlir::ComplexType)#1}::operator()((uint64_t)v27, ElementTypeOrSelf);
    }
  }
  return v32;
}

void mlir::mps::getConstantAttr<int>(mlir::Type,int)::{lambda(mlir::Type)#1}::operator()(uint64_t a1, uint64_t a2)
{
  _BOOL8 isF16;
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  void *v7;
  _BOOL8 isBF16;
  uint64_t v9;
  void *v10;
  std::string *v11;
  std::string::size_type size;
  llvm::APFloatBase *v13;
  void *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  std::string v21;
  uint64_t v22;
  double v23;
  _QWORD v24[4];

  v24[3] = *MEMORY[0x1E0C80C00];
  v22 = a2;
  isF16 = mlir::Type::isF16((mlir::Type *)&v22);
  if (isF16)
  {
    v4 = *(_QWORD *)(a1 + 8);
    v5 = *(llvm::APFloatBase **)v4;
    v6 = *(_QWORD *)(v4 + 8);
    v7 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)isF16);
  }
  else
  {
    isBF16 = mlir::Type::isBF16((mlir::Type *)&v22);
    if (!isBF16)
    {
      if (mlir::Type::isF32((mlir::Type *)&v22))
      {
        v15 = *(uint64_t **)(a1 + 8);
        *(float *)&v23 = (float)**(int **)(a1 + 16);
        v16 = *v15;
        v17 = v15[1];
        v18 = 4;
        v19 = 4;
      }
      else
      {
        mlir::Type::isF64((mlir::Type *)&v22);
        v20 = *(uint64_t **)(a1 + 8);
        v23 = (double)**(int **)(a1 + 16);
        v16 = *v20;
        v17 = v20[1];
        v18 = 8;
        v19 = 8;
      }
      **(_QWORD **)a1 = mlir::DenseElementsAttr::getFromRawBuffer(v16, v17, &v23, v18, v19, 0, 1);
      return;
    }
    v9 = *(_QWORD *)(a1 + 8);
    v5 = *(llvm::APFloatBase **)v9;
    v6 = *(_QWORD *)(v9 + 8);
    v7 = llvm::APFloatBase::BFloat((llvm::APFloatBase *)isBF16);
  }
  v10 = v7;
  std::to_string(&v21, **(_DWORD **)(a1 + 16));
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = &v21;
  else
    v11 = (std::string *)v21.__r_.__value_.__r.__words[0];
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v21.__r_.__value_.__r.__words[2]);
  else
    size = v21.__r_.__value_.__l.__size_;
  llvm::APFloat::APFloat((llvm::APFloatBase *)&v23, v10, (unsigned __int8 *)v11, size);
  v13 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get(v5, v6, (uint64_t)&v23, 1);
  **(_QWORD **)a1 = v13;
  v14 = (void *)v24[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v13) == v14)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v24);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
  }
  else
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v24);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
  }
  operator delete(v21.__r_.__value_.__l.__data_);
}

void mlir::mps::getConstantAttr<int>(mlir::Type,int)::{lambda(mlir::Type)#2}::operator()(uint64_t a1, uint64_t a2)
{
  _BOOL4 isInteger;
  uint64_t *v4;
  unsigned int IntOrFloatBitWidth;
  uint64_t v6;
  _BOOL4 isSignedInteger;
  unint64_t v8;
  void *__p;
  unsigned int v10;
  uint64_t v11;

  v11 = a2;
  isInteger = mlir::Type::isInteger((mlir::Type *)&v11, 1);
  v4 = *(uint64_t **)(a1 + 8);
  if (isInteger)
  {
    LOBYTE(__p) = **(_DWORD **)(a1 + 16) != 0;
    **(_QWORD **)a1 = mlir::DenseElementsAttr::get(*v4, v4[1], &__p, 1);
  }
  else
  {
    IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v11);
    v6 = **(int **)(a1 + 16);
    isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)&v11);
    v10 = IntOrFloatBitWidth;
    if (IntOrFloatBitWidth > 0x40)
    {
      llvm::APInt::initSlowCase((llvm::APInt *)&__p, v6, isSignedInteger);
    }
    else
    {
      v8 = 0xFFFFFFFFFFFFFFFFLL >> -(char)IntOrFloatBitWidth;
      if (!IntOrFloatBitWidth)
        v8 = 0;
      __p = (void *)(v8 & v6);
    }
    **(_QWORD **)a1 = mlir::DenseElementsAttr::get(*v4, v4[1], (llvm::APInt *)&__p, 1);
    if (v10 >= 0x41)
    {
      if (__p)
        operator delete[](__p);
    }
  }
}

void mlir::mps::getConstantAttr<int>(mlir::Type,int)::{lambda(mlir::ComplexType)#1}::operator()(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _BOOL8 isF16;
  uint64_t v5;
  void *v12;
  std::string *v14;
  std::string::size_type size;
  std::string *v16;
  std::string::size_type v17;
  llvm::APFloatBase *v18;
  void *v19;
  void *v20;
  std::string v21;
  std::string v22;
  uint64_t Value;
  uint64_t v24;
  _BYTE v25[8];
  _QWORD v26[3];
  float v27[2];
  _QWORD v28[3];
  _BYTE v29[8];
  _QWORD v30[4];
  _QWORD v31[4];

  v31[3] = *MEMORY[0x1E0C80C00];
  v24 = a2;
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v24);
  if (mlir::Type::isF32((mlir::Type *)&Value))
  {
    v3 = *(_QWORD **)(a1 + 8);
    v27[0] = (float)**(int **)(a1 + 16);
    v27[1] = 0.0;
    **(_QWORD **)a1 = mlir::DenseElementsAttr::getFromRawBuffer(*v3, v3[1], v27, 8, 8, 0, 1);
    return;
  }
  isF16 = mlir::Type::isF16((mlir::Type *)&Value);
  v5 = *(_QWORD *)(a1 + 8);
  _S0 = (float)**(int **)(a1 + 16);
  __asm { FCVT            H8, S0 }
  v12 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)isF16);
  __asm { FCVT            S0, H8; __val }
  std::to_string(&v22, _S0);
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v14 = &v22;
  else
    v14 = (std::string *)v22.__r_.__value_.__r.__words[0];
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v22.__r_.__value_.__r.__words[2]);
  else
    size = v22.__r_.__value_.__l.__size_;
  llvm::APFloat::APFloat((llvm::APFloatBase *)v27, v12, (unsigned __int8 *)v14, size);
  std::to_string(&v21, 0.0);
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v16 = &v21;
  else
    v16 = (std::string *)v21.__r_.__value_.__r.__words[0];
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = HIBYTE(v21.__r_.__value_.__r.__words[2]);
  else
    v17 = v21.__r_.__value_.__l.__size_;
  v18 = llvm::APFloat::APFloat((llvm::APFloatBase *)v25, v12, (unsigned __int8 *)v16, v17);
  v19 = (void *)v28[0];
  v20 = llvm::APFloatBase::PPCDoubleDouble(v18);
  if (v20 == v19)
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v30, (const llvm::detail::DoubleAPFloat *)v28);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v30, (const llvm::detail::IEEEFloat *)v28);
  if (v20 == (void *)v26[0])
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v31, (const llvm::detail::DoubleAPFloat *)v26);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v31, (const llvm::detail::IEEEFloat *)v26);
  **(_QWORD **)a1 = mlir::DenseElementsAttr::get(*(llvm::APFloatBase **)v5, *(_QWORD *)(v5 + 8), (uint64_t)v29, 1);
  if (v20 == (void *)v31[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v31);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v31);
  if (v20 == (void *)v30[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v30);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v30);
  if (v20 != (void *)v26[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v26);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_30;
    goto LABEL_29;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v26);
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
LABEL_29:
    operator delete(v21.__r_.__value_.__l.__data_);
LABEL_30:
  if (v20 != (void *)v28[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v28);
    if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
    goto LABEL_32;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v28);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
LABEL_32:
    operator delete(v22.__r_.__value_.__l.__data_);
}

uint64_t mlir::mps::getConstantAttr<float>(uint64_t *a1, float a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t *v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t ElementTypeOrSelf;
  void *v14;
  _QWORD v27[3];
  _QWORD v28[3];
  _QWORD v29[3];
  _QWORD v30[2];
  float v31;
  uint64_t v32;

  v31 = a2;
  v32 = 0;
  if (!a1)
    goto LABEL_10;
  v3 = *a1;
  v4 = mlir::TypeID::get<mlir::ShapedType>();
  v5 = *(unsigned int *)(v3 + 16);
  if (!(_DWORD)v5)
    goto LABEL_10;
  v6 = *(_QWORD **)(v3 + 8);
  v7 = &v6[2 * v5];
  do
  {
    v8 = v5 >> 1;
    v9 = &v6[2 * (v5 >> 1)];
    v11 = *v9;
    v10 = v9 + 2;
    v5 += ~(v5 >> 1);
    if (v11 < v4)
      v6 = v10;
    else
      v5 = v8;
  }
  while (v5);
  if (v6 != v7 && *v6 == v4)
    v12 = v6[1];
  else
LABEL_10:
    v12 = 0;
  v30[0] = a1;
  v30[1] = v12;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
  v29[0] = &v32;
  v29[1] = v30;
  v29[2] = &v31;
  v14 = *(void **)(*(_QWORD *)ElementTypeOrSelf + 136);
  if (v14 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    mlir::mps::getConstantAttr<float>(mlir::Type,float)::{lambda(mlir::Type)#1}::operator()((uint64_t)v29, ElementTypeOrSelf);
  }
  else
  {
    v28[0] = &v32;
    v28[1] = v30;
    v28[2] = &v31;
    if (v14 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
    {
      mlir::mps::getConstantAttr<float>(mlir::Type,float)::{lambda(mlir::Type)#2}::operator()((uint64_t)v28, ElementTypeOrSelf);
    }
    else
    {
      v27[0] = &v32;
      v27[1] = v30;
      v27[2] = &v31;
      if (v14 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
        mlir::mps::getConstantAttr<float>(mlir::Type,float)::{lambda(mlir::ComplexType)#1}::operator()((uint64_t)v27, ElementTypeOrSelf);
    }
  }
  return v32;
}

void mlir::mps::getConstantAttr<float>(mlir::Type,float)::{lambda(mlir::Type)#1}::operator()(uint64_t a1, uint64_t a2)
{
  _BOOL8 isF16;
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  void *v7;
  _BOOL8 isBF16;
  uint64_t v9;
  void *v10;
  std::string *v11;
  std::string::size_type size;
  llvm::APFloatBase *v13;
  void *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  std::string v21;
  uint64_t v22;
  double v23;
  _QWORD v24[4];

  v24[3] = *MEMORY[0x1E0C80C00];
  v22 = a2;
  isF16 = mlir::Type::isF16((mlir::Type *)&v22);
  if (isF16)
  {
    v4 = *(_QWORD *)(a1 + 8);
    v5 = *(llvm::APFloatBase **)v4;
    v6 = *(_QWORD *)(v4 + 8);
    v7 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)isF16);
  }
  else
  {
    isBF16 = mlir::Type::isBF16((mlir::Type *)&v22);
    if (!isBF16)
    {
      if (mlir::Type::isF32((mlir::Type *)&v22))
      {
        v15 = *(uint64_t **)(a1 + 8);
        LODWORD(v23) = **(_DWORD **)(a1 + 16);
        v16 = *v15;
        v17 = v15[1];
        v18 = 4;
        v19 = 4;
      }
      else
      {
        mlir::Type::isF64((mlir::Type *)&v22);
        v20 = *(uint64_t **)(a1 + 8);
        v23 = **(float **)(a1 + 16);
        v16 = *v20;
        v17 = v20[1];
        v18 = 8;
        v19 = 8;
      }
      **(_QWORD **)a1 = mlir::DenseElementsAttr::getFromRawBuffer(v16, v17, &v23, v18, v19, 0, 1);
      return;
    }
    v9 = *(_QWORD *)(a1 + 8);
    v5 = *(llvm::APFloatBase **)v9;
    v6 = *(_QWORD *)(v9 + 8);
    v7 = llvm::APFloatBase::BFloat((llvm::APFloatBase *)isBF16);
  }
  v10 = v7;
  std::to_string(&v21, **(float **)(a1 + 16));
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = &v21;
  else
    v11 = (std::string *)v21.__r_.__value_.__r.__words[0];
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v21.__r_.__value_.__r.__words[2]);
  else
    size = v21.__r_.__value_.__l.__size_;
  llvm::APFloat::APFloat((llvm::APFloatBase *)&v23, v10, (unsigned __int8 *)v11, size);
  v13 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get(v5, v6, (uint64_t)&v23, 1);
  **(_QWORD **)a1 = v13;
  v14 = (void *)v24[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v13) == v14)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v24);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
  }
  else
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v24);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
  }
  operator delete(v21.__r_.__value_.__l.__data_);
}

void mlir::mps::getConstantAttr<float>(mlir::Type,float)::{lambda(mlir::Type)#2}::operator()(uint64_t a1, uint64_t a2)
{
  _BOOL4 isInteger;
  uint64_t *v4;
  unsigned int IntOrFloatBitWidth;
  uint64_t v6;
  _BOOL4 isSignedInteger;
  unint64_t v8;
  void *__p;
  unsigned int v10;
  uint64_t v11;

  v11 = a2;
  isInteger = mlir::Type::isInteger((mlir::Type *)&v11, 1);
  v4 = *(uint64_t **)(a1 + 8);
  if (isInteger)
  {
    LOBYTE(__p) = **(float **)(a1 + 16) != 0.0;
    **(_QWORD **)a1 = mlir::DenseElementsAttr::get(*v4, v4[1], &__p, 1);
  }
  else
  {
    IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v11);
    v6 = (unint64_t)**(float **)(a1 + 16);
    isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)&v11);
    v10 = IntOrFloatBitWidth;
    if (IntOrFloatBitWidth > 0x40)
    {
      llvm::APInt::initSlowCase((llvm::APInt *)&__p, v6, isSignedInteger);
    }
    else
    {
      v8 = 0xFFFFFFFFFFFFFFFFLL >> -(char)IntOrFloatBitWidth;
      if (!IntOrFloatBitWidth)
        v8 = 0;
      __p = (void *)(v8 & v6);
    }
    **(_QWORD **)a1 = mlir::DenseElementsAttr::get(*v4, v4[1], (llvm::APInt *)&__p, 1);
    if (v10 >= 0x41)
    {
      if (__p)
        operator delete[](__p);
    }
  }
}

void mlir::mps::getConstantAttr<float>(mlir::Type,float)::{lambda(mlir::ComplexType)#1}::operator()(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _BOOL8 isF16;
  uint64_t v5;
  void *v12;
  std::string *v14;
  std::string::size_type size;
  std::string *v16;
  std::string::size_type v17;
  llvm::APFloatBase *v18;
  void *v19;
  void *v20;
  std::string v21;
  std::string v22;
  uint64_t Value;
  uint64_t v24;
  _BYTE v25[8];
  _QWORD v26[3];
  _DWORD v27[2];
  _QWORD v28[3];
  _BYTE v29[8];
  _QWORD v30[4];
  _QWORD v31[4];

  v31[3] = *MEMORY[0x1E0C80C00];
  v24 = a2;
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v24);
  if (mlir::Type::isF32((mlir::Type *)&Value))
  {
    v3 = *(_QWORD **)(a1 + 8);
    v27[0] = **(_DWORD **)(a1 + 16);
    v27[1] = 0;
    **(_QWORD **)a1 = mlir::DenseElementsAttr::getFromRawBuffer(*v3, v3[1], v27, 8, 8, 0, 1);
    return;
  }
  isF16 = mlir::Type::isF16((mlir::Type *)&Value);
  v5 = *(_QWORD *)(a1 + 8);
  _S0 = **(_DWORD **)(a1 + 16);
  __asm { FCVT            H8, S0 }
  v12 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)isF16);
  __asm { FCVT            S0, H8; __val }
  std::to_string(&v22, _S0);
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v14 = &v22;
  else
    v14 = (std::string *)v22.__r_.__value_.__r.__words[0];
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v22.__r_.__value_.__r.__words[2]);
  else
    size = v22.__r_.__value_.__l.__size_;
  llvm::APFloat::APFloat((llvm::APFloatBase *)v27, v12, (unsigned __int8 *)v14, size);
  std::to_string(&v21, 0.0);
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v16 = &v21;
  else
    v16 = (std::string *)v21.__r_.__value_.__r.__words[0];
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = HIBYTE(v21.__r_.__value_.__r.__words[2]);
  else
    v17 = v21.__r_.__value_.__l.__size_;
  v18 = llvm::APFloat::APFloat((llvm::APFloatBase *)v25, v12, (unsigned __int8 *)v16, v17);
  v19 = (void *)v28[0];
  v20 = llvm::APFloatBase::PPCDoubleDouble(v18);
  if (v20 == v19)
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v30, (const llvm::detail::DoubleAPFloat *)v28);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v30, (const llvm::detail::IEEEFloat *)v28);
  if (v20 == (void *)v26[0])
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v31, (const llvm::detail::DoubleAPFloat *)v26);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v31, (const llvm::detail::IEEEFloat *)v26);
  **(_QWORD **)a1 = mlir::DenseElementsAttr::get(*(llvm::APFloatBase **)v5, *(_QWORD *)(v5 + 8), (uint64_t)v29, 1);
  if (v20 == (void *)v31[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v31);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v31);
  if (v20 == (void *)v30[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v30);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v30);
  if (v20 != (void *)v26[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v26);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_30;
    goto LABEL_29;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v26);
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
LABEL_29:
    operator delete(v21.__r_.__value_.__l.__data_);
LABEL_30:
  if (v20 != (void *)v28[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v28);
    if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
    goto LABEL_32;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v28);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
LABEL_32:
    operator delete(v22.__r_.__value_.__l.__data_);
}

void mlir::mps::`anonymous namespace'::LowerNonZero::~LowerNonZero(mlir::mps::_anonymous_namespace_::LowerNonZero *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NonZeroOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NonZeroOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::NonZeroOpGenericAdaptorBase::NonZeroOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::NonZeroOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::NonZeroOpGenericAdaptorBase::NonZeroOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::`anonymous namespace'::LowerNonZero::matchAndRewrite(int a1, uint64_t a2, uint64_t **this, uint64_t a4)
{
  unsigned int ODSOperandIndexAndLength;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t *v16;
  _QWORD *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t *v41;
  uint64_t *v42;
  uint64_t v43;
  __int128 v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t *v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  unsigned __int8 v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _OWORD v61[2];
  uint64_t v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _OWORD v71[2];
  uint64_t v72;
  _OWORD v73[2];
  uint64_t v74;
  _OWORD v75[2];
  uint64_t v76;
  _OWORD v77[2];
  uint64_t v78;
  _QWORD v79[2];
  unint64_t v80[2];
  _QWORD v81[2];
  uint64_t *SI32TensorAttr;
  uint64_t v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)this, 0);
  v8 = this[5];
  SI32TensorAttr = v8;
  v83 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v8 = (uint64_t *)mlir::ValueRange::offset_base(&SI32TensorAttr, ODSOperandIndexAndLength);
  SI32TensorAttr = v8;
  v83 = 0;
  v9 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&SI32TensorAttr, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v9)
    goto LABEL_12;
  v10 = *v9;
  v11 = mlir::TypeID::get<mlir::ShapedType>();
  v12 = *(unsigned int *)(v10 + 16);
  if (!(_DWORD)v12)
    goto LABEL_12;
  v13 = *(_QWORD **)(v10 + 8);
  v14 = &v13[2 * v12];
  do
  {
    v15 = v12 >> 1;
    v16 = &v13[2 * (v12 >> 1)];
    v18 = *v16;
    v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11)
      v13 = v17;
    else
      v12 = v15;
  }
  while (v12);
  if (v13 != v14 && *v13 == v11)
    v19 = v13[1];
  else
LABEL_12:
    v19 = 0;
  v79[0] = v9;
  v79[1] = v19;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v79))
    return 0;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v79);
  v21 = v20;
  v22 = *(_QWORD *)(a2 + 24);
  v23 = *(_OWORD *)(a4 + 24);
  v77[0] = *(_OWORD *)(a4 + 8);
  v77[1] = v23;
  LODWORD(v81[0]) = -1;
  SI32TensorAttr = (uint64_t *)mlir::getSI32TensorAttr((mlir::Builder *)v77, (uint64_t)v81, 1);
  v78 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v22, &SI32TensorAttr)- 16;
  v24 = *(_QWORD *)(a2 + 24);
  v25 = *(_OWORD *)(a4 + 24);
  v75[0] = *(_OWORD *)(a4 + 8);
  v75[1] = v25;
  LODWORD(v81[0]) = 0;
  SI32TensorAttr = (uint64_t *)mlir::getSI32TensorAttr((mlir::Builder *)v75, (uint64_t)v81, 1);
  v76 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v24, &SI32TensorAttr)- 16;
  v26 = *(_QWORD *)(a2 + 24);
  v27 = *(_OWORD *)(a4 + 24);
  v73[0] = *(_OWORD *)(a4 + 8);
  v73[1] = v27;
  LODWORD(v81[0]) = 1;
  SI32TensorAttr = (uint64_t *)mlir::getSI32TensorAttr((mlir::Builder *)v73, (uint64_t)v81, 1);
  v74 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v26, &SI32TensorAttr)- 16;
  v28 = *(_QWORD *)(a2 + 24);
  v29 = *(_OWORD *)(a4 + 24);
  v71[0] = *(_OWORD *)(a4 + 8);
  v71[1] = v29;
  LODWORD(v81[0]) = -1;
  SI32TensorAttr = (uint64_t *)mlir::getSI32TensorAttr((mlir::Builder *)v71, (uint64_t)v81, 1);
  v72 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v28, &SI32TensorAttr)- 16;
  v30 = *(_QWORD *)(a2 + 24);
  v31 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)this, 0);
  v32 = this[5];
  SI32TensorAttr = v32;
  v83 = v31;
  if (v31)
    v32 = (uint64_t *)mlir::ValueRange::offset_base(&SI32TensorAttr, v31);
  SI32TensorAttr = v32;
  v83 = 0;
  v33 = mlir::ValueRange::dereference_iterator(&SI32TensorAttr, 0);
  SI32TensorAttr = (uint64_t *)mlir::getElementTypeOrSelf(v33);
  v70 = (uint64_t)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), v30, &v76, (uint64_t *)&SI32TensorAttr)- 16;
  v34 = *(_QWORD *)(a2 + 24);
  v35 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)this, 0);
  v36 = this[5];
  SI32TensorAttr = v36;
  v83 = v35;
  if (v35)
    v36 = (uint64_t *)mlir::ValueRange::offset_base(&SI32TensorAttr, v35);
  SI32TensorAttr = v36;
  v83 = 0;
  SI32TensorAttr = (uint64_t *)mlir::ValueRange::dereference_iterator(&SI32TensorAttr, 0);
  v69 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value&>((mlir::UnitAttr **)(a4 + 8), v34, (uint64_t *)&SI32TensorAttr, &v78)- 16;
  v68 = (uint64_t)mlir::OpBuilder::create<mlir::mps::NotEqualToOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(a2 + 24), &v69, &v70)- 16;
  v67 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SelectOp,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(a2 + 24), &v68, &v74, &v76)- 16;
  v37 = *(_QWORD *)(a2 + 24);
  SI32TensorAttr = (uint64_t *)mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x20u, 1);
  v66 = (uint64_t)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), v37, &v67, (uint64_t *)&SI32TensorAttr)- 16;
  v38 = *(_QWORD *)(a2 + 24);
  LOBYTE(SI32TensorAttr) = 0;
  v65 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::Value &,BOOL &>((mlir::UnitAttr **)(a4 + 8), v38, &v66, &v76, (unsigned __int8 *)&SI32TensorAttr)- 16;
  v39 = *(_QWORD *)(a2 + 24);
  v40 = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength((mlir::scf::detail::IfOpGenericAdaptorBase *)this, 0);
  v41 = this[5];
  SI32TensorAttr = v41;
  v83 = v40;
  if (v40)
    v41 = (uint64_t *)mlir::ValueRange::offset_base(&SI32TensorAttr, v40);
  SI32TensorAttr = v41;
  v83 = 0;
  SI32TensorAttr = (uint64_t *)mlir::ValueRange::dereference_iterator(&SI32TensorAttr, 0);
  v64 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>((mlir::OpBuilder *)(a4 + 8), v39, (uint64_t *)&SI32TensorAttr)- 16;
  v63 = 0;
  if (v21 < 1)
  {
    v49 = 0;
  }
  else
  {
    v42 = 0;
    do
    {
      v43 = *(_QWORD *)(a2 + 24);
      v44 = *(_OWORD *)(a4 + 24);
      v61[0] = *(_OWORD *)(a4 + 8);
      v61[1] = v44;
      SI32TensorAttr = (uint64_t *)mlir::getSI32TensorAttr((mlir::Builder *)v61, (uint64_t)&v63, 1);
      v62 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v43, &SI32TensorAttr)- 16;
      v60 = (uint64_t)mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::Value &,mlir::Value &>((uint64_t *)(a4 + 8), *(_QWORD *)(a2 + 24), &v64, &v62)- 16;
      v59 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value&>((mlir::UnitAttr **)(a4 + 8), *(_QWORD *)(a2 + 24), &v60, &v78)- 16;
      v45 = *(_QWORD *)(a2 + 24);
      LOBYTE(SI32TensorAttr) = 1;
      LOBYTE(v81[0]) = 0;
      v58 = (uint64_t)mlir::OpBuilder::create<mlir::mps::CumulativeSumOp,mlir::Value &,mlir::Value &,BOOL,BOOL>((mlir::UnitAttr **)(a4 + 8), v45, &v67, &v76, (unsigned __int8 *)&SI32TensorAttr, (unsigned __int8 *)v81)- 16;
      v57 = (uint64_t)mlir::OpBuilder::create<mlir::mps::SelectOp,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(a2 + 24), &v68, &v58, &v72)- 16;
      v56 = (uint64_t)mlir::OpBuilder::create<mlir::mps::BroadcastToOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(a2 + 24), &v76, &v65)- 16;
      v46 = *(_QWORD *)(a2 + 24);
      SI32TensorAttr = (uint64_t *)mlir::getElementTypeOrSelf(v59);
      v56 = (uint64_t)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), v46, &v56, (uint64_t *)&SI32TensorAttr)- 16;
      v47 = *(_QWORD *)(a2 + 24);
      LODWORD(SI32TensorAttr) = 6;
      v55 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ScatterOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::mps::ScatterMode>((mlir::MLIRContext **)(a4 + 8), v47, &v56, &v59, &v57, &v76, (unsigned int *)&SI32TensorAttr)- 16);
      v55 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v55, &v74)- 16);
      v48 = *(_QWORD *)(a2 + 24);
      SI32TensorAttr = (uint64_t *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8));
      v49 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), v48, (uint64_t *)&v55, (uint64_t *)&SI32TensorAttr)- 16);
      v55 = v49;
      v50 = v63;
      if (v63)
      {
        v51 = *(_QWORD *)(a2 + 24);
        v81[0] = v42;
        v81[1] = v49;
        mlir::ValueRange::ValueRange((unint64_t *)&SI32TensorAttr, (uint64_t)v81, 2uLL);
        v54 = 0;
        v49 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConcatOp,mlir::ValueRange,mlir::Value &,BOOL>((mlir::UnitAttr **)(a4 + 8), v51, (uint64_t *)&SI32TensorAttr, &v74, &v54)- 16);
        v50 = v63;
      }
      v63 = v50 + 1;
      v42 = v49;
    }
    while (v21 > v50 + 1);
  }
  SI32TensorAttr = v49;
  v52 = 1;
  mlir::ValueRange::ValueRange(v80, (uint64_t)&SI32TensorAttr, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, (unsigned int *)a2, v80[0], v80[1]);
  return v52;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::NotEqualToOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.not_equal", (const unsigned __int8 *)0xD, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.not_equal";
    v17[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::EqualToOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::NotEqualToOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SelectOp,mlir::Value &,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.select";
    v19[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::SelectOp::build((uint64_t)a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SelectOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::Value &,mlir::Value &>(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.get_coordinates", (const unsigned __int8 *)0x13, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.get_coordinates";
    v17[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::GetCoordOp::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::GetCoordOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CumulativeSumOp,mlir::Value &,mlir::Value &,BOOL,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5, unsigned __int8 *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cumulative_sum", (const unsigned __int8 *)0x12, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.cumulative_sum";
    v21[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::CumulativeSumOp::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CumulativeSumOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::BroadcastToOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.broadcast_to", (const unsigned __int8 *)0x10, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.broadcast_to";
    v17[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::BroadcastToOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::BroadcastToOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ScatterOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::mps::ScatterMode>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned int *a7)
{
  uint64_t *Context;
  uint64_t v15;
  char v16;
  mlir::GenericProgramPoint *v17;
  mlir::GenericProgramPoint *v18;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.scatter", (const unsigned __int8 *)0xB, Context);
  if (!v16)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.scatter";
    v23[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::mps::ScatterOp::build(a1, (uint64_t)v25, *a3, *a4, *a5, *a6, *a7);
  v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((_QWORD *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ScatterOp,void>::id)
    v18 = v17;
  else
    v18 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConcatOp,mlir::ValueRange,mlir::Value &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.concat", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.concat";
    v19[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ConcatOp::build(a1, (uint64_t)v21, *a3, a3[1], *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConcatOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::mps::`anonymous namespace'::LowerSigmoid::~LowerSigmoid(mlir::mps::_anonymous_namespace_::LowerSigmoid *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SigmoidOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SigmoidOp>::rewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SigmoidOpGenericAdaptorBase::SigmoidOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::SigmoidOp>::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::SigmoidOpGenericAdaptorBase::SigmoidOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, mlir::Operation *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::`anonymous namespace'::LowerSigmoid::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::scf::detail::IfOpGenericAdaptorBase *a3, uint64_t a4)
{
  uint64_t v7;
  mlir::OpBuilder *v8;
  unsigned int ODSOperandIndexAndLength;
  unint64_t v10;
  mlir::GenericProgramPoint *v11;
  uint64_t ElementTypeOrSelf;
  mlir::GenericProgramPoint *v14;
  uint64_t v15;
  mlir::GenericProgramPoint *v16;
  mlir::GenericProgramPoint *v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a2 + 24);
  v8 = (mlir::OpBuilder *)(a4 + 8);
  LODWORD(v17) = 1;
  v16 = mlir::OpBuilder::create<mlir::mps::ConstantOp,int>((mlir::mps::ConstantOp *)(a4 + 8), v7, (unsigned int *)&v17);
  ODSOperandIndexAndLength = mlir::scf::detail::IfOpGenericAdaptorBase::getODSOperandIndexAndLength(a3, 0);
  v10 = *((_QWORD *)a3 + 5);
  v17 = (mlir::GenericProgramPoint *)v10;
  v18 = ODSOperandIndexAndLength;
  if (ODSOperandIndexAndLength)
    v10 = mlir::ValueRange::offset_base(&v17, ODSOperandIndexAndLength);
  v17 = (mlir::GenericProgramPoint *)v10;
  v18 = 0;
  v15 = mlir::ValueRange::dereference_iterator(&v17, 0);
  v17 = mlir::OpBuilder::create<mlir::mps::NegativeOp,mlir::Value>(v8, v7, &v15);
  v15 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ExponentOp,mlir::mps::NegativeOp &>(v8, v7, &v17);
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(v15 - 16);
  v14 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::ConstantOp &,mlir::Type>((mlir::UnknownLoc **)v8, v7, &v16, &ElementTypeOrSelf);
  ElementTypeOrSelf = (uint64_t)mlir::OpBuilder::create<mlir::mps::AddOp,mlir::mps::SubtractOp &,mlir::mps::ConstantOp>((mlir::Float32Type **)v8, v7, &v15, &v14);
  v11 = mlir::OpBuilder::create<mlir::mps::ReciprocalOp,mlir::mps::AddOp &>(v8, *(_QWORD *)(a2 + 24), &ElementTypeOrSelf);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, a2, v11);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::NegativeOp,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.negative", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.negative";
    v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::NegativeOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ExponentOp,mlir::mps::NegativeOp &>(mlir::OpBuilder *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.exponent", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.exponent";
    v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3 - 16);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExponentOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::ConstantOp &,mlir::Type>(mlir::UnknownLoc **a1, uint64_t a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.cast";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::CastOp::build(a1, (uint64_t)v19, *a3 - 16, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReciprocalOp,mlir::mps::AddOp &>(mlir::OpBuilder *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal", (const unsigned __int8 *)0xE, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.reciprocal";
    v15[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v17, *a3 - 16);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void mlir::mps::`anonymous namespace'::LowerArithSelect::~LowerArithSelect(mlir::mps::_anonymous_namespace_::LowerArithSelect *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::arith::SelectOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::arith::SelectOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::arith::detail::SelectOpGenericAdaptorBase::SelectOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::arith::SelectOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::arith::detail::SelectOpGenericAdaptorBase::SelectOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

BOOL mlir::mps::`anonymous namespace'::LowerArithSelect::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t Input;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  _BOOL8 result;
  uint64_t Loc;
  uint64_t v17;
  uint64_t v18;
  mlir::GenericProgramPoint *v19;
  uint64_t Bias;
  uint64_t v21[2];
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;

  v24 = a2;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v24);
  v22 = (uint64_t *)(*(_QWORD *)(Input + 8) & 0xFFFFFFFFFFFFFFF8);
  v23 = Input;
  v6 = *v22;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_10;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 == v10 || *v9 != v7 || !v9[1])
  {
LABEL_10:
    result = mlir::Type::isInteger((mlir::Type *)&v22, 1);
    if (!result)
      return result;
    Loc = mlir::Value::getLoc((mlir::Value *)&v23);
    v23 = (uint64_t)mlir::OpBuilder::create<mlir::tensor::FromElementsOp,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), Loc, (uint64_t)&v23)- 16;
    v17 = mlir::Value::getLoc((mlir::Value *)&v23);
    v21[0] = 0;
    v21[1] = 0;
    v23 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::ArrayRef<long long>>((mlir::Builder *)(a4 + 8), v17, &v23, (uint64_t)v21)- 16;
  }
  v18 = v24;
  v21[0] = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v24);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v24);
  v19 = mlir::OpBuilder::create<mlir::mps::SelectOp,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a4 + 8), *(_QWORD *)(v18 + 24), &v23, v21, &Bias);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v18, v19);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::tensor::FromElementsOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.from_elements", (const unsigned __int8 *)0x14, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"tensor.from_elements";
    v15[3] = 20;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::tensor::FromElementsOp::build((uint64_t)a1, (uint64_t)v17, a3, 1);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::FromElementsOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::ArrayRef<long long>>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  uint64_t v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.reshape";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ReshapeOp::build(a1, v19, *a3, *(_QWORD *)a4, *(uint64_t **)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

_QWORD *mlir::mps::`anonymous namespace'::LowerInterleave<mlir::mpsx::DeinterleaveOp>::~LowerInterleave(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::LowerInterleave<mlir::mpsx::DeinterleaveOp>::~LowerInterleave(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::DeinterleaveOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::DeinterleaveOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mpsx::detail::DeinterleaveOpGenericAdaptorBase::DeinterleaveOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::DeinterleaveOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mpsx::detail::DeinterleaveOpGenericAdaptorBase::DeinterleaveOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::`anonymous namespace'::LowerInterleave<mlir::mpsx::DeinterleaveOp>::matchAndRewrite(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  signed int Axis;
  uint64_t IntegerType;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t *v16;
  _QWORD *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  unint64_t v25;
  unint64_t *v26;
  _QWORD *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  unint64_t v36;
  unint64_t *v37;
  _QWORD *v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  mlir::GenericProgramPoint *v42;
  uint64_t **v43;
  unint64_t v44;
  unint64_t v45;
  __int128 v46;
  unint64_t v48;
  char *v49;
  signed int v50;
  uint64_t *v51;
  uint64_t *v52[4];
  __int16 v53;
  uint64_t *v54;
  uint64_t *v55[3];
  uint64_t v56;
  _BYTE v57[16];
  unint64_t v58;
  unsigned int v59;
  unsigned int v60;
  _BYTE v61[152];
  __int128 v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  v54 = a2;
  v62 = *(_OWORD *)(a3 + 40);
  v5 = a2[3];
  Axis = mlir::anec::Concat::getAxis((mlir::Operation **)&v54);
  if (mlir::getANENextSupportedInterleaveValue(Axis) == Axis)
  {
    v56 = 1;
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x20u, 1);
    v8 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v56, 1, IntegerType, 0);
    v9 = v8;
    if (!v8)
      goto LABEL_11;
    v10 = *v8;
    v11 = mlir::TypeID::get<mlir::ShapedType>();
    v12 = *(unsigned int *)(v10 + 16);
    if (!(_DWORD)v12)
      goto LABEL_11;
    v13 = *(_QWORD **)(v10 + 8);
    v14 = &v13[2 * v12];
    do
    {
      v15 = v12 >> 1;
      v16 = &v13[2 * (v12 >> 1)];
      v18 = *v16;
      v17 = v16 + 2;
      v12 += ~(v12 >> 1);
      if (v18 < v11)
        v13 = v17;
      else
        v12 = v15;
    }
    while (v12);
    if (v13 != v14 && *v13 == v11)
      v19 = v13[1];
    else
LABEL_11:
      v19 = 0;
    LODWORD(v55[0]) = -1;
    v52[0] = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v19, v55, 4, 4, 1, 1);
    v56 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v5, v52)- 16;
    if (!v9)
      goto LABEL_21;
    v20 = *v9;
    v21 = mlir::TypeID::get<mlir::ShapedType>();
    v22 = *(unsigned int *)(v20 + 16);
    if (!(_DWORD)v22)
      goto LABEL_21;
    v23 = *(_QWORD **)(v20 + 8);
    v24 = &v23[2 * v22];
    do
    {
      v25 = v22 >> 1;
      v26 = &v23[2 * (v22 >> 1)];
      v28 = *v26;
      v27 = v26 + 2;
      v22 += ~(v22 >> 1);
      if (v28 < v21)
        v23 = v27;
      else
        v22 = v25;
    }
    while (v22);
    if (v23 != v24 && *v23 == v21)
      v29 = v23[1];
    else
LABEL_21:
      v29 = 0;
    LODWORD(v51) = -3;
    v30 = 1;
    v55[0] = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v29, &v51, 4, 4, 1, 1);
    v52[0] = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v5, v55)- 16);
    if (!v9)
      goto LABEL_31;
    v31 = *v9;
    v32 = mlir::TypeID::get<mlir::ShapedType>();
    v33 = *(unsigned int *)(v31 + 16);
    if (!(_DWORD)v33)
      goto LABEL_31;
    v34 = *(_QWORD **)(v31 + 8);
    v35 = &v34[2 * v33];
    do
    {
      v36 = v33 >> 1;
      v37 = &v34[2 * (v33 >> 1)];
      v39 = *v37;
      v38 = v37 + 2;
      v33 += ~(v33 >> 1);
      if (v39 < v32)
        v34 = v38;
      else
        v33 = v36;
    }
    while (v33);
    if (v34 != v35 && *v34 == v32)
      v40 = v34[1];
    else
LABEL_31:
      v40 = 0;
    v50 = Axis;
    v51 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v40, &v50, 4, 4, 1, 1);
    v55[0] = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v5, &v51)- 16);
    v51 = (uint64_t *)mlir::ValueRange::dereference_iterator(&v62, 0);
    v41 = v54;
    LOBYTE(v50) = 1;
    v42 = mlir::OpBuilder::create<mlir::mps::SpaceToBatchOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>((mlir::UnitAttr **)(a4 + 8), v54[3], (uint64_t *)&v51, &v56, (uint64_t *)v52, (uint64_t *)v55, (unsigned __int8 *)&v50);
    (*(void (**)(uint64_t, uint64_t *, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v41, v42);
  }
  else
  {
    v53 = 257;
    mlir::OpState::emitOpError(&v54, (const void ***)v52, (uint64_t)&v56);
    if (v56)
    {
      mlir::Diagnostic::operator<<((uint64_t)v57, "Unsupported interleave factor ");
      if (v56)
      {
        LODWORD(v55[0]) = 2;
        v55[1] = (uint64_t *)Axis;
        v43 = v55;
        v44 = v58;
        if (v59 >= v60)
        {
          v48 = v59 + 1;
          if (v58 <= (unint64_t)v55 && v58 + 24 * v59 > (unint64_t)v55)
          {
            v49 = (char *)v55 - v58;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v61, v48, 24);
            v44 = v58;
            v43 = (uint64_t **)&v49[v58];
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v61, v48, 24);
            v43 = v55;
            v44 = v58;
          }
        }
        v45 = v44 + 24 * v59;
        v46 = *(_OWORD *)v43;
        *(_QWORD *)(v45 + 16) = v43[2];
        *(_OWORD *)v45 = v46;
        ++v59;
        if (v56)
          mlir::Diagnostic::operator<<((uint64_t)v57, ": the model must be placed on ANE to work properly");
      }
    }
    v30 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v56);
    if (v56)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v56);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v57);
  }
  return v30;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SpaceToBatchOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned __int8 *a7)
{
  uint64_t *Context;
  uint64_t v15;
  char v16;
  mlir::GenericProgramPoint *v17;
  mlir::GenericProgramPoint *v18;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.space_to_batch", (const unsigned __int8 *)0x12, Context);
  if (!v16)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.space_to_batch";
    v23[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::mps::SpaceToBatchOp::build(a1, (uint64_t)v25, *a3, *a4, *a5, *a6, *a7);
  v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((_QWORD *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SpaceToBatchOp,void>::id)
    v18 = v17;
  else
    v18 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

_QWORD *mlir::mps::`anonymous namespace'::LowerInterleave<mlir::mpsx::InterleaveOp>::~LowerInterleave(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::LowerInterleave<mlir::mpsx::InterleaveOp>::~LowerInterleave(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::InterleaveOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::InterleaveOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mpsx::detail::InterleaveOpGenericAdaptorBase::InterleaveOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::InterleaveOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mpsx::detail::InterleaveOpGenericAdaptorBase::InterleaveOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::`anonymous namespace'::LowerInterleave<mlir::mpsx::InterleaveOp>::matchAndRewrite(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  signed int Axis;
  uint64_t IntegerType;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t *v16;
  _QWORD *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  unint64_t v25;
  unint64_t *v26;
  _QWORD *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  unint64_t v36;
  unint64_t *v37;
  _QWORD *v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  mlir::GenericProgramPoint *v42;
  uint64_t **v43;
  unint64_t v44;
  unint64_t v45;
  __int128 v46;
  unint64_t v48;
  char *v49;
  signed int v50;
  uint64_t *v51;
  uint64_t *v52[4];
  __int16 v53;
  uint64_t *v54;
  uint64_t *v55[3];
  uint64_t v56;
  _BYTE v57[16];
  unint64_t v58;
  unsigned int v59;
  unsigned int v60;
  _BYTE v61[152];
  __int128 v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  v54 = a2;
  v62 = *(_OWORD *)(a3 + 40);
  v5 = a2[3];
  Axis = mlir::anec::Concat::getAxis((mlir::Operation **)&v54);
  if (mlir::getANENextSupportedInterleaveValue(Axis) == Axis)
  {
    v56 = 1;
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a4 + 8), 0x20u, 1);
    v8 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v56, 1, IntegerType, 0);
    v9 = v8;
    if (!v8)
      goto LABEL_11;
    v10 = *v8;
    v11 = mlir::TypeID::get<mlir::ShapedType>();
    v12 = *(unsigned int *)(v10 + 16);
    if (!(_DWORD)v12)
      goto LABEL_11;
    v13 = *(_QWORD **)(v10 + 8);
    v14 = &v13[2 * v12];
    do
    {
      v15 = v12 >> 1;
      v16 = &v13[2 * (v12 >> 1)];
      v18 = *v16;
      v17 = v16 + 2;
      v12 += ~(v12 >> 1);
      if (v18 < v11)
        v13 = v17;
      else
        v12 = v15;
    }
    while (v12);
    if (v13 != v14 && *v13 == v11)
      v19 = v13[1];
    else
LABEL_11:
      v19 = 0;
    LODWORD(v55[0]) = -1;
    v52[0] = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v19, v55, 4, 4, 1, 1);
    v56 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v5, v52)- 16;
    if (!v9)
      goto LABEL_21;
    v20 = *v9;
    v21 = mlir::TypeID::get<mlir::ShapedType>();
    v22 = *(unsigned int *)(v20 + 16);
    if (!(_DWORD)v22)
      goto LABEL_21;
    v23 = *(_QWORD **)(v20 + 8);
    v24 = &v23[2 * v22];
    do
    {
      v25 = v22 >> 1;
      v26 = &v23[2 * (v22 >> 1)];
      v28 = *v26;
      v27 = v26 + 2;
      v22 += ~(v22 >> 1);
      if (v28 < v21)
        v23 = v27;
      else
        v22 = v25;
    }
    while (v22);
    if (v23 != v24 && *v23 == v21)
      v29 = v23[1];
    else
LABEL_21:
      v29 = 0;
    LODWORD(v51) = -3;
    v30 = 1;
    v55[0] = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v29, &v51, 4, 4, 1, 1);
    v52[0] = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v5, v55)- 16);
    if (!v9)
      goto LABEL_31;
    v31 = *v9;
    v32 = mlir::TypeID::get<mlir::ShapedType>();
    v33 = *(unsigned int *)(v31 + 16);
    if (!(_DWORD)v33)
      goto LABEL_31;
    v34 = *(_QWORD **)(v31 + 8);
    v35 = &v34[2 * v33];
    do
    {
      v36 = v33 >> 1;
      v37 = &v34[2 * (v33 >> 1)];
      v39 = *v37;
      v38 = v37 + 2;
      v33 += ~(v33 >> 1);
      if (v39 < v32)
        v34 = v38;
      else
        v33 = v36;
    }
    while (v33);
    if (v34 != v35 && *v34 == v32)
      v40 = v34[1];
    else
LABEL_31:
      v40 = 0;
    v50 = Axis;
    v51 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v40, &v50, 4, 4, 1, 1);
    v55[0] = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a4 + 8), v5, &v51)- 16);
    v51 = (uint64_t *)mlir::ValueRange::dereference_iterator(&v62, 0);
    v41 = v54;
    LOBYTE(v50) = 1;
    v42 = mlir::OpBuilder::create<mlir::mps::BatchToSpaceOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>((mlir::UnitAttr **)(a4 + 8), v54[3], (uint64_t *)&v51, &v56, (uint64_t *)v52, (uint64_t *)v55, (unsigned __int8 *)&v50);
    (*(void (**)(uint64_t, uint64_t *, mlir::GenericProgramPoint *))(*(_QWORD *)a4 + 32))(a4, v41, v42);
  }
  else
  {
    v53 = 257;
    mlir::OpState::emitOpError(&v54, (const void ***)v52, (uint64_t)&v56);
    if (v56)
    {
      mlir::Diagnostic::operator<<((uint64_t)v57, "Unsupported interleave factor ");
      if (v56)
      {
        LODWORD(v55[0]) = 2;
        v55[1] = (uint64_t *)Axis;
        v43 = v55;
        v44 = v58;
        if (v59 >= v60)
        {
          v48 = v59 + 1;
          if (v58 <= (unint64_t)v55 && v58 + 24 * v59 > (unint64_t)v55)
          {
            v49 = (char *)v55 - v58;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v61, v48, 24);
            v44 = v58;
            v43 = (uint64_t **)&v49[v58];
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v61, v48, 24);
            v43 = v55;
            v44 = v58;
          }
        }
        v45 = v44 + 24 * v59;
        v46 = *(_OWORD *)v43;
        *(_QWORD *)(v45 + 16) = v43[2];
        *(_OWORD *)v45 = v46;
        ++v59;
        if (v56)
          mlir::Diagnostic::operator<<((uint64_t)v57, ": the model must be placed on ANE to work properly");
      }
    }
    v30 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v56);
    if (v56)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v56);
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v57);
  }
  return v30;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::BatchToSpaceOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,BOOL>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, unsigned __int8 *a7)
{
  uint64_t *Context;
  uint64_t v15;
  char v16;
  mlir::GenericProgramPoint *v17;
  mlir::GenericProgramPoint *v18;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.batch_to_space", (const unsigned __int8 *)0x12, Context);
  if (!v16)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.batch_to_space";
    v23[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::mps::BatchToSpaceOp::build(a1, (uint64_t)v25, *a3, *a4, *a5, *a6, *a7);
  v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((_QWORD *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::BatchToSpaceOp,void>::id)
    v18 = v17;
  else
    v18 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

void mlir::mps::`anonymous namespace'::LowerDequantizeLUT::~LowerDequantizeLUT(mlir::mps::_anonymous_namespace_::LowerDequantizeLUT *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DequantizeLUTOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DequantizeLUTOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::DequantizeLUTOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DequantizeLUTOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[48];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::DequantizeLUTOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::`anonymous namespace'::LowerDequantizeLUT::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase *a3, mlir::Float32Type **a4)
{
  uint64_t DefiningOp;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t *v20;
  _QWORD *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  unint64_t v30;
  unint64_t *v31;
  _QWORD *v32;
  unint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  unint64_t v41;
  unint64_t *v42;
  _QWORD *v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v52;
  uint64_t *ArgAttrsAttr;
  uint64_t v54;
  int Axis;
  uint64_t PositiveAxis;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  unint64_t NumElements;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  _BOOL4 v91;
  uint64_t v92;
  char *v93;
  char *v94;
  char *v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t *v99;
  uint64_t *v100;
  char *v101;
  uint64_t v102;
  double v103;
  uint64_t v104;
  uint64_t v105;
  int v106;
  unint64_t v107;
  _BOOL4 v109;
  unint64_t v110;
  uint64_t v111;
  unint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  _QWORD *v117;
  _QWORD *v118;
  unint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  uint64_t *v124;
  uint64_t *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  unint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t *v134;
  _QWORD *v135;
  _QWORD *v136;
  unint64_t v137;
  uint64_t *v138;
  uint64_t *v139;
  uint64_t *v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  char *v148;
  char *v149;
  uint64_t v150;
  unint64_t v151;
  unint64_t v152;
  char *v153;
  char *v154;
  int v155;
  _QWORD *v156;
  _QWORD *v157;
  uint64_t v158;
  _OWORD *v159;
  __int128 *v160;
  unint64_t v161;
  __int128 v162;
  uint64_t v163;
  mlir::MLIRContext *v164;
  uint64_t v165;
  uint64_t F32Type;
  _QWORD *v167;
  _QWORD *RawElementsAttr;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  mlir::GenericProgramPoint *v172;
  int64x2_t *v173;
  int64x2_t *v174;
  int64x2_t *v175;
  unint64_t v176;
  int64x2_t v177;
  uint64_t v178;
  uint64_t v179;
  mlir::Float32Type **v180;
  uint64_t v181;
  _BOOL4 v182;
  unint64_t v183;
  unint64_t v184;
  _QWORD v185[2];
  _QWORD *v186;
  uint64_t v187;
  _QWORD v188[2];
  _QWORD v189[2];
  uint64_t v190;
  void *v191;
  uint64_t v192;
  _BYTE v193[48];
  void *v194;
  uint64_t v195;
  _BYTE v196[48];
  void *v197;
  uint64_t v198;
  _BYTE v199[48];
  void *v200;
  uint64_t v201;
  _BYTE v202[48];
  void *v203;
  uint64_t v204;
  _BYTE v205[48];
  void *v206;
  uint64_t v207;
  _BYTE v208[48];
  void *v209;
  uint64_t v210;
  _BYTE v211[48];
  void *v212;
  uint64_t v213;
  _BYTE v214[48];
  char *v215;
  uint64_t v216;
  _BYTE v217[48];
  void *v218[2];
  _BYTE v219[48];
  __int128 v220;
  uint64_t v221;

  v221 = *MEMORY[0x1E0C80C00];
  v190 = a2;
  v220 = *((_OWORD *)a3 + 3);
  v218[0] = v219;
  v218[1] = (void *)0xC00000000;
  v212 = (void *)mlir::ValueRange::dereference_iterator(&v220, 0);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v212);
  if (!DefiningOp)
    goto LABEL_43;
  v7 = DefiningOp;
  v8 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v7 + 48) + 32))(*(_QWORD *)(v7 + 48), v8))
    goto LABEL_43;
  v215 = v217;
  v216 = 0x100000000;
  mlir::Operation::fold(v7, 0, 0, (uint64_t)&v215);
  v10 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v215 & 0xFFFFFFFFFFFFFFF8));
  if (v10)
    v11 = v9;
  else
    v11 = 0;
  if (v215 != v217)
    free(v215);
  if (!v10
    || (v12 = mlir::ValueRange::dereference_iterator(&v220, 1),
        !mlir::matchConstantWithFloatVector<float>(v12, (uint64_t)v218)))
  {
LABEL_43:
    v50 = 0;
    goto LABEL_44;
  }
  v13 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v220, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v13)
    goto LABEL_19;
  v14 = *v13;
  v15 = mlir::TypeID::get<mlir::ShapedType>();
  v16 = *(unsigned int *)(v14 + 16);
  if (!(_DWORD)v16)
    goto LABEL_19;
  v17 = *(_QWORD **)(v14 + 8);
  v18 = &v17[2 * v16];
  do
  {
    v19 = v16 >> 1;
    v20 = &v17[2 * (v16 >> 1)];
    v22 = *v20;
    v21 = v20 + 2;
    v16 += ~(v16 >> 1);
    if (v22 < v15)
      v17 = v21;
    else
      v16 = v19;
  }
  while (v16);
  if (v17 != v18 && *v17 == v15)
    v23 = v17[1];
  else
LABEL_19:
    v23 = 0;
  v189[0] = v13;
  v189[1] = v23;
  v24 = (uint64_t *)(*(_QWORD *)(mlir::ValueRange::dereference_iterator(&v220, 1) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v24)
    goto LABEL_29;
  v25 = *v24;
  v26 = mlir::TypeID::get<mlir::ShapedType>();
  v27 = *(unsigned int *)(v25 + 16);
  if (!(_DWORD)v27)
    goto LABEL_29;
  v28 = *(_QWORD **)(v25 + 8);
  v29 = &v28[2 * v27];
  do
  {
    v30 = v27 >> 1;
    v31 = &v28[2 * (v27 >> 1)];
    v33 = *v31;
    v32 = v31 + 2;
    v27 += ~(v27 >> 1);
    if (v33 < v26)
      v28 = v32;
    else
      v27 = v30;
  }
  while (v27);
  if (v28 != v29 && *v28 == v26)
    v34 = v28[1];
  else
LABEL_29:
    v34 = 0;
  v188[0] = v24;
  v188[1] = v34;
  v35 = (_QWORD *)(*(_QWORD *)(mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v190) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v35)
    goto LABEL_39;
  v36 = *v35;
  v37 = mlir::TypeID::get<mlir::ShapedType>();
  v38 = *(unsigned int *)(v36 + 16);
  if (!(_DWORD)v38)
    goto LABEL_39;
  v39 = *(_QWORD **)(v36 + 8);
  v40 = &v39[2 * v38];
  do
  {
    v41 = v38 >> 1;
    v42 = &v39[2 * (v38 >> 1)];
    v44 = *v42;
    v43 = v42 + 2;
    v38 += ~(v38 >> 1);
    if (v44 < v37)
      v39 = v43;
    else
      v38 = v41;
  }
  while (v38);
  if (v39 != v40 && *v39 == v37)
    v45 = v39[1];
  else
LABEL_39:
    v45 = 0;
  v186 = v35;
  v187 = v45;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v189);
  v184 = v46;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v188);
  v48 = v47;
  if (v47 == 1 || (mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::getAxis(a3) & 0xFF00000000) == 0)
    v49 = 1;
  else
    v49 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v188)
                    + 8 * (v48 - 1));
  if ((mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::getAxis(a3) & 0xFF00000000) == 0)
  {
    v52 = v48 - 1;
    goto LABEL_52;
  }
  if (v48 >= 3)
  {
    v52 = v48 - 2;
LABEL_52:
    ArgAttrsAttr = (uint64_t *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v188) + 8 * v52);
    goto LABEL_54;
  }
  ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v188);
LABEL_54:
  v54 = *ArgAttrsAttr;
  if (mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::getAxisAttr(a3))
  {
    Axis = mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::getAxis(a3);
    PositiveAxis = mlir::getPositiveAxis(Axis, v184);
  }
  else
  {
    PositiveAxis = v184 - 1;
  }
  v179 = PositiveAxis;
  v57 = ~PositiveAxis;
  v58 = mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::getAxis(a3);
  v59 = -2;
  if ((v58 & 0xFF00000000) == 0)
    v59 = -1;
  v181 = v59;
  v60 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v189);
  NumElements = mlir::ShapedType::getNumElements(v60, v61);
  v215 = v217;
  v216 = 0xC00000000;
  v63 = v184;
  if (NumElements)
  {
    v64 = NumElements;
    if (NumElements < 0xD)
    {
      v65 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v217, NumElements, 4);
      v63 = v184;
      v65 = v216;
    }
    if (v64 != v65)
    {
      bzero(&v215[4 * v65], 4 * (v64 - v65));
      v63 = v184;
    }
    LODWORD(v216) = v64;
  }
  v183 = v63 + v57;
  v66 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v189);
  v68 = mlir::ShapedType::getNumElements(v66, v67) * v49;
  v212 = v214;
  v213 = 0xC00000000;
  if (v68)
  {
    if (v68 < 0xD)
    {
      v69 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v212, v214, v68, 4);
      v69 = v213;
    }
    if (v68 != v69)
      bzero((char *)v212 + 4 * v69, 4 * (v68 - v69));
    LODWORD(v213) = v68;
  }
  mlir::getIntValues<int>((uint64_t)v10, v11, (uint64_t)&v215, 1);
  v209 = v211;
  v210 = 0x600000000;
  v70 = v184;
  v180 = a4;
  if (v184)
  {
    if (v184 < 7)
    {
      v71 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v209, v211, v184, 8);
      v70 = v184;
      v71 = v210;
    }
    if (v70 != v71)
    {
      bzero((char *)v209 + 8 * v71, 8 * (v70 - v71));
      v70 = v184;
    }
    LODWORD(v210) = v70;
    v206 = v208;
    v207 = 0x600000000;
    if (v70 < 7)
    {
      v72 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v206, v208, v70, 8);
      v70 = v184;
      v72 = v207;
    }
    if (v70 != v72)
    {
      bzero((char *)v206 + 8 * v72, 8 * (v70 - v72));
      v70 = v184;
    }
    LODWORD(v207) = v70;
    v203 = v205;
    v204 = 0x600000000;
    if (v70 < 7)
    {
      v73 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v203, v205, v70, 8);
      v70 = v184;
      v73 = v204;
    }
    if (v70 != v73)
    {
      bzero((char *)v203 + 8 * v73, 8 * (v70 - v73));
      v70 = v184;
    }
    LODWORD(v204) = v70;
    v200 = v202;
    v201 = 0x600000000;
    if (v70 < 7)
    {
      v74 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v200, v202, v70, 8);
      v70 = v184;
      v74 = v201;
    }
    if (v70 != v74)
    {
      bzero((char *)v200 + 8 * v74, 8 * (v70 - v74));
      v70 = v184;
    }
    LODWORD(v201) = v70;
    v197 = v199;
    v198 = 0x600000000;
    if (v70 < 7)
    {
      v75 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v197, v199, v70, 8);
      v70 = v184;
      v75 = v198;
    }
    if (v70 != v75)
    {
      bzero((char *)v197 + 8 * v75, 8 * (v70 - v75));
      v70 = v184;
    }
    LODWORD(v198) = v70;
    v194 = v196;
    v195 = 0x600000000;
    if (v70 < 7)
    {
      v76 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v194, v196, v70, 8);
      v70 = v184;
      v76 = v195;
    }
    if (v70 != v76)
    {
      bzero((char *)v194 + 8 * v76, 8 * (v70 - v76));
      v70 = v184;
    }
    LODWORD(v195) = v70;
    v191 = v193;
    v192 = 0x600000000;
    if (v70 < 7)
    {
      v77 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v191, v193, v70, 8);
      v70 = v184;
      v77 = v192;
    }
    if (v70 != v77)
    {
      bzero((char *)v191 + 8 * v77, 8 * (v70 - v77));
      v70 = v184;
    }
    LODWORD(v192) = v70;
    v182 = (uint64_t)v70 > 0;
    if ((uint64_t)v70 >= 1)
    {
      v78 = 0;
      v79 = v181 + v48;
      v80 = v54 * v49;
      v81 = -1;
      v82 = 1;
      v83 = 1;
      v178 = v80;
      do
      {
        v85 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v189)
                        + 8 * (v70 + v81));
        v86 = v209;
        v87 = 8 * v78;
        *(_QWORD *)((char *)v209 + v87) = v85;
        *(_QWORD *)((char *)v203 + v87) = v82;
        *(_QWORD *)((char *)v200 + v87) = v83;
        v88 = v86[v78];
        if (v183 == v78)
          v89 = v49;
        else
          v89 = 1;
        if (v78 < v79)
          v84 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v188)
                          + 8 * (v79 + v81));
        else
          v84 = 1;
        v82 *= v88;
        v83 *= v89 * v88;
        *((_QWORD *)v197 + v78) = v84;
        *((_QWORD *)v194 + v78) = v80;
        v80 *= v84;
        ++v78;
        --v81;
        v70 = v184;
      }
      while (v184 != v78);
      v90 = v183;
      v92 = *((_QWORD *)v200 + v183);
      v91 = v80 > v178;
      if (v80 <= v178)
        goto LABEL_126;
      v93 = (char *)v209;
      v94 = (char *)v197;
      v95 = (char *)v191;
      if (v184 >= 4)
      {
        v96 = 0;
        if ((unint64_t)((_BYTE *)v191 - (_BYTE *)v209) >= 0x20
          && (unint64_t)((_BYTE *)v191 - (_BYTE *)v197) >= 0x20)
        {
          v96 = v184 & 0xFFFFFFFFFFFFFFFCLL;
          v173 = (int64x2_t *)((char *)v209 + 16);
          v174 = (int64x2_t *)((char *)v197 + 16);
          v175 = (int64x2_t *)((char *)v191 + 16);
          v176 = v184 & 0xFFFFFFFFFFFFFFFCLL;
          do
          {
            v177 = vcvtq_s64_f64(vrndpq_f64(vdivq_f64(vcvtq_f64_s64(*v173), vcvtq_f64_s64(*v174))));
            v175[-1] = vcvtq_s64_f64(vrndpq_f64(vdivq_f64(vcvtq_f64_s64(v173[-1]), vcvtq_f64_s64(v174[-1]))));
            *v175 = v177;
            v173 += 2;
            v174 += 2;
            v175 += 2;
            v176 -= 4;
          }
          while (v176);
          if (v184 == v96)
            goto LABEL_125;
        }
      }
      else
      {
        v96 = 0;
      }
      v97 = v184 - v96;
      v98 = 8 * v96;
      v99 = (uint64_t *)&v93[v98];
      v100 = (uint64_t *)&v94[v98];
      v101 = &v95[v98];
      do
      {
        v102 = *v99++;
        v103 = (double)v102;
        v104 = *v100++;
        *(_QWORD *)v101 = vcvtpd_s64_f64(v103 / (double)v104);
        v101 += 8;
        --v97;
      }
      while (v97);
LABEL_125:
      v91 = 1;
      goto LABEL_126;
    }
  }
  else
  {
    v206 = v208;
    v207 = 0x600000000;
    v203 = v205;
    v204 = 0x600000000;
    v200 = v202;
    v201 = 0x600000000;
    v197 = v199;
    v198 = 0x600000000;
    v194 = v196;
    v195 = 0x600000000;
    v191 = v193;
    v192 = 0x600000000;
  }
  v90 = v183;
  v91 = 0;
  v182 = 0;
  v92 = *((_QWORD *)v200 + v183);
LABEL_126:
  if ((_DWORD)v216)
  {
    v105 = 0;
    v106 = v91 && v182;
    v107 = v70 & 0xFFFFFFFFFFFFFFFELL;
    v109 = (unint64_t)v49 > 0xB && v92 == 1;
    while (1)
    {
      if (!v70)
      {
        v113 = 0;
        goto LABEL_153;
      }
      if (v70 == 1)
        break;
      v114 = 0;
      v115 = 0;
      v116 = 0;
      v117 = (char *)v206 + 8;
      v118 = (char *)v200 + 8;
      v119 = v90;
      do
      {
        if (v119)
          v120 = 1;
        else
          v120 = v49;
        if ((v114 | 1) == v90)
          v121 = v49;
        else
          v121 = 1;
        v115 += *(v117 - 1) * v120 * *(v118 - 1);
        v116 += *v117 * v121 * *v118;
        v114 += 2;
        v117 += 2;
        v118 += 2;
        v119 -= 2;
      }
      while (v114 != v107);
      v113 = v116 + v115;
      v112 = v107;
      if (v70 != v107)
        goto LABEL_148;
LABEL_153:
      if (!v106)
      {
        v131 = 0;
        goto LABEL_162;
      }
      if (v70 < 2)
      {
        v130 = 0;
        v131 = 0;
LABEL_160:
        v138 = (uint64_t *)((char *)v194 + 8 * v130);
        v139 = (uint64_t *)((char *)v191 + 8 * v130);
        v140 = (uint64_t *)((char *)v206 + 8 * v130);
        v141 = v70 - v130;
        do
        {
          v143 = *v140++;
          v142 = v143;
          v144 = *v139++;
          v145 = v142 / v144;
          v146 = *v138++;
          v131 += v146 * v145;
          --v141;
        }
        while (v141);
        goto LABEL_162;
      }
      v132 = 0;
      v133 = 0;
      v134 = (uint64_t *)((char *)v191 + 8);
      v135 = (char *)v194 + 8;
      v136 = (char *)v206 + 8;
      v137 = v107;
      do
      {
        v132 += *(v135 - 1) * (*(v136 - 1) / *(v134 - 1));
        v133 += *v135 * (*v136 / *v134);
        v134 += 2;
        v135 += 2;
        v136 += 2;
        v137 -= 2;
      }
      while (v137);
      v131 = v133 + v132;
      v130 = v107;
      if (v70 != v107)
        goto LABEL_160;
LABEL_162:
      if (v49 >= 1)
      {
        v147 = v49 * *(int *)&v215[4 * v105];
        v148 = (char *)v218[0];
        v149 = (char *)v212;
        if (v109
          && (v150 = 4 * (v131 + v147), (unint64_t)((_BYTE *)v212 + 4 * v113 - (char *)v218[0] - v150) >= 0x20))
        {
          v159 = (char *)v212 + 4 * v113 + 16;
          v160 = (__int128 *)((char *)v218[0] + v150 + 16);
          v161 = v49 & 0xFFFFFFFFFFFFFFF8;
          do
          {
            v162 = *v160;
            *(v159 - 1) = *(v160 - 1);
            *v159 = v162;
            v159 += 2;
            v160 += 2;
            v161 -= 8;
          }
          while (v161);
          v151 = v49 & 0xFFFFFFFFFFFFFFF8;
          if (v49 == (v49 & 0xFFFFFFFFFFFFFFF8))
            goto LABEL_168;
        }
        else
        {
          v151 = 0;
        }
        v152 = v49 - v151;
        v153 = &v149[4 * v113 + 4 * v92 * v151];
        v154 = &v148[4 * v151 + 4 * v131 + 4 * v147];
        do
        {
          v155 = *(_DWORD *)v154;
          v154 += 4;
          *(_DWORD *)v153 = v155;
          v153 += 4 * v92;
          --v152;
        }
        while (v152);
      }
LABEL_168:
      if (v182)
      {
        v110 = 0;
        v156 = v206;
        v157 = v209;
        while (1)
        {
          v158 = v156[v110] + 1;
          if (v158 < v157[v110])
            break;
          v156[v110++] = 0;
          if (v70 == v110)
          {
            v110 = v70;
            goto LABEL_134;
          }
        }
        v156[v110] = v158;
      }
      else
      {
        v110 = 0;
      }
LABEL_134:
      ++v105;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v189);
      v90 = v183;
      v70 = v184;
      if (v111 == v110)
        goto LABEL_178;
    }
    v112 = 0;
    v113 = 0;
LABEL_148:
    v122 = v70 - v112;
    v123 = 8 * v112;
    v124 = (uint64_t *)((char *)v206 + v123);
    v125 = (uint64_t *)((char *)v200 + v123);
    do
    {
      v127 = *v124++;
      v126 = v127;
      if (v179 + 1 == v122)
        v128 = v49;
      else
        v128 = 1;
      v129 = *v125++;
      v113 += v126 * v128 * v129;
      --v122;
    }
    while (v122);
    goto LABEL_153;
  }
LABEL_178:
  v163 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v186);
  v165 = (uint64_t)v164;
  F32Type = mlir::Builder::getF32Type(v180 + 1, v164);
  v167 = (_QWORD *)mlir::RankedTensorType::get(v163, v165, F32Type, 0);
  RawElementsAttr = mlir::createRawElementsAttr(v167, v212, (const void *)(4 * v213));
  v185[0] = mlir::rewriteElementsAttr((uint64_t)RawElementsAttr, v169, (uint64_t)v186, v187, 0);
  v185[1] = v170;
  v171 = v190;
  v172 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ElementsAttr &>((mlir::OpBuilder *)(v180 + 1), *(_QWORD *)(v190 + 24), (uint64_t)v185);
  (*((void (**)(mlir::Float32Type **, uint64_t, mlir::GenericProgramPoint *))*v180 + 4))(v180, v171, v172);
  if (v191 != v193)
    free(v191);
  if (v194 != v196)
    free(v194);
  if (v197 != v199)
    free(v197);
  if (v200 != v202)
    free(v200);
  if (v203 != v205)
    free(v203);
  if (v206 != v208)
    free(v206);
  if (v209 != v211)
    free(v209);
  if (v212 != v214)
    free(v212);
  if (v215 != v217)
    free(v215);
  v50 = 1;
LABEL_44:
  if (v218[0] != v219)
    free(v218[0]);
  return v50;
}

void mlir::getIntValues<int>(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unint64_t NumElements;
  unint64_t v7;
  int32x2_t *v8;
  _QWORD *Type;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  unsigned __int8 *ElementsAttrRawData;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t i;
  uint64_t v27;
  uint64_t j;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  int v34;
  int32x2_t *v35;
  unint64_t v36;
  uint64_t k;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  int v42;
  int32x2_t *v43;
  uint64_t m;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  uint64_t v51;
  int32x2_t *v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int32x2_t *v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  int v70;
  int *v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  int v77;
  int32x2_t *v78;
  int32x2_t v79;
  unint64_t v80;
  unint64_t v81;
  _QWORD *v82;
  uint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  int v87;
  int32x2_t *v88;
  unsigned int IntOrFloatBitWidth;
  uint64_t v90;
  int v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unsigned int v96;
  unint64_t v97;
  uint64x2_t v98;
  int32x2_t v99;
  uint64_t v100;
  int32x2_t v101;
  int32x2_t v102;
  int32x2_t v103;
  uint64_t v104;
  int32x2_t *v105;
  uint64_t v106;
  uint64_t v107;
  BOOL *v108;
  uint64_t v109;
  uint64_t v110;
  unsigned int v111;
  uint64x2_t v112;
  int32x2_t v113;
  uint64_t v114;
  int32x2_t v115;
  int32x2_t v116;
  int32x2_t v117;
  unint64_t v118;
  unint64_t v119;
  unint64_t v120;
  unint64_t v121;
  int v122;
  int32x2_t *v123;
  unint64_t v124;
  unint64_t v125;
  unint64_t v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  unint64_t v134;
  int32x2_t *v135;
  __int128 v136;
  uint64_t OperandRange;
  _QWORD v138[2];
  __int128 v139;
  _QWORD *v140;
  __int128 v141;
  _QWORD v142[6];

  v142[5] = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v136 = a1;
  *((_QWORD *)&v136 + 1) = a2;
  if (!mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v136) || a4)
    NumElements = mlir::ElementsAttr::getNumElements(v136, *((uint64_t *)&v136 + 1));
  else
    NumElements = 1;
  v7 = *(unsigned int *)(a3 + 8);
  if (NumElements != v7)
  {
    if (NumElements >= v7)
    {
      if (NumElements > *(unsigned int *)(a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), NumElements, 4);
        v7 = *(unsigned int *)(a3 + 8);
      }
      if (NumElements != v7)
        bzero((void *)(*(_QWORD *)a3 + 4 * v7), 4 * (NumElements - v7));
    }
    *(_DWORD *)(a3 + 8) = NumElements;
  }
  v8 = *(int32x2_t **)a3;
  v139 = v136;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v139);
  v10 = Type;
  if (!Type)
    goto LABEL_21;
  v11 = *Type;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_21;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_21:
    v20 = 0;
  v138[0] = v10;
  v138[1] = v20;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v138);
  v21 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v139);
  ElementsAttrRawData = (unsigned __int8 *)mlir::getElementsAttrRawData(v139);
  v24 = v23;
  if (!v21 || a4)
  {
    v25 = mlir::ElementsAttr::getNumElements(v139, *((uint64_t *)&v139 + 1));
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
    {
      if (v25 < 1)
        return;
      goto LABEL_28;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
    {
      if (v25 < 1)
        return;
      goto LABEL_39;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
    {
      if (v25 < 1)
        return;
      if ((unint64_t)v25 >= 2)
      {
        v31 = 0;
        v30 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21)
            v32 = 0;
          else
            v32 = v31;
          if (v21)
            v33 = 0;
          else
            v33 = v31 + 1;
          v34 = *(unsigned __int16 *)&ElementsAttrRawData[2 * v33];
          v35 = &v8[v31 / 2];
          v35->i32[0] = *(unsigned __int16 *)&ElementsAttrRawData[2 * v32];
          v35->i32[1] = v34;
          v31 += 2;
        }
        while (v31 != v30);
        goto LABEL_282;
      }
      goto LABEL_48;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
    {
      if (v25 < 1)
        return;
      goto LABEL_66;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      if (v25 < 1)
        return;
      goto LABEL_73;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
    {
      if (v25 < 1)
        return;
      goto LABEL_93;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      if (v25 < 1)
        return;
      goto LABEL_104;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
    {
      if (v25 < 1)
        return;
      goto LABEL_111;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
    {
      if (v25 < 1)
        return;
      goto LABEL_127;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      if (v25 < 1)
        return;
      goto LABEL_143;
    }
    if (mlir::Type::isF64((mlir::Type *)&OperandRange))
    {
      if (v25 < 1)
        return;
      goto LABEL_159;
    }
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      if (v25 < 1)
        return;
LABEL_174:
      if ((unint64_t)v25 >= 2)
      {
        v104 = 0;
        v80 = v25 & 0xFFFFFFFFFFFFFFFELL;
        v105 = v8;
        do
        {
          if (v21)
            v106 = 0;
          else
            v106 = v104;
          if (v21)
            v107 = 0;
          else
            v107 = v104 + 1;
          v79.i16[0] = *(_WORD *)&ElementsAttrRawData[2 * v106];
          v79.i16[2] = *(_WORD *)&ElementsAttrRawData[2 * v107];
          v79 = vcvt_s32_f32((float32x2_t)vshl_n_s32(v79, 0x10uLL));
          *v105++ = v79;
          v104 += 2;
        }
        while (v104 != v80);
        goto LABEL_324;
      }
      v80 = 0;
      do
      {
        if (v21)
          v133 = 0;
        else
          v133 = v80;
        v8->i32[v80++] = (int)COERCE_FLOAT(*(unsigned __int16 *)&ElementsAttrRawData[2 * v133] << 16);
LABEL_324:
        ;
      }
      while (v25 != v80);
      return;
    }
  }
  else
  {
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
    {
      v25 = 1;
LABEL_28:
      for (i = 0; i != v25; ++i)
      {
        if (v21)
          v27 = 0;
        else
          v27 = i;
        v8->i32[i] = ElementsAttrRawData[v27];
      }
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 8))
    {
      v25 = 1;
LABEL_39:
      for (j = 0; j != v25; ++j)
      {
        if (v21)
          v29 = 0;
        else
          v29 = j;
        v8->i32[j] = (char)ElementsAttrRawData[v29];
      }
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
    {
      v25 = 1;
LABEL_48:
      v30 = 0;
      do
      {
        if (v21)
          v124 = 0;
        else
          v124 = v30;
        v8->i32[v30++] = *(unsigned __int16 *)&ElementsAttrRawData[2 * v124];
LABEL_282:
        ;
      }
      while (v25 != v30);
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 16))
    {
      v25 = 1;
LABEL_66:
      if ((unint64_t)v25 >= 2)
      {
        v39 = 0;
        v36 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21)
            v40 = 0;
          else
            v40 = v39;
          if (v21)
            v41 = 0;
          else
            v41 = v39 + 1;
          v42 = *(__int16 *)&ElementsAttrRawData[2 * v41];
          v43 = &v8[v39 / 2];
          v43->i32[0] = *(__int16 *)&ElementsAttrRawData[2 * v40];
          v43->i32[1] = v42;
          v39 += 2;
        }
        while (v39 != v36);
        goto LABEL_288;
      }
      v36 = 0;
      do
      {
        if (v21)
          v125 = 0;
        else
          v125 = v36;
        v8->i32[v36++] = *(__int16 *)&ElementsAttrRawData[2 * v125];
LABEL_288:
        ;
      }
      while (v25 != v36);
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      v25 = 1;
LABEL_73:
      for (k = 0; k != v25; ++k)
      {
        if (v21)
          v38 = 0;
        else
          v38 = k;
        v8->i32[k] = *(_DWORD *)&ElementsAttrRawData[4 * v38];
      }
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 32))
    {
      v25 = 1;
LABEL_93:
      for (m = 0; m != v25; ++m)
      {
        if (v21)
          v45 = 0;
        else
          v45 = m;
        v8->i32[m] = *(_DWORD *)&ElementsAttrRawData[4 * v45];
      }
      return;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      v25 = 1;
LABEL_104:
      if ((unint64_t)v25 >= 2)
      {
        v48 = 0;
        v46 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21)
            v49 = 0;
          else
            v49 = v48;
          if (v21)
            v50 = 0;
          else
            v50 = v48 + 1;
          v51 = *(_QWORD *)&ElementsAttrRawData[8 * v50];
          v52 = &v8[v48 / 2];
          v52->i32[0] = *(_QWORD *)&ElementsAttrRawData[8 * v49];
          v52->i32[1] = v51;
          v48 += 2;
        }
        while (v48 != v46);
        goto LABEL_294;
      }
      v46 = 0;
      do
      {
        if (v21)
          v126 = 0;
        else
          v126 = v46;
        v8->i32[v46++] = *(_QWORD *)&ElementsAttrRawData[8 * v126];
LABEL_294:
        ;
      }
      while (v25 != v46);
      return;
    }
    if (mlir::Type::isInteger((mlir::Type *)&OperandRange, 64))
    {
      v25 = 1;
LABEL_111:
      if ((unint64_t)v25 >= 2)
      {
        v54 = 0;
        v47 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21)
            v55 = 0;
          else
            v55 = v54;
          if (v21)
            v56 = 0;
          else
            v56 = v54 + 1;
          v57 = *(_QWORD *)&ElementsAttrRawData[8 * v56];
          v58 = &v8[v54 / 2];
          v58->i32[0] = *(_QWORD *)&ElementsAttrRawData[8 * v55];
          v58->i32[1] = v57;
          v54 += 2;
        }
        while (v54 != v47);
        goto LABEL_300;
      }
      v47 = 0;
      do
      {
        if (v21)
          v127 = 0;
        else
          v127 = v47;
        v8->i32[v47++] = *(_QWORD *)&ElementsAttrRawData[8 * v127];
LABEL_300:
        ;
      }
      while (v25 != v47);
      return;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
    {
      v25 = 1;
LABEL_127:
      if ((unint64_t)v25 >= 2)
      {
        v60 = 0;
        v53 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21)
            v61 = 0;
          else
            v61 = v60;
          if (v21)
            v62 = 0;
          else
            v62 = v60 + 1;
          _H0 = *(_WORD *)&ElementsAttrRawData[2 * v61];
          _H1 = *(_WORD *)&ElementsAttrRawData[2 * v62];
          __asm { FCVT            S0, H0 }
          v70 = (int)_S0;
          __asm { FCVT            S0, H1 }
          v72 = (int *)&v8[v60 / 2];
          *v72 = v70;
          v72[1] = (int)_S0;
          v60 += 2;
        }
        while (v60 != v53);
        goto LABEL_306;
      }
      v53 = 0;
      do
      {
        if (v21)
          v128 = 0;
        else
          v128 = v53;
        _H0 = *(_WORD *)&ElementsAttrRawData[2 * v128];
        __asm { FCVT            S0, H0 }
        v8->i32[v53++] = (int)_S0;
LABEL_306:
        ;
      }
      while (v25 != v53);
      return;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
    {
      v25 = 1;
LABEL_143:
      if ((unint64_t)v25 >= 2)
      {
        v74 = 0;
        v59 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21)
            v75 = 0;
          else
            v75 = v74;
          if (v21)
            v76 = 0;
          else
            v76 = v74 + 1;
          v77 = (int)*(float *)&ElementsAttrRawData[4 * v76];
          v78 = &v8[v74 / 2];
          v78->i32[0] = (int)*(float *)&ElementsAttrRawData[4 * v75];
          v78->i32[1] = v77;
          v74 += 2;
        }
        while (v74 != v59);
        goto LABEL_312;
      }
      v59 = 0;
      do
      {
        if (v21)
          v131 = 0;
        else
          v131 = v59;
        v8->i32[v59++] = (int)*(float *)&ElementsAttrRawData[4 * v131];
LABEL_312:
        ;
      }
      while (v25 != v59);
      return;
    }
    if (mlir::Type::isF64((mlir::Type *)&OperandRange))
    {
      v25 = 1;
LABEL_159:
      if ((unint64_t)v25 >= 2)
      {
        v84 = 0;
        v73 = v25 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          if (v21)
            v85 = 0;
          else
            v85 = v84;
          if (v21)
            v86 = 0;
          else
            v86 = v84 + 1;
          v87 = (int)*(double *)&ElementsAttrRawData[8 * v86];
          v88 = &v8[v84 / 2];
          v88->i32[0] = (int)*(double *)&ElementsAttrRawData[8 * v85];
          v88->i32[1] = v87;
          v84 += 2;
        }
        while (v84 != v73);
        goto LABEL_318;
      }
      v73 = 0;
      do
      {
        if (v21)
          v132 = 0;
        else
          v132 = v73;
        v8->i32[v73++] = (int)*(double *)&ElementsAttrRawData[8 * v132];
LABEL_318:
        ;
      }
      while (v25 != v73);
      return;
    }
    v25 = 1;
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange))
      goto LABEL_174;
  }
  if (!mlir::Type::isInteger((mlir::Type *)&OperandRange, 1))
  {
    mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
    IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
    if (!v24)
      return;
    v90 = 0;
    v91 = ~(-1 << IntOrFloatBitWidth);
    v92 = v25;
    v93 = 8 / IntOrFloatBitWidth;
    while (1)
    {
      v94 = v90 * v93;
      v95 = v25 - v90 * v93;
      if (v95 >= v93)
        v95 = 8 / IntOrFloatBitWidth;
      if (!v95)
        goto LABEL_194;
      v96 = *ElementsAttrRawData;
      if (v92 >= v93)
        v97 = 8 / IntOrFloatBitWidth;
      else
        v97 = v92;
      v98 = (uint64x2_t)vdupq_n_s64(v97 - 1);
      v99 = vmovn_s64((int64x2_t)vcgeq_u64(v98, (uint64x2_t)xmmword_181233120));
      if ((v99.i8[0] & 1) != 0)
        v8->i32[v94] = v91 & v96;
      if ((v99.i8[4] & 1) != 0)
        v8->i32[v94 + 1] = (v96 >> IntOrFloatBitWidth) & v91;
      v100 = ((_BYTE)v97 + 1) & 0x1E;
      if (v100 == 2)
        goto LABEL_194;
      v101 = vmovn_s64((int64x2_t)vcgtq_u64(v98, (uint64x2_t)xmmword_181233160));
      if ((v101.i8[0] & 1) != 0)
      {
        v8[1].i32[v94] = (v96 >> (2 * IntOrFloatBitWidth)) & v91;
        if ((v101.i8[4] & 1) != 0)
          goto LABEL_211;
      }
      else if ((v101.i8[4] & 1) != 0)
      {
LABEL_211:
        v8[1].i32[v94 + 1] = (v96 >> (3 * IntOrFloatBitWidth)) & v91;
        if (v100 == 4)
          goto LABEL_194;
        goto LABEL_212;
      }
      if (v100 == 4)
        goto LABEL_194;
LABEL_212:
      v102 = vmovn_s64((int64x2_t)vcgtq_u64(v98, (uint64x2_t)xmmword_181233170));
      if ((v102.i8[0] & 1) != 0)
      {
        v8[2].i32[v94] = (v96 >> (4 * IntOrFloatBitWidth)) & v91;
        if ((v102.i8[4] & 1) == 0)
          goto LABEL_214;
      }
      else if ((v102.i8[4] & 1) == 0)
      {
LABEL_214:
        if (v100 != 6)
          goto LABEL_218;
        goto LABEL_194;
      }
      v8[2].i32[v94 + 1] = (v96 >> (5 * IntOrFloatBitWidth)) & v91;
      if (v100 != 6)
      {
LABEL_218:
        v103 = vmovn_s64((int64x2_t)vcgtq_u64(v98, (uint64x2_t)xmmword_181233180));
        if ((v103.i8[0] & 1) != 0)
          v8[3].i32[v94] = (v96 >> (6 * IntOrFloatBitWidth)) & v91;
        if ((v103.i8[4] & 1) != 0)
          v8[3].i32[v94 + 1] = (v96 >> (7 * IntOrFloatBitWidth)) & v91;
      }
LABEL_194:
      ++v90;
      v92 -= v93;
      ++ElementsAttrRawData;
      if (!--v24)
        return;
    }
  }
  v135 = v8;
  if (v21)
    v81 = 1;
  else
    v81 = v25;
  v82 = v142;
  v140 = v142;
  v141 = xmmword_181233150;
  if (v81)
  {
    if (v81 < 0x29)
    {
      v83 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)&v140, v142, v81, 1);
      v82 = v140;
      v83 = v141;
    }
    if (v81 != v83)
      bzero((char *)v82 + v83, v81 - v83);
    *(_QWORD *)&v141 = v81;
  }
  if (v24)
  {
    v108 = (BOOL *)v82 + 3;
    do
    {
      if (v81 >= 8)
        v109 = 8;
      else
        v109 = v81;
      if (!v109)
        goto LABEL_237;
      if (v81 >= 8)
        v110 = 8;
      else
        v110 = v81;
      v111 = *ElementsAttrRawData;
      v112 = (uint64x2_t)vdupq_n_s64(v110 - 1);
      v113 = vmovn_s64((int64x2_t)vcgeq_u64(v112, (uint64x2_t)xmmword_181233120));
      if ((v113.i8[0] & 1) != 0)
        *(v108 - 3) = v111 & 1;
      if ((v113.i8[4] & 1) != 0)
        *(v108 - 2) = (v111 & 2) != 0;
      v114 = ((_BYTE)v110 + 1) & 0x1E;
      if (v114 == 2)
        goto LABEL_237;
      v115 = vmovn_s64((int64x2_t)vcgtq_u64(v112, (uint64x2_t)xmmword_181233160));
      if ((v115.i8[0] & 1) != 0)
      {
        *(v108 - 1) = (v111 & 4) != 0;
        if ((v115.i8[4] & 1) != 0)
          goto LABEL_255;
      }
      else if ((v115.i8[4] & 1) != 0)
      {
LABEL_255:
        *v108 = (v111 & 8) != 0;
        if (v114 == 4)
          goto LABEL_237;
        goto LABEL_256;
      }
      if (v114 == 4)
        goto LABEL_237;
LABEL_256:
      v116 = vmovn_s64((int64x2_t)vcgtq_u64(v112, (uint64x2_t)xmmword_181233170));
      if ((v116.i8[0] & 1) != 0)
      {
        v108[1] = (v111 & 0x10) != 0;
        if ((v116.i8[4] & 1) == 0)
          goto LABEL_258;
      }
      else if ((v116.i8[4] & 1) == 0)
      {
LABEL_258:
        if (v114 != 6)
          goto LABEL_262;
        goto LABEL_237;
      }
      v108[2] = (v111 & 0x20) != 0;
      if (v114 != 6)
      {
LABEL_262:
        v117 = vmovn_s64((int64x2_t)vcgtq_u64(v112, (uint64x2_t)xmmword_181233180));
        if ((v117.i8[0] & 1) != 0)
          v108[3] = (v111 & 0x40) != 0;
        if ((v117.i8[4] & 1) != 0)
          v108[4] = v111 >> 7;
      }
LABEL_237:
      ++ElementsAttrRawData;
      v108 += 8;
      v81 -= 8;
      --v24;
    }
    while (v24);
  }
  if (v25 >= 1)
  {
    if (v25 == 1)
    {
      v119 = 0;
      goto LABEL_326;
    }
    v118 = 0;
    v119 = v25 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      if (v21)
        v120 = 0;
      else
        v120 = v118;
      if (v21)
        v121 = 0;
      else
        v121 = v118 + 1;
      v122 = *((unsigned __int8 *)v82 + v121);
      v123 = &v135[v118 / 2];
      v123->i32[0] = *((unsigned __int8 *)v82 + v120);
      v123->i32[1] = v122;
      v118 += 2;
    }
    while (v118 != v119);
    while (v25 != v119)
    {
LABEL_326:
      if (v21)
        v134 = 0;
      else
        v134 = v119;
      v135->i32[v119++] = *((unsigned __int8 *)v82 + v134);
    }
  }
  if (v82 != v142)
    free(v82);
}

void mlir::mps::`anonymous namespace'::LowerDequantizeND::~LowerDequantizeND(mlir::mps::_anonymous_namespace_::LowerDequantizeND *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DequantizeOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DequantizeOp>::rewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[56];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::DequantizeOpGenericAdaptorBase::DequantizeOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mps::DequantizeOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[56];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mps::detail::DequantizeOpGenericAdaptorBase::DequantizeOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::`anonymous namespace'::LowerDequantizeND::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t *v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t *v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  unint64_t v44;
  unint64_t *v45;
  _QWORD *v46;
  unint64_t v47;
  uint64_t v48;
  _QWORD *ArgAttrsAttr;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  mlir::GenericProgramPoint *v61;
  uint64_t v62;
  mlir::GenericProgramPoint *v63;
  mlir::GenericProgramPoint *v64;
  uint64_t v65;
  mlir::GenericProgramPoint *v66;
  uint64_t v67;
  _QWORD *v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  _QWORD *v72;
  _QWORD *v73;
  unint64_t v74;
  unint64_t *v75;
  _QWORD *v76;
  unint64_t v77;
  uint64_t v78;
  _QWORD *v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  _QWORD *v83;
  _QWORD *v84;
  unint64_t v85;
  unint64_t *v86;
  _QWORD *v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  char *v92;
  uint64_t v93;
  uint64_t v95;
  unint64_t i;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unsigned int v101;
  unsigned int v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  char *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  _QWORD *v110;
  uint64_t v111;
  unint64_t v112;
  unint64_t v113;
  _QWORD *v114;
  _QWORD *v115;
  unint64_t v116;
  unint64_t *v117;
  _QWORD *v118;
  unint64_t v119;
  uint64_t v120;
  _QWORD *v121;
  uint64_t v122;
  unint64_t v123;
  unint64_t v124;
  _QWORD *v125;
  _QWORD *v126;
  unint64_t v127;
  unint64_t *v128;
  _QWORD *v129;
  unint64_t v130;
  uint64_t v131;
  uint64_t *v132;
  uint64_t v133;
  char *v134;
  uint64_t v135;
  unint64_t j;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unsigned int v141;
  unsigned int v142;
  uint64_t v143;
  uint64_t v144;
  unint64_t v145;
  char *v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  _QWORD *v150;
  uint64_t v151;
  unint64_t v152;
  unint64_t v153;
  _QWORD *v154;
  _QWORD *v155;
  unint64_t v156;
  unint64_t *v157;
  _QWORD *v158;
  unint64_t v159;
  uint64_t v160;
  _QWORD *v161;
  uint64_t v162;
  unint64_t v163;
  unint64_t v164;
  _QWORD *v165;
  _QWORD *v166;
  unint64_t v167;
  unint64_t *v168;
  _QWORD *v169;
  unint64_t v170;
  uint64_t v171;
  uint64_t *v172;
  uint64_t v173;
  char *v174;
  uint64_t v175;
  unint64_t k;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  unsigned int v181;
  unsigned int v182;
  uint64_t v183;
  uint64_t v184;
  unint64_t v185;
  char *v186;
  uint64_t v187;
  uint64_t v188;
  unsigned int *v189;
  mlir::GenericProgramPoint *v190;
  _QWORD v191[2];
  _QWORD v192[2];
  _QWORD v193[2];
  _QWORD v194[2];
  uint64_t FunctionType;
  uint64_t SparseShape;
  uint64_t Bias;
  uint64_t Filter;
  uint64_t Input;
  uint64_t v200;
  char *v201;
  char *v202;
  uint64_t *v203;
  uint64_t *v204;
  _QWORD *v205;
  uint64_t v206;
  _QWORD *v207;
  uint64_t v208;
  uint64_t v209;
  char *v210;
  uint64_t v211;
  unint64_t v212[2];
  _QWORD *v213;
  uint64_t v214;
  _BYTE v215[48];
  char *v216;
  uint64_t v217;
  _QWORD v218[8];

  v218[6] = *MEMORY[0x1E0C80C00];
  v200 = a2;
  if (!mlir::mps::DequantizeOp::hasNDParams((mlir::mps::DequantizeOp *)&v200))
    return 0;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v200);
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v200);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v200);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v200);
  FunctionType = mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v200);
  v5 = (uint64_t *)(*(_QWORD *)(Input + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5)
    goto LABEL_11;
  v6 = *v5;
  v7 = mlir::TypeID::get<mlir::ShapedType>();
  v8 = *(unsigned int *)(v6 + 16);
  if (!(_DWORD)v8)
    goto LABEL_11;
  v9 = *(_QWORD **)(v6 + 8);
  v10 = &v9[2 * v8];
  do
  {
    v11 = v8 >> 1;
    v12 = &v9[2 * (v8 >> 1)];
    v14 = *v12;
    v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7)
      v9 = v13;
    else
      v8 = v11;
  }
  while (v8);
  if (v9 != v10 && *v9 == v7)
    v15 = v9[1];
  else
LABEL_11:
    v15 = 0;
  v194[0] = v5;
  v194[1] = v15;
  v16 = (uint64_t *)(*(_QWORD *)(Filter + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16)
    goto LABEL_21;
  v17 = *v16;
  v18 = mlir::TypeID::get<mlir::ShapedType>();
  v19 = *(unsigned int *)(v17 + 16);
  if (!(_DWORD)v19)
    goto LABEL_21;
  v20 = *(_QWORD **)(v17 + 8);
  v21 = &v20[2 * v19];
  do
  {
    v22 = v19 >> 1;
    v23 = &v20[2 * (v19 >> 1)];
    v25 = *v23;
    v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18)
      v20 = v24;
    else
      v19 = v22;
  }
  while (v19);
  if (v20 != v21 && *v20 == v18)
    v26 = v20[1];
  else
LABEL_21:
    v26 = 0;
  v193[0] = v16;
  v193[1] = v26;
  v27 = (uint64_t *)(*(_QWORD *)(Bias + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v27)
    goto LABEL_31;
  v28 = *v27;
  v29 = mlir::TypeID::get<mlir::ShapedType>();
  v30 = *(unsigned int *)(v28 + 16);
  if (!(_DWORD)v30)
    goto LABEL_31;
  v31 = *(_QWORD **)(v28 + 8);
  v32 = &v31[2 * v30];
  do
  {
    v33 = v30 >> 1;
    v34 = &v31[2 * (v30 >> 1)];
    v36 = *v34;
    v35 = v34 + 2;
    v30 += ~(v30 >> 1);
    if (v36 < v29)
      v31 = v35;
    else
      v30 = v33;
  }
  while (v30);
  if (v31 != v32 && *v31 == v29)
    v37 = v31[1];
  else
LABEL_31:
    v37 = 0;
  v192[0] = v27;
  v192[1] = v37;
  v38 = (uint64_t *)(*(_QWORD *)(SparseShape + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v38)
    goto LABEL_41;
  v39 = *v38;
  v40 = mlir::TypeID::get<mlir::ShapedType>();
  v41 = *(unsigned int *)(v39 + 16);
  if (!(_DWORD)v41)
    goto LABEL_41;
  v42 = *(_QWORD **)(v39 + 8);
  v43 = &v42[2 * v41];
  do
  {
    v44 = v41 >> 1;
    v45 = &v42[2 * (v41 >> 1)];
    v47 = *v45;
    v46 = v45 + 2;
    v41 += ~(v41 >> 1);
    if (v47 < v40)
      v42 = v46;
    else
      v41 = v44;
  }
  while (v41);
  if (v42 != v43 && *v42 == v40)
    v48 = v42[1];
  else
LABEL_41:
    v48 = 0;
  v191[0] = v38;
  v191[1] = v48;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v194))
    return 0;
  ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v194);
  if (v50)
  {
    v51 = 8 * v50;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v51 -= 8;
      if (!v51)
        goto LABEL_47;
    }
    return 0;
  }
LABEL_47:
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v193))
    return 0;
  v52 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v193);
  if (v53)
  {
    v54 = 8 * v53;
    while (*v52 != 0x8000000000000000)
    {
      ++v52;
      v54 -= 8;
      if (!v54)
        goto LABEL_52;
    }
    return 0;
  }
LABEL_52:
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v192))
    return 0;
  v55 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v192);
  if (v56)
  {
    v57 = 8 * v56;
    while (*v55 != 0x8000000000000000)
    {
      ++v55;
      v57 -= 8;
      if (!v57)
        goto LABEL_57;
    }
    return 0;
  }
LABEL_57:
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v191))
    return 0;
  v58 = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v191);
  if (v59)
  {
    v60 = 8 * v59;
    while (*v58 != 0x8000000000000000)
    {
      ++v58;
      v60 -= 8;
      if (!v60)
        goto LABEL_62;
    }
    return 0;
  }
LABEL_62:
  v61 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), *(_QWORD *)(v200 + 24), &Input, &FunctionType);
  v62 = (uint64_t)v61 - 16;
  v63 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), *(_QWORD *)(v200 + 24), &Filter, &FunctionType);
  v64 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), *(_QWORD *)(v200 + 24), &Bias, &FunctionType);
  v65 = (uint64_t)v64 - 16;
  v66 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>((mlir::UnknownLoc **)(a4 + 8), *(_QWORD *)(v200 + 24), &SparseShape, &FunctionType);
  v67 = *(_QWORD *)(v200 + 24);
  v210 = (char *)v61 - 16;
  v211 = v67;
  v209 = (uint64_t)v64 - 16;
  v68 = (_QWORD *)(*((_QWORD *)v61 - 1) & 0xFFFFFFFFFFFFFFF8);
  if (!v68)
    goto LABEL_71;
  v69 = *v68;
  v70 = mlir::TypeID::get<mlir::ShapedType>();
  v71 = *(unsigned int *)(v69 + 16);
  if (!(_DWORD)v71)
    goto LABEL_71;
  v72 = *(_QWORD **)(v69 + 8);
  v73 = &v72[2 * v71];
  do
  {
    v74 = v71 >> 1;
    v75 = &v72[2 * (v71 >> 1)];
    v77 = *v75;
    v76 = v75 + 2;
    v71 += ~(v71 >> 1);
    if (v77 < v70)
      v72 = v76;
    else
      v71 = v74;
  }
  while (v71);
  if (v72 != v73 && *v72 == v70)
    v78 = v72[1];
  else
LABEL_71:
    v78 = 0;
  v207 = v68;
  v208 = v78;
  v79 = (_QWORD *)(*((_QWORD *)v64 - 1) & 0xFFFFFFFFFFFFFFF8);
  if (!v79)
    goto LABEL_81;
  v80 = *v79;
  v81 = mlir::TypeID::get<mlir::ShapedType>();
  v82 = *(unsigned int *)(v80 + 16);
  if (!(_DWORD)v82)
    goto LABEL_81;
  v83 = *(_QWORD **)(v80 + 8);
  v84 = &v83[2 * v82];
  do
  {
    v85 = v82 >> 1;
    v86 = &v83[2 * (v82 >> 1)];
    v88 = *v86;
    v87 = v86 + 2;
    v82 += ~(v82 >> 1);
    if (v88 < v81)
      v83 = v87;
    else
      v82 = v85;
  }
  while (v82);
  if (v83 != v84 && *v83 == v81)
    v89 = v83[1];
  else
LABEL_81:
    v89 = 0;
  v205 = v79;
  v206 = v89;
  v90 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v205);
  if (mlir::ShapedType::getNumElements(v90, v91) == 1)
  {
    v92 = (char *)mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>((mlir::Float32Type **)(a4 + 8), v67, (uint64_t *)&v210, &v209)- 16;
  }
  else
  {
    v190 = v66;
    v216 = (char *)v218;
    v217 = 0x600000000;
    v213 = v215;
    v214 = 0x600000000;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v207);
    if (v95)
    {
      for (i = 0; i < v105; ++i)
      {
        v97 = 8 * i;
        v98 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v207) + v97);
        v99 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v205) + v97);
        v100 = v217;
        if (v98 == v99)
        {
          if (v217 >= (unint64_t)HIDWORD(v217))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v216, v218, v217 + 1, 8);
            v100 = v217;
          }
          *(_QWORD *)&v216[8 * v100] = v98;
          LODWORD(v217) = v217 + 1;
          v101 = v214;
          v102 = HIDWORD(v214);
        }
        else
        {
          if (v217 >= (unint64_t)HIDWORD(v217))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v216, v218, v217 + 1, 8);
            v100 = v217;
          }
          *(_QWORD *)&v216[8 * v100] = v99;
          v103 = (v217 + 1);
          LODWORD(v217) = v103;
          if (v103 >= HIDWORD(v217))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v216, v218, v103 + 1, 8);
            LODWORD(v103) = v217;
          }
          *(_QWORD *)&v216[8 * v103] = v98 / v99;
          LODWORD(v217) = v217 + 1;
          v104 = v214;
          if (v214 >= (unint64_t)HIDWORD(v214))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v213, v215, v214 + 1, 8);
            v104 = v214;
          }
          v213[v104] = v99;
          v102 = HIDWORD(v214);
          v101 = v214 + 1;
          LODWORD(v214) = v214 + 1;
          v98 = 1;
        }
        if (v101 >= v102)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v213, v215, v101 + 1, 8);
          v101 = v214;
        }
        v213[v101] = v98;
        LODWORD(v214) = v214 + 1;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v207);
      }
    }
    v203 = (uint64_t *)a4;
    v204 = &v211;
    v106 = (char *)mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>((mlir::Float32Type **)(a4 + 8), v211, (uint64_t *)&v202, (uint64_t *)&v201)- 16;
    v107 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v207);
    if (v213 != (_QWORD *)v215)
      free(v213);
    v66 = v190;
    if (v216 != (char *)v218)
      free(v216);
  }
  v109 = *(_QWORD *)(v200 + 24);
  v210 = v92;
  v211 = v109;
  v209 = (uint64_t)v63 - 16;
  v110 = (_QWORD *)(*((_QWORD *)v92 + 1) & 0xFFFFFFFFFFFFFFF8);
  if (!v110)
    goto LABEL_119;
  v111 = *v110;
  v112 = mlir::TypeID::get<mlir::ShapedType>();
  v113 = *(unsigned int *)(v111 + 16);
  if (!(_DWORD)v113)
    goto LABEL_119;
  v114 = *(_QWORD **)(v111 + 8);
  v115 = &v114[2 * v113];
  do
  {
    v116 = v113 >> 1;
    v117 = &v114[2 * (v113 >> 1)];
    v119 = *v117;
    v118 = v117 + 2;
    v113 += ~(v113 >> 1);
    if (v119 < v112)
      v114 = v118;
    else
      v113 = v116;
  }
  while (v113);
  if (v114 != v115 && *v114 == v112)
    v120 = v114[1];
  else
LABEL_119:
    v120 = 0;
  v207 = v110;
  v208 = v120;
  v121 = (_QWORD *)(*((_QWORD *)v63 - 1) & 0xFFFFFFFFFFFFFFF8);
  if (!v121)
    goto LABEL_129;
  v122 = *v121;
  v123 = mlir::TypeID::get<mlir::ShapedType>();
  v124 = *(unsigned int *)(v122 + 16);
  if (!(_DWORD)v124)
    goto LABEL_129;
  v125 = *(_QWORD **)(v122 + 8);
  v126 = &v125[2 * v124];
  do
  {
    v127 = v124 >> 1;
    v128 = &v125[2 * (v124 >> 1)];
    v130 = *v128;
    v129 = v128 + 2;
    v124 += ~(v124 >> 1);
    if (v130 < v123)
      v125 = v129;
    else
      v124 = v127;
  }
  while (v124);
  if (v125 != v126 && *v125 == v123)
    v131 = v125[1];
  else
LABEL_129:
    v131 = 0;
  v205 = v121;
  v206 = v131;
  v132 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v205);
  if (mlir::ShapedType::getNumElements(v132, v133) == 1)
  {
    v134 = (char *)mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)(a4 + 8), v109, (uint64_t *)&v210, &v209)- 16;
  }
  else
  {
    v216 = (char *)v218;
    v217 = 0x600000000;
    v213 = v215;
    v214 = 0x600000000;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v207);
    if (v135)
    {
      for (j = 0; j < v145; ++j)
      {
        v137 = 8 * j;
        v138 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v207) + v137);
        v139 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v205) + v137);
        v140 = v217;
        if (v138 == v139)
        {
          if (v217 >= (unint64_t)HIDWORD(v217))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v216, v218, v217 + 1, 8);
            v140 = v217;
          }
          *(_QWORD *)&v216[8 * v140] = v138;
          LODWORD(v217) = v217 + 1;
          v141 = v214;
          v142 = HIDWORD(v214);
        }
        else
        {
          if (v217 >= (unint64_t)HIDWORD(v217))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v216, v218, v217 + 1, 8);
            v140 = v217;
          }
          *(_QWORD *)&v216[8 * v140] = v139;
          v143 = (v217 + 1);
          LODWORD(v217) = v143;
          if (v143 >= HIDWORD(v217))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v216, v218, v143 + 1, 8);
            LODWORD(v143) = v217;
          }
          *(_QWORD *)&v216[8 * v143] = v138 / v139;
          LODWORD(v217) = v217 + 1;
          v144 = v214;
          if (v214 >= (unint64_t)HIDWORD(v214))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v213, v215, v214 + 1, 8);
            v144 = v214;
          }
          v213[v144] = v139;
          v142 = HIDWORD(v214);
          v141 = v214 + 1;
          LODWORD(v214) = v214 + 1;
          v138 = 1;
        }
        if (v141 >= v142)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v213, v215, v141 + 1, 8);
          v141 = v214;
        }
        v213[v141] = v138;
        LODWORD(v214) = v214 + 1;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v207);
      }
    }
    v203 = (uint64_t *)a4;
    v204 = &v211;
    v146 = (char *)mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)(a4 + 8), v211, (uint64_t *)&v202, (uint64_t *)&v201)- 16;
    v147 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v207);
    if (v213 != (_QWORD *)v215)
      free(v213);
    if (v216 != (char *)v218)
      free(v216);
  }
  v149 = *(_QWORD *)(v200 + 24);
  v210 = v134;
  v211 = v149;
  v209 = (uint64_t)v66 - 16;
  v150 = (_QWORD *)(*((_QWORD *)v134 + 1) & 0xFFFFFFFFFFFFFFF8);
  if (!v150)
    goto LABEL_161;
  v151 = *v150;
  v152 = mlir::TypeID::get<mlir::ShapedType>();
  v153 = *(unsigned int *)(v151 + 16);
  if (!(_DWORD)v153)
    goto LABEL_161;
  v154 = *(_QWORD **)(v151 + 8);
  v155 = &v154[2 * v153];
  do
  {
    v156 = v153 >> 1;
    v157 = &v154[2 * (v153 >> 1)];
    v159 = *v157;
    v158 = v157 + 2;
    v153 += ~(v153 >> 1);
    if (v159 < v152)
      v154 = v158;
    else
      v153 = v156;
  }
  while (v153);
  if (v154 != v155 && *v154 == v152)
    v160 = v154[1];
  else
LABEL_161:
    v160 = 0;
  v207 = v150;
  v208 = v160;
  v161 = (_QWORD *)(*((_QWORD *)v66 - 1) & 0xFFFFFFFFFFFFFFF8);
  if (!v161)
    goto LABEL_171;
  v162 = *v161;
  v163 = mlir::TypeID::get<mlir::ShapedType>();
  v164 = *(unsigned int *)(v162 + 16);
  if (!(_DWORD)v164)
    goto LABEL_171;
  v165 = *(_QWORD **)(v162 + 8);
  v166 = &v165[2 * v164];
  do
  {
    v167 = v164 >> 1;
    v168 = &v165[2 * (v164 >> 1)];
    v170 = *v168;
    v169 = v168 + 2;
    v164 += ~(v164 >> 1);
    if (v170 < v163)
      v165 = v169;
    else
      v164 = v167;
  }
  while (v164);
  if (v165 != v166 && *v165 == v163)
    v171 = v165[1];
  else
LABEL_171:
    v171 = 0;
  v205 = v161;
  v206 = v171;
  v172 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v205);
  if (mlir::ShapedType::getNumElements(v172, v173) == 1)
  {
    v174 = (char *)mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)(a4 + 8), v149, (uint64_t *)&v210, &v209)- 16;
  }
  else
  {
    v216 = (char *)v218;
    v217 = 0x600000000;
    v213 = v215;
    v214 = 0x600000000;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v207);
    if (v175)
    {
      for (k = 0; k < v185; ++k)
      {
        v177 = 8 * k;
        v178 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v207) + v177);
        v179 = *(_QWORD *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v205) + v177);
        v180 = v217;
        if (v178 == v179)
        {
          if (v217 >= (unint64_t)HIDWORD(v217))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v216, v218, v217 + 1, 8);
            v180 = v217;
          }
          *(_QWORD *)&v216[8 * v180] = v178;
          LODWORD(v217) = v217 + 1;
          v181 = v214;
          v182 = HIDWORD(v214);
        }
        else
        {
          if (v217 >= (unint64_t)HIDWORD(v217))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v216, v218, v217 + 1, 8);
            v180 = v217;
          }
          *(_QWORD *)&v216[8 * v180] = v179;
          v183 = (v217 + 1);
          LODWORD(v217) = v183;
          if (v183 >= HIDWORD(v217))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v216, v218, v183 + 1, 8);
            LODWORD(v183) = v217;
          }
          *(_QWORD *)&v216[8 * v183] = v178 / v179;
          LODWORD(v217) = v217 + 1;
          v184 = v214;
          if (v214 >= (unint64_t)HIDWORD(v214))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v213, v215, v214 + 1, 8);
            v184 = v214;
          }
          v213[v184] = v179;
          v182 = HIDWORD(v214);
          v181 = v214 + 1;
          LODWORD(v214) = v214 + 1;
          v178 = 1;
        }
        if (v181 >= v182)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v213, v215, v181 + 1, 8);
          v181 = v214;
        }
        v213[v181] = v178;
        LODWORD(v214) = v214 + 1;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v207);
      }
    }
    v203 = (uint64_t *)a4;
    v204 = &v211;
    v186 = (char *)mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>((mlir::Float32Type **)(a4 + 8), v211, (uint64_t *)&v202, (uint64_t *)&v201)- 16;
    v187 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v207);
    if (v213 != (_QWORD *)v215)
      free(v213);
    if (v216 != (char *)v218)
      free(v216);
  }
  v189 = (unsigned int *)v200;
  v216 = v174;
  v93 = 1;
  mlir::ValueRange::ValueRange(v212, (uint64_t)&v216, 1uLL);
  mlir::ConversionPatternRewriter::replaceOp(a4, v189, v212[0], v212[1]);
  return v93;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.subtract", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.subtract";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

char *mlir::mps::`anonymous namespace'::LowerDequantizeND::broadcastGrouped<mlir::mps::SubtractOp>(mlir::ConversionPatternRewriter &,mlir::Location,mlir::Value,mlir::Value)const::{lambda(mlir::Value,llvm::ArrayRef<long long>)#1}::operator()(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Builder *v7;
  uint64_t v8;
  uint64_t IntegerType;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  unint64_t v17;
  unint64_t *v18;
  _QWORD *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t *v23;
  mlir::GenericProgramPoint *v24;
  uint64_t v25;
  _QWORD v26[2];

  v26[1] = *MEMORY[0x1E0C80C00];
  v25 = a2;
  v7 = (mlir::Builder *)(*a1 + 1);
  v8 = *a1[1];
  v26[0] = a4;
  IntegerType = mlir::Builder::getIntegerType(v7, 0x40u, 1);
  v10 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v26, 1, IntegerType, 0);
  v11 = v10;
  if (!v10)
    goto LABEL_10;
  v12 = *v10;
  v13 = mlir::TypeID::get<mlir::ShapedType>();
  v14 = *(unsigned int *)(v12 + 16);
  if (!(_DWORD)v14)
    goto LABEL_10;
  v15 = *(_QWORD **)(v12 + 8);
  v16 = &v15[2 * v14];
  do
  {
    v17 = v14 >> 1;
    v18 = &v15[2 * (v14 >> 1)];
    v20 = *v18;
    v19 = v18 + 2;
    v14 += ~(v14 >> 1);
    if (v20 < v13)
      v15 = v19;
    else
      v14 = v17;
  }
  while (v14);
  if (v15 != v16 && *v15 == v13)
    v21 = v15[1];
  else
LABEL_10:
    v21 = 0;
  v23 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v11, v21, a3, 8 * a4, 8, 1, 1);
  v24 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v7, v8, &v23);
  return (char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::UnitAttr **)*a1 + 1, *a1[1], &v25, &v24)- 16;
}

void mlir::mps::`anonymous namespace'::LowerPerAxisDequantize::~LowerPerAxisDequantize(mlir::mps::_anonymous_namespace_::LowerPerAxisDequantize *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::LowerPerAxisDequantize::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3, mlir::UnknownLoc **a4)
{
  uint64_t Input;
  uint64_t Filter;
  uint64_t Bias;
  uint64_t SparseShape;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t *v16;
  _QWORD *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  int Axis;
  uint64_t PositiveAxis;
  _QWORD *v24;
  uint64_t v25;
  unint64_t v27;
  uint64_t v28;
  char v29;
  unint64_t v30;
  uint64_t v31;
  char v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  mlir::GenericProgramPoint *v36;
  uint64_t InputAttributeNames;
  uint64_t v38[2];
  uint64_t v39[2];
  uint64_t v40[2];
  _QWORD v41[4];
  uint64_t v42;
  _QWORD v43[2];
  uint64_t v44;
  uint64_t v45;
  void *__b;
  int v47;
  int v48;
  _QWORD v49[5];

  v49[4] = *MEMORY[0x1E0C80C00];
  v45 = a2;
  Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  v44 = Input;
  __b = (void *)mlir::getElementTypeOrSelf(Input);
  if (*(_UNKNOWN **)(*(_QWORD *)__b + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    || mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&__b) != 4
    || !mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v45))
  {
    return 0;
  }
  Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v45);
  Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v45);
  SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v45);
  v9 = (uint64_t *)(*(_QWORD *)(Input + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v9)
    goto LABEL_13;
  v10 = *v9;
  v11 = mlir::TypeID::get<mlir::ShapedType>();
  v12 = *(unsigned int *)(v10 + 16);
  if (!(_DWORD)v12)
    goto LABEL_13;
  v13 = *(_QWORD **)(v10 + 8);
  v14 = &v13[2 * v12];
  do
  {
    v15 = v12 >> 1;
    v16 = &v13[2 * (v12 >> 1)];
    v18 = *v16;
    v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11)
      v13 = v17;
    else
      v12 = v15;
  }
  while (v12);
  if (v13 != v14 && *v13 == v11)
    v19 = v13[1];
  else
LABEL_13:
    v19 = 0;
  v43[0] = v9;
  v43[1] = v19;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v43))
    return 0;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v43);
  v21 = v20;
  Axis = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v45);
  PositiveAxis = mlir::getPositiveAxis(Axis, v21);
  v42 = PositiveAxis;
  __b = v49;
  v48 = 4;
  if (v21 < 5)
  {
    if (v21)
      memset_pattern16(v49, &unk_181233190, 8 * v21);
    v24 = v49;
  }
  else
  {
    v47 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__b, v49, v21, 8);
    v24 = __b;
    memset_pattern16(__b, &unk_181233190, 8 * v21);
  }
  v47 = v21;
  v24[PositiveAxis] = -1;
  v41[0] = a4;
  v41[1] = &v45;
  v41[2] = &__b;
  v41[3] = &v42;
  v29 = v28;
  v40[0] = v27;
  v40[1] = v28;
  v32 = v31;
  v39[0] = v30;
  v39[1] = v31;
  v25 = 0;
  v38[0] = v33;
  v38[1] = v34;
  if (v29 && v32 && (_BYTE)v34)
  {
    v35 = v45;
    InputAttributeNames = mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v45);
    v36 = mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr,decltype(nullptr)>(a4 + 1, *(_QWORD *)(v35 + 24), &v44, v40, v39, v38, &InputAttributeNames);
    (*((void (**)(mlir::UnknownLoc **, uint64_t, mlir::GenericProgramPoint *))*a4 + 4))(a4, v35, v36);
    v25 = 1;
  }
  if (__b != v49)
    free(__b);
  return v25;
}

unint64_t mlir::mps::`anonymous namespace'::LowerPerAxisDequantize::matchAndRewrite(mlir::mps::DequantizeOp,mlir::mps::DequantizeOpAdaptor,mlir::ConversionPatternRewriter &)const::{lambda(mlir::Value)#1}::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t *v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;
  _QWORD *ArgAttrsAttr;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t DefiningOp;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *Type;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  unint64_t v36;
  unint64_t *v37;
  _QWORD *v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t OperandRange;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49[2];
  uint64_t *v50;
  uint64_t v51;
  _QWORD v52[2];
  uint64_t v53;
  __int128 v54;
  char v55;
  uint64_t v56;

  v2 = a2;
  v56 = *MEMORY[0x1E0C80C00];
  v53 = a2;
  v4 = (uint64_t *)(*(_QWORD *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4)
    goto LABEL_10;
  v5 = *v4;
  v6 = mlir::TypeID::get<mlir::ShapedType>();
  v7 = *(unsigned int *)(v5 + 16);
  if (!(_DWORD)v7)
    goto LABEL_10;
  v8 = *(_QWORD **)(v5 + 8);
  v9 = &v8[2 * v7];
  do
  {
    v10 = v7 >> 1;
    v11 = &v8[2 * (v7 >> 1)];
    v13 = *v11;
    v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6)
      v8 = v12;
    else
      v7 = v10;
  }
  while (v7);
  if (v8 != v9 && *v8 == v6)
    v14 = v8[1];
  else
LABEL_10:
    v14 = 0;
  v52[0] = v4;
  v52[1] = v14;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v52))
  {
    ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v52);
    if (v16)
    {
      v17 = 8 * v16;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v17 -= 8;
        if (!v17)
          goto LABEL_16;
      }
    }
    else
    {
LABEL_16:
      v18 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v52);
      if (mlir::ShapedType::getNumElements(v18, v19) == 1)
      {
        v20 = v2 & 0xFFFFFFFFFFFFFF00;
        return v20 & 0xFFFFFFFFFFFFFF00 | v2;
      }
    }
  }
  *(_QWORD *)&v54 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v52);
  if (*(_UNKNOWN **)(*(_QWORD *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
    || mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v54) != 4)
  {
    *(_QWORD *)&v54 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,llvm::SmallVector<long long,6u>>((mlir::Builder *)(*(_QWORD *)a1 + 8), *(_QWORD *)(**(_QWORD **)(a1 + 8) + 24), &v53, *(_QWORD *)(a1 + 16));
    v27 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v54);
    LOBYTE(v2) = v27;
    v20 = v27 & 0xFFFFFFFFFFFFFF00;
    return v20 & 0xFFFFFFFFFFFFFF00 | v2;
  }
  v50 = 0;
  v51 = 0;
  v49[0] = v2;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v49);
  if (!DefiningOp
    || (v22 = DefiningOp,
        v23 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        !(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v22 + 48) + 32))(*(_QWORD *)(v22 + 48), v23)))
  {
    LOBYTE(v2) = 0;
LABEL_27:
    v20 = 0;
    return v20 & 0xFFFFFFFFFFFFFF00 | v2;
  }
  *(_QWORD *)&v54 = &v55;
  *((_QWORD *)&v54 + 1) = 0x100000000;
  mlir::Operation::fold(v22, 0, 0, (uint64_t)&v54);
  v24 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v54 & 0xFFFFFFFFFFFFFFF8));
  v2 = (uint64_t)v24;
  if (v24)
  {
    v26 = v25;
    v50 = v24;
    v51 = v25;
  }
  else
  {
    v26 = 0;
  }
  if ((char *)v54 != &v55)
    free((void *)v54);
  if (!v2)
    goto LABEL_27;
  *(_QWORD *)(**(_QWORD **)(a1 + 16) + 8 * **(_QWORD **)(a1 + 24)) = mlir::ElementsAttr::getNumElements(v2, v26);
  Type = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v50);
  v30 = (uint64_t)Type;
  if (!Type)
    goto LABEL_42;
  v31 = *Type;
  v32 = mlir::TypeID::get<mlir::ShapedType>();
  v33 = *(unsigned int *)(v31 + 16);
  if (!(_DWORD)v33)
    goto LABEL_42;
  v34 = *(_QWORD **)(v31 + 8);
  v35 = &v34[2 * v33];
  do
  {
    v36 = v33 >> 1;
    v37 = &v34[2 * (v33 >> 1)];
    v39 = *v37;
    v38 = v37 + 2;
    v33 += ~(v33 >> 1);
    if (v39 < v32)
      v34 = v38;
    else
      v33 = v36;
  }
  while (v33);
  if (v34 != v35 && *v34 == v32)
    v40 = v34[1];
  else
LABEL_42:
    v40 = 0;
  v49[0] = v30;
  v49[1] = v40;
  v41 = *(uint64_t **)(a1 + 16);
  v42 = *v41;
  v43 = *((unsigned int *)v41 + 2);
  *(_QWORD *)&v54 = v42;
  *((_QWORD *)&v54 + 1) = v43;
  v55 = 1;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v49);
  v45 = mlir::ShapedType::cloneWith(v49, &v54, OperandRange);
  v50 = mlir::reshapeElementsAttr(v2, v26, v45, v46);
  v51 = v47;
  *(_QWORD *)&v54 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::ElementsAttr &>((mlir::OpBuilder *)(*(_QWORD *)a1 + 8), *(_QWORD *)(**(_QWORD **)(a1 + 8) + 24), (uint64_t)&v50);
  v48 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v54);
  LOBYTE(v2) = v48;
  v20 = v48 & 0xFFFFFFFFFFFFFF00;
  return v20 & 0xFFFFFFFFFFFFFF00 | v2;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DequantizeOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::TypeAttr,decltype(nullptr)>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t *Context;
  uint64_t v15;
  char v16;
  mlir::GenericProgramPoint *v17;
  mlir::GenericProgramPoint *v18;
  uint64_t v20;
  const char *v21;
  __int16 v22;
  uint64_t v23[4];
  __int16 v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x1E0C80C00];
  v20 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
  v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize", (const unsigned __int8 *)0xE, Context);
  if (!v16)
  {
    v24 = 1283;
    v23[2] = (uint64_t)"mps.dequantize";
    v23[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v22 = 259;
    llvm::operator+(v23, (uint64_t *)&v21, (uint64_t)v25);
    llvm::report_fatal_error((llvm::Twine *)v25, 1);
  }
  mlir::OperationState::OperationState(v25, a2, v15);
  mlir::mps::DequantizeOp::build(a1, (uint64_t)v25, *a3, *a4, *a5, *a6, *a7, 0);
  v17 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v25);
  if (*(_UNKNOWN **)(*((_QWORD *)v17 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id)
    v18 = v17;
  else
    v18 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v25);
  return v18;
}

void mlir::mps::`anonymous namespace'::LowerQuantizedMatmul::~LowerQuantizedMatmul(mlir::mps::_anonymous_namespace_::LowerQuantizedMatmul *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::QuantizedMatMulOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::QuantizedMatMulOp>::rewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mpsx::detail::QuantizedMatMulOpGenericAdaptorBase::QuantizedMatMulOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, v12, a5);
}

uint64_t mlir::OpConversionPattern<mlir::mpsx::QuantizedMatMulOp>::matchAndRewrite(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v11[2];
  _BYTE v12[40];
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  v8 = v11[0];
  v9 = v11[1];
  mlir::mpsx::detail::QuantizedMatMulOpGenericAdaptorBase::QuantizedMatMulOpGenericAdaptorBase((uint64_t)v12, a2);
  v13 = v8;
  v14 = v9;
  return (*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 80))(a1, a2, v12, a5);
}

uint64_t mlir::mps::`anonymous namespace'::LowerQuantizedMatmul::matchAndRewrite(uint64_t a1, mlir::Operation *a2, uint64_t a3, mlir::MLIRContext **a4)
{
  uint64_t *InputScale;
  uint64_t *InputZeroPoint;
  uint64_t *InputMin;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t *WeightsScale;
  uint64_t *WeightsZeroPoint;
  uint64_t *WeightsMin;
  uint64_t *BiquantWeightsScale;
  uint64_t *BiquantWeightsZeroPoint;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t *v34;
  _QWORD *v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  mlir::Operation *v41;
  mlir::GenericProgramPoint *v42;
  BOOL TransposeRhs;
  BOOL TransposeLhs;
  uint64_t OutputType;
  uint64_t WeightsPaletteLut;
  uint64_t WeightsQuantParamsAxisAttr;
  uint64_t *v49;
  uint64_t *v50;
  uint64_t *v51;
  uint64_t *v52;
  uint64_t *v53;
  void *__p;
  unsigned int v55;
  _QWORD *Input;
  uint64_t v57;
  uint64_t InputQuantParamsAxisAttr;
  uint64_t *v59;
  uint64_t *v60;
  uint64_t *v61;
  mlir::Operation *v62;

  v62 = a2;
  InputScale = (uint64_t *)mlir::mpsx::QuantizedMatMulOp::getInputScale(&v62);
  v61 = InputScale;
  InputZeroPoint = (uint64_t *)mlir::mpsx::QuantizedMatMulOp::getInputZeroPoint(&v62);
  v60 = InputZeroPoint;
  InputMin = (uint64_t *)mlir::mpsx::QuantizedMatMulOp::getInputMin(&v62);
  v59 = InputMin;
  InputQuantParamsAxisAttr = mlir::mpsx::QuantizedMatMulOp::getInputQuantParamsAxisAttr(&v62);
  if (mlir::mpsx::QuantizedMatMulOp::isInputAffneQuantized(&v62)
    && mlir::mpsx::QuantizedMatMulOp::getInputQuantParamsAxisAttr(&v62))
  {
    v8 = (_QWORD *)(*(_QWORD *)(mlir::mpsx::QuantizedMatMulOp::getInput(&v62) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v8)
      goto LABEL_12;
    v9 = *v8;
    v10 = mlir::TypeID::get<mlir::ShapedType>();
    v11 = *(unsigned int *)(v9 + 16);
    if (!(_DWORD)v11)
      goto LABEL_12;
    v12 = *(_QWORD **)(v9 + 8);
    v13 = &v12[2 * v11];
    do
    {
      v14 = v11 >> 1;
      v15 = &v12[2 * (v11 >> 1)];
      v17 = *v15;
      v16 = v15 + 2;
      v11 += ~(v11 >> 1);
      if (v17 < v10)
        v12 = v16;
      else
        v11 = v14;
    }
    while (v11);
    if (v12 != v13 && *v12 == v10)
      v18 = v12[1];
    else
LABEL_12:
      v18 = 0;
    Input = v8;
    v57 = v18;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&Input))
    {
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Input);
      v20 = v19;
      mlir::IntegerAttr::getValue(&InputQuantParamsAxisAttr, (llvm::APInt *)&__p);
      if (v55 > 0x40)
      {
        v21 = *(_QWORD *)__p;
        operator delete[](__p);
      }
      else
      {
        v21 = (uint64_t)((_QWORD)__p << -(uint64_t)v55) >> -(uint64_t)v55;
      }
      InputQuantParamsAxisAttr = 0;
    }
  }
  WeightsScale = (uint64_t *)mlir::mpsx::QuantizedMatMulOp::getWeightsScale(&v62);
  v53 = WeightsScale;
  WeightsZeroPoint = (uint64_t *)mlir::mpsx::QuantizedMatMulOp::getWeightsZeroPoint(&v62);
  v52 = WeightsZeroPoint;
  WeightsMin = (uint64_t *)mlir::mpsx::QuantizedMatMulOp::getWeightsMin(&v62);
  v51 = WeightsMin;
  BiquantWeightsScale = (uint64_t *)mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsScale(&v62);
  v50 = BiquantWeightsScale;
  BiquantWeightsZeroPoint = (uint64_t *)mlir::mpsx::QuantizedMatMulOp::getBiquantWeightsZeroPoint(&v62);
  v49 = BiquantWeightsZeroPoint;
  WeightsQuantParamsAxisAttr = mlir::mpsx::QuantizedMatMulOp::getWeightsQuantParamsAxisAttr(&v62);
  if ((mlir::mpsx::QuantizedMatMulOp::isWeightsAffineQuantized(&v62)
     || mlir::mpsx::QuantizedMatMulOp::isWeightsDoubleAffineQuantized(&v62))
    && mlir::mpsx::QuantizedMatMulOp::getWeightsQuantParamsAxisAttr(&v62))
  {
    v27 = (_QWORD *)(*(_QWORD *)(mlir::mpsx::QuantizedMatMulOp::getWeights(&v62) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v27)
      goto LABEL_30;
    v28 = *v27;
    v29 = mlir::TypeID::get<mlir::ShapedType>();
    v30 = *(unsigned int *)(v28 + 16);
    if (!(_DWORD)v30)
      goto LABEL_30;
    v31 = *(_QWORD **)(v28 + 8);
    v32 = &v31[2 * v30];
    do
    {
      v33 = v30 >> 1;
      v34 = &v31[2 * (v30 >> 1)];
      v36 = *v34;
      v35 = v34 + 2;
      v30 += ~(v30 >> 1);
      if (v36 < v29)
        v31 = v35;
      else
        v30 = v33;
    }
    while (v30);
    if (v31 != v32 && *v31 == v29)
      v37 = v31[1];
    else
LABEL_30:
      v37 = 0;
    Input = v27;
    v57 = v37;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&Input))
    {
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Input);
      v39 = v38;
      mlir::IntegerAttr::getValue(&WeightsQuantParamsAxisAttr, (llvm::APInt *)&__p);
      if (v55 > 0x40)
      {
        v40 = *(_QWORD *)__p;
        operator delete[](__p);
      }
      else
      {
        v40 = (uint64_t)((_QWORD)__p << -(uint64_t)v55) >> -(uint64_t)v55;
      }
      WeightsQuantParamsAxisAttr = 0;
      if (mlir::mpsx::QuantizedMatMulOp::isWeightsDoubleAffineQuantized(&v62))
      {
      }
    }
  }
  v41 = v62;
  Input = (_QWORD *)mlir::mpsx::QuantizedMatMulOp::getInput(&v62);
  __p = (void *)mlir::mpsx::QuantizedMatMulOp::getWeights(&v62);
  WeightsPaletteLut = mlir::mpsx::QuantizedMatMulOp::getWeightsPaletteLut(&v62);
  OutputType = mlir::mpsx::QuantizedMatMulOp::getOutputType(&v62);
  TransposeLhs = mlir::mpsx::QuantizedMatMulOp::getTransposeLhs(&v62);
  TransposeRhs = mlir::mpsx::QuantizedMatMulOp::getTransposeRhs(&v62);
  v42 = mlir::OpBuilder::create<mlir::mpsx::QuantizedMatMulOp,mlir::Value,mlir::Value&,mlir::Value&,mlir::Value&,mlir::IntegerAttr &,mlir::Value&,mlir::Value&,mlir::Value&,mlir::Value&,mlir::IntegerAttr &,mlir::Value,mlir::detail::TypedValue<mlir::RankedTensorType>,mlir::detail::TypedValue<mlir::RankedTensorType>,mlir::Type,BOOL,BOOL>(a4 + 1, *((_QWORD *)v41 + 3), (uint64_t *)&Input, (uint64_t *)&v61, (uint64_t *)&v60, (uint64_t *)&v59, &InputQuantParamsAxisAttr, (uint64_t *)&__p, (uint64_t *)&v53, (uint64_t *)&v52, (uint64_t *)&v51, &WeightsQuantParamsAxisAttr, &WeightsPaletteLut, (uint64_t *)&v50, (uint64_t *)&v49, &OutputType, (unsigned __int8 *)&TransposeLhs, (unsigned __int8 *)&TransposeRhs);
  (*((void (**)(mlir::MLIRContext **, mlir::Operation *, mlir::GenericProgramPoint *))*a4 + 4))(a4, v41, v42);
  return 1;
}

uint64_t *mlir::mps::`anonymous namespace'::LowerQuantizedMatmul::convertParamToND(uint64_t a1, uint64_t *a2, unint64_t a3, uint64_t a4)
{
  uint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t *v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _BYTE *v20;
  char *v21;
  uint64_t DefiningOp;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *Type;
  uint64_t *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  unint64_t v36;
  unint64_t *v37;
  _QWORD *v38;
  unint64_t v39;
  uint64_t *v40;
  uint64_t *ArgAttrsAttr;
  uint64_t v42;
  uint64_t NumElements;
  void *v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t OperandRange;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  mlir::OpBuilder *v51;
  uint64_t Loc;
  uint64_t *v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  _QWORD *v57;
  _QWORD *v58;
  unint64_t v59;
  unint64_t *v60;
  _QWORD *v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  mlir::GenericProgramPoint *v66;
  mlir::Builder *v67;
  uint64_t v68;
  uint64_t IntegerType;
  _QWORD *v70;
  _QWORD *v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  _QWORD *v75;
  _QWORD *v76;
  unint64_t v77;
  unint64_t *v78;
  _QWORD *v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t *v83[2];
  uint64_t *v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t v87[2];
  void *__b;
  uint64_t v89;
  _BYTE v90[32];
  __int128 v91;
  char v92;
  uint64_t v93;

  v93 = *MEMORY[0x1E0C80C00];
  v86 = a2;
  v7 = (uint64_t *)(a2[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v7)
    goto LABEL_10;
  v8 = *v7;
  v9 = mlir::TypeID::get<mlir::ShapedType>();
  v10 = *(unsigned int *)(v8 + 16);
  if (!(_DWORD)v10)
    goto LABEL_10;
  v11 = *(_QWORD **)(v8 + 8);
  v12 = &v11[2 * v10];
  do
  {
    v13 = v10 >> 1;
    v14 = &v11[2 * (v10 >> 1)];
    v16 = *v14;
    v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9)
      v11 = v15;
    else
      v10 = v13;
  }
  while (v10);
  if (v11 != v12 && *v11 == v9)
    v17 = v11[1];
  else
LABEL_10:
    v17 = 0;
  __b = v7;
  v89 = v17;
  if ((mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&__b) & 1) == 0)
    return v86;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__b);
  if (a3 == 1 || v18 != 1)
    return v86;
  v19 = (a3 & (a4 >> 63)) + a4;
  __b = v90;
  HIDWORD(v89) = 4;
  if (a3 < 5)
  {
    if (a3)
      memset_pattern16(v90, &unk_181233190, 8 * a3);
    v20 = v90;
  }
  else
  {
    LODWORD(v89) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__b, v90, a3, 8);
    v20 = __b;
    memset_pattern16(__b, &unk_181233190, 8 * a3);
  }
  LODWORD(v89) = a3;
  *(_QWORD *)&v20[8 * v19] = -1;
  v84 = 0;
  v85 = 0;
  v83[0] = v86;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v83);
  if (!DefiningOp)
    goto LABEL_49;
  v24 = DefiningOp;
  v25 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v24 + 48) + 32))(*(_QWORD *)(v24 + 48), v25))
    goto LABEL_49;
  *(_QWORD *)&v91 = &v92;
  *((_QWORD *)&v91 + 1) = 0x100000000;
  mlir::Operation::fold(v24, 0, 0, (uint64_t)&v91);
  v26 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)v91 & 0xFFFFFFFFFFFFFFF8));
  v28 = v26;
  if (v26)
  {
    v84 = v26;
    v85 = v27;
  }
  if ((char *)v91 != &v92)
    free((void *)v91);
  if (v28)
  {
    Type = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v84);
    v30 = Type;
    if (!Type)
      goto LABEL_37;
    v31 = *Type;
    v32 = mlir::TypeID::get<mlir::ShapedType>();
    v33 = *(unsigned int *)(v31 + 16);
    if (!(_DWORD)v33)
      goto LABEL_37;
    v34 = *(_QWORD **)(v31 + 8);
    v35 = &v34[2 * v33];
    do
    {
      v36 = v33 >> 1;
      v37 = &v34[2 * (v33 >> 1)];
      v39 = *v37;
      v38 = v37 + 2;
      v33 += ~(v33 >> 1);
      if (v39 < v32)
        v34 = v38;
      else
        v33 = v36;
    }
    while (v33);
    if (v34 != v35 && *v34 == v32)
      v40 = (uint64_t *)v34[1];
    else
LABEL_37:
      v40 = 0;
    v83[0] = v30;
    v83[1] = v40;
    ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v83);
    NumElements = mlir::ShapedType::getNumElements(ArgAttrsAttr, v42);
    v44 = __b;
    *((_QWORD *)__b + v19) = NumElements;
    v45 = v84;
    v46 = v85;
    *(_QWORD *)&v91 = v44;
    *((_QWORD *)&v91 + 1) = v89;
    v92 = 1;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v83);
    v48 = mlir::ShapedType::cloneWith((uint64_t *)v83, &v91, OperandRange);
    v84 = mlir::reshapeElementsAttr((uint64_t)v45, v46, v48, v49);
    v85 = v50;
    v51 = (mlir::OpBuilder *)(a1 + 8);
    Loc = mlir::Value::getLoc((mlir::Value *)&v86);
    v53 = (uint64_t *)(v86[1] & 0xFFFFFFFFFFFFFFF8);
    if (!v53)
      goto LABEL_47;
    v54 = *v53;
    v55 = mlir::TypeID::get<mlir::ShapedType>();
    v56 = *(unsigned int *)(v54 + 16);
    if (!(_DWORD)v56)
      goto LABEL_47;
    v57 = *(_QWORD **)(v54 + 8);
    v58 = &v57[2 * v56];
    do
    {
      v59 = v56 >> 1;
      v60 = &v57[2 * (v56 >> 1)];
      v62 = *v60;
      v61 = v60 + 2;
      v56 += ~(v56 >> 1);
      if (v62 < v55)
        v57 = v61;
      else
        v56 = v59;
    }
    while (v56);
    if (v57 != v58 && *v57 == v55)
      v63 = v57[1];
    else
LABEL_47:
      v63 = 0;
    v87[0] = (uint64_t)v53;
    v87[1] = v63;
    *(_QWORD *)&v91 = __b;
    *((_QWORD *)&v91 + 1) = v89;
    v92 = 1;
    v64 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v87);
    *(_QWORD *)&v91 = mlir::ShapedType::cloneWith(v87, &v91, v64);
    *((_QWORD *)&v91 + 1) = v65;
    v66 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>(v51, Loc, (uint64_t *)&v91, &v84);
  }
  else
  {
LABEL_49:
    v67 = (mlir::Builder *)(a1 + 8);
    v68 = mlir::Value::getLoc((mlir::Value *)&v86);
    v87[0] = a3;
    IntegerType = mlir::Builder::getIntegerType(v67, 0x40u, 1);
    v70 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v87, 1, IntegerType, 0);
    v71 = v70;
    if (!v70)
      goto LABEL_58;
    v72 = *v70;
    v73 = mlir::TypeID::get<mlir::ShapedType>();
    v74 = *(unsigned int *)(v72 + 16);
    if (!(_DWORD)v74)
      goto LABEL_58;
    v75 = *(_QWORD **)(v72 + 8);
    v76 = &v75[2 * v74];
    do
    {
      v77 = v74 >> 1;
      v78 = &v75[2 * (v74 >> 1)];
      v80 = *v78;
      v79 = v78 + 2;
      v74 += ~(v74 >> 1);
      if (v80 < v73)
        v75 = v79;
      else
        v74 = v77;
    }
    while (v74);
    if (v75 != v76 && *v75 == v73)
      v81 = v75[1];
    else
LABEL_58:
      v81 = 0;
    v83[0] = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v71, v81, __b, 8 * v89, 8, 1, 1);
    *(_QWORD *)&v91 = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v67, v68, v83)
                    - 16;
    v82 = mlir::Value::getLoc((mlir::Value *)&v86);
    v66 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value,mlir::Value&>((mlir::UnitAttr **)v67, v82, (uint64_t *)&v86, (uint64_t *)&v91);
  }
  v21 = (char *)v66 - 16;
  if (__b != v90)
    free(__b);
  return (uint64_t *)v21;
}

void mlir::mps::`anonymous namespace'::MPS_LowerBiasAddNHWC::~MPS_LowerBiasAddNHWC(mlir::mps::_anonymous_namespace_::MPS_LowerBiasAddNHWC *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::MPS_LowerBiasAddNHWC::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerBiasAddNHWC *this, mlir::Operation *a2, mlir::MLIRContext **a3)
{
  mlir::Operation *v5;
  uint64_t InherentAttr;
  char v7;
  uint64_t v8;
  uint64_t v9;
  mlir::Operation *v11;
  uint64_t v12;
  void *v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD v16[6];

  v16[4] = *MEMORY[0x1E0C80C00];
  v12 = 0;
  v14 = v16;
  v16[0] = a2;
  v15 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::BiasAddOp,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v11 = v5;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v11, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v11, 1u);
  if (*((_BYTE *)a2 + 47))
  {
    InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"data_format", 11);
    if (v7)
    {
      if (!InherentAttr)
        goto LABEL_10;
LABEL_9:
      if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
        goto LABEL_11;
      goto LABEL_10;
    }
  }
  InherentAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "data_format", 0xBuLL);
  if (InherentAttr)
    goto LABEL_9;
LABEL_10:
  InherentAttr = mlir::mps::TensorDataLayoutAttr::get(a3[1], 1u);
LABEL_11:
  v12 = InherentAttr;
  if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v12) == 1)
  {
    v13 = *(void **)(*v14 + 24);
    mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v13, (mlir::MLIRContext *)1, 0);
  }
  v8 = (uint64_t)a3[2];
  if (v8 && mlir::RewriterBase::Listener::classof(v8))
  else
    v9 = 0;
  if (v14 != v16)
    free(v14);
  return v9;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::AddOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.add", (const unsigned __int8 *)7, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.add";
    v19[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_LowerBiasAddNHWC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'data_format' failed to satisfy constraint: 'is NHWC'");
}

void mlir::mps::`anonymous namespace'::MPS_LowerDegamma::~MPS_LowerDegamma(mlir::mps::_anonymous_namespace_::MPS_LowerDegamma *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerDegamma::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerDegamma *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  _QWORD v5[2];
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DegammaOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::PowerOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.power", (const unsigned __int8 *)9, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.power";
    v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PowerOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t mlir::mps::getConstantAttr<double>(uint64_t *a1, double a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t *v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t ElementTypeOrSelf;
  void *v14;
  _QWORD v27[3];
  _QWORD v28[3];
  _QWORD v29[3];
  _QWORD v30[2];
  double v31;
  uint64_t v32;

  v31 = a2;
  v32 = 0;
  if (!a1)
    goto LABEL_10;
  v3 = *a1;
  v4 = mlir::TypeID::get<mlir::ShapedType>();
  v5 = *(unsigned int *)(v3 + 16);
  if (!(_DWORD)v5)
    goto LABEL_10;
  v6 = *(_QWORD **)(v3 + 8);
  v7 = &v6[2 * v5];
  do
  {
    v8 = v5 >> 1;
    v9 = &v6[2 * (v5 >> 1)];
    v11 = *v9;
    v10 = v9 + 2;
    v5 += ~(v5 >> 1);
    if (v11 < v4)
      v6 = v10;
    else
      v5 = v8;
  }
  while (v5);
  if (v6 != v7 && *v6 == v4)
    v12 = v6[1];
  else
LABEL_10:
    v12 = 0;
  v30[0] = a1;
  v30[1] = v12;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
  v29[0] = &v32;
  v29[1] = v30;
  v29[2] = &v31;
  v14 = *(void **)(*(_QWORD *)ElementTypeOrSelf + 136);
  if (v14 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v14 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    mlir::mps::getConstantAttr<double>(mlir::Type,double)::{lambda(mlir::Type)#1}::operator()((uint64_t)v29, ElementTypeOrSelf);
  }
  else
  {
    v28[0] = &v32;
    v28[1] = v30;
    v28[2] = &v31;
    if (v14 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
    {
      mlir::mps::getConstantAttr<double>(mlir::Type,double)::{lambda(mlir::Type)#2}::operator()((uint64_t)v28, ElementTypeOrSelf);
    }
    else
    {
      v27[0] = &v32;
      v27[1] = v30;
      v27[2] = &v31;
      if (v14 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
        mlir::mps::getConstantAttr<double>(mlir::Type,double)::{lambda(mlir::ComplexType)#1}::operator()((uint64_t)v27, ElementTypeOrSelf);
    }
  }
  return v32;
}

void mlir::mps::getConstantAttr<double>(mlir::Type,double)::{lambda(mlir::Type)#1}::operator()(uint64_t a1, uint64_t a2)
{
  _BOOL8 isF16;
  uint64_t v4;
  llvm::APFloatBase *v5;
  uint64_t v6;
  void *v7;
  _BOOL8 isBF16;
  uint64_t v9;
  void *v10;
  std::string *v11;
  std::string::size_type size;
  llvm::APFloatBase *v13;
  void *v14;
  uint64_t *v15;
  float v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  std::string v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD v25[4];

  v25[3] = *MEMORY[0x1E0C80C00];
  v23 = a2;
  isF16 = mlir::Type::isF16((mlir::Type *)&v23);
  if (isF16)
  {
    v4 = *(_QWORD *)(a1 + 8);
    v5 = *(llvm::APFloatBase **)v4;
    v6 = *(_QWORD *)(v4 + 8);
    v7 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)isF16);
  }
  else
  {
    isBF16 = mlir::Type::isBF16((mlir::Type *)&v23);
    if (!isBF16)
    {
      if (mlir::Type::isF32((mlir::Type *)&v23))
      {
        v15 = *(uint64_t **)(a1 + 8);
        v16 = **(double **)(a1 + 16);
        *(float *)&v24 = v16;
        v17 = *v15;
        v18 = v15[1];
        v19 = 4;
        v20 = 4;
      }
      else
      {
        mlir::Type::isF64((mlir::Type *)&v23);
        v21 = *(uint64_t **)(a1 + 8);
        v24 = **(_QWORD **)(a1 + 16);
        v17 = *v21;
        v18 = v21[1];
        v19 = 8;
        v20 = 8;
      }
      **(_QWORD **)a1 = mlir::DenseElementsAttr::getFromRawBuffer(v17, v18, &v24, v19, v20, 0, 1);
      return;
    }
    v9 = *(_QWORD *)(a1 + 8);
    v5 = *(llvm::APFloatBase **)v9;
    v6 = *(_QWORD *)(v9 + 8);
    v7 = llvm::APFloatBase::BFloat((llvm::APFloatBase *)isBF16);
  }
  v10 = v7;
  std::to_string(&v22, **(double **)(a1 + 16));
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = &v22;
  else
    v11 = (std::string *)v22.__r_.__value_.__r.__words[0];
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v22.__r_.__value_.__r.__words[2]);
  else
    size = v22.__r_.__value_.__l.__size_;
  llvm::APFloat::APFloat((llvm::APFloatBase *)&v24, v10, (unsigned __int8 *)v11, size);
  v13 = (llvm::APFloatBase *)mlir::DenseElementsAttr::get(v5, v6, (uint64_t)&v24, 1);
  **(_QWORD **)a1 = v13;
  v14 = (void *)v25[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v13) == v14)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v25);
    if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
  }
  else
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v25);
    if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
  }
  operator delete(v22.__r_.__value_.__l.__data_);
}

void mlir::mps::getConstantAttr<double>(mlir::Type,double)::{lambda(mlir::Type)#2}::operator()(uint64_t a1, uint64_t a2)
{
  _BOOL4 isInteger;
  uint64_t *v4;
  unsigned int IntOrFloatBitWidth;
  uint64_t v6;
  _BOOL4 isSignedInteger;
  unint64_t v8;
  void *__p;
  unsigned int v10;
  uint64_t v11;

  v11 = a2;
  isInteger = mlir::Type::isInteger((mlir::Type *)&v11, 1);
  v4 = *(uint64_t **)(a1 + 8);
  if (isInteger)
  {
    LOBYTE(__p) = **(double **)(a1 + 16) != 0.0;
    **(_QWORD **)a1 = mlir::DenseElementsAttr::get(*v4, v4[1], &__p, 1);
  }
  else
  {
    IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v11);
    v6 = (unint64_t)**(double **)(a1 + 16);
    isSignedInteger = mlir::Type::isSignedInteger((mlir::Type *)&v11);
    v10 = IntOrFloatBitWidth;
    if (IntOrFloatBitWidth > 0x40)
    {
      llvm::APInt::initSlowCase((llvm::APInt *)&__p, v6, isSignedInteger);
    }
    else
    {
      v8 = 0xFFFFFFFFFFFFFFFFLL >> -(char)IntOrFloatBitWidth;
      if (!IntOrFloatBitWidth)
        v8 = 0;
      __p = (void *)(v8 & v6);
    }
    **(_QWORD **)a1 = mlir::DenseElementsAttr::get(*v4, v4[1], (llvm::APInt *)&__p, 1);
    if (v10 >= 0x41)
    {
      if (__p)
        operator delete[](__p);
    }
  }
}

void mlir::mps::getConstantAttr<double>(mlir::Type,double)::{lambda(mlir::ComplexType)#1}::operator()(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  float v4;
  _BOOL8 isF16;
  uint64_t v6;
  void *v13;
  std::string *v15;
  std::string::size_type size;
  std::string *v17;
  std::string::size_type v18;
  llvm::APFloatBase *v19;
  void *v20;
  void *v21;
  std::string v22;
  std::string v23;
  uint64_t Value;
  uint64_t v25;
  _BYTE v26[8];
  _QWORD v27[3];
  _DWORD v28[2];
  _QWORD v29[3];
  _BYTE v30[8];
  _QWORD v31[4];
  _QWORD v32[4];

  v32[3] = *MEMORY[0x1E0C80C00];
  v25 = a2;
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v25);
  if (mlir::Type::isF32((mlir::Type *)&Value))
  {
    v3 = *(_QWORD **)(a1 + 8);
    v4 = **(double **)(a1 + 16);
    *(float *)v28 = v4;
    v28[1] = 0;
    **(_QWORD **)a1 = mlir::DenseElementsAttr::getFromRawBuffer(*v3, v3[1], v28, 8, 8, 0, 1);
    return;
  }
  isF16 = mlir::Type::isF16((mlir::Type *)&Value);
  v6 = *(_QWORD *)(a1 + 8);
  _S0 = **(double **)(a1 + 16);
  __asm { FCVT            H8, S0 }
  v13 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)isF16);
  __asm { FCVT            S0, H8; __val }
  std::to_string(&v23, _S0);
  if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v15 = &v23;
  else
    v15 = (std::string *)v23.__r_.__value_.__r.__words[0];
  if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v23.__r_.__value_.__r.__words[2]);
  else
    size = v23.__r_.__value_.__l.__size_;
  llvm::APFloat::APFloat((llvm::APFloatBase *)v28, v13, (unsigned __int8 *)v15, size);
  std::to_string(&v22, 0.0);
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = &v22;
  else
    v17 = (std::string *)v22.__r_.__value_.__r.__words[0];
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v18 = HIBYTE(v22.__r_.__value_.__r.__words[2]);
  else
    v18 = v22.__r_.__value_.__l.__size_;
  v19 = llvm::APFloat::APFloat((llvm::APFloatBase *)v26, v13, (unsigned __int8 *)v17, v18);
  v20 = (void *)v29[0];
  v21 = llvm::APFloatBase::PPCDoubleDouble(v19);
  if (v21 == v20)
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v31, (const llvm::detail::DoubleAPFloat *)v29);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v31, (const llvm::detail::IEEEFloat *)v29);
  if (v21 == (void *)v27[0])
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v32, (const llvm::detail::DoubleAPFloat *)v27);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v32, (const llvm::detail::IEEEFloat *)v27);
  **(_QWORD **)a1 = mlir::DenseElementsAttr::get(*(llvm::APFloatBase **)v6, *(_QWORD *)(v6 + 8), (uint64_t)v30, 1);
  if (v21 == (void *)v32[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v32);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v32);
  if (v21 == (void *)v31[0])
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v31);
  else
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v31);
  if (v21 != (void *)v27[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v27);
    if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_30;
    goto LABEL_29;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v27);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
LABEL_29:
    operator delete(v22.__r_.__value_.__l.__data_);
LABEL_30:
  if (v21 != (void *)v29[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v29);
    if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
    goto LABEL_32;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v29);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
LABEL_32:
    operator delete(v23.__r_.__value_.__l.__data_);
}

void mlir::mps::`anonymous namespace'::MPS_LowerDequantize::~MPS_LowerDequantize(mlir::mps::_anonymous_namespace_::MPS_LowerDequantize *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::MPS_LowerDequantize::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerDequantize *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  mlir::Operation *v5;
  uint64_t ODSOperands;
  uint64_t InherentAttr;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t (*v11)(int, uint64_t);
  uint64_t v12;
  char v13;
  uint64_t ODSResults;
  mlir::detail::OpResultImpl *NextResultAtOffset;
  mlir::Operation *v17;
  uint64_t v18;
  mlir::Operation *v19;
  void *Owner;
  _QWORD *v21;
  uint64_t v22;
  _QWORD v23[6];

  v23[4] = *MEMORY[0x1E0C80C00];
  v18 = 0;
  v21 = v23;
  v23[0] = a2;
  v22 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v17 = v5;
  v19 = v5;
  ODSOperands = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v17, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v17, 1u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v17, 2u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v17, 3u);
  if (*((_BYTE *)a2 + 47) && (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"dtype", 5), v8))
  {
    if (!InherentAttr)
      goto LABEL_10;
  }
  else
  {
    InherentAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "dtype", 5uLL);
    if (!InherentAttr)
    {
LABEL_10:
      v9 = *((_QWORD *)a3 + 2);
      if (v9 && mlir::RewriterBase::Listener::classof(v9))
      {
        v10 = *((_QWORD *)a2 + 3);
LABEL_13:
        v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v9 + 64))(v9, v10, v11, &Owner);
        goto LABEL_27;
      }
      goto LABEL_26;
    }
  }
  if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
    goto LABEL_10;
  v18 = InherentAttr;
  if (!*((_BYTE *)a2 + 47) || (mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"axis", 4), !v13))
    mlir::DictionaryAttr::get((uint64_t)a2 + 56, "axis", 4uLL);
  ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v19, 0);
  NextResultAtOffset = (mlir::detail::OpResultImpl *)mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
  Owner = (void *)mlir::detail::OpResultImpl::getOwner(NextResultAtOffset);
  if (mlir::mps::DequantizeOp::hasNDParams((mlir::mps::DequantizeOp *)&Owner))
  {
    v9 = *((_QWORD *)a3 + 2);
    if (v9 && mlir::RewriterBase::Listener::classof(v9))
    {
      v10 = *((_QWORD *)a2 + 3);
      goto LABEL_13;
    }
  }
  else
  {
    Owner = (void *)mlir::getElementTypeOrSelf(*(_QWORD *)(ODSOperands + 24));
    if (*(_UNKNOWN **)(*(_QWORD *)Owner + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id
      || mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&Owner) != 4)
    {
      Owner = *(void **)(*v21 + 24);
      mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)&Owner, (mlir::MLIRContext *)1, 0);
    }
    v9 = *((_QWORD *)a3 + 2);
    if (v9 && mlir::RewriterBase::Listener::classof(v9))
    {
      v10 = *((_QWORD *)a2 + 3);
      goto LABEL_13;
    }
  }
LABEL_26:
  v12 = 0;
LABEL_27:
  if (v21 != v23)
    free(v21);
  return v12;
}

char *mlir::mps::`anonymous namespace'::reshapeQuantizeScaleZp(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t Loc;
  uint64_t *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t *v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD *ArgAttrsAttr;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  char *v23;
  uint64_t *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  unint64_t v30;
  unint64_t *v31;
  _QWORD *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  unint64_t v41;
  unint64_t *v42;
  _QWORD *v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  mlir::mps::ConstantOp *v49;
  uint64_t v50;
  uint64_t PositiveAxis;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  uint64_t v55;
  mlir::Builder *v56;
  uint64_t IntegerType;
  uint64_t *v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  _QWORD *v63;
  _QWORD *v64;
  unint64_t v65;
  unint64_t *v66;
  _QWORD *v67;
  unint64_t v68;
  uint64_t v69;
  mlir::GenericProgramPoint *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t *v75;
  _QWORD v76[2];
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  mlir::GenericProgramPoint *v80;
  void *__p;
  uint64_t v82;
  _QWORD v83[4];

  v83[3] = *MEMORY[0x1E0C80C00];
  v78 = a3;
  v79 = a2;
  v77 = a4;
  Loc = mlir::Value::getLoc((mlir::Value *)&v79);
  v7 = (uint64_t *)(*(_QWORD *)(v79 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v7)
    goto LABEL_10;
  v8 = *v7;
  v9 = mlir::TypeID::get<mlir::ShapedType>();
  v10 = *(unsigned int *)(v8 + 16);
  if (!(_DWORD)v10)
    goto LABEL_10;
  v11 = *(_QWORD **)(v8 + 8);
  v12 = &v11[2 * v10];
  do
  {
    v13 = v10 >> 1;
    v14 = &v11[2 * (v10 >> 1)];
    v16 = *v14;
    v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9)
      v11 = v15;
    else
      v10 = v13;
  }
  while (v10);
  if (v11 != v12 && *v11 == v9)
    v17 = v11[1];
  else
LABEL_10:
    v17 = 0;
  v76[0] = v7;
  v76[1] = v17;
  if (!v78)
    return (char *)v79;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v76))
  {
    ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v76);
    if (v19)
    {
      v20 = 8 * v19;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v20 -= 8;
        if (!v20)
          goto LABEL_17;
      }
      goto LABEL_19;
    }
LABEL_17:
    v21 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v76);
    if (mlir::ShapedType::getNumElements(v21, v22) == 1)
      return (char *)v79;
  }
LABEL_19:
  v24 = (uint64_t *)(*(_QWORD *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v24)
    goto LABEL_28;
  v25 = *v24;
  v26 = mlir::TypeID::get<mlir::ShapedType>();
  v27 = *(unsigned int *)(v25 + 16);
  if (!(_DWORD)v27)
    goto LABEL_28;
  v28 = *(_QWORD **)(v25 + 8);
  v29 = &v28[2 * v27];
  do
  {
    v30 = v27 >> 1;
    v31 = &v28[2 * (v27 >> 1)];
    v33 = *v31;
    v32 = v31 + 2;
    v27 += ~(v27 >> 1);
    if (v33 < v26)
      v28 = v32;
    else
      v27 = v30;
  }
  while (v27);
  if (v28 != v29 && *v28 == v26)
    v34 = v28[1];
  else
LABEL_28:
    v34 = 0;
  __p = v24;
  v82 = v34;
  if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&__p))
  {
    v35 = (uint64_t *)(*(_QWORD *)(a4 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v35)
      goto LABEL_39;
    v36 = *v35;
    v37 = mlir::TypeID::get<mlir::ShapedType>();
    v38 = *(unsigned int *)(v36 + 16);
    if (!(_DWORD)v38)
      goto LABEL_39;
    v39 = *(_QWORD **)(v36 + 8);
    v40 = &v39[2 * v38];
    do
    {
      v41 = v38 >> 1;
      v42 = &v39[2 * (v38 >> 1)];
      v44 = *v42;
      v43 = v42 + 2;
      v38 += ~(v38 >> 1);
      if (v44 < v37)
        v39 = v43;
      else
        v38 = v41;
    }
    while (v38);
    if (v39 != v40 && *v39 == v37)
      v45 = v39[1];
    else
LABEL_39:
      v45 = 0;
    __p = v35;
    v82 = v45;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__p);
    v47 = v46;
    mlir::IntegerAttr::getValue(&v78, (llvm::APInt *)&__p);
    if (v82 > 0x40)
      v48 = *(_QWORD *)__p;
    else
      v48 = (uint64_t)((_QWORD)__p << -(uint64_t)v82) >> -(uint64_t)v82;
    PositiveAxis = mlir::getPositiveAxis(v48, v47);
    if (v82 >= 0x41 && __p)
      operator delete[](__p);
    v52 = v47 + ~PositiveAxis;
    __p = v83;
    v82 = 0x500000000;
    if (v52 >= 1)
    {
      v53 = 0;
      v54 = v47 - PositiveAxis;
      v55 = 1;
      do
      {
        if (v53 >= HIDWORD(v82))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__p, v83, v53 + 1, 4);
          v53 = v82;
        }
        *((_DWORD *)__p + v53) = v55;
        v53 = v82 + 1;
        LODWORD(v82) = v82 + 1;
        ++v55;
      }
      while (v54 != v55);
    }
    v80 = (mlir::GenericProgramPoint *)v52;
    v56 = (mlir::Builder *)(a1 + 8);
    IntegerType = mlir::Builder::getIntegerType(v56, 0x20u, 1);
    v58 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)&v80, 1, IntegerType, 0);
    v59 = mlir::Value::getLoc((mlir::Value *)&v79);
    if (!v58)
      goto LABEL_62;
    v60 = *v58;
    v61 = mlir::TypeID::get<mlir::ShapedType>();
    v62 = *(unsigned int *)(v60 + 16);
    if (!(_DWORD)v62)
      goto LABEL_62;
    v63 = *(_QWORD **)(v60 + 8);
    v64 = &v63[2 * v62];
    do
    {
      v65 = v62 >> 1;
      v66 = &v63[2 * (v62 >> 1)];
      v68 = *v66;
      v67 = v66 + 2;
      v62 += ~(v62 >> 1);
      if (v68 < v61)
        v63 = v67;
      else
        v62 = v65;
    }
    while (v62);
    if (v63 != v64 && *v63 == v61)
      v69 = v63[1];
    else
LABEL_62:
      v69 = 0;
    v75 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v58, v69, __p, 4 * v82, 4, 1, 1);
    v80 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v56, v59, &v75);
    v23 = (char *)mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>(v56, Loc, &v79, &v80)- 16;
    if (__p != v83)
      free(__p);
  }
  else
  {
    v49 = (mlir::mps::ConstantOp *)(a1 + 8);
    LODWORD(__p) = 0;
    v80 = (mlir::GenericProgramPoint *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>(v49, Loc, (unsigned int *)&__p)- 16);
    LODWORD(__p) = 1;
    v75 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>(v49, Loc, (unsigned int *)&__p) - 16);
    LODWORD(__p) = -1;
    v74 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>(v49, Loc, (unsigned int *)&__p) - 16;
    mlir::IntegerAttr::getValue(&v78, (llvm::APInt *)&__p);
    if (v82 > 0x40)
      v50 = *(_QWORD *)__p;
    else
      v50 = (uint64_t)((_QWORD)__p << -(uint64_t)v82) >> -(uint64_t)v82;
    LODWORD(v72) = v50;
    v73 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,int>(v49, Loc, (unsigned int *)&v72) - 16;
    if (v82 >= 0x41 && __p)
      operator delete[](__p);
    __p = (char *)mlir::OpBuilder::create<mlir::mps::RankOp,mlir::Value &>(v49, Loc, &v77) - 16;
    v71 = mlir::OpBuilder::create<mlir::mps::GetCoordOp,mlir::Value &,mlir::Value &>((uint64_t *)v49, Loc, (uint64_t *)&__p, (uint64_t *)&v80);
    v72 = (uint64_t)mlir::OpBuilder::create<mlir::mps::CropOp,mlir::mps::GetCoordOp,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::UnknownLoc **)v49, Loc, &v71, (uint64_t *)&v80, (uint64_t *)&v80, (uint64_t *)&v75)- 16;
    v71 = (mlir::GenericProgramPoint *)((char *)mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>(v49, Loc, &v79, &v72)- 16);
    return (char *)mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::Float32Type **)v49, Loc, (uint64_t *)&v71, &v74, &v73)- 16;
  }
  return v23;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_LowerDequantize::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'mps.dequantize' to have attribute 'dtype' of type '::mlir::TypeAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_LowerDequantize::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'op' failed to satisfy constraint: 'Dequantize has 0D / 1D parameters'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_LowerDequantize::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'input' failed to satisfy constraint: 'isn't a native MPS quantization type'");
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::mps::ConstantOp &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.expand_dims", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.expand_dims";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ExpandDimsOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4 - 16);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CropOp,mlir::mps::GetCoordOp,mlir::Value &,mlir::Value &,mlir::Value &>(mlir::UnknownLoc **a1, uint64_t a2, _QWORD *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.crop", (const unsigned __int8 *)8, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.crop";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::CropOp::build(a1, (uint64_t)v23, *a3 - 16, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CropOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::TransposeOp,mlir::Value &,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.transpose", (const unsigned __int8 *)0xD, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.transpose";
    v19[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::TransposeOp::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::TransposeOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::mps::`anonymous namespace'::MPS_LowerDirac::~MPS_LowerDirac(mlir::mps::_anonymous_namespace_::MPS_LowerDirac *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerDirac::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerDirac *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  _QWORD v5[2];
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DiracOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::EqualToOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.equal", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.equal";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::EqualToOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::EqualToOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SelectOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.select";
    v19[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SelectOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

void mlir::mps::`anonymous namespace'::MPS_LowerElu::~MPS_LowerElu(mlir::mps::_anonymous_namespace_::MPS_LowerElu *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerElu::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerElu *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  _QWORD v5[2];
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::EluOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::GreaterThanOrEqualToOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.greater_equal", (const unsigned __int8 *)0x11, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.greater_equal";
    v17[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::EqualToOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::GreaterThanOrEqualToOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ExponentOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.exponent", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.exponent";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ExponentOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

void mlir::mps::`anonymous namespace'::MPS_LowerFloorDiv::~MPS_LowerFloorDiv(mlir::mps::_anonymous_namespace_::MPS_LowerFloorDiv *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerFloorDiv::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerFloorDiv *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  mlir::Operation *v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[5];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::FloorDivideOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5 = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 1u);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DivideOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.divide", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.divide";
    v17[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::FloorOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.floor", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.floor";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::FloorOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

void mlir::mps::`anonymous namespace'::MPS_LowerGelu::~MPS_LowerGelu(mlir::mps::_anonymous_namespace_::MPS_LowerGelu *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerGelu::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerGelu *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  _QWORD v5[2];
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::GeluOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SquareRootOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square_root", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.square_root";
    v17[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SquareRootOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ErfOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.erf", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.erf";
    v17[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ErfOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MultiplyOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.multiply";
    v19[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

void mlir::mps::`anonymous namespace'::MPS_LowerInstanceNorm::~MPS_LowerInstanceNorm(mlir::mps::_anonymous_namespace_::MPS_LowerInstanceNorm *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerInstanceNorm::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerInstanceNorm *this, mlir::Operation *a2, mlir::Float32Type **a3)
{
  mlir::Operation *v5;
  uint64_t InherentAttr;
  mlir::MLIRContext *v7;
  uint64_t F32Type;
  _QWORD v9[2];
  void *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD v13[6];

  v13[4] = *MEMORY[0x1E0C80C00];
  v11 = v13;
  v13[0] = a2;
  v12 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::InstanceNormOp,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v9[0] = v5;
  v9[1] = v5;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v9, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v9, 1u);
  if (!*((_BYTE *)a2 + 47)
    || (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"epsilon", 7), !(_BYTE)v7))
  {
    InherentAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "epsilon", 7uLL);
  }
  if (!InherentAttr
    || *(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    F32Type = mlir::Builder::getF32Type(a3 + 1, v7);
    mlir::Builder::getFloatAttr(0.0, (uint64_t)(a3 + 1), F32Type);
  }
  v10 = *(void **)(*v11 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v10, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionMeanOp,mlir::Value &,mlir::Value &,mlir::UnitAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_mean", (const unsigned __int8 *)0x12, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.reduction_mean";
    v19[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReductionMeanOp::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMeanOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionVarianceOp,mlir::Value &,mlir::Value &,mlir::UnitAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_variance", (const unsigned __int8 *)0x16, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.reduction_variance";
    v19[3] = 22;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReductionVarianceOp::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionVarianceOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::NormalizationOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.normalization", (const unsigned __int8 *)0x11, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.normalization";
    v19[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::NormalizationOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

void mlir::mps::`anonymous namespace'::MPS_LowerLPNorm::~MPS_LowerLPNorm(mlir::mps::_anonymous_namespace_::MPS_LowerLPNorm *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerLPNorm::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerLPNorm *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  mlir::Operation *v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::LPNormOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5 = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 1u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 2u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 3u);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::AbsoluteOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.absolute", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.absolute";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::AbsoluteOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::PowerOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.power", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.power";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PowerOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionSumOp,mlir::Value &,mlir::Value &,mlir::UnitAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_sum", (const unsigned __int8 *)0x11, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.reduction_sum";
    v19[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReductionSumOp::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReciprocalOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.reciprocal";
    v17[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DivideOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.divide", (const unsigned __int8 *)0xA, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.divide";
    v19[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

void mlir::mps::`anonymous namespace'::MPS_LowerLeakyRelu::~MPS_LowerLeakyRelu(mlir::mps::_anonymous_namespace_::MPS_LowerLeakyRelu *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerLeakyRelu::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerLeakyRelu *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  _QWORD v5[2];
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::LeakyReluOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

void mlir::mps::`anonymous namespace'::MPS_LowerNRelu::~MPS_LowerNRelu(mlir::mps::_anonymous_namespace_::MPS_LowerNRelu *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerNRelu::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerNRelu *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  _QWORD v5[2];
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::NReluOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 2u);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MinimumOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.minimum", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.minimum";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MinimumOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::`anonymous namespace'::MPS_LowerNormalization::~MPS_LowerNormalization(mlir::mps::_anonymous_namespace_::MPS_LowerNormalization *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::MPS_LowerNormalization::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerNormalization *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v5;
  uint64_t InherentAttr;
  char v7;
  uint64_t v8;
  uint64_t v9;
  mlir::Operation *v11;
  uint64_t v12;
  void *v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD v16[6];

  v16[4] = *MEMORY[0x1E0C80C00];
  v12 = 0;
  v14 = v16;
  v16[0] = a2;
  v15 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::NormalizationOp,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v11 = v5;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v11, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v11, 1u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v11, 2u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v11, 3u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v11, 4u);
  if (*((_BYTE *)a2 + 47)
    && (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"epsilon", 7), v7))
  {
    if (!InherentAttr)
      goto LABEL_10;
  }
  else
  {
    InherentAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "epsilon", 7uLL);
    if (!InherentAttr)
      goto LABEL_10;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    v12 = InherentAttr;
    v13 = *(void **)(*v14 + 24);
    mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v13, (mlir::MLIRContext *)1, 0);
  }
LABEL_10:
  v8 = (uint64_t)a3[2];
  if (v8 && mlir::RewriterBase::Listener::classof(v8))
  else
    v9 = 0;
  if (v14 != v16)
    free(v14);
  return v9;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReciprocalSquareRootOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reciprocal_square_root", (const unsigned __int8 *)0x1A, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.reciprocal_square_root";
    v17[3] = 26;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalSquareRootOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_LowerNormalization::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'mps.normalization' to have attribute 'epsilon' of type '::mlir::FloatAttr'");
}

void mlir::mps::`anonymous namespace'::MPS_LowerPRelu::~MPS_LowerPRelu(mlir::mps::_anonymous_namespace_::MPS_LowerPRelu *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerPRelu::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerPRelu *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  _QWORD v5[2];
  __int128 v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PReluOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  *(_QWORD *)&v6 = *(_QWORD *)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::Value &,BOOL &>(mlir::UnitAttr **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned __int8 *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.reshape";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ReshapeOp::build(a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void mlir::mps::`anonymous namespace'::MPS_LowerQuantize::~MPS_LowerQuantize(mlir::mps::_anonymous_namespace_::MPS_LowerQuantize *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::MPS_LowerQuantize::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerQuantize *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t ODSResults;
  uint64_t NextResultAtOffset;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _QWORD v14[2];
  uint64_t v15;
  _QWORD v16[2];
  _QWORD v17[2];
  uint64_t v18;
  void *v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD v22[6];

  v22[4] = *MEMORY[0x1E0C80C00];
  v18 = 0;
  if ((*((_BYTE *)a2 + 46) & 0x80) != 0)
  {
    v5 = *((_QWORD *)a2 + 9);
    v6 = *((unsigned int *)a2 + 17);
  }
  else
  {
    v5 = 0;
    v6 = 0;
  }
  v17[0] = v5;
  v17[1] = v6;
  v16[0] = v5;
  v16[1] = v6;
  v14[1] = v6;
  v15 = 0;
  v13 = 0;
  v14[0] = v5;
  v20 = v22;
  v22[0] = a2;
  v21 = 0x400000001;
  v7 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v16[0] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v15, 0);
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
  if (!mlir::mpsx::FPToIntClampedOp::isSupportedForTypes(v7, (_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8)))
  {
    v19 = *(void **)(*v20 + 24);
    mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v19, (mlir::MLIRContext *)1, 0);
  }
  v10 = (uint64_t)a3[2];
  if (v10 && mlir::RewriterBase::Listener::classof(v10))
  else
LABEL_8:
    v11 = 0;
  if (v20 != v22)
    free(v20);
  return v11;
}

uint64_t mlir::mps::`anonymous namespace'::static_dag_matcher_0(uint64_t a1, uint64_t a2, uint64_t *a3, _QWORD *a4, _QWORD *a5, uint64_t *a6, _QWORD *a7, uint64_t *a8)
{
  uint64_t v10;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t InherentAttr;
  char v20;
  uint64_t v21;
  uint64_t result;
  uint64_t v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  char v27;
  char v28;
  uint64_t v29;

  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::QuantizeOp,void>::id)
    v10 = a2;
  else
    v10 = 0;
  v29 = v10;
  if (v10)
  {
    *a6 = v10;
    *a5 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v29, 0);
    a5[1] = v16;
    *a7 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v29, 1u);
    a7[1] = v17;
    *a4 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v29, 2u);
    a4[1] = v18;
    if (*(_BYTE *)(a2 + 47) && (InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"dtype", 5), v20))
    {
      if (!InherentAttr)
      {
LABEL_11:
        v21 = *(_QWORD *)(a1 + 16);
        if (v21)
        {
          result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
          if ((_DWORD)result)
          return result;
        }
        return 0;
      }
    }
    else
    {
      InherentAttr = mlir::DictionaryAttr::get(a2 + 56, "dtype", 5uLL);
      if (!InherentAttr)
        goto LABEL_11;
    }
    if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
      goto LABEL_11;
    *a8 = InherentAttr;
    if (!*(_BYTE *)(a2 + 47) || (v24 = mlir::Operation::getInherentAttr(a2, (uint64_t)"axis", 4), !v25))
      v24 = mlir::DictionaryAttr::get(a2 + 56, "axis", 4uLL);
    if (v24)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v24 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
        v26 = v24;
      else
        v26 = 0;
    }
    else
    {
      v26 = 0;
    }
    *a3 = v26;
    return 1;
  }
  else
  {
    v23 = *(_QWORD *)(a1 + 16);
    if (!v23)
      return 0;
    result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
    if ((_DWORD)result)
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::RoundOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.round", (const unsigned __int8 *)9, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.round";
    v17[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::RoundOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

char *mlir::mps::`anonymous namespace'::getBoundDatatypeValue(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v6;
  mlir::Builder *v7;
  uint64_t IntegerType;
  uint64_t *v9;
  uint64_t Loc;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t ElementTypeOrSelf;
  uint64_t *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[2];

  v28[1] = *MEMORY[0x1E0C80C00];
  v26 = a3;
  v27 = a2;
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&v26, 8))
  {
    if (a4)
      v6 = 255;
    else
      v6 = 0;
  }
  else
  {
    mlir::Type::isInteger((mlir::Type *)&v26, 8);
    if (a4)
      v6 = 127;
    else
      v6 = -128;
  }
  v25 = v6;
  v28[0] = 1;
  v7 = (mlir::Builder *)(a1 + 8);
  IntegerType = mlir::Builder::getIntegerType(v7, 0x20u, 1);
  v9 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v28, 1, IntegerType, 0);
  Loc = mlir::Value::getLoc((mlir::Value *)&v27);
  if (!v9)
    goto LABEL_17;
  v11 = *v9;
  v12 = mlir::TypeID::get<mlir::ShapedType>();
  v13 = *(unsigned int *)(v11 + 16);
  if (!(_DWORD)v13)
    goto LABEL_17;
  v14 = *(_QWORD **)(v11 + 8);
  v15 = &v14[2 * v13];
  do
  {
    v16 = v13 >> 1;
    v17 = &v14[2 * (v13 >> 1)];
    v19 = *v17;
    v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12)
      v14 = v18;
    else
      v13 = v16;
  }
  while (v13);
  if (v14 != v15 && *v14 == v12)
    v20 = v14[1];
  else
LABEL_17:
    v20 = 0;
  v24 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v20, &v25, 4, 4, 1, 1);
  v28[0] = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v7, Loc, &v24);
  v21 = mlir::Value::getLoc((mlir::Value *)&v27);
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(v27);
  v24 = (uint64_t *)mlir::TypeAttr::get(ElementTypeOrSelf);
  return (char *)mlir::OpBuilder::create<mlir::mps::CastOp,mlir::mps::ReductionProdOp &,mlir::TypeAttr>((mlir::UnknownLoc **)v7, v21, v28, (uint64_t *)&v24)- 16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ClampOp,mlir::Value &,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.clamp", (const unsigned __int8 *)9, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.clamp";
    v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::mps::ClampOp::build((uint64_t)a1, (uint64_t)v21, *a3, *a4, *a5);
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ClampOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CastOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.cast";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::mps::QuantizeOp &,mlir::OperandRange &,mlir::TypeAttr &)::$_0>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::mps::QuantizeOp type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::mps::QuantizeOp &,mlir::OperandRange &,mlir::TypeAttr &)::$_1>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'mps.quantize' to have attribute 'dtype' of type '::mlir::TypeAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_LowerQuantize::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'input, old' failed to satisfy constraint: 'mpsx dag op for quantize not supported'");
}

void mlir::mps::`anonymous namespace'::MPS_LowerQuantizeWithMPSXQuantDAG::~MPS_LowerQuantizeWithMPSXQuantDAG(mlir::mps::_anonymous_namespace_::MPS_LowerQuantizeWithMPSXQuantDAG *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::MPS_LowerQuantizeWithMPSXQuantDAG::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerQuantizeWithMPSXQuantDAG *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t ODSResults;
  uint64_t NextResultAtOffset;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _QWORD v14[2];
  uint64_t v15;
  _QWORD v16[2];
  _QWORD v17[2];
  uint64_t v18;
  void *v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD v22[6];

  v22[4] = *MEMORY[0x1E0C80C00];
  v18 = 0;
  if ((*((_BYTE *)a2 + 46) & 0x80) != 0)
  {
    v5 = *((_QWORD *)a2 + 9);
    v6 = *((unsigned int *)a2 + 17);
  }
  else
  {
    v5 = 0;
    v6 = 0;
  }
  v17[0] = v5;
  v17[1] = v6;
  v16[0] = v5;
  v16[1] = v6;
  v14[1] = v6;
  v15 = 0;
  v13 = 0;
  v14[0] = v5;
  v20 = v22;
  v22[0] = a2;
  v21 = 0x400000001;
  v7 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(v16[0] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  ODSResults = mlir::anec::Convolution::getODSResults((mlir::anec::Convolution *)&v15, 0);
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(ODSResults, 0);
  if (mlir::mpsx::FPToIntClampedOp::isSupportedForTypes(v7, (_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8)))
  {
    v19 = *(void **)(*v20 + 24);
    mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v19, (mlir::MLIRContext *)1, 0);
  }
  v10 = (uint64_t)a3[2];
  if (v10 && mlir::RewriterBase::Listener::classof(v10))
  else
LABEL_9:
    v11 = 0;
  if (v20 != v22)
    free(v20);
  return v11;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::FPToIntClampedOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.fp_to_int_clamped", (const unsigned __int8 *)0x16, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mpsx.fp_to_int_clamped";
    v19[3] = 22;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::anec::GOC::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::FPToIntClampedOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_LowerQuantizeWithMPSXQuantDAG::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'input, old' failed to satisfy constraint: 'mpsx dag op for quantize supported'");
}

void mlir::mps::`anonymous namespace'::MPS_LowerReductionLogSumExp::~MPS_LowerReductionLogSumExp(mlir::mps::_anonymous_namespace_::MPS_LowerReductionLogSumExp *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerReductionLogSumExp::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerReductionLogSumExp *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v5;
  uint64_t InherentAttr;
  char v7;
  mlir::Operation *v8;
  uint64_t v9;
  void *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD v13[6];

  v13[4] = *MEMORY[0x1E0C80C00];
  v9 = 0;
  v11 = v13;
  v13[0] = a2;
  v12 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionLogSumExpOp,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v8 = v5;
  mlir::memref::PrefetchOp::getODSOperands((mlir::memref::PrefetchOp *)&v8, 0);
  mlir::memref::PrefetchOp::getODSOperands((mlir::memref::PrefetchOp *)&v8, 1u);
  if (*((_BYTE *)a2 + 47)
    && (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"keep_dims", 9), v7))
  {
    if (!InherentAttr)
      goto LABEL_10;
  }
  else
  {
    InherentAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "keep_dims", 9uLL);
    if (!InherentAttr)
    {
LABEL_10:
      InherentAttr = 0;
LABEL_11:
      v9 = InherentAttr;
      v10 = *(void **)(*v11 + 24);
      mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v10, (mlir::MLIRContext *)1, 0);
    }
  }
  if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    goto LABEL_11;
  goto LABEL_10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReductionMaxOp,mlir::Value &,mlir::Value &,mlir::UnitAttr,mlir::UnitAttr>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reduction_max", (const unsigned __int8 *)0x11, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.reduction_max";
    v21[3] = 17;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::ReductionMaxOp::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReductionMaxOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::LogarithmOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.logarithm", (const unsigned __int8 *)0xD, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.logarithm";
    v17[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::LogarithmOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

void mlir::mps::`anonymous namespace'::MPS_LowerRelu::~MPS_LowerRelu(mlir::mps::_anonymous_namespace_::MPS_LowerRelu *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerRelu::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerRelu *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  _QWORD v5[2];
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReluOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MaximumOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.maximum", (const unsigned __int8 *)0xB, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.maximum";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MaximumOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

void mlir::mps::`anonymous namespace'::MPS_LowerRelu6::~MPS_LowerRelu6(mlir::mps::_anonymous_namespace_::MPS_LowerRelu6 *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerRelu6::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerRelu6 *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  _QWORD v5[2];
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::Relu6Op,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReluOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.relu", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.relu";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReluOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MinimumOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.minimum", (const unsigned __int8 *)0xB, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.minimum";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MinimumOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

void mlir::mps::`anonymous namespace'::MPS_LowerReluGrad::~MPS_LowerReluGrad(mlir::mps::_anonymous_namespace_::MPS_LowerReluGrad *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerReluGrad::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerReluGrad *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  _QWORD v5[2];
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReluGradOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::GreaterThanOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.greater", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.greater";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::EqualToOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::GreaterThanOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::`anonymous namespace'::MPS_LowerSigmoidGradient::~MPS_LowerSigmoidGradient(mlir::mps::_anonymous_namespace_::MPS_LowerSigmoidGradient *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerSigmoidGradient::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerSigmoidGradient *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  _QWORD v5[2];
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SigmoidGradientOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SigmoidOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sigmoid", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.sigmoid";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SigmoidOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

void mlir::mps::`anonymous namespace'::MPS_LowerSigmoidGradientWithSigmoid::~MPS_LowerSigmoidGradientWithSigmoid(mlir::mps::_anonymous_namespace_::MPS_LowerSigmoidGradientWithSigmoid *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerSigmoidGradientWithSigmoid::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerSigmoidGradientWithSigmoid *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  _QWORD v5[2];
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SigmoidGradientWithSigmoidOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

void mlir::mps::`anonymous namespace'::MPS_LowerSigmoidHard::~MPS_LowerSigmoidHard(mlir::mps::_anonymous_namespace_::MPS_LowerSigmoidHard *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerSigmoidHard::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerSigmoidHard *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  _QWORD v5[2];
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SigmoidHardOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 2u);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MaximumOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.maximum", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.maximum";
    v17[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MaximumOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::mps::`anonymous namespace'::MPS_LowerSoftmax::~MPS_LowerSoftmax(mlir::mps::_anonymous_namespace_::MPS_LowerSoftmax *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerSoftmax::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerSoftmax *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  mlir::Operation *v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SoftmaxOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5 = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 1u);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

void mlir::mps::`anonymous namespace'::MPS_LowerSoftplusParametric::~MPS_LowerSoftplusParametric(mlir::mps::_anonymous_namespace_::MPS_LowerSoftplusParametric *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerSoftplusParametric::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerSoftplusParametric *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  _QWORD v5[2];
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[7];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SoftplusParametricOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 1u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 2u);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SoftplusOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softplus", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.softplus";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SoftplusOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

void mlir::mps::`anonymous namespace'::MPS_LowerSoftsign::~MPS_LowerSoftsign(mlir::mps::_anonymous_namespace_::MPS_LowerSoftsign *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerSoftsign::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerSoftsign *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  _QWORD v5[2];
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SoftsignOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

void mlir::mps::`anonymous namespace'::MPS_LowerSwish::~MPS_LowerSwish(mlir::mps::_anonymous_namespace_::MPS_LowerSwish *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerSwish::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerSwish *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  mlir::Operation *v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SwishOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5 = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v5, 0);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

void mlir::mps::`anonymous namespace'::MPS_LowerTruncate::~MPS_LowerTruncate(mlir::mps::_anonymous_namespace_::MPS_LowerTruncate *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

void mlir::mps::`anonymous namespace'::MPS_LowerTruncate::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_LowerTruncate *this, mlir::Operation *a2, mlir::UnknownLoc **a3)
{
  mlir::Operation *v4;
  _QWORD v5[2];
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v9[6];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = v9;
  v9[0] = a2;
  v8 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::TruncateOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v5[0] = v4;
  v5[1] = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v5, 0);
  v6 = *(void **)(*v7 + 24);
  mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v6, (mlir::MLIRContext *)1, 0);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CeilOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.ceil", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.ceil";
    v17[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CeilOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

uint64_t mlir::mps::createGPURegionFormationPass@<X0>(_BYTE *a1@<X0>, _QWORD *a2@<X8>)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;

  v4 = operator new(0x3C8uLL);
  *(_QWORD *)v5 = off_1E0E05090;
  *(_BYTE *)(v5 + 888) = *a1;
  v6 = *(_QWORD *)(v5 + 944);
  if (v6)
  {
    result = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)v6 + 48))(v6, a1);
    *a2 = v4;
  }
  else
  {
    v8 = std::__throw_bad_function_call[abi:nn180100]();
  }
  return result;
}

uint64_t mlir::mps::MPSGPURegionFormationBase<mlir::mps::`anonymous namespace'::GPURegionFormationPass>::MPSGPURegionFormationBase(uint64_t a1)
{
  _QWORD *v2;
  char v4;
  char *v5;
  __n128 v6;

  *(_QWORD *)(a1 + 16) = "builtin.module";
  *(_QWORD *)(a1 + 24) = 14;
  *(_BYTE *)(a1 + 32) = 1;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  v2 = (_QWORD *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = a1 + 200;
  *(_QWORD *)(a1 + 192) = 0x400000000;
  *(_QWORD *)(a1 + 232) = a1 + 248;
  *(_QWORD *)(a1 + 240) = 0x400000000;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0x1000000000;
  *(_QWORD *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_QWORD *)a1 = off_1E0E05100;
  v6.n128_u64[0] = (unint64_t)"Device placement hints are strict.";
  v6.n128_u64[1] = 34;
  v4 = 0;
  v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 344), (_QWORD *)(a1 + 152), (uint64_t)"strict-hints", 12, &v6, &v5);
  *(_QWORD *)(a1 + 344) = &off_1E0E4C320;
  *(_QWORD *)(a1 + 536) = &unk_1E0E4C3A0;
  v6.n128_u64[0] = (unint64_t)"Insert instrumentation for perf recording.";
  v6.n128_u64[1] = 42;
  v4 = 0;
  v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 552), v2, (uint64_t)"insert-instrumentation", 22, &v6, &v5);
  *(_QWORD *)(a1 + 552) = &off_1E0E4C320;
  *(_QWORD *)(a1 + 744) = &unk_1E0E4C3A0;
  v6.n128_u64[0] = (unint64_t)"Whether to duplicate variable creating operations for each region they are used in.";
  v6.n128_u64[1] = 83;
  v4 = 0;
  v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 760), v2, (uint64_t)"duplicate-var-operations", 24, &v6, &v5);
  *(_QWORD *)(a1 + 760) = &off_1E0E4C320;
  *(_QWORD *)(a1 + 952) = &unk_1E0E4C3A0;
  return a1;
}

void mlir::mps::`anonymous namespace'::GPURegionFormationPass::~GPURegionFormationPass(mlir::mps::_anonymous_namespace_::GPURegionFormationPass *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;
  mlir::mps::_anonymous_namespace_::GPURegionFormationPass *v7;
  uint64_t v8;
  void *v9;
  char *v10;
  mlir::mps::_anonymous_namespace_::GPURegionFormationPass *v11;
  uint64_t v12;
  void *v13;
  char *v14;

  *(_QWORD *)this = off_1E0E05100;
  *((_QWORD *)this + 95) = &unk_1E0E23520;
  v2 = (char *)this + 920;
  v3 = (char *)*((_QWORD *)this + 118);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)this + 95) = &unk_1E0E23930;
  v5 = (void *)*((_QWORD *)this + 107);
  if (v5 != *((void **)this + 106))
    free(v5);
  v6 = (char *)*((_QWORD *)this + 103);
  if (v6 != (char *)this + 840)
    free(v6);
  *((_QWORD *)this + 69) = &unk_1E0E23520;
  v7 = (mlir::mps::_anonymous_namespace_::GPURegionFormationPass *)*((_QWORD *)this + 92);
  if (v7 == (mlir::mps::_anonymous_namespace_::GPURegionFormationPass *)((char *)this + 712))
  {
    v8 = 4;
    v7 = (mlir::mps::_anonymous_namespace_::GPURegionFormationPass *)((char *)this + 712);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_15:
  *((_QWORD *)this + 69) = &unk_1E0E23930;
  v9 = (void *)*((_QWORD *)this + 81);
  if (v9 != *((void **)this + 80))
    free(v9);
  v10 = (char *)*((_QWORD *)this + 77);
  if (v10 != (char *)this + 632)
    free(v10);
  *((_QWORD *)this + 43) = &unk_1E0E23520;
  v11 = (mlir::mps::_anonymous_namespace_::GPURegionFormationPass *)*((_QWORD *)this + 66);
  if (v11 == (mlir::mps::_anonymous_namespace_::GPURegionFormationPass *)((char *)this + 504))
  {
    v12 = 4;
    v11 = (mlir::mps::_anonymous_namespace_::GPURegionFormationPass *)((char *)this + 504);
  }
  else
  {
    if (!v11)
      goto LABEL_24;
    v12 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v11 + 8 * v12))();
LABEL_24:
  *((_QWORD *)this + 43) = &unk_1E0E23930;
  v13 = (void *)*((_QWORD *)this + 55);
  if (v13 != *((void **)this + 54))
    free(v13);
  v14 = (char *)*((_QWORD *)this + 51);
  if (v14 != (char *)this + 424)
    free(v14);
  mlir::Pass::~Pass(this);
}

{
  void *v1;

  operator delete(v1);
}

const char *mlir::mps::MPSGPURegionFormationBase<mlir::mps::`anonymous namespace'::GPURegionFormationPass>::getName()
{
  return "MPSGPURegionFormation";
}

_QWORD *mlir::mps::`anonymous namespace'::GPURegionFormationPass::getDependentDialects(mlir::mps::_anonymous_namespace_::GPURegionFormationPass *this, uint64_t **a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6[0] = off_1E0E50A68;
  v7 = v6;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::placement::PlacementDialect,void>::id, "placement", 9uLL, v6);
  v3 = v7;
  if (v7 == v6)
  {
    v4 = 4;
    v3 = v6;
    goto LABEL_5;
  }
  if (v7)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return mlir::DialectRegistry::insert<mlir::mpsx::MPSXDialect,mlir::tensor::TensorDialect,mlir::scf::SCFDialect>(a2);
}

const char *mlir::mps::MPSGPURegionFormationBase<mlir::mps::`anonymous namespace'::GPURegionFormationPass>::getArgument()
{
  return "mps-gpu-region-formation";
}

const char *mlir::mps::MPSGPURegionFormationBase<mlir::mps::`anonymous namespace'::GPURegionFormationPass>::getDescription()
{
  return "Form GPU regions.";
}

void mlir::mps::`anonymous namespace'::GPURegionFormationPass::runOnOperation(mlir::mps::_anonymous_namespace_::GPURegionFormationPass *this)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  char v6;
  char v7;
  _QWORD v8[4];
  _QWORD v9[2];
  int64x2_t v10;
  char v11;
  uint64_t v12[3];
  int v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD v16[2];
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  char v28;
  char v29;
  const char **v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v2 = (_QWORD *)(*((_QWORD *)this + 5) & 0xFFFFFFFFFFFFFFF8);
  v8[0] = mlir::Attribute::getContext((mlir::Attribute *)(v2 + 3));
  v8[1] = 0;
  v3 = v2[2];
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)v2);
  v8[2] = v3;
  v8[3] = v4;
  v5 = *((_BYTE *)this + 472);
  v6 = *((_BYTE *)this + 680);
  v7 = *((_BYTE *)this + 888);
  v10 = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
  v11 = 0;
  v9[0] = off_1E0E04F48;
  v9[1] = v8;
  v12[1] = 0;
  v12[2] = 0;
  v12[0] = (uint64_t)off_1E0E2B708;
  v13 = 0;
  v18 = 0;
  v19 = 0;
  v14 = v16;
  v15 = 0;
  v16[0] = 0;
  v16[1] = 0;
  v17 = 0;
  v20 = 0;
  v21 = 16;
  v22 = 0;
  v23 = 0;
  v24 = 0x2800000000;
  v25 = 0;
  v26 = v8[0];
  v27 = v5;
  v28 = v6;
  v29 = v7;
  v30 = &v32;
  v32 = "func";
  v33 = 4;
  v31 = 0x200000001;
  mlir::ConversionTarget::setDialectAction(v12, (uint64_t)&v32, 1, 2);
  if (v30 != &v32)
    free(v30);
  mlir::OperationName::OperationName(&v30, "placement.region_call", 21, v26);
  mlir::ConversionTarget::setOpAction((uint64_t)v12, (uint64_t)v30, 2);
  mlir::OperationName::OperationName(&v30, "placement.tensor_to_memref", 26, v26);
  mlir::ConversionTarget::setOpAction((uint64_t)v12, (uint64_t)v30, 2);
  mlir::OperationName::OperationName(&v30, "placement.memref_to_tensor", 26, v26);
  mlir::ConversionTarget::setOpAction((uint64_t)v12, (uint64_t)v30, 2);
  v30 = &v32;
  v32 = "mpsx";
  v33 = 4;
  v31 = 0x200000001;
  mlir::ConversionTarget::setDialectAction(v12, (uint64_t)&v32, 1, 0);
  if (v30 != &v32)
    free(v30);
  v30 = &v32;
  v32 = "mps";
  v33 = 3;
  v31 = 0x200000001;
  mlir::ConversionTarget::setDialectAction(v12, (uint64_t)&v32, 1, 0);
  if (v30 != &v32)
    free(v30);
  v30 = &v32;
  v32 = "tensor";
  v33 = 6;
  v31 = 0x200000001;
  mlir::ConversionTarget::setDialectAction(v12, (uint64_t)&v32, 1, 2);
  if (v30 != &v32)
    free(v30);
  v30 = &v32;
  v32 = "scf";
  v33 = 3;
  v31 = 0x200000001;
  mlir::ConversionTarget::setDialectAction(v12, (uint64_t)&v32, 1, 2);
  if (v30 != &v32)
    free(v30);
  if (!mlir::collectRegions((mlir::ForwardIterator *)(*((_QWORD *)this + 5) & 0xFFFFFFFFFFFFFFF8), (uint64_t)v9, 0))*((_QWORD *)this + 5) |= 4uLL;
  v9[0] = off_1E0E04F48;
  mlir::ConversionTarget::~ConversionTarget((mlir::ConversionTarget *)v12);
}

_QWORD *mlir::mps::MPSGPURegionFormationBase<mlir::mps::`anonymous namespace'::GPURegionFormationPass>::clonePass@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _OWORD *v4;
  uint64_t v5;
  _QWORD *result;
  char v7;
  char *v8;
  __n128 v9;

  v4 = operator new(0x3C8uLL);
  v5 = *(_QWORD *)(a1 + 8);
  v4[1] = *(_OWORD *)(a1 + 16);
  *((_QWORD *)v4 + 4) = *(_QWORD *)(a1 + 32);
  *((_BYTE *)v4 + 40) = 0;
  *((_BYTE *)v4 + 120) = 0;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  *((_QWORD *)v4 + 22) = 0;
  *((_QWORD *)v4 + 23) = (char *)v4 + 200;
  *((_QWORD *)v4 + 24) = 0x400000000;
  *((_QWORD *)v4 + 29) = (char *)v4 + 248;
  *((_QWORD *)v4 + 30) = 0x400000000;
  *((_QWORD *)v4 + 35) = 0;
  *((_QWORD *)v4 + 36) = 0;
  *((_DWORD *)v4 + 74) = 0;
  *((_DWORD *)v4 + 75) = 16;
  v4[19] = 0u;
  v4[20] = 0u;
  *((_QWORD *)v4 + 42) = 0;
  *(_QWORD *)v4 = off_1E0E05100;
  *((_QWORD *)v4 + 1) = v5;
  v9.n128_u64[0] = (unint64_t)"Device placement hints are strict.";
  v9.n128_u64[1] = 34;
  v7 = 0;
  v8 = &v7;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)v4 + 43, (_QWORD *)v4 + 19, (uint64_t)"strict-hints", 12, &v9, &v8);
  *((_QWORD *)v4 + 43) = &off_1E0E4C320;
  *((_QWORD *)v4 + 67) = &unk_1E0E4C3A0;
  v9.n128_u64[0] = (unint64_t)"Insert instrumentation for perf recording.";
  v9.n128_u64[1] = 42;
  v7 = 0;
  v8 = &v7;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)v4 + 69, (_QWORD *)v4 + 19, (uint64_t)"insert-instrumentation", 22, &v9, &v8);
  *((_QWORD *)v4 + 69) = &off_1E0E4C320;
  *((_QWORD *)v4 + 93) = &unk_1E0E4C3A0;
  v9.n128_u64[0] = (unint64_t)"Whether to duplicate variable creating operations for each region they are used in.";
  v9.n128_u64[1] = 83;
  v7 = 0;
  v8 = &v7;
  result = mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)v4 + 95, (_QWORD *)v4 + 19, (uint64_t)"duplicate-var-operations", 24, &v9, &v8);
  *((_QWORD *)v4 + 95) = &off_1E0E4C320;
  *((_QWORD *)v4 + 119) = &unk_1E0E4C3A0;
  *(_QWORD *)v4 = off_1E0E05090;
  *a2 = v4;
  return result;
}

_QWORD *mlir::DialectRegistry::insert<mlir::mpsx::MPSXDialect,mlir::tensor::TensorDialect,mlir::scf::SCFDialect>(uint64_t **a1)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *result;
  uint64_t v7;
  _QWORD v8[3];
  _QWORD *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v8[0] = off_1E0E50990;
  v9 = v8;
  v2 = 4;
  mlir::DialectRegistry::insert(a1, &mlir::detail::TypeIDResolver<mlir::mpsx::MPSXDialect,void>::id, "mpsx", 4uLL, v8);
  v3 = v9;
  if (v9 == v8)
  {
    v3 = v8;
  }
  else
  {
    if (!v9)
      goto LABEL_6;
    v2 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v2))();
LABEL_6:
  v8[0] = off_1E0E50A20;
  v9 = v8;
  mlir::DialectRegistry::insert(a1, &mlir::detail::TypeIDResolver<mlir::tensor::TensorDialect,void>::id, "tensor", 6uLL, v8);
  v4 = v9;
  if (v9 == v8)
  {
    v5 = 4;
    v4 = v8;
  }
  else
  {
    if (!v9)
      goto LABEL_11;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_11:
  v8[0] = off_1E0E508B8;
  v9 = v8;
  mlir::DialectRegistry::insert(a1, &mlir::detail::TypeIDResolver<mlir::scf::SCFDialect,void>::id, "scf", 3uLL, v8);
  result = v9;
  if (v9 == v8)
  {
    v7 = 4;
    result = v8;
  }
  else
  {
    if (!v9)
      return result;
    v7 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v7))();
}

_QWORD *std::__function::__func<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = off_1E0E50A68;
  return result;
}

void std::__function::__func<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = off_1E0E50A68;
}

mlir::Dialect *std::__function::__func<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::placement::PlacementDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::operator()(uint64_t a1, _QWORD **a2)
{
  uint64_t v3;

  return mlir::MLIRContext::getOrLoadDialect(*a2, (uint64_t)"placement", 9, (uint64_t)&mlir::detail::TypeIDResolver<mlir::placement::PlacementDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::placement::PlacementDialect * mlir::MLIRContext::getOrLoadDialect<mlir::placement::PlacementDialect>(void)::{lambda(void)#1}>, (uint64_t)&v3);
}

mlir::placement::PlacementDialect *llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::placement::PlacementDialect * mlir::MLIRContext::getOrLoadDialect<mlir::placement::PlacementDialect>(void)::{lambda(void)#1}>@<X0>(mlir::MLIRContext **a1@<X0>, mlir::placement::PlacementDialect **a2@<X8>)
{
  mlir::MLIRContext *v3;
  mlir::placement::PlacementDialect *v4;
  mlir::placement::PlacementDialect *result;

  v3 = *a1;
  v4 = (mlir::placement::PlacementDialect *)operator new(0x60uLL);
  result = mlir::placement::PlacementDialect::PlacementDialect(v4, v3);
  *a2 = result;
  return result;
}

_QWORD *std::__function::__func<void mlir::DialectRegistry::insert<mlir::scf::SCFDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::scf::SCFDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = off_1E0E508B8;
  return result;
}

void std::__function::__func<void mlir::DialectRegistry::insert<mlir::scf::SCFDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::scf::SCFDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = off_1E0E508B8;
}

mlir::Dialect *std::__function::__func<void mlir::DialectRegistry::insert<mlir::scf::SCFDialect>(void)::{lambda(mlir::MLIRContext *)#1},std::allocator<void mlir::DialectRegistry::insert<mlir::scf::SCFDialect>(void)::{lambda(mlir::MLIRContext *)#1}>,mlir::Dialect * ()(mlir::MLIRContext *)>::operator()(uint64_t a1, _QWORD **a2)
{
  uint64_t v3;

  return mlir::MLIRContext::getOrLoadDialect(*a2, (uint64_t)"scf", 3, (uint64_t)&mlir::detail::TypeIDResolver<mlir::scf::SCFDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::scf::SCFDialect * mlir::MLIRContext::getOrLoadDialect<mlir::scf::SCFDialect>(void)::{lambda(void)#1}>, (uint64_t)&v3);
}

mlir::scf::SCFDialect *llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::scf::SCFDialect * mlir::MLIRContext::getOrLoadDialect<mlir::scf::SCFDialect>(void)::{lambda(void)#1}>@<X0>(mlir::MLIRContext **a1@<X0>, mlir::scf::SCFDialect **a2@<X8>)
{
  mlir::MLIRContext *v3;
  mlir::scf::SCFDialect *v4;
  mlir::scf::SCFDialect *result;

  v3 = *a1;
  v4 = (mlir::scf::SCFDialect *)operator new(0x60uLL);
  result = mlir::scf::SCFDialect::SCFDialect(v4, v3);
  *a2 = result;
  return result;
}

void mlir::mps::`anonymous namespace'::GPURegionOpCreator::~GPURegionOpCreator(mlir::mps::_anonymous_namespace_::GPURegionOpCreator *this)
{
  *(_QWORD *)this = off_1E0E04F48;
  mlir::ConversionTarget::~ConversionTarget((mlir::mps::_anonymous_namespace_::GPURegionOpCreator *)((char *)this + 40));
}

{
  *(_QWORD *)this = off_1E0E04F48;
  mlir::ConversionTarget::~ConversionTarget((mlir::mps::_anonymous_namespace_::GPURegionOpCreator *)((char *)this + 40));
}

uint64_t sub_18052838C()
{
  uint64_t v0;

  return v0;
}

void sub_1805283BC()
{
  void *v0;

  operator delete(v0);
}

uint64_t mlir::mps::`anonymous namespace'::GPURegionOpCreator::getMarkAttrID(mlir::mps::_anonymous_namespace_::GPURegionOpCreator *this)
{
  mlir::StringAttr **v1;
  const char *v3;
  __int16 v4;

  v1 = (mlir::StringAttr **)*((_QWORD *)this + 1);
  v3 = "GPU_region";
  v4 = 259;
  return mlir::Builder::getStringAttr(v1, (mlir::MLIRContext *)&v3);
}

BOOL mlir::mps::`anonymous namespace'::GPURegionOpCreator::isOpCompatible(mlir::mps::_anonymous_namespace_::GPURegionOpCreator *this, mlir::Operation *a2)
{
  unsigned __int16 v4;
  _BOOL8 v5;
  uint64_t InherentAttr;
  char v7;
  void *v8;
  BOOL v9;
  uint64_t v10;
  const void **v12;
  uint64_t v13;
  char v14[192];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = (unsigned __int16)mlir::ConversionTarget::isLegal((mlir::mps::_anonymous_namespace_::GPURegionOpCreator *)((char *)this + 40), a2);
  v5 = v4 > 0xFFu;
  if (*((_BYTE *)a2 + 47)
    && (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"device_hint", 11), v7))
  {
    if (!InherentAttr)
      return v5;
  }
  else
  {
    InherentAttr = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "device_hint", 0xBuLL);
    if (!InherentAttr)
      return v5;
  }
  v8 = *(void **)(*(_QWORD *)InherentAttr + 136);
  v9 = v8 == &mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id;
  if (v8 == &mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id)
    v10 = InherentAttr;
  else
    v10 = 0;
  v13 = v10;
  if (v9)
  {
    if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v13) == 1 && *((_BYTE *)this + 200) && v4 <= 0xFFu)
    if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v13) != 1)
      return 0;
  }
  return v5;
}

uint64_t mlir::RegionOpCreator::isOpCompatible(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::GPURegionOpCreator::isRegionProfitable()
{
  return 1;
}

mlir::GenericProgramPoint *mlir::mps::`anonymous namespace'::GPURegionOpCreator::getRegionOp(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  mlir::OpBuilder *v20;
  mlir::GenericProgramPoint *v21;
  _QWORD v23[4];
  __int16 v24;
  _QWORD v25[4];
  __int16 v26;
  std::string __p;
  _QWORD v28[2];
  uint64_t v29[2];
  _QWORD v30[2];
  uint64_t v31[2];
  _QWORD v32[3];

  v32[2] = *MEMORY[0x1E0C80C00];
  v32[0] = a6;
  v32[1] = a7;
  v31[0] = a9;
  v31[1] = a10;
  v30[0] = a11;
  v30[1] = a12;
  v29[0] = a13;
  v29[1] = a14;
  v28[0] = a15;
  v28[1] = a16;
  v24 = 773;
  v23[0] = a3;
  v23[1] = a4;
  v23[2] = "_GPU_region_";
  v25[0] = v23;
  v25[2] = &a17;
  v26 = 2818;
  llvm::Twine::str((llvm::Twine *)v25, &__p);
  v20 = *(mlir::OpBuilder **)(a1 + 8);
  v25[0] = 0;
  v25[1] = 0;
  v21 = mlir::OpBuilder::create<mlir::mpsx::GPUOp,std::string &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute>>(v20, a2, (void **)&__p.__r_.__value_.__l.__data_, a5, (uint64_t)v30, v29, (uint64_t)v32, v31, (uint64_t)v28, (uint64_t)v25);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v21;
}

mlir::FrozenRewritePatternSet *mlir::mps::`anonymous namespace'::GPURegionOpCreator::getCanonicalizationPatterns@<X0>(mlir::FrozenRewritePatternSet *a1@<X8>)
{
  return mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(a1);
}

mlir::GenericProgramPoint *mlir::mps::`anonymous namespace'::GPURegionOpCreator::getRegionTerminator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD v5[2];

  v5[0] = a3;
  v5[1] = a4;
  return mlir::OpBuilder::create<mlir::mpsx::RegionReturnOp,llvm::ArrayRef<mlir::Value> &>(*(mlir::OpBuilder **)(a1 + 8), a2, (uint64_t)v5);
}

uint64_t mlir::mps::`anonymous namespace'::GPURegionOpCreator::getBody(mlir::mps::_anonymous_namespace_::GPURegionOpCreator *this, mlir::Operation *a2)
{
  uint64_t result;

  if (!a2)
    return 0;
  result = mlir::OpInterface<mlir::FormableRegionOpInterface,mlir::detail::FormableRegionOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a2);
  if (result)
  {
    mlir::OpInterface<mlir::FormableRegionOpInterface,mlir::detail::FormableRegionOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a2);
    return *((_QWORD *)a2 + 2);
  }
  return result;
}

void mlir::mps::`anonymous namespace'::GPURegionOpCreator::getInitializedConversionTarget(mlir::mps::_anonymous_namespace_::GPURegionOpCreator *this@<X0>, mlir::ConversionTarget *a2@<X8>)
{
  mlir::ConversionTarget::ConversionTarget(a2, (mlir::mps::_anonymous_namespace_::GPURegionOpCreator *)((char *)this + 40));
}

float mlir::RegionOpCreator::computeDeviceRegionCost()
{
  return 0.0;
}

float mlir::RegionOpCreator::computeDeviceRegionCost(mlir::RegionOpCreator *this, mlir::Operation *a2)
{
  return 0.0;
}

float mlir::RegionOpCreator::computeHostRegionCost()
{
  return 0.0;
}

float mlir::RegionOpCreator::computeHostRegionCost(mlir::RegionOpCreator *this, mlir::Operation *a2)
{
  return 0.0;
}

float mlir::RegionOpCreator::computeModuleCost(mlir::RegionOpCreator *this, mlir::Operation *a2)
{
  return 0.0;
}

float mlir::RegionOpCreator::synchronizationCost(mlir::RegionOpCreator *this, mlir::Operation *a2)
{
  return 0.0;
}

BOOL mlir::mps::`anonymous namespace'::GPURegionOpCreator::replaceOutOfRegionUses(mlir::mps::_anonymous_namespace_::GPURegionOpCreator *this, mlir::Operation *a2)
{
  _BOOL8 result;
  void *v4;

  result = 1;
  if (a2 && *((_BYTE *)this + 202))
  {
    v4 = *(void **)(*((_QWORD *)a2 + 6) + 16);
    return v4 != &mlir::detail::TypeIDResolver<mlir::mps::VariableFromTensorOp,void>::id
        && v4 != &mlir::detail::TypeIDResolver<mlir::mpsx::VarHandleOp,void>::id;
  }
  return result;
}

mlir::GenericProgramPoint *mlir::mps::`anonymous namespace'::GPURegionOpCreator::getCallOp(uint64_t a1, uint64_t a2, mlir::SymbolRefAttr *a3, uint64_t a4, uint64_t a5)
{
  mlir::MLIRContext **v5;
  int v7;
  mlir::SymbolRefAttr *v8;
  uint64_t v9[3];

  v9[2] = *MEMORY[0x1E0C80C00];
  v9[0] = a4;
  v9[1] = a5;
  v8 = a3;
  v5 = *(mlir::MLIRContext ***)(a1 + 8);
  v7 = 0;
  return mlir::OpBuilder::create<mlir::placement::RegionCall,mlir::Operation *&,mlir::placement::RegionType,mlir::ValueRange &>(v5, a2, &v8, &v7, v9);
}

uint64_t mlir::RegionOpCreator::getHostReshape()
{
  return 0;
}

uint64_t mlir::RegionOpCreator::getHostCast()
{
  return 0;
}

uint64_t *mlir::RegionOpCreator::getConvertedType(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t *v8;
  _QWORD *v9;
  unint64_t v10;

  if (a2)
  {
    v3 = *a2;
    v4 = mlir::TypeID::get<mlir::ShapedType>();
    v5 = *(unsigned int *)(v3 + 16);
    if ((_DWORD)v5)
    {
      v6 = *(_QWORD **)(v3 + 8);
      do
      {
        v7 = v5 >> 1;
        v8 = &v6[2 * (v5 >> 1)];
        v10 = *v8;
        v9 = v8 + 2;
        v5 += ~(v5 >> 1);
        if (v10 < v4)
          v6 = v9;
        else
          v5 = v7;
      }
      while (v5);
    }
  }
  return a2;
}

uint64_t mlir::RegionOpCreator::getPromotedType(uint64_t a1, uint64_t a2)
{
  return a2;
}

void mlir::RegionOpCreator::getPromotedTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)(a4 + 8) = 0;
  v13 = a2;
  v14 = 0;
  if (a3)
  {
    v8 = 0;
    v9 = (void *)(a4 + 16);
    do
    {
      v10 = mlir::ValueRange::dereference_iterator(&v13, v8);
      v11 = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)a1 + 184))(a1, *(_QWORD *)(v10 + 8) & 0xFFFFFFFFFFFFFFF8);
      v12 = *(unsigned int *)(a4 + 8);
      if (v12 >= *(unsigned int *)(a4 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4, v9, v12 + 1, 8);
        v12 = *(unsigned int *)(a4 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a4 + 8 * v12) = v11;
      ++*(_DWORD *)(a4 + 8);
      v8 = ++v14;
    }
    while (v13 != a2 || v8 != a3);
  }
}

{
  uint64_t v8;
  void *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;

  *(_DWORD *)(a4 + 8) = 0;
  if (a3)
  {
    v8 = 0;
    v9 = (void *)(a4 + 16);
    do
    {
      v10 = mlir::TypeRange::dereference_iterator(a2, v8);
      v11 = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)a1 + 184))(a1, v10);
      v12 = *(unsigned int *)(a4 + 8);
      if (v12 >= *(unsigned int *)(a4 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4, v9, v12 + 1, 8);
        v12 = *(unsigned int *)(a4 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a4 + 8 * v12) = v11;
      ++*(_DWORD *)(a4 + 8);
      ++v8;
    }
    while (a3 != v8);
  }
}

uint64_t mlir::mps::`anonymous namespace'::GPURegionOpCreator::insertInstrumentation(mlir::mps::_anonymous_namespace_::GPURegionOpCreator *this)
{
  return *((unsigned __int8 *)this + 201);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::GPUOp,std::string &,mlir::IRMapping &,mlir::ValueRange &,mlir::TypeRange &,mlir::ValueRange &,mlir::TypeRange &,llvm::ArrayRef<mlir::Operation *> &,llvm::ArrayRef<mlir::NamedAttribute>>(mlir::OpBuilder *a1, uint64_t a2, void **a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t *a8, uint64_t a9, uint64_t a10)
{
  uint64_t *Context;
  uint64_t v19;
  char v20;
  int v21;
  int v22;
  void *v23;
  uint64_t v24;
  mlir::GenericProgramPoint *v25;
  mlir::GenericProgramPoint *v26;
  uint64_t v28;
  const char *v29;
  __int16 v30;
  uint64_t v31[4];
  __int16 v32;
  _QWORD v33[40];

  v33[38] = *MEMORY[0x1E0C80C00];
  v28 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
  v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.gpu", (const unsigned __int8 *)8, Context);
  if (!v20)
  {
    v32 = 1283;
    v31[2] = (uint64_t)"mpsx.gpu";
    v31[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v30 = 259;
    llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
    llvm::report_fatal_error((llvm::Twine *)v33, 1);
  }
  mlir::OperationState::OperationState(v33, a2, v19);
  v22 = *((char *)a3 + 23);
  if (v22 >= 0)
    v23 = a3;
  else
    v23 = *a3;
  if (v22 >= 0)
    v24 = *((unsigned __int8 *)a3 + 23);
  else
    v24 = (uint64_t)a3[1];
  mlir::mpsx::ANEOp::build((uint64_t)a1, (uint64_t)v33, v23, v24, a4, *(void **)a5, *(_QWORD *)(a5 + 8), v21, *a6, a6[1], *(_QWORD **)a7, *(_QWORD *)(a7 + 8), *a8, a8[1], *(mlir::Operation ***)a9, *(_QWORD *)(a9 + 8), *(void **)a10, *(_QWORD *)(a10 + 8));
  v25 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v33);
  if (*(_UNKNOWN **)(*((_QWORD *)v25 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::GPUOp,void>::id)
    v26 = v25;
  else
    v26 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v33);
  return v26;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mpsx::RegionReturnOp,llvm::ArrayRef<mlir::Value> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  unint64_t v17[2];
  _QWORD v18[39];

  v18[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mpsx.region_return", (const unsigned __int8 *)0x12, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mpsx.region_return";
    v15[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a3, *(_QWORD *)(a3 + 8));
  mlir::anec::RegionReturn::build((uint64_t)a1, (uint64_t)v18, v17[0], v17[1]);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mpsx::RegionReturnOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

uint64_t mlir::OpInterface<mlir::FormableRegionOpInterface,mlir::detail::FormableRegionOpInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  BOOL v3;
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v1 = *(_QWORD *)(a1 + 48);
  v2 = *(void **)(v1 + 16);
  v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
    v4 = 0;
  else
    v4 = *(_QWORD *)(a1 + 48);
  if (v3)
  {
    v21 = *(_QWORD *)(v1 + 8);
    result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v21);
    if (result)
    {
      v19 = result;
      v20 = mlir::TypeID::get<mlir::FormableRegionOpInterface>();
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v19 + 104))(v19, v20, v1);
    }
  }
  else
  {
    v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    v7 = mlir::TypeID::get<mlir::FormableRegionOpInterface>();
    v8 = *(unsigned int *)(v6 + 40);
    if (!(_DWORD)v8)
      goto LABEL_14;
    v9 = *(_QWORD **)(v6 + 32);
    v10 = &v9[2 * v8];
    do
    {
      v11 = v8 >> 1;
      v12 = &v9[2 * (v8 >> 1)];
      v14 = *v12;
      v13 = v12 + 2;
      v8 += ~(v8 >> 1);
      if (v14 < v7)
        v9 = v13;
      else
        v8 = v11;
    }
    while (v8);
    if (v9 == v10 || *v9 != v7 || (result = v9[1]) == 0)
    {
LABEL_14:
      v16 = *(_QWORD *)(v6 + 24);
      v17 = *(_QWORD *)(a1 + 48);
      v18 = mlir::TypeID::get<mlir::FormableRegionOpInterface>();
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v16 + 104))(v16, v18, v17);
    }
  }
  return result;
}

void mlir::ConversionTarget::ConversionTarget(mlir::ConversionTarget *this, const mlir::ConversionTarget *a2)
{
  *(_QWORD *)this = off_1E0E2B708;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  llvm::deallocate_buffer(0, 0);
}

void sub_180528E24()
{
  uint64_t v0;
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  void *buffer;

  v3 = *(unsigned int *)(v1 + 24);
  *(_DWORD *)(v0 + 24) = v3;
  if ((_DWORD)v3)
  {
    buffer = llvm::allocate_buffer(16 * v3, (std::align_val_t)8uLL);
    *(_QWORD *)(v0 + 8) = buffer;
    *(_QWORD *)(v0 + 16) = *(_QWORD *)(v1 + 16);
    memcpy(buffer, *(const void **)(v1 + 8), 16 * *(unsigned int *)(v0 + 24));
  }
  else
  {
    *v2 = 0;
    v2[1] = 0;
  }
  *(_QWORD *)(v0 + 32) = v0 + 48;
  *(_QWORD *)(v0 + 40) = 0;
  if (*(_DWORD *)(v1 + 40))
    llvm::SmallVectorImpl<std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>>::operator=(v0 + 32, (unsigned int *)(v1 + 32));
  *(_QWORD *)(v0 + 48) = 0;
  *(_QWORD *)(v0 + 56) = 0;
  *(_DWORD *)(v0 + 64) = 0;
  llvm::DenseMap<mlir::OperationName,std::function<std::optional<BOOL> ()(mlir::Operation *)>,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,std::function<std::optional<BOOL> ()(mlir::Operation *)>>>::copyFrom(v0 + 48);
}

_QWORD *sub_180528E90()
{
  _QWORD *v0;
  uint64_t *v1;
  uint64_t *v2;

  llvm::StringMap<mlir::ConversionTarget::LegalizationAction,llvm::MallocAllocator>::StringMap((llvm::StringMapImpl *)(v0 + 9), v1 + 9);
  llvm::StringMap<std::function<std::optional<BOOL> ()(mlir::Operation *)>,llvm::MallocAllocator>::StringMap((llvm::StringMapImpl *)(v0 + 12), v1 + 12);
  v2 = (uint64_t *)v1[18];
  if (v2)
  {
    if (v2 == v1 + 15)
    {
      v0[18] = v0 + 15;
      (*(void (**)(uint64_t))(*(_QWORD *)v1[18] + 24))(v1[18]);
    }
    else
    {
      v0[18] = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
    }
  }
  else
  {
    v0[18] = 0;
  }
  v0[19] = v1[19];
  return v0;
}

uint64_t llvm::SmallVectorImpl<std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>>::operator=(uint64_t a1, unsigned int *a2)
{
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t j;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  int v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;
  _QWORD *v26;
  int v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  _QWORD *i;
  _QWORD *v41;
  uint64_t v42;
  _QWORD v43[3];
  _QWORD *v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if ((unsigned int *)a1 == a2)
    return a1;
  v4 = a2[2];
  v5 = *(unsigned int *)(a1 + 8);
  if (v5 >= v4)
  {
    if ((_DWORD)v4)
    {
      v10 = *(_QWORD *)a2 + 48 * v4;
      v11 = *(_QWORD **)a1;
      v12 = (_QWORD *)(*(_QWORD *)a2 + 16);
      while (1)
      {
        v15 = v11;
        v16 = v12 - 2;
        *v11 = *(v12 - 2);
        v17 = *((_DWORD *)v12 - 2);
        *((_BYTE *)v15 + 12) = *((_BYTE *)v12 - 4);
        *((_DWORD *)v15 + 2) = v17;
        v18 = (_QWORD *)v12[3];
        if (v18)
        {
          if (v12 == v18)
          {
            v44 = v43;
            (*(void (**)(_QWORD *, _QWORD *))(*v12 + 24))(v12, v43);
          }
          else
          {
            v44 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v18 + 16))(v18);
          }
        }
        else
        {
          v44 = 0;
        }
        std::__function::__value_func<void ()(long long const&)>::swap[abi:nn180100](v43, v15 + 2);
        v13 = v44;
        if (v44 == v43)
        {
          v13 = v43;
          v14 = 4;
        }
        else
        {
          if (!v44)
            goto LABEL_16;
          v14 = 5;
        }
        (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_16:
        v12 += 6;
        v11 = v15 + 6;
        if (v16 + 6 == (_QWORD *)v10)
        {
          v19 = v15 + 6;
          v20 = *(_QWORD **)a1;
          LODWORD(v5) = *(_DWORD *)(a1 + 8);
          goto LABEL_52;
        }
      }
    }
    v20 = *(_QWORD **)a1;
    v19 = *(_QWORD **)a1;
LABEL_52:
    for (i = &v20[6 * v5]; ; i -= 6)
    {
      if (i == v19)
        goto LABEL_42;
      v41 = (_QWORD *)*(i - 1);
      if (i - 4 == v41)
        break;
      if (v41)
      {
        v42 = 5;
        goto LABEL_54;
      }
LABEL_55:
      ;
    }
    v41 = i - 4;
    v42 = 4;
LABEL_54:
    (*(void (**)(void))(*v41 + 8 * v42))();
    goto LABEL_55;
  }
  if (*(_DWORD *)(a1 + 12) < v4)
  {
    if ((_DWORD)v5)
    {
      v6 = *(_QWORD **)a1;
      for (j = 6 * v5; j * 8; j -= 6)
      {
        v8 = (_QWORD *)v6[j - 1];
        if (&v6[j - 4] == v8)
        {
          v8 = &v6[j - 4];
          v9 = 4;
        }
        else
        {
          if (!v8)
            continue;
          v9 = 5;
        }
        (*(void (**)(void))(*v8 + 8 * v9))();
      }
    }
    *(_DWORD *)(a1 + 8) = 0;
    llvm::SmallVectorTemplateBase<std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>,false>::grow(a1, v4);
    goto LABEL_40;
  }
  if ((_DWORD)v5)
  {
    v21 = *(_QWORD *)a2 + 48 * v5;
    v22 = *(_QWORD **)a1;
    v23 = (_QWORD *)(*(_QWORD *)a2 + 16);
    while (1)
    {
      v26 = v23 - 2;
      *v22 = *(v23 - 2);
      v27 = *((_DWORD *)v23 - 2);
      *((_BYTE *)v22 + 12) = *((_BYTE *)v23 - 4);
      *((_DWORD *)v22 + 2) = v27;
      v28 = (_QWORD *)v23[3];
      if (v28)
      {
        if (v23 == v28)
        {
          v44 = v43;
          (*(void (**)(_QWORD *, _QWORD *))(*v23 + 24))(v23, v43);
        }
        else
        {
          v44 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v28 + 16))(v28);
        }
      }
      else
      {
        v44 = 0;
      }
      v29 = v22 + 2;
      std::__function::__value_func<void ()(long long const&)>::swap[abi:nn180100](v43, v29);
      v24 = v44;
      if (v44 == v43)
      {
        v24 = v43;
        v25 = 4;
      }
      else
      {
        if (!v44)
          goto LABEL_30;
        v25 = 5;
      }
      (*(void (**)(void))(*v24 + 8 * v25))();
LABEL_30:
      v23 += 6;
      v22 = v29 + 4;
      if (v26 + 6 == (_QWORD *)v21)
        goto LABEL_41;
    }
  }
LABEL_40:
  v5 = 0;
LABEL_41:
  v30 = a2[2];
  if (v5 != v30)
  {
    v32 = *(_QWORD *)a2;
    v33 = *(_QWORD **)a1;
    v34 = 48 * v5;
    v35 = 48 * v30;
    do
    {
      v36 = &v33[(unint64_t)v34 / 8];
      v37 = v32 + v34;
      *v36 = *(_QWORD *)(v32 + v34);
      v38 = *(_DWORD *)(v32 + v34 + 8);
      *((_BYTE *)v36 + 12) = *(_BYTE *)(v32 + v34 + 12);
      *((_DWORD *)v36 + 2) = v38;
      v39 = *(_QWORD *)(v32 + v34 + 40);
      if (v39)
      {
        if (v37 + 16 == v39)
        {
          v33[(unint64_t)v34 / 8 + 5] = v36 + 2;
          (*(void (**)(_QWORD))(**(_QWORD **)(v37 + 40) + 24))(*(_QWORD *)(v37 + 40));
        }
        else
        {
          v33[(unint64_t)v34 / 8 + 5] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v39 + 16))(v39);
        }
      }
      else
      {
        v36[5] = 0;
      }
      v33 += 6;
      v35 -= 48;
      v32 += 48;
    }
    while (v34 != v35);
  }
LABEL_42:
  *(_DWORD *)(a1 + 8) = v4;
  return a1;
}

void llvm::SmallVectorTemplateBase<std::pair<mlir::OperationName,mlir::ConversionTarget::LegalizationInfo>,false>::grow(uint64_t a1, unint64_t a2)
{
  _QWORD *v3;
  char *v4;
  char *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  int v17;
  unint64_t v18;

  v18 = 0;
  v3 = (_QWORD *)(a1 + 16);
  v4 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 48, &v18);
  v5 = v4;
  v6 = *(_QWORD **)a1;
  v7 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v7)
  {
    v8 = v4 + 40;
    v9 = 48 * v7;
    v10 = v6 + 5;
    do
    {
      *(v8 - 5) = *(v10 - 5);
      v11 = *((_DWORD *)v10 - 8);
      *((_BYTE *)v8 - 28) = *((_BYTE *)v10 - 28);
      *((_DWORD *)v8 - 8) = v11;
      v12 = (_QWORD *)*v10;
      if (*v10)
      {
        if (v10 - 3 == v12)
        {
          *v8 = v8 - 3;
          (*(void (**)(_QWORD))(*(_QWORD *)*v10 + 24))(*v10);
        }
        else
        {
          *v8 = v12;
          *v10 = 0;
        }
      }
      else
      {
        *v8 = 0;
      }
      v8 += 6;
      v10 += 6;
      v9 -= 48;
    }
    while (v9);
    v6 = *(_QWORD **)a1;
    v13 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v13)
    {
      v14 = 6 * v13;
      while (1)
      {
        v15 = (_QWORD *)v6[v14 - 1];
        if (&v6[v14 - 4] == v15)
        {
          v15 = &v6[v14 - 4];
          v16 = 4;
        }
        else
        {
          if (!v15)
            goto LABEL_13;
          v16 = 5;
        }
        (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_13:
        v14 -= 6;
        if (!(v14 * 8))
        {
          v6 = *(_QWORD **)a1;
          break;
        }
      }
    }
  }
  v17 = v18;
  if (v6 != v3)
    free(v6);
  *(_QWORD *)a1 = v5;
  *(_DWORD *)(a1 + 12) = v17;
}

void llvm::DenseMap<mlir::OperationName,std::function<std::optional<BOOL> ()(mlir::Operation *)>,llvm::DenseMapInfo<mlir::OperationName,void>,llvm::detail::DenseMapPair<mlir::OperationName,std::function<std::optional<BOOL> ()(mlir::Operation *)>>>::copyFrom(uint64_t a1)
{
  uint64_t v2;
  llvm *v3;
  _QWORD **v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *(unsigned int *)(a1 + 16);
  v3 = *(llvm **)a1;
  if (!(_DWORD)v2)
  {
    v8 = 0;
LABEL_12:
    llvm::deallocate_buffer(v3, (void *)v8);
  }
  v4 = (_QWORD **)((char *)v3 + 32);
  v5 = 40 * v2;
  while (1)
  {
    if (((unint64_t)*(v4 - 4) | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      v6 = *v4;
      if (v4 - 3 == *v4)
      {
        v6 = v4 - 3;
        v7 = 4;
      }
      else
      {
        if (!v6)
          goto LABEL_5;
        v7 = 5;
      }
      (*(void (**)(void))(*v6 + 8 * v7))();
    }
LABEL_5:
    v4 += 5;
    v5 -= 40;
    if (!v5)
    {
      v3 = *(llvm **)a1;
      v8 = 40 * *(unsigned int *)(a1 + 16);
      goto LABEL_12;
    }
  }
}

llvm::StringMapImpl *llvm::StringMap<mlir::ConversionTarget::LegalizationAction,llvm::MallocAllocator>::StringMap(llvm::StringMapImpl *this, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  size_t v12;
  char *buffer;
  char *v14;
  char *v15;
  int v16;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0x1000000000;
  if (*((_DWORD *)a2 + 3))
  {
    llvm::StringMapImpl::init(this, *((_DWORD *)a2 + 2));
    v4 = *(_QWORD *)this;
    v5 = *((unsigned int *)this + 2);
    v6 = *a2;
    *(_QWORD *)((char *)this + 12) = *(uint64_t *)((char *)a2 + 12);
    if ((_DWORD)v5)
    {
      v7 = 0;
      v8 = v4 + 8 * v5 + 8;
      v9 = v6 + 8 * v5 + 8;
      do
      {
        v10 = *(_QWORD *)(*a2 + 8 * v7);
        if (v10)
          v11 = v10 == -8;
        else
          v11 = 1;
        if (v11)
        {
          *(_QWORD *)(*(_QWORD *)this + 8 * v7) = v10;
        }
        else
        {
          v12 = *(_QWORD *)v10;
          buffer = (char *)llvm::allocate_buffer(*(_QWORD *)v10 + 17, (std::align_val_t)8uLL);
          v14 = buffer;
          v15 = buffer + 16;
          if (v12)
            memcpy(buffer + 16, (const void *)(v10 + 16), v12);
          v15[v12] = 0;
          *(_QWORD *)v14 = v12;
          v16 = *(_DWORD *)(v10 + 8);
          *(_QWORD *)(*(_QWORD *)this + 8 * v7) = v14;
          *((_DWORD *)v14 + 2) = v16;
          *(_DWORD *)(v8 + 4 * v7) = *(_DWORD *)(v9 + 4 * v7);
        }
        ++v7;
      }
      while (v5 != v7);
    }
  }
  return this;
}

llvm::StringMapImpl *llvm::StringMap<std::function<std::optional<BOOL> ()(mlir::Operation *)>,llvm::MallocAllocator>::StringMap(llvm::StringMapImpl *this, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t *v9;
  BOOL v10;
  size_t v11;
  size_t *v12;
  _QWORD *buffer;
  size_t *v14;
  char *v15;
  _QWORD *v16;
  size_t v17;
  uint64_t v19;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0x2800000000;
  if (*((_DWORD *)a2 + 3))
  {
    llvm::StringMapImpl::init(this, *((_DWORD *)a2 + 2));
    v4 = *(_QWORD *)this;
    v5 = *((unsigned int *)this + 2);
    v6 = *a2;
    *(_QWORD *)((char *)this + 12) = *(uint64_t *)((char *)a2 + 12);
    if ((_DWORD)v5)
    {
      v7 = 0;
      v19 = v4 + 8 * v5 + 8;
      v8 = v6 + 8 * v5 + 8;
      do
      {
        v9 = *(size_t **)(*a2 + 8 * v7);
        if (v9)
          v10 = v9 + 1 == 0;
        else
          v10 = 1;
        if (v10)
        {
          *(_QWORD *)(*(_QWORD *)this + 8 * v7) = v9;
        }
        else
        {
          v12 = v9 + 1;
          v11 = *v9;
          buffer = llvm::allocate_buffer(*v9 + 41, (std::align_val_t)8uLL);
          v14 = buffer;
          v15 = (char *)(buffer + 5);
          if (v11)
            memcpy(buffer + 5, v9 + 5, v11);
          v15[v11] = 0;
          *v14 = v11;
          v16 = v14 + 1;
          v17 = v9[4];
          if (v17)
          {
            if ((size_t *)v17 == v12)
            {
              v14[4] = (size_t)v16;
              (*(void (**)(size_t *))(*v12 + 24))(v9 + 1);
            }
            else
            {
              v14[4] = (*(uint64_t (**)(size_t, _QWORD *))(*(_QWORD *)v17 + 16))(v17, v16);
            }
          }
          else
          {
            v14[4] = 0;
          }
          *(_QWORD *)(*(_QWORD *)this + 8 * v7) = v14;
          *(_DWORD *)(v19 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        }
        ++v7;
      }
      while (v5 != v7);
    }
  }
  return this;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::placement::RegionCall,mlir::Operation *&,mlir::placement::RegionType,mlir::ValueRange &>(mlir::MLIRContext **a1, uint64_t a2, mlir::SymbolRefAttr **a3, int *a4, uint64_t *a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[39];

  v21[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"placement.region_call", (const unsigned __int8 *)0x15, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"placement.region_call";
    v19[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v11);
  mlir::placement::RegionCall::build(a1, (uint64_t)v21, *a3, *a4, *a5, a5[1]);
  v13 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::placement::RegionCall,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t mlir::RegionOpCreator::replaceOutOfRegionUses(mlir::RegionOpCreator *this, mlir::Operation *a2)
{
  return 1;
}

_OWORD *mlir::detail::FunctionOpInterfaceTrait<mlir::func::FuncOp>::addEntryBlock(mlir::func::FuncOp *a1)
{
  _OWORD *v2;
  unint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t Inputs;
  unint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  int64x2_t v12;
  int64x2_t *v13;
  unint64_t v14;
  unint64_t v16[2];
  void *FunctionType;
  uint64_t v18;
  _QWORD v19[7];

  v19[6] = *MEMORY[0x1E0C80C00];
  v2 = operator new(0x48uLL);
  *v2 = 0u;
  v2[1] = 0u;
  *((_QWORD *)v2 + 4) = v2 + 2;
  *((_QWORD *)v2 + 5) = v2 + 2;
  *((_QWORD *)v2 + 7) = 0;
  *((_QWORD *)v2 + 8) = 0;
  *((_QWORD *)v2 + 6) = 0;
  v3 = *(unsigned int *)(*(_QWORD *)a1 + 44);
  if ((v3 & 0x7FFFFF) != 0)
    v4 = (uint64_t *)(((*(_QWORD *)a1 + 16 * ((v3 >> 23) & 1) + ((v3 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                   + 32 * *(unsigned int *)(*(_QWORD *)a1 + 40));
  else
    v4 = 0;
  llvm::ilist_traits<mlir::Block>::addNodeToList((uint64_t)v4, (uint64_t)v2);
  v5 = *v4;
  *((_QWORD *)v2 + 1) = *v4;
  *((_QWORD *)v2 + 2) = v4;
  *(_QWORD *)(v5 + 8) = (char *)v2 + 8;
  *v4 = (uint64_t)v2 + 8;
  FunctionType = (void *)mlir::func::FuncOp::getFunctionType(a1);
  Inputs = mlir::FunctionType::getInputs((mlir::FunctionType *)&FunctionType);
  v8 = v6;
  v9 = *(_QWORD *)(*(_QWORD *)a1 + 24);
  FunctionType = v19;
  v18 = 0x600000000;
  if (v6 < 7)
  {
    if (v6)
    {
      v19[0] = v9;
      if (v6 != 1)
      {
        v19[1] = v9;
        if (v6 != 2)
        {
          v19[2] = v9;
          if (v6 != 3)
          {
            v19[3] = v9;
            if (v6 != 4)
            {
              v19[4] = v9;
              if (v6 != 5)
                v19[5] = v9;
            }
          }
        }
      }
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&FunctionType, v19, v6, 8);
    v10 = (unint64_t *)((char *)FunctionType + 8 * (v8 & 0xFFFFFFFFFFFFFFFCLL));
    v11 = v8 & 3;
    v12 = vdupq_n_s64(v9);
    v13 = (int64x2_t *)((char *)FunctionType + 16);
    v14 = v8 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v13[-1] = v12;
      *v13 = v12;
      v13 += 2;
      v14 -= 4;
    }
    while (v14);
    if (v8 != (v8 & 0xFFFFFFFFFFFFFFFCLL))
    {
      do
      {
        *v10++ = v9;
        --v11;
      }
      while (v11);
    }
  }
  LODWORD(v18) = v8;
  mlir::ValueRange::ValueRange(v16, Inputs, v8);
  mlir::Block::addArguments(v2, v16[0], v16[1], (uint64_t)FunctionType, v18);
  if (FunctionType != v19)
    free(FunctionType);
  return v2;
}

void OUTLINED_FUNCTION_0_0(uint64_t a1@<X0>, const void ***a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4;

  *(_QWORD *)a1 = a4;
  *(_WORD *)(a1 + 32) = 259;
  mlir::Operation::emitOpError(a3, a2, v4);
}

double mlir::mps::createRefineDynamicShapeInfoPass@<D0>(_QWORD *a1@<X8>)
{
  _OWORD *v3;
  double result;

  v3 = operator new(0x178uLL);
  result = 0.0;
  v3[2] = 0u;
  v3[3] = 0u;
  v3[4] = 0u;
  v3[5] = 0u;
  v3[6] = 0u;
  v3[7] = 0u;
  v3[8] = 0u;
  v3[9] = 0u;
  v3[10] = 0u;
  v3[11] = 0u;
  v3[12] = 0u;
  v3[13] = 0u;
  v3[14] = 0u;
  v3[15] = 0u;
  v3[16] = 0u;
  v3[17] = 0u;
  v3[18] = 0u;
  v3[19] = 0u;
  v3[22] = 0u;
  *((_QWORD *)v3 + 46) = 0;
  *((_QWORD *)v3 + 2) = "func.func";
  *((_QWORD *)v3 + 3) = 9;
  *((_BYTE *)v3 + 32) = 1;
  v3[8] = 0u;
  v3[9] = 0u;
  v3[10] = 0u;
  *((_QWORD *)v3 + 22) = 0;
  *((_QWORD *)v3 + 23) = (char *)v3 + 200;
  *((_QWORD *)v3 + 29) = (char *)v3 + 248;
  *((_DWORD *)v3 + 49) = 4;
  *((_DWORD *)v3 + 61) = 4;
  *((_QWORD *)v3 + 35) = 0;
  *((_QWORD *)v3 + 36) = 0;
  *((_QWORD *)v3 + 37) = 0x1000000000;
  v3[19] = 0u;
  v3[20] = 0u;
  v3[20] = 0u;
  v3[21] = 0u;
  *(_QWORD *)v3 = off_1E0E49B88;
  *((_QWORD *)v3 + 42) = 0;
  *((_QWORD *)v3 + 43) = 0;
  *((_DWORD *)v3 + 92) = 0;
  *((_QWORD *)v3 + 44) = 0;
  *((_QWORD *)v3 + 45) = 0;
  *a1 = v3;
  return result;
}

void mlir::mps::`anonymous namespace'::RefineDynamicShapes::~RefineDynamicShapes(llvm **this)
{
  *this = (llvm *)off_1E0E49B88;
  llvm::deallocate_buffer(this[44], (void *)(16 * *((unsigned int *)this + 92)));
}

{
  *this = (llvm *)off_1E0E49B88;
  llvm::deallocate_buffer(this[44], (void *)(16 * *((unsigned int *)this + 92)));
}

void sub_180529C78(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  mlir::Pass *v12;

  mlir::Pass::~Pass(v12);
}

void sub_180529CB8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  mlir::Pass *v12;
  void *v13;

  mlir::Pass::~Pass(v12);
  operator delete(v13);
}

const char *mlir::mps::MPSRefineDynamicShapesBase<mlir::mps::`anonymous namespace'::RefineDynamicShapes>::getName()
{
  return "MPSRefineDynamicShapes";
}

const char *mlir::mps::MPSRefineDynamicShapesBase<mlir::mps::`anonymous namespace'::RefineDynamicShapes>::getArgument()
{
  return "mps-refine-dynamic-shapes";
}

const char *mlir::mps::MPSRefineDynamicShapesBase<mlir::mps::`anonymous namespace'::RefineDynamicShapes>::getDescription()
{
  return "Refine dynamic shape info to enable more stitching";
}

uint64_t mlir::mps::`anonymous namespace'::RefineDynamicShapes::runOnOperation(mlir::mps::_anonymous_namespace_::RefineDynamicShapes *this)
{
  unsigned int *v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  uint64_t *inserted;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *ArgAttrsAttr;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t *v22;
  int v23;
  BOOL v24;
  unsigned int v25;
  uint64_t v27;
  _QWORD v28[2];

  v2 = (unsigned int *)(*((_QWORD *)this + 5) & 0xFFFFFFFFFFFFFFF8);
  v3 = v2[11];
  if ((v3 & 0x7FFFFF) != 0)
    v4 = (_QWORD *)((((unint64_t)&v2[4 * ((v3 >> 23) & 1) + 16] + ((v3 >> 21) & 0x7F8)) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * v2[10]);
  else
    v4 = 0;
  if ((_QWORD *)*v4 != v4)
  {
    v5 = v4[1];
    v6 = v5 ? v5 - 8 : 0;
    v7 = *(uint64_t **)(v6 + 48);
    v8 = *(uint64_t **)(v6 + 56);
    if (v8 != v7)
    {
      while (1)
      {
        v16 = *v7;
        v28[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(_QWORD *)(*v7 + 8) & 0xFFFFFFFFFFFFFFF8));
        v28[1] = v17;
        if (!v28[0])
          goto LABEL_13;
        if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v28))
        {
          ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v28);
          if (!v19)
            goto LABEL_13;
          v20 = 8 * v19;
          while (*ArgAttrsAttr != 0x8000000000000000)
          {
            ++ArgAttrsAttr;
            v20 -= 8;
            if (!v20)
              goto LABEL_13;
          }
        }
        v9 = *((_QWORD *)this + 43);
        *((_QWORD *)this + 43) = v9 + 1;
        v27 = v16;
        v10 = *((_DWORD *)this + 92);
        if (!v10)
          break;
        v11 = *((_QWORD *)this + 44);
        v12 = v10 - 1;
        v13 = v12 & ((v16 >> 4) ^ (v16 >> 9));
        inserted = (uint64_t *)(v11 + 16 * v13);
        v15 = *inserted;
        if (*inserted != v16)
        {
          v22 = 0;
          v23 = 1;
          while (v15 != -4096)
          {
            if (v22)
              v24 = 0;
            else
              v24 = v15 == -8192;
            if (v24)
              v22 = inserted;
            v25 = v13 + v23++;
            v13 = v25 & v12;
            inserted = (uint64_t *)(v11 + 16 * v13);
            v15 = *inserted;
            if (*inserted == v16)
              goto LABEL_12;
          }
          if (v22)
            v21 = v22;
          else
            v21 = inserted;
          goto LABEL_22;
        }
LABEL_12:
        inserted[1] = v9;
LABEL_13:
        if (++v7 == v8)
          goto LABEL_35;
      }
      v21 = 0;
LABEL_22:
      inserted = llvm::DenseMapBase<llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>,void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::InsertIntoBucket<void *>((uint64_t)this + 352, v21, &v27);
      goto LABEL_12;
    }
  }
LABEL_35:
  v28[0] = this;
}

double mlir::mps::MPSRefineDynamicShapesBase<mlir::mps::`anonymous namespace'::RefineDynamicShapes>::clonePass@<D0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  double result;

  v2 = operator new(0x178uLL);
  v2[2] = "func.func";
  v2[3] = 9;
  *((_BYTE *)v2 + 32) = 1;
  *((_BYTE *)v2 + 40) = 0;
  *((_BYTE *)v2 + 120) = 0;
  result = 0.0;
  *((_OWORD *)v2 + 8) = 0u;
  *((_OWORD *)v2 + 9) = 0u;
  *((_OWORD *)v2 + 10) = 0u;
  v2[22] = 0;
  v2[23] = v2 + 25;
  v2[24] = 0x400000000;
  v2[29] = v2 + 31;
  v2[30] = 0x400000000;
  v2[35] = 0;
  v2[36] = 0;
  v2[37] = 0x1000000000;
  *((_OWORD *)v2 + 19) = 0u;
  *((_OWORD *)v2 + 20) = 0u;
  *v2 = off_1E0E49B88;
  *((_DWORD *)v2 + 92) = 0;
  v2[42] = 0;
  v2[43] = 0;
  v2[44] = 0;
  v2[45] = 0;
  *a1 = v2;
  return result;
}

uint64_t *llvm::DenseMapBase<llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>,void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::InsertIntoBucket<void *>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6;
  unsigned int v7;
  uint64_t v8;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t *v13;
  int v14;
  BOOL v15;
  unsigned int v16;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
LABEL_3:
    v8 = *a2;
    goto LABEL_4;
  }
  llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::grow(a1, v7);
  v8 = *a3;
  v10 = *(_DWORD *)(a1 + 16) - 1;
  v11 = ((*a3 >> 4) ^ (*a3 >> 9)) & v10;
  a2 = (uint64_t *)(*(_QWORD *)a1 + 16 * v11);
  v12 = *a2;
  if (*a3 != *a2)
  {
    v13 = 0;
    v14 = 1;
    while (v12 != -4096)
    {
      if (v13)
        v15 = 0;
      else
        v15 = v12 == -8192;
      if (v15)
        v13 = a2;
      v16 = v11 + v14++;
      v11 = v16 & v10;
      a2 = (uint64_t *)(*(_QWORD *)a1 + 16 * (v16 & v10));
      v12 = *a2;
      if (v8 == *a2)
        goto LABEL_4;
    }
    if (v13)
      a2 = v13;
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -4096)
    --*(_DWORD *)(a1 + 12);
  *a2 = *a3;
  a2[1] = 0;
  return a2;
}

_QWORD *llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  llvm *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  _QWORD *result;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  int v15;
  int v16;
  llvm *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  _QWORD *v28;
  int v29;
  BOOL v30;
  unsigned int v31;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(llvm **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  v10 = result;
  *(_QWORD *)a1 = result;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v11 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v11)
    {
      if (((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
        goto LABEL_39;
      v12 = ((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
      v10 = &result[2 * (v12 & 0x1FFFFFFFFFFFFFFELL)];
      v13 = result + 2;
      v14 = v12 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(v13 - 2) = -4096;
        *v13 = -4096;
        v13 += 4;
        v14 -= 2;
      }
      while (v14);
      if (v12 != (v12 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_39:
        do
        {
          *v10 = -4096;
          v10 += 2;
        }
        while (v10 != &result[2 * v11]);
      }
    }
    if ((_DWORD)v3)
    {
      v15 = 0;
      v16 = v11 - 1;
      v17 = v4;
      do
      {
        v25 = *(_QWORD *)v17;
        if ((*(_QWORD *)v17 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          v26 = ((v25 >> 4) ^ (v25 >> 9)) & v16;
          v23 = (_QWORD *)(*(_QWORD *)a1 + 16 * v26);
          v27 = *v23;
          if (v25 != *v23)
          {
            v28 = 0;
            v29 = 1;
            while (v27 != -4096)
            {
              if (v28)
                v30 = 0;
              else
                v30 = v27 == -8192;
              if (v30)
                v28 = v23;
              v31 = v26 + v29++;
              v26 = v31 & v16;
              v23 = (_QWORD *)(*(_QWORD *)a1 + 16 * (v31 & v16));
              v27 = *v23;
              if (v25 == *v23)
                goto LABEL_23;
            }
            if (v28)
              v23 = v28;
          }
LABEL_23:
          v24 = *((_QWORD *)v17 + 1);
          *v23 = v25;
          v23[1] = v24;
          *(_DWORD *)(a1 + 8) = ++v15;
        }
        v17 = (llvm *)((char *)v17 + 16);
      }
      while (v17 != (llvm *)((char *)v4 + 16 * v3));
    }
    llvm::deallocate_buffer(v4, (void *)(16 * v3));
  }
  *(_QWORD *)(a1 + 8) = 0;
  v18 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v18)
  {
    if (((v18 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0)
      goto LABEL_18;
    v19 = ((v18 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    v10 = &result[2 * (v19 & 0x1FFFFFFFFFFFFFFELL)];
    v20 = result + 2;
    v21 = v19 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v20 - 2) = -4096;
      *v20 = -4096;
      v20 += 4;
      v21 -= 2;
    }
    while (v21);
    if (v19 != (v19 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_18:
      v22 = &result[2 * v18];
      do
      {
        *v10 = -4096;
        v10 += 2;
      }
      while (v10 != v22);
    }
  }
  return result;
}

uint64_t llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<mlir::mps::`anonymous namespace'::RefineDynamicShapes::runOnOperation(void)::$_0>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t NextResultAtOffset;
  int hasDynamicShapes;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t InterfaceFor;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  uint64_t *inserted;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  int v26;
  uint64_t *v27;
  uint64_t *v28;
  int v29;
  BOOL v30;
  unsigned int v31;
  int v32;
  mlir::detail::OpResultImpl *v33;
  char *v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int v46;
  unsigned int v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t *v50;
  int v51;
  BOOL v52;
  unsigned int v53;
  uint64_t *v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  int v58;
  unsigned int v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t *v62;
  int v63;
  BOOL v64;
  unsigned int v65;
  uint64_t *v66;
  int v67;
  uint64_t v68;
  int v69;
  unsigned int v70;
  uint64_t *v71;
  uint64_t v72;
  uint64_t *v73;
  int v74;
  BOOL v75;
  unsigned int v76;
  uint64_t *v77;
  uint64_t v78;
  BOOL v79;
  mlir::UnitAttr *Context;
  mlir::MLIRContext *v81;
  uint64_t v82;
  mlir::StringAttr *v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  int v88;
  unsigned int v89;
  uint64_t *v90;
  uint64_t v91;
  uint64_t *v92;
  int v93;
  BOOL v94;
  unsigned int v95;
  uint64_t *v96;
  unint64_t v97;
  char *v98;
  char *v100;
  mlir::detail::OpResultImpl *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106[4];
  __int16 v107;
  void *v108;
  unsigned int v109;
  _QWORD v110[10];

  v110[8] = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned int *)(a2 + 36);
  v3 = a2 - 16;
  if ((_DWORD)v2)
    v4 = a2 - 16;
  else
    v4 = 0;
  if (!(_DWORD)v2)
    return 1;
  v6 = 0;
  v7 = *a1;
  v8 = v2 - 1;
  do
  {
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, v6);
    if ((hasDynamicShapes & 1) != 0)
      break;
    v30 = v8 == v6++;
  }
  while (!v30);
  if (!hasDynamicShapes)
    return 1;
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0 && (v11 = *(unsigned int *)(a2 + 68), (_DWORD)v11))
  {
    v12 = 0;
    v13 = (uint64_t *)(*(_QWORD *)(a2 + 72) + 24);
    do
    {
      v14 = *v13;
      v13 += 4;
      --v11;
    }
    while (v11);
  }
  else
  {
    v12 = 0;
  }
  if (!mlir::OpInterface<mlir::MapDynamicShapeOpInterface,mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits>::getInterfaceFor(a2))
  {
    v104 = 0;
    v105 = 0;
LABEL_20:
    v16 = *(unsigned int *)(a2 + 36);
    if ((_DWORD)v16)
      v17 = v3;
    else
      v17 = 0;
    if (!(_DWORD)v16)
      return 1;
    v18 = 0;
    while (1)
    {
      v24 = (void *)mlir::detail::OpResultImpl::getNextResultAtOffset(v17, v18);
        goto LABEL_27;
      v25 = *(_QWORD *)(v7 + 344);
      *(_QWORD *)(v7 + 344) = v25 + 1;
      v108 = v24;
      v26 = *(_DWORD *)(v7 + 368);
      if (!v26)
        break;
      v19 = *(_QWORD *)(v7 + 352);
      v20 = v26 - 1;
      v21 = v20 & ((v24 >> 4) ^ (v24 >> 9));
      inserted = (uint64_t *)(v19 + 16 * v21);
      v23 = *inserted;
      if (v24 != (void *)*inserted)
      {
        v28 = 0;
        v29 = 1;
        while (v23 != -4096)
        {
          if (v28)
            v30 = 0;
          else
            v30 = v23 == -8192;
          if (v30)
            v28 = inserted;
          v31 = v21 + v29++;
          v21 = v31 & v20;
          inserted = (uint64_t *)(v19 + 16 * v21);
          v23 = *inserted;
          if (v24 == (void *)*inserted)
            goto LABEL_26;
        }
        if (v28)
          v27 = v28;
        else
          v27 = inserted;
        goto LABEL_31;
      }
LABEL_26:
      inserted[1] = v25;
LABEL_27:
      if (++v18 == v16)
        return 1;
    }
    v27 = 0;
LABEL_31:
    inserted = llvm::DenseMapBase<llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>,void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::InsertIntoBucket<void *>(v7 + 352, v27, (uint64_t *)&v108);
    goto LABEL_26;
  }
  if (a2)
    InterfaceFor = mlir::OpInterface<mlir::MapDynamicShapeOpInterface,mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
  else
    InterfaceFor = 0;
  v104 = a2;
  v105 = InterfaceFor;
  if (!a2)
    goto LABEL_20;
  mlir::MapDynamicShapeOpInterface::mapDynamicShape((uint64_t *)&v108, (mlir::MapDynamicShapeOpInterface *)&v104);
  v32 = *(_DWORD *)(a2 + 36);
  if (v32)
    v33 = (mlir::detail::OpResultImpl *)v3;
  else
    v33 = 0;
  v101 = v33;
  v102 = *(unsigned int *)(a2 + 36);
  v34 = (char *)v108;
  v35 = v109;
  if (v32 && v109)
  {
    v36 = 0;
    v103 = v7 + 352;
    v100 = (char *)v108 + 64 * (unint64_t)v109;
    while (1)
    {
      v37 = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v101, v36);
      v38 = *((unsigned int *)v34 + 2);
      if (!(_DWORD)v38)
        goto LABEL_124;
      v39 = v37;
      v40 = *(_QWORD **)v34;
      v41 = *(_QWORD *)v34 + 8 * v38;
      v42 = -1;
      while (*v40 != -1)
      {
        v43 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 32 * *v40 + 24);
          goto LABEL_55;
        v106[0] = v43;
        v44 = *(_DWORD *)(v7 + 368);
        if (v44)
        {
          v45 = *(_QWORD *)(v7 + 352);
          v46 = v44 - 1;
          v47 = v46 & ((v43 >> 4) ^ (v43 >> 9));
          v48 = (uint64_t *)(v45 + 16 * v47);
          v49 = *v48;
          if (v43 == *v48)
            goto LABEL_71;
          v50 = 0;
          v51 = 1;
          while (v49 != -4096)
          {
            if (v50)
              v52 = 0;
            else
              v52 = v49 == -8192;
            if (v52)
              v50 = v48;
            v53 = v47 + v51++;
            v47 = v53 & v46;
            v48 = (uint64_t *)(v45 + 16 * v47);
            v49 = *v48;
            if (v43 == *v48)
              goto LABEL_71;
          }
          if (v50)
            v54 = v50;
          else
            v54 = v48;
        }
        else
        {
          v54 = 0;
        }
        v48 = llvm::DenseMapBase<llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>,void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::InsertIntoBucket<void *>(v103, v54, v106);
LABEL_71:
        if (v42 == -1)
        {
          v42 = v48[1];
        }
        else if (v42 != v48[1])
        {
          v85 = *(_QWORD *)(v7 + 344);
          *(_QWORD *)(v7 + 344) = v85 + 1;
          v106[0] = v39;
          v86 = *(_DWORD *)(v7 + 368);
          if (v86)
          {
            v87 = *(_QWORD *)(v7 + 352);
            v88 = v86 - 1;
            v89 = v88 & ((v39 >> 4) ^ (v39 >> 9));
            v90 = (uint64_t *)(v87 + 16 * v89);
            v91 = *v90;
            if (v39 != *v90)
            {
              v92 = 0;
              v93 = 1;
              while (v91 != -4096)
              {
                if (v92)
                  v94 = 0;
                else
                  v94 = v91 == -8192;
                if (v94)
                  v92 = v90;
                v95 = v89 + v93++;
                v89 = v95 & v88;
                v90 = (uint64_t *)(v87 + 16 * v89);
                v91 = *v90;
                if (v39 == *v90)
                  goto LABEL_123;
              }
              if (v92)
                v96 = v92;
              else
                v96 = v90;
LABEL_122:
              v90 = llvm::DenseMapBase<llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>,void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::InsertIntoBucket<void *>(v103, v96, v106);
            }
LABEL_123:
            v90[1] = v85;
            goto LABEL_124;
          }
          v96 = 0;
          goto LABEL_122;
        }
LABEL_55:
        if (++v40 == (_QWORD *)v41)
          goto LABEL_91;
      }
      v55 = *(_QWORD *)(v7 + 344);
      *(_QWORD *)(v7 + 344) = v55 + 1;
      v106[0] = v39;
      v56 = *(_DWORD *)(v7 + 368);
      if (!v56)
      {
        v66 = 0;
        goto LABEL_89;
      }
      v57 = *(_QWORD *)(v7 + 352);
      v58 = v56 - 1;
      v59 = v58 & ((v39 >> 4) ^ (v39 >> 9));
      v60 = (uint64_t *)(v57 + 16 * v59);
      v61 = *v60;
      if (v39 != *v60)
      {
        v62 = 0;
        v63 = 1;
        while (v61 != -4096)
        {
          if (v62)
            v64 = 0;
          else
            v64 = v61 == -8192;
          if (v64)
            v62 = v60;
          v65 = v59 + v63++;
          v59 = v65 & v58;
          v60 = (uint64_t *)(v57 + 16 * v59);
          v61 = *v60;
          if (v39 == *v60)
            goto LABEL_90;
        }
        if (v62)
          v66 = v62;
        else
          v66 = v60;
LABEL_89:
        v60 = llvm::DenseMapBase<llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>,void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::InsertIntoBucket<void *>(v103, v66, v106);
      }
LABEL_90:
      v60[1] = v55;
LABEL_91:
      if (v42 == -1)
        goto LABEL_124;
      v106[0] = v39;
      v67 = *(_DWORD *)(v7 + 368);
      if (!v67)
      {
        v77 = 0;
        goto LABEL_104;
      }
      v68 = *(_QWORD *)(v7 + 352);
      v69 = v67 - 1;
      v70 = v69 & ((v39 >> 4) ^ (v39 >> 9));
      v71 = (uint64_t *)(v68 + 16 * v70);
      v72 = *v71;
      if (v39 != *v71)
      {
        v73 = 0;
        v74 = 1;
        while (v72 != -4096)
        {
          if (v73)
            v75 = 0;
          else
            v75 = v72 == -8192;
          if (v75)
            v73 = v71;
          v76 = v70 + v74++;
          v70 = v76 & v69;
          v71 = (uint64_t *)(v68 + 16 * v70);
          v72 = *v71;
          if (v39 == *v71)
            goto LABEL_105;
        }
        if (v73)
          v77 = v73;
        else
          v77 = v71;
LABEL_104:
        v71 = llvm::DenseMapBase<llvm::DenseMap<void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>,void *,long long,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,long long>>::InsertIntoBucket<void *>(v103, v77, v106);
      }
LABEL_105:
      v71[1] = v42;
      v78 = mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>>();
      if ((*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 48) + 32))(*(_QWORD *)(a2 + 48), v78))
        v79 = v12 < 2;
      else
        v79 = 1;
      if (!v79)
      {
        Context = (mlir::UnitAttr *)mlir::Attribute::getContext((mlir::Attribute *)((*(_QWORD *)(v7 + 40) & 0xFFFFFFFFFFFFFFF8)
                                                                                  + 24));
        v82 = mlir::UnitAttr::get(Context, v81);
        v83 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
        v107 = 261;
        v106[0] = (uint64_t)"__no_dynamic_broadcast";
        v106[1] = 22;
        v84 = mlir::StringAttr::get(v83, (mlir::MLIRContext *)v106);
        mlir::Operation::setAttr(a2, v84, v82);
      }
LABEL_124:
      if (++v36 != v102)
      {
        v34 += 64;
        if (v34 != v100)
          continue;
      }
      v34 = (char *)v108;
      v35 = v109;
      break;
    }
  }
  if (v35)
  {
    v97 = (unint64_t)v35 << 6;
    do
    {
      v98 = *(char **)&v34[v97 - 64];
      if (&v34[v97 - 48] != v98)
        free(v98);
      v97 -= 64;
    }
    while (v97);
    v34 = (char *)v108;
  }
  if (v34 != (char *)v110)
    free(v34);
  return 1;
}

uint64_t mlir::mps::`anonymous namespace'::hasDynamicShapes(uint64_t a1)
{
  uint64_t *i;
  uint64_t v2;
  BOOL v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t *ArgAttrsAttr;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  _QWORD v12[2];

  for (i = (uint64_t *)(*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFF8); i; i = (uint64_t *)i[1])
  {
    v2 = *(_QWORD *)(*i + 136);
    if (v2 != mlir::TypeID::get<mlir::mpsx::ListType>())
      break;
  }
  v4 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible(i);
  v12[0] = v4;
  v12[1] = v5;
  if (v4)
  {
    if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v12))
      goto LABEL_16;
    if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v12))
    {
      v3 = 1;
      return (v4 != 0) & v3;
    }
    ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v12);
    if (v7)
    {
      v8 = 8 * v7 - 8;
      do
      {
        v9 = *ArgAttrsAttr++;
        v3 = v9 == 0x8000000000000000;
        v10 = v9 == 0x8000000000000000 || v8 == 0;
        v8 -= 8;
      }
      while (!v10);
    }
    else
    {
LABEL_16:
      v3 = 0;
    }
  }
  return (v4 != 0) & v3;
}

uint64_t mlir::OpInterface<mlir::MapDynamicShapeOpInterface,mlir::detail::MapDynamicShapeOpInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  BOOL v3;
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  __guard v18;
  uint64_t v19;
  __guard v20;
  uint64_t v21;

  v1 = *(_QWORD *)(a1 + 48);
  v2 = *(void **)(v1 + 16);
  v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
    v4 = 0;
  else
    v4 = *(_QWORD *)(a1 + 48);
  if (v3)
  {
    v21 = *(_QWORD *)(v1 + 8);
    result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v21);
    if (result)
    {
      v19 = result;
      v20 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
      return (*(uint64_t (**)(uint64_t, __guard, uint64_t))(*(_QWORD *)v19 + 104))(v19, v20, v1);
    }
  }
  else
  {
    v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    v7 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
    v8 = *(unsigned int *)(v6 + 40);
    if (!(_DWORD)v8)
      goto LABEL_14;
    v9 = *(_QWORD **)(v6 + 32);
    v10 = &v9[2 * v8];
    do
    {
      v11 = v8 >> 1;
      v12 = &v9[2 * (v8 >> 1)];
      v14 = *v12;
      v13 = v12 + 2;
      v8 += ~(v8 >> 1);
      if (v14 < v7)
        v9 = v13;
      else
        v8 = v11;
    }
    while (v8);
    if (v9 == v10 || *v9 != v7 || (result = v9[1]) == 0)
    {
LABEL_14:
      v16 = *(_QWORD *)(v6 + 24);
      v17 = *(_QWORD *)(a1 + 48);
      v18 = mlir::TypeID::get<mlir::MapDynamicShapeOpInterface>();
      return (*(uint64_t (**)(uint64_t, __guard, uint64_t))(*(_QWORD *)v16 + 104))(v16, v18, v17);
    }
  }
  return result;
}

__guard mlir::TypeID::get<mlir::mpsx::ListType>()
{
  unsigned __int8 v0;
  __guard *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  if ((v0 & 1) == 0)
  {
    if (v3)
    {
      v11 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mpsx::ListType]";
      v12 = 70;
      v4 = llvm::StringRef::find((uint64_t *)&v11, "DesiredTypeName = ", 0x12uLL, 0);
      if (v12 >= v4)
        v5 = v4;
      else
        v5 = v12;
      v6 = &v11[v5];
      v7 = v12 - v5;
      if (v12 - v5 >= 0x12)
        v8 = 18;
      else
        v8 = v12 - v5;
      v9 = v7 - v8;
      if (v9 >= v9 - 1)
        v10 = v9 - 1;
      else
        v10 = v9;
      mlir::detail::TypeIDResolver<mlir::mpsx::ListType,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v6[v8], v10);
    }
  }
  return v1[130];
}

uint64_t mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>>()
{
  unsigned __int8 v0;
  uint64_t *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;
  const char *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;

  v1 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v0 & 1) == 0)
  {
    v1 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    if (v3)
    {
      v11 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ResultsBroadcastableShape<Empty>]";
      v12 = 97;
      v4 = llvm::StringRef::find((uint64_t *)&v11, "DesiredTypeName = ", 0x12uLL, 0);
      if (v12 >= v4)
        v5 = v4;
      else
        v5 = v12;
      v6 = &v11[v5];
      v7 = v12 - v5;
      if (v12 - v5 >= 0x12)
        v8 = 18;
      else
        v8 = v12 - v5;
      v9 = v7 - v8;
      if (v9 >= v9 - 1)
        v10 = v9 - 1;
      else
        v10 = v9;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v6[v8], v10);
      v1 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  return v1[204];
}

uint64_t mlir::mps::createRuntimeCanonicalizationPass@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _BYTE *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;

  v4 = operator new(0x498uLL);
  *(_QWORD *)v5 = off_1E0E4AF50;
  *(_BYTE *)(v5 + 472) = *(_BYTE *)a1;
  v6 = *(_QWORD *)(v5 + 528);
  if (!v6)
    goto LABEL_6;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 48))(v6, a1);
  v4[680] = *(_BYTE *)(a1 + 1);
  v7 = *((_QWORD *)v4 + 92);
  if (!v7)
    goto LABEL_6;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 48))(v7, a1 + 1);
  *((_DWORD *)v4 + 222) = *(_DWORD *)(a1 + 4);
  v8 = *((_QWORD *)v4 + 118);
  if (!v8)
    goto LABEL_6;
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 48))(v8, a1 + 4);
  v10 = *(_BYTE *)(a1 + 8);
  v9 = a1 + 8;
  v4[1096] = v10;
  v11 = *((_QWORD *)v4 + 144);
  if (v11)
  {
    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v11 + 48))(v11, v9);
    *a2 = v4;
  }
  else
  {
LABEL_6:
    v13 = std::__throw_bad_function_call[abi:nn180100]();
  }
  return result;
}

uint64_t mlir::mps::MPSRuntimeCanonicalizationBase<mlir::mps::`anonymous namespace'::RuntimeCanonicalizationPass>::MPSRuntimeCanonicalizationBase(uint64_t a1)
{
  _QWORD *v2;
  int v4;
  int *v5;
  __n128 v6;

  *(_QWORD *)(a1 + 16) = "func.func";
  *(_QWORD *)(a1 + 24) = 9;
  *(_BYTE *)(a1 + 32) = 1;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  v2 = (_QWORD *)(a1 + 152);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = a1 + 200;
  *(_QWORD *)(a1 + 192) = 0x400000000;
  *(_QWORD *)(a1 + 232) = a1 + 248;
  *(_QWORD *)(a1 + 240) = 0x400000000;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0x1000000000;
  *(_QWORD *)(a1 + 336) = 0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_QWORD *)a1 = off_1E0E4BCB0;
  v6.n128_u64[0] = (unint64_t)"Enables the folding of a matmul RHS input, where RHS is a transpose of a constant.";
  v6.n128_u64[1] = 82;
  LOBYTE(v4) = 0;
  v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 344), (_QWORD *)(a1 + 152), (uint64_t)"enable-matmul-nt-to-nn-fold", 27, &v6, (_BYTE **)&v5);
  *(_QWORD *)(a1 + 344) = &off_1E0E4C320;
  *(_QWORD *)(a1 + 536) = &unk_1E0E4C3A0;
  v6.n128_u64[0] = (unint64_t)"Use legacy quantization patterns";
  v6.n128_u64[1] = 32;
  LOBYTE(v4) = 1;
  v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 552), v2, (uint64_t)"legacy-quantization", 19, &v6, (_BYTE **)&v5);
  *(_QWORD *)(a1 + 552) = &off_1E0E4C320;
  *(_QWORD *)(a1 + 744) = &unk_1E0E4C3A0;
  v6.n128_u64[0] = (unint64_t)"Maximum number of inputs supported by MPS quantization kernels.";
  v6.n128_u64[1] = 63;
  v4 = 32;
  v5 = &v4;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((_QWORD *)(a1 + 760), v2, (uint64_t)"quant-ops-max-inputs-count", 26, &v6, &v5);
  *(_QWORD *)(a1 + 760) = off_1E0E4C3E0;
  *(_QWORD *)(a1 + 952) = &unk_1E0E4C460;
  v6.n128_u64[0] = (unint64_t)"Enables the canonicalization of 2D (de)convolutions to matmuls.";
  v6.n128_u64[1] = 63;
  LOBYTE(v4) = 0;
  v5 = &v4;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)(a1 + 968), v2, (uint64_t)"enable-conv2d-to-matmul", 23, &v6, (_BYTE **)&v5);
  *(_QWORD *)(a1 + 968) = &off_1E0E4C320;
  *(_QWORD *)(a1 + 1160) = &unk_1E0E4C3A0;
  return a1;
}

void mlir::mps::`anonymous namespace'::RuntimeCanonicalizationPass::~RuntimeCanonicalizationPass(mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;
  mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *v7;
  uint64_t v8;
  void *v9;
  char *v10;
  mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *v11;
  uint64_t v12;
  void *v13;
  char *v14;
  mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *v15;
  uint64_t v16;
  void *v17;
  char *v18;

  *(_QWORD *)this = off_1E0E4BCB0;
  *((_QWORD *)this + 121) = &unk_1E0E23520;
  v2 = (char *)this + 1128;
  v3 = (char *)*((_QWORD *)this + 144);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  *((_QWORD *)this + 121) = &unk_1E0E23930;
  v5 = (void *)*((_QWORD *)this + 133);
  if (v5 != *((void **)this + 132))
    free(v5);
  v6 = (char *)*((_QWORD *)this + 129);
  if (v6 != (char *)this + 1048)
    free(v6);
  *((_QWORD *)this + 95) = &unk_1E0E23658;
  v7 = (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)*((_QWORD *)this + 118);
  if (v7 == (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)((char *)this + 920))
  {
    v8 = 4;
    v7 = (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)((char *)this + 920);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_15:
  *((_QWORD *)this + 95) = &unk_1E0E23930;
  v9 = (void *)*((_QWORD *)this + 107);
  if (v9 != *((void **)this + 106))
    free(v9);
  v10 = (char *)*((_QWORD *)this + 103);
  if (v10 != (char *)this + 840)
    free(v10);
  *((_QWORD *)this + 69) = &unk_1E0E23520;
  v11 = (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)*((_QWORD *)this + 92);
  if (v11 == (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)((char *)this + 712))
  {
    v12 = 4;
    v11 = (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)((char *)this + 712);
  }
  else
  {
    if (!v11)
      goto LABEL_24;
    v12 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v11 + 8 * v12))();
LABEL_24:
  *((_QWORD *)this + 69) = &unk_1E0E23930;
  v13 = (void *)*((_QWORD *)this + 81);
  if (v13 != *((void **)this + 80))
    free(v13);
  v14 = (char *)*((_QWORD *)this + 77);
  if (v14 != (char *)this + 632)
    free(v14);
  *((_QWORD *)this + 43) = &unk_1E0E23520;
  v15 = (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)*((_QWORD *)this + 66);
  if (v15 == (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)((char *)this + 504))
  {
    v16 = 4;
    v15 = (mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *)((char *)this + 504);
  }
  else
  {
    if (!v15)
      goto LABEL_33;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_33:
  *((_QWORD *)this + 43) = &unk_1E0E23930;
  v17 = (void *)*((_QWORD *)this + 55);
  if (v17 != *((void **)this + 54))
    free(v17);
  v18 = (char *)*((_QWORD *)this + 51);
  if (v18 != (char *)this + 424)
    free(v18);
  mlir::Pass::~Pass(this);
}

{
  void *v1;

  operator delete(v1);
}

const char *mlir::mps::MPSRuntimeCanonicalizationBase<mlir::mps::`anonymous namespace'::RuntimeCanonicalizationPass>::getName()
{
  return "MPSRuntimeCanonicalization";
}

_QWORD *mlir::mps::MPSRuntimeCanonicalizationBase<mlir::mps::`anonymous namespace'::RuntimeCanonicalizationPass>::getDependentDialects(int a1, uint64_t **a2)
{
  uint64_t v2;
  _QWORD *result;
  _QWORD v4[3];
  _QWORD *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4[0] = off_1E0E50990;
  v5 = v4;
  v2 = 4;
  mlir::DialectRegistry::insert(a2, &mlir::detail::TypeIDResolver<mlir::mpsx::MPSXDialect,void>::id, "mpsx", 4uLL, v4);
  result = v5;
  if (v5 == v4)
  {
    result = v4;
  }
  else
  {
    if (!v5)
      return result;
    v2 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v2))();
}

const char *mlir::mps::MPSRuntimeCanonicalizationBase<mlir::mps::`anonymous namespace'::RuntimeCanonicalizationPass>::getArgument()
{
  return "mps-runtime-canonicalization";
}

const char *mlir::mps::MPSRuntimeCanonicalizationBase<mlir::mps::`anonymous namespace'::RuntimeCanonicalizationPass>::getDescription()
{
  return "Canonicalize operations as required by the MPS runtime for execution.";
}

void mlir::mps::`anonymous namespace'::RuntimeCanonicalizationPass::runOnOperation(mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *this)
{
}

_QWORD *mlir::mps::MPSRuntimeCanonicalizationBase<mlir::mps::`anonymous namespace'::RuntimeCanonicalizationPass>::clonePass@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _OWORD *v4;
  uint64_t v5;
  _QWORD *result;
  int v7;
  int *v8;
  __n128 v9;

  v4 = operator new(0x498uLL);
  v5 = *(_QWORD *)(a1 + 8);
  v4[1] = *(_OWORD *)(a1 + 16);
  *((_QWORD *)v4 + 4) = *(_QWORD *)(a1 + 32);
  *((_BYTE *)v4 + 40) = 0;
  *((_BYTE *)v4 + 120) = 0;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  *((_QWORD *)v4 + 22) = 0;
  *((_QWORD *)v4 + 23) = (char *)v4 + 200;
  *((_QWORD *)v4 + 24) = 0x400000000;
  *((_QWORD *)v4 + 29) = (char *)v4 + 248;
  *((_QWORD *)v4 + 30) = 0x400000000;
  *((_QWORD *)v4 + 35) = 0;
  *((_QWORD *)v4 + 36) = 0;
  *((_DWORD *)v4 + 74) = 0;
  *((_DWORD *)v4 + 75) = 16;
  v4[19] = 0u;
  v4[20] = 0u;
  *((_QWORD *)v4 + 42) = 0;
  *(_QWORD *)v4 = off_1E0E4BCB0;
  *((_QWORD *)v4 + 1) = v5;
  v9.n128_u64[0] = (unint64_t)"Enables the folding of a matmul RHS input, where RHS is a transpose of a constant.";
  v9.n128_u64[1] = 82;
  LOBYTE(v7) = 0;
  v8 = &v7;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)v4 + 43, (_QWORD *)v4 + 19, (uint64_t)"enable-matmul-nt-to-nn-fold", 27, &v9, (_BYTE **)&v8);
  *((_QWORD *)v4 + 43) = &off_1E0E4C320;
  *((_QWORD *)v4 + 67) = &unk_1E0E4C3A0;
  v9.n128_u64[0] = (unint64_t)"Use legacy quantization patterns";
  v9.n128_u64[1] = 32;
  LOBYTE(v7) = 1;
  v8 = &v7;
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)v4 + 69, (_QWORD *)v4 + 19, (uint64_t)"legacy-quantization", 19, &v9, (_BYTE **)&v8);
  *((_QWORD *)v4 + 69) = &off_1E0E4C320;
  *((_QWORD *)v4 + 93) = &unk_1E0E4C3A0;
  v9.n128_u64[0] = (unint64_t)"Maximum number of inputs supported by MPS quantization kernels.";
  v9.n128_u64[1] = 63;
  v7 = 32;
  v8 = &v7;
  mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>((_QWORD *)v4 + 95, (_QWORD *)v4 + 19, (uint64_t)"quant-ops-max-inputs-count", 26, &v9, &v8);
  *((_QWORD *)v4 + 95) = off_1E0E4C3E0;
  *((_QWORD *)v4 + 119) = &unk_1E0E4C460;
  v9.n128_u64[0] = (unint64_t)"Enables the canonicalization of 2D (de)convolutions to matmuls.";
  v9.n128_u64[1] = 63;
  LOBYTE(v7) = 0;
  v8 = &v7;
  result = mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>((_QWORD *)v4 + 121, (_QWORD *)v4 + 19, (uint64_t)"enable-conv2d-to-matmul", 23, &v9, (_BYTE **)&v8);
  *((_QWORD *)v4 + 121) = &off_1E0E4C320;
  *((_QWORD *)v4 + 145) = &unk_1E0E4C3A0;
  *(_QWORD *)v4 = off_1E0E4AF50;
  *a2 = v4;
  return result;
}

_QWORD *mlir::detail::PassOptions::Option<unsigned int,llvm::cl::parser<unsigned int>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>(_QWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4, __n128 *a5, int **a6)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t *v20;
  char *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t *v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  const void **v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  _QWORD v35[2];
  _QWORD v36[3];
  _QWORD *v37;
  const void *v38[3];
  const void **v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v35[0] = a3;
  v35[1] = a4;
  v38[0] = a2;
  v8 = llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>((uint64_t)a1, (uint64_t)v35, v38, a5, a6);
  *(_QWORD *)(v8 + 192) = &unk_1E0E4E208;
  v9 = v8 + 192;
  *(_BYTE *)(v8 + 200) = 0;
  *(_QWORD *)v8 = off_1E0E4E188;
  v11 = (uint64_t *)a2[21];
  v10 = a2[22];
  v12 = v11;
  if ((unint64_t)v11 >= v10)
  {
    v14 = (uint64_t *)a2[20];
    v15 = v11 - v14;
    v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61)
      abort();
    v17 = v10 - (_QWORD)v14;
    if (v17 >> 2 > v16)
      v16 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v16;
    if (v18)
    {
      if (v18 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v19 = (char *)operator new(8 * v18);
    }
    else
    {
      v19 = 0;
    }
    v20 = (uint64_t *)&v19[8 * v15];
    v21 = &v19[8 * v18];
    *v20 = v9;
    v13 = v20 + 1;
    if (v11 != v14)
    {
      v22 = (char *)v11 - (char *)v14 - 8;
      if (v22 < 0x58)
        goto LABEL_38;
      if ((unint64_t)((char *)v14 - v19) < 0x20)
        goto LABEL_38;
      v23 = (v22 >> 3) + 1;
      v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      v12 = &v11[v24 / 0xFFFFFFFFFFFFFFF8];
      v20 = (uint64_t *)((char *)v20 - v24);
      v25 = &v19[8 * v15 - 16];
      v26 = v11 - 2;
      v27 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v28 = *(_OWORD *)v26;
        *((_OWORD *)v25 - 1) = *((_OWORD *)v26 - 1);
        *(_OWORD *)v25 = v28;
        v25 -= 32;
        v26 -= 4;
        v27 -= 4;
      }
      while (v27);
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_38:
        do
        {
          v29 = *--v12;
          *--v20 = v29;
        }
        while (v12 != v14);
      }
      v12 = (uint64_t *)a2[20];
    }
    a2[20] = v20;
    a2[21] = v13;
    a2[22] = v21;
    if (v12)
      operator delete(v12);
  }
  else
  {
    *v11 = v9;
    v13 = v11 + 1;
  }
  a2[21] = v13;
  v36[0] = off_1E0E515A0;
  v36[1] = a1;
  v37 = v36;
  v38[0] = off_1E0E515A0;
  v39 = v38;
  v38[1] = a1;
  std::__function::__value_func<void ()(long long const&)>::swap[abi:nn180100](v38, a1 + 20);
  v30 = v39;
  if (v39 == v38)
  {
    v31 = 4;
    v30 = v38;
  }
  else
  {
    if (!v39)
      goto LABEL_28;
    v31 = 5;
  }
  (*((void (**)(void))*v30 + v31))();
LABEL_28:
  v32 = v37;
  if (v37 == v36)
  {
    v33 = 4;
    v32 = v36;
    goto LABEL_32;
  }
  if (v37)
  {
    v33 = 5;
LABEL_32:
    (*(void (**)(void))(*v32 + 8 * v33))();
  }
  return a1;
}

uint64_t llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, int **a5)
{
  void *v10;
  uint64_t v11;
  uint64_t *GeneralCategory;
  uint64_t v13;

  *(_WORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &unk_1E0E23930;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  v10 = (void *)(a1 + 80);
  *(_QWORD *)(a1 + 64) = a1 + 80;
  v11 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(_QWORD *)(a1 + 72) = 0x100000000;
  *(_QWORD *)(a1 + 88) = a1 + 120;
  *(_QWORD *)(a1 + 96) = a1 + 120;
  *(_QWORD *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  v13 = *(unsigned int *)(a1 + 72);
  if (v13 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v11, v10, v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a1 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v13) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = &off_1E0E22FA8;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)a1 = &unk_1E0E23658;
  *(_QWORD *)(a1 + 152) = &unk_1E0E23BC8;
  *(_QWORD *)(a1 + 160) = off_1E0E4FBE0;
  *(_QWORD *)(a1 + 184) = a1 + 160;
  llvm::cl::apply<llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>(a1, a2, a3, a4, a5);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

__n128 llvm::cl::apply<llvm::cl::opt<unsigned int,false,llvm::cl::parser<unsigned int>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, int **a5)
{
  const void *v9;
  uint64_t v10;
  __n128 result;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;

  llvm::cl::Option::setArgStr(a1, *(int8x16_t **)a2, *(const unsigned __int8 **)(a2 + 8));
  v9 = *a3;
  v10 = *(_QWORD *)(a1 + 96);
  if (v10 != *(_QWORD *)(a1 + 88))
  {
LABEL_2:
    llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(a1 + 88), v9);
    goto LABEL_3;
  }
  v13 = *(unsigned int *)(a1 + 108);
  if (!(_DWORD)v13)
  {
LABEL_12:
    if (v13 < *(_DWORD *)(a1 + 104))
    {
      *(_DWORD *)(a1 + 108) = v13 + 1;
      *(_QWORD *)(v10 + 8 * v13) = v9;
      goto LABEL_3;
    }
    goto LABEL_2;
  }
  v14 = 0;
  v15 = 8 * v13;
  v16 = *(_QWORD **)(a1 + 96);
  while ((const void *)*v16 != v9)
  {
    if (*v16 == -2)
      v14 = v16;
    ++v16;
    v15 -= 8;
    if (!v15)
    {
      if (!v14)
        goto LABEL_12;
      *v14 = v9;
      --*(_DWORD *)(a1 + 112);
      break;
    }
  }
LABEL_3:
  result = *a4;
  *(__n128 *)(a1 + 32) = *a4;
  v12 = **a5;
  *(_DWORD *)(a1 + 128) = v12;
  *(_BYTE *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = v12;
  return result;
}

_QWORD *_ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_11initializerIiEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKjEE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = off_1E0E515A0;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_11initializerIiEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKjEE7__cloneEPNS0_6__baseISS_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = off_1E0E515A0;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIjN4llvm2cl6parserIjEEEC1IJNS7_4descENS7_11initializerIiEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKjEEclESR_(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 8) + 200) = 1;
  return result;
}

void mlir::mps::`anonymous namespace'::RuntimeCanonicalizationPass::canonicalize(mlir::mps::_anonymous_namespace_::RuntimeCanonicalizationPass *this, mlir::Operation *a2)
{
  uint64_t Context;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  void *v15;
  char *v16;
  int64_t v17;
  int64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  char *v48;
  void *v49;
  char *v50;
  int64_t v51;
  int64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  char *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  _QWORD *v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  char *v82;
  void *v83;
  char *v84;
  int64_t v85;
  int64_t v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  char *v90;
  char *v91;
  char *v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  _QWORD *v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  unint64_t v115;
  char *v116;
  void *v117;
  char *v118;
  int64_t v119;
  int64_t v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  char *v124;
  char *v125;
  char *v126;
  unint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  char *v131;
  char *v132;
  uint64_t v133;
  __int128 v134;
  __int128 v135;
  uint64_t v136;
  char *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  _QWORD *v141;
  unint64_t v142;
  unint64_t v143;
  unint64_t v144;
  unint64_t v145;
  uint64_t v146;
  unint64_t v147;
  unint64_t v148;
  unint64_t v149;
  char *v150;
  void *v151;
  char *v152;
  int64_t v153;
  int64_t v154;
  unint64_t v155;
  uint64_t v156;
  unint64_t v157;
  char *v158;
  char *v159;
  char *v160;
  unint64_t v161;
  uint64_t v162;
  uint64_t v163;
  char *v164;
  char *v165;
  char *v166;
  uint64_t v167;
  __int128 v168;
  __int128 v169;
  uint64_t v170;
  char *v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  _QWORD *v175;
  unint64_t v176;
  unint64_t v177;
  unint64_t v178;
  unint64_t v179;
  uint64_t v180;
  unint64_t v181;
  unint64_t v182;
  unint64_t v183;
  char *v184;
  void *v185;
  char *v186;
  int64_t v187;
  int64_t v188;
  unint64_t v189;
  uint64_t v190;
  unint64_t v191;
  char *v192;
  char *v193;
  char *v194;
  unint64_t v195;
  uint64_t v196;
  uint64_t v197;
  char *v198;
  char *v199;
  char *v200;
  uint64_t v201;
  __int128 v202;
  __int128 v203;
  uint64_t v204;
  char *v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  _QWORD *v209;
  unint64_t v210;
  unint64_t v211;
  unint64_t v212;
  unint64_t v213;
  uint64_t v214;
  unint64_t v215;
  unint64_t v216;
  unint64_t v217;
  char *v218;
  void *v219;
  char *v220;
  int64_t v221;
  int64_t v222;
  unint64_t v223;
  uint64_t v224;
  unint64_t v225;
  char *v226;
  char *v227;
  char *v228;
  unint64_t v229;
  uint64_t v230;
  uint64_t v231;
  char *v232;
  char *v233;
  char *v234;
  uint64_t v235;
  __int128 v236;
  __int128 v237;
  uint64_t v238;
  char *v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  _QWORD *v243;
  unint64_t v244;
  unint64_t v245;
  unint64_t v246;
  unint64_t v247;
  uint64_t v248;
  unint64_t v249;
  unint64_t v250;
  unint64_t v251;
  char *v252;
  void *v253;
  char *v254;
  int64_t v255;
  int64_t v256;
  unint64_t v257;
  uint64_t v258;
  unint64_t v259;
  char *v260;
  char *v261;
  char *v262;
  unint64_t v263;
  uint64_t v264;
  uint64_t v265;
  char *v266;
  char *v267;
  char *v268;
  uint64_t v269;
  __int128 v270;
  __int128 v271;
  uint64_t v272;
  char *v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  _QWORD *v277;
  unint64_t v278;
  unint64_t v279;
  unint64_t v280;
  unint64_t v281;
  uint64_t v282;
  unint64_t v283;
  unint64_t v284;
  unint64_t v285;
  char *v286;
  void *v287;
  char *v288;
  int64_t v289;
  int64_t v290;
  unint64_t v291;
  uint64_t v292;
  unint64_t v293;
  char *v294;
  char *v295;
  char *v296;
  unint64_t v297;
  uint64_t v298;
  uint64_t v299;
  char *v300;
  char *v301;
  char *v302;
  uint64_t v303;
  __int128 v304;
  __int128 v305;
  uint64_t v306;
  char *v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  _QWORD *v311;
  unint64_t v312;
  unint64_t v313;
  unint64_t v314;
  unint64_t v315;
  uint64_t v316;
  unint64_t v317;
  unint64_t v318;
  unint64_t v319;
  char *v320;
  void *v321;
  char *v322;
  int64_t v323;
  int64_t v324;
  unint64_t v325;
  uint64_t v326;
  unint64_t v327;
  char *v328;
  char *v329;
  char *v330;
  unint64_t v331;
  uint64_t v332;
  uint64_t v333;
  char *v334;
  char *v335;
  char *v336;
  uint64_t v337;
  __int128 v338;
  __int128 v339;
  uint64_t v340;
  char *v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  _QWORD *v345;
  unint64_t v346;
  unint64_t v347;
  unint64_t v348;
  unint64_t v349;
  uint64_t v350;
  unint64_t v351;
  unint64_t v352;
  unint64_t v353;
  char *v354;
  void *v355;
  char *v356;
  int64_t v357;
  int64_t v358;
  unint64_t v359;
  uint64_t v360;
  unint64_t v361;
  char *v362;
  char *v363;
  char *v364;
  unint64_t v365;
  uint64_t v366;
  uint64_t v367;
  char *v368;
  char *v369;
  char *v370;
  uint64_t v371;
  __int128 v372;
  __int128 v373;
  uint64_t v374;
  char *v375;
  uint64_t v376;
  uint64_t v377;
  _QWORD *v378;
  uint64_t v379;
  unint64_t v380;
  unint64_t v381;
  unint64_t v382;
  unint64_t v383;
  uint64_t v384;
  unint64_t v385;
  unint64_t v386;
  unint64_t v387;
  char *v388;
  void *v389;
  _QWORD *v390;
  uint64_t v391;
  int v392;
  unint64_t v393;
  unint64_t v394;
  unint64_t v395;
  unint64_t v396;
  uint64_t v397;
  unint64_t v398;
  unint64_t v399;
  unint64_t v400;
  char *v401;
  char *v402;
  int64_t v403;
  int64_t v404;
  unint64_t v405;
  uint64_t v406;
  unint64_t v407;
  char *v408;
  char *v409;
  int64_t v410;
  int64_t v411;
  unint64_t v412;
  uint64_t v413;
  unint64_t v414;
  char *v415;
  char *v416;
  char *v417;
  unint64_t v418;
  uint64_t v419;
  uint64_t v420;
  char *v421;
  char *v422;
  char *v423;
  uint64_t v424;
  __int128 v425;
  __int128 v426;
  uint64_t v427;
  char *v428;
  uint64_t v429;
  uint64_t v430;
  _QWORD *v431;
  uint64_t v432;
  unint64_t v433;
  unint64_t v434;
  unint64_t v435;
  unint64_t v436;
  uint64_t v437;
  unint64_t v438;
  unint64_t v439;
  unint64_t v440;
  char *v441;
  void *v442;
  char *v443;
  int64_t v444;
  int64_t v445;
  unint64_t v446;
  uint64_t v447;
  unint64_t v448;
  char *v449;
  char *v450;
  char *v451;
  unint64_t v452;
  uint64_t v453;
  uint64_t v454;
  char *v455;
  char *v456;
  char *v457;
  uint64_t v458;
  __int128 v459;
  __int128 v460;
  uint64_t v461;
  char *v462;
  uint64_t v463;
  uint64_t v464;
  _QWORD *v465;
  uint64_t v466;
  unint64_t v467;
  unint64_t v468;
  unint64_t v469;
  unint64_t v470;
  uint64_t v471;
  unint64_t v472;
  unint64_t v473;
  unint64_t v474;
  char *v475;
  void *v476;
  char *v477;
  int64_t v478;
  int64_t v479;
  unint64_t v480;
  uint64_t v481;
  unint64_t v482;
  char *v483;
  char *v484;
  char *v485;
  unint64_t v486;
  uint64_t v487;
  uint64_t v488;
  char *v489;
  char *v490;
  char *v491;
  uint64_t v492;
  __int128 v493;
  __int128 v494;
  uint64_t v495;
  char *v496;
  uint64_t v497;
  uint64_t v498;
  uint64_t v499;
  unint64_t v500;
  unint64_t v501;
  unint64_t v502;
  unint64_t v503;
  uint64_t v504;
  unint64_t v505;
  unint64_t v506;
  unint64_t v507;
  void *v508;
  char *v509;
  int64_t v510;
  int64_t v511;
  unint64_t v512;
  uint64_t v513;
  unint64_t v514;
  char *v515;
  char *v516;
  char *v517;
  unint64_t v518;
  uint64_t v519;
  uint64_t v520;
  char *v521;
  char *v522;
  char *v523;
  uint64_t v524;
  __int128 v525;
  __int128 v526;
  uint64_t v527;
  char *v528;
  uint64_t v529;
  uint64_t v530;
  unint64_t v531;
  uint64_t v532;
  uint64_t v533;
  char *v534;
  char *v535;
  char *v536;
  uint64_t v537;
  __int128 v538;
  __int128 v539;
  uint64_t v540;
  char *v541;
  uint64_t v542;
  uint64_t v543;
  _QWORD *v544;
  uint64_t v545;
  unint64_t v546;
  unint64_t v547;
  unint64_t v548;
  unint64_t v549;
  uint64_t v550;
  unint64_t v551;
  unint64_t v552;
  unint64_t v553;
  char *v554;
  void *v555;
  char *v556;
  int64_t v557;
  int64_t v558;
  unint64_t v559;
  uint64_t v560;
  unint64_t v561;
  char *v562;
  char *v563;
  char *v564;
  unint64_t v565;
  uint64_t v566;
  uint64_t v567;
  char *v568;
  char *v569;
  char *v570;
  uint64_t v571;
  __int128 v572;
  __int128 v573;
  uint64_t v574;
  char *v575;
  uint64_t v576;
  uint64_t v577;
  _BYTE *v578;
  uint64_t v579;
  char v580;
  unint64_t v581;
  unint64_t v582;
  unint64_t v583;
  unint64_t v584;
  uint64_t v585;
  unint64_t v586;
  unint64_t v587;
  unint64_t v588;
  char *v589;
  void *v590;
  char *v591;
  int64_t v592;
  int64_t v593;
  unint64_t v594;
  uint64_t v595;
  unint64_t v596;
  char *v597;
  char *v598;
  char *v599;
  unint64_t v600;
  uint64_t v601;
  uint64_t v602;
  char *v603;
  char *v604;
  char *v605;
  uint64_t v606;
  __int128 v607;
  __int128 v608;
  uint64_t v609;
  char *v610;
  uint64_t v611;
  uint64_t v612;
  _BYTE *v613;
  uint64_t v614;
  char v615;
  unint64_t v616;
  unint64_t v617;
  unint64_t v618;
  unint64_t v619;
  uint64_t v620;
  unint64_t v621;
  unint64_t v622;
  unint64_t v623;
  char *v624;
  void *v625;
  char *v626;
  int64_t v627;
  int64_t v628;
  unint64_t v629;
  uint64_t v630;
  unint64_t v631;
  char *v632;
  char *v633;
  char *v634;
  unint64_t v635;
  uint64_t v636;
  uint64_t v637;
  char *v638;
  char *v639;
  char *v640;
  uint64_t v641;
  __int128 v642;
  __int128 v643;
  uint64_t v644;
  char *v645;
  uint64_t v646;
  uint64_t v647;
  _BYTE *v648;
  uint64_t v649;
  char v650;
  unint64_t v651;
  unint64_t v652;
  unint64_t v653;
  unint64_t v654;
  uint64_t v655;
  unint64_t v656;
  unint64_t v657;
  unint64_t v658;
  char *v659;
  void *v660;
  char *v661;
  int64_t v662;
  int64_t v663;
  unint64_t v664;
  uint64_t v665;
  unint64_t v666;
  char *v667;
  char *v668;
  char *v669;
  unint64_t v670;
  uint64_t v671;
  uint64_t v672;
  char *v673;
  char *v674;
  char *v675;
  uint64_t v676;
  __int128 v677;
  __int128 v678;
  uint64_t v679;
  char *v680;
  uint64_t v681;
  uint64_t v682;
  _BYTE *v683;
  uint64_t v684;
  char v685;
  unint64_t v686;
  unint64_t v687;
  unint64_t v688;
  unint64_t v689;
  uint64_t v690;
  unint64_t v691;
  unint64_t v692;
  unint64_t v693;
  char *v694;
  void *v695;
  char *v696;
  int64_t v697;
  int64_t v698;
  unint64_t v699;
  uint64_t v700;
  unint64_t v701;
  char *v702;
  char *v703;
  char *v704;
  unint64_t v705;
  uint64_t v706;
  uint64_t v707;
  char *v708;
  char *v709;
  char *v710;
  uint64_t v711;
  __int128 v712;
  __int128 v713;
  uint64_t v714;
  char *v715;
  uint64_t v716;
  uint64_t v717;
  _BYTE *v718;
  uint64_t v719;
  char v720;
  unint64_t v721;
  unint64_t v722;
  unint64_t v723;
  unint64_t v724;
  uint64_t v725;
  unint64_t v726;
  unint64_t v727;
  unint64_t v728;
  char *v729;
  void *v730;
  char *v731;
  int64_t v732;
  int64_t v733;
  unint64_t v734;
  uint64_t v735;
  unint64_t v736;
  char *v737;
  char *v738;
  char *v739;
  unint64_t v740;
  uint64_t v741;
  uint64_t v742;
  char *v743;
  char *v744;
  char *v745;
  uint64_t v746;
  __int128 v747;
  __int128 v748;
  uint64_t v749;
  char *v750;
  uint64_t v751;
  uint64_t v752;
  _BYTE *v753;
  uint64_t v754;
  char v755;
  unint64_t v756;
  unint64_t v757;
  unint64_t v758;
  unint64_t v759;
  uint64_t v760;
  unint64_t v761;
  unint64_t v762;
  unint64_t v763;
  char *v764;
  void *v765;
  char *v766;
  int64_t v767;
  int64_t v768;
  unint64_t v769;
  uint64_t v770;
  unint64_t v771;
  char *v772;
  char *v773;
  char *v774;
  unint64_t v775;
  uint64_t v776;
  uint64_t v777;
  char *v778;
  char *v779;
  char *v780;
  uint64_t v781;
  __int128 v782;
  __int128 v783;
  uint64_t v784;
  char *v785;
  uint64_t v786;
  uint64_t v787;
  unint64_t v788;
  mlir::Region **v789;
  __int16 v790[8];
  uint64_t v791;
  BOOL v792;
  uint64_t v793;
  void *__p[2];
  __int128 v795;
  _QWORD *v796;
  uint64_t v797;
  _QWORD v798[8];
  int v799;
  uint64_t v800;
  uint64_t v801;
  uint64_t v802;
  uint64_t v803;
  uint64_t v804;
  uint64_t v805;
  _BYTE v806[32];
  __int128 v807;
  __int128 v808;
  __int128 v809;
  __int128 v810;
  uint64_t v811;

  v811 = *MEMORY[0x1E0C80C00];
  Context = mlir::Attribute::getContext((mlir::Operation *)((char *)a2 + 24));
  v791 = Context;
  v793 = Context;
  *(_OWORD *)__p = 0u;
  v795 = 0u;
  v796 = v798;
  v797 = 0x600000000;
  v798[6] = 0;
  v798[7] = 0;
  v799 = 0;
  v800 = 0;
  v801 = 0;
  v802 = 0x2800000000;
  v803 = 0;
  v804 = 0;
  v805 = 0x2800000000;
  v5 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v790, 1);
  v807 = xmmword_1E0E54928;
  v808 = *(_OWORD *)&off_1E0E54938;
  v809 = xmmword_1E0E54948;
  v810 = *(_OWORD *)&off_1E0E54958;
  *(_OWORD *)v806 = xmmword_1E0E54908;
  *(_OWORD *)&v806[16] = *(_OWORD *)&off_1E0E54918;
  mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.matmul", 10, v790[0], Context, v806, 6uLL);
  *v5 = off_1E0E498C0;
  if (!v5[9])
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_ComplexGEMM_CC]";
    *(_QWORD *)&v806[8] = 102;
    v6 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v6)
      v7 = v6;
    else
      v7 = *(_QWORD *)&v806[8];
    v8 = *(_QWORD *)v806 + v7;
    v9 = *(_QWORD *)&v806[8] - v7;
    if (*(_QWORD *)&v806[8] - v7 >= 0x12)
      v10 = 18;
    else
      v10 = *(_QWORD *)&v806[8] - v7;
    v11 = v8 + v10;
    v12 = v9 - v10;
    if (v12 >= v12 - 1)
      --v12;
    v5[8] = v11;
    v5[9] = v12;
  }
  v13 = *((unsigned int *)v5 + 22);
  if (v13 > *((_DWORD *)v5 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v5 + 10), v5 + 12, v13, 16);
    LODWORD(v13) = *((_DWORD *)v5 + 22);
  }
  *((_DWORD *)v5 + 22) = v13;
  v14 = (char *)__p[1];
  if (__p[1] >= (void *)v795)
  {
    v16 = (char *)__p[0];
    v17 = (char *)__p[1] - (char *)__p[0];
    v18 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v19 = v18 + 1;
    if ((unint64_t)(v18 + 1) >> 61)
      goto LABEL_900;
    v20 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v19)
      v19 = v20 >> 2;
    if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8)
      v21 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v21 = v19;
    if (v21)
    {
      if (v21 >> 61)
        goto LABEL_901;
      v22 = (char *)operator new(8 * v21);
    }
    else
    {
      v22 = 0;
    }
    v23 = &v22[8 * v18];
    v24 = &v22[8 * v21];
    *(_QWORD *)v23 = v5;
    v15 = v23 + 8;
    if (v14 == v16)
    {
      __p[0] = &v22[8 * v18];
      __p[1] = v23 + 8;
      *(_QWORD *)&v795 = v24;
    }
    else
    {
      v25 = v14 - v16 - 8;
      if (v25 < 0x78
        || &v14[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v23 && &v22[v17 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v14)
      {
        goto LABEL_904;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v14[-v27];
      v23 -= v27;
      v29 = &v22[8 * v18 - 16];
      v30 = v14 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v14 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_904:
        do
        {
          v34 = *((_QWORD *)v14 - 1);
          v14 -= 8;
          *(_QWORD *)v14 = 0;
          *((_QWORD *)v23 - 1) = v34;
          v23 -= 8;
        }
        while (v14 != v16);
      }
      v14 = (char *)__p[0];
      v35 = (char *)__p[1];
      __p[0] = v23;
      __p[1] = v15;
      *(_QWORD *)&v795 = v24;
      while (v35 != v14)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
    }
    if (v14)
      operator delete(v14);
  }
  else
  {
    *(_QWORD *)__p[1] = v5;
    v15 = v14 + 8;
  }
  __p[1] = v15;
  v38 = v793;
  v39 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v790, 1);
  *(_OWORD *)v806 = xmmword_1E0E54968;
  *(_OWORD *)&v806[16] = *(_OWORD *)&off_1E0E54978;
  v807 = xmmword_1E0E54988;
  v808 = *(_OWORD *)&off_1E0E54998;
  mlir::Pattern::Pattern((uint64_t)(v39 + 1), (uint64_t)"mps.matmul", 10, v790[0], v38, v806, 4uLL);
  *v39 = off_1E0E49900;
  if (!v39[9])
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_ComplexGEMM_CR]";
    *(_QWORD *)&v806[8] = 102;
    v40 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v40)
      v41 = v40;
    else
      v41 = *(_QWORD *)&v806[8];
    v42 = *(_QWORD *)v806 + v41;
    v43 = *(_QWORD *)&v806[8] - v41;
    if (*(_QWORD *)&v806[8] - v41 >= 0x12)
      v44 = 18;
    else
      v44 = *(_QWORD *)&v806[8] - v41;
    v45 = v42 + v44;
    v46 = v43 - v44;
    if (v46 >= v46 - 1)
      --v46;
    v39[8] = v45;
    v39[9] = v46;
  }
  v47 = *((unsigned int *)v39 + 22);
  if (v47 > *((_DWORD *)v39 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v39 + 10), v39 + 12, v47, 16);
    LODWORD(v47) = *((_DWORD *)v39 + 22);
  }
  *((_DWORD *)v39 + 22) = v47;
  v48 = (char *)__p[1];
  if (__p[1] >= (void *)v795)
  {
    v50 = (char *)__p[0];
    v51 = (char *)__p[1] - (char *)__p[0];
    v52 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v53 = v52 + 1;
    if ((unint64_t)(v52 + 1) >> 61)
      goto LABEL_900;
    v54 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v53)
      v53 = v54 >> 2;
    if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8)
      v55 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v55 = v53;
    if (v55)
    {
      if (v55 >> 61)
        goto LABEL_901;
      v56 = (char *)operator new(8 * v55);
    }
    else
    {
      v56 = 0;
    }
    v57 = &v56[8 * v52];
    v58 = &v56[8 * v55];
    *(_QWORD *)v57 = v39;
    v49 = v57 + 8;
    if (v48 == v50)
    {
      __p[0] = &v56[8 * v52];
      __p[1] = v57 + 8;
      *(_QWORD *)&v795 = v58;
    }
    else
    {
      v59 = v48 - v50 - 8;
      if (v59 < 0x78
        || &v48[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v57 && &v56[v51 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v48)
      {
        goto LABEL_905;
      }
      v60 = (v59 >> 3) + 1;
      v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      v62 = &v48[-v61];
      v57 -= v61;
      v63 = &v56[8 * v52 - 16];
      v64 = v48 - 16;
      v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v67 = *((_OWORD *)v64 - 1);
        v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      v48 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_905:
        do
        {
          v68 = *((_QWORD *)v48 - 1);
          v48 -= 8;
          *(_QWORD *)v48 = 0;
          *((_QWORD *)v57 - 1) = v68;
          v57 -= 8;
        }
        while (v48 != v50);
      }
      v48 = (char *)__p[0];
      v69 = (char *)__p[1];
      __p[0] = v57;
      __p[1] = v49;
      *(_QWORD *)&v795 = v58;
      while (v69 != v48)
      {
        v71 = *((_QWORD *)v69 - 1);
        v69 -= 8;
        v70 = v71;
        *(_QWORD *)v69 = 0;
        if (v71)
          (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
      }
    }
    if (v48)
      operator delete(v48);
  }
  else
  {
    *(_QWORD *)__p[1] = v39;
    v49 = v48 + 8;
  }
  __p[1] = v49;
  v72 = v793;
  v73 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v790, 1);
  *(_OWORD *)v806 = xmmword_1E0E54968;
  *(_OWORD *)&v806[16] = *(_OWORD *)&off_1E0E54978;
  v807 = xmmword_1E0E54988;
  v808 = *(_OWORD *)&off_1E0E54998;
  mlir::Pattern::Pattern((uint64_t)(v73 + 1), (uint64_t)"mps.matmul", 10, v790[0], v72, v806, 4uLL);
  *v73 = off_1E0E49940;
  if (!v73[9])
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_ComplexGEMM_RC]";
    *(_QWORD *)&v806[8] = 102;
    v74 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v74)
      v75 = v74;
    else
      v75 = *(_QWORD *)&v806[8];
    v76 = *(_QWORD *)v806 + v75;
    v77 = *(_QWORD *)&v806[8] - v75;
    if (*(_QWORD *)&v806[8] - v75 >= 0x12)
      v78 = 18;
    else
      v78 = *(_QWORD *)&v806[8] - v75;
    v79 = v76 + v78;
    v80 = v77 - v78;
    if (v80 >= v80 - 1)
      --v80;
    v73[8] = v79;
    v73[9] = v80;
  }
  v81 = *((unsigned int *)v73 + 22);
  if (v81 > *((_DWORD *)v73 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v73 + 10), v73 + 12, v81, 16);
    LODWORD(v81) = *((_DWORD *)v73 + 22);
  }
  *((_DWORD *)v73 + 22) = v81;
  v82 = (char *)__p[1];
  if (__p[1] >= (void *)v795)
  {
    v84 = (char *)__p[0];
    v85 = (char *)__p[1] - (char *)__p[0];
    v86 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v87 = v86 + 1;
    if ((unint64_t)(v86 + 1) >> 61)
      goto LABEL_900;
    v88 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v87)
      v87 = v88 >> 2;
    if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFF8)
      v89 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v89 = v87;
    if (v89)
    {
      if (v89 >> 61)
        goto LABEL_901;
      v90 = (char *)operator new(8 * v89);
    }
    else
    {
      v90 = 0;
    }
    v91 = &v90[8 * v86];
    v92 = &v90[8 * v89];
    *(_QWORD *)v91 = v73;
    v83 = v91 + 8;
    if (v82 == v84)
    {
      __p[0] = &v90[8 * v86];
      __p[1] = v91 + 8;
      *(_QWORD *)&v795 = v92;
    }
    else
    {
      v93 = v82 - v84 - 8;
      if (v93 < 0x78
        || &v82[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v91 && &v90[v85 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v82)
      {
        goto LABEL_906;
      }
      v94 = (v93 >> 3) + 1;
      v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
      v96 = &v82[-v95];
      v91 -= v95;
      v97 = &v90[8 * v86 - 16];
      v98 = v82 - 16;
      v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v101 = *((_OWORD *)v98 - 1);
        v100 = *(_OWORD *)v98;
        *((_OWORD *)v98 - 1) = 0uLL;
        *(_OWORD *)v98 = 0uLL;
        *((_OWORD *)v97 - 1) = v101;
        *(_OWORD *)v97 = v100;
        v97 -= 32;
        v98 -= 32;
        v99 -= 4;
      }
      while (v99);
      v82 = v96;
      if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_906:
        do
        {
          v102 = *((_QWORD *)v82 - 1);
          v82 -= 8;
          *(_QWORD *)v82 = 0;
          *((_QWORD *)v91 - 1) = v102;
          v91 -= 8;
        }
        while (v82 != v84);
      }
      v82 = (char *)__p[0];
      v103 = (char *)__p[1];
      __p[0] = v91;
      __p[1] = v83;
      *(_QWORD *)&v795 = v92;
      while (v103 != v82)
      {
        v105 = *((_QWORD *)v103 - 1);
        v103 -= 8;
        v104 = v105;
        *(_QWORD *)v103 = 0;
        if (v105)
          (*(void (**)(uint64_t))(*(_QWORD *)v104 + 8))(v104);
      }
    }
    if (v82)
      operator delete(v82);
  }
  else
  {
    *(_QWORD *)__p[1] = v73;
    v83 = v82 + 8;
  }
  __p[1] = v83;
  v106 = v793;
  v107 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v790, 2);
  *(_OWORD *)v806 = xmmword_1E0E549A8;
  *(_OWORD *)&v806[16] = *(_OWORD *)&off_1E0E549B8;
  v807 = xmmword_1E0E549C8;
  mlir::Pattern::Pattern((uint64_t)(v107 + 1), (uint64_t)"mps.divide", 10, v790[0], v106, v806, 3uLL);
  *v107 = off_1E0E49468;
  if (!v107[9])
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_DivideOfPower]";
    *(_QWORD *)&v806[8] = 101;
    v108 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v108)
      v109 = v108;
    else
      v109 = *(_QWORD *)&v806[8];
    v110 = *(_QWORD *)v806 + v109;
    v111 = *(_QWORD *)&v806[8] - v109;
    if (*(_QWORD *)&v806[8] - v109 >= 0x12)
      v112 = 18;
    else
      v112 = *(_QWORD *)&v806[8] - v109;
    v113 = v110 + v112;
    v114 = v111 - v112;
    if (v114 >= v114 - 1)
      --v114;
    v107[8] = v113;
    v107[9] = v114;
  }
  v115 = *((unsigned int *)v107 + 22);
  if (v115 > *((_DWORD *)v107 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v107 + 10), v107 + 12, v115, 16);
    LODWORD(v115) = *((_DWORD *)v107 + 22);
  }
  *((_DWORD *)v107 + 22) = v115;
  v116 = (char *)__p[1];
  if (__p[1] >= (void *)v795)
  {
    v118 = (char *)__p[0];
    v119 = (char *)__p[1] - (char *)__p[0];
    v120 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v121 = v120 + 1;
    if ((unint64_t)(v120 + 1) >> 61)
      goto LABEL_900;
    v122 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v121)
      v121 = v122 >> 2;
    if ((unint64_t)v122 >= 0x7FFFFFFFFFFFFFF8)
      v123 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v123 = v121;
    if (v123)
    {
      if (v123 >> 61)
        goto LABEL_901;
      v124 = (char *)operator new(8 * v123);
    }
    else
    {
      v124 = 0;
    }
    v125 = &v124[8 * v120];
    v126 = &v124[8 * v123];
    *(_QWORD *)v125 = v107;
    v117 = v125 + 8;
    if (v116 == v118)
    {
      __p[0] = &v124[8 * v120];
      __p[1] = v125 + 8;
      *(_QWORD *)&v795 = v126;
    }
    else
    {
      v127 = v116 - v118 - 8;
      if (v127 < 0x78
        || &v116[-(v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v125 && &v124[v119 - (v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v116)
      {
        goto LABEL_907;
      }
      v128 = (v127 >> 3) + 1;
      v129 = 8 * (v128 & 0x3FFFFFFFFFFFFFFCLL);
      v130 = &v116[-v129];
      v125 -= v129;
      v131 = &v124[8 * v120 - 16];
      v132 = v116 - 16;
      v133 = v128 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v135 = *((_OWORD *)v132 - 1);
        v134 = *(_OWORD *)v132;
        *((_OWORD *)v132 - 1) = 0uLL;
        *(_OWORD *)v132 = 0uLL;
        *((_OWORD *)v131 - 1) = v135;
        *(_OWORD *)v131 = v134;
        v131 -= 32;
        v132 -= 32;
        v133 -= 4;
      }
      while (v133);
      v116 = v130;
      if (v128 != (v128 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_907:
        do
        {
          v136 = *((_QWORD *)v116 - 1);
          v116 -= 8;
          *(_QWORD *)v116 = 0;
          *((_QWORD *)v125 - 1) = v136;
          v125 -= 8;
        }
        while (v116 != v118);
      }
      v116 = (char *)__p[0];
      v137 = (char *)__p[1];
      __p[0] = v125;
      __p[1] = v117;
      *(_QWORD *)&v795 = v126;
      while (v137 != v116)
      {
        v139 = *((_QWORD *)v137 - 1);
        v137 -= 8;
        v138 = v139;
        *(_QWORD *)v137 = 0;
        if (v139)
          (*(void (**)(uint64_t))(*(_QWORD *)v138 + 8))(v138);
      }
    }
    if (v116)
      operator delete(v116);
  }
  else
  {
    *(_QWORD *)__p[1] = v107;
    v117 = v116 + 8;
  }
  __p[1] = v117;
  v140 = v793;
  v141 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v790, 2);
  *(_OWORD *)v806 = xmmword_1E0E549D8;
  *(_OWORD *)&v806[16] = *(_OWORD *)&off_1E0E549E8;
  mlir::Pattern::Pattern((uint64_t)(v141 + 1), (uint64_t)"mps.divide", 10, v790[0], v140, v806, 2uLL);
  *v141 = off_1E0E4B018;
  if (!v141[9])
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_DivideSqrtToMultiplyRsqrt]";
    *(_QWORD *)&v806[8] = 113;
    v142 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v142)
      v143 = v142;
    else
      v143 = *(_QWORD *)&v806[8];
    v144 = *(_QWORD *)v806 + v143;
    v145 = *(_QWORD *)&v806[8] - v143;
    if (*(_QWORD *)&v806[8] - v143 >= 0x12)
      v146 = 18;
    else
      v146 = *(_QWORD *)&v806[8] - v143;
    v147 = v144 + v146;
    v148 = v145 - v146;
    if (v148 >= v148 - 1)
      --v148;
    v141[8] = v147;
    v141[9] = v148;
  }
  v149 = *((unsigned int *)v141 + 22);
  if (v149 > *((_DWORD *)v141 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v141 + 10), v141 + 12, v149, 16);
    LODWORD(v149) = *((_DWORD *)v141 + 22);
  }
  *((_DWORD *)v141 + 22) = v149;
  v150 = (char *)__p[1];
  if (__p[1] >= (void *)v795)
  {
    v152 = (char *)__p[0];
    v153 = (char *)__p[1] - (char *)__p[0];
    v154 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v155 = v154 + 1;
    if ((unint64_t)(v154 + 1) >> 61)
      goto LABEL_900;
    v156 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v155)
      v155 = v156 >> 2;
    if ((unint64_t)v156 >= 0x7FFFFFFFFFFFFFF8)
      v157 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v157 = v155;
    if (v157)
    {
      if (v157 >> 61)
        goto LABEL_901;
      v158 = (char *)operator new(8 * v157);
    }
    else
    {
      v158 = 0;
    }
    v159 = &v158[8 * v154];
    v160 = &v158[8 * v157];
    *(_QWORD *)v159 = v141;
    v151 = v159 + 8;
    if (v150 == v152)
    {
      __p[0] = &v158[8 * v154];
      __p[1] = v159 + 8;
      *(_QWORD *)&v795 = v160;
    }
    else
    {
      v161 = v150 - v152 - 8;
      if (v161 < 0x78
        || &v150[-(v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v159 && &v158[v153 - (v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v150)
      {
        goto LABEL_908;
      }
      v162 = (v161 >> 3) + 1;
      v163 = 8 * (v162 & 0x3FFFFFFFFFFFFFFCLL);
      v164 = &v150[-v163];
      v159 -= v163;
      v165 = &v158[8 * v154 - 16];
      v166 = v150 - 16;
      v167 = v162 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v169 = *((_OWORD *)v166 - 1);
        v168 = *(_OWORD *)v166;
        *((_OWORD *)v166 - 1) = 0uLL;
        *(_OWORD *)v166 = 0uLL;
        *((_OWORD *)v165 - 1) = v169;
        *(_OWORD *)v165 = v168;
        v165 -= 32;
        v166 -= 32;
        v167 -= 4;
      }
      while (v167);
      v150 = v164;
      if (v162 != (v162 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_908:
        do
        {
          v170 = *((_QWORD *)v150 - 1);
          v150 -= 8;
          *(_QWORD *)v150 = 0;
          *((_QWORD *)v159 - 1) = v170;
          v159 -= 8;
        }
        while (v150 != v152);
      }
      v150 = (char *)__p[0];
      v171 = (char *)__p[1];
      __p[0] = v159;
      __p[1] = v151;
      *(_QWORD *)&v795 = v160;
      while (v171 != v150)
      {
        v173 = *((_QWORD *)v171 - 1);
        v171 -= 8;
        v172 = v173;
        *(_QWORD *)v171 = 0;
        if (v173)
          (*(void (**)(uint64_t))(*(_QWORD *)v172 + 8))(v172);
      }
    }
    if (v150)
      operator delete(v150);
  }
  else
  {
    *(_QWORD *)__p[1] = v141;
    v151 = v150 + 8;
  }
  __p[1] = v151;
  v174 = v793;
  v175 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v790, 4);
  *(_OWORD *)v806 = xmmword_1E0E549F8;
  *(_OWORD *)&v806[16] = *(_OWORD *)&off_1E0E54A08;
  mlir::Pattern::Pattern((uint64_t)(v175 + 1), (uint64_t)"mps.permute", 11, v790[0], v174, v806, 2uLL);
  *v175 = off_1E0E4A428;
  if (!v175[9])
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_NCHW_ConvBias_NHWC]";
    *(_QWORD *)&v806[8] = 106;
    v176 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v176)
      v177 = v176;
    else
      v177 = *(_QWORD *)&v806[8];
    v178 = *(_QWORD *)v806 + v177;
    v179 = *(_QWORD *)&v806[8] - v177;
    if (*(_QWORD *)&v806[8] - v177 >= 0x12)
      v180 = 18;
    else
      v180 = *(_QWORD *)&v806[8] - v177;
    v181 = v178 + v180;
    v182 = v179 - v180;
    if (v182 >= v182 - 1)
      --v182;
    v175[8] = v181;
    v175[9] = v182;
  }
  v183 = *((unsigned int *)v175 + 22);
  if (v183 > *((_DWORD *)v175 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v175 + 10), v175 + 12, v183, 16);
    LODWORD(v183) = *((_DWORD *)v175 + 22);
  }
  *((_DWORD *)v175 + 22) = v183;
  v184 = (char *)__p[1];
  if (__p[1] >= (void *)v795)
  {
    v186 = (char *)__p[0];
    v187 = (char *)__p[1] - (char *)__p[0];
    v188 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v189 = v188 + 1;
    if ((unint64_t)(v188 + 1) >> 61)
      goto LABEL_900;
    v190 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v189)
      v189 = v190 >> 2;
    if ((unint64_t)v190 >= 0x7FFFFFFFFFFFFFF8)
      v191 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v191 = v189;
    if (v191)
    {
      if (v191 >> 61)
        goto LABEL_901;
      v192 = (char *)operator new(8 * v191);
    }
    else
    {
      v192 = 0;
    }
    v193 = &v192[8 * v188];
    v194 = &v192[8 * v191];
    *(_QWORD *)v193 = v175;
    v185 = v193 + 8;
    if (v184 == v186)
    {
      __p[0] = &v192[8 * v188];
      __p[1] = v193 + 8;
      *(_QWORD *)&v795 = v194;
    }
    else
    {
      v195 = v184 - v186 - 8;
      if (v195 < 0x78
        || &v184[-(v195 & 0xFFFFFFFFFFFFFFF8) - 8] < v193 && &v192[v187 - (v195 & 0xFFFFFFFFFFFFFFF8) - 8] < v184)
      {
        goto LABEL_909;
      }
      v196 = (v195 >> 3) + 1;
      v197 = 8 * (v196 & 0x3FFFFFFFFFFFFFFCLL);
      v198 = &v184[-v197];
      v193 -= v197;
      v199 = &v192[8 * v188 - 16];
      v200 = v184 - 16;
      v201 = v196 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v203 = *((_OWORD *)v200 - 1);
        v202 = *(_OWORD *)v200;
        *((_OWORD *)v200 - 1) = 0uLL;
        *(_OWORD *)v200 = 0uLL;
        *((_OWORD *)v199 - 1) = v203;
        *(_OWORD *)v199 = v202;
        v199 -= 32;
        v200 -= 32;
        v201 -= 4;
      }
      while (v201);
      v184 = v198;
      if (v196 != (v196 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_909:
        do
        {
          v204 = *((_QWORD *)v184 - 1);
          v184 -= 8;
          *(_QWORD *)v184 = 0;
          *((_QWORD *)v193 - 1) = v204;
          v193 -= 8;
        }
        while (v184 != v186);
      }
      v184 = (char *)__p[0];
      v205 = (char *)__p[1];
      __p[0] = v193;
      __p[1] = v185;
      *(_QWORD *)&v795 = v194;
      while (v205 != v184)
      {
        v207 = *((_QWORD *)v205 - 1);
        v205 -= 8;
        v206 = v207;
        *(_QWORD *)v205 = 0;
        if (v207)
          (*(void (**)(uint64_t))(*(_QWORD *)v206 + 8))(v206);
      }
    }
    if (v184)
      operator delete(v184);
  }
  else
  {
    *(_QWORD *)__p[1] = v175;
    v185 = v184 + 8;
  }
  __p[1] = v185;
  v208 = v793;
  v209 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v790, 3);
  *(_QWORD *)v806 = "mps.conv_2d";
  *(_QWORD *)&v806[8] = 11;
  mlir::Pattern::Pattern((uint64_t)(v209 + 1), (uint64_t)"mps.permute", 11, v790[0], v208, v806, 1uLL);
  *v209 = off_1E0E499C0;
  if (!v209[9])
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_NCHW_Conv_NHWC]";
    *(_QWORD *)&v806[8] = 102;
    v210 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v210)
      v211 = v210;
    else
      v211 = *(_QWORD *)&v806[8];
    v212 = *(_QWORD *)v806 + v211;
    v213 = *(_QWORD *)&v806[8] - v211;
    if (*(_QWORD *)&v806[8] - v211 >= 0x12)
      v214 = 18;
    else
      v214 = *(_QWORD *)&v806[8] - v211;
    v215 = v212 + v214;
    v216 = v213 - v214;
    if (v216 >= v216 - 1)
      --v216;
    v209[8] = v215;
    v209[9] = v216;
  }
  v217 = *((unsigned int *)v209 + 22);
  if (v217 > *((_DWORD *)v209 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v209 + 10), v209 + 12, v217, 16);
    LODWORD(v217) = *((_DWORD *)v209 + 22);
  }
  *((_DWORD *)v209 + 22) = v217;
  v218 = (char *)__p[1];
  if (__p[1] >= (void *)v795)
  {
    v220 = (char *)__p[0];
    v221 = (char *)__p[1] - (char *)__p[0];
    v222 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v223 = v222 + 1;
    if ((unint64_t)(v222 + 1) >> 61)
      goto LABEL_900;
    v224 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v223)
      v223 = v224 >> 2;
    if ((unint64_t)v224 >= 0x7FFFFFFFFFFFFFF8)
      v225 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v225 = v223;
    if (v225)
    {
      if (v225 >> 61)
        goto LABEL_901;
      v226 = (char *)operator new(8 * v225);
    }
    else
    {
      v226 = 0;
    }
    v227 = &v226[8 * v222];
    v228 = &v226[8 * v225];
    *(_QWORD *)v227 = v209;
    v219 = v227 + 8;
    if (v218 == v220)
    {
      __p[0] = &v226[8 * v222];
      __p[1] = v227 + 8;
      *(_QWORD *)&v795 = v228;
    }
    else
    {
      v229 = v218 - v220 - 8;
      if (v229 < 0x78
        || &v218[-(v229 & 0xFFFFFFFFFFFFFFF8) - 8] < v227 && &v226[v221 - (v229 & 0xFFFFFFFFFFFFFFF8) - 8] < v218)
      {
        goto LABEL_910;
      }
      v230 = (v229 >> 3) + 1;
      v231 = 8 * (v230 & 0x3FFFFFFFFFFFFFFCLL);
      v232 = &v218[-v231];
      v227 -= v231;
      v233 = &v226[8 * v222 - 16];
      v234 = v218 - 16;
      v235 = v230 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v237 = *((_OWORD *)v234 - 1);
        v236 = *(_OWORD *)v234;
        *((_OWORD *)v234 - 1) = 0uLL;
        *(_OWORD *)v234 = 0uLL;
        *((_OWORD *)v233 - 1) = v237;
        *(_OWORD *)v233 = v236;
        v233 -= 32;
        v234 -= 32;
        v235 -= 4;
      }
      while (v235);
      v218 = v232;
      if (v230 != (v230 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_910:
        do
        {
          v238 = *((_QWORD *)v218 - 1);
          v218 -= 8;
          *(_QWORD *)v218 = 0;
          *((_QWORD *)v227 - 1) = v238;
          v227 -= 8;
        }
        while (v218 != v220);
      }
      v218 = (char *)__p[0];
      v239 = (char *)__p[1];
      __p[0] = v227;
      __p[1] = v219;
      *(_QWORD *)&v795 = v228;
      while (v239 != v218)
      {
        v241 = *((_QWORD *)v239 - 1);
        v239 -= 8;
        v240 = v241;
        *(_QWORD *)v239 = 0;
        if (v241)
          (*(void (**)(uint64_t))(*(_QWORD *)v240 + 8))(v240);
      }
    }
    if (v218)
      operator delete(v218);
  }
  else
  {
    *(_QWORD *)__p[1] = v209;
    v219 = v218 + 8;
  }
  __p[1] = v219;
  v242 = v793;
  v243 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v790, 2);
  *(_OWORD *)v806 = xmmword_1E0E54A18;
  *(_OWORD *)&v806[16] = *(_OWORD *)&off_1E0E54A28;
  mlir::Pattern::Pattern((uint64_t)(v243 + 1), (uint64_t)"mps.pad", 7, v790[0], v242, v806, 2uLL);
  *v243 = off_1E0E4A280;
  if (!v243[9])
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_ReorderDequantPad]";
    *(_QWORD *)&v806[8] = 105;
    v244 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v244)
      v245 = v244;
    else
      v245 = *(_QWORD *)&v806[8];
    v246 = *(_QWORD *)v806 + v245;
    v247 = *(_QWORD *)&v806[8] - v245;
    if (*(_QWORD *)&v806[8] - v245 >= 0x12)
      v248 = 18;
    else
      v248 = *(_QWORD *)&v806[8] - v245;
    v249 = v246 + v248;
    v250 = v247 - v248;
    if (v250 >= v250 - 1)
      --v250;
    v243[8] = v249;
    v243[9] = v250;
  }
  v251 = *((unsigned int *)v243 + 22);
  if (v251 > *((_DWORD *)v243 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v243 + 10), v243 + 12, v251, 16);
    LODWORD(v251) = *((_DWORD *)v243 + 22);
  }
  *((_DWORD *)v243 + 22) = v251;
  v252 = (char *)__p[1];
  if (__p[1] >= (void *)v795)
  {
    v254 = (char *)__p[0];
    v255 = (char *)__p[1] - (char *)__p[0];
    v256 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v257 = v256 + 1;
    if ((unint64_t)(v256 + 1) >> 61)
      goto LABEL_900;
    v258 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v257)
      v257 = v258 >> 2;
    if ((unint64_t)v258 >= 0x7FFFFFFFFFFFFFF8)
      v259 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v259 = v257;
    if (v259)
    {
      if (v259 >> 61)
        goto LABEL_901;
      v260 = (char *)operator new(8 * v259);
    }
    else
    {
      v260 = 0;
    }
    v261 = &v260[8 * v256];
    v262 = &v260[8 * v259];
    *(_QWORD *)v261 = v243;
    v253 = v261 + 8;
    if (v252 == v254)
    {
      __p[0] = &v260[8 * v256];
      __p[1] = v261 + 8;
      *(_QWORD *)&v795 = v262;
    }
    else
    {
      v263 = v252 - v254 - 8;
      if (v263 < 0x78
        || &v252[-(v263 & 0xFFFFFFFFFFFFFFF8) - 8] < v261 && &v260[v255 - (v263 & 0xFFFFFFFFFFFFFFF8) - 8] < v252)
      {
        goto LABEL_911;
      }
      v264 = (v263 >> 3) + 1;
      v265 = 8 * (v264 & 0x3FFFFFFFFFFFFFFCLL);
      v266 = &v252[-v265];
      v261 -= v265;
      v267 = &v260[8 * v256 - 16];
      v268 = v252 - 16;
      v269 = v264 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v271 = *((_OWORD *)v268 - 1);
        v270 = *(_OWORD *)v268;
        *((_OWORD *)v268 - 1) = 0uLL;
        *(_OWORD *)v268 = 0uLL;
        *((_OWORD *)v267 - 1) = v271;
        *(_OWORD *)v267 = v270;
        v267 -= 32;
        v268 -= 32;
        v269 -= 4;
      }
      while (v269);
      v252 = v266;
      if (v264 != (v264 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_911:
        do
        {
          v272 = *((_QWORD *)v252 - 1);
          v252 -= 8;
          *(_QWORD *)v252 = 0;
          *((_QWORD *)v261 - 1) = v272;
          v261 -= 8;
        }
        while (v252 != v254);
      }
      v252 = (char *)__p[0];
      v273 = (char *)__p[1];
      __p[0] = v261;
      __p[1] = v253;
      *(_QWORD *)&v795 = v262;
      while (v273 != v252)
      {
        v275 = *((_QWORD *)v273 - 1);
        v273 -= 8;
        v274 = v275;
        *(_QWORD *)v273 = 0;
        if (v275)
          (*(void (**)(uint64_t))(*(_QWORD *)v274 + 8))(v274);
      }
    }
    if (v252)
      operator delete(v252);
  }
  else
  {
    *(_QWORD *)__p[1] = v243;
    v253 = v252 + 8;
  }
  __p[1] = v253;
  v276 = v793;
  v277 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v790, 2);
  *(_QWORD *)v806 = "mps.reshape";
  *(_QWORD *)&v806[8] = 11;
  mlir::Pattern::Pattern((uint64_t)(v277 + 1), (uint64_t)"mps.reshape", 11, v790[0], v276, v806, 1uLL);
  *v277 = off_1E0E49A00;
  if (!v277[9])
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_ReshapeReshape]";
    *(_QWORD *)&v806[8] = 102;
    v278 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v278)
      v279 = v278;
    else
      v279 = *(_QWORD *)&v806[8];
    v280 = *(_QWORD *)v806 + v279;
    v281 = *(_QWORD *)&v806[8] - v279;
    if (*(_QWORD *)&v806[8] - v279 >= 0x12)
      v282 = 18;
    else
      v282 = *(_QWORD *)&v806[8] - v279;
    v283 = v280 + v282;
    v284 = v281 - v282;
    if (v284 >= v284 - 1)
      --v284;
    v277[8] = v283;
    v277[9] = v284;
  }
  v285 = *((unsigned int *)v277 + 22);
  if (v285 > *((_DWORD *)v277 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v277 + 10), v277 + 12, v285, 16);
    LODWORD(v285) = *((_DWORD *)v277 + 22);
  }
  *((_DWORD *)v277 + 22) = v285;
  v286 = (char *)__p[1];
  if (__p[1] >= (void *)v795)
  {
    v288 = (char *)__p[0];
    v289 = (char *)__p[1] - (char *)__p[0];
    v290 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v291 = v290 + 1;
    if ((unint64_t)(v290 + 1) >> 61)
      goto LABEL_900;
    v292 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v291)
      v291 = v292 >> 2;
    if ((unint64_t)v292 >= 0x7FFFFFFFFFFFFFF8)
      v293 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v293 = v291;
    if (v293)
    {
      if (v293 >> 61)
        goto LABEL_901;
      v294 = (char *)operator new(8 * v293);
    }
    else
    {
      v294 = 0;
    }
    v295 = &v294[8 * v290];
    v296 = &v294[8 * v293];
    *(_QWORD *)v295 = v277;
    v287 = v295 + 8;
    if (v286 == v288)
    {
      __p[0] = &v294[8 * v290];
      __p[1] = v295 + 8;
      *(_QWORD *)&v795 = v296;
    }
    else
    {
      v297 = v286 - v288 - 8;
      if (v297 < 0x78
        || &v286[-(v297 & 0xFFFFFFFFFFFFFFF8) - 8] < v295 && &v294[v289 - (v297 & 0xFFFFFFFFFFFFFFF8) - 8] < v286)
      {
        goto LABEL_912;
      }
      v298 = (v297 >> 3) + 1;
      v299 = 8 * (v298 & 0x3FFFFFFFFFFFFFFCLL);
      v300 = &v286[-v299];
      v295 -= v299;
      v301 = &v294[8 * v290 - 16];
      v302 = v286 - 16;
      v303 = v298 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v305 = *((_OWORD *)v302 - 1);
        v304 = *(_OWORD *)v302;
        *((_OWORD *)v302 - 1) = 0uLL;
        *(_OWORD *)v302 = 0uLL;
        *((_OWORD *)v301 - 1) = v305;
        *(_OWORD *)v301 = v304;
        v301 -= 32;
        v302 -= 32;
        v303 -= 4;
      }
      while (v303);
      v286 = v300;
      if (v298 != (v298 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_912:
        do
        {
          v306 = *((_QWORD *)v286 - 1);
          v286 -= 8;
          *(_QWORD *)v286 = 0;
          *((_QWORD *)v295 - 1) = v306;
          v295 -= 8;
        }
        while (v286 != v288);
      }
      v286 = (char *)__p[0];
      v307 = (char *)__p[1];
      __p[0] = v295;
      __p[1] = v287;
      *(_QWORD *)&v795 = v296;
      while (v307 != v286)
      {
        v309 = *((_QWORD *)v307 - 1);
        v307 -= 8;
        v308 = v309;
        *(_QWORD *)v307 = 0;
        if (v309)
          (*(void (**)(uint64_t))(*(_QWORD *)v308 + 8))(v308);
      }
    }
    if (v286)
      operator delete(v286);
  }
  else
  {
    *(_QWORD *)__p[1] = v277;
    v287 = v286 + 8;
  }
  __p[1] = v287;
  v310 = v793;
  v311 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v790, 1);
  *(_OWORD *)v806 = xmmword_1E0E54A38;
  *(_OWORD *)&v806[16] = *(_OWORD *)&off_1E0E54A48;
  mlir::Pattern::Pattern((uint64_t)(v311 + 1), (uint64_t)"mps.select", 10, v790[0], v310, v806, 2uLL);
  *v311 = off_1E0E49A40;
  if (!v311[9])
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_SelectCondCast]";
    *(_QWORD *)&v806[8] = 102;
    v312 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v312)
      v313 = v312;
    else
      v313 = *(_QWORD *)&v806[8];
    v314 = *(_QWORD *)v806 + v313;
    v315 = *(_QWORD *)&v806[8] - v313;
    if (*(_QWORD *)&v806[8] - v313 >= 0x12)
      v316 = 18;
    else
      v316 = *(_QWORD *)&v806[8] - v313;
    v317 = v314 + v316;
    v318 = v315 - v316;
    if (v318 >= v318 - 1)
      --v318;
    v311[8] = v317;
    v311[9] = v318;
  }
  v319 = *((unsigned int *)v311 + 22);
  if (v319 > *((_DWORD *)v311 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v311 + 10), v311 + 12, v319, 16);
    LODWORD(v319) = *((_DWORD *)v311 + 22);
  }
  *((_DWORD *)v311 + 22) = v319;
  v320 = (char *)__p[1];
  if (__p[1] >= (void *)v795)
  {
    v322 = (char *)__p[0];
    v323 = (char *)__p[1] - (char *)__p[0];
    v324 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v325 = v324 + 1;
    if ((unint64_t)(v324 + 1) >> 61)
      goto LABEL_900;
    v326 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v325)
      v325 = v326 >> 2;
    if ((unint64_t)v326 >= 0x7FFFFFFFFFFFFFF8)
      v327 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v327 = v325;
    if (v327)
    {
      if (v327 >> 61)
        goto LABEL_901;
      v328 = (char *)operator new(8 * v327);
    }
    else
    {
      v328 = 0;
    }
    v329 = &v328[8 * v324];
    v330 = &v328[8 * v327];
    *(_QWORD *)v329 = v311;
    v321 = v329 + 8;
    if (v320 == v322)
    {
      __p[0] = &v328[8 * v324];
      __p[1] = v329 + 8;
      *(_QWORD *)&v795 = v330;
    }
    else
    {
      v331 = v320 - v322 - 8;
      if (v331 < 0x78
        || &v320[-(v331 & 0xFFFFFFFFFFFFFFF8) - 8] < v329 && &v328[v323 - (v331 & 0xFFFFFFFFFFFFFFF8) - 8] < v320)
      {
        goto LABEL_913;
      }
      v332 = (v331 >> 3) + 1;
      v333 = 8 * (v332 & 0x3FFFFFFFFFFFFFFCLL);
      v334 = &v320[-v333];
      v329 -= v333;
      v335 = &v328[8 * v324 - 16];
      v336 = v320 - 16;
      v337 = v332 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v339 = *((_OWORD *)v336 - 1);
        v338 = *(_OWORD *)v336;
        *((_OWORD *)v336 - 1) = 0uLL;
        *(_OWORD *)v336 = 0uLL;
        *((_OWORD *)v335 - 1) = v339;
        *(_OWORD *)v335 = v338;
        v335 -= 32;
        v336 -= 32;
        v337 -= 4;
      }
      while (v337);
      v320 = v334;
      if (v332 != (v332 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_913:
        do
        {
          v340 = *((_QWORD *)v320 - 1);
          v320 -= 8;
          *(_QWORD *)v320 = 0;
          *((_QWORD *)v329 - 1) = v340;
          v329 -= 8;
        }
        while (v320 != v322);
      }
      v320 = (char *)__p[0];
      v341 = (char *)__p[1];
      __p[0] = v329;
      __p[1] = v321;
      *(_QWORD *)&v795 = v330;
      while (v341 != v320)
      {
        v343 = *((_QWORD *)v341 - 1);
        v341 -= 8;
        v342 = v343;
        *(_QWORD *)v341 = 0;
        if (v343)
          (*(void (**)(uint64_t))(*(_QWORD *)v342 + 8))(v342);
      }
    }
    if (v320)
      operator delete(v320);
  }
  else
  {
    *(_QWORD *)__p[1] = v311;
    v321 = v320 + 8;
  }
  __p[1] = v321;
  v344 = v793;
  v345 = operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(v790, 2);
  *(_QWORD *)v806 = "mps.square";
  *(_QWORD *)&v806[8] = 10;
  mlir::Pattern::Pattern((uint64_t)(v345 + 1), (uint64_t)"mps.square", 10, v790[0], v344, v806, 1uLL);
  *v345 = off_1E0E49E50;
  if (!v345[9])
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::MPS_SquareOfAbsolute]";
    *(_QWORD *)&v806[8] = 104;
    v346 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v346)
      v347 = v346;
    else
      v347 = *(_QWORD *)&v806[8];
    v348 = *(_QWORD *)v806 + v347;
    v349 = *(_QWORD *)&v806[8] - v347;
    if (*(_QWORD *)&v806[8] - v347 >= 0x12)
      v350 = 18;
    else
      v350 = *(_QWORD *)&v806[8] - v347;
    v351 = v348 + v350;
    v352 = v349 - v350;
    if (v352 >= v352 - 1)
      --v352;
    v345[8] = v351;
    v345[9] = v352;
  }
  v353 = *((unsigned int *)v345 + 22);
  if (v353 > *((_DWORD *)v345 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v345 + 10), v345 + 12, v353, 16);
    LODWORD(v353) = *((_DWORD *)v345 + 22);
  }
  *((_DWORD *)v345 + 22) = v353;
  v354 = (char *)__p[1];
  if (__p[1] >= (void *)v795)
  {
    v356 = (char *)__p[0];
    v357 = (char *)__p[1] - (char *)__p[0];
    v358 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v359 = v358 + 1;
    if ((unint64_t)(v358 + 1) >> 61)
      goto LABEL_900;
    v360 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v359)
      v359 = v360 >> 2;
    if ((unint64_t)v360 >= 0x7FFFFFFFFFFFFFF8)
      v361 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v361 = v359;
    if (v361)
    {
      if (v361 >> 61)
        goto LABEL_901;
      v362 = (char *)operator new(8 * v361);
    }
    else
    {
      v362 = 0;
    }
    v363 = &v362[8 * v358];
    v364 = &v362[8 * v361];
    *(_QWORD *)v363 = v345;
    v355 = v363 + 8;
    if (v354 == v356)
    {
      __p[0] = &v362[8 * v358];
      __p[1] = v363 + 8;
      *(_QWORD *)&v795 = v364;
    }
    else
    {
      v365 = v354 - v356 - 8;
      if (v365 < 0x78
        || &v354[-(v365 & 0xFFFFFFFFFFFFFFF8) - 8] < v363 && &v362[v357 - (v365 & 0xFFFFFFFFFFFFFFF8) - 8] < v354)
      {
        goto LABEL_914;
      }
      v366 = (v365 >> 3) + 1;
      v367 = 8 * (v366 & 0x3FFFFFFFFFFFFFFCLL);
      v368 = &v354[-v367];
      v363 -= v367;
      v369 = &v362[8 * v358 - 16];
      v370 = v354 - 16;
      v371 = v366 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v373 = *((_OWORD *)v370 - 1);
        v372 = *(_OWORD *)v370;
        *((_OWORD *)v370 - 1) = 0uLL;
        *(_OWORD *)v370 = 0uLL;
        *((_OWORD *)v369 - 1) = v373;
        *(_OWORD *)v369 = v372;
        v369 -= 32;
        v370 -= 32;
        v371 -= 4;
      }
      while (v371);
      v354 = v368;
      if (v366 != (v366 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_914:
        do
        {
          v374 = *((_QWORD *)v354 - 1);
          v354 -= 8;
          *(_QWORD *)v354 = 0;
          *((_QWORD *)v363 - 1) = v374;
          v363 -= 8;
        }
        while (v354 != v356);
      }
      v354 = (char *)__p[0];
      v375 = (char *)__p[1];
      __p[0] = v363;
      __p[1] = v355;
      *(_QWORD *)&v795 = v364;
      while (v375 != v354)
      {
        v377 = *((_QWORD *)v375 - 1);
        v375 -= 8;
        v376 = v377;
        *(_QWORD *)v375 = 0;
        if (v377)
          (*(void (**)(uint64_t))(*(_QWORD *)v376 + 8))(v376);
      }
    }
    if (v354)
      operator delete(v354);
  }
  else
  {
    *(_QWORD *)__p[1] = v345;
    v355 = v354 + 8;
  }
  __p[1] = v355;
  _ZN4mlir17RewritePatternSet6insertIJNS_3mps12_GLOBAL__N_121CanonicalizeReductionINS2_17ReductionArgMaxOpEEENS4_INS2_17ReductionArgMinOpEEENS4_INS2_14ReductionMaxOpEEENS4_INS2_14ReductionMinOpEEENS4_INS2_15ReductionProdOpEEENS4_INS2_14ReductionSumOpEEENS3_25CanonicalizeReductionAxesIS5_EENSH_IS7_EENSH_IS9_EENSH_ISB_EENSH_ISD_EENSH_ISF_EENS3_27CanonicalizeMatMulTransposeENS3_20CanonicalizeMatMul1DENS3_27CanonicalizeConvToDepthwiseINS2_8Conv2DOpEEENSQ_INS2_20Conv2DDataGradientOpEEENS3_33CanonicalizeSparseMatMulTransposeENS3_35CanonicalizeQuantizedMatmulTranposeENS3_7FuseRMSINS2_10MultiplyOpEEENSX_INS2_8DivideOpEEENS3_16CanonicalizeRoPEENS3_24CanonicalizeReadVariableENS3_32CanonicalizeStridedSliceToGatherEERPNS_11MLIRContextEJEvEERS0_OT0_DpOT1_(&v793, &v791);
  if (*((_BYTE *)this + 680))
  {
    v378 = operator new(0x60uLL);
    v379 = v791;
    mlir::PatternBenefit::PatternBenefit(v806, 2);
    mlir::Pattern::Pattern((uint64_t)(v378 + 1), (uint64_t)"mps.conv_2d", 11, *(__int16 *)v806, v379, 0, 0);
    *v378 = &off_1E0E4B160;
    if (!v378[9])
    {
      *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeQ"
                        "uantizedLayerScale<mlir::mps::Conv2DOp>]";
      *(_QWORD *)&v806[8] = 136;
      v380 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
      if (*(_QWORD *)&v806[8] >= v380)
        v381 = v380;
      else
        v381 = *(_QWORD *)&v806[8];
      v382 = *(_QWORD *)v806 + v381;
      v383 = *(_QWORD *)&v806[8] - v381;
      if (*(_QWORD *)&v806[8] - v381 >= 0x12)
        v384 = 18;
      else
        v384 = *(_QWORD *)&v806[8] - v381;
      v385 = v382 + v384;
      v386 = v383 - v384;
      if (v386 >= v386 - 1)
        --v386;
      v378[8] = v385;
      v378[9] = v386;
    }
    v387 = *((unsigned int *)v378 + 22);
    if (v387 > *((_DWORD *)v378 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v378 + 10), v378 + 12, v387, 16);
      LODWORD(v387) = *((_DWORD *)v378 + 22);
    }
    *((_DWORD *)v378 + 22) = v387;
    v388 = (char *)__p[1];
    if (__p[1] >= (void *)v795)
    {
      v409 = (char *)__p[0];
      v410 = (char *)__p[1] - (char *)__p[0];
      v411 = ((char *)__p[1] - (char *)__p[0]) >> 3;
      v412 = v411 + 1;
      if ((unint64_t)(v411 + 1) >> 61)
        goto LABEL_900;
      v413 = v795 - (unint64_t)__p[0];
      if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v412)
        v412 = v413 >> 2;
      if ((unint64_t)v413 >= 0x7FFFFFFFFFFFFFF8)
        v414 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v414 = v412;
      if (v414)
      {
        if (v414 >> 61)
          goto LABEL_901;
        v415 = (char *)operator new(8 * v414);
      }
      else
      {
        v415 = 0;
      }
      v416 = &v415[8 * v411];
      v417 = &v415[8 * v414];
      *(_QWORD *)v416 = v378;
      v389 = v416 + 8;
      if (v388 == v409)
      {
        __p[0] = &v415[8 * v411];
        __p[1] = v416 + 8;
        *(_QWORD *)&v795 = v417;
      }
      else
      {
        v418 = v388 - v409 - 8;
        if (v418 < 0x78
          || &v388[-(v418 & 0xFFFFFFFFFFFFFFF8) - 8] < v416 && &v415[v410 - (v418 & 0xFFFFFFFFFFFFFFF8) - 8] < v388)
        {
          goto LABEL_915;
        }
        v419 = (v418 >> 3) + 1;
        v420 = 8 * (v419 & 0x3FFFFFFFFFFFFFFCLL);
        v421 = &v388[-v420];
        v416 -= v420;
        v422 = &v415[8 * v411 - 16];
        v423 = v388 - 16;
        v424 = v419 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v426 = *((_OWORD *)v423 - 1);
          v425 = *(_OWORD *)v423;
          *((_OWORD *)v423 - 1) = 0uLL;
          *(_OWORD *)v423 = 0uLL;
          *((_OWORD *)v422 - 1) = v426;
          *(_OWORD *)v422 = v425;
          v422 -= 32;
          v423 -= 32;
          v424 -= 4;
        }
        while (v424);
        v388 = v421;
        if (v419 != (v419 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_915:
          do
          {
            v427 = *((_QWORD *)v388 - 1);
            v388 -= 8;
            *(_QWORD *)v388 = 0;
            *((_QWORD *)v416 - 1) = v427;
            v416 -= 8;
          }
          while (v388 != v409);
        }
        v388 = (char *)__p[0];
        v428 = (char *)__p[1];
        __p[0] = v416;
        __p[1] = v389;
        *(_QWORD *)&v795 = v417;
        while (v428 != v388)
        {
          v430 = *((_QWORD *)v428 - 1);
          v428 -= 8;
          v429 = v430;
          *(_QWORD *)v428 = 0;
          if (v430)
            (*(void (**)(uint64_t))(*(_QWORD *)v429 + 8))(v429);
        }
      }
      if (v388)
        operator delete(v388);
    }
    else
    {
      *(_QWORD *)__p[1] = v378;
      v389 = v388 + 8;
    }
    __p[1] = v389;
    v431 = operator new(0x60uLL);
    v432 = v791;
    mlir::PatternBenefit::PatternBenefit(v806, 2);
    mlir::Pattern::Pattern((uint64_t)(v431 + 1), (uint64_t)"mps.depthwise_conv_3d", 21, *(__int16 *)v806, v432, 0, 0);
    *v431 = &off_1E0E4B0B0;
    if (!v431[9])
    {
      *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeQ"
                        "uantizedLayerScale<mlir::mps::DepthwiseConv3DOp>]";
      *(_QWORD *)&v806[8] = 145;
      v433 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
      if (*(_QWORD *)&v806[8] >= v433)
        v434 = v433;
      else
        v434 = *(_QWORD *)&v806[8];
      v435 = *(_QWORD *)v806 + v434;
      v436 = *(_QWORD *)&v806[8] - v434;
      if (*(_QWORD *)&v806[8] - v434 >= 0x12)
        v437 = 18;
      else
        v437 = *(_QWORD *)&v806[8] - v434;
      v438 = v435 + v437;
      v439 = v436 - v437;
      if (v439 >= v439 - 1)
        --v439;
      v431[8] = v438;
      v431[9] = v439;
    }
    v440 = *((unsigned int *)v431 + 22);
    if (v440 > *((_DWORD *)v431 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v431 + 10), v431 + 12, v440, 16);
      LODWORD(v440) = *((_DWORD *)v431 + 22);
    }
    *((_DWORD *)v431 + 22) = v440;
    v441 = (char *)__p[1];
    if (__p[1] >= (void *)v795)
    {
      v443 = (char *)__p[0];
      v444 = (char *)__p[1] - (char *)__p[0];
      v445 = ((char *)__p[1] - (char *)__p[0]) >> 3;
      v446 = v445 + 1;
      if ((unint64_t)(v445 + 1) >> 61)
        goto LABEL_900;
      v447 = v795 - (unint64_t)__p[0];
      if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v446)
        v446 = v447 >> 2;
      if ((unint64_t)v447 >= 0x7FFFFFFFFFFFFFF8)
        v448 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v448 = v446;
      if (v448)
      {
        if (v448 >> 61)
          goto LABEL_901;
        v449 = (char *)operator new(8 * v448);
      }
      else
      {
        v449 = 0;
      }
      v450 = &v449[8 * v445];
      v451 = &v449[8 * v448];
      *(_QWORD *)v450 = v431;
      v442 = v450 + 8;
      if (v441 == v443)
      {
        __p[0] = &v449[8 * v445];
        __p[1] = v450 + 8;
        *(_QWORD *)&v795 = v451;
      }
      else
      {
        v452 = v441 - v443 - 8;
        if (v452 < 0x78
          || &v441[-(v452 & 0xFFFFFFFFFFFFFFF8) - 8] < v450 && &v449[v444 - (v452 & 0xFFFFFFFFFFFFFFF8) - 8] < v441)
        {
          goto LABEL_916;
        }
        v453 = (v452 >> 3) + 1;
        v454 = 8 * (v453 & 0x3FFFFFFFFFFFFFFCLL);
        v455 = &v441[-v454];
        v450 -= v454;
        v456 = &v449[8 * v445 - 16];
        v457 = v441 - 16;
        v458 = v453 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v460 = *((_OWORD *)v457 - 1);
          v459 = *(_OWORD *)v457;
          *((_OWORD *)v457 - 1) = 0uLL;
          *(_OWORD *)v457 = 0uLL;
          *((_OWORD *)v456 - 1) = v460;
          *(_OWORD *)v456 = v459;
          v456 -= 32;
          v457 -= 32;
          v458 -= 4;
        }
        while (v458);
        v441 = v455;
        if (v453 != (v453 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_916:
          do
          {
            v461 = *((_QWORD *)v441 - 1);
            v441 -= 8;
            *(_QWORD *)v441 = 0;
            *((_QWORD *)v450 - 1) = v461;
            v450 -= 8;
          }
          while (v441 != v443);
        }
        v441 = (char *)__p[0];
        v462 = (char *)__p[1];
        __p[0] = v450;
        __p[1] = v442;
        *(_QWORD *)&v795 = v451;
        while (v462 != v441)
        {
          v464 = *((_QWORD *)v462 - 1);
          v462 -= 8;
          v463 = v464;
          *(_QWORD *)v462 = 0;
          if (v464)
            (*(void (**)(uint64_t))(*(_QWORD *)v463 + 8))(v463);
        }
      }
      if (v441)
        operator delete(v441);
    }
    else
    {
      *(_QWORD *)__p[1] = v431;
      v442 = v441 + 8;
    }
    __p[1] = v442;
    v465 = operator new(0x60uLL);
    v466 = v791;
    mlir::PatternBenefit::PatternBenefit(v806, 2);
    mlir::Pattern::Pattern((uint64_t)(v465 + 1), (uint64_t)"mps.depthwise_conv_3d_data_gradient", 35, *(__int16 *)v806, v466, 0, 0);
    *v465 = &off_1E0E4B108;
    if (!v465[9])
    {
      *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeQ"
                        "uantizedLayerScale<mlir::mps::DepthwiseConv3DDataGradientOp>]";
      *(_QWORD *)&v806[8] = 157;
      v467 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
      if (*(_QWORD *)&v806[8] >= v467)
        v468 = v467;
      else
        v468 = *(_QWORD *)&v806[8];
      v469 = *(_QWORD *)v806 + v468;
      v470 = *(_QWORD *)&v806[8] - v468;
      if (*(_QWORD *)&v806[8] - v468 >= 0x12)
        v471 = 18;
      else
        v471 = *(_QWORD *)&v806[8] - v468;
      v472 = v469 + v471;
      v473 = v470 - v471;
      if (v473 >= v473 - 1)
        --v473;
      v465[8] = v472;
      v465[9] = v473;
    }
    v474 = *((unsigned int *)v465 + 22);
    if (v474 > *((_DWORD *)v465 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v465 + 10), v465 + 12, v474, 16);
      LODWORD(v474) = *((_DWORD *)v465 + 22);
    }
    *((_DWORD *)v465 + 22) = v474;
    v475 = (char *)__p[1];
    if (__p[1] >= (void *)v795)
    {
      v477 = (char *)__p[0];
      v478 = (char *)__p[1] - (char *)__p[0];
      v479 = ((char *)__p[1] - (char *)__p[0]) >> 3;
      v480 = v479 + 1;
      if ((unint64_t)(v479 + 1) >> 61)
        goto LABEL_900;
      v481 = v795 - (unint64_t)__p[0];
      if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v480)
        v480 = v481 >> 2;
      if ((unint64_t)v481 >= 0x7FFFFFFFFFFFFFF8)
        v482 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v482 = v480;
      if (v482)
      {
        if (v482 >> 61)
          goto LABEL_901;
        v483 = (char *)operator new(8 * v482);
      }
      else
      {
        v483 = 0;
      }
      v484 = &v483[8 * v479];
      v485 = &v483[8 * v482];
      *(_QWORD *)v484 = v465;
      v476 = v484 + 8;
      if (v475 == v477)
      {
        __p[0] = &v483[8 * v479];
        __p[1] = v484 + 8;
        *(_QWORD *)&v795 = v485;
      }
      else
      {
        v486 = v475 - v477 - 8;
        if (v486 < 0x78
          || &v475[-(v486 & 0xFFFFFFFFFFFFFFF8) - 8] < v484 && &v483[v478 - (v486 & 0xFFFFFFFFFFFFFFF8) - 8] < v475)
        {
          goto LABEL_917;
        }
        v487 = (v486 >> 3) + 1;
        v488 = 8 * (v487 & 0x3FFFFFFFFFFFFFFCLL);
        v489 = &v475[-v488];
        v484 -= v488;
        v490 = &v483[8 * v479 - 16];
        v491 = v475 - 16;
        v492 = v487 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v494 = *((_OWORD *)v491 - 1);
          v493 = *(_OWORD *)v491;
          *((_OWORD *)v491 - 1) = 0uLL;
          *(_OWORD *)v491 = 0uLL;
          *((_OWORD *)v490 - 1) = v494;
          *(_OWORD *)v490 = v493;
          v490 -= 32;
          v491 -= 32;
          v492 -= 4;
        }
        while (v492);
        v475 = v489;
        if (v487 != (v487 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_917:
          do
          {
            v495 = *((_QWORD *)v475 - 1);
            v475 -= 8;
            *(_QWORD *)v475 = 0;
            *((_QWORD *)v484 - 1) = v495;
            v484 -= 8;
          }
          while (v475 != v477);
        }
        v475 = (char *)__p[0];
        v496 = (char *)__p[1];
        __p[0] = v484;
        __p[1] = v476;
        *(_QWORD *)&v795 = v485;
        while (v496 != v475)
        {
          v498 = *((_QWORD *)v496 - 1);
          v496 -= 8;
          v497 = v498;
          *(_QWORD *)v496 = 0;
          if (v498)
            (*(void (**)(uint64_t))(*(_QWORD *)v497 + 8))(v497);
        }
      }
      if (v475)
        operator delete(v475);
    }
    else
    {
      *(_QWORD *)__p[1] = v465;
      v476 = v475 + 8;
    }
    __p[1] = v476;
    v390 = operator new(0x60uLL);
    v499 = v791;
    mlir::PatternBenefit::PatternBenefit(v806, 2);
    mlir::Pattern::Pattern((uint64_t)(v390 + 1), (uint64_t)"mps.matmul", 10, *(__int16 *)v806, v499, 0, 0);
    *v390 = &off_1E0E4B1B8;
    if (!v390[9])
    {
      *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeQ"
                        "uantizedLayerScale<mlir::mps::MatMulOp>]";
      *(_QWORD *)&v806[8] = 136;
      v500 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
      if (*(_QWORD *)&v806[8] >= v500)
        v501 = v500;
      else
        v501 = *(_QWORD *)&v806[8];
      v502 = *(_QWORD *)v806 + v501;
      v503 = *(_QWORD *)&v806[8] - v501;
      if (*(_QWORD *)&v806[8] - v501 >= 0x12)
        v504 = 18;
      else
        v504 = *(_QWORD *)&v806[8] - v501;
      v505 = v502 + v504;
      v506 = v503 - v504;
      if (v506 >= v506 - 1)
        --v506;
      v390[8] = v505;
      v390[9] = v506;
    }
    v507 = *((unsigned int *)v390 + 22);
    if (v507 > *((_DWORD *)v390 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v390 + 10), v390 + 12, v507, 16);
      LODWORD(v507) = *((_DWORD *)v390 + 22);
    }
    *((_DWORD *)v390 + 22) = v507;
    v401 = (char *)__p[1];
    if (__p[1] < (void *)v795)
      goto LABEL_583;
    v509 = (char *)__p[0];
    v510 = (char *)__p[1] - (char *)__p[0];
    v511 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v512 = v511 + 1;
    if ((unint64_t)(v511 + 1) >> 61)
      goto LABEL_900;
    v513 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v512)
      v512 = v513 >> 2;
    if ((unint64_t)v513 >= 0x7FFFFFFFFFFFFFF8)
      v514 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v514 = v512;
    if (v514)
    {
      if (v514 >> 61)
        goto LABEL_901;
      v515 = (char *)operator new(8 * v514);
    }
    else
    {
      v515 = 0;
    }
    v516 = &v515[8 * v511];
    v517 = &v515[8 * v514];
    *(_QWORD *)v516 = v390;
    v508 = v516 + 8;
    if (v401 != v509)
    {
      v518 = v401 - v509 - 8;
      if (v518 < 0x78
        || &v401[-(v518 & 0xFFFFFFFFFFFFFFF8) - 8] < v516 && &v515[v510 - (v518 & 0xFFFFFFFFFFFFFFF8) - 8] < v401)
      {
        goto LABEL_918;
      }
      v519 = (v518 >> 3) + 1;
      v520 = 8 * (v519 & 0x3FFFFFFFFFFFFFFCLL);
      v521 = &v401[-v520];
      v516 -= v520;
      v522 = &v515[8 * v511 - 16];
      v523 = v401 - 16;
      v524 = v519 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v526 = *((_OWORD *)v523 - 1);
        v525 = *(_OWORD *)v523;
        *((_OWORD *)v523 - 1) = 0uLL;
        *(_OWORD *)v523 = 0uLL;
        *((_OWORD *)v522 - 1) = v526;
        *(_OWORD *)v522 = v525;
        v522 -= 32;
        v523 -= 32;
        v524 -= 4;
      }
      while (v524);
      v401 = v521;
      if (v519 != (v519 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_918:
        do
        {
          v527 = *((_QWORD *)v401 - 1);
          v401 -= 8;
          *(_QWORD *)v401 = 0;
          *((_QWORD *)v516 - 1) = v527;
          v516 -= 8;
        }
        while (v401 != v509);
      }
      v401 = (char *)__p[0];
      v528 = (char *)__p[1];
      __p[0] = v516;
      __p[1] = v508;
      *(_QWORD *)&v795 = v517;
      while (v528 != v401)
      {
        v530 = *((_QWORD *)v528 - 1);
        v528 -= 8;
        v529 = v530;
        *(_QWORD *)v528 = 0;
        if (v530)
          (*(void (**)(uint64_t))(*(_QWORD *)v529 + 8))(v529);
      }
      goto LABEL_620;
    }
  }
  else
  {
    v390 = operator new(0x68uLL);
    v391 = v791;
    v392 = *((_DWORD *)this + 222);
    mlir::PatternBenefit::PatternBenefit(v806, 2);
    mlir::Pattern::Pattern((uint64_t)(v390 + 1), (uint64_t)"mps.matmul", 10, *(__int16 *)v806, v391, 0, 0);
    *v390 = &off_1E0DFB4A8;
    *((_DWORD *)v390 + 24) = v392;
    if (!v390[9])
    {
      *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::Conditionally"
                        "CanonicalizeQuantizedOp<mlir::mps::MatMulOp>]";
      *(_QWORD *)&v806[8] = 141;
      v393 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
      if (*(_QWORD *)&v806[8] >= v393)
        v394 = v393;
      else
        v394 = *(_QWORD *)&v806[8];
      v395 = *(_QWORD *)v806 + v394;
      v396 = *(_QWORD *)&v806[8] - v394;
      if (*(_QWORD *)&v806[8] - v394 >= 0x12)
        v397 = 18;
      else
        v397 = *(_QWORD *)&v806[8] - v394;
      v398 = v395 + v397;
      v399 = v396 - v397;
      if (v399 >= v399 - 1)
        --v399;
      v390[8] = v398;
      v390[9] = v399;
    }
    v400 = *((unsigned int *)v390 + 22);
    if (v400 > *((_DWORD *)v390 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v390 + 10), v390 + 12, v400, 16);
      LODWORD(v400) = *((_DWORD *)v390 + 22);
    }
    *((_DWORD *)v390 + 22) = v400;
    v401 = (char *)__p[1];
    if (__p[1] < (void *)v795)
    {
LABEL_583:
      *(_QWORD *)v401 = v390;
      v508 = v401 + 8;
      goto LABEL_622;
    }
    v402 = (char *)__p[0];
    v403 = (char *)__p[1] - (char *)__p[0];
    v404 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v405 = v404 + 1;
    if ((unint64_t)(v404 + 1) >> 61)
      goto LABEL_900;
    v406 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v405)
      v405 = v406 >> 2;
    if ((unint64_t)v406 >= 0x7FFFFFFFFFFFFFF8)
      v407 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v407 = v405;
    if (v407)
    {
      if (v407 >> 61)
        goto LABEL_901;
      v408 = (char *)operator new(8 * v407);
    }
    else
    {
      v408 = 0;
    }
    v516 = &v408[8 * v404];
    v517 = &v408[8 * v407];
    *(_QWORD *)v516 = v390;
    v508 = v516 + 8;
    if (v401 != v402)
    {
      v531 = v401 - v402 - 8;
      if (v531 < 0x78
        || &v401[-(v531 & 0xFFFFFFFFFFFFFFF8) - 8] < v516 && &v408[v403 - (v531 & 0xFFFFFFFFFFFFFFF8) - 8] < v401)
      {
        goto LABEL_919;
      }
      v532 = (v531 >> 3) + 1;
      v533 = 8 * (v532 & 0x3FFFFFFFFFFFFFFCLL);
      v534 = &v401[-v533];
      v516 -= v533;
      v535 = &v408[8 * v404 - 16];
      v536 = v401 - 16;
      v537 = v532 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v539 = *((_OWORD *)v536 - 1);
        v538 = *(_OWORD *)v536;
        *((_OWORD *)v536 - 1) = 0uLL;
        *(_OWORD *)v536 = 0uLL;
        *((_OWORD *)v535 - 1) = v539;
        *(_OWORD *)v535 = v538;
        v535 -= 32;
        v536 -= 32;
        v537 -= 4;
      }
      while (v537);
      v401 = v534;
      if (v532 != (v532 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_919:
        do
        {
          v540 = *((_QWORD *)v401 - 1);
          v401 -= 8;
          *(_QWORD *)v401 = 0;
          *((_QWORD *)v516 - 1) = v540;
          v516 -= 8;
        }
        while (v401 != v402);
      }
      v401 = (char *)__p[0];
      v541 = (char *)__p[1];
      __p[0] = v516;
      __p[1] = v508;
      *(_QWORD *)&v795 = v517;
      while (v541 != v401)
      {
        v543 = *((_QWORD *)v541 - 1);
        v541 -= 8;
        v542 = v543;
        *(_QWORD *)v541 = 0;
        if (v543)
          (*(void (**)(uint64_t))(*(_QWORD *)v542 + 8))(v542);
      }
      goto LABEL_620;
    }
  }
  __p[0] = v516;
  __p[1] = v508;
  *(_QWORD *)&v795 = v517;
LABEL_620:
  if (v401)
    operator delete(v401);
LABEL_622:
  __p[1] = v508;
  if (*((_BYTE *)this + 472))
  {
    v544 = operator new(0x60uLL);
    v545 = v791;
    mlir::PatternBenefit::PatternBenefit(v806, 1);
    mlir::Pattern::Pattern((uint64_t)(v544 + 1), (uint64_t)"mps.transpose", 13, *(__int16 *)v806, v545, 0, 0);
    *v544 = off_1E0E4A798;
    if (!v544[9])
    {
      *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeMatMulNNToNT]";
      *(_QWORD *)&v806[8] = 108;
      v546 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
      if (*(_QWORD *)&v806[8] >= v546)
        v547 = v546;
      else
        v547 = *(_QWORD *)&v806[8];
      v548 = *(_QWORD *)v806 + v547;
      v549 = *(_QWORD *)&v806[8] - v547;
      if (*(_QWORD *)&v806[8] - v547 >= 0x12)
        v550 = 18;
      else
        v550 = *(_QWORD *)&v806[8] - v547;
      v551 = v548 + v550;
      v552 = v549 - v550;
      if (v552 >= v552 - 1)
        --v552;
      v544[8] = v551;
      v544[9] = v552;
    }
    v553 = *((unsigned int *)v544 + 22);
    if (v553 > *((_DWORD *)v544 + 23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v544 + 10), v544 + 12, v553, 16);
      LODWORD(v553) = *((_DWORD *)v544 + 22);
    }
    *((_DWORD *)v544 + 22) = v553;
    v554 = (char *)__p[1];
    if (__p[1] >= (void *)v795)
    {
      v556 = (char *)__p[0];
      v557 = (char *)__p[1] - (char *)__p[0];
      v558 = ((char *)__p[1] - (char *)__p[0]) >> 3;
      v559 = v558 + 1;
      if ((unint64_t)(v558 + 1) >> 61)
        goto LABEL_900;
      v560 = v795 - (unint64_t)__p[0];
      if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v559)
        v559 = v560 >> 2;
      if ((unint64_t)v560 >= 0x7FFFFFFFFFFFFFF8)
        v561 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v561 = v559;
      if (v561)
      {
        if (v561 >> 61)
          goto LABEL_901;
        v562 = (char *)operator new(8 * v561);
      }
      else
      {
        v562 = 0;
      }
      v563 = &v562[8 * v558];
      v564 = &v562[8 * v561];
      *(_QWORD *)v563 = v544;
      v555 = v563 + 8;
      if (v554 == v556)
      {
        __p[0] = &v562[8 * v558];
        __p[1] = v563 + 8;
        *(_QWORD *)&v795 = v564;
      }
      else
      {
        v565 = v554 - v556 - 8;
        if (v565 < 0x78
          || &v554[-(v565 & 0xFFFFFFFFFFFFFFF8) - 8] < v563 && &v562[v557 - (v565 & 0xFFFFFFFFFFFFFFF8) - 8] < v554)
        {
          goto LABEL_920;
        }
        v566 = (v565 >> 3) + 1;
        v567 = 8 * (v566 & 0x3FFFFFFFFFFFFFFCLL);
        v568 = &v554[-v567];
        v563 -= v567;
        v569 = &v562[8 * v558 - 16];
        v570 = v554 - 16;
        v571 = v566 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v573 = *((_OWORD *)v570 - 1);
          v572 = *(_OWORD *)v570;
          *((_OWORD *)v570 - 1) = 0uLL;
          *(_OWORD *)v570 = 0uLL;
          *((_OWORD *)v569 - 1) = v573;
          *(_OWORD *)v569 = v572;
          v569 -= 32;
          v570 -= 32;
          v571 -= 4;
        }
        while (v571);
        v554 = v568;
        if (v566 != (v566 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_920:
          do
          {
            v574 = *((_QWORD *)v554 - 1);
            v554 -= 8;
            *(_QWORD *)v554 = 0;
            *((_QWORD *)v563 - 1) = v574;
            v563 -= 8;
          }
          while (v554 != v556);
        }
        v554 = (char *)__p[0];
        v575 = (char *)__p[1];
        __p[0] = v563;
        __p[1] = v555;
        *(_QWORD *)&v795 = v564;
        while (v575 != v554)
        {
          v577 = *((_QWORD *)v575 - 1);
          v575 -= 8;
          v576 = v577;
          *(_QWORD *)v575 = 0;
          if (v577)
            (*(void (**)(uint64_t))(*(_QWORD *)v576 + 8))(v576);
        }
      }
      if (v554)
        operator delete(v554);
    }
    else
    {
      *(_QWORD *)__p[1] = v544;
      v555 = v554 + 8;
    }
    __p[1] = v555;
  }
  v578 = operator new(0x68uLL);
  v579 = v791;
  v580 = *((_BYTE *)this + 1096);
  mlir::PatternBenefit::PatternBenefit(v806, 1);
  mlir::Pattern::Pattern((uint64_t)(v578 + 8), (uint64_t)"mps.conv_2d", 11, *(__int16 *)v806, v579, 0, 0);
  *(_QWORD *)v578 = &off_1E0DFB240;
  v578[96] = v580;
  if (!*((_QWORD *)v578 + 9))
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeCon"
                      "vToMatMul<mlir::mps::Conv2DOp>]";
    *(_QWORD *)&v806[8] = 129;
    v581 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v581)
      v582 = v581;
    else
      v582 = *(_QWORD *)&v806[8];
    v583 = *(_QWORD *)v806 + v582;
    v584 = *(_QWORD *)&v806[8] - v582;
    if (*(_QWORD *)&v806[8] - v582 >= 0x12)
      v585 = 18;
    else
      v585 = *(_QWORD *)&v806[8] - v582;
    v586 = v583 + v585;
    v587 = v584 - v585;
    if (v587 >= v587 - 1)
      --v587;
    *((_QWORD *)v578 + 8) = v586;
    *((_QWORD *)v578 + 9) = v587;
  }
  v588 = *((unsigned int *)v578 + 22);
  if (v588 > *((_DWORD *)v578 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v578 + 80), v578 + 96, v588, 16);
    LODWORD(v588) = *((_DWORD *)v578 + 22);
  }
  *((_DWORD *)v578 + 22) = v588;
  v589 = (char *)__p[1];
  if (__p[1] >= (void *)v795)
  {
    v591 = (char *)__p[0];
    v592 = (char *)__p[1] - (char *)__p[0];
    v593 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v594 = v593 + 1;
    if ((unint64_t)(v593 + 1) >> 61)
      goto LABEL_900;
    v595 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v594)
      v594 = v595 >> 2;
    if ((unint64_t)v595 >= 0x7FFFFFFFFFFFFFF8)
      v596 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v596 = v594;
    if (v596)
    {
      if (v596 >> 61)
        goto LABEL_901;
      v597 = (char *)operator new(8 * v596);
    }
    else
    {
      v597 = 0;
    }
    v598 = &v597[8 * v593];
    v599 = &v597[8 * v596];
    *(_QWORD *)v598 = v578;
    v590 = v598 + 8;
    if (v589 == v591)
    {
      __p[0] = &v597[8 * v593];
      __p[1] = v598 + 8;
      *(_QWORD *)&v795 = v599;
    }
    else
    {
      v600 = v589 - v591 - 8;
      if (v600 < 0x78
        || &v589[-(v600 & 0xFFFFFFFFFFFFFFF8) - 8] < v598 && &v597[v592 - (v600 & 0xFFFFFFFFFFFFFFF8) - 8] < v589)
      {
        goto LABEL_921;
      }
      v601 = (v600 >> 3) + 1;
      v602 = 8 * (v601 & 0x3FFFFFFFFFFFFFFCLL);
      v603 = &v589[-v602];
      v598 -= v602;
      v604 = &v597[8 * v593 - 16];
      v605 = v589 - 16;
      v606 = v601 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v608 = *((_OWORD *)v605 - 1);
        v607 = *(_OWORD *)v605;
        *((_OWORD *)v605 - 1) = 0uLL;
        *(_OWORD *)v605 = 0uLL;
        *((_OWORD *)v604 - 1) = v608;
        *(_OWORD *)v604 = v607;
        v604 -= 32;
        v605 -= 32;
        v606 -= 4;
      }
      while (v606);
      v589 = v603;
      if (v601 != (v601 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_921:
        do
        {
          v609 = *((_QWORD *)v589 - 1);
          v589 -= 8;
          *(_QWORD *)v589 = 0;
          *((_QWORD *)v598 - 1) = v609;
          v598 -= 8;
        }
        while (v589 != v591);
      }
      v589 = (char *)__p[0];
      v610 = (char *)__p[1];
      __p[0] = v598;
      __p[1] = v590;
      *(_QWORD *)&v795 = v599;
      while (v610 != v589)
      {
        v612 = *((_QWORD *)v610 - 1);
        v610 -= 8;
        v611 = v612;
        *(_QWORD *)v610 = 0;
        if (v612)
          (*(void (**)(uint64_t))(*(_QWORD *)v611 + 8))(v611);
      }
    }
    if (v589)
      operator delete(v589);
  }
  else
  {
    *(_QWORD *)__p[1] = v578;
    v590 = v589 + 8;
  }
  __p[1] = v590;
  v613 = operator new(0x68uLL);
  v614 = v791;
  v615 = *((_BYTE *)this + 1096);
  mlir::PatternBenefit::PatternBenefit(v806, 1);
  mlir::Pattern::Pattern((uint64_t)(v613 + 8), (uint64_t)"mps.conv_2d_data_gradient", 25, *(__int16 *)v806, v614, 0, 0);
  *(_QWORD *)v613 = &off_1E0DFB138;
  v613[96] = v615;
  if (!*((_QWORD *)v613 + 9))
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeCon"
                      "vToMatMul<mlir::mps::Conv2DDataGradientOp>]";
    *(_QWORD *)&v806[8] = 141;
    v616 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v616)
      v617 = v616;
    else
      v617 = *(_QWORD *)&v806[8];
    v618 = *(_QWORD *)v806 + v617;
    v619 = *(_QWORD *)&v806[8] - v617;
    if (*(_QWORD *)&v806[8] - v617 >= 0x12)
      v620 = 18;
    else
      v620 = *(_QWORD *)&v806[8] - v617;
    v621 = v618 + v620;
    v622 = v619 - v620;
    if (v622 >= v622 - 1)
      --v622;
    *((_QWORD *)v613 + 8) = v621;
    *((_QWORD *)v613 + 9) = v622;
  }
  v623 = *((unsigned int *)v613 + 22);
  if (v623 > *((_DWORD *)v613 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v613 + 80), v613 + 96, v623, 16);
    LODWORD(v623) = *((_DWORD *)v613 + 22);
  }
  *((_DWORD *)v613 + 22) = v623;
  v624 = (char *)__p[1];
  if (__p[1] >= (void *)v795)
  {
    v626 = (char *)__p[0];
    v627 = (char *)__p[1] - (char *)__p[0];
    v628 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v629 = v628 + 1;
    if ((unint64_t)(v628 + 1) >> 61)
      goto LABEL_900;
    v630 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v629)
      v629 = v630 >> 2;
    if ((unint64_t)v630 >= 0x7FFFFFFFFFFFFFF8)
      v631 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v631 = v629;
    if (v631)
    {
      if (v631 >> 61)
        goto LABEL_901;
      v632 = (char *)operator new(8 * v631);
    }
    else
    {
      v632 = 0;
    }
    v633 = &v632[8 * v628];
    v634 = &v632[8 * v631];
    *(_QWORD *)v633 = v613;
    v625 = v633 + 8;
    if (v624 == v626)
    {
      __p[0] = &v632[8 * v628];
      __p[1] = v633 + 8;
      *(_QWORD *)&v795 = v634;
    }
    else
    {
      v635 = v624 - v626 - 8;
      if (v635 < 0x78
        || &v624[-(v635 & 0xFFFFFFFFFFFFFFF8) - 8] < v633 && &v632[v627 - (v635 & 0xFFFFFFFFFFFFFFF8) - 8] < v624)
      {
        goto LABEL_922;
      }
      v636 = (v635 >> 3) + 1;
      v637 = 8 * (v636 & 0x3FFFFFFFFFFFFFFCLL);
      v638 = &v624[-v637];
      v633 -= v637;
      v639 = &v632[8 * v628 - 16];
      v640 = v624 - 16;
      v641 = v636 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v643 = *((_OWORD *)v640 - 1);
        v642 = *(_OWORD *)v640;
        *((_OWORD *)v640 - 1) = 0uLL;
        *(_OWORD *)v640 = 0uLL;
        *((_OWORD *)v639 - 1) = v643;
        *(_OWORD *)v639 = v642;
        v639 -= 32;
        v640 -= 32;
        v641 -= 4;
      }
      while (v641);
      v624 = v638;
      if (v636 != (v636 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_922:
        do
        {
          v644 = *((_QWORD *)v624 - 1);
          v624 -= 8;
          *(_QWORD *)v624 = 0;
          *((_QWORD *)v633 - 1) = v644;
          v633 -= 8;
        }
        while (v624 != v626);
      }
      v624 = (char *)__p[0];
      v645 = (char *)__p[1];
      __p[0] = v633;
      __p[1] = v625;
      *(_QWORD *)&v795 = v634;
      while (v645 != v624)
      {
        v647 = *((_QWORD *)v645 - 1);
        v645 -= 8;
        v646 = v647;
        *(_QWORD *)v645 = 0;
        if (v647)
          (*(void (**)(uint64_t))(*(_QWORD *)v646 + 8))(v646);
      }
    }
    if (v624)
      operator delete(v624);
  }
  else
  {
    *(_QWORD *)__p[1] = v613;
    v625 = v624 + 8;
  }
  __p[1] = v625;
  v648 = operator new(0x68uLL);
  v649 = v791;
  v650 = *((_BYTE *)this + 1096);
  mlir::PatternBenefit::PatternBenefit(v806, 1);
  mlir::Pattern::Pattern((uint64_t)(v648 + 8), (uint64_t)"mps.conv_3d", 11, *(__int16 *)v806, v649, 0, 0);
  *(_QWORD *)v648 = &off_1E0DFB298;
  v648[96] = v650;
  if (!*((_QWORD *)v648 + 9))
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeCon"
                      "vToMatMul<mlir::mps::Conv3DOp>]";
    *(_QWORD *)&v806[8] = 129;
    v651 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v651)
      v652 = v651;
    else
      v652 = *(_QWORD *)&v806[8];
    v653 = *(_QWORD *)v806 + v652;
    v654 = *(_QWORD *)&v806[8] - v652;
    if (*(_QWORD *)&v806[8] - v652 >= 0x12)
      v655 = 18;
    else
      v655 = *(_QWORD *)&v806[8] - v652;
    v656 = v653 + v655;
    v657 = v654 - v655;
    if (v657 >= v657 - 1)
      --v657;
    *((_QWORD *)v648 + 8) = v656;
    *((_QWORD *)v648 + 9) = v657;
  }
  v658 = *((unsigned int *)v648 + 22);
  if (v658 > *((_DWORD *)v648 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v648 + 80), v648 + 96, v658, 16);
    LODWORD(v658) = *((_DWORD *)v648 + 22);
  }
  *((_DWORD *)v648 + 22) = v658;
  v659 = (char *)__p[1];
  if (__p[1] >= (void *)v795)
  {
    v661 = (char *)__p[0];
    v662 = (char *)__p[1] - (char *)__p[0];
    v663 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v664 = v663 + 1;
    if ((unint64_t)(v663 + 1) >> 61)
      goto LABEL_900;
    v665 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v664)
      v664 = v665 >> 2;
    if ((unint64_t)v665 >= 0x7FFFFFFFFFFFFFF8)
      v666 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v666 = v664;
    if (v666)
    {
      if (v666 >> 61)
        goto LABEL_901;
      v667 = (char *)operator new(8 * v666);
    }
    else
    {
      v667 = 0;
    }
    v668 = &v667[8 * v663];
    v669 = &v667[8 * v666];
    *(_QWORD *)v668 = v648;
    v660 = v668 + 8;
    if (v659 == v661)
    {
      __p[0] = &v667[8 * v663];
      __p[1] = v668 + 8;
      *(_QWORD *)&v795 = v669;
    }
    else
    {
      v670 = v659 - v661 - 8;
      if (v670 < 0x78
        || &v659[-(v670 & 0xFFFFFFFFFFFFFFF8) - 8] < v668 && &v667[v662 - (v670 & 0xFFFFFFFFFFFFFFF8) - 8] < v659)
      {
        goto LABEL_923;
      }
      v671 = (v670 >> 3) + 1;
      v672 = 8 * (v671 & 0x3FFFFFFFFFFFFFFCLL);
      v673 = &v659[-v672];
      v668 -= v672;
      v674 = &v667[8 * v663 - 16];
      v675 = v659 - 16;
      v676 = v671 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v678 = *((_OWORD *)v675 - 1);
        v677 = *(_OWORD *)v675;
        *((_OWORD *)v675 - 1) = 0uLL;
        *(_OWORD *)v675 = 0uLL;
        *((_OWORD *)v674 - 1) = v678;
        *(_OWORD *)v674 = v677;
        v674 -= 32;
        v675 -= 32;
        v676 -= 4;
      }
      while (v676);
      v659 = v673;
      if (v671 != (v671 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_923:
        do
        {
          v679 = *((_QWORD *)v659 - 1);
          v659 -= 8;
          *(_QWORD *)v659 = 0;
          *((_QWORD *)v668 - 1) = v679;
          v668 -= 8;
        }
        while (v659 != v661);
      }
      v659 = (char *)__p[0];
      v680 = (char *)__p[1];
      __p[0] = v668;
      __p[1] = v660;
      *(_QWORD *)&v795 = v669;
      while (v680 != v659)
      {
        v682 = *((_QWORD *)v680 - 1);
        v680 -= 8;
        v681 = v682;
        *(_QWORD *)v680 = 0;
        if (v682)
          (*(void (**)(uint64_t))(*(_QWORD *)v681 + 8))(v681);
      }
    }
    if (v659)
      operator delete(v659);
  }
  else
  {
    *(_QWORD *)__p[1] = v648;
    v660 = v659 + 8;
  }
  __p[1] = v660;
  v683 = operator new(0x68uLL);
  v684 = v791;
  v685 = *((_BYTE *)this + 1096);
  mlir::PatternBenefit::PatternBenefit(v806, 1);
  mlir::Pattern::Pattern((uint64_t)(v683 + 8), (uint64_t)"mps.conv_3d_data_gradient", 25, *(__int16 *)v806, v684, 0, 0);
  *(_QWORD *)v683 = &off_1E0DFB190;
  v683[96] = v685;
  if (!*((_QWORD *)v683 + 9))
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeCon"
                      "vToMatMul<mlir::mps::Conv3DDataGradientOp>]";
    *(_QWORD *)&v806[8] = 141;
    v686 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v686)
      v687 = v686;
    else
      v687 = *(_QWORD *)&v806[8];
    v688 = *(_QWORD *)v806 + v687;
    v689 = *(_QWORD *)&v806[8] - v687;
    if (*(_QWORD *)&v806[8] - v687 >= 0x12)
      v690 = 18;
    else
      v690 = *(_QWORD *)&v806[8] - v687;
    v691 = v688 + v690;
    v692 = v689 - v690;
    if (v692 >= v692 - 1)
      --v692;
    *((_QWORD *)v683 + 8) = v691;
    *((_QWORD *)v683 + 9) = v692;
  }
  v693 = *((unsigned int *)v683 + 22);
  if (v693 > *((_DWORD *)v683 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v683 + 80), v683 + 96, v693, 16);
    LODWORD(v693) = *((_DWORD *)v683 + 22);
  }
  *((_DWORD *)v683 + 22) = v693;
  v694 = (char *)__p[1];
  if (__p[1] >= (void *)v795)
  {
    v696 = (char *)__p[0];
    v697 = (char *)__p[1] - (char *)__p[0];
    v698 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v699 = v698 + 1;
    if ((unint64_t)(v698 + 1) >> 61)
      goto LABEL_900;
    v700 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v699)
      v699 = v700 >> 2;
    if ((unint64_t)v700 >= 0x7FFFFFFFFFFFFFF8)
      v701 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v701 = v699;
    if (v701)
    {
      if (v701 >> 61)
        goto LABEL_901;
      v702 = (char *)operator new(8 * v701);
    }
    else
    {
      v702 = 0;
    }
    v703 = &v702[8 * v698];
    v704 = &v702[8 * v701];
    *(_QWORD *)v703 = v683;
    v695 = v703 + 8;
    if (v694 == v696)
    {
      __p[0] = &v702[8 * v698];
      __p[1] = v703 + 8;
      *(_QWORD *)&v795 = v704;
    }
    else
    {
      v705 = v694 - v696 - 8;
      if (v705 < 0x78
        || &v694[-(v705 & 0xFFFFFFFFFFFFFFF8) - 8] < v703 && &v702[v697 - (v705 & 0xFFFFFFFFFFFFFFF8) - 8] < v694)
      {
        goto LABEL_924;
      }
      v706 = (v705 >> 3) + 1;
      v707 = 8 * (v706 & 0x3FFFFFFFFFFFFFFCLL);
      v708 = &v694[-v707];
      v703 -= v707;
      v709 = &v702[8 * v698 - 16];
      v710 = v694 - 16;
      v711 = v706 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v713 = *((_OWORD *)v710 - 1);
        v712 = *(_OWORD *)v710;
        *((_OWORD *)v710 - 1) = 0uLL;
        *(_OWORD *)v710 = 0uLL;
        *((_OWORD *)v709 - 1) = v713;
        *(_OWORD *)v709 = v712;
        v709 -= 32;
        v710 -= 32;
        v711 -= 4;
      }
      while (v711);
      v694 = v708;
      if (v706 != (v706 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_924:
        do
        {
          v714 = *((_QWORD *)v694 - 1);
          v694 -= 8;
          *(_QWORD *)v694 = 0;
          *((_QWORD *)v703 - 1) = v714;
          v703 -= 8;
        }
        while (v694 != v696);
      }
      v694 = (char *)__p[0];
      v715 = (char *)__p[1];
      __p[0] = v703;
      __p[1] = v695;
      *(_QWORD *)&v795 = v704;
      while (v715 != v694)
      {
        v717 = *((_QWORD *)v715 - 1);
        v715 -= 8;
        v716 = v717;
        *(_QWORD *)v715 = 0;
        if (v717)
          (*(void (**)(uint64_t))(*(_QWORD *)v716 + 8))(v716);
      }
    }
    if (v694)
      operator delete(v694);
  }
  else
  {
    *(_QWORD *)__p[1] = v683;
    v695 = v694 + 8;
  }
  __p[1] = v695;
  v718 = operator new(0x68uLL);
  v719 = v791;
  v720 = *((_BYTE *)this + 1096);
  mlir::PatternBenefit::PatternBenefit(v806, 1);
  mlir::Pattern::Pattern((uint64_t)(v718 + 8), (uint64_t)"mps.bias_add", 12, *(__int16 *)v806, v719, 0, 0);
  *(_QWORD *)v718 = &off_1E0DFB2F0;
  v718[96] = v720;
  if (!*((_QWORD *)v718 + 9))
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeCon"
                      "vToMatMul<mlir::mps::BiasAddOp>]";
    *(_QWORD *)&v806[8] = 130;
    v721 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v721)
      v722 = v721;
    else
      v722 = *(_QWORD *)&v806[8];
    v723 = *(_QWORD *)v806 + v722;
    v724 = *(_QWORD *)&v806[8] - v722;
    if (*(_QWORD *)&v806[8] - v722 >= 0x12)
      v725 = 18;
    else
      v725 = *(_QWORD *)&v806[8] - v722;
    v726 = v723 + v725;
    v727 = v724 - v725;
    if (v727 >= v727 - 1)
      --v727;
    *((_QWORD *)v718 + 8) = v726;
    *((_QWORD *)v718 + 9) = v727;
  }
  v728 = *((unsigned int *)v718 + 22);
  if (v728 > *((_DWORD *)v718 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v718 + 80), v718 + 96, v728, 16);
    LODWORD(v728) = *((_DWORD *)v718 + 22);
  }
  *((_DWORD *)v718 + 22) = v728;
  v729 = (char *)__p[1];
  if (__p[1] >= (void *)v795)
  {
    v731 = (char *)__p[0];
    v732 = (char *)__p[1] - (char *)__p[0];
    v733 = ((char *)__p[1] - (char *)__p[0]) >> 3;
    v734 = v733 + 1;
    if ((unint64_t)(v733 + 1) >> 61)
      goto LABEL_900;
    v735 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v734)
      v734 = v735 >> 2;
    if ((unint64_t)v735 >= 0x7FFFFFFFFFFFFFF8)
      v736 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v736 = v734;
    if (v736)
    {
      if (v736 >> 61)
        goto LABEL_901;
      v737 = (char *)operator new(8 * v736);
    }
    else
    {
      v737 = 0;
    }
    v738 = &v737[8 * v733];
    v739 = &v737[8 * v736];
    *(_QWORD *)v738 = v718;
    v730 = v738 + 8;
    if (v729 == v731)
    {
      __p[0] = &v737[8 * v733];
      __p[1] = v738 + 8;
      *(_QWORD *)&v795 = v739;
    }
    else
    {
      v740 = v729 - v731 - 8;
      if (v740 < 0x78
        || &v729[-(v740 & 0xFFFFFFFFFFFFFFF8) - 8] < v738 && &v737[v732 - (v740 & 0xFFFFFFFFFFFFFFF8) - 8] < v729)
      {
        goto LABEL_925;
      }
      v741 = (v740 >> 3) + 1;
      v742 = 8 * (v741 & 0x3FFFFFFFFFFFFFFCLL);
      v743 = &v729[-v742];
      v738 -= v742;
      v744 = &v737[8 * v733 - 16];
      v745 = v729 - 16;
      v746 = v741 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v748 = *((_OWORD *)v745 - 1);
        v747 = *(_OWORD *)v745;
        *((_OWORD *)v745 - 1) = 0uLL;
        *(_OWORD *)v745 = 0uLL;
        *((_OWORD *)v744 - 1) = v748;
        *(_OWORD *)v744 = v747;
        v744 -= 32;
        v745 -= 32;
        v746 -= 4;
      }
      while (v746);
      v729 = v743;
      if (v741 != (v741 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_925:
        do
        {
          v749 = *((_QWORD *)v729 - 1);
          v729 -= 8;
          *(_QWORD *)v729 = 0;
          *((_QWORD *)v738 - 1) = v749;
          v738 -= 8;
        }
        while (v729 != v731);
      }
      v729 = (char *)__p[0];
      v750 = (char *)__p[1];
      __p[0] = v738;
      __p[1] = v730;
      *(_QWORD *)&v795 = v739;
      while (v750 != v729)
      {
        v752 = *((_QWORD *)v750 - 1);
        v750 -= 8;
        v751 = v752;
        *(_QWORD *)v750 = 0;
        if (v752)
          (*(void (**)(uint64_t))(*(_QWORD *)v751 + 8))(v751);
      }
    }
    if (v729)
      operator delete(v729);
  }
  else
  {
    *(_QWORD *)__p[1] = v718;
    v730 = v729 + 8;
  }
  __p[1] = v730;
  v753 = operator new(0x68uLL);
  v754 = v791;
  v755 = *((_BYTE *)this + 1096);
  mlir::PatternBenefit::PatternBenefit(v806, 1);
  mlir::Pattern::Pattern((uint64_t)(v753 + 8), (uint64_t)"mps.add", 7, *(__int16 *)v806, v754, 0, 0);
  *(_QWORD *)v753 = &off_1E0DFB1E8;
  v753[96] = v755;
  if (!*((_QWORD *)v753 + 9))
  {
    *(_QWORD *)v806 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeCon"
                      "vToMatMul<mlir::mps::AddOp>]";
    *(_QWORD *)&v806[8] = 126;
    v756 = llvm::StringRef::find((uint64_t *)v806, "DesiredTypeName = ", 0x12uLL, 0);
    if (*(_QWORD *)&v806[8] >= v756)
      v757 = v756;
    else
      v757 = *(_QWORD *)&v806[8];
    v758 = *(_QWORD *)v806 + v757;
    v759 = *(_QWORD *)&v806[8] - v757;
    if (*(_QWORD *)&v806[8] - v757 >= 0x12)
      v760 = 18;
    else
      v760 = *(_QWORD *)&v806[8] - v757;
    v761 = v758 + v760;
    v762 = v759 - v760;
    if (v762 >= v762 - 1)
      --v762;
    *((_QWORD *)v753 + 8) = v761;
    *((_QWORD *)v753 + 9) = v762;
  }
  v763 = *((unsigned int *)v753 + 22);
  if (v763 > *((_DWORD *)v753 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v753 + 80), v753 + 96, v763, 16);
    LODWORD(v763) = *((_DWORD *)v753 + 22);
  }
  *((_DWORD *)v753 + 22) = v763;
  v764 = (char *)__p[1];
  if (__p[1] < (void *)v795)
  {
    *(_QWORD *)__p[1] = v753;
    v765 = v764 + 8;
    goto LABEL_897;
  }
  v766 = (char *)__p[0];
  v767 = (char *)__p[1] - (char *)__p[0];
  v768 = ((char *)__p[1] - (char *)__p[0]) >> 3;
  v769 = v768 + 1;
  if (!((unint64_t)(v768 + 1) >> 61))
  {
    v770 = v795 - (unint64_t)__p[0];
    if ((uint64_t)(v795 - (unint64_t)__p[0]) >> 2 > v769)
      v769 = v770 >> 2;
    if ((unint64_t)v770 >= 0x7FFFFFFFFFFFFFF8)
      v771 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v771 = v769;
    if (!v771)
    {
      v772 = 0;
      goto LABEL_882;
    }
    if (!(v771 >> 61))
    {
      v772 = (char *)operator new(8 * v771);
LABEL_882:
      v773 = &v772[8 * v768];
      v774 = &v772[8 * v771];
      *(_QWORD *)v773 = v753;
      v765 = v773 + 8;
      if (v764 == v766)
      {
        __p[0] = &v772[8 * v768];
        __p[1] = v773 + 8;
        *(_QWORD *)&v795 = v774;
      }
      else
      {
        v775 = v764 - v766 - 8;
        if (v775 < 0x78
          || &v764[-(v775 & 0xFFFFFFFFFFFFFFF8) - 8] < v773 && &v772[v767 - (v775 & 0xFFFFFFFFFFFFFFF8) - 8] < v764)
        {
          goto LABEL_926;
        }
        v776 = (v775 >> 3) + 1;
        v777 = 8 * (v776 & 0x3FFFFFFFFFFFFFFCLL);
        v778 = &v764[-v777];
        v773 -= v777;
        v779 = &v772[8 * v768 - 16];
        v780 = v764 - 16;
        v781 = v776 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v783 = *((_OWORD *)v780 - 1);
          v782 = *(_OWORD *)v780;
          *((_OWORD *)v780 - 1) = 0uLL;
          *(_OWORD *)v780 = 0uLL;
          *((_OWORD *)v779 - 1) = v783;
          *(_OWORD *)v779 = v782;
          v779 -= 32;
          v780 -= 32;
          v781 -= 4;
        }
        while (v781);
        v764 = v778;
        if (v776 != (v776 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_926:
          do
          {
            v784 = *((_QWORD *)v764 - 1);
            v764 -= 8;
            *(_QWORD *)v764 = 0;
            *((_QWORD *)v773 - 1) = v784;
            v773 -= 8;
          }
          while (v764 != v766);
        }
        v764 = (char *)__p[0];
        v785 = (char *)__p[1];
        __p[0] = v773;
        __p[1] = v765;
        *(_QWORD *)&v795 = v774;
        while (v785 != v764)
        {
          v787 = *((_QWORD *)v785 - 1);
          v785 -= 8;
          v786 = v787;
          *(_QWORD *)v785 = 0;
          if (v787)
            (*(void (**)(uint64_t))(*(_QWORD *)v786 + 8))(v786);
        }
      }
      if (v764)
        operator delete(v764);
LABEL_897:
      __p[1] = v765;
      mlir::FrozenRewritePatternSet::FrozenRewritePatternSet(v790, &v793, 0, 0, 0, 0);
      v788 = *((unsigned int *)a2 + 11);
      if ((v788 & 0x7FFFFF) != 0)
      {
        v789 = (mlir::Region **)((((unint64_t)a2
                                 + 16 * ((v788 >> 23) & 1)
                                 + ((v788 >> 21) & 0x7F8)
                                 + 71) & 0xFFFFFFFFFFFFFFF8)
                               + 32 * *((unsigned int *)a2 + 10));
        v792 = 0;
        *(_WORD *)v806 = 256;
        *(_DWORD *)&v806[2] = 0;
        *(_WORD *)&v806[6] = 0;
        *(_OWORD *)&v806[8] = xmmword_181233220;
        v807 = 0uLL;
        *(_QWORD *)&v806[24] = 0;
        mlir::applyPatternsAndFoldGreedily(v789, (const mlir::FrozenRewritePatternSet *)v790, (__int128 *)v806, &v792);
      }
      mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)v790);
      mlir::PDLPatternModule::~PDLPatternModule((mlir::PDLPatternModule *)((char *)&v795 + 8));
    }
LABEL_901:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_900:
  abort();
}

_QWORD *_ZN4mlir17RewritePatternSet6insertIJNS_3mps12_GLOBAL__N_121CanonicalizeReductionINS2_17ReductionArgMaxOpEEENS4_INS2_17ReductionArgMinOpEEENS4_INS2_14ReductionMaxOpEEENS4_INS2_14ReductionMinOpEEENS4_INS2_15ReductionProdOpEEENS4_INS2_14ReductionSumOpEEENS3_25CanonicalizeReductionAxesIS5_EENSH_IS7_EENSH_IS9_EENSH_ISB_EENSH_ISD_EENSH_ISF_EENS3_27CanonicalizeMatMulTransposeENS3_20CanonicalizeMatMul1DENS3_27CanonicalizeConvToDepthwiseINS2_8Conv2DOpEEENSQ_INS2_20Conv2DDataGradientOpEEENS3_33CanonicalizeSparseMatMulTransposeENS3_35CanonicalizeQuantizedMatmulTranposeENS3_7FuseRMSINS2_10MultiplyOpEEENSX_INS2_8DivideOpEEENS3_16CanonicalizeRoPEENS3_24CanonicalizeReadVariableENS3_32CanonicalizeStridedSliceToGatherEERPNS_11MLIRContextEJEvEERS0_OT0_DpOT1_(_QWORD *a1, uint64_t *a2)
{
  _QWORD *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  _QWORD *v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  const char *v42;
  unint64_t v43;
  uint64_t v44;
  const char *v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  char *v49;
  _QWORD *v50;
  char *v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  char *v56;
  char *v57;
  char *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  _QWORD *v72;
  uint64_t v73;
  unint64_t v74;
  unint64_t v75;
  const char *v76;
  unint64_t v77;
  uint64_t v78;
  const char *v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  char *v83;
  _QWORD *v84;
  char *v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  char *v90;
  char *v91;
  char *v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  _QWORD *v106;
  uint64_t v107;
  unint64_t v108;
  unint64_t v109;
  const char *v110;
  unint64_t v111;
  uint64_t v112;
  const char *v113;
  unint64_t v114;
  unint64_t v115;
  unint64_t v116;
  char *v117;
  _QWORD *v118;
  char *v119;
  uint64_t v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  char *v124;
  char *v125;
  char *v126;
  unint64_t v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  char *v131;
  char *v132;
  uint64_t v133;
  __int128 v134;
  __int128 v135;
  uint64_t v136;
  char *v137;
  uint64_t v138;
  uint64_t v139;
  _QWORD *v140;
  uint64_t v141;
  unint64_t v142;
  unint64_t v143;
  const char *v144;
  unint64_t v145;
  uint64_t v146;
  const char *v147;
  unint64_t v148;
  unint64_t v149;
  unint64_t v150;
  char *v151;
  _QWORD *v152;
  char *v153;
  uint64_t v154;
  unint64_t v155;
  uint64_t v156;
  unint64_t v157;
  char *v158;
  char *v159;
  char *v160;
  unint64_t v161;
  uint64_t v162;
  uint64_t v163;
  char *v164;
  char *v165;
  char *v166;
  uint64_t v167;
  __int128 v168;
  __int128 v169;
  uint64_t v170;
  char *v171;
  uint64_t v172;
  uint64_t v173;
  _QWORD *v174;
  uint64_t v175;
  unint64_t v176;
  unint64_t v177;
  const char *v178;
  unint64_t v179;
  uint64_t v180;
  const char *v181;
  unint64_t v182;
  unint64_t v183;
  unint64_t v184;
  char *v185;
  _QWORD *v186;
  char *v187;
  uint64_t v188;
  unint64_t v189;
  uint64_t v190;
  unint64_t v191;
  char *v192;
  char *v193;
  char *v194;
  unint64_t v195;
  uint64_t v196;
  uint64_t v197;
  char *v198;
  char *v199;
  char *v200;
  uint64_t v201;
  __int128 v202;
  __int128 v203;
  uint64_t v204;
  char *v205;
  uint64_t v206;
  uint64_t v207;
  _QWORD *v208;
  uint64_t v209;
  unint64_t v210;
  unint64_t v211;
  const char *v212;
  unint64_t v213;
  uint64_t v214;
  const char *v215;
  unint64_t v216;
  unint64_t v217;
  unint64_t v218;
  char *v219;
  _QWORD *v220;
  char *v221;
  uint64_t v222;
  unint64_t v223;
  uint64_t v224;
  unint64_t v225;
  char *v226;
  char *v227;
  char *v228;
  unint64_t v229;
  uint64_t v230;
  uint64_t v231;
  char *v232;
  char *v233;
  char *v234;
  uint64_t v235;
  __int128 v236;
  __int128 v237;
  uint64_t v238;
  char *v239;
  uint64_t v240;
  uint64_t v241;
  _QWORD *v242;
  uint64_t v243;
  unint64_t v244;
  unint64_t v245;
  const char *v246;
  unint64_t v247;
  uint64_t v248;
  const char *v249;
  unint64_t v250;
  unint64_t v251;
  unint64_t v252;
  char *v253;
  _QWORD *v254;
  char *v255;
  uint64_t v256;
  unint64_t v257;
  uint64_t v258;
  unint64_t v259;
  char *v260;
  char *v261;
  char *v262;
  unint64_t v263;
  uint64_t v264;
  uint64_t v265;
  char *v266;
  char *v267;
  char *v268;
  uint64_t v269;
  __int128 v270;
  __int128 v271;
  uint64_t v272;
  char *v273;
  uint64_t v274;
  uint64_t v275;
  _QWORD *v276;
  uint64_t v277;
  unint64_t v278;
  unint64_t v279;
  const char *v280;
  unint64_t v281;
  uint64_t v282;
  const char *v283;
  unint64_t v284;
  unint64_t v285;
  unint64_t v286;
  char *v287;
  _QWORD *v288;
  char *v289;
  uint64_t v290;
  unint64_t v291;
  uint64_t v292;
  unint64_t v293;
  char *v294;
  char *v295;
  char *v296;
  unint64_t v297;
  uint64_t v298;
  uint64_t v299;
  char *v300;
  char *v301;
  char *v302;
  uint64_t v303;
  __int128 v304;
  __int128 v305;
  uint64_t v306;
  char *v307;
  uint64_t v308;
  uint64_t v309;
  _QWORD *v310;
  uint64_t v311;
  unint64_t v312;
  unint64_t v313;
  const char *v314;
  unint64_t v315;
  uint64_t v316;
  const char *v317;
  unint64_t v318;
  unint64_t v319;
  unint64_t v320;
  char *v321;
  _QWORD *v322;
  char *v323;
  uint64_t v324;
  unint64_t v325;
  uint64_t v326;
  unint64_t v327;
  char *v328;
  char *v329;
  char *v330;
  unint64_t v331;
  uint64_t v332;
  uint64_t v333;
  char *v334;
  char *v335;
  char *v336;
  uint64_t v337;
  __int128 v338;
  __int128 v339;
  uint64_t v340;
  char *v341;
  uint64_t v342;
  uint64_t v343;
  _QWORD *v344;
  uint64_t v345;
  unint64_t v346;
  unint64_t v347;
  const char *v348;
  unint64_t v349;
  uint64_t v350;
  const char *v351;
  unint64_t v352;
  unint64_t v353;
  unint64_t v354;
  char *v355;
  _QWORD *v356;
  char *v357;
  uint64_t v358;
  unint64_t v359;
  uint64_t v360;
  unint64_t v361;
  char *v362;
  char *v363;
  char *v364;
  unint64_t v365;
  uint64_t v366;
  uint64_t v367;
  char *v368;
  char *v369;
  char *v370;
  uint64_t v371;
  __int128 v372;
  __int128 v373;
  uint64_t v374;
  char *v375;
  uint64_t v376;
  uint64_t v377;
  _QWORD *v378;
  uint64_t v379;
  unint64_t v380;
  unint64_t v381;
  const char *v382;
  unint64_t v383;
  uint64_t v384;
  const char *v385;
  unint64_t v386;
  unint64_t v387;
  unint64_t v388;
  char *v389;
  _QWORD *v390;
  char *v391;
  uint64_t v392;
  unint64_t v393;
  uint64_t v394;
  unint64_t v395;
  char *v396;
  char *v397;
  char *v398;
  unint64_t v399;
  uint64_t v400;
  uint64_t v401;
  char *v402;
  char *v403;
  char *v404;
  uint64_t v405;
  __int128 v406;
  __int128 v407;
  uint64_t v408;
  char *v409;
  uint64_t v410;
  uint64_t v411;
  _QWORD *v412;
  uint64_t v413;
  unint64_t v414;
  unint64_t v415;
  const char *v416;
  unint64_t v417;
  uint64_t v418;
  const char *v419;
  unint64_t v420;
  unint64_t v421;
  unint64_t v422;
  char *v423;
  _QWORD *v424;
  char *v425;
  uint64_t v426;
  unint64_t v427;
  uint64_t v428;
  unint64_t v429;
  char *v430;
  char *v431;
  char *v432;
  unint64_t v433;
  uint64_t v434;
  uint64_t v435;
  char *v436;
  char *v437;
  char *v438;
  uint64_t v439;
  __int128 v440;
  __int128 v441;
  uint64_t v442;
  char *v443;
  uint64_t v444;
  uint64_t v445;
  _QWORD *v446;
  uint64_t v447;
  unint64_t v448;
  unint64_t v449;
  const char *v450;
  unint64_t v451;
  uint64_t v452;
  const char *v453;
  unint64_t v454;
  unint64_t v455;
  unint64_t v456;
  char *v457;
  _QWORD *v458;
  char *v459;
  uint64_t v460;
  unint64_t v461;
  uint64_t v462;
  unint64_t v463;
  char *v464;
  char *v465;
  char *v466;
  unint64_t v467;
  uint64_t v468;
  uint64_t v469;
  char *v470;
  char *v471;
  char *v472;
  uint64_t v473;
  __int128 v474;
  __int128 v475;
  uint64_t v476;
  char *v477;
  uint64_t v478;
  uint64_t v479;
  _QWORD *v480;
  uint64_t v481;
  unint64_t v482;
  unint64_t v483;
  const char *v484;
  unint64_t v485;
  uint64_t v486;
  const char *v487;
  unint64_t v488;
  unint64_t v489;
  unint64_t v490;
  char *v491;
  _QWORD *v492;
  char *v493;
  uint64_t v494;
  unint64_t v495;
  uint64_t v496;
  unint64_t v497;
  char *v498;
  char *v499;
  char *v500;
  unint64_t v501;
  uint64_t v502;
  uint64_t v503;
  char *v504;
  char *v505;
  char *v506;
  uint64_t v507;
  __int128 v508;
  __int128 v509;
  uint64_t v510;
  char *v511;
  uint64_t v512;
  uint64_t v513;
  _QWORD *v514;
  uint64_t v515;
  unint64_t v516;
  unint64_t v517;
  const char *v518;
  unint64_t v519;
  uint64_t v520;
  const char *v521;
  unint64_t v522;
  unint64_t v523;
  unint64_t v524;
  char *v525;
  _QWORD *v526;
  char *v527;
  uint64_t v528;
  unint64_t v529;
  uint64_t v530;
  unint64_t v531;
  char *v532;
  char *v533;
  char *v534;
  unint64_t v535;
  uint64_t v536;
  uint64_t v537;
  char *v538;
  char *v539;
  char *v540;
  uint64_t v541;
  __int128 v542;
  __int128 v543;
  uint64_t v544;
  char *v545;
  uint64_t v546;
  uint64_t v547;
  _QWORD *v548;
  uint64_t v549;
  unint64_t v550;
  unint64_t v551;
  const char *v552;
  unint64_t v553;
  uint64_t v554;
  const char *v555;
  unint64_t v556;
  unint64_t v557;
  unint64_t v558;
  char *v559;
  _QWORD *v560;
  char *v561;
  uint64_t v562;
  unint64_t v563;
  uint64_t v564;
  unint64_t v565;
  char *v566;
  char *v567;
  char *v568;
  unint64_t v569;
  uint64_t v570;
  uint64_t v571;
  char *v572;
  char *v573;
  char *v574;
  uint64_t v575;
  __int128 v576;
  __int128 v577;
  uint64_t v578;
  char *v579;
  uint64_t v580;
  uint64_t v581;
  _QWORD *v582;
  uint64_t v583;
  unint64_t v584;
  unint64_t v585;
  const char *v586;
  unint64_t v587;
  uint64_t v588;
  const char *v589;
  unint64_t v590;
  unint64_t v591;
  unint64_t v592;
  char *v593;
  _QWORD *v594;
  char *v595;
  uint64_t v596;
  unint64_t v597;
  uint64_t v598;
  unint64_t v599;
  char *v600;
  char *v601;
  char *v602;
  unint64_t v603;
  uint64_t v604;
  uint64_t v605;
  char *v606;
  char *v607;
  char *v608;
  uint64_t v609;
  __int128 v610;
  __int128 v611;
  uint64_t v612;
  char *v613;
  uint64_t v614;
  uint64_t v615;
  _QWORD *v616;
  uint64_t v617;
  unint64_t v618;
  unint64_t v619;
  const char *v620;
  unint64_t v621;
  uint64_t v622;
  const char *v623;
  unint64_t v624;
  unint64_t v625;
  unint64_t v626;
  char *v627;
  _QWORD *v628;
  char *v629;
  uint64_t v630;
  unint64_t v631;
  uint64_t v632;
  unint64_t v633;
  char *v634;
  char *v635;
  char *v636;
  unint64_t v637;
  uint64_t v638;
  uint64_t v639;
  char *v640;
  char *v641;
  char *v642;
  uint64_t v643;
  __int128 v644;
  __int128 v645;
  uint64_t v646;
  char *v647;
  uint64_t v648;
  uint64_t v649;
  _QWORD *v650;
  uint64_t v651;
  unint64_t v652;
  unint64_t v653;
  const char *v654;
  unint64_t v655;
  uint64_t v656;
  const char *v657;
  unint64_t v658;
  unint64_t v659;
  unint64_t v660;
  char *v661;
  _QWORD *v662;
  char *v663;
  uint64_t v664;
  unint64_t v665;
  uint64_t v666;
  unint64_t v667;
  char *v668;
  char *v669;
  char *v670;
  unint64_t v671;
  uint64_t v672;
  uint64_t v673;
  char *v674;
  char *v675;
  char *v676;
  uint64_t v677;
  __int128 v678;
  __int128 v679;
  uint64_t v680;
  char *v681;
  uint64_t v682;
  uint64_t v683;
  _QWORD *v684;
  uint64_t v685;
  unint64_t v686;
  unint64_t v687;
  const char *v688;
  unint64_t v689;
  uint64_t v690;
  const char *v691;
  unint64_t v692;
  unint64_t v693;
  unint64_t v694;
  char *v695;
  _QWORD *v696;
  char *v697;
  uint64_t v698;
  unint64_t v699;
  uint64_t v700;
  unint64_t v701;
  char *v702;
  char *v703;
  char *v704;
  unint64_t v705;
  uint64_t v706;
  uint64_t v707;
  char *v708;
  char *v709;
  char *v710;
  uint64_t v711;
  __int128 v712;
  __int128 v713;
  uint64_t v714;
  char *v715;
  uint64_t v716;
  uint64_t v717;
  _QWORD *v718;
  uint64_t v719;
  unint64_t v720;
  unint64_t v721;
  const char *v722;
  unint64_t v723;
  uint64_t v724;
  const char *v725;
  unint64_t v726;
  unint64_t v727;
  unint64_t v728;
  char *v729;
  _QWORD *v730;
  char *v731;
  uint64_t v732;
  unint64_t v733;
  uint64_t v734;
  unint64_t v735;
  char *v736;
  char *v737;
  char *v738;
  unint64_t v739;
  uint64_t v740;
  uint64_t v741;
  char *v742;
  char *v743;
  char *v744;
  uint64_t v745;
  __int128 v746;
  __int128 v747;
  uint64_t v748;
  char *v749;
  uint64_t v750;
  uint64_t v751;
  _QWORD *v752;
  uint64_t v753;
  unint64_t v754;
  unint64_t v755;
  const char *v756;
  unint64_t v757;
  uint64_t v758;
  const char *v759;
  unint64_t v760;
  unint64_t v761;
  unint64_t v762;
  char *v763;
  _QWORD *v764;
  char *v765;
  uint64_t v766;
  unint64_t v767;
  uint64_t v768;
  unint64_t v769;
  char *v770;
  char *v771;
  char *v772;
  unint64_t v773;
  uint64_t v774;
  uint64_t v775;
  char *v776;
  char *v777;
  char *v778;
  uint64_t v779;
  __int128 v780;
  __int128 v781;
  uint64_t v782;
  char *v783;
  uint64_t v784;
  uint64_t v785;
  const char *v787;
  unint64_t v788;

  v4 = operator new(0x60uLL);
  v5 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"mps.reduction_argmax", 20, (__int16)v787, v5, 0, 0);
  *v4 = &off_1E0E4A048;
  if (!v4[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReduction<mlir"
           "::mps::ReductionArgMaxOp>]";
    v788 = 135;
    v6 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v6)
      v7 = v6;
    else
      v7 = v788;
    v8 = &v787[v7];
    v9 = v788 - v7;
    if (v788 - v7 >= 0x12)
      v10 = 18;
    else
      v10 = v788 - v7;
    v11 = &v8[v10];
    v12 = v9 - v10;
    if (v12 >= v12 - 1)
      --v12;
    v4[8] = v11;
    v4[9] = v12;
  }
  v13 = *((unsigned int *)v4 + 22);
  if (v13 > *((_DWORD *)v4 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v4 + 10), v4 + 12, v13, 16);
    LODWORD(v13) = *((_DWORD *)v4 + 22);
  }
  *((_DWORD *)v4 + 22) = v13;
  v15 = (char *)a1[2];
  v14 = a1[3];
  if ((unint64_t)v15 >= v14)
  {
    v17 = (char *)a1[1];
    v18 = (v15 - v17) >> 3;
    v19 = v18 + 1;
    if ((unint64_t)(v18 + 1) >> 61)
      goto LABEL_899;
    v20 = v14 - (_QWORD)v17;
    if (v20 >> 2 > v19)
      v19 = v20 >> 2;
    if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8)
      v21 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v21 = v19;
    if (v21)
    {
      if (v21 >> 61)
        goto LABEL_900;
      v22 = (char *)operator new(8 * v21);
    }
    else
    {
      v22 = 0;
    }
    v23 = &v22[8 * v18];
    v24 = &v22[8 * v21];
    *(_QWORD *)v23 = v4;
    v16 = v23 + 8;
    if (v15 == v17)
    {
      a1[1] = v23;
      a1[2] = v16;
      a1[3] = v24;
    }
    else
    {
      v25 = v15 - v17 - 8;
      if (v25 < 0x78
        || &v15[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v23 && &v22[v15 - v17 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v15)
      {
        goto LABEL_903;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v15[-v27];
      v23 -= v27;
      v29 = &v22[8 * v18 - 16];
      v30 = v15 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v15 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_903:
        do
        {
          v34 = *((_QWORD *)v15 - 1);
          v15 -= 8;
          *(_QWORD *)v15 = 0;
          *((_QWORD *)v23 - 1) = v34;
          v23 -= 8;
        }
        while (v15 != v17);
      }
      v15 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v23;
      a1[2] = v16;
      a1[3] = v24;
      while (v35 != v15)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
    }
    if (v15)
      operator delete(v15);
  }
  else
  {
    *(_QWORD *)v15 = v4;
    v16 = v15 + 8;
  }
  a1[2] = v16;
  v38 = operator new(0x60uLL);
  v39 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v38 + 1), (uint64_t)"mps.reduction_argmin", 20, (__int16)v787, v39, 0, 0);
  *v38 = &off_1E0E4A0A0;
  if (!v38[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReduction<mlir"
           "::mps::ReductionArgMinOp>]";
    v788 = 135;
    v40 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v40)
      v41 = v40;
    else
      v41 = v788;
    v42 = &v787[v41];
    v43 = v788 - v41;
    if (v788 - v41 >= 0x12)
      v44 = 18;
    else
      v44 = v788 - v41;
    v45 = &v42[v44];
    v46 = v43 - v44;
    if (v46 >= v46 - 1)
      --v46;
    v38[8] = v45;
    v38[9] = v46;
  }
  v47 = *((unsigned int *)v38 + 22);
  if (v47 > *((_DWORD *)v38 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v38 + 10), v38 + 12, v47, 16);
    LODWORD(v47) = *((_DWORD *)v38 + 22);
  }
  *((_DWORD *)v38 + 22) = v47;
  v49 = (char *)a1[2];
  v48 = a1[3];
  if ((unint64_t)v49 >= v48)
  {
    v51 = (char *)a1[1];
    v52 = (v49 - v51) >> 3;
    v53 = v52 + 1;
    if ((unint64_t)(v52 + 1) >> 61)
      goto LABEL_899;
    v54 = v48 - (_QWORD)v51;
    if (v54 >> 2 > v53)
      v53 = v54 >> 2;
    if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8)
      v55 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v55 = v53;
    if (v55)
    {
      if (v55 >> 61)
        goto LABEL_900;
      v56 = (char *)operator new(8 * v55);
    }
    else
    {
      v56 = 0;
    }
    v57 = &v56[8 * v52];
    v58 = &v56[8 * v55];
    *(_QWORD *)v57 = v38;
    v50 = v57 + 8;
    if (v49 == v51)
    {
      a1[1] = v57;
      a1[2] = v50;
      a1[3] = v58;
    }
    else
    {
      v59 = v49 - v51 - 8;
      if (v59 < 0x78
        || &v49[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v57 && &v56[v49 - v51 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v49)
      {
        goto LABEL_904;
      }
      v60 = (v59 >> 3) + 1;
      v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      v62 = &v49[-v61];
      v57 -= v61;
      v63 = &v56[8 * v52 - 16];
      v64 = v49 - 16;
      v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v67 = *((_OWORD *)v64 - 1);
        v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      v49 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_904:
        do
        {
          v68 = *((_QWORD *)v49 - 1);
          v49 -= 8;
          *(_QWORD *)v49 = 0;
          *((_QWORD *)v57 - 1) = v68;
          v57 -= 8;
        }
        while (v49 != v51);
      }
      v49 = (char *)a1[1];
      v69 = (char *)a1[2];
      a1[1] = v57;
      a1[2] = v50;
      a1[3] = v58;
      while (v69 != v49)
      {
        v71 = *((_QWORD *)v69 - 1);
        v69 -= 8;
        v70 = v71;
        *(_QWORD *)v69 = 0;
        if (v71)
          (*(void (**)(uint64_t))(*(_QWORD *)v70 + 8))(v70);
      }
    }
    if (v49)
      operator delete(v49);
  }
  else
  {
    *(_QWORD *)v49 = v38;
    v50 = v49 + 8;
  }
  a1[2] = v50;
  v72 = operator new(0x60uLL);
  v73 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v72 + 1), (uint64_t)"mps.reduction_max", 17, (__int16)v787, v73, 0, 0);
  *v72 = &off_1E0E49EE8;
  if (!v72[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReduction<mlir"
           "::mps::ReductionMaxOp>]";
    v788 = 132;
    v74 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v74)
      v75 = v74;
    else
      v75 = v788;
    v76 = &v787[v75];
    v77 = v788 - v75;
    if (v788 - v75 >= 0x12)
      v78 = 18;
    else
      v78 = v788 - v75;
    v79 = &v76[v78];
    v80 = v77 - v78;
    if (v80 >= v80 - 1)
      --v80;
    v72[8] = v79;
    v72[9] = v80;
  }
  v81 = *((unsigned int *)v72 + 22);
  if (v81 > *((_DWORD *)v72 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v72 + 10), v72 + 12, v81, 16);
    LODWORD(v81) = *((_DWORD *)v72 + 22);
  }
  *((_DWORD *)v72 + 22) = v81;
  v83 = (char *)a1[2];
  v82 = a1[3];
  if ((unint64_t)v83 >= v82)
  {
    v85 = (char *)a1[1];
    v86 = (v83 - v85) >> 3;
    v87 = v86 + 1;
    if ((unint64_t)(v86 + 1) >> 61)
      goto LABEL_899;
    v88 = v82 - (_QWORD)v85;
    if (v88 >> 2 > v87)
      v87 = v88 >> 2;
    if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFF8)
      v89 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v89 = v87;
    if (v89)
    {
      if (v89 >> 61)
        goto LABEL_900;
      v90 = (char *)operator new(8 * v89);
    }
    else
    {
      v90 = 0;
    }
    v91 = &v90[8 * v86];
    v92 = &v90[8 * v89];
    *(_QWORD *)v91 = v72;
    v84 = v91 + 8;
    if (v83 == v85)
    {
      a1[1] = v91;
      a1[2] = v84;
      a1[3] = v92;
    }
    else
    {
      v93 = v83 - v85 - 8;
      if (v93 < 0x78
        || &v83[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v91 && &v90[v83 - v85 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v83)
      {
        goto LABEL_905;
      }
      v94 = (v93 >> 3) + 1;
      v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
      v96 = &v83[-v95];
      v91 -= v95;
      v97 = &v90[8 * v86 - 16];
      v98 = v83 - 16;
      v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v101 = *((_OWORD *)v98 - 1);
        v100 = *(_OWORD *)v98;
        *((_OWORD *)v98 - 1) = 0uLL;
        *(_OWORD *)v98 = 0uLL;
        *((_OWORD *)v97 - 1) = v101;
        *(_OWORD *)v97 = v100;
        v97 -= 32;
        v98 -= 32;
        v99 -= 4;
      }
      while (v99);
      v83 = v96;
      if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_905:
        do
        {
          v102 = *((_QWORD *)v83 - 1);
          v83 -= 8;
          *(_QWORD *)v83 = 0;
          *((_QWORD *)v91 - 1) = v102;
          v91 -= 8;
        }
        while (v83 != v85);
      }
      v83 = (char *)a1[1];
      v103 = (char *)a1[2];
      a1[1] = v91;
      a1[2] = v84;
      a1[3] = v92;
      while (v103 != v83)
      {
        v105 = *((_QWORD *)v103 - 1);
        v103 -= 8;
        v104 = v105;
        *(_QWORD *)v103 = 0;
        if (v105)
          (*(void (**)(uint64_t))(*(_QWORD *)v104 + 8))(v104);
      }
    }
    if (v83)
      operator delete(v83);
  }
  else
  {
    *(_QWORD *)v83 = v72;
    v84 = v83 + 8;
  }
  a1[2] = v84;
  v106 = operator new(0x60uLL);
  v107 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v106 + 1), (uint64_t)"mps.reduction_min", 17, (__int16)v787, v107, 0, 0);
  *v106 = &off_1E0E49F40;
  if (!v106[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReduction<mlir"
           "::mps::ReductionMinOp>]";
    v788 = 132;
    v108 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v108)
      v109 = v108;
    else
      v109 = v788;
    v110 = &v787[v109];
    v111 = v788 - v109;
    if (v788 - v109 >= 0x12)
      v112 = 18;
    else
      v112 = v788 - v109;
    v113 = &v110[v112];
    v114 = v111 - v112;
    if (v114 >= v114 - 1)
      --v114;
    v106[8] = v113;
    v106[9] = v114;
  }
  v115 = *((unsigned int *)v106 + 22);
  if (v115 > *((_DWORD *)v106 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v106 + 10), v106 + 12, v115, 16);
    LODWORD(v115) = *((_DWORD *)v106 + 22);
  }
  *((_DWORD *)v106 + 22) = v115;
  v117 = (char *)a1[2];
  v116 = a1[3];
  if ((unint64_t)v117 >= v116)
  {
    v119 = (char *)a1[1];
    v120 = (v117 - v119) >> 3;
    v121 = v120 + 1;
    if ((unint64_t)(v120 + 1) >> 61)
      goto LABEL_899;
    v122 = v116 - (_QWORD)v119;
    if (v122 >> 2 > v121)
      v121 = v122 >> 2;
    if ((unint64_t)v122 >= 0x7FFFFFFFFFFFFFF8)
      v123 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v123 = v121;
    if (v123)
    {
      if (v123 >> 61)
        goto LABEL_900;
      v124 = (char *)operator new(8 * v123);
    }
    else
    {
      v124 = 0;
    }
    v125 = &v124[8 * v120];
    v126 = &v124[8 * v123];
    *(_QWORD *)v125 = v106;
    v118 = v125 + 8;
    if (v117 == v119)
    {
      a1[1] = v125;
      a1[2] = v118;
      a1[3] = v126;
    }
    else
    {
      v127 = v117 - v119 - 8;
      if (v127 < 0x78
        || &v117[-(v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v125
        && &v124[v117 - v119 - (v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v117)
      {
        goto LABEL_906;
      }
      v128 = (v127 >> 3) + 1;
      v129 = 8 * (v128 & 0x3FFFFFFFFFFFFFFCLL);
      v130 = &v117[-v129];
      v125 -= v129;
      v131 = &v124[8 * v120 - 16];
      v132 = v117 - 16;
      v133 = v128 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v135 = *((_OWORD *)v132 - 1);
        v134 = *(_OWORD *)v132;
        *((_OWORD *)v132 - 1) = 0uLL;
        *(_OWORD *)v132 = 0uLL;
        *((_OWORD *)v131 - 1) = v135;
        *(_OWORD *)v131 = v134;
        v131 -= 32;
        v132 -= 32;
        v133 -= 4;
      }
      while (v133);
      v117 = v130;
      if (v128 != (v128 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_906:
        do
        {
          v136 = *((_QWORD *)v117 - 1);
          v117 -= 8;
          *(_QWORD *)v117 = 0;
          *((_QWORD *)v125 - 1) = v136;
          v125 -= 8;
        }
        while (v117 != v119);
      }
      v117 = (char *)a1[1];
      v137 = (char *)a1[2];
      a1[1] = v125;
      a1[2] = v118;
      a1[3] = v126;
      while (v137 != v117)
      {
        v139 = *((_QWORD *)v137 - 1);
        v137 -= 8;
        v138 = v139;
        *(_QWORD *)v137 = 0;
        if (v139)
          (*(void (**)(uint64_t))(*(_QWORD *)v138 + 8))(v138);
      }
    }
    if (v117)
      operator delete(v117);
  }
  else
  {
    *(_QWORD *)v117 = v106;
    v118 = v117 + 8;
  }
  a1[2] = v118;
  v140 = operator new(0x60uLL);
  v141 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v140 + 1), (uint64_t)"mps.reduction_prod", 18, (__int16)v787, v141, 0, 0);
  *v140 = &off_1E0E49FF0;
  if (!v140[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReduction<mlir"
           "::mps::ReductionProdOp>]";
    v788 = 133;
    v142 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v142)
      v143 = v142;
    else
      v143 = v788;
    v144 = &v787[v143];
    v145 = v788 - v143;
    if (v788 - v143 >= 0x12)
      v146 = 18;
    else
      v146 = v788 - v143;
    v147 = &v144[v146];
    v148 = v145 - v146;
    if (v148 >= v148 - 1)
      --v148;
    v140[8] = v147;
    v140[9] = v148;
  }
  v149 = *((unsigned int *)v140 + 22);
  if (v149 > *((_DWORD *)v140 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v140 + 10), v140 + 12, v149, 16);
    LODWORD(v149) = *((_DWORD *)v140 + 22);
  }
  *((_DWORD *)v140 + 22) = v149;
  v151 = (char *)a1[2];
  v150 = a1[3];
  if ((unint64_t)v151 >= v150)
  {
    v153 = (char *)a1[1];
    v154 = (v151 - v153) >> 3;
    v155 = v154 + 1;
    if ((unint64_t)(v154 + 1) >> 61)
      goto LABEL_899;
    v156 = v150 - (_QWORD)v153;
    if (v156 >> 2 > v155)
      v155 = v156 >> 2;
    if ((unint64_t)v156 >= 0x7FFFFFFFFFFFFFF8)
      v157 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v157 = v155;
    if (v157)
    {
      if (v157 >> 61)
        goto LABEL_900;
      v158 = (char *)operator new(8 * v157);
    }
    else
    {
      v158 = 0;
    }
    v159 = &v158[8 * v154];
    v160 = &v158[8 * v157];
    *(_QWORD *)v159 = v140;
    v152 = v159 + 8;
    if (v151 == v153)
    {
      a1[1] = v159;
      a1[2] = v152;
      a1[3] = v160;
    }
    else
    {
      v161 = v151 - v153 - 8;
      if (v161 < 0x78
        || &v151[-(v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v159
        && &v158[v151 - v153 - (v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v151)
      {
        goto LABEL_907;
      }
      v162 = (v161 >> 3) + 1;
      v163 = 8 * (v162 & 0x3FFFFFFFFFFFFFFCLL);
      v164 = &v151[-v163];
      v159 -= v163;
      v165 = &v158[8 * v154 - 16];
      v166 = v151 - 16;
      v167 = v162 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v169 = *((_OWORD *)v166 - 1);
        v168 = *(_OWORD *)v166;
        *((_OWORD *)v166 - 1) = 0uLL;
        *(_OWORD *)v166 = 0uLL;
        *((_OWORD *)v165 - 1) = v169;
        *(_OWORD *)v165 = v168;
        v165 -= 32;
        v166 -= 32;
        v167 -= 4;
      }
      while (v167);
      v151 = v164;
      if (v162 != (v162 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_907:
        do
        {
          v170 = *((_QWORD *)v151 - 1);
          v151 -= 8;
          *(_QWORD *)v151 = 0;
          *((_QWORD *)v159 - 1) = v170;
          v159 -= 8;
        }
        while (v151 != v153);
      }
      v151 = (char *)a1[1];
      v171 = (char *)a1[2];
      a1[1] = v159;
      a1[2] = v152;
      a1[3] = v160;
      while (v171 != v151)
      {
        v173 = *((_QWORD *)v171 - 1);
        v171 -= 8;
        v172 = v173;
        *(_QWORD *)v171 = 0;
        if (v173)
          (*(void (**)(uint64_t))(*(_QWORD *)v172 + 8))(v172);
      }
    }
    if (v151)
      operator delete(v151);
  }
  else
  {
    *(_QWORD *)v151 = v140;
    v152 = v151 + 8;
  }
  a1[2] = v152;
  v174 = operator new(0x60uLL);
  v175 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v174 + 1), (uint64_t)"mps.reduction_sum", 17, (__int16)v787, v175, 0, 0);
  *v174 = &off_1E0E49F98;
  if (!v174[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReduction<mlir"
           "::mps::ReductionSumOp>]";
    v788 = 132;
    v176 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v176)
      v177 = v176;
    else
      v177 = v788;
    v178 = &v787[v177];
    v179 = v788 - v177;
    if (v788 - v177 >= 0x12)
      v180 = 18;
    else
      v180 = v788 - v177;
    v181 = &v178[v180];
    v182 = v179 - v180;
    if (v182 >= v182 - 1)
      --v182;
    v174[8] = v181;
    v174[9] = v182;
  }
  v183 = *((unsigned int *)v174 + 22);
  if (v183 > *((_DWORD *)v174 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v174 + 10), v174 + 12, v183, 16);
    LODWORD(v183) = *((_DWORD *)v174 + 22);
  }
  *((_DWORD *)v174 + 22) = v183;
  v185 = (char *)a1[2];
  v184 = a1[3];
  if ((unint64_t)v185 >= v184)
  {
    v187 = (char *)a1[1];
    v188 = (v185 - v187) >> 3;
    v189 = v188 + 1;
    if ((unint64_t)(v188 + 1) >> 61)
      goto LABEL_899;
    v190 = v184 - (_QWORD)v187;
    if (v190 >> 2 > v189)
      v189 = v190 >> 2;
    if ((unint64_t)v190 >= 0x7FFFFFFFFFFFFFF8)
      v191 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v191 = v189;
    if (v191)
    {
      if (v191 >> 61)
        goto LABEL_900;
      v192 = (char *)operator new(8 * v191);
    }
    else
    {
      v192 = 0;
    }
    v193 = &v192[8 * v188];
    v194 = &v192[8 * v191];
    *(_QWORD *)v193 = v174;
    v186 = v193 + 8;
    if (v185 == v187)
    {
      a1[1] = v193;
      a1[2] = v186;
      a1[3] = v194;
    }
    else
    {
      v195 = v185 - v187 - 8;
      if (v195 < 0x78
        || &v185[-(v195 & 0xFFFFFFFFFFFFFFF8) - 8] < v193
        && &v192[v185 - v187 - (v195 & 0xFFFFFFFFFFFFFFF8) - 8] < v185)
      {
        goto LABEL_908;
      }
      v196 = (v195 >> 3) + 1;
      v197 = 8 * (v196 & 0x3FFFFFFFFFFFFFFCLL);
      v198 = &v185[-v197];
      v193 -= v197;
      v199 = &v192[8 * v188 - 16];
      v200 = v185 - 16;
      v201 = v196 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v203 = *((_OWORD *)v200 - 1);
        v202 = *(_OWORD *)v200;
        *((_OWORD *)v200 - 1) = 0uLL;
        *(_OWORD *)v200 = 0uLL;
        *((_OWORD *)v199 - 1) = v203;
        *(_OWORD *)v199 = v202;
        v199 -= 32;
        v200 -= 32;
        v201 -= 4;
      }
      while (v201);
      v185 = v198;
      if (v196 != (v196 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_908:
        do
        {
          v204 = *((_QWORD *)v185 - 1);
          v185 -= 8;
          *(_QWORD *)v185 = 0;
          *((_QWORD *)v193 - 1) = v204;
          v193 -= 8;
        }
        while (v185 != v187);
      }
      v185 = (char *)a1[1];
      v205 = (char *)a1[2];
      a1[1] = v193;
      a1[2] = v186;
      a1[3] = v194;
      while (v205 != v185)
      {
        v207 = *((_QWORD *)v205 - 1);
        v205 -= 8;
        v206 = v207;
        *(_QWORD *)v205 = 0;
        if (v207)
          (*(void (**)(uint64_t))(*(_QWORD *)v206 + 8))(v206);
      }
    }
    if (v185)
      operator delete(v185);
  }
  else
  {
    *(_QWORD *)v185 = v174;
    v186 = v185 + 8;
  }
  a1[2] = v186;
  v208 = operator new(0x60uLL);
  v209 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v208 + 1), (uint64_t)"mps.reduction_argmax", 20, (__int16)v787, v209, 0, 0);
  *v208 = &off_1E0E4AC68;
  if (!v208[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReductionAxes<"
           "mlir::mps::ReductionArgMaxOp>]";
    v788 = 139;
    v210 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v210)
      v211 = v210;
    else
      v211 = v788;
    v212 = &v787[v211];
    v213 = v788 - v211;
    if (v788 - v211 >= 0x12)
      v214 = 18;
    else
      v214 = v788 - v211;
    v215 = &v212[v214];
    v216 = v213 - v214;
    if (v216 >= v216 - 1)
      --v216;
    v208[8] = v215;
    v208[9] = v216;
  }
  v217 = *((unsigned int *)v208 + 22);
  if (v217 > *((_DWORD *)v208 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v208 + 10), v208 + 12, v217, 16);
    LODWORD(v217) = *((_DWORD *)v208 + 22);
  }
  *((_DWORD *)v208 + 22) = v217;
  v219 = (char *)a1[2];
  v218 = a1[3];
  if ((unint64_t)v219 >= v218)
  {
    v221 = (char *)a1[1];
    v222 = (v219 - v221) >> 3;
    v223 = v222 + 1;
    if ((unint64_t)(v222 + 1) >> 61)
      goto LABEL_899;
    v224 = v218 - (_QWORD)v221;
    if (v224 >> 2 > v223)
      v223 = v224 >> 2;
    if ((unint64_t)v224 >= 0x7FFFFFFFFFFFFFF8)
      v225 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v225 = v223;
    if (v225)
    {
      if (v225 >> 61)
        goto LABEL_900;
      v226 = (char *)operator new(8 * v225);
    }
    else
    {
      v226 = 0;
    }
    v227 = &v226[8 * v222];
    v228 = &v226[8 * v225];
    *(_QWORD *)v227 = v208;
    v220 = v227 + 8;
    if (v219 == v221)
    {
      a1[1] = v227;
      a1[2] = v220;
      a1[3] = v228;
    }
    else
    {
      v229 = v219 - v221 - 8;
      if (v229 < 0x78
        || &v219[-(v229 & 0xFFFFFFFFFFFFFFF8) - 8] < v227
        && &v226[v219 - v221 - (v229 & 0xFFFFFFFFFFFFFFF8) - 8] < v219)
      {
        goto LABEL_909;
      }
      v230 = (v229 >> 3) + 1;
      v231 = 8 * (v230 & 0x3FFFFFFFFFFFFFFCLL);
      v232 = &v219[-v231];
      v227 -= v231;
      v233 = &v226[8 * v222 - 16];
      v234 = v219 - 16;
      v235 = v230 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v237 = *((_OWORD *)v234 - 1);
        v236 = *(_OWORD *)v234;
        *((_OWORD *)v234 - 1) = 0uLL;
        *(_OWORD *)v234 = 0uLL;
        *((_OWORD *)v233 - 1) = v237;
        *(_OWORD *)v233 = v236;
        v233 -= 32;
        v234 -= 32;
        v235 -= 4;
      }
      while (v235);
      v219 = v232;
      if (v230 != (v230 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_909:
        do
        {
          v238 = *((_QWORD *)v219 - 1);
          v219 -= 8;
          *(_QWORD *)v219 = 0;
          *((_QWORD *)v227 - 1) = v238;
          v227 -= 8;
        }
        while (v219 != v221);
      }
      v219 = (char *)a1[1];
      v239 = (char *)a1[2];
      a1[1] = v227;
      a1[2] = v220;
      a1[3] = v228;
      while (v239 != v219)
      {
        v241 = *((_QWORD *)v239 - 1);
        v239 -= 8;
        v240 = v241;
        *(_QWORD *)v239 = 0;
        if (v241)
          (*(void (**)(uint64_t))(*(_QWORD *)v240 + 8))(v240);
      }
    }
    if (v219)
      operator delete(v219);
  }
  else
  {
    *(_QWORD *)v219 = v208;
    v220 = v219 + 8;
  }
  a1[2] = v220;
  v242 = operator new(0x60uLL);
  v243 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v242 + 1), (uint64_t)"mps.reduction_argmin", 20, (__int16)v787, v243, 0, 0);
  *v242 = &off_1E0E4ACC0;
  if (!v242[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReductionAxes<"
           "mlir::mps::ReductionArgMinOp>]";
    v788 = 139;
    v244 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v244)
      v245 = v244;
    else
      v245 = v788;
    v246 = &v787[v245];
    v247 = v788 - v245;
    if (v788 - v245 >= 0x12)
      v248 = 18;
    else
      v248 = v788 - v245;
    v249 = &v246[v248];
    v250 = v247 - v248;
    if (v250 >= v250 - 1)
      --v250;
    v242[8] = v249;
    v242[9] = v250;
  }
  v251 = *((unsigned int *)v242 + 22);
  if (v251 > *((_DWORD *)v242 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v242 + 10), v242 + 12, v251, 16);
    LODWORD(v251) = *((_DWORD *)v242 + 22);
  }
  *((_DWORD *)v242 + 22) = v251;
  v253 = (char *)a1[2];
  v252 = a1[3];
  if ((unint64_t)v253 >= v252)
  {
    v255 = (char *)a1[1];
    v256 = (v253 - v255) >> 3;
    v257 = v256 + 1;
    if ((unint64_t)(v256 + 1) >> 61)
      goto LABEL_899;
    v258 = v252 - (_QWORD)v255;
    if (v258 >> 2 > v257)
      v257 = v258 >> 2;
    if ((unint64_t)v258 >= 0x7FFFFFFFFFFFFFF8)
      v259 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v259 = v257;
    if (v259)
    {
      if (v259 >> 61)
        goto LABEL_900;
      v260 = (char *)operator new(8 * v259);
    }
    else
    {
      v260 = 0;
    }
    v261 = &v260[8 * v256];
    v262 = &v260[8 * v259];
    *(_QWORD *)v261 = v242;
    v254 = v261 + 8;
    if (v253 == v255)
    {
      a1[1] = v261;
      a1[2] = v254;
      a1[3] = v262;
    }
    else
    {
      v263 = v253 - v255 - 8;
      if (v263 < 0x78
        || &v253[-(v263 & 0xFFFFFFFFFFFFFFF8) - 8] < v261
        && &v260[v253 - v255 - (v263 & 0xFFFFFFFFFFFFFFF8) - 8] < v253)
      {
        goto LABEL_910;
      }
      v264 = (v263 >> 3) + 1;
      v265 = 8 * (v264 & 0x3FFFFFFFFFFFFFFCLL);
      v266 = &v253[-v265];
      v261 -= v265;
      v267 = &v260[8 * v256 - 16];
      v268 = v253 - 16;
      v269 = v264 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v271 = *((_OWORD *)v268 - 1);
        v270 = *(_OWORD *)v268;
        *((_OWORD *)v268 - 1) = 0uLL;
        *(_OWORD *)v268 = 0uLL;
        *((_OWORD *)v267 - 1) = v271;
        *(_OWORD *)v267 = v270;
        v267 -= 32;
        v268 -= 32;
        v269 -= 4;
      }
      while (v269);
      v253 = v266;
      if (v264 != (v264 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_910:
        do
        {
          v272 = *((_QWORD *)v253 - 1);
          v253 -= 8;
          *(_QWORD *)v253 = 0;
          *((_QWORD *)v261 - 1) = v272;
          v261 -= 8;
        }
        while (v253 != v255);
      }
      v253 = (char *)a1[1];
      v273 = (char *)a1[2];
      a1[1] = v261;
      a1[2] = v254;
      a1[3] = v262;
      while (v273 != v253)
      {
        v275 = *((_QWORD *)v273 - 1);
        v273 -= 8;
        v274 = v275;
        *(_QWORD *)v273 = 0;
        if (v275)
          (*(void (**)(uint64_t))(*(_QWORD *)v274 + 8))(v274);
      }
    }
    if (v253)
      operator delete(v253);
  }
  else
  {
    *(_QWORD *)v253 = v242;
    v254 = v253 + 8;
  }
  a1[2] = v254;
  v276 = operator new(0x60uLL);
  v277 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v276 + 1), (uint64_t)"mps.reduction_max", 17, (__int16)v787, v277, 0, 0);
  *v276 = &off_1E0E4AB08;
  if (!v276[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReductionAxes<"
           "mlir::mps::ReductionMaxOp>]";
    v788 = 136;
    v278 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v278)
      v279 = v278;
    else
      v279 = v788;
    v280 = &v787[v279];
    v281 = v788 - v279;
    if (v788 - v279 >= 0x12)
      v282 = 18;
    else
      v282 = v788 - v279;
    v283 = &v280[v282];
    v284 = v281 - v282;
    if (v284 >= v284 - 1)
      --v284;
    v276[8] = v283;
    v276[9] = v284;
  }
  v285 = *((unsigned int *)v276 + 22);
  if (v285 > *((_DWORD *)v276 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v276 + 10), v276 + 12, v285, 16);
    LODWORD(v285) = *((_DWORD *)v276 + 22);
  }
  *((_DWORD *)v276 + 22) = v285;
  v287 = (char *)a1[2];
  v286 = a1[3];
  if ((unint64_t)v287 >= v286)
  {
    v289 = (char *)a1[1];
    v290 = (v287 - v289) >> 3;
    v291 = v290 + 1;
    if ((unint64_t)(v290 + 1) >> 61)
      goto LABEL_899;
    v292 = v286 - (_QWORD)v289;
    if (v292 >> 2 > v291)
      v291 = v292 >> 2;
    if ((unint64_t)v292 >= 0x7FFFFFFFFFFFFFF8)
      v293 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v293 = v291;
    if (v293)
    {
      if (v293 >> 61)
        goto LABEL_900;
      v294 = (char *)operator new(8 * v293);
    }
    else
    {
      v294 = 0;
    }
    v295 = &v294[8 * v290];
    v296 = &v294[8 * v293];
    *(_QWORD *)v295 = v276;
    v288 = v295 + 8;
    if (v287 == v289)
    {
      a1[1] = v295;
      a1[2] = v288;
      a1[3] = v296;
    }
    else
    {
      v297 = v287 - v289 - 8;
      if (v297 < 0x78
        || &v287[-(v297 & 0xFFFFFFFFFFFFFFF8) - 8] < v295
        && &v294[v287 - v289 - (v297 & 0xFFFFFFFFFFFFFFF8) - 8] < v287)
      {
        goto LABEL_911;
      }
      v298 = (v297 >> 3) + 1;
      v299 = 8 * (v298 & 0x3FFFFFFFFFFFFFFCLL);
      v300 = &v287[-v299];
      v295 -= v299;
      v301 = &v294[8 * v290 - 16];
      v302 = v287 - 16;
      v303 = v298 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v305 = *((_OWORD *)v302 - 1);
        v304 = *(_OWORD *)v302;
        *((_OWORD *)v302 - 1) = 0uLL;
        *(_OWORD *)v302 = 0uLL;
        *((_OWORD *)v301 - 1) = v305;
        *(_OWORD *)v301 = v304;
        v301 -= 32;
        v302 -= 32;
        v303 -= 4;
      }
      while (v303);
      v287 = v300;
      if (v298 != (v298 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_911:
        do
        {
          v306 = *((_QWORD *)v287 - 1);
          v287 -= 8;
          *(_QWORD *)v287 = 0;
          *((_QWORD *)v295 - 1) = v306;
          v295 -= 8;
        }
        while (v287 != v289);
      }
      v287 = (char *)a1[1];
      v307 = (char *)a1[2];
      a1[1] = v295;
      a1[2] = v288;
      a1[3] = v296;
      while (v307 != v287)
      {
        v309 = *((_QWORD *)v307 - 1);
        v307 -= 8;
        v308 = v309;
        *(_QWORD *)v307 = 0;
        if (v309)
          (*(void (**)(uint64_t))(*(_QWORD *)v308 + 8))(v308);
      }
    }
    if (v287)
      operator delete(v287);
  }
  else
  {
    *(_QWORD *)v287 = v276;
    v288 = v287 + 8;
  }
  a1[2] = v288;
  v310 = operator new(0x60uLL);
  v311 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v310 + 1), (uint64_t)"mps.reduction_min", 17, (__int16)v787, v311, 0, 0);
  *v310 = &off_1E0E4AB60;
  if (!v310[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReductionAxes<"
           "mlir::mps::ReductionMinOp>]";
    v788 = 136;
    v312 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v312)
      v313 = v312;
    else
      v313 = v788;
    v314 = &v787[v313];
    v315 = v788 - v313;
    if (v788 - v313 >= 0x12)
      v316 = 18;
    else
      v316 = v788 - v313;
    v317 = &v314[v316];
    v318 = v315 - v316;
    if (v318 >= v318 - 1)
      --v318;
    v310[8] = v317;
    v310[9] = v318;
  }
  v319 = *((unsigned int *)v310 + 22);
  if (v319 > *((_DWORD *)v310 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v310 + 10), v310 + 12, v319, 16);
    LODWORD(v319) = *((_DWORD *)v310 + 22);
  }
  *((_DWORD *)v310 + 22) = v319;
  v321 = (char *)a1[2];
  v320 = a1[3];
  if ((unint64_t)v321 >= v320)
  {
    v323 = (char *)a1[1];
    v324 = (v321 - v323) >> 3;
    v325 = v324 + 1;
    if ((unint64_t)(v324 + 1) >> 61)
      goto LABEL_899;
    v326 = v320 - (_QWORD)v323;
    if (v326 >> 2 > v325)
      v325 = v326 >> 2;
    if ((unint64_t)v326 >= 0x7FFFFFFFFFFFFFF8)
      v327 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v327 = v325;
    if (v327)
    {
      if (v327 >> 61)
        goto LABEL_900;
      v328 = (char *)operator new(8 * v327);
    }
    else
    {
      v328 = 0;
    }
    v329 = &v328[8 * v324];
    v330 = &v328[8 * v327];
    *(_QWORD *)v329 = v310;
    v322 = v329 + 8;
    if (v321 == v323)
    {
      a1[1] = v329;
      a1[2] = v322;
      a1[3] = v330;
    }
    else
    {
      v331 = v321 - v323 - 8;
      if (v331 < 0x78
        || &v321[-(v331 & 0xFFFFFFFFFFFFFFF8) - 8] < v329
        && &v328[v321 - v323 - (v331 & 0xFFFFFFFFFFFFFFF8) - 8] < v321)
      {
        goto LABEL_912;
      }
      v332 = (v331 >> 3) + 1;
      v333 = 8 * (v332 & 0x3FFFFFFFFFFFFFFCLL);
      v334 = &v321[-v333];
      v329 -= v333;
      v335 = &v328[8 * v324 - 16];
      v336 = v321 - 16;
      v337 = v332 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v339 = *((_OWORD *)v336 - 1);
        v338 = *(_OWORD *)v336;
        *((_OWORD *)v336 - 1) = 0uLL;
        *(_OWORD *)v336 = 0uLL;
        *((_OWORD *)v335 - 1) = v339;
        *(_OWORD *)v335 = v338;
        v335 -= 32;
        v336 -= 32;
        v337 -= 4;
      }
      while (v337);
      v321 = v334;
      if (v332 != (v332 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_912:
        do
        {
          v340 = *((_QWORD *)v321 - 1);
          v321 -= 8;
          *(_QWORD *)v321 = 0;
          *((_QWORD *)v329 - 1) = v340;
          v329 -= 8;
        }
        while (v321 != v323);
      }
      v321 = (char *)a1[1];
      v341 = (char *)a1[2];
      a1[1] = v329;
      a1[2] = v322;
      a1[3] = v330;
      while (v341 != v321)
      {
        v343 = *((_QWORD *)v341 - 1);
        v341 -= 8;
        v342 = v343;
        *(_QWORD *)v341 = 0;
        if (v343)
          (*(void (**)(uint64_t))(*(_QWORD *)v342 + 8))(v342);
      }
    }
    if (v321)
      operator delete(v321);
  }
  else
  {
    *(_QWORD *)v321 = v310;
    v322 = v321 + 8;
  }
  a1[2] = v322;
  v344 = operator new(0x60uLL);
  v345 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v344 + 1), (uint64_t)"mps.reduction_prod", 18, (__int16)v787, v345, 0, 0);
  *v344 = &off_1E0E4AC10;
  if (!v344[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReductionAxes<"
           "mlir::mps::ReductionProdOp>]";
    v788 = 137;
    v346 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v346)
      v347 = v346;
    else
      v347 = v788;
    v348 = &v787[v347];
    v349 = v788 - v347;
    if (v788 - v347 >= 0x12)
      v350 = 18;
    else
      v350 = v788 - v347;
    v351 = &v348[v350];
    v352 = v349 - v350;
    if (v352 >= v352 - 1)
      --v352;
    v344[8] = v351;
    v344[9] = v352;
  }
  v353 = *((unsigned int *)v344 + 22);
  if (v353 > *((_DWORD *)v344 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v344 + 10), v344 + 12, v353, 16);
    LODWORD(v353) = *((_DWORD *)v344 + 22);
  }
  *((_DWORD *)v344 + 22) = v353;
  v355 = (char *)a1[2];
  v354 = a1[3];
  if ((unint64_t)v355 >= v354)
  {
    v357 = (char *)a1[1];
    v358 = (v355 - v357) >> 3;
    v359 = v358 + 1;
    if ((unint64_t)(v358 + 1) >> 61)
      goto LABEL_899;
    v360 = v354 - (_QWORD)v357;
    if (v360 >> 2 > v359)
      v359 = v360 >> 2;
    if ((unint64_t)v360 >= 0x7FFFFFFFFFFFFFF8)
      v361 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v361 = v359;
    if (v361)
    {
      if (v361 >> 61)
        goto LABEL_900;
      v362 = (char *)operator new(8 * v361);
    }
    else
    {
      v362 = 0;
    }
    v363 = &v362[8 * v358];
    v364 = &v362[8 * v361];
    *(_QWORD *)v363 = v344;
    v356 = v363 + 8;
    if (v355 == v357)
    {
      a1[1] = v363;
      a1[2] = v356;
      a1[3] = v364;
    }
    else
    {
      v365 = v355 - v357 - 8;
      if (v365 < 0x78
        || &v355[-(v365 & 0xFFFFFFFFFFFFFFF8) - 8] < v363
        && &v362[v355 - v357 - (v365 & 0xFFFFFFFFFFFFFFF8) - 8] < v355)
      {
        goto LABEL_913;
      }
      v366 = (v365 >> 3) + 1;
      v367 = 8 * (v366 & 0x3FFFFFFFFFFFFFFCLL);
      v368 = &v355[-v367];
      v363 -= v367;
      v369 = &v362[8 * v358 - 16];
      v370 = v355 - 16;
      v371 = v366 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v373 = *((_OWORD *)v370 - 1);
        v372 = *(_OWORD *)v370;
        *((_OWORD *)v370 - 1) = 0uLL;
        *(_OWORD *)v370 = 0uLL;
        *((_OWORD *)v369 - 1) = v373;
        *(_OWORD *)v369 = v372;
        v369 -= 32;
        v370 -= 32;
        v371 -= 4;
      }
      while (v371);
      v355 = v368;
      if (v366 != (v366 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_913:
        do
        {
          v374 = *((_QWORD *)v355 - 1);
          v355 -= 8;
          *(_QWORD *)v355 = 0;
          *((_QWORD *)v363 - 1) = v374;
          v363 -= 8;
        }
        while (v355 != v357);
      }
      v355 = (char *)a1[1];
      v375 = (char *)a1[2];
      a1[1] = v363;
      a1[2] = v356;
      a1[3] = v364;
      while (v375 != v355)
      {
        v377 = *((_QWORD *)v375 - 1);
        v375 -= 8;
        v376 = v377;
        *(_QWORD *)v375 = 0;
        if (v377)
          (*(void (**)(uint64_t))(*(_QWORD *)v376 + 8))(v376);
      }
    }
    if (v355)
      operator delete(v355);
  }
  else
  {
    *(_QWORD *)v355 = v344;
    v356 = v355 + 8;
  }
  a1[2] = v356;
  v378 = operator new(0x60uLL);
  v379 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v378 + 1), (uint64_t)"mps.reduction_sum", 17, (__int16)v787, v379, 0, 0);
  *v378 = &off_1E0E4ABB8;
  if (!v378[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReductionAxes<"
           "mlir::mps::ReductionSumOp>]";
    v788 = 136;
    v380 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v380)
      v381 = v380;
    else
      v381 = v788;
    v382 = &v787[v381];
    v383 = v788 - v381;
    if (v788 - v381 >= 0x12)
      v384 = 18;
    else
      v384 = v788 - v381;
    v385 = &v382[v384];
    v386 = v383 - v384;
    if (v386 >= v386 - 1)
      --v386;
    v378[8] = v385;
    v378[9] = v386;
  }
  v387 = *((unsigned int *)v378 + 22);
  if (v387 > *((_DWORD *)v378 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v378 + 10), v378 + 12, v387, 16);
    LODWORD(v387) = *((_DWORD *)v378 + 22);
  }
  *((_DWORD *)v378 + 22) = v387;
  v389 = (char *)a1[2];
  v388 = a1[3];
  if ((unint64_t)v389 >= v388)
  {
    v391 = (char *)a1[1];
    v392 = (v389 - v391) >> 3;
    v393 = v392 + 1;
    if ((unint64_t)(v392 + 1) >> 61)
      goto LABEL_899;
    v394 = v388 - (_QWORD)v391;
    if (v394 >> 2 > v393)
      v393 = v394 >> 2;
    if ((unint64_t)v394 >= 0x7FFFFFFFFFFFFFF8)
      v395 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v395 = v393;
    if (v395)
    {
      if (v395 >> 61)
        goto LABEL_900;
      v396 = (char *)operator new(8 * v395);
    }
    else
    {
      v396 = 0;
    }
    v397 = &v396[8 * v392];
    v398 = &v396[8 * v395];
    *(_QWORD *)v397 = v378;
    v390 = v397 + 8;
    if (v389 == v391)
    {
      a1[1] = v397;
      a1[2] = v390;
      a1[3] = v398;
    }
    else
    {
      v399 = v389 - v391 - 8;
      if (v399 < 0x78
        || &v389[-(v399 & 0xFFFFFFFFFFFFFFF8) - 8] < v397
        && &v396[v389 - v391 - (v399 & 0xFFFFFFFFFFFFFFF8) - 8] < v389)
      {
        goto LABEL_914;
      }
      v400 = (v399 >> 3) + 1;
      v401 = 8 * (v400 & 0x3FFFFFFFFFFFFFFCLL);
      v402 = &v389[-v401];
      v397 -= v401;
      v403 = &v396[8 * v392 - 16];
      v404 = v389 - 16;
      v405 = v400 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v407 = *((_OWORD *)v404 - 1);
        v406 = *(_OWORD *)v404;
        *((_OWORD *)v404 - 1) = 0uLL;
        *(_OWORD *)v404 = 0uLL;
        *((_OWORD *)v403 - 1) = v407;
        *(_OWORD *)v403 = v406;
        v403 -= 32;
        v404 -= 32;
        v405 -= 4;
      }
      while (v405);
      v389 = v402;
      if (v400 != (v400 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_914:
        do
        {
          v408 = *((_QWORD *)v389 - 1);
          v389 -= 8;
          *(_QWORD *)v389 = 0;
          *((_QWORD *)v397 - 1) = v408;
          v397 -= 8;
        }
        while (v389 != v391);
      }
      v389 = (char *)a1[1];
      v409 = (char *)a1[2];
      a1[1] = v397;
      a1[2] = v390;
      a1[3] = v398;
      while (v409 != v389)
      {
        v411 = *((_QWORD *)v409 - 1);
        v409 -= 8;
        v410 = v411;
        *(_QWORD *)v409 = 0;
        if (v411)
          (*(void (**)(uint64_t))(*(_QWORD *)v410 + 8))(v410);
      }
    }
    if (v389)
      operator delete(v389);
  }
  else
  {
    *(_QWORD *)v389 = v378;
    v390 = v389 + 8;
  }
  a1[2] = v390;
  v412 = operator new(0x60uLL);
  v413 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v412 + 1), (uint64_t)"mps.matmul", 10, (__int16)v787, v413, 0, 0);
  *v412 = off_1E0E4AE20;
  if (!v412[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeMatMulTranspose]";
    v788 = 111;
    v414 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v414)
      v415 = v414;
    else
      v415 = v788;
    v416 = &v787[v415];
    v417 = v788 - v415;
    if (v788 - v415 >= 0x12)
      v418 = 18;
    else
      v418 = v788 - v415;
    v419 = &v416[v418];
    v420 = v417 - v418;
    if (v420 >= v420 - 1)
      --v420;
    v412[8] = v419;
    v412[9] = v420;
  }
  v421 = *((unsigned int *)v412 + 22);
  if (v421 > *((_DWORD *)v412 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v412 + 10), v412 + 12, v421, 16);
    LODWORD(v421) = *((_DWORD *)v412 + 22);
  }
  *((_DWORD *)v412 + 22) = v421;
  v423 = (char *)a1[2];
  v422 = a1[3];
  if ((unint64_t)v423 >= v422)
  {
    v425 = (char *)a1[1];
    v426 = (v423 - v425) >> 3;
    v427 = v426 + 1;
    if ((unint64_t)(v426 + 1) >> 61)
      goto LABEL_899;
    v428 = v422 - (_QWORD)v425;
    if (v428 >> 2 > v427)
      v427 = v428 >> 2;
    if ((unint64_t)v428 >= 0x7FFFFFFFFFFFFFF8)
      v429 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v429 = v427;
    if (v429)
    {
      if (v429 >> 61)
        goto LABEL_900;
      v430 = (char *)operator new(8 * v429);
    }
    else
    {
      v430 = 0;
    }
    v431 = &v430[8 * v426];
    v432 = &v430[8 * v429];
    *(_QWORD *)v431 = v412;
    v424 = v431 + 8;
    if (v423 == v425)
    {
      a1[1] = v431;
      a1[2] = v424;
      a1[3] = v432;
    }
    else
    {
      v433 = v423 - v425 - 8;
      if (v433 < 0x78
        || &v423[-(v433 & 0xFFFFFFFFFFFFFFF8) - 8] < v431
        && &v430[v423 - v425 - (v433 & 0xFFFFFFFFFFFFFFF8) - 8] < v423)
      {
        goto LABEL_915;
      }
      v434 = (v433 >> 3) + 1;
      v435 = 8 * (v434 & 0x3FFFFFFFFFFFFFFCLL);
      v436 = &v423[-v435];
      v431 -= v435;
      v437 = &v430[8 * v426 - 16];
      v438 = v423 - 16;
      v439 = v434 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v441 = *((_OWORD *)v438 - 1);
        v440 = *(_OWORD *)v438;
        *((_OWORD *)v438 - 1) = 0uLL;
        *(_OWORD *)v438 = 0uLL;
        *((_OWORD *)v437 - 1) = v441;
        *(_OWORD *)v437 = v440;
        v437 -= 32;
        v438 -= 32;
        v439 -= 4;
      }
      while (v439);
      v423 = v436;
      if (v434 != (v434 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_915:
        do
        {
          v442 = *((_QWORD *)v423 - 1);
          v423 -= 8;
          *(_QWORD *)v423 = 0;
          *((_QWORD *)v431 - 1) = v442;
          v431 -= 8;
        }
        while (v423 != v425);
      }
      v423 = (char *)a1[1];
      v443 = (char *)a1[2];
      a1[1] = v431;
      a1[2] = v424;
      a1[3] = v432;
      while (v443 != v423)
      {
        v445 = *((_QWORD *)v443 - 1);
        v443 -= 8;
        v444 = v445;
        *(_QWORD *)v443 = 0;
        if (v445)
          (*(void (**)(uint64_t))(*(_QWORD *)v444 + 8))(v444);
      }
    }
    if (v423)
      operator delete(v423);
  }
  else
  {
    *(_QWORD *)v423 = v412;
    v424 = v423 + 8;
  }
  a1[2] = v424;
  v446 = operator new(0x60uLL);
  v447 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v446 + 1), (uint64_t)"mps.matmul", 10, (__int16)v787, v447, 0, 0);
  *v446 = off_1E0E49C50;
  if (!v446[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeMatMul1D]";
    v788 = 104;
    v448 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v448)
      v449 = v448;
    else
      v449 = v788;
    v450 = &v787[v449];
    v451 = v788 - v449;
    if (v788 - v449 >= 0x12)
      v452 = 18;
    else
      v452 = v788 - v449;
    v453 = &v450[v452];
    v454 = v451 - v452;
    if (v454 >= v454 - 1)
      --v454;
    v446[8] = v453;
    v446[9] = v454;
  }
  v455 = *((unsigned int *)v446 + 22);
  if (v455 > *((_DWORD *)v446 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v446 + 10), v446 + 12, v455, 16);
    LODWORD(v455) = *((_DWORD *)v446 + 22);
  }
  *((_DWORD *)v446 + 22) = v455;
  v457 = (char *)a1[2];
  v456 = a1[3];
  if ((unint64_t)v457 >= v456)
  {
    v459 = (char *)a1[1];
    v460 = (v457 - v459) >> 3;
    v461 = v460 + 1;
    if ((unint64_t)(v460 + 1) >> 61)
      goto LABEL_899;
    v462 = v456 - (_QWORD)v459;
    if (v462 >> 2 > v461)
      v461 = v462 >> 2;
    if ((unint64_t)v462 >= 0x7FFFFFFFFFFFFFF8)
      v463 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v463 = v461;
    if (v463)
    {
      if (v463 >> 61)
        goto LABEL_900;
      v464 = (char *)operator new(8 * v463);
    }
    else
    {
      v464 = 0;
    }
    v465 = &v464[8 * v460];
    v466 = &v464[8 * v463];
    *(_QWORD *)v465 = v446;
    v458 = v465 + 8;
    if (v457 == v459)
    {
      a1[1] = v465;
      a1[2] = v458;
      a1[3] = v466;
    }
    else
    {
      v467 = v457 - v459 - 8;
      if (v467 < 0x78
        || &v457[-(v467 & 0xFFFFFFFFFFFFFFF8) - 8] < v465
        && &v464[v457 - v459 - (v467 & 0xFFFFFFFFFFFFFFF8) - 8] < v457)
      {
        goto LABEL_916;
      }
      v468 = (v467 >> 3) + 1;
      v469 = 8 * (v468 & 0x3FFFFFFFFFFFFFFCLL);
      v470 = &v457[-v469];
      v465 -= v469;
      v471 = &v464[8 * v460 - 16];
      v472 = v457 - 16;
      v473 = v468 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v475 = *((_OWORD *)v472 - 1);
        v474 = *(_OWORD *)v472;
        *((_OWORD *)v472 - 1) = 0uLL;
        *(_OWORD *)v472 = 0uLL;
        *((_OWORD *)v471 - 1) = v475;
        *(_OWORD *)v471 = v474;
        v471 -= 32;
        v472 -= 32;
        v473 -= 4;
      }
      while (v473);
      v457 = v470;
      if (v468 != (v468 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_916:
        do
        {
          v476 = *((_QWORD *)v457 - 1);
          v457 -= 8;
          *(_QWORD *)v457 = 0;
          *((_QWORD *)v465 - 1) = v476;
          v465 -= 8;
        }
        while (v457 != v459);
      }
      v457 = (char *)a1[1];
      v477 = (char *)a1[2];
      a1[1] = v465;
      a1[2] = v458;
      a1[3] = v466;
      while (v477 != v457)
      {
        v479 = *((_QWORD *)v477 - 1);
        v477 -= 8;
        v478 = v479;
        *(_QWORD *)v477 = 0;
        if (v479)
          (*(void (**)(uint64_t))(*(_QWORD *)v478 + 8))(v478);
      }
    }
    if (v457)
      operator delete(v457);
  }
  else
  {
    *(_QWORD *)v457 = v446;
    v458 = v457 + 8;
  }
  a1[2] = v458;
  v480 = operator new(0x60uLL);
  v481 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v480 + 1), (uint64_t)"mps.conv_2d", 11, (__int16)v787, v481, 0, 0);
  *v480 = &off_1E0E4ADC8;
  if (!v480[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeConvToDepthwis"
           "e<mlir::mps::Conv2DOp>]";
    v788 = 132;
    v482 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v482)
      v483 = v482;
    else
      v483 = v788;
    v484 = &v787[v483];
    v485 = v788 - v483;
    if (v788 - v483 >= 0x12)
      v486 = 18;
    else
      v486 = v788 - v483;
    v487 = &v484[v486];
    v488 = v485 - v486;
    if (v488 >= v488 - 1)
      --v488;
    v480[8] = v487;
    v480[9] = v488;
  }
  v489 = *((unsigned int *)v480 + 22);
  if (v489 > *((_DWORD *)v480 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v480 + 10), v480 + 12, v489, 16);
    LODWORD(v489) = *((_DWORD *)v480 + 22);
  }
  *((_DWORD *)v480 + 22) = v489;
  v491 = (char *)a1[2];
  v490 = a1[3];
  if ((unint64_t)v491 >= v490)
  {
    v493 = (char *)a1[1];
    v494 = (v491 - v493) >> 3;
    v495 = v494 + 1;
    if ((unint64_t)(v494 + 1) >> 61)
      goto LABEL_899;
    v496 = v490 - (_QWORD)v493;
    if (v496 >> 2 > v495)
      v495 = v496 >> 2;
    if ((unint64_t)v496 >= 0x7FFFFFFFFFFFFFF8)
      v497 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v497 = v495;
    if (v497)
    {
      if (v497 >> 61)
        goto LABEL_900;
      v498 = (char *)operator new(8 * v497);
    }
    else
    {
      v498 = 0;
    }
    v499 = &v498[8 * v494];
    v500 = &v498[8 * v497];
    *(_QWORD *)v499 = v480;
    v492 = v499 + 8;
    if (v491 == v493)
    {
      a1[1] = v499;
      a1[2] = v492;
      a1[3] = v500;
    }
    else
    {
      v501 = v491 - v493 - 8;
      if (v501 < 0x78
        || &v491[-(v501 & 0xFFFFFFFFFFFFFFF8) - 8] < v499
        && &v498[v491 - v493 - (v501 & 0xFFFFFFFFFFFFFFF8) - 8] < v491)
      {
        goto LABEL_917;
      }
      v502 = (v501 >> 3) + 1;
      v503 = 8 * (v502 & 0x3FFFFFFFFFFFFFFCLL);
      v504 = &v491[-v503];
      v499 -= v503;
      v505 = &v498[8 * v494 - 16];
      v506 = v491 - 16;
      v507 = v502 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v509 = *((_OWORD *)v506 - 1);
        v508 = *(_OWORD *)v506;
        *((_OWORD *)v506 - 1) = 0uLL;
        *(_OWORD *)v506 = 0uLL;
        *((_OWORD *)v505 - 1) = v509;
        *(_OWORD *)v505 = v508;
        v505 -= 32;
        v506 -= 32;
        v507 -= 4;
      }
      while (v507);
      v491 = v504;
      if (v502 != (v502 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_917:
        do
        {
          v510 = *((_QWORD *)v491 - 1);
          v491 -= 8;
          *(_QWORD *)v491 = 0;
          *((_QWORD *)v499 - 1) = v510;
          v499 -= 8;
        }
        while (v491 != v493);
      }
      v491 = (char *)a1[1];
      v511 = (char *)a1[2];
      a1[1] = v499;
      a1[2] = v492;
      a1[3] = v500;
      while (v511 != v491)
      {
        v513 = *((_QWORD *)v511 - 1);
        v511 -= 8;
        v512 = v513;
        *(_QWORD *)v511 = 0;
        if (v513)
          (*(void (**)(uint64_t))(*(_QWORD *)v512 + 8))(v512);
      }
    }
    if (v491)
      operator delete(v491);
  }
  else
  {
    *(_QWORD *)v491 = v480;
    v492 = v491 + 8;
  }
  a1[2] = v492;
  v514 = operator new(0x60uLL);
  v515 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v514 + 1), (uint64_t)"mps.conv_2d_data_gradient", 25, (__int16)v787, v515, 0, 0);
  *v514 = &off_1E0E4AD70;
  if (!v514[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeConvToDepthwis"
           "e<mlir::mps::Conv2DDataGradientOp>]";
    v788 = 144;
    v516 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v516)
      v517 = v516;
    else
      v517 = v788;
    v518 = &v787[v517];
    v519 = v788 - v517;
    if (v788 - v517 >= 0x12)
      v520 = 18;
    else
      v520 = v788 - v517;
    v521 = &v518[v520];
    v522 = v519 - v520;
    if (v522 >= v522 - 1)
      --v522;
    v514[8] = v521;
    v514[9] = v522;
  }
  v523 = *((unsigned int *)v514 + 22);
  if (v523 > *((_DWORD *)v514 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v514 + 10), v514 + 12, v523, 16);
    LODWORD(v523) = *((_DWORD *)v514 + 22);
  }
  *((_DWORD *)v514 + 22) = v523;
  v525 = (char *)a1[2];
  v524 = a1[3];
  if ((unint64_t)v525 >= v524)
  {
    v527 = (char *)a1[1];
    v528 = (v525 - v527) >> 3;
    v529 = v528 + 1;
    if ((unint64_t)(v528 + 1) >> 61)
      goto LABEL_899;
    v530 = v524 - (_QWORD)v527;
    if (v530 >> 2 > v529)
      v529 = v530 >> 2;
    if ((unint64_t)v530 >= 0x7FFFFFFFFFFFFFF8)
      v531 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v531 = v529;
    if (v531)
    {
      if (v531 >> 61)
        goto LABEL_900;
      v532 = (char *)operator new(8 * v531);
    }
    else
    {
      v532 = 0;
    }
    v533 = &v532[8 * v528];
    v534 = &v532[8 * v531];
    *(_QWORD *)v533 = v514;
    v526 = v533 + 8;
    if (v525 == v527)
    {
      a1[1] = v533;
      a1[2] = v526;
      a1[3] = v534;
    }
    else
    {
      v535 = v525 - v527 - 8;
      if (v535 < 0x78
        || &v525[-(v535 & 0xFFFFFFFFFFFFFFF8) - 8] < v533
        && &v532[v525 - v527 - (v535 & 0xFFFFFFFFFFFFFFF8) - 8] < v525)
      {
        goto LABEL_918;
      }
      v536 = (v535 >> 3) + 1;
      v537 = 8 * (v536 & 0x3FFFFFFFFFFFFFFCLL);
      v538 = &v525[-v537];
      v533 -= v537;
      v539 = &v532[8 * v528 - 16];
      v540 = v525 - 16;
      v541 = v536 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v543 = *((_OWORD *)v540 - 1);
        v542 = *(_OWORD *)v540;
        *((_OWORD *)v540 - 1) = 0uLL;
        *(_OWORD *)v540 = 0uLL;
        *((_OWORD *)v539 - 1) = v543;
        *(_OWORD *)v539 = v542;
        v539 -= 32;
        v540 -= 32;
        v541 -= 4;
      }
      while (v541);
      v525 = v538;
      if (v536 != (v536 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_918:
        do
        {
          v544 = *((_QWORD *)v525 - 1);
          v525 -= 8;
          *(_QWORD *)v525 = 0;
          *((_QWORD *)v533 - 1) = v544;
          v533 -= 8;
        }
        while (v525 != v527);
      }
      v525 = (char *)a1[1];
      v545 = (char *)a1[2];
      a1[1] = v533;
      a1[2] = v526;
      a1[3] = v534;
      while (v545 != v525)
      {
        v547 = *((_QWORD *)v545 - 1);
        v545 -= 8;
        v546 = v547;
        *(_QWORD *)v545 = 0;
        if (v547)
          (*(void (**)(uint64_t))(*(_QWORD *)v546 + 8))(v546);
      }
    }
    if (v525)
      operator delete(v525);
  }
  else
  {
    *(_QWORD *)v525 = v514;
    v526 = v525 + 8;
  }
  a1[2] = v526;
  v548 = operator new(0x60uLL);
  v549 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v548 + 1), (uint64_t)"mpsx.sparse_dense_matmul", 24, (__int16)v787, v549, 0, 0);
  *v548 = off_1E0E4B210;
  if (!v548[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeSparseMatMulTranspose]";
    v788 = 117;
    v550 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v550)
      v551 = v550;
    else
      v551 = v788;
    v552 = &v787[v551];
    v553 = v788 - v551;
    if (v788 - v551 >= 0x12)
      v554 = 18;
    else
      v554 = v788 - v551;
    v555 = &v552[v554];
    v556 = v553 - v554;
    if (v556 >= v556 - 1)
      --v556;
    v548[8] = v555;
    v548[9] = v556;
  }
  v557 = *((unsigned int *)v548 + 22);
  if (v557 > *((_DWORD *)v548 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v548 + 10), v548 + 12, v557, 16);
    LODWORD(v557) = *((_DWORD *)v548 + 22);
  }
  *((_DWORD *)v548 + 22) = v557;
  v559 = (char *)a1[2];
  v558 = a1[3];
  if ((unint64_t)v559 >= v558)
  {
    v561 = (char *)a1[1];
    v562 = (v559 - v561) >> 3;
    v563 = v562 + 1;
    if ((unint64_t)(v562 + 1) >> 61)
      goto LABEL_899;
    v564 = v558 - (_QWORD)v561;
    if (v564 >> 2 > v563)
      v563 = v564 >> 2;
    if ((unint64_t)v564 >= 0x7FFFFFFFFFFFFFF8)
      v565 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v565 = v563;
    if (v565)
    {
      if (v565 >> 61)
        goto LABEL_900;
      v566 = (char *)operator new(8 * v565);
    }
    else
    {
      v566 = 0;
    }
    v567 = &v566[8 * v562];
    v568 = &v566[8 * v565];
    *(_QWORD *)v567 = v548;
    v560 = v567 + 8;
    if (v559 == v561)
    {
      a1[1] = v567;
      a1[2] = v560;
      a1[3] = v568;
    }
    else
    {
      v569 = v559 - v561 - 8;
      if (v569 < 0x78
        || &v559[-(v569 & 0xFFFFFFFFFFFFFFF8) - 8] < v567
        && &v566[v559 - v561 - (v569 & 0xFFFFFFFFFFFFFFF8) - 8] < v559)
      {
        goto LABEL_919;
      }
      v570 = (v569 >> 3) + 1;
      v571 = 8 * (v570 & 0x3FFFFFFFFFFFFFFCLL);
      v572 = &v559[-v571];
      v567 -= v571;
      v573 = &v566[8 * v562 - 16];
      v574 = v559 - 16;
      v575 = v570 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v577 = *((_OWORD *)v574 - 1);
        v576 = *(_OWORD *)v574;
        *((_OWORD *)v574 - 1) = 0uLL;
        *(_OWORD *)v574 = 0uLL;
        *((_OWORD *)v573 - 1) = v577;
        *(_OWORD *)v573 = v576;
        v573 -= 32;
        v574 -= 32;
        v575 -= 4;
      }
      while (v575);
      v559 = v572;
      if (v570 != (v570 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_919:
        do
        {
          v578 = *((_QWORD *)v559 - 1);
          v559 -= 8;
          *(_QWORD *)v559 = 0;
          *((_QWORD *)v567 - 1) = v578;
          v567 -= 8;
        }
        while (v559 != v561);
      }
      v559 = (char *)a1[1];
      v579 = (char *)a1[2];
      a1[1] = v567;
      a1[2] = v560;
      a1[3] = v568;
      while (v579 != v559)
      {
        v581 = *((_QWORD *)v579 - 1);
        v579 -= 8;
        v580 = v581;
        *(_QWORD *)v579 = 0;
        if (v581)
          (*(void (**)(uint64_t))(*(_QWORD *)v580 + 8))(v580);
      }
    }
    if (v559)
      operator delete(v559);
  }
  else
  {
    *(_QWORD *)v559 = v548;
    v560 = v559 + 8;
  }
  a1[2] = v560;
  v582 = operator new(0x60uLL);
  v583 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v582 + 1), (uint64_t)"mpsx.quantized_matmul", 21, (__int16)v787, v583, 0, 0);
  *v582 = off_1E0E4B318;
  if (!v582[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeQuantizedMatmulTranpose]";
    v788 = 119;
    v584 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v584)
      v585 = v584;
    else
      v585 = v788;
    v586 = &v787[v585];
    v587 = v788 - v585;
    if (v788 - v585 >= 0x12)
      v588 = 18;
    else
      v588 = v788 - v585;
    v589 = &v586[v588];
    v590 = v587 - v588;
    if (v590 >= v590 - 1)
      --v590;
    v582[8] = v589;
    v582[9] = v590;
  }
  v591 = *((unsigned int *)v582 + 22);
  if (v591 > *((_DWORD *)v582 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v582 + 10), v582 + 12, v591, 16);
    LODWORD(v591) = *((_DWORD *)v582 + 22);
  }
  *((_DWORD *)v582 + 22) = v591;
  v593 = (char *)a1[2];
  v592 = a1[3];
  if ((unint64_t)v593 >= v592)
  {
    v595 = (char *)a1[1];
    v596 = (v593 - v595) >> 3;
    v597 = v596 + 1;
    if ((unint64_t)(v596 + 1) >> 61)
      goto LABEL_899;
    v598 = v592 - (_QWORD)v595;
    if (v598 >> 2 > v597)
      v597 = v598 >> 2;
    if ((unint64_t)v598 >= 0x7FFFFFFFFFFFFFF8)
      v599 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v599 = v597;
    if (v599)
    {
      if (v599 >> 61)
        goto LABEL_900;
      v600 = (char *)operator new(8 * v599);
    }
    else
    {
      v600 = 0;
    }
    v601 = &v600[8 * v596];
    v602 = &v600[8 * v599];
    *(_QWORD *)v601 = v582;
    v594 = v601 + 8;
    if (v593 == v595)
    {
      a1[1] = v601;
      a1[2] = v594;
      a1[3] = v602;
    }
    else
    {
      v603 = v593 - v595 - 8;
      if (v603 < 0x78
        || &v593[-(v603 & 0xFFFFFFFFFFFFFFF8) - 8] < v601
        && &v600[v593 - v595 - (v603 & 0xFFFFFFFFFFFFFFF8) - 8] < v593)
      {
        goto LABEL_920;
      }
      v604 = (v603 >> 3) + 1;
      v605 = 8 * (v604 & 0x3FFFFFFFFFFFFFFCLL);
      v606 = &v593[-v605];
      v601 -= v605;
      v607 = &v600[8 * v596 - 16];
      v608 = v593 - 16;
      v609 = v604 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v611 = *((_OWORD *)v608 - 1);
        v610 = *(_OWORD *)v608;
        *((_OWORD *)v608 - 1) = 0uLL;
        *(_OWORD *)v608 = 0uLL;
        *((_OWORD *)v607 - 1) = v611;
        *(_OWORD *)v607 = v610;
        v607 -= 32;
        v608 -= 32;
        v609 -= 4;
      }
      while (v609);
      v593 = v606;
      if (v604 != (v604 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_920:
        do
        {
          v612 = *((_QWORD *)v593 - 1);
          v593 -= 8;
          *(_QWORD *)v593 = 0;
          *((_QWORD *)v601 - 1) = v612;
          v601 -= 8;
        }
        while (v593 != v595);
      }
      v593 = (char *)a1[1];
      v613 = (char *)a1[2];
      a1[1] = v601;
      a1[2] = v594;
      a1[3] = v602;
      while (v613 != v593)
      {
        v615 = *((_QWORD *)v613 - 1);
        v613 -= 8;
        v614 = v615;
        *(_QWORD *)v613 = 0;
        if (v615)
          (*(void (**)(uint64_t))(*(_QWORD *)v614 + 8))(v614);
      }
    }
    if (v593)
      operator delete(v593);
  }
  else
  {
    *(_QWORD *)v593 = v582;
    v594 = v593 + 8;
  }
  a1[2] = v594;
  v616 = operator new(0x60uLL);
  v617 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v616 + 1), (uint64_t)"mps.multiply", 12, (__int16)v787, v617, 0, 0);
  *v616 = &off_1E0E4B670;
  if (!v616[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::FuseRMS<mlir::mps::MultiplyOp>]";
    v788 = 114;
    v618 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v618)
      v619 = v618;
    else
      v619 = v788;
    v620 = &v787[v619];
    v621 = v788 - v619;
    if (v788 - v619 >= 0x12)
      v622 = 18;
    else
      v622 = v788 - v619;
    v623 = &v620[v622];
    v624 = v621 - v622;
    if (v624 >= v624 - 1)
      --v624;
    v616[8] = v623;
    v616[9] = v624;
  }
  v625 = *((unsigned int *)v616 + 22);
  if (v625 > *((_DWORD *)v616 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v616 + 10), v616 + 12, v625, 16);
    LODWORD(v625) = *((_DWORD *)v616 + 22);
  }
  *((_DWORD *)v616 + 22) = v625;
  v627 = (char *)a1[2];
  v626 = a1[3];
  if ((unint64_t)v627 >= v626)
  {
    v629 = (char *)a1[1];
    v630 = (v627 - v629) >> 3;
    v631 = v630 + 1;
    if ((unint64_t)(v630 + 1) >> 61)
      goto LABEL_899;
    v632 = v626 - (_QWORD)v629;
    if (v632 >> 2 > v631)
      v631 = v632 >> 2;
    if ((unint64_t)v632 >= 0x7FFFFFFFFFFFFFF8)
      v633 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v633 = v631;
    if (v633)
    {
      if (v633 >> 61)
        goto LABEL_900;
      v634 = (char *)operator new(8 * v633);
    }
    else
    {
      v634 = 0;
    }
    v635 = &v634[8 * v630];
    v636 = &v634[8 * v633];
    *(_QWORD *)v635 = v616;
    v628 = v635 + 8;
    if (v627 == v629)
    {
      a1[1] = v635;
      a1[2] = v628;
      a1[3] = v636;
    }
    else
    {
      v637 = v627 - v629 - 8;
      if (v637 < 0x78
        || &v627[-(v637 & 0xFFFFFFFFFFFFFFF8) - 8] < v635
        && &v634[v627 - v629 - (v637 & 0xFFFFFFFFFFFFFFF8) - 8] < v627)
      {
        goto LABEL_921;
      }
      v638 = (v637 >> 3) + 1;
      v639 = 8 * (v638 & 0x3FFFFFFFFFFFFFFCLL);
      v640 = &v627[-v639];
      v635 -= v639;
      v641 = &v634[8 * v630 - 16];
      v642 = v627 - 16;
      v643 = v638 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v645 = *((_OWORD *)v642 - 1);
        v644 = *(_OWORD *)v642;
        *((_OWORD *)v642 - 1) = 0uLL;
        *(_OWORD *)v642 = 0uLL;
        *((_OWORD *)v641 - 1) = v645;
        *(_OWORD *)v641 = v644;
        v641 -= 32;
        v642 -= 32;
        v643 -= 4;
      }
      while (v643);
      v627 = v640;
      if (v638 != (v638 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_921:
        do
        {
          v646 = *((_QWORD *)v627 - 1);
          v627 -= 8;
          *(_QWORD *)v627 = 0;
          *((_QWORD *)v635 - 1) = v646;
          v635 -= 8;
        }
        while (v627 != v629);
      }
      v627 = (char *)a1[1];
      v647 = (char *)a1[2];
      a1[1] = v635;
      a1[2] = v628;
      a1[3] = v636;
      while (v647 != v627)
      {
        v649 = *((_QWORD *)v647 - 1);
        v647 -= 8;
        v648 = v649;
        *(_QWORD *)v647 = 0;
        if (v649)
          (*(void (**)(uint64_t))(*(_QWORD *)v648 + 8))(v648);
      }
    }
    if (v627)
      operator delete(v627);
  }
  else
  {
    *(_QWORD *)v627 = v616;
    v628 = v627 + 8;
  }
  a1[2] = v628;
  v650 = operator new(0x60uLL);
  v651 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v650 + 1), (uint64_t)"mps.divide", 10, (__int16)v787, v651, 0, 0);
  *v650 = &off_1E0E4B6C8;
  if (!v650[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::FuseRMS<mlir::mps::DivideOp>]";
    v788 = 112;
    v652 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v652)
      v653 = v652;
    else
      v653 = v788;
    v654 = &v787[v653];
    v655 = v788 - v653;
    if (v788 - v653 >= 0x12)
      v656 = 18;
    else
      v656 = v788 - v653;
    v657 = &v654[v656];
    v658 = v655 - v656;
    if (v658 >= v658 - 1)
      --v658;
    v650[8] = v657;
    v650[9] = v658;
  }
  v659 = *((unsigned int *)v650 + 22);
  if (v659 > *((_DWORD *)v650 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v650 + 10), v650 + 12, v659, 16);
    LODWORD(v659) = *((_DWORD *)v650 + 22);
  }
  *((_DWORD *)v650 + 22) = v659;
  v661 = (char *)a1[2];
  v660 = a1[3];
  if ((unint64_t)v661 >= v660)
  {
    v663 = (char *)a1[1];
    v664 = (v661 - v663) >> 3;
    v665 = v664 + 1;
    if ((unint64_t)(v664 + 1) >> 61)
      goto LABEL_899;
    v666 = v660 - (_QWORD)v663;
    if (v666 >> 2 > v665)
      v665 = v666 >> 2;
    if ((unint64_t)v666 >= 0x7FFFFFFFFFFFFFF8)
      v667 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v667 = v665;
    if (v667)
    {
      if (v667 >> 61)
        goto LABEL_900;
      v668 = (char *)operator new(8 * v667);
    }
    else
    {
      v668 = 0;
    }
    v669 = &v668[8 * v664];
    v670 = &v668[8 * v667];
    *(_QWORD *)v669 = v650;
    v662 = v669 + 8;
    if (v661 == v663)
    {
      a1[1] = v669;
      a1[2] = v662;
      a1[3] = v670;
    }
    else
    {
      v671 = v661 - v663 - 8;
      if (v671 < 0x78
        || &v661[-(v671 & 0xFFFFFFFFFFFFFFF8) - 8] < v669
        && &v668[v661 - v663 - (v671 & 0xFFFFFFFFFFFFFFF8) - 8] < v661)
      {
        goto LABEL_922;
      }
      v672 = (v671 >> 3) + 1;
      v673 = 8 * (v672 & 0x3FFFFFFFFFFFFFFCLL);
      v674 = &v661[-v673];
      v669 -= v673;
      v675 = &v668[8 * v664 - 16];
      v676 = v661 - 16;
      v677 = v672 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v679 = *((_OWORD *)v676 - 1);
        v678 = *(_OWORD *)v676;
        *((_OWORD *)v676 - 1) = 0uLL;
        *(_OWORD *)v676 = 0uLL;
        *((_OWORD *)v675 - 1) = v679;
        *(_OWORD *)v675 = v678;
        v675 -= 32;
        v676 -= 32;
        v677 -= 4;
      }
      while (v677);
      v661 = v674;
      if (v672 != (v672 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_922:
        do
        {
          v680 = *((_QWORD *)v661 - 1);
          v661 -= 8;
          *(_QWORD *)v661 = 0;
          *((_QWORD *)v669 - 1) = v680;
          v669 -= 8;
        }
        while (v661 != v663);
      }
      v661 = (char *)a1[1];
      v681 = (char *)a1[2];
      a1[1] = v669;
      a1[2] = v662;
      a1[3] = v670;
      while (v681 != v661)
      {
        v683 = *((_QWORD *)v681 - 1);
        v681 -= 8;
        v682 = v683;
        *(_QWORD *)v681 = 0;
        if (v683)
          (*(void (**)(uint64_t))(*(_QWORD *)v682 + 8))(v682);
      }
    }
    if (v661)
      operator delete(v661);
  }
  else
  {
    *(_QWORD *)v661 = v650;
    v662 = v661 + 8;
  }
  a1[2] = v662;
  v684 = operator new(0x60uLL);
  v685 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v684 + 1), (uint64_t)"mps.add", 7, (__int16)v787, v685, 0, 0);
  *v684 = off_1E0E04EF0;
  if (!v684[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeRoPE]";
    v788 = 100;
    v686 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v686)
      v687 = v686;
    else
      v687 = v788;
    v688 = &v787[v687];
    v689 = v788 - v687;
    if (v788 - v687 >= 0x12)
      v690 = 18;
    else
      v690 = v788 - v687;
    v691 = &v688[v690];
    v692 = v689 - v690;
    if (v692 >= v692 - 1)
      --v692;
    v684[8] = v691;
    v684[9] = v692;
  }
  v693 = *((unsigned int *)v684 + 22);
  if (v693 > *((_DWORD *)v684 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v684 + 10), v684 + 12, v693, 16);
    LODWORD(v693) = *((_DWORD *)v684 + 22);
  }
  *((_DWORD *)v684 + 22) = v693;
  v695 = (char *)a1[2];
  v694 = a1[3];
  if ((unint64_t)v695 >= v694)
  {
    v697 = (char *)a1[1];
    v698 = (v695 - v697) >> 3;
    v699 = v698 + 1;
    if ((unint64_t)(v698 + 1) >> 61)
      goto LABEL_899;
    v700 = v694 - (_QWORD)v697;
    if (v700 >> 2 > v699)
      v699 = v700 >> 2;
    if ((unint64_t)v700 >= 0x7FFFFFFFFFFFFFF8)
      v701 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v701 = v699;
    if (v701)
    {
      if (v701 >> 61)
        goto LABEL_900;
      v702 = (char *)operator new(8 * v701);
    }
    else
    {
      v702 = 0;
    }
    v703 = &v702[8 * v698];
    v704 = &v702[8 * v701];
    *(_QWORD *)v703 = v684;
    v696 = v703 + 8;
    if (v695 == v697)
    {
      a1[1] = v703;
      a1[2] = v696;
      a1[3] = v704;
    }
    else
    {
      v705 = v695 - v697 - 8;
      if (v705 < 0x78
        || &v695[-(v705 & 0xFFFFFFFFFFFFFFF8) - 8] < v703
        && &v702[v695 - v697 - (v705 & 0xFFFFFFFFFFFFFFF8) - 8] < v695)
      {
        goto LABEL_923;
      }
      v706 = (v705 >> 3) + 1;
      v707 = 8 * (v706 & 0x3FFFFFFFFFFFFFFCLL);
      v708 = &v695[-v707];
      v703 -= v707;
      v709 = &v702[8 * v698 - 16];
      v710 = v695 - 16;
      v711 = v706 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v713 = *((_OWORD *)v710 - 1);
        v712 = *(_OWORD *)v710;
        *((_OWORD *)v710 - 1) = 0uLL;
        *(_OWORD *)v710 = 0uLL;
        *((_OWORD *)v709 - 1) = v713;
        *(_OWORD *)v709 = v712;
        v709 -= 32;
        v710 -= 32;
        v711 -= 4;
      }
      while (v711);
      v695 = v708;
      if (v706 != (v706 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_923:
        do
        {
          v714 = *((_QWORD *)v695 - 1);
          v695 -= 8;
          *(_QWORD *)v695 = 0;
          *((_QWORD *)v703 - 1) = v714;
          v703 -= 8;
        }
        while (v695 != v697);
      }
      v695 = (char *)a1[1];
      v715 = (char *)a1[2];
      a1[1] = v703;
      a1[2] = v696;
      a1[3] = v704;
      while (v715 != v695)
      {
        v717 = *((_QWORD *)v715 - 1);
        v715 -= 8;
        v716 = v717;
        *(_QWORD *)v715 = 0;
        if (v717)
          (*(void (**)(uint64_t))(*(_QWORD *)v716 + 8))(v716);
      }
    }
    if (v695)
      operator delete(v695);
  }
  else
  {
    *(_QWORD *)v695 = v684;
    v696 = v695 + 8;
  }
  a1[2] = v696;
  v718 = operator new(0x60uLL);
  v719 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v718 + 1), (uint64_t)"mps.read_variable", 17, (__int16)v787, v719, 0, 0);
  *v718 = off_1E0DFB348;
  if (!v718[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeReadVariable]";
    v788 = 108;
    v720 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v720)
      v721 = v720;
    else
      v721 = v788;
    v722 = &v787[v721];
    v723 = v788 - v721;
    if (v788 - v721 >= 0x12)
      v724 = 18;
    else
      v724 = v788 - v721;
    v725 = &v722[v724];
    v726 = v723 - v724;
    if (v726 >= v726 - 1)
      --v726;
    v718[8] = v725;
    v718[9] = v726;
  }
  v727 = *((unsigned int *)v718 + 22);
  if (v727 > *((_DWORD *)v718 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v718 + 10), v718 + 12, v727, 16);
    LODWORD(v727) = *((_DWORD *)v718 + 22);
  }
  *((_DWORD *)v718 + 22) = v727;
  v729 = (char *)a1[2];
  v728 = a1[3];
  if ((unint64_t)v729 >= v728)
  {
    v731 = (char *)a1[1];
    v732 = (v729 - v731) >> 3;
    v733 = v732 + 1;
    if ((unint64_t)(v732 + 1) >> 61)
      goto LABEL_899;
    v734 = v728 - (_QWORD)v731;
    if (v734 >> 2 > v733)
      v733 = v734 >> 2;
    if ((unint64_t)v734 >= 0x7FFFFFFFFFFFFFF8)
      v735 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v735 = v733;
    if (v735)
    {
      if (v735 >> 61)
        goto LABEL_900;
      v736 = (char *)operator new(8 * v735);
    }
    else
    {
      v736 = 0;
    }
    v737 = &v736[8 * v732];
    v738 = &v736[8 * v735];
    *(_QWORD *)v737 = v718;
    v730 = v737 + 8;
    if (v729 == v731)
    {
      a1[1] = v737;
      a1[2] = v730;
      a1[3] = v738;
    }
    else
    {
      v739 = v729 - v731 - 8;
      if (v739 < 0x78
        || &v729[-(v739 & 0xFFFFFFFFFFFFFFF8) - 8] < v737
        && &v736[v729 - v731 - (v739 & 0xFFFFFFFFFFFFFFF8) - 8] < v729)
      {
        goto LABEL_924;
      }
      v740 = (v739 >> 3) + 1;
      v741 = 8 * (v740 & 0x3FFFFFFFFFFFFFFCLL);
      v742 = &v729[-v741];
      v737 -= v741;
      v743 = &v736[8 * v732 - 16];
      v744 = v729 - 16;
      v745 = v740 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v747 = *((_OWORD *)v744 - 1);
        v746 = *(_OWORD *)v744;
        *((_OWORD *)v744 - 1) = 0uLL;
        *(_OWORD *)v744 = 0uLL;
        *((_OWORD *)v743 - 1) = v747;
        *(_OWORD *)v743 = v746;
        v743 -= 32;
        v744 -= 32;
        v745 -= 4;
      }
      while (v745);
      v729 = v742;
      if (v740 != (v740 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_924:
        do
        {
          v748 = *((_QWORD *)v729 - 1);
          v729 -= 8;
          *(_QWORD *)v729 = 0;
          *((_QWORD *)v737 - 1) = v748;
          v737 -= 8;
        }
        while (v729 != v731);
      }
      v729 = (char *)a1[1];
      v749 = (char *)a1[2];
      a1[1] = v737;
      a1[2] = v730;
      a1[3] = v738;
      while (v749 != v729)
      {
        v751 = *((_QWORD *)v749 - 1);
        v749 -= 8;
        v750 = v751;
        *(_QWORD *)v749 = 0;
        if (v751)
          (*(void (**)(uint64_t))(*(_QWORD *)v750 + 8))(v750);
      }
    }
    if (v729)
      operator delete(v729);
  }
  else
  {
    *(_QWORD *)v729 = v718;
    v730 = v729 + 8;
  }
  a1[2] = v730;
  v752 = operator new(0x60uLL);
  v753 = *a2;
  mlir::PatternBenefit::PatternBenefit(&v787, 1);
  mlir::Pattern::Pattern((uint64_t)(v752 + 1), (uint64_t)"mps.strided_slice", 17, (__int16)v787, v753, 0, 0);
  *v752 = off_1E0DFB450;
  if (!v752[9])
  {
    v787 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::(anonymous namespace)::CanonicalizeStridedSliceToGather]";
    v788 = 116;
    v754 = llvm::StringRef::find((uint64_t *)&v787, "DesiredTypeName = ", 0x12uLL, 0);
    if (v788 >= v754)
      v755 = v754;
    else
      v755 = v788;
    v756 = &v787[v755];
    v757 = v788 - v755;
    if (v788 - v755 >= 0x12)
      v758 = 18;
    else
      v758 = v788 - v755;
    v759 = &v756[v758];
    v760 = v757 - v758;
    if (v760 >= v760 - 1)
      --v760;
    v752[8] = v759;
    v752[9] = v760;
  }
  v761 = *((unsigned int *)v752 + 22);
  if (v761 > *((_DWORD *)v752 + 23))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v752 + 10), v752 + 12, v761, 16);
    LODWORD(v761) = *((_DWORD *)v752 + 22);
  }
  *((_DWORD *)v752 + 22) = v761;
  v763 = (char *)a1[2];
  v762 = a1[3];
  if ((unint64_t)v763 < v762)
  {
    *(_QWORD *)v763 = v752;
    v764 = v763 + 8;
    goto LABEL_898;
  }
  v765 = (char *)a1[1];
  v766 = (v763 - v765) >> 3;
  v767 = v766 + 1;
  if ((unint64_t)(v766 + 1) >> 61)
LABEL_899:
    abort();
  v768 = v762 - (_QWORD)v765;
  if (v768 >> 2 > v767)
    v767 = v768 >> 2;
  if ((unint64_t)v768 >= 0x7FFFFFFFFFFFFFF8)
    v769 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v769 = v767;
  if (!v769)
  {
    v770 = 0;
    goto LABEL_883;
  }
  if (v769 >> 61)
LABEL_900:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v770 = (char *)operator new(8 * v769);
LABEL_883:
  v771 = &v770[8 * v766];
  v772 = &v770[8 * v769];
  *(_QWORD *)v771 = v752;
  v764 = v771 + 8;
  if (v763 == v765)
  {
    a1[1] = v771;
    a1[2] = v764;
    a1[3] = v772;
  }
  else
  {
    v773 = v763 - v765 - 8;
    if (v773 < 0x78
      || &v763[-(v773 & 0xFFFFFFFFFFFFFFF8) - 8] < v771
      && &v770[v763 - v765 - (v773 & 0xFFFFFFFFFFFFFFF8) - 8] < v763)
    {
      goto LABEL_925;
    }
    v774 = (v773 >> 3) + 1;
    v775 = 8 * (v774 & 0x3FFFFFFFFFFFFFFCLL);
    v776 = &v763[-v775];
    v771 -= v775;
    v777 = &v770[8 * v766 - 16];
    v778 = v763 - 16;
    v779 = v774 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v781 = *((_OWORD *)v778 - 1);
      v780 = *(_OWORD *)v778;
      *((_OWORD *)v778 - 1) = 0uLL;
      *(_OWORD *)v778 = 0uLL;
      *((_OWORD *)v777 - 1) = v781;
      *(_OWORD *)v777 = v780;
      v777 -= 32;
      v778 -= 32;
      v779 -= 4;
    }
    while (v779);
    v763 = v776;
    if (v774 != (v774 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_925:
      do
      {
        v782 = *((_QWORD *)v763 - 1);
        v763 -= 8;
        *(_QWORD *)v763 = 0;
        *((_QWORD *)v771 - 1) = v782;
        v771 -= 8;
      }
      while (v763 != v765);
    }
    v763 = (char *)a1[1];
    v783 = (char *)a1[2];
    a1[1] = v771;
    a1[2] = v764;
    a1[3] = v772;
    while (v783 != v763)
    {
      v785 = *((_QWORD *)v783 - 1);
      v783 -= 8;
      v784 = v785;
      *(_QWORD *)v783 = 0;
      if (v785)
        (*(void (**)(uint64_t))(*(_QWORD *)v784 + 8))(v784);
    }
  }
  if (v763)
    operator delete(v763);
LABEL_898:
  a1[2] = v764;
  return a1;
}

void mlir::mps::`anonymous namespace'::MPS_ComplexGEMM_CC::~MPS_ComplexGEMM_CC(mlir::mps::_anonymous_namespace_::MPS_ComplexGEMM_CC *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::MPS_ComplexGEMM_CC::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_ComplexGEMM_CC *this, mlir::Operation *a2, mlir::BoolAttr **a3)
{
  mlir::Operation *v5;
  uint64_t ODSOperands;
  uint64_t v7;
  uint64_t InherentAttr;
  char v9;
  _QWORD *BoolAttr;
  uint64_t v11;
  char v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(int, uint64_t);
  uint64_t v17;
  mlir::Operation *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  uint64_t v24;
  _QWORD v25[6];

  v25[4] = *MEMORY[0x1E0C80C00];
  v20 = 0;
  v21 = 0;
  v23 = v25;
  v25[0] = a2;
  v24 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v19 = v5;
  ODSOperands = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v19, 0);
  v7 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v19, 1u);
  if (*((_BYTE *)a2 + 47)
    && (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"transpose_lhs", 13), v9))
  {
    BoolAttr = (_QWORD *)InherentAttr;
    if (!InherentAttr)
      goto LABEL_10;
  }
  else
  {
    BoolAttr = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)a2 + 56, "transpose_lhs", 0xDuLL);
    if (!BoolAttr)
    {
LABEL_10:
      BoolAttr = (_QWORD *)mlir::Builder::getBoolAttr(a3 + 1, 0);
      goto LABEL_11;
    }
  }
  if (!mlir::BoolAttr::classof(BoolAttr))
    goto LABEL_10;
LABEL_11:
  v20 = BoolAttr;
  if (*((_BYTE *)a2 + 47))
  {
    v11 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"transpose_rhs", 13);
    if (v12)
    {
      v13 = (_QWORD *)v11;
      if (!v11)
        goto LABEL_17;
LABEL_16:
      if (mlir::BoolAttr::classof(v13))
        goto LABEL_18;
      goto LABEL_17;
    }
  }
  v13 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)a2 + 56, "transpose_rhs", 0xDuLL);
  if (v13)
    goto LABEL_16;
LABEL_17:
  v13 = (_QWORD *)mlir::Builder::getBoolAttr(a3 + 1, 0);
LABEL_18:
  v21 = v13;
  if (*(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
                    + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
                      + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      v22 = *(void **)(*v23 + 24);
      mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v22, (mlir::MLIRContext *)1, 0);
    }
    v14 = (uint64_t)a3[2];
    if (v14 && mlir::RewriterBase::Listener::classof(v14))
    {
      v15 = *((_QWORD *)a2 + 3);
      goto LABEL_26;
    }
  }
  else
  {
    v14 = (uint64_t)a3[2];
    if (v14 && mlir::RewriterBase::Listener::classof(v14))
    {
      v15 = *((_QWORD *)a2 + 3);
LABEL_26:
      v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v14 + 64))(v14, v15, v16, &v22);
      goto LABEL_28;
    }
  }
  v17 = 0;
LABEL_28:
  if (v23 != v25)
    free(v23);
  return v17;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::RealPartOp,mlir::Value &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.real_part", (const unsigned __int8 *)0xD, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.real_part";
    v15[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::RealPartOp::build(a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::RealPartOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::MatMulOp,mlir::Value &,mlir::Value &,mlir::BoolAttr &,mlir::BoolAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.matmul", (const unsigned __int8 *)0xA, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.matmul";
    v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::MatMulOp::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ImaginaryPartOp,mlir::Value &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.imaginary_part", (const unsigned __int8 *)0x12, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.imaginary_part";
    v15[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ImaginaryPartOp::build(a1, (uint64_t)v17, *a3);
  v9 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ImaginaryPartOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::CreateComplexOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.create_complex", (const unsigned __int8 *)0x12, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.create_complex";
    v19[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::CreateComplexOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_ComplexGEMM_CC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'lhs_c' failed to satisfy constraint: 'is complex type'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_ComplexGEMM_CC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'rhs_c' failed to satisfy constraint: 'is complex type'");
}

void mlir::mps::`anonymous namespace'::MPS_ComplexGEMM_CR::~MPS_ComplexGEMM_CR(mlir::mps::_anonymous_namespace_::MPS_ComplexGEMM_CR *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::MPS_ComplexGEMM_CR::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_ComplexGEMM_CR *this, mlir::Operation *a2, mlir::BoolAttr **a3)
{
  mlir::Operation *v5;
  uint64_t ODSOperands;
  uint64_t v7;
  uint64_t InherentAttr;
  char v9;
  _QWORD *BoolAttr;
  uint64_t v11;
  char v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(int, uint64_t);
  uint64_t v17;
  mlir::Operation *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  uint64_t v24;
  _QWORD v25[6];

  v25[4] = *MEMORY[0x1E0C80C00];
  v20 = 0;
  v21 = 0;
  v23 = v25;
  v25[0] = a2;
  v24 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v19 = v5;
  ODSOperands = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v19, 0);
  v7 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v19, 1u);
  if (*((_BYTE *)a2 + 47)
    && (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"transpose_lhs", 13), v9))
  {
    BoolAttr = (_QWORD *)InherentAttr;
    if (!InherentAttr)
      goto LABEL_10;
  }
  else
  {
    BoolAttr = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)a2 + 56, "transpose_lhs", 0xDuLL);
    if (!BoolAttr)
    {
LABEL_10:
      BoolAttr = (_QWORD *)mlir::Builder::getBoolAttr(a3 + 1, 0);
      goto LABEL_11;
    }
  }
  if (!mlir::BoolAttr::classof(BoolAttr))
    goto LABEL_10;
LABEL_11:
  v20 = BoolAttr;
  if (*((_BYTE *)a2 + 47))
  {
    v11 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"transpose_rhs", 13);
    if (v12)
    {
      v13 = (_QWORD *)v11;
      if (!v11)
        goto LABEL_17;
LABEL_16:
      if (mlir::BoolAttr::classof(v13))
        goto LABEL_18;
      goto LABEL_17;
    }
  }
  v13 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)a2 + 56, "transpose_rhs", 0xDuLL);
  if (v13)
    goto LABEL_16;
LABEL_17:
  v13 = (_QWORD *)mlir::Builder::getBoolAttr(a3 + 1, 0);
LABEL_18:
  v21 = v13;
  if (*(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
                    + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
                      + 136) != &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      v22 = *(void **)(*v23 + 24);
      mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v22, (mlir::MLIRContext *)1, 0);
    }
    v14 = (uint64_t)a3[2];
    if (v14 && mlir::RewriterBase::Listener::classof(v14))
    {
      v15 = *((_QWORD *)a2 + 3);
      goto LABEL_22;
    }
  }
  else
  {
    v14 = (uint64_t)a3[2];
    if (v14 && mlir::RewriterBase::Listener::classof(v14))
    {
      v15 = *((_QWORD *)a2 + 3);
LABEL_22:
      v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v14 + 64))(v14, v15, v16, &v22);
      goto LABEL_29;
    }
  }
  v17 = 0;
LABEL_29:
  if (v23 != v25)
    free(v23);
  return v17;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_ComplexGEMM_CR::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'lhs_c' failed to satisfy constraint: 'is complex type'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_ComplexGEMM_CR::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'rhs_r' failed to satisfy constraint: 'is not complex type'");
}

void mlir::mps::`anonymous namespace'::MPS_ComplexGEMM_RC::~MPS_ComplexGEMM_RC(mlir::mps::_anonymous_namespace_::MPS_ComplexGEMM_RC *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::MPS_ComplexGEMM_RC::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_ComplexGEMM_RC *this, mlir::Operation *a2, mlir::BoolAttr **a3)
{
  mlir::Operation *v5;
  uint64_t ODSOperands;
  uint64_t v7;
  uint64_t InherentAttr;
  char v9;
  _QWORD *BoolAttr;
  uint64_t v11;
  char v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(int, uint64_t);
  uint64_t v17;
  mlir::Operation *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  uint64_t v24;
  _QWORD v25[6];

  v25[4] = *MEMORY[0x1E0C80C00];
  v20 = 0;
  v21 = 0;
  v23 = v25;
  v25[0] = a2;
  v24 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v19 = v5;
  ODSOperands = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v19, 0);
  v7 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v19, 1u);
  if (*((_BYTE *)a2 + 47)
    && (InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"transpose_lhs", 13), v9))
  {
    BoolAttr = (_QWORD *)InherentAttr;
    if (!InherentAttr)
      goto LABEL_10;
  }
  else
  {
    BoolAttr = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)a2 + 56, "transpose_lhs", 0xDuLL);
    if (!BoolAttr)
    {
LABEL_10:
      BoolAttr = (_QWORD *)mlir::Builder::getBoolAttr(a3 + 1, 0);
      goto LABEL_11;
    }
  }
  if (!mlir::BoolAttr::classof(BoolAttr))
    goto LABEL_10;
LABEL_11:
  v21 = BoolAttr;
  if (*((_BYTE *)a2 + 47))
  {
    v11 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"transpose_rhs", 13);
    if (v12)
    {
      v13 = (_QWORD *)v11;
      if (!v11)
        goto LABEL_17;
LABEL_16:
      if (mlir::BoolAttr::classof(v13))
        goto LABEL_18;
      goto LABEL_17;
    }
  }
  v13 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)a2 + 56, "transpose_rhs", 0xDuLL);
  if (v13)
    goto LABEL_16;
LABEL_17:
  v13 = (_QWORD *)mlir::Builder::getBoolAttr(a3 + 1, 0);
LABEL_18:
  v20 = v13;
  if (*(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
                    + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
  {
    v14 = (uint64_t)a3[2];
    if (v14 && mlir::RewriterBase::Listener::classof(v14))
    {
      v15 = *((_QWORD *)a2 + 3);
      goto LABEL_26;
    }
  }
  else
  {
    if (*(_UNKNOWN **)(*(_QWORD *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
                      + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      v22 = *(void **)(*v23 + 24);
      mlir::Builder::getFusedLoc(a3 + 1, (uint64_t **)&v22, (mlir::MLIRContext *)1, 0);
    }
    v14 = (uint64_t)a3[2];
    if (v14 && mlir::RewriterBase::Listener::classof(v14))
    {
      v15 = *((_QWORD *)a2 + 3);
LABEL_26:
      v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v14 + 64))(v14, v15, v16, &v22);
      goto LABEL_29;
    }
  }
  v17 = 0;
LABEL_29:
  if (v23 != v25)
    free(v23);
  return v17;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_ComplexGEMM_RC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'lhs_r' failed to satisfy constraint: 'is not complex type'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_ComplexGEMM_RC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'rhs_c' failed to satisfy constraint: 'is complex type'");
}

void mlir::mps::`anonymous namespace'::MPS_DivideOfPower::~MPS_DivideOfPower(mlir::mps::_anonymous_namespace_::MPS_DivideOfPower *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::MPS_DivideOfPower::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_DivideOfPower *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  mlir::Operation *v4;
  uint64_t DefiningOp;
  uint64_t v6;
  void *v7;
  BOOL v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  mlir::Operation *v12;
  int v13;
  void *v14;
  mlir::Operation *v16;
  void *v17[10];
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD v21[6];

  v21[4] = *MEMORY[0x1E0C80C00];
  v19 = v21;
  v21[0] = a2;
  v20 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v16 = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v16, 0);
  v17[0] = *(void **)(mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v16, 1u) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v17);
  if (!DefiningOp)
  {
    v10 = *((_QWORD *)a3 + 2);
    if (!v10)
      goto LABEL_20;
    v12 = v16;
    if (mlir::RewriterBase::Listener::classof(v10))
    {
      goto LABEL_15;
    }
    goto LABEL_16;
  }
  v6 = DefiningOp;
  v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
  v8 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::PowerOp,void>::id;
  if (v7 == &mlir::detail::TypeIDResolver<mlir::mps::PowerOp,void>::id)
    v9 = (void *)DefiningOp;
  else
    v9 = 0;
  v17[0] = v9;
  if (v8)
  {
    mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v17, 0);
    mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v17, 1u);
    v13 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 8);
      v13 = v20;
    }
    v19[v13] = v6;
    LODWORD(v20) = v20 + 1;
    v14 = *(void **)(v19[1] + 24);
    v17[0] = *(void **)(*v19 + 24);
    v17[1] = v14;
    mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v17, (mlir::MLIRContext *)2, 0);
  }
  v10 = *((_QWORD *)a3 + 2);
  if (v10)
  {
    if (mlir::RewriterBase::Listener::classof(v10))
    {
LABEL_15:
      v10 = v11;
      goto LABEL_20;
    }
LABEL_16:
    v10 = 0;
  }
LABEL_20:
  if (v19 != v21)
    free(v19);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::NegativeOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.negative", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.negative";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::NegativeOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_DivideOfPower::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 1 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_DivideOfPower::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::mps::PowerOp type");
}

void mlir::mps::`anonymous namespace'::MPS_DivideSqrtToMultiplyRsqrt::~MPS_DivideSqrtToMultiplyRsqrt(mlir::mps::_anonymous_namespace_::MPS_DivideSqrtToMultiplyRsqrt *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::MPS_DivideSqrtToMultiplyRsqrt::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_DivideSqrtToMultiplyRsqrt *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  mlir::Operation *v4;
  uint64_t DefiningOp;
  uint64_t v6;
  void *v7;
  BOOL v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  mlir::Operation *v12;
  int v13;
  void *v14;
  mlir::Operation *v16;
  void *v17[10];
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD v21[6];

  v21[4] = *MEMORY[0x1E0C80C00];
  v19 = v21;
  v21[0] = a2;
  v20 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v16 = v4;
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v16, 0);
  v17[0] = *(void **)(mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v16, 1u) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v17);
  if (!DefiningOp)
  {
    v10 = *((_QWORD *)a3 + 2);
    if (!v10)
      goto LABEL_20;
    v12 = v16;
    if (mlir::RewriterBase::Listener::classof(v10))
    {
      goto LABEL_15;
    }
    goto LABEL_16;
  }
  v6 = DefiningOp;
  v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
  v8 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::SquareRootOp,void>::id;
  if (v7 == &mlir::detail::TypeIDResolver<mlir::mps::SquareRootOp,void>::id)
    v9 = (void *)DefiningOp;
  else
    v9 = 0;
  v17[0] = v9;
  if (v8)
  {
    mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v17, 0);
    v13 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 8);
      v13 = v20;
    }
    v19[v13] = v6;
    LODWORD(v20) = v20 + 1;
    v14 = *(void **)(v19[1] + 24);
    v17[0] = *(void **)(*v19 + 24);
    v17[1] = v14;
    mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v17, (mlir::MLIRContext *)2, 0);
  }
  v10 = *((_QWORD *)a3 + 2);
  if (v10)
  {
    if (mlir::RewriterBase::Listener::classof(v10))
    {
LABEL_15:
      v10 = v11;
      goto LABEL_20;
    }
LABEL_16:
    v10 = 0;
  }
LABEL_20:
  if (v19 != v21)
    free(v19);
  return v10;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_DivideSqrtToMultiplyRsqrt::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 1 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_DivideSqrtToMultiplyRsqrt::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::mps::SquareRootOp type");
}

void mlir::mps::`anonymous namespace'::MPS_NCHW_ConvBias_NHWC::~MPS_NCHW_ConvBias_NHWC(mlir::mps::_anonymous_namespace_::MPS_NCHW_ConvBias_NHWC *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::MPS_NCHW_ConvBias_NHWC::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_NCHW_ConvBias_NHWC *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  mlir::Operation *v8;
  uint64_t DefiningOp;
  uint64_t v10;
  void *v11;
  BOOL v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(int, uint64_t);
  uint64_t (*v17)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **);
  void **v18;
  mlir::Operation *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t InherentAttr;
  char v25;
  int v26;
  uint64_t ODSOperands;
  uint64_t v28;
  uint64_t v29;
  uint64_t (*v30)(int, uint64_t);
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  mlir::Operation *v37;
  uint64_t v38;
  _QWORD v39[2];
  uint64_t v40;
  _QWORD v41[2];
  uint64_t v42;
  uint64_t v43;
  _QWORD v44[2];
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void *v48[2];
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  _QWORD v54[6];

  v54[4] = *MEMORY[0x1E0C80C00];
  v5 = *((_DWORD *)a2 + 11);
  v46 = 0;
  v47 = 0;
  v45 = 0;
  if ((v5 & 0x800000) != 0)
  {
    v6 = *((_QWORD *)a2 + 9);
    v7 = *((unsigned int *)a2 + 17);
    v44[0] = v6;
  }
  else
  {
    v7 = 0;
    v6 = 0;
    v44[0] = 0;
  }
  v44[1] = v7;
  v42 = 0;
  v43 = 0;
  v41[0] = v6;
  v41[1] = v7;
  v39[1] = v7;
  v40 = 0;
  v38 = 0;
  v39[0] = v6;
  v52 = v54;
  v54[0] = a2;
  v53 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id)
    v8 = a2;
  else
    v8 = 0;
  v37 = v8;
  v48[0] = *(void **)(mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v37, 0) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v48);
  if (DefiningOp)
  {
    v10 = DefiningOp;
    v11 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
    v12 = v11 == &mlir::detail::TypeIDResolver<mlir::mps::BiasAddOp,void>::id;
    if (v11 == &mlir::detail::TypeIDResolver<mlir::mps::BiasAddOp,void>::id)
      v13 = (void *)DefiningOp;
    else
      v13 = 0;
    v48[0] = v13;
    if (!v12)
    {
      v14 = *((_QWORD *)a3 + 2);
      if (!v14)
        goto LABEL_50;
      if (mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
      {
        v15 = *(_QWORD *)(v10 + 24);
LABEL_14:
        v17 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v14 + 64);
        v18 = (void **)&v51;
LABEL_18:
        v20 = v17(v14, v15, v16, v18);
LABEL_19:
        v14 = v20;
        goto LABEL_50;
      }
      goto LABEL_49;
    }
    v51 = *(_QWORD *)(mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v48, 0) + 24);
    v21 = mlir::Value::getDefiningOp((mlir::Value *)&v51);
    if (v21)
    {
      v22 = v21;
      {
        v23 = v53;
        if (v53 >= HIDWORD(v53))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v54, v53 + 1, 8);
          v23 = v53;
        }
        v52[v23] = v22;
        LODWORD(v53) = v53 + 1;
        mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v48, 1u);
        if (!*(_BYTE *)(v10 + 47)
          || (InherentAttr = mlir::Operation::getInherentAttr(v10, (uint64_t)"data_format", 11), !v25))
        {
          InherentAttr = mlir::DictionaryAttr::get(v10 + 56, "data_format", 0xBuLL);
        }
        if (!InherentAttr
          || *(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
        {
          mlir::mps::TensorDataLayoutAttr::get(*((mlir::MLIRContext **)a3 + 1), 1u);
        }
        v26 = v53;
        if (v53 >= HIDWORD(v53))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v52, v54, v53 + 1, 8);
          v26 = v53;
        }
        v52[v26] = v10;
        LODWORD(v53) = v53 + 1;
        ODSOperands = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v37, 1u);
        if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v46))
        {
          v28 = *((_QWORD *)a3 + 2);
          if (v28 && mlir::RewriterBase::Listener::classof(v28))
          {
            v29 = *((_QWORD *)a2 + 3);
LABEL_48:
            v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v28 + 64))(v28, v29, v30, v48);
            goto LABEL_19;
          }
        }
        else
        {
          v32 = *(_QWORD *)(v39[0] + 24);
          *(_OWORD *)v48 = xmmword_181240F30;
          {
            v33 = *(_QWORD *)(ODSOperands + 24);
            *(_OWORD *)v48 = xmmword_181240F40;
            {
              v34 = *(void **)(v52[1] + 24);
              v48[0] = *(void **)(*v52 + 24);
              v48[1] = v34;
              v35 = *(_QWORD *)(v52[3] + 24);
              v49 = *(_QWORD *)(v52[2] + 24);
              v50 = v35;
              mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v48, (mlir::MLIRContext *)4, 0);
            }
            v28 = *((_QWORD *)a3 + 2);
            if (v28 && mlir::RewriterBase::Listener::classof(v28))
            {
              v29 = *((_QWORD *)a2 + 3);
              goto LABEL_48;
            }
          }
          else
          {
            v28 = *((_QWORD *)a3 + 2);
            if (v28 && mlir::RewriterBase::Listener::classof(v28))
            {
              v29 = *((_QWORD *)a2 + 3);
              goto LABEL_48;
            }
          }
        }
      }
    }
    else
    {
      v14 = *((_QWORD *)a3 + 2);
      if (!v14)
        goto LABEL_50;
      v31 = v48[0];
      if (mlir::RewriterBase::Listener::classof(v14))
      {
        v15 = v31[3];
        goto LABEL_14;
      }
    }
  }
  else
  {
    v14 = *((_QWORD *)a3 + 2);
    if (!v14)
      goto LABEL_50;
    v19 = v37;
    if (mlir::RewriterBase::Listener::classof(v14))
    {
      v15 = *((_QWORD *)v19 + 3);
      v17 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v14 + 64);
      v18 = v48;
      goto LABEL_18;
    }
  }
LABEL_49:
  v14 = 0;
LABEL_50:
  if (v52 != v54)
    free(v52);
  return v14;
}

uint64_t mlir::mps::`anonymous namespace'::static_dag_matcher_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, _QWORD *a9, _QWORD *a10, uint64_t *a11, _QWORD *a12, uint64_t *a13)
{
  uint64_t v15;
  uint64_t DefiningOp;
  uint64_t v23;
  void *v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t result;
  uint64_t v29;
  uint64_t v30;
  uint64_t (*v31)(int, uint64_t);
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t InherentAttr;
  char v39;
  uint64_t v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char v52;
  uint64_t v53;
  uint64_t v54;

  if (*(_UNKNOWN **)(*(_QWORD *)(a2 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id)
    v15 = a2;
  else
    v15 = 0;
  v54 = v15;
  if (!v15)
  {
    v29 = *(_QWORD *)(a1 + 16);
    if (!v29)
      return 0;
    result = mlir::RewriterBase::Listener::classof(v29);
    if (!(_DWORD)result)
      return result;
    v30 = *(_QWORD *)(a2 + 24);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(_QWORD *)v29 + 64))(v29, v30, v31, &v53);
  }
  v53 = *(_QWORD *)(mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v54, 0) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v53);
  if (DefiningOp)
  {
    v23 = DefiningOp;
    v24 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
    v25 = v24 == &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id;
    if (v24 == &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id)
      v26 = DefiningOp;
    else
      v26 = 0;
    v53 = v26;
    if (!v25)
    {
      v27 = *(_QWORD *)(a1 + 16);
      if (v27)
      {
        result = mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16));
        if ((_DWORD)result)
        return result;
      }
      return 0;
    }
    *a12 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v53, 0);
    a12[1] = v34;
    *a10 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v53, 1u);
    a10[1] = v35;
    v36 = *(unsigned int *)(a3 + 8);
    if (v36 >= *(_DWORD *)(a3 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v36 + 1, 8);
      LODWORD(v36) = *(_DWORD *)(a3 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a3 + 8 * v36) = v23;
    ++*(_DWORD *)(a3 + 8);
    *a9 = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v54, 1u);
    a9[1] = v37;
    if (!*(_BYTE *)(a2 + 47) || (InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"groups", 6), !v39))
      InherentAttr = mlir::DictionaryAttr::get(a2 + 56, "groups", 6uLL);
    if (!InherentAttr
      || *(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      v29 = *(_QWORD *)(a1 + 16);
      if (!v29)
        return 0;
      result = mlir::RewriterBase::Listener::classof(v29);
      if (!(_DWORD)result)
        return result;
      v30 = *(_QWORD *)(a2 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(_QWORD *)v29 + 64))(v29, v30, v31, &v53);
    }
    *a8 = InherentAttr;
    if (!*(_BYTE *)(a2 + 47) || (v40 = mlir::Operation::getInherentAttr(a2, (uint64_t)"strides", 7), !v41))
      v40 = mlir::DictionaryAttr::get(a2 + 56, "strides", 7uLL);
    v42 = v40;
    if (!v40 || (mlir::DenseIntElementsAttr::classof(v40) & 1) == 0)
    {
      v29 = *(_QWORD *)(a1 + 16);
      if (!v29)
        return 0;
      result = mlir::RewriterBase::Listener::classof(v29);
      if (!(_DWORD)result)
        return result;
      v30 = *(_QWORD *)(a2 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(_QWORD *)v29 + 64))(v29, v30, v31, &v53);
    }
    *a6 = v42;
    if (!*(_BYTE *)(a2 + 47) || (v43 = mlir::Operation::getInherentAttr(a2, (uint64_t)"dilation_rates", 14), !v44))
      v43 = mlir::DictionaryAttr::get(a2 + 56, "dilation_rates", 0xEuLL);
    v45 = v43;
    if (!v43 || (mlir::DenseIntElementsAttr::classof(v43) & 1) == 0)
    {
      v29 = *(_QWORD *)(a1 + 16);
      if (!v29)
        return 0;
      result = mlir::RewriterBase::Listener::classof(v29);
      if (!(_DWORD)result)
        return result;
      v30 = *(_QWORD *)(a2 + 24);
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(_QWORD *)v29 + 64))(v29, v30, v31, &v53);
    }
    *a4 = v45;
    if (!*(_BYTE *)(a2 + 47) || (v46 = mlir::Operation::getInherentAttr(a2, (uint64_t)"explicit_padding", 16), !v47))
      v46 = mlir::DictionaryAttr::get(a2 + 56, "explicit_padding", 0x10uLL);
    v48 = v46;
    if (v46 && (mlir::DenseIntElementsAttr::classof(v46) & 1) != 0)
    {
      *a11 = v48;
      v49 = mlir::Operation::getAttrOfType<mlir::mps::PaddingStyleAttr>(a2, "padding_style", 0xDuLL);
      if (v49)
      {
        *a7 = v49;
        v50 = mlir::Operation::getAttrOfType<mlir::mps::TensorDataLayoutAttr>(a2, "data_layout", 0xBuLL);
        if (v50)
        {
          *a5 = v50;
          v51 = mlir::Operation::getAttrOfType<mlir::mps::TensorDataLayoutAttr>(a2, "weights_layout", 0xEuLL);
          if (v51)
          {
            *a13 = v51;
            return 1;
          }
          else
          {
          }
        }
        else
        {
        }
      }
      else
      {
      }
    }
    else
    {
    }
  }
  else
  {
    v32 = *(_QWORD *)(a1 + 16);
    if (!v32)
      return 0;
    v33 = v54;
    result = mlir::RewriterBase::Listener::classof(v32);
    if ((_DWORD)result)
  }
  return result;
}

uint64_t mlir::Operation::getAttrOfType<mlir::mps::TensorDataLayoutAttr>(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t result;
  char v7;

  if (!*(_BYTE *)(a1 + 47) || (result = mlir::Operation::getInherentAttr(a1, (uint64_t)a2, a3), !v7))
    result = mlir::DictionaryAttr::get(a1 + 56, a2, a3);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)result + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
      return 0;
  }
  return result;
}

BOOL mlir::mps::`anonymous namespace'::matchConstantValues<int>(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t DefiningOp;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t *v14;
  _QWORD *v15;
  unint64_t v16;
  const void *v17;
  uint64_t NumElements;
  _BOOL8 v19;
  uint64_t v21;
  void *v22[2];
  _QWORD v23[9];

  v23[8] = *MEMORY[0x1E0C80C00];
  v21 = a1;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v21);
  if (!DefiningOp)
    return 0;
  v6 = DefiningOp;
  v7 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(_QWORD, uint64_t))(**(_QWORD **)(v6 + 48) + 32))(*(_QWORD *)(v6 + 48), v7))
    return 0;
  v22[0] = v23;
  v22[1] = (void *)0x100000000;
  mlir::Operation::fold(v6, 0, 0, (uint64_t)v22);
  v8 = (uint64_t *)(*(_QWORD *)v22[0] & 0xFFFFFFFFFFFFFFF8);
  if (v22[0] != v23)
    free(v22[0]);
  if (!v8)
    return 0;
  v9 = *v8;
  v10 = mlir::TypeID::get<mlir::ElementsAttr>();
  v11 = *(unsigned int *)(v9 + 16);
  if ((_DWORD)v11)
  {
    v12 = *(_QWORD **)(v9 + 8);
    do
    {
      v13 = v11 >> 1;
      v14 = &v12[2 * (v11 >> 1)];
      v16 = *v14;
      v15 = v14 + 2;
      v11 += ~(v11 >> 1);
      if (v16 < v10)
        v12 = v15;
      else
        v11 = v13;
    }
    while (v11);
  }
  mlir::mps::CPUNDArray::CPUNDArray(v22, v8);
  v17 = (const void *)v23[3];
  NumElements = mlir::mps::CPUNDArray::getNumElements((mlir::mps::CPUNDArray *)v22);
  v19 = NumElements == a3 && memcmp(v17, a2, 4 * NumElements) == 0;
  mlir::mps::CPUNDArray::~CPUNDArray(v22);
  return v19;
}

uint64_t mlir::mps::`anonymous namespace'::transpose4VecIntAttrToNHWC(uint64_t a1, uint64_t a2)
{
  int64_t NumElements;
  char *v5;
  uint64_t v6;
  int64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  _OWORD *v13;
  __int128 *v14;
  unint64_t v15;
  __int128 v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  char *v21;
  unint64_t v22;
  char *v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  char *v28;
  unint64_t v29;
  char *v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t *v37;
  unint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t ArgOperands;
  uint64_t v42;
  uint64_t v43;
  _OWORD *v45;
  __int128 *v46;
  unint64_t v47;
  __int128 v48;
  _OWORD *v49;
  __int128 *v50;
  unint64_t v51;
  __int128 v52;
  _OWORD *v53;
  __int128 *v54;
  unint64_t v55;
  __int128 v56;
  _QWORD v57[2];
  void *v58;
  uint64_t v59;
  _BYTE v60[48];
  void *v61[2];
  _QWORD v62[5];

  v62[4] = *MEMORY[0x1E0C80C00];
  v57[0] = a1;
  v57[1] = a2;
  NumElements = mlir::ElementsAttr::getNumElements(a1, a2);
  v61[0] = v62;
  v61[1] = (void *)0x400000000;
  mlir::getIntValues<unsigned long long>(a1, a2, (uint64_t)v61, 1);
  v5 = (char *)v61[0];
  v58 = v60;
  v59 = 0x600000000;
  if (!NumElements)
    goto LABEL_33;
  if ((unint64_t)NumElements < 7)
  {
    v6 = 0;
    v7 = NumElements;
    goto LABEL_6;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v58, v60, NumElements, 8);
  v6 = v59;
  v7 = NumElements - v59;
  if (NumElements != v59)
LABEL_6:
    bzero((char *)v58 + 8 * v6, 8 * v7);
  LODWORD(v59) = NumElements;
  if (NumElements >= 0)
    v8 = NumElements;
  else
    v8 = NumElements + 3;
  if ((unint64_t)(NumElements + 3) < 7)
    goto LABEL_33;
  v9 = 0;
  v10 = v8 >> 2;
  v11 = (char *)v58;
  if (v10 < 4)
    goto LABEL_16;
  if ((unint64_t)((_BYTE *)v58 - v5) < 0x20)
    goto LABEL_16;
  v9 = v10 & 0xFFFFFFFFFFFFFFFCLL;
  v12 = &v5[8 * (v10 & 0xFFFFFFFFFFFFFFFCLL)];
  v13 = (char *)v58 + 16;
  v14 = (__int128 *)(v5 + 16);
  v15 = v10 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v16 = *v14;
    *(v13 - 1) = *(v14 - 1);
    *v13 = v16;
    v13 += 2;
    v14 += 2;
    v15 -= 4;
  }
  while (v15);
  v5 += 8 * (v10 & 0xFFFFFFFFFFFFFFFCLL);
  if (v10 != v9)
  {
LABEL_16:
    v17 = v10 - v9;
    v18 = &v11[8 * v9];
    v12 = v5;
    do
    {
      v19 = *(_QWORD *)v12;
      v12 += 8;
      *(_QWORD *)v18 = v19;
      v18 += 8;
      --v17;
    }
    while (v17);
  }
  v20 = (char *)v58;
  if (v10 < 6 || (v21 = (char *)v58 + 24 * v10, (unint64_t)(v21 - v12) < 0x20))
  {
    v22 = 0;
    v23 = v12;
LABEL_21:
    v24 = v10 - v22;
    v25 = &v20[24 * v10 + 8 * v22];
    do
    {
      v26 = *(_QWORD *)v23;
      v23 += 8;
      *(_QWORD *)v25 = v26;
      v25 += 8;
      --v24;
    }
    while (v24);
    goto LABEL_23;
  }
  v22 = v10 & 0xFFFFFFFFFFFFFFFCLL;
  v23 = &v12[8 * (v10 & 0xFFFFFFFFFFFFFFFCLL)];
  v45 = v21 + 16;
  v46 = (__int128 *)(v12 + 16);
  v47 = v10 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v48 = *v46;
    *(v45 - 1) = *(v46 - 1);
    *v45 = v48;
    v45 += 2;
    v46 += 2;
    v47 -= 4;
  }
  while (v47);
  if (v10 != v22)
    goto LABEL_21;
LABEL_23:
  v27 = (char *)v58;
  if (v10 >= 6 && (v28 = (char *)v58 + 8 * v10, (unint64_t)(v28 - v23) >= 0x20))
  {
    v29 = v10 & 0xFFFFFFFFFFFFFFFCLL;
    v30 = &v23[8 * (v10 & 0xFFFFFFFFFFFFFFFCLL)];
    v49 = v28 + 16;
    v50 = (__int128 *)(v23 + 16);
    v51 = v10 & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v52 = *v50;
      *(v49 - 1) = *(v50 - 1);
      *v49 = v52;
      v49 += 2;
      v50 += 2;
      v51 -= 4;
    }
    while (v51);
    if (v10 == v29)
      goto LABEL_28;
  }
  else
  {
    v29 = 0;
    v30 = v23;
  }
  v31 = v10 - v29;
  v32 = &v27[8 * v29 + 8 * v10];
  do
  {
    v33 = *(_QWORD *)v30;
    v30 += 8;
    *(_QWORD *)v32 = v33;
    v32 += 8;
    --v31;
  }
  while (v31);
LABEL_28:
  v34 = (char *)v58;
  v35 = 16 * v10;
  if (v10 < 6 || (unint64_t)((_BYTE *)v58 + v35 - v30) < 0x20)
  {
    v36 = 0;
    v37 = (uint64_t *)v30;
LABEL_31:
    v38 = v10 - v36;
    v39 = &v34[8 * v36 + v35];
    do
    {
      v40 = *v37++;
      *(_QWORD *)v39 = v40;
      v39 += 8;
      --v38;
    }
    while (v38);
    goto LABEL_33;
  }
  v36 = v10 & 0xFFFFFFFFFFFFFFFCLL;
  v37 = (uint64_t *)&v30[8 * (v10 & 0xFFFFFFFFFFFFFFFCLL)];
  v53 = (char *)v58 + v35 + 16;
  v54 = (__int128 *)(v30 + 16);
  v55 = v10 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v56 = *v54;
    *(v53 - 1) = *(v54 - 1);
    *v53 = v56;
    v53 += 2;
    v54 += 2;
    v55 -= 4;
  }
  while (v55);
  if (v10 != v36)
    goto LABEL_31;
LABEL_33:
  ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v57);
  v43 = mlir::DenseElementsAttr::getFromRawBuffer(ArgOperands, v42, v58, 8 * v59, 8, 1, 0);
  if (v58 != v60)
    free(v58);
  if (v61[0] != v62)
    free(v61[0]);
  return v43;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::Conv2DOp,mlir::Value &,mlir::Value &,mlir::IntegerAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::mps::TensorDataLayoutAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11)
{
  uint64_t *Context;
  uint64_t v20;
  char v21;
  mlir::GenericProgramPoint *v22;
  mlir::GenericProgramPoint *v23;
  uint64_t v25;
  const char *v26;
  __int16 v27;
  uint64_t v28[4];
  __int16 v29;
  _QWORD v30[40];

  v30[38] = *MEMORY[0x1E0C80C00];
  v25 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
  v20 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d", (const unsigned __int8 *)0xB, Context);
  if (!v21)
  {
    v29 = 1283;
    v28[2] = (uint64_t)"mps.conv_2d";
    v28[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v27 = 259;
    llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
    llvm::report_fatal_error((llvm::Twine *)v30, 1);
  }
  mlir::OperationState::OperationState(v30, a2, v20);
  mlir::mps::Conv2DOp::build(a1, (uint64_t)v30, *a3, *a4, *a5, *a6, *a7, *a8, *a9, *a10, *a11);
  v22 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v30);
  if (*(_UNKNOWN **)(*((_QWORD *)v22 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id)
    v23 = v22;
  else
    v23 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v30);
  return v23;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::BiasAddOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.bias_add", (const unsigned __int8 *)0xC, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.bias_add";
    v19[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::BiasAddOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_NCHW_ConvBias_NHWC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_NCHW_ConvBias_NHWC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::mps::BiasAddOp type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_NCHW_ConvBias_NHWC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp1");
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_6>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::Operation::getAttrOfType<mlir::mps::PaddingStyleAttr>(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t result;
  char v7;

  if (!*(_BYTE *)(a1 + 47) || (result = mlir::Operation::getInherentAttr(a1, (uint64_t)a2, a3), !v7))
    result = mlir::DictionaryAttr::get(a1 + 56, a2, a3);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)result + 136) != &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
      return 0;
  }
  return result;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_7>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_8>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t mlir::RewriterBase::notifyMatchFailure<mlir::mps::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_9>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && mlir::RewriterBase::Listener::classof(*(_QWORD *)(a1 + 16)))
  else
    return 0;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_0>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::mps::Conv2DOp type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_1>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp1");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_2>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp2 is not ::mlir::mps::PermuteOp type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_3>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'mps.conv_2d' to have attribute 'groups' of type '::mlir::IntegerAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_4>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'mps.conv_2d' to have attribute 'strides' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_5>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'mps.conv_2d' to have attribute 'dilation_rates' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_6>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'mps.conv_2d' to have attribute 'explicit_padding' of type '::mlir::DenseIntElementsAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_7>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'mps.conv_2d' to have attribute 'padding_style' of type '::mlir::mps::PaddingStyleAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_8>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'mps.conv_2d' to have attribute 'data_layout' of type '::mlir::mps::TensorDataLayoutAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::static_dag_matcher_0(mlir::PatternRewriter &,mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u> &,mlir::DenseIntElementsAttr &,mlir::mps::TensorDataLayoutAttr &,mlir::DenseIntElementsAttr &,mlir::mps::PaddingStyleAttr &,mlir::IntegerAttr &,mlir::OperandRange &,mlir::OperandRange &,mlir::DenseIntElementsAttr &,mlir::OperandRange &,mlir::mps::TensorDataLayoutAttr &)::$_9>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'mps.conv_2d' to have attribute 'weights_layout' of type '::mlir::mps::TensorDataLayoutAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_NCHW_ConvBias_NHWC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'data_layout' failed to satisfy constraint: 'is NCHW'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_NCHW_ConvBias_NHWC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'to_nchw' failed to satisfy constraint: 'NHWC to NCHW'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_NCHW_ConvBias_NHWC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#6}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'to_nhwc' failed to satisfy constraint: 'NCHW to NHWC'");
}

void mlir::mps::`anonymous namespace'::MPS_NCHW_Conv_NHWC::~MPS_NCHW_Conv_NHWC(mlir::mps::_anonymous_namespace_::MPS_NCHW_Conv_NHWC *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::MPS_NCHW_Conv_NHWC::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_NCHW_Conv_NHWC *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  mlir::Operation *v8;
  uint64_t DefiningOp;
  uint64_t v10;
  int v11;
  uint64_t ODSOperands;
  uint64_t v13;
  uint64_t v14;
  uint64_t (*v15)(int, uint64_t);
  uint64_t v16;
  mlir::Operation *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  mlir::Operation *v23;
  uint64_t v24;
  _QWORD v25[2];
  uint64_t v26;
  _QWORD v27[2];
  uint64_t v28;
  uint64_t v29;
  _QWORD v30[2];
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void *v34[11];
  _QWORD *v35;
  uint64_t v36;
  _QWORD v37[7];

  v37[4] = *MEMORY[0x1E0C80C00];
  v5 = *((_DWORD *)a2 + 11);
  v32 = 0;
  v33 = 0;
  v31 = 0;
  if ((v5 & 0x800000) != 0)
  {
    v6 = *((_QWORD *)a2 + 9);
    v7 = *((unsigned int *)a2 + 17);
    v30[0] = v6;
  }
  else
  {
    v7 = 0;
    v6 = 0;
    v30[0] = 0;
  }
  v30[1] = v7;
  v28 = 0;
  v29 = 0;
  v27[0] = v6;
  v27[1] = v7;
  v25[1] = v7;
  v26 = 0;
  v24 = 0;
  v25[0] = v6;
  v35 = v37;
  v37[0] = a2;
  v36 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id)
    v8 = a2;
  else
    v8 = 0;
  v23 = v8;
  v34[0] = *(void **)(mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v23, 0) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v34);
  if (DefiningOp)
  {
    v10 = DefiningOp;
    {
      v11 = v36;
      if (v36 >= HIDWORD(v36))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v37, v36 + 1, 8);
        v11 = v36;
      }
      v35[v11] = v10;
      LODWORD(v36) = v36 + 1;
      ODSOperands = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v23, 1u);
      if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v32))
      {
        v13 = *((_QWORD *)a3 + 2);
        if (v13 && mlir::RewriterBase::Listener::classof(v13))
        {
          v14 = *((_QWORD *)a2 + 3);
LABEL_26:
          v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v13 + 64))(v13, v14, v15, v34);
          goto LABEL_27;
        }
      }
      else
      {
        v19 = *(_QWORD *)(v25[0] + 24);
        *(_OWORD *)v34 = xmmword_181240F30;
        {
          v20 = *(_QWORD *)(ODSOperands + 24);
          *(_OWORD *)v34 = xmmword_181240F40;
          {
            v21 = *(void **)(v35[1] + 24);
            v34[0] = *(void **)(*v35 + 24);
            v34[1] = v21;
            v34[2] = *(void **)(v35[2] + 24);
            mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v34, (mlir::MLIRContext *)3, 0);
          }
          v13 = *((_QWORD *)a3 + 2);
          if (v13 && mlir::RewriterBase::Listener::classof(v13))
          {
            v14 = *((_QWORD *)a2 + 3);
            goto LABEL_26;
          }
        }
        else
        {
          v13 = *((_QWORD *)a3 + 2);
          if (v13 && mlir::RewriterBase::Listener::classof(v13))
          {
            v14 = *((_QWORD *)a2 + 3);
            goto LABEL_26;
          }
        }
      }
    }
  }
  else
  {
    v16 = *((_QWORD *)a3 + 2);
    if (!v16)
      goto LABEL_29;
    v17 = v23;
    if (mlir::RewriterBase::Listener::classof(v16))
    {
LABEL_27:
      v16 = v18;
      goto LABEL_29;
    }
  }
  v16 = 0;
LABEL_29:
  if (v35 != v37)
    free(v35);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::Conv2DOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.conv_2d", (const unsigned __int8 *)0xB, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.conv_2d";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_NCHW_Conv_NHWC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_NCHW_Conv_NHWC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'data_layout' failed to satisfy constraint: 'is NCHW'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_NCHW_Conv_NHWC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'to_nchw' failed to satisfy constraint: 'NHWC to NCHW'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_NCHW_Conv_NHWC::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'to_nhwc' failed to satisfy constraint: 'NCHW to NHWC'");
}

void mlir::mps::`anonymous namespace'::MPS_ReorderDequantPad::~MPS_ReorderDequantPad(mlir::mps::_anonymous_namespace_::MPS_ReorderDequantPad *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::MPS_ReorderDequantPad::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_ReorderDequantPad *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  mlir::Operation *v5;
  uint64_t DefiningOp;
  uint64_t v7;
  void *v8;
  BOOL v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(int, uint64_t);
  mlir::Operation *v14;
  uint64_t v15;
  uint64_t InherentAttr;
  char v17;
  char v18;
  int v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t (*v24)(int, uint64_t);
  void *v25;
  mlir::Operation *v27;
  uint64_t v28;
  void *v29[10];
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  _QWORD v33[6];

  v33[4] = *MEMORY[0x1E0C80C00];
  v28 = 0;
  v31 = v33;
  v33[0] = a2;
  v32 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PadOp,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v27 = v5;
  v29[0] = *(void **)(mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v27, 0) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v29);
  if (DefiningOp)
  {
    v7 = DefiningOp;
    v8 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
    v9 = v8 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id;
    if (v8 == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id)
      v10 = (void *)DefiningOp;
    else
      v10 = 0;
    v29[0] = v10;
    if (v9)
    {
      mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v29, 0);
      mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v29, 1u);
      mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v29, 2u);
      mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v29, 3u);
      if (!*(_BYTE *)(v7 + 47) || (InherentAttr = mlir::Operation::getInherentAttr(v7, (uint64_t)"dtype", 5), !v17))
        InherentAttr = mlir::DictionaryAttr::get(v7 + 56, "dtype", 5uLL);
      if (InherentAttr
        && *(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
      {
        if (!*(_BYTE *)(v7 + 47) || (mlir::Operation::getInherentAttr(v7, (uint64_t)"axis", 4), !v18))
          mlir::DictionaryAttr::get(v7 + 56, "axis", 4uLL);
        v19 = v32;
        if (v32 >= HIDWORD(v32))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v31, v33, v32 + 1, 8);
          v19 = v32;
        }
        v31[v19] = v7;
        LODWORD(v32) = v32 + 1;
        mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v27, 1u);
        mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v27, 2u);
        if (!*((_BYTE *)a2 + 47)
          || (v20 = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"paddingMode", 11), !v21))
        {
          v20 = mlir::DictionaryAttr::get((uint64_t)a2 + 56, "paddingMode", 0xBuLL);
        }
        if (v20
          && *(_UNKNOWN **)(*(_QWORD *)v20 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id)
        {
          v28 = v20;
          if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v28) == 3)
          {
            v25 = *(void **)(v31[1] + 24);
            v29[0] = *(void **)(*v31 + 24);
            v29[1] = v25;
            mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v29, (mlir::MLIRContext *)2, 0);
          }
          v22 = *((_QWORD *)a3 + 2);
          if (!v22 || !mlir::RewriterBase::Listener::classof(v22))
            goto LABEL_44;
          v23 = *((_QWORD *)a2 + 3);
        }
        else
        {
          v22 = *((_QWORD *)a3 + 2);
          if (!v22 || !mlir::RewriterBase::Listener::classof(v22))
            goto LABEL_44;
          v23 = *((_QWORD *)a2 + 3);
        }
        v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), void **))(*(_QWORD *)v22 + 64))(v22, v23, v24, v29);
        goto LABEL_24;
      }
      v11 = *((_QWORD *)a3 + 2);
      if (!v11)
        goto LABEL_45;
      if (mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
      {
        v12 = *(_QWORD *)(v7 + 24);
        goto LABEL_23;
      }
    }
    else
    {
      v11 = *((_QWORD *)a3 + 2);
      if (!v11)
        goto LABEL_45;
      if (mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2)))
      {
        v12 = *(_QWORD *)(v7 + 24);
LABEL_23:
        v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t (*)(int, uint64_t), uint64_t *))(*(_QWORD *)v11 + 64))(v11, v12, v13, &v30);
        goto LABEL_24;
      }
    }
  }
  else
  {
    v11 = *((_QWORD *)a3 + 2);
    if (!v11)
      goto LABEL_45;
    v14 = v27;
    if (mlir::RewriterBase::Listener::classof(v11))
    {
LABEL_24:
      v11 = v15;
      goto LABEL_45;
    }
  }
LABEL_44:
  v11 = 0;
LABEL_45:
  if (v31 != v33)
    free(v31);
  return v11;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::PadOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::mps::PaddingModeAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t *Context;
  uint64_t v13;
  char v14;
  mlir::GenericProgramPoint *v15;
  mlir::GenericProgramPoint *v16;
  uint64_t v18;
  const char *v19;
  __int16 v20;
  uint64_t v21[4];
  __int16 v22;
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.pad", (const unsigned __int8 *)7, Context);
  if (!v14)
  {
    v22 = 1283;
    v21[2] = (uint64_t)"mps.pad";
    v21[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v13);
  mlir::mps::PadOp::build(a1, (uint64_t)v23, *a3, *a4, *a5, *a6);
  v15 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::PadOp,void>::id)
    v16 = v15;
  else
    v16 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::DequantizeOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.dequantize", (const unsigned __int8 *)0xE, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.dequantize";
    v19[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_ReorderDequantPad::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_ReorderDequantPad::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::mps::DequantizeOp type");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_ReorderDequantPad::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#3}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'mps.dequantize' to have attribute 'dtype' of type '::mlir::TypeAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_ReorderDequantPad::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#4}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "expected op 'mps.pad' to have attribute 'paddingMode' of type '::mlir::mps::PaddingModeAttr'");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_ReorderDequantPad::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#5}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'paddingMode' failed to satisfy constraint: 'is clamp to edge padding mode'");
}

void mlir::mps::`anonymous namespace'::MPS_ReshapeReshape::~MPS_ReshapeReshape(mlir::mps::_anonymous_namespace_::MPS_ReshapeReshape *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::MPS_ReshapeReshape::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_ReshapeReshape *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  mlir::Operation *v5;
  uint64_t DefiningOp;
  uint64_t v7;
  void *v8;
  BOOL v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  mlir::Operation *v13;
  char v14;
  int v15;
  char v16;
  void *v17;
  mlir::Operation *v19;
  void *v20[10];
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD v24[6];

  v24[4] = *MEMORY[0x1E0C80C00];
  v22 = v24;
  v24[0] = a2;
  v23 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v19 = v5;
  v20[0] = *(void **)(mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v19, 0) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v20);
  if (!DefiningOp)
  {
    v11 = *((_QWORD *)a3 + 2);
    if (!v11)
      goto LABEL_26;
    v13 = v19;
    if (mlir::RewriterBase::Listener::classof(v11))
    {
      goto LABEL_15;
    }
    goto LABEL_16;
  }
  v7 = DefiningOp;
  v8 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
  v9 = v8 == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id;
  if (v8 == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
    v10 = (void *)DefiningOp;
  else
    v10 = 0;
  v20[0] = v10;
  if (v9)
  {
    mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v20, 0);
    mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v20, 1u);
    if (!*(_BYTE *)(v7 + 47) || (mlir::Operation::getInherentAttr(v7, (uint64_t)"zero_is_copy", 12), !v14))
      mlir::DictionaryAttr::get(v7 + 56, "zero_is_copy", 0xCuLL);
    v15 = v23;
    if (v23 >= HIDWORD(v23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v22, v24, v23 + 1, 8);
      v15 = v23;
    }
    v22[v15] = v7;
    LODWORD(v23) = v23 + 1;
    mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v19, 1u);
    if (!*((_BYTE *)a2 + 47) || (mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"zero_is_copy", 12), !v16))
      mlir::DictionaryAttr::get((uint64_t)a2 + 56, "zero_is_copy", 0xCuLL);
    v17 = *(void **)(v22[1] + 24);
    v20[0] = *(void **)(*v22 + 24);
    v20[1] = v17;
    mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v20, (mlir::MLIRContext *)2, 0);
  }
  v11 = *((_QWORD *)a3 + 2);
  if (v11)
  {
    if (mlir::RewriterBase::Listener::classof(v11))
    {
LABEL_15:
      v11 = v12;
      goto LABEL_26;
    }
LABEL_16:
    v11 = 0;
  }
LABEL_26:
  if (v22 != v24)
    free(v22);
  return v11;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ReshapeOp,llvm::SmallVector<mlir::Type,4u> &,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *Context;
  uint64_t v11;
  char v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  unint64_t v21[2];
  unint64_t v22[2];
  _QWORD v23[39];

  v23[38] = *MEMORY[0x1E0C80C00];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.reshape", (const unsigned __int8 *)0xB, Context);
  if (!v12)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"mps.reshape";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v11);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a4, *(unsigned int *)(a4 + 8));
  mlir::arith::CmpIOp::build((uint64_t)a1, (uint64_t)v23, v22[0], v22[1], v21[0], v21[1], *(const void **)a5, *(unsigned int *)(a5 + 8));
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v14;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_ReshapeReshape::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_ReshapeReshape::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::mps::ReshapeOp type");
}

void mlir::mps::`anonymous namespace'::MPS_SelectCondCast::~MPS_SelectCondCast(mlir::mps::_anonymous_namespace_::MPS_SelectCondCast *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::MPS_SelectCondCast::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_SelectCondCast *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  mlir::Operation *v5;
  unint64_t v6;
  uint64_t v7;
  void *v8;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t *v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t ODSOperands;
  uint64_t v21;
  uint64_t v22;
  mlir::Operation *v24;
  void *v25[10];
  void *OperandRange;
  _QWORD v27[6];
  _QWORD *v28;
  uint64_t v29;
  _QWORD v30[6];

  v30[4] = *MEMORY[0x1E0C80C00];
  v28 = v30;
  v30[0] = a2;
  v29 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SelectOp,void>::id)
    v5 = a2;
  else
    v5 = 0;
  v24 = v5;
  v6 = *(_QWORD *)(*(_QWORD *)(mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v24, 0) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v25[0] = "operand 0 of op 'mps.select' failed to satisfy constraint: 'tensor of 1-bit signless integer values'";
  v25[1] = (void *)100;
  v7 = *(_QWORD *)v6;
  v8 = *(void **)(*(_QWORD *)v6 + 136);
  if (v8 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    && v8 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    goto LABEL_34;
  }
  v10 = mlir::TypeID::get<mlir::ShapedType>();
  v11 = *(unsigned int *)(v7 + 16);
  if (!(_DWORD)v11)
    goto LABEL_17;
  v12 = *(_QWORD **)(v7 + 8);
  v13 = &v12[2 * v11];
  do
  {
    v14 = v11 >> 1;
    v15 = &v12[2 * (v11 >> 1)];
    v17 = *v15;
    v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10)
      v12 = v16;
    else
      v11 = v14;
  }
  while (v11);
  if (v12 != v13 && *v12 == v10)
    v18 = v12[1];
  else
LABEL_17:
    v18 = 0;
  v27[0] = v6;
  v27[1] = v18;
  OperandRange = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v27);
  if (!mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1))
  {
LABEL_34:
    v27[0] = v25;
    v19 = *((_QWORD *)a3 + 2);
    if (!v19
      || !mlir::RewriterBase::Listener::classof(*((_QWORD *)a3 + 2))
    {
      goto LABEL_26;
    }
  }
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v24, 0);
  ODSOperands = mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v24, 1u);
  mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v24, 2u);
  v25[0] = (void *)mlir::getElementTypeOrSelf((_QWORD *)(*(_QWORD *)(*(_QWORD *)(ODSOperands + 24) + 8) & 0xFFFFFFFFFFFFFFF8));
  if (!mlir::Type::isInteger((mlir::Type *)v25, 1))
  {
    v25[0] = *(void **)(*v28 + 24);
    mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v25, (mlir::MLIRContext *)1, 0);
  }
  v21 = *((_QWORD *)a3 + 2);
  if (v21 && mlir::RewriterBase::Listener::classof(v21))
  else
LABEL_26:
    v22 = 0;
  if (v28 != v30)
    free(v28);
  return v22;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::__mlir_ods_local_type_constraint_RuntimeCanonicalizationPatterns0(mlir::PatternRewriter &,mlir::Operation *,mlir::Type,llvm::StringRef)::$_0>(const void ****a1, uint64_t a2)
{
  const void ***v2;
  const void **v3;
  const void **v4;
  uint64_t v5;
  const void **v7[4];
  __int16 v8;

  v2 = *a1;
  v8 = 261;
  v4 = *v2;
  v3 = v2[1];
  v7[0] = v4;
  v7[1] = v3;
  v5 = mlir::Diagnostic::operator<<(a2, v7);
  return mlir::Diagnostic::operator<<(v5, ": tensor of 1-bit signless integer values");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_SelectCondCast::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "entities 'true_value' failed to satisfy constraint: 'is not BOOLean type'");
}

void mlir::mps::`anonymous namespace'::MPS_SquareOfAbsolute::~MPS_SquareOfAbsolute(mlir::mps::_anonymous_namespace_::MPS_SquareOfAbsolute *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  operator delete(this);
}

uint64_t mlir::mps::`anonymous namespace'::MPS_SquareOfAbsolute::matchAndRewrite(mlir::mps::_anonymous_namespace_::MPS_SquareOfAbsolute *this, mlir::Operation *a2, mlir::PatternRewriter *a3)
{
  mlir::Operation *v4;
  uint64_t DefiningOp;
  uint64_t v6;
  void *v7;
  BOOL v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  mlir::Operation *v12;
  int v13;
  void *v14;
  mlir::Operation *v16;
  void *v17[10];
  void *v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD v21[5];

  v21[4] = *MEMORY[0x1E0C80C00];
  v19 = v21;
  v21[0] = a2;
  v20 = 0x400000001;
  if (*(_UNKNOWN **)(*((_QWORD *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SquareOp,void>::id)
    v4 = a2;
  else
    v4 = 0;
  v16 = v4;
  v17[0] = *(void **)(mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)&v16, 0) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v17);
  if (!DefiningOp)
  {
    v10 = *((_QWORD *)a3 + 2);
    if (!v10)
      goto LABEL_20;
    v12 = v16;
    if (mlir::RewriterBase::Listener::classof(v10))
    {
      goto LABEL_15;
    }
    goto LABEL_16;
  }
  v6 = DefiningOp;
  v7 = *(void **)(*(_QWORD *)(DefiningOp + 48) + 16);
  v8 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::AbsoluteOp,void>::id;
  if (v7 == &mlir::detail::TypeIDResolver<mlir::mps::AbsoluteOp,void>::id)
    v9 = (void *)DefiningOp;
  else
    v9 = 0;
  v17[0] = v9;
  if (v8)
  {
    mlir::mps::AbsoluteOp::getODSOperands((mlir::mps::AbsoluteOp *)v17, 0);
    v13 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 8);
      v13 = v20;
    }
    v19[v13] = v6;
    LODWORD(v20) = v20 + 1;
    v14 = *(void **)(v19[1] + 24);
    v17[0] = *(void **)(*v19 + 24);
    v17[1] = v14;
    mlir::Builder::getFusedLoc((mlir::UnknownLoc **)a3 + 1, (uint64_t **)v17, (mlir::MLIRContext *)2, 0);
  }
  v10 = *((_QWORD *)a3 + 2);
  if (v10)
  {
    if (mlir::RewriterBase::Listener::classof(v10))
    {
LABEL_15:
      v10 = v11;
      goto LABEL_20;
    }
LABEL_16:
    v10 = 0;
  }
LABEL_20:
  if (v19 != v21)
    free(v19);
  return v10;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SquareOp,llvm::SmallVector<mlir::Value,4u> &,llvm::SmallVector<mlir::NamedAttribute,4u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  mlir::GenericProgramPoint *v11;
  mlir::GenericProgramPoint *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  unint64_t v19[2];
  _QWORD v20[39];

  v20[38] = *MEMORY[0x1E0C80C00];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"mps.square";
    v17[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v20);
    llvm::report_fatal_error((llvm::Twine *)v20, 1);
  }
  mlir::OperationState::OperationState(v20, a2, v9);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)a3, *(unsigned int *)(a3 + 8));
  mlir::arith::AddIOp::build((uint64_t)a1, (uint64_t)v20, v19[0], v19[1], *(const void **)a4, *(unsigned int *)(a4 + 8));
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v20);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SquareOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v20);
  return v12;
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_SquareOfAbsolute::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#1}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "There's no operation that defines operand 0 of castedOp0");
}

uint64_t llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::mps::`anonymous namespace'::MPS_SquareOfAbsolute::matchAndRewrite(mlir::Operation *,mlir::PatternRewriter &)::{lambda(mlir::Diagnostic &)#2}>(int a1, uint64_t a2)
{
  return mlir::Diagnostic::operator<<(a2, "castedOp1 is not ::mlir::mps::AbsoluteOp type");
}

_QWORD *mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionArgMaxOp>::~CanonicalizeReduction(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionArgMaxOp>::~CanonicalizeReduction(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionArgMaxOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionArgMaxOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionArgMaxOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionArgMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2)
{
  mlir::Operation::CloneOptions *InherentAttr;
  char v4;
  char v5;

  if (*(_BYTE *)(a2 + 47)
    && (InherentAttr = (mlir::Operation::CloneOptions *)mlir::Operation::getInherentAttr(a2, (uint64_t)"keep_dims", 9),
        v4))
  {
    if (!InherentAttr)
    {
LABEL_7:
      v5 = mlir::Operation::CloneOptions::all(InherentAttr);
      mlir::Operation::clone(a2, v5);
    }
  }
  else
  {
    InherentAttr = (mlir::Operation::CloneOptions *)mlir::DictionaryAttr::get(a2 + 56, "keep_dims", 9uLL);
    if (!InherentAttr)
      goto LABEL_7;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    goto LABEL_7;
  return 0;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::SqueezeOp,mlir::OpResult>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.squeeze", (const unsigned __int8 *)0xB, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.squeeze";
    v15[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::SqueezeOp::build((uint64_t)a1, (uint64_t)v17, a3, 1, 0, 0);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::SqueezeOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

_QWORD *mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionArgMinOp>::~CanonicalizeReduction(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionArgMinOp>::~CanonicalizeReduction(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionArgMinOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionArgMinOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionArgMinOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionArgMinOp>::matchAndRewrite(uint64_t a1, uint64_t a2)
{
  mlir::Operation::CloneOptions *InherentAttr;
  char v4;
  char v5;

  if (*(_BYTE *)(a2 + 47)
    && (InherentAttr = (mlir::Operation::CloneOptions *)mlir::Operation::getInherentAttr(a2, (uint64_t)"keep_dims", 9),
        v4))
  {
    if (!InherentAttr)
    {
LABEL_7:
      v5 = mlir::Operation::CloneOptions::all(InherentAttr);
      mlir::Operation::clone(a2, v5);
    }
  }
  else
  {
    InherentAttr = (mlir::Operation::CloneOptions *)mlir::DictionaryAttr::get(a2 + 56, "keep_dims", 9uLL);
    if (!InherentAttr)
      goto LABEL_7;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    goto LABEL_7;
  return 0;
}

_QWORD *mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionMaxOp>::~CanonicalizeReduction(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionMaxOp>::~CanonicalizeReduction(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionMaxOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionMaxOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionMaxOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2)
{
  mlir::Operation::CloneOptions *InherentAttr;
  char v4;
  char v5;

  if (*(_BYTE *)(a2 + 47)
    && (InherentAttr = (mlir::Operation::CloneOptions *)mlir::Operation::getInherentAttr(a2, (uint64_t)"keep_dims", 9),
        v4))
  {
    if (!InherentAttr)
    {
LABEL_7:
      v5 = mlir::Operation::CloneOptions::all(InherentAttr);
      mlir::Operation::clone(a2, v5);
    }
  }
  else
  {
    InherentAttr = (mlir::Operation::CloneOptions *)mlir::DictionaryAttr::get(a2 + 56, "keep_dims", 9uLL);
    if (!InherentAttr)
      goto LABEL_7;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    goto LABEL_7;
  return 0;
}

_QWORD *mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionMinOp>::~CanonicalizeReduction(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionMinOp>::~CanonicalizeReduction(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionMinOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionMinOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionMinOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionMinOp>::matchAndRewrite(uint64_t a1, uint64_t a2)
{
  mlir::Operation::CloneOptions *InherentAttr;
  char v4;
  char v5;

  if (*(_BYTE *)(a2 + 47)
    && (InherentAttr = (mlir::Operation::CloneOptions *)mlir::Operation::getInherentAttr(a2, (uint64_t)"keep_dims", 9),
        v4))
  {
    if (!InherentAttr)
    {
LABEL_7:
      v5 = mlir::Operation::CloneOptions::all(InherentAttr);
      mlir::Operation::clone(a2, v5);
    }
  }
  else
  {
    InherentAttr = (mlir::Operation::CloneOptions *)mlir::DictionaryAttr::get(a2 + 56, "keep_dims", 9uLL);
    if (!InherentAttr)
      goto LABEL_7;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    goto LABEL_7;
  return 0;
}

_QWORD *mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionProdOp>::~CanonicalizeReduction(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionProdOp>::~CanonicalizeReduction(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionProdOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionProdOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionProdOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionProdOp>::matchAndRewrite(uint64_t a1, uint64_t a2)
{
  mlir::Operation::CloneOptions *InherentAttr;
  char v4;
  char v5;

  if (*(_BYTE *)(a2 + 47)
    && (InherentAttr = (mlir::Operation::CloneOptions *)mlir::Operation::getInherentAttr(a2, (uint64_t)"keep_dims", 9),
        v4))
  {
    if (!InherentAttr)
    {
LABEL_7:
      v5 = mlir::Operation::CloneOptions::all(InherentAttr);
      mlir::Operation::clone(a2, v5);
    }
  }
  else
  {
    InherentAttr = (mlir::Operation::CloneOptions *)mlir::DictionaryAttr::get(a2 + 56, "keep_dims", 9uLL);
    if (!InherentAttr)
      goto LABEL_7;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    goto LABEL_7;
  return 0;
}

_QWORD *mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionSumOp>::~CanonicalizeReduction(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionSumOp>::~CanonicalizeReduction(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionSumOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionSumOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::mps::ReductionSumOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeReduction<mlir::mps::ReductionSumOp>::matchAndRewrite(uint64_t a1, uint64_t a2)
{
  mlir::Operation::CloneOptions *InherentAttr;
  char v4;
  char v5;

  if (*(_BYTE *)(a2 + 47)
    && (InherentAttr = (mlir::Operation::CloneOptions *)mlir::Operation::getInherentAttr(a2, (uint64_t)"keep_dims", 9),
        v4))
  {
    if (!InherentAttr)
    {
LABEL_7:
      v5 = mlir::Operation::CloneOptions::all(InherentAttr);
      mlir::Operation::clone(a2, v5);
    }
  }
  else
  {
    InherentAttr = (mlir::Operation::CloneOptions *)mlir::DictionaryAttr::get(a2 + 56, "keep_dims", 9uLL);
    if (!InherentAttr)
      goto LABEL_7;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    goto LABEL_7;
  return 0;
}

_QWORD *mlir::mps::`anonymous namespace'::CanonicalizeReductionAxes<mlir::mps::ReductionArgMaxOp>::~CanonicalizeReductionAxes(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void mlir::mps::`anonymous namespace'::CanonicalizeReductionAxes<mlir::mps::ReductionArgMaxOp>::~CanonicalizeReductionAxes(_QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)__p[10];
  if (v2 != __p + 12)
    free(v2);
  v3 = (_QWORD *)__p[4];
  if (v3 != __p + 6)
    free(v3);
  operator delete(__p);
}

uint64_t mlir::mps::`anonymous namespace'::CanonicalizeReductionAxes<mlir::mps::ReductionArgMaxOp>::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t InherentAttr;
  char v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  unint64_t v27;
  unint64_t *v28;
  _QWORD *v29;
  unint64_t v30;
  _QWORD *ArgAttrsAttr;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  char matched;
  uint64_t v41;
  uint64_t v42;
  mlir **v43;
  mlir **v44;
  uint64_t *v45;
  uint64_t NegativeAxis;
  uint64_t v47;
  uint64_t *v48;
  uint64_t **v49;
  uint64_t **v50;
  uint64_t v51;
  uint64_t *v52;
  int v53;
  uint64_t v54;
  char *v55;
  char *v56;
  uint64_t v57;
  char *v58;
  int64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  _BYTE *v64;
  char *v65;
  unint64_t v66;
  char *v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  _OWORD *v72;
  char *v73;
  uint64_t v74;
  __int128 v75;
  size_t v76;
  _QWORD *v77;
  char *v78;
  uint64_t *v79;
  void *v80;
  uint64_t v81;
  uint64_t *v82;
  uint64_t **v83;
  BOOL v84;
  uint64_t *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  char *v89;
  char *v90;
  unint64_t v91;
  char *v92;
  uint64_t v93;
  char *v94;
  unint64_t v95;
  uint64_t v96;
  char *v97;
  char *v98;
  uint64_t v99;
  char *v100;
  char *v101;
  uint64_t *v102;
  uint64_t v103;
  uint64_t PositiveAxis;
  uint64_t v105;
  char *v106;
  unint64_t v107;
  unint64_t v108;
  uint64_t v109;
  char *v110;
  _BOOL4 v111;
  uint64_t v112;
  char *v113;
  char *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  char *v119;
  char *v120;
  char *v121;
  char *v122;
  uint64_t *v123;
  uint64_t v124;
  unint64_t v125;
  unint64_t v126;
  _BYTE *v127;
  uint64_t v128;
  unint64_t v129;
  unint64_t v130;
  char *v131;
  _BYTE *v132;
  uint64_t *v133;
  unint64_t v134;
  char *v135;
  uint64_t v136;
  uint64_t *v137;
  char *v138;
  unint64_t v139;
  char *v140;
  uint64_t v141;
  uint64_t v142;
  char *v143;
  uint64_t v144;
  char *v145;
  uint64_t v146;
  uint64_t v147;
  unint64_t v148;
  uint64_t *v149;
  uint64_t *v150;
  unint64_t v151;
  unint64_t v152;
  unint64_t v153;
  char *v154;
  char *v155;
  char *v156;
  unint64_t v157;
  uint64_t *v158;
  uint64_t v159;
  uint64_t *v160;
  char *v161;
  unint64_t v162;
  uint64_t v163;
  uint64_t v164;
  _OWORD *v165;
  char *v166;
  uint64_t v167;
  __int128 v168;
  unint64_t v169;
  uint64_t v170;
  uint64_t v171;
  _OWORD *v172;
  char *v173;
  uint64_t v174;
  __int128 v175;
  unint64_t v176;
  uint64_t v177;
  uint64_t v178;
  char *v179;
  uint64_t *v180;
  uint64_t v181;
  __int128 v182;
  char *v183;
  uint64_t v184;
  unint64_t v185;
  _BYTE *v186;
  uint64_t *v187;
  unint64_t v188;
  char *v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  int64_t v193;
  char *v194;
  uint64_t v195;
  unint64_t v196;
  char *v197;
  char *v198;
  unint64_t v199;
  unint64_t v200;
  char *v201;
  char *v202;
  unint64_t v203;
  char *v204;
  char *v205;
  uint64_t v206;
  char *v207;
  char *v208;
  uint64_t v209;
  BOOL v210;
  char *v211;
  char *v212;
  uint64_t v213;
  uint64_t Loc;
  uint64_t IntegerType;
  _QWORD *v216;
  _QWORD *v217;
  uint64_t v218;
  unint64_t v219;
  unint64_t v220;
  _QWORD *v221;
  _QWORD *v222;
  unint64_t v223;
  unint64_t *v224;
  _QWORD *v225;
  unint64_t v226;
  uint64_t v227;
  uint64_t v228;
  unint64_t v229;
  uint64_t v230;
  char *v231;
  char *v232;
  uint64_t v233;
  uint64_t *v234;
  char *v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  unint64_t v239;
  unint64_t v240;
  _BYTE *v241;
  uint64_t *v242;
  unint64_t v243;
  uint64_t *v244;
  uint64_t v245;
  unint64_t v246;
  uint64_t v247;
  uint64_t v248;
  _OWORD *v249;
  __int128 *v250;
  uint64_t v251;
  __int128 v252;
  uint64_t v253;
  uint64_t v254;
  _QWORD *v255;
  _QWORD *v256;
  uint64_t v257;
  unint64_t v258;
  unint64_t v259;
  _QWORD *v260;
  _QWORD *v261;
  unint64_t v262;
  unint64_t *v263;
  _QWORD *v264;
  unint64_t v265;
  uint64_t v266;
  char v267;
  mlir::GenericProgramPoint *v268;
  mlir::Operation *v269;
  unint64_t v270;
  uint64_t v271;
  char *v272;
  char *v273;
  char *v274;
  uint64_t v275;
  uint64_t v276;
  unint64_t v277;
  unint64_t v278;
  _BYTE *v279;
  char *v280;
  char *v281;
  unint64_t v282;
  char *v283;
  uint64_t v284;
  unint64_t v285;
  uint64_t v286;
  uint64_t v287;
  _OWORD *v288;
  char *v289;
  uint64_t v290;
  __int128 v291;
  char *v292;
  BOOL v293;
  char *v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  _OWORD *v298;
  char *v299;
  uint64_t v300;
  __int128 v301;
  uint64_t v302;
  uint64_t v303;
  char *v304;
  char *v305;
  uint64_t v306;
  __int128 v307;
  uint64_t *v308;
  uint64_t v309;
  _BYTE *v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t *v314;
  uint64_t v315;
  mlir::GenericProgramPoint *v316;
  uint64_t v317;
  uint64_t v318;
  mlir::Builder *v319;
  char *v320;
  char *v321;
  uint64_t v322;
  char *v323;
  char *v324;
  char *v325;
  char *v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  char *v332;
  uint64_t *v333;
  uint64_t **v334;
  uint64_t *v335;
  size_t v336;
  void *__p;
  unint64_t v338;
  char *v339;
  _QWORD *v340;
  uint64_t v341;
  _QWORD v342[2];
  uint64_t *v343;
  uint64_t *v344;
  mlir::GenericProgramPoint *v345;
  unint64_t v346[2];
  uint64_t *v347;
  uint64_t v348;
  _QWORD v349[6];

  v349[4] = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a2 + 47))
  {
    InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"keep_dims", 9);
    if (v6)
    {
      if (!InherentAttr)
        return 0;
      goto LABEL_6;
    }
  }
  InherentAttr = mlir::DictionaryAttr::get(a2 + 56, "keep_dims", 9uLL);
  if (InherentAttr)
  {
LABEL_6:
    if (*(_UNKNOWN **)(*(_QWORD *)InherentAttr + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
      return 0;
    v317 = a3;
    v9 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
    v10 = (uint64_t *)(*(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v10)
      goto LABEL_18;
    v11 = *v10;
    v12 = mlir::TypeID::get<mlir::ShapedType>();
    v13 = *(unsigned int *)(v11 + 16);
    if (!(_DWORD)v13)
      goto LABEL_18;
    v14 = *(_QWORD **)(v11 + 8);
    v15 = &v14[2 * v13];
    do
    {
      v16 = v13 >> 1;
      v17 = &v14[2 * (v13 >> 1)];
      v19 = *v17;
      v18 = v17 + 2;
      v13 += ~(v13 >> 1);
      if (v19 < v12)
        v14 = v18;
      else
        v13 = v16;
    }
    while (v13);
    if (v14 != v15 && *v14 == v12)
      v20 = v14[1];
    else
LABEL_18:
      v20 = 0;
    v342[0] = v10;
    v342[1] = v20;
    v21 = (_QWORD *)(*(_QWORD *)(v9 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v21)
      goto LABEL_28;
    v22 = *v21;
    v23 = mlir::TypeID::get<mlir::ShapedType>();
    v24 = *(unsigned int *)(v22 + 16);
    if (!(_DWORD)v24)
      goto LABEL_28;
    v25 = *(_QWORD **)(v22 + 8);
    v26 = &v25[2 * v24];
    do
    {
      v27 = v24 >> 1;
      v28 = &v25[2 * (v24 >> 1)];
      v30 = *v28;
      v29 = v28 + 2;
      v24 += ~(v24 >> 1);
      if (v30 < v23)
        v25 = v29;
      else
        v24 = v27;
    }
    while (v24);
    if (v25 != v26 && *v25 == v23)
    {
      v38 = v25[1];
      v340 = v21;
      v341 = v38;
      if (!v10)
        return 0;
    }
    else
    {
LABEL_28:
      v340 = v21;
      v341 = 0;
      if (!v10)
        return 0;
    }
    if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v342))
      return 0;
    ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v342);
    if (v32)
    {
      v33 = 8 * v32;
      while (*ArgAttrsAttr != 0x8000000000000000)
      {
        ++ArgAttrsAttr;
        v33 -= 8;
        if (!v33)
          goto LABEL_34;
      }
      return 0;
    }
LABEL_34:
    if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    {
      v331 = *(_QWORD *)(a2 + 72);
      v34 = *(unsigned int *)(a2 + 68);
    }
    else
    {
      v331 = 0;
      v34 = 0;
    }
    __p = 0;
    v338 = 0;
    v339 = 0;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v340);
    v318 = a2;
    if (v35)
    {
      if (v35 >> 61)
        goto LABEL_425;
      v36 = 8 * v35;
      v37 = (char *)operator new(8 * v35);
      __p = &v37[v338 & 0xFFFFFFFFFFFFFFF8];
      v338 = (unint64_t)__p;
      v339 = &v37[v36];
    }
    if (v34 >= 2)
    {
      v39 = *(_QWORD *)(v331 + 56);
      v347 = v349;
      v348 = 0x400000000;
      matched = mlir::matchConstantWithIntVector<long long>(v39, (uint64_t)&v347);
      if (matched)
      {
        v335 = 0;
        v336 = 0;
        v334 = &v335;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v340);
        if ((_DWORD)v348)
        {
          v42 = v41;
          v43 = (mlir **)v347;
          v44 = (mlir **)&v347[v348];
          do
          {
            NegativeAxis = mlir::getNegativeAxis(*v43, v42);
            v47 = NegativeAxis;
            v48 = v335;
            v49 = &v335;
            v50 = &v335;
            if (v335)
            {
              while (1)
              {
                while (1)
                {
                  v50 = (uint64_t **)v48;
                  v51 = v48[4];
                  if (NegativeAxis >= v51)
                    break;
                  v48 = *v50;
                  v49 = v50;
                  if (!*v50)
                    goto LABEL_56;
                }
                if (v51 >= NegativeAxis)
                  break;
                v48 = v50[1];
                if (!v48)
                {
                  v49 = v50 + 1;
                  goto LABEL_56;
                }
              }
            }
            else
            {
LABEL_56:
              v52 = (uint64_t *)operator new(0x28uLL);
              v52[4] = v47;
              *v52 = 0;
              v52[1] = 0;
              v52[2] = (uint64_t)v50;
              *v49 = v52;
              if (*v334)
              {
                v334 = (uint64_t **)*v334;
                v45 = *v49;
              }
              else
              {
                v45 = v52;
              }
              std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v335, v45);
              ++v336;
            }
            ++v43;
          }
          while (v43 != v44);
        }
        if (v336)
        {
          if (v336 >> 61)
            goto LABEL_425;
          v76 = v336;
          v77 = operator new(8 * v336);
          v78 = (char *)&v77[v76];
          bzero(v77, v76 * 8);
        }
        else
        {
          v78 = 0;
          v77 = 0;
        }
        if (__p)
        {
          v338 = (unint64_t)__p;
          operator delete(__p);
        }
        __p = v77;
        v338 = (unint64_t)v78;
        v339 = v78;
        v79 = (uint64_t *)v334;
        if (v334 != &v335)
        {
          do
          {
            *v77 = v79[4];
            v82 = (uint64_t *)v79[1];
            if (v82)
            {
              do
              {
                v83 = (uint64_t **)v82;
                v82 = (uint64_t *)*v82;
              }
              while (v82);
            }
            else
            {
              do
              {
                v83 = (uint64_t **)v79[2];
                v84 = *v83 == v79;
                v79 = (uint64_t *)v83;
              }
              while (!v84);
            }
            ++v77;
            v79 = (uint64_t *)v83;
          }
          while (v83 != &v335);
        }
        std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v334, v335);
      }
      if (v347 != v349)
        free(v347);
      if (!matched)
        goto LABEL_420;
      goto LABEL_100;
    }
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v340);
    if (!v53)
    {
LABEL_100:
      v80 = __p;
      if ((void *)v338 == __p)
      {
        v347 = *(uint64_t **)(*(_QWORD *)(v318 + 72) + 24);
        v7 = 1;
        mlir::ValueRange::ValueRange(v346, (uint64_t)&v347, 1uLL);
        (*(void (**)(uint64_t, uint64_t, unint64_t, unint64_t))(*(_QWORD *)v317 + 24))(v317, v318, v346[0], v346[1]);
        goto LABEL_422;
      }
      v81 = v318;
      if (*(uint64_t *)__p > -5)
      {
        v7 = 1;
        goto LABEL_423;
      }
      v333 = *(uint64_t **)(v331 + 24);
      v319 = (mlir::Builder *)(v317 + 8);
LABEL_113:
      if (__p != (void *)v338)
      {
        v85 = v333;
        v343 = v333;
        v347 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(v333[1] & 0xFFFFFFFFFFFFFFF8));
        v348 = v86;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v347);
        v88 = v87;
        v90 = (char *)__p;
        v89 = (char *)v338;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v347);
        if (v91)
        {
          if (v91 >> 61)
            goto LABEL_425;
          v92 = v89;
          v93 = 8 * v91;
          v94 = (char *)operator new(8 * v91);
          v332 = &v94[v93];
          v89 = v92;
        }
        else
        {
          v332 = 0;
          v94 = 0;
        }
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v347);
        v322 = v88;
        if (v95)
        {
          if (v95 >> 61)
            goto LABEL_425;
          v96 = 8 * v95;
          v97 = (char *)operator new(8 * v95);
          v325 = &v97[v96];
          v98 = v89 - 8;
          v99 = *((_QWORD *)v89 - 1);
          if (v99 != -1)
          {
            v100 = v97;
            v101 = v97;
            v88 = v322;
LABEL_130:
            v334 = (uint64_t **)llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(v85[1] & 0xFFFFFFFFFFFFFFF8));
            v335 = v102;
            v103 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v334);
            PositiveAxis = mlir::getPositiveAxis(-1, v88);
            v105 = PositiveAxis;
            v321 = v90;
            v326 = v100;
            if (v94 >= v332)
            {
              v107 = (v332 - v94) >> 2;
              if (v107 <= 1)
                v107 = 1;
              v108 = 0x1FFFFFFFFFFFFFFFLL;
              if ((unint64_t)(v332 - v94) < 0x7FFFFFFFFFFFFFF8)
                v108 = v107;
              if (v108 >> 61)
                goto LABEL_426;
              v109 = 8 * v108;
              v110 = (char *)operator new(8 * v108);
              *(_QWORD *)v110 = *(_QWORD *)(v103 + 8 * v105);
              v106 = v110 + 8;
              v332 = &v110[v109];
              if (v94)
                operator delete(v94);
              v94 = v110;
              v90 = v321;
            }
            else
            {
              *(_QWORD *)v94 = *(_QWORD *)(v103 + 8 * PositiveAxis);
              v106 = v94 + 8;
            }
            v111 = v99 == -2;
            if (v88 < 2)
            {
              v112 = 1;
LABEL_142:
              if (v106 < v332)
              {
                *(_QWORD *)v106 = v112;
                v113 = v106 + 8;
                v114 = v326;
                if (!v111)
                {
LABEL_283:
                  if (v94 != v113)
                  {
                    v207 = v113 - 8;
                    if (v113 - 8 > v94)
                    {
                      v208 = v94 + 8;
                      do
                      {
                        v209 = *((_QWORD *)v208 - 1);
                        *((_QWORD *)v208 - 1) = *(_QWORD *)v207;
                        *(_QWORD *)v207 = v209;
                        v207 -= 8;
                        v210 = v208 >= v207;
                        v208 += 8;
                      }
                      while (!v210);
                    }
                  }
                  if (v101 != v114)
                  {
                    v211 = v114 - 8;
                    if (v114 - 8 > v101)
                    {
                      v212 = v101 + 8;
                      do
                      {
                        v213 = *((_QWORD *)v212 - 1);
                        *((_QWORD *)v212 - 1) = *(_QWORD *)v211;
                        *(_QWORD *)v211 = v213;
                        v211 -= 8;
                        v210 = v212 >= v211;
                        v212 += 8;
                      }
                      while (!v210);
                    }
                  }
                  Loc = mlir::Value::getLoc((mlir::Value *)&v343);
                  v334 = (uint64_t **)v333;
                  v345 = (mlir::GenericProgramPoint *)((v113 - v94) >> 3);
                  IntegerType = mlir::Builder::getIntegerType(v319, 0x40u, 1);
                  v216 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v345, 1, IntegerType, 0);
                  v217 = v216;
                  if (!v216)
                    goto LABEL_302;
                  v218 = *v216;
                  v219 = mlir::TypeID::get<mlir::ShapedType>();
                  v220 = *(unsigned int *)(v218 + 16);
                  if (!(_DWORD)v220)
                    goto LABEL_302;
                  v221 = *(_QWORD **)(v218 + 8);
                  v222 = &v221[2 * v220];
                  do
                  {
                    v223 = v220 >> 1;
                    v224 = &v221[2 * (v220 >> 1)];
                    v226 = *v224;
                    v225 = v224 + 2;
                    v220 += ~(v220 >> 1);
                    if (v226 < v219)
                      v221 = v225;
                    else
                      v220 = v223;
                  }
                  while (v220);
                  if (v221 != v222 && *v221 == v219)
                    v227 = v221[1];
                  else
LABEL_302:
                    v227 = 0;
                  v344 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v217, v227, v94, v113 - v94, 8, 1, 1);
                  v345 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v319, Loc, &v344);
                  v333 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::UnitAttr **)v319, Loc, (uint64_t *)&v334, &v345)- 16);
                  std::vector<long long>::__assign_with_size[abi:nn180100]<long long *,long long *>(&__p, v101, v114, (v114 - v101) >> 3);
                  if (v101)
                    operator delete(v101);
                  if (v94)
                    operator delete(v94);
                  v343 = v333;
                  v347 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(v333[1] & 0xFFFFFFFFFFFFFFF8));
                  v348 = v228;
                  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v347);
                  if (v229)
                  {
                    if (v229 >> 61)
                      goto LABEL_425;
                    v230 = 8 * v229;
                    v231 = (char *)operator new(8 * v229);
                    v232 = &v231[v230];
                  }
                  else
                  {
                    v231 = 0;
                    v232 = 0;
                  }
                  v233 = ((uint64_t)(v338 - (_QWORD)__p) >> 3) - 1;
                  if ((uint64_t)(v338 - (_QWORD)__p) < 1)
                  {
                    v236 = ((uint64_t)(v338 - (_QWORD)__p) >> 3) - 1;
                    v234 = (uint64_t *)v231;
                    goto LABEL_359;
                  }
                  v234 = (uint64_t *)v231;
                  while (1)
                  {
                    v237 = *((_QWORD *)__p + v233);
                    if (v237 < -4)
                    {
                      v235 = v231;
                      v236 = v233;
LABEL_346:
                      if (v235 != (char *)v234)
                      {
                        v253 = mlir::Value::getLoc((mlir::Value *)&v343);
                        v334 = (uint64_t **)v343;
                        v345 = (mlir::GenericProgramPoint *)((v235 - (char *)v234) >> 3);
                        v254 = mlir::Builder::getIntegerType(v319, 0x40u, 1);
                        v255 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v345, 1, v254, 0);
                        v256 = v255;
                        if (!v255)
                          goto LABEL_356;
                        v257 = *v255;
                        v258 = mlir::TypeID::get<mlir::ShapedType>();
                        v259 = *(unsigned int *)(v257 + 16);
                        if (!(_DWORD)v259)
                          goto LABEL_356;
                        v260 = *(_QWORD **)(v257 + 8);
                        v261 = &v260[2 * v259];
                        do
                        {
                          v262 = v259 >> 1;
                          v263 = &v260[2 * (v259 >> 1)];
                          v265 = *v263;
                          v264 = v263 + 2;
                          v259 += ~(v259 >> 1);
                          if (v265 < v258)
                            v260 = v264;
                          else
                            v259 = v262;
                        }
                        while (v259);
                        if (v260 != v261 && *v260 == v258)
                          v266 = v260[1];
                        else
LABEL_356:
                          v266 = 0;
                        v267 = 1;
                        v344 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v256, v266, v234, v235 - (char *)v234, 8, 1, 1);
                        v345 = (mlir::GenericProgramPoint *)((char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v319, v253, &v344)- 16);
                        LOBYTE(v344) = 1;
                        v268 = mlir::OpBuilder::create<mlir::mps::ReductionArgMaxOp,mlir::Value &,mlir::Value &,BOOL>((mlir::UnitAttr **)v319, v253, (uint64_t *)&v334, (uint64_t *)&v345, (unsigned __int8 *)&v344);
                        if (mlir::mps::inferTypes(v268, v269))
                        {
                          v333 = (uint64_t *)((char *)v268 - 16);
                          goto LABEL_359;
                        }
LABEL_406:
                        if (v234)
                          operator delete(v234);
                        v81 = v318;
                        if ((v267 & 1) == 0)
                          goto LABEL_113;
                        v7 = 0;
LABEL_422:
                        v80 = __p;
                        if (!__p)
                          return v7;
LABEL_423:
                        v338 = (unint64_t)v80;
                        operator delete(v80);
                        return v7;
                      }
LABEL_359:
                      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v347);
                      if (v270)
                      {
                        if (!(v270 >> 61))
                        {
                          v271 = 8 * v270;
                          v272 = (char *)operator new(8 * v270);
                          v273 = &v272[v271];
                          v274 = v272;
                          if ((v236 & 0x8000000000000000) == 0)
                            goto LABEL_367;
LABEL_403:
                          std::vector<long long>::__assign_with_size[abi:nn180100]<long long *,long long *>(&__p, v274, v272, (v272 - v274) >> 3);
                          if (v274)
                            operator delete(v274);
                          v267 = 0;
                          goto LABEL_406;
                        }
LABEL_425:
                        abort();
                      }
                      v272 = 0;
                      v273 = 0;
                      v274 = 0;
                      if (v236 < 0)
                        goto LABEL_403;
LABEL_367:
                      while (2)
                      {
                        v275 = *((_QWORD *)__p + v236);
                        if (v272 < v273)
                        {
                          *(_QWORD *)v272 = v275;
                          v272 += 8;
                        }
                        else
                        {
                          v276 = (v272 - v274) >> 3;
                          v277 = v276 + 1;
                          if ((unint64_t)(v276 + 1) >> 61)
                            goto LABEL_425;
                          if ((v273 - v274) >> 2 > v277)
                            v277 = (v273 - v274) >> 2;
                          if ((unint64_t)(v273 - v274) >= 0x7FFFFFFFFFFFFFF8)
                            v278 = 0x1FFFFFFFFFFFFFFFLL;
                          else
                            v278 = v277;
                          if (v278)
                          {
                            if (v278 >> 61)
                              goto LABEL_426;
                            v279 = operator new(8 * v278);
                          }
                          else
                          {
                            v279 = 0;
                          }
                          v280 = &v279[8 * v276];
                          *(_QWORD *)v280 = v275;
                          v281 = v280 + 8;
                          if (v272 != v274)
                          {
                            v282 = v272 - v274 - 8;
                            if (v282 < 0x168)
                            {
                              v283 = v272;
                              goto LABEL_381;
                            }
                            v285 = (v272 - 8 - v274) & 0xFFFFFFFFFFFFFFF8;
                            if (&v279[v272 - v274 - 8 - v285] > &v279[v272 - v274 - 8])
                            {
                              v283 = v272;
                              goto LABEL_381;
                            }
                            if (&v272[-v285 - 8] > v272 - 8)
                            {
                              v283 = v272;
                              goto LABEL_381;
                            }
                            if ((unint64_t)(v274 - v279) < 0x20)
                            {
                              v283 = v272;
                              goto LABEL_381;
                            }
                            v286 = (v282 >> 3) + 1;
                            v287 = 8 * (v286 & 0x3FFFFFFFFFFFFFFCLL);
                            v283 = &v272[-v287];
                            v280 -= v287;
                            v288 = &v279[8 * v276 - 16];
                            v289 = v272 - 16;
                            v290 = v286 & 0x3FFFFFFFFFFFFFFCLL;
                            do
                            {
                              v291 = *(_OWORD *)v289;
                              *(v288 - 1) = *((_OWORD *)v289 - 1);
                              *v288 = v291;
                              v288 -= 2;
                              v289 -= 32;
                              v290 -= 4;
                            }
                            while (v290);
                            if (v286 != (v286 & 0x3FFFFFFFFFFFFFFCLL))
                            {
                              do
                              {
LABEL_381:
                                v284 = *((_QWORD *)v283 - 1);
                                v283 -= 8;
                                *((_QWORD *)v280 - 1) = v284;
                                v280 -= 8;
                              }
                              while (v283 != v274);
                            }
                          }
                          v273 = &v279[8 * v278];
                          if (v274)
                            operator delete(v274);
                          v274 = v280;
                          v272 = v281;
                        }
                        v293 = v236-- <= 0;
                        if (v293)
                        {
                          v292 = v272 - 8;
                          v293 = v274 != v272 && v292 > v274;
                          if (v293)
                          {
                            v294 = v274 + 8;
                            do
                            {
                              v295 = *((_QWORD *)v294 - 1);
                              *((_QWORD *)v294 - 1) = *(_QWORD *)v292;
                              *(_QWORD *)v292 = v295;
                              v292 -= 8;
                              v210 = v294 >= v292;
                              v294 += 8;
                            }
                            while (!v210);
                          }
                          goto LABEL_403;
                        }
                        continue;
                      }
                    }
                    if (v231 >= v232)
                      break;
                    *(_QWORD *)v231 = v237;
                    v235 = v231 + 8;
LABEL_314:
                    v236 = v233 - 1;
                    v231 = v235;
                    v293 = v233-- <= 0;
                    if (v293)
                      goto LABEL_346;
                  }
                  v238 = (v231 - (char *)v234) >> 3;
                  v239 = v238 + 1;
                  if ((unint64_t)(v238 + 1) >> 61)
                    goto LABEL_425;
                  if ((v232 - (char *)v234) >> 2 > v239)
                    v239 = (v232 - (char *)v234) >> 2;
                  if ((unint64_t)(v232 - (char *)v234) >= 0x7FFFFFFFFFFFFFF8)
                    v240 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v240 = v239;
                  if (v240)
                  {
                    if (v240 >> 61)
                      goto LABEL_426;
                    v241 = operator new(8 * v240);
                  }
                  else
                  {
                    v241 = 0;
                  }
                  v242 = (uint64_t *)&v241[8 * v238];
                  *v242 = v237;
                  v235 = (char *)(v242 + 1);
                  if (v231 != (char *)v234)
                  {
                    v243 = v231 - (char *)v234 - 8;
                    if (v243 >= 0x168)
                    {
                      v246 = (v231 - 8 - (char *)v234) & 0xFFFFFFFFFFFFFFF8;
                      if (&v241[v231 - (char *)v234 - 8 - v246] > &v241[v231 - (char *)v234 - 8])
                      {
                        v244 = (uint64_t *)v231;
                      }
                      else if (&v231[-v246 - 8] > v231 - 8)
                      {
                        v244 = (uint64_t *)v231;
                      }
                      else if ((unint64_t)((char *)v234 - v241) >= 0x20)
                      {
                        v247 = (v243 >> 3) + 1;
                        v248 = 8 * (v247 & 0x3FFFFFFFFFFFFFFCLL);
                        v244 = (uint64_t *)&v231[-v248];
                        v242 = (uint64_t *)((char *)v242 - v248);
                        v249 = &v241[8 * v238 - 16];
                        v250 = (__int128 *)(v231 - 16);
                        v251 = v247 & 0x3FFFFFFFFFFFFFFCLL;
                        do
                        {
                          v252 = *v250;
                          *(v249 - 1) = *(v250 - 1);
                          *v249 = v252;
                          v249 -= 2;
                          v250 -= 2;
                          v251 -= 4;
                        }
                        while (v251);
                        if (v247 == (v247 & 0x3FFFFFFFFFFFFFFCLL))
                          goto LABEL_331;
                      }
                      else
                      {
                        v244 = (uint64_t *)v231;
                      }
                    }
                    else
                    {
                      v244 = (uint64_t *)v231;
                    }
                    do
                    {
                      v245 = *--v244;
                      *--v242 = v245;
                    }
                    while (v244 != v234);
                  }
LABEL_331:
                  v232 = &v241[8 * v240];
                  if (v234)
                    operator delete(v234);
                  v234 = v242;
                  goto LABEL_314;
                }
LABEL_260:
                v191 = mlir::getNegativeAxis(0, (v113 - v94) >> 3);
                v192 = v191;
                if (v114 < v325)
                {
                  *(_QWORD *)v114 = v191;
                  v114 += 8;
                  goto LABEL_283;
                }
                v193 = v114 - v101;
                v194 = v101;
                v195 = (v114 - v101) >> 3;
                v196 = v195 + 1;
                if ((unint64_t)(v195 + 1) >> 61)
                  goto LABEL_425;
                v197 = v114;
                v198 = v194;
                v199 = v325 - v194;
                v200 = (v325 - v194) >> 2;
                if (v200 > v196)
                  v196 = v200;
                if (v199 >= 0x7FFFFFFFFFFFFFF8)
                  v196 = 0x1FFFFFFFFFFFFFFFLL;
                if (v196)
                {
                  if (v196 >> 61)
                    goto LABEL_426;
                  v201 = (char *)operator new(8 * v196);
                }
                else
                {
                  v201 = 0;
                }
                v202 = &v201[8 * v195];
                *(_QWORD *)v202 = v192;
                v114 = v202 + 8;
                if (v197 == v198)
                {
                  v205 = v198;
                }
                else
                {
                  v203 = v197 - v198 - 8;
                  if (v203 >= 0x58 && (unint64_t)(v197 - v201 - v193) >= 0x20)
                  {
                    v302 = (v203 >> 3) + 1;
                    v303 = 8 * (v302 & 0x3FFFFFFFFFFFFFFCLL);
                    v204 = &v197[-v303];
                    v202 -= v303;
                    v304 = &v201[8 * v195 - 16];
                    v305 = v197 - 16;
                    v306 = v302 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      v307 = *(_OWORD *)v305;
                      *((_OWORD *)v304 - 1) = *((_OWORD *)v305 - 1);
                      *(_OWORD *)v304 = v307;
                      v304 -= 32;
                      v305 -= 32;
                      v306 -= 4;
                    }
                    while (v306);
                    v205 = v198;
                    if (v302 == (v302 & 0x3FFFFFFFFFFFFFFCLL))
                      goto LABEL_280;
                  }
                  else
                  {
                    v204 = v197;
                    v205 = v198;
                  }
                  do
                  {
                    v206 = *((_QWORD *)v204 - 1);
                    v204 -= 8;
                    *((_QWORD *)v202 - 1) = v206;
                    v202 -= 8;
                  }
                  while (v204 != v205);
                }
LABEL_280:
                if (v205)
                  operator delete(v205);
                v101 = v202;
                goto LABEL_283;
              }
              v183 = v101;
              v184 = (v106 - v94) >> 3;
              v185 = v184 + 1;
              if ((unint64_t)(v184 + 1) >> 61)
                goto LABEL_425;
              if ((v332 - v94) >> 2 > v185)
                v185 = (v332 - v94) >> 2;
              if ((unint64_t)(v332 - v94) >= 0x7FFFFFFFFFFFFFF8)
                v185 = 0x1FFFFFFFFFFFFFFFLL;
              if (v185)
              {
                if (v185 >> 61)
                  goto LABEL_426;
                v186 = operator new(8 * v185);
              }
              else
              {
                v186 = 0;
              }
              v187 = (uint64_t *)&v186[8 * v184];
              *v187 = v112;
              v113 = (char *)(v187 + 1);
              if (v106 == v94)
              {
                v101 = v183;
                v114 = v326;
                if (!v94)
                {
LABEL_259:
                  v94 = (char *)v187;
                  if (!v111)
                    goto LABEL_283;
                  goto LABEL_260;
                }
LABEL_258:
                operator delete(v94);
                goto LABEL_259;
              }
              v188 = v106 - v94 - 8;
              if (v188 >= 0x58 && (unint64_t)(v94 - v186) >= 0x20)
              {
                v296 = (v188 >> 3) + 1;
                v297 = 8 * (v296 & 0x3FFFFFFFFFFFFFFCLL);
                v189 = &v106[-v297];
                v187 = (uint64_t *)((char *)v187 - v297);
                v298 = &v186[8 * v184 - 16];
                v299 = v106 - 16;
                v300 = v296 & 0x3FFFFFFFFFFFFFFCLL;
                v114 = v326;
                do
                {
                  v301 = *(_OWORD *)v299;
                  *(v298 - 1) = *((_OWORD *)v299 - 1);
                  *v298 = v301;
                  v298 -= 2;
                  v299 -= 32;
                  v300 -= 4;
                }
                while (v300);
                v101 = v183;
                if (v296 == (v296 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_257:
                  if (!v94)
                    goto LABEL_259;
                  goto LABEL_258;
                }
              }
              else
              {
                v189 = v106;
                v101 = v183;
                v114 = v326;
              }
              do
              {
                v190 = *((_QWORD *)v189 - 1);
                v189 -= 8;
                *--v187 = v190;
              }
              while (v189 != v94);
              goto LABEL_257;
            }
            v115 = v99;
            v329 = v103;
            v330 = -v88;
            v116 = -2;
            v112 = 1;
            while (1)
            {
              if (!v111)
              {
                if (v115 == v116)
                {
                  v119 = v332;
                  if (v106 < v332)
                  {
                    *(_QWORD *)v106 = v112;
                    v120 = v106 + 8;
LABEL_184:
                    v332 = v119;
                    v112 = *(_QWORD *)(v329 + 8 * mlir::getPositiveAxis(v115, v88));
                    if (v89 - 8 == v90)
                    {
                      v115 = 0x7FFFFFFFFFFFFFFFLL;
                      v111 = 1;
                      v106 = v120;
                      v89 = v90;
                    }
                    else
                    {
                      v115 = *((_QWORD *)v89 - 2);
                      v111 = 1;
                      v106 = v120;
                      v89 -= 8;
                    }
                    v103 = v329;
                    goto LABEL_146;
                  }
                  v328 = v115;
                  v124 = (v106 - v94) >> 3;
                  v125 = v124 + 1;
                  if ((unint64_t)(v124 + 1) >> 61)
                    goto LABEL_425;
                  if ((v332 - v94) >> 2 > v125)
                    v125 = (v332 - v94) >> 2;
                  if ((unint64_t)(v332 - v94) >= 0x7FFFFFFFFFFFFFF8)
                    v126 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v126 = v125;
                  v323 = v89;
                  if (v126)
                  {
                    if (v126 >> 61)
                      goto LABEL_426;
                    v127 = operator new(8 * v126);
                  }
                  else
                  {
                    v127 = 0;
                  }
                  v133 = (uint64_t *)&v127[8 * v124];
                  *v133 = v112;
                  v120 = (char *)(v133 + 1);
                  if (v106 != v94)
                  {
                    v134 = v106 - v94 - 8;
                    if (v134 < 0x168
                      || (v162 = (v106 - 8 - v94) & 0xFFFFFFFFFFFFFFF8,
                          &v127[v106 - v94 - 8 - v162] > &v127[v106 - v94 - 8])
                      || &v106[-v162 - 8] > v106 - 8
                      || (unint64_t)(v94 - v127) < 0x20)
                    {
                      v135 = v106;
                      v90 = v321;
                      v88 = v322;
                    }
                    else
                    {
                      v163 = (v134 >> 3) + 1;
                      v164 = 8 * (v163 & 0x3FFFFFFFFFFFFFFCLL);
                      v135 = &v106[-v164];
                      v133 = (uint64_t *)((char *)v133 - v164);
                      v165 = &v127[8 * v124 - 16];
                      v166 = v106 - 16;
                      v167 = v163 & 0x3FFFFFFFFFFFFFFCLL;
                      v88 = v322;
                      do
                      {
                        v168 = *(_OWORD *)v166;
                        *(v165 - 1) = *((_OWORD *)v166 - 1);
                        *v165 = v168;
                        v165 -= 2;
                        v166 -= 32;
                        v167 -= 4;
                      }
                      while (v167);
                      v90 = v321;
                      if (v163 == (v163 & 0x3FFFFFFFFFFFFFFCLL))
                      {
LABEL_181:
                        v119 = &v127[8 * v126];
                        if (v94)
                          goto LABEL_182;
                        goto LABEL_183;
                      }
                    }
                    do
                    {
                      v136 = *((_QWORD *)v135 - 1);
                      v135 -= 8;
                      *--v133 = v136;
                    }
                    while (v135 != v94);
                    goto LABEL_181;
                  }
                  v90 = v321;
                  v88 = v322;
                  v119 = &v127[8 * v126];
                  if (v94)
LABEL_182:
                    operator delete(v94);
LABEL_183:
                  v94 = (char *)v133;
                  v89 = v323;
                  v115 = v328;
                  goto LABEL_184;
                }
                v117 = v115;
                v118 = mlir::getPositiveAxis(v116, v88);
                v115 = v117;
                v111 = 0;
                v112 *= *(_QWORD *)(v103 + 8 * v118);
                goto LABEL_146;
              }
              if (v115 == v116)
              {
                v112 *= *(_QWORD *)(v103 + 8 * mlir::getPositiveAxis(v115, v88));
                if (v89 - 8 == v90)
                {
                  v115 = 0x7FFFFFFFFFFFFFFFLL;
                  v111 = 1;
                  v89 = v90;
                }
                else
                {
                  v115 = *((_QWORD *)v89 - 2);
                  v111 = 1;
                  v89 -= 8;
                }
                goto LABEL_146;
              }
              v121 = v332;
              v327 = v115;
              if (v106 >= v332)
                break;
              *(_QWORD *)v106 = v112;
              v122 = v106 + 8;
              v123 = (uint64_t *)v326;
LABEL_196:
              v112 = *(_QWORD *)(v103 + 8 * mlir::getPositiveAxis(v116, v88));
              v142 = mlir::getNegativeAxis(0, (v122 - v94) >> 3);
              v143 = v122;
              v144 = v142;
              v332 = v121;
              if (v123 >= (uint64_t *)v325)
              {
                v320 = v143;
                v145 = v101;
                v146 = (char *)v123 - v101;
                v147 = v146 >> 3;
                v148 = (v146 >> 3) + 1;
                if (v148 >> 61)
                  goto LABEL_425;
                v149 = v123;
                v150 = (uint64_t *)v145;
                v151 = v325 - v145;
                v152 = (v325 - v145) >> 2;
                if (v152 > v148)
                  v148 = v152;
                if (v151 >= 0x7FFFFFFFFFFFFFF8)
                  v153 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v153 = v148;
                v324 = v89;
                if (v153)
                {
                  if (v153 >> 61)
                    goto LABEL_426;
                  v154 = (char *)operator new(8 * v153);
                }
                else
                {
                  v154 = 0;
                }
                v155 = &v154[8 * v147];
                *(_QWORD *)v155 = v144;
                v156 = v155 + 8;
                if (v149 == v150)
                {
                  v90 = v321;
                  v88 = v322;
                  v103 = v329;
                  goto LABEL_218;
                }
                v157 = (char *)v149 - (char *)v150 - 8;
                v90 = v321;
                if (v157 < 0x168
                  || (v176 = ((char *)(v149 - 1) - (char *)v150) & 0xFFFFFFFFFFFFFFF8,
                      &v154[v146 - 8 - v176] > &v154[v146 - 8])
                  || (uint64_t *)((char *)v149 - v176 - 8) > v149 - 1
                  || (unint64_t)((char *)v149 - v154 - v146) < 0x20)
                {
                  v158 = v149;
                  v88 = v322;
                  v103 = v329;
                }
                else
                {
                  v177 = (v157 >> 3) + 1;
                  v178 = 8 * (v177 & 0x3FFFFFFFFFFFFFFCLL);
                  v158 = &v149[v178 / 0xFFFFFFFFFFFFFFF8];
                  v155 -= v178;
                  v179 = &v154[8 * v147 - 16];
                  v180 = v149 - 2;
                  v181 = v177 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    v182 = *(_OWORD *)v180;
                    *((_OWORD *)v179 - 1) = *((_OWORD *)v180 - 1);
                    *(_OWORD *)v179 = v182;
                    v179 -= 32;
                    v180 -= 4;
                    v181 -= 4;
                  }
                  while (v181);
                  v88 = v322;
                  v103 = v329;
                  if (v177 == (v177 & 0x3FFFFFFFFFFFFFFCLL))
                  {
LABEL_218:
                    v325 = &v154[8 * v153];
                    if (v150)
                    {
                      v160 = v150;
                      v161 = v156;
                      operator delete(v160);
                      v111 = 0;
                      v101 = v155;
                      v326 = v161;
                    }
                    else
                    {
                      v111 = 0;
                      v101 = v155;
                      v326 = v156;
                    }
                    v106 = v320;
                    v89 = v324;
                    v115 = v327;
                    goto LABEL_146;
                  }
                }
                do
                {
                  v159 = *--v158;
                  *((_QWORD *)v155 - 1) = v159;
                  v155 -= 8;
                }
                while (v158 != v150);
                goto LABEL_218;
              }
              v111 = 0;
              *v123 = v142;
              v326 = (char *)(v123 + 1);
              v106 = v143;
              v90 = v321;
              v115 = v327;
LABEL_146:
              v293 = v116-- <= v330;
              if (v293)
                goto LABEL_142;
            }
            v128 = (v106 - v94) >> 3;
            v129 = v128 + 1;
            if ((unint64_t)(v128 + 1) >> 61)
              goto LABEL_425;
            if ((v332 - v94) >> 2 > v129)
              v129 = (v332 - v94) >> 2;
            if ((unint64_t)(v332 - v94) >= 0x7FFFFFFFFFFFFFF8)
              v130 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v130 = v129;
            if (v130)
            {
              if (v130 >> 61)
                goto LABEL_426;
              v131 = v89;
              v132 = operator new(8 * v130);
            }
            else
            {
              v131 = v89;
              v132 = 0;
            }
            v137 = (uint64_t *)&v132[8 * v128];
            *v137 = v112;
            v138 = (char *)(v137 + 1);
            if (v106 == v94)
            {
              v88 = v322;
              v123 = (uint64_t *)v326;
              v122 = (char *)(v137 + 1);
              v121 = &v132[8 * v130];
              if (!v94)
                goto LABEL_195;
              goto LABEL_194;
            }
            v139 = v106 - v94 - 8;
            if (v139 < 0x168
              || (v169 = (v106 - 8 - v94) & 0xFFFFFFFFFFFFFFF8, &v132[v106 - v94 - 8 - v169] > &v132[v106 - v94 - 8])
              || &v106[-v169 - 8] > v106 - 8
              || (unint64_t)(v94 - v132) < 0x20)
            {
              v140 = v106;
              v88 = v322;
              v123 = (uint64_t *)v326;
              v122 = (char *)(v137 + 1);
            }
            else
            {
              v170 = (v139 >> 3) + 1;
              v171 = 8 * (v170 & 0x3FFFFFFFFFFFFFFCLL);
              v140 = &v106[-v171];
              v137 = (uint64_t *)((char *)v137 - v171);
              v172 = &v132[8 * v128 - 16];
              v173 = v106 - 16;
              v174 = v170 & 0x3FFFFFFFFFFFFFFCLL;
              v88 = v322;
              do
              {
                v175 = *(_OWORD *)v173;
                *(v172 - 1) = *((_OWORD *)v173 - 1);
                *v172 = v175;
                v172 -= 2;
                v173 -= 32;
                v174 -= 4;
              }
              while (v174);
              v123 = (uint64_t *)v326;
              v122 = v138;
              if (v170 == (v170 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_193:
                v121 = &v132[8 * v130];
                if (!v94)
                {
LABEL_195:
                  v94 = (char *)v137;
                  v89 = v131;
                  v103 = v329;
                  goto LABEL_196;
                }
LABEL_194:
                operator delete(v94);
                goto LABEL_195;
              }
            }
            do
            {
              v141 = *((_QWORD *)v140 - 1);
              v140 -= 8;
              *--v137 = v141;
            }
            while (v140 != v94);
            goto LABEL_193;
          }
          v88 = v322;
        }
        else
        {
          v98 = v89 - 8;
          v99 = *((_QWORD *)v89 - 1);
          if (v99 != -1)
          {
            v101 = 0;
            v100 = 0;
            v325 = 0;
            goto LABEL_130;
          }
          v97 = (char *)operator new(8uLL);
          v325 = v97 + 8;
        }
        *(_QWORD *)v97 = -1;
        v100 = v97 + 8;
        if (v98 == v90)
        {
          v99 = 0x7FFFFFFFFFFFFFFFLL;
          v89 = v90;
        }
        else
        {
          v99 = *((_QWORD *)v89 - 2);
          v89 = v98;
        }
        v101 = v97;
        goto LABEL_130;
      }
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v342);
      v347 = v308;
      v309 = mlir::Builder::getIntegerType(v319, 0x40u, 1);
      v334 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)&v347, 1, v309, 0);
      v310 = (_BYTE *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v342);
      v311 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v342);
      llvm::SmallVector<long long,4u>::SmallVector<long long const*,void>(&v347, v310, (_BYTE *)(v311 + 8 * v312));
      v313 = *(_QWORD *)(v81 + 24);
      v314 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v334);
      v344 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v314, v315, v347, 8 * v348, 8, 1, 1);
      v345 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>(v319, v313, &v344);
      v316 = mlir::OpBuilder::create<mlir::mps::ReshapeOp,mlir::Value &,mlir::mps::ConstantOp &>((mlir::UnitAttr **)v319, *(_QWORD *)(v81 + 24), (uint64_t *)&v333, &v345);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(_QWORD *)v317 + 32))(v317, v81, v316);
      if (v347 != v349)
        free(v347);
LABEL_420:
      v7 = 1;
      goto LABEL_422;
    }
    v54 = v53;
    v55 = (char *)v338;
    while (1)
    {
      v57 = -v54;
      if (v55 >= v339)
        break;
      *(_QWORD *)v55 = v57;
      v56 = v55 + 8;
LABEL_61:
      v338 = (unint64_t)v56;
      v55 = v56;
      if (!(_DWORD)--v54)
        goto LABEL_100;
    }
    v58 = (char *)__p;
    v59 = v55 - (_BYTE *)__p;
    v60 = (v55 - (_BYTE *)__p) >> 3;
    v61 = v60 + 1;
    if ((unint64_t)(v60 + 1) >> 61)
      goto LABEL_425;
    v62 = v339 - (_BYTE *)__p;
    if ((v339 - (_BYTE *)__p) >> 2 > v61)
      v61 = v62 >> 2;
    if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8)
      v63 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v63 = v61;
    if (v63)
    {
      if (v63 >> 61)
LABEL_426:
        std::__throw_bad_array_new_length[abi:nn180100]();
      v64 = operator new(8 * v63);
    }
    else
    {
      v64 = 0;
    }
    v65 = &v64[8 * v60];
    *(_QWORD *)v65 = v57;
    v56 = v65 + 8;
    if (v55 == v58)
      goto LABEL_77;
    v66 = v55 - v58 - 8;
    if (v66 < 0x168)
    {
      v67 = v55;
      goto LABEL_76;
    }
    v69 = (v55 - 8 - v58) & 0xFFFFFFFFFFFFFFF8;
    if (&v64[v59 - 8 - v69] > &v64[v59 - 8])
    {
      v67 = v55;
    }
    else
    {
      if (&v55[-v69 - 8] <= v55 - 8)
      {
        if ((unint64_t)(v55 - v64 - v59) < 0x20)
        {
          v67 = v55;
          goto LABEL_76;
        }
        v70 = (v66 >> 3) + 1;
        v71 = 8 * (v70 & 0x3FFFFFFFFFFFFFFCLL);
        v67 = &v55[-v71];
        v65 -= v71;
        v72 = &v64[8 * v60 - 16];
        v73 = v55 - 16;
        v74 = v70 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v75 = *(_OWORD *)v73;
          *(v72 - 1) = *((_OWORD *)v73 - 1);
          *v72 = v75;
          v72 -= 2;
          v73 -= 32;
          v74 -= 4;
        }
        while (v74);
        if (v70 != (v70 & 0x3FFFFFFFFFFFFFFCLL))
          goto LABEL_76;
LABEL_77:
        __p = v65;
        v339 = &v64[8 * v63];
        if (v58)
          operator delete(v58);
        goto LABEL_61;
      }
      v67 = v55;
    }
    do
    {
LABEL_76:
      v68 = *((_QWORD *)v67 - 1);
      v67 -= 8;
      *((_QWORD *)v65 - 1) = v68;
      v65 -= 8;
    }
    while (v67 != v58);
    goto LABEL_77;
  }
  return 0;
}

